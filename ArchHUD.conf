name: ArchHud - Archaegeo v1.512 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        WipeDamage = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.512;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"local bR=false;local bS=0;function p(bT)system.print(E..": "..bT)end;local function bU(bV)local D=1;if bV then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bW=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bW<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then b7=r(b7+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bS=bS+1*D*-1;if bS>#bG then bS=1 end;if bS<1 then bS=#bG end else if not bV then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end end;local function bX(bY)local bZ,b_,c0=aR:getPlanetarySystem(0):castIntersections(bv,bY,function(c1)if c1.noAtmosphericDensityAltitude>0 then return c1.radius+c1.noAtmosphericDensityAltitude else return c1.radius+c1.surfaceMaxAltitude*1.5 end end)local c2=b_;if c0~=nil and b_~=nil then c2=math.min(c0,b_)end;if c2~=nil then return bZ,c2 else return nil,nil end end;local function c3(c4,c5,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c4 .."|"..c5 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c4 .."|"..c5 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c4 .."|"..c5 .."|"..soundVolume)end end;local function c6(c7,c8)for i=1,#c8 do c7[#c7+1]=c8[i]end;return c7 end;local function c9(ca)local cb={}local cc={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local cd={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local ce={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cf={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not ca then c6(cb,cc)c6(cb,cd)c6(cb,ce)c6(cb,cf)return cb elseif ca=="boolean"then return cc elseif ca=="handling"then return cd elseif ca=="hud"then return ce elseif ca=="physics"then return cf end end;local function cg(ch,ci,cj,ck,cl)if ck==nil then ck=""end;if cl==nil then cl=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ck,ch,ci,cl,cj)end;local function cm(cn,co)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not co then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cn)K=r(A(cn*100,0)/100,-1,1)bz=nil end;local function cp(cn,co)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not co then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cn)bz=cn end;local function cq(cr,cs)if cr==0 then return d(cs)<1e-09 end;if cs==0 then return d(cr)<1e-09 end;return d(cr-cs)<math.max(d(cr),d(cs))*epsilon end;local function ct(aj,cu)local cv=aj>100000;if cu==nil then cu=1 end;if cv then return A(aj/1000/200,cu).."SU"elseif aj<1000 then return A(aj,cu).."M"else return A(aj/1000,cu).."KM"end end;local function cw()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cp(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cx()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then c3("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then c3("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cy()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;c3("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cx()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cx()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then c3("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cw()end else c3("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cw()end end;if am then HoldAltitude=100000 end else c3("altOff","AH")if IntoOrbit then cx()end;if VertTakeOff then cw()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cz(cA)if cA then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cw()end;if IntoOrbit then cx()end;b0=autoRollPreference;al=false;an=false;af=0 end;local function cB()local function cC(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cy()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c3("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c3("apSpc","AP")if ar~=0 then am=true;cy()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then c3("vtt","AP")cC(SpaceTarget)end else c3("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cx()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cx()end end end else c3("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cy()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cx()else c3("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else c3("apP","AP")am=true;cy()end else c3("apOff","AP")cz(1)end end;local function cD()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then c3("bkOn","B",1)cz()else c3("bkOff","B",1)end end;local function cE()if Reentry then a2="Re-Entry cancelled"c3("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;c3("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cj=ct(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..cj;c3("glide","RE")cp(e(b7))end;AutoTakeoff=false end;local function cF()if antigrav and not ExternalAGG then if by then c3("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c3("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cG(cH)local cI=0;local cJ=0;local cK=0;if cH<60 then cH=e(cH)elseif cH<3600 then cI=e(cH/60)cH=e(cH%60)elseif cH<86400 then cJ=e(cH/3600)cI=e(cH%3600/60)else cK=e(cH/86400)cJ=e(cH%86400/3600)end;if cK>0 then return cK.."d "..cJ.."h "elseif cJ>0 then return cJ.."h "..cI.."m "elseif cI>0 then return cI.."m "..cH.."s"elseif cH>0 then return cH.."s"else return"0s"end end;local function cL(cM)local function cN(cO)for cP,cQ in pairs(cO)do dbHud_1.setStringValue(cQ,h(_G[cQ]))if cM and dbHud_2 then dbHud_2.setStringValue(cQ,h(_G[cQ]))end end end;if dbHud_1 then cN(c)cN(c9())system.print("Saved Variables to Datacore")if cM and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cR()local function cS(cT)return type(cT)=='number'end;local function cU(cT)return type(z(cT))=='number'end;local function cV(cW)return type(cW)=='table'end;local function cX(cY)return type(cY)=='string'end;local function cZ(cQ)return cV(cQ)and cS(cQ.x and cQ.y and cQ.z)end;local function c_(d0)return cV(d0)and cS(d0.latitude and d0.longitude and d0.altitude and d0.id and d0.systemId)end;local d1=math.pi/180;local d2=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d3='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d4(cT)local d5=string.gsub(string.reverse(f('%.4f',cT)),'^0*%.?','')return d5==''and'0'or string.reverse(d5)end;local function d6(d7)if cZ(d7)then return f('{x=%.3f,y=%.3f,z=%.3f}',d7.x,d7.y,d7.z)end;if cV(d7)and not getmetatable(d7)then local d8={}local d9=next(d7)if type(d9)=='nil'or d9==1 then d8=d7 else for cP,cQ in pairs(d7)do local cn=d6(cQ)if type(cP)=='number'then table.insert(d8,f('[%s]=%s',cP,cn))else table.insert(d8,f('%s=%s',cP,cn))end end end;return f('{%s}',table.concat(d8,','))end;if cX(d7)then return f("'%s'",d7:gsub("'",[[\']]))end;return tostring(d7)end;local da={}da.__index=da;da.__tostring=function(d7,db)local dc={}for cP in pairs(d7)do table.insert(dc,cP)end;table.sort(dc)local d8={}for _,cP in ipairs(dc)do local cn=d6(d7[cP])if type(cP)=='number'then table.insert(d8,f('[%s]=%s',cP,cn))else table.insert(d8,f('%s=%s',cP,cn))end end;if db then return f('%s%s',db,table.concat(d8,',\n'..db))end;return f('{%s}',table.concat(d8,','))end;da.__eq=function(dd,de)return dd.systemId==de.systemId and dd.id==de.id and cq(dd.radius,de.radius)and cq(dd.center.x,de.center.x)and cq(dd.center.y,de.center.y)and cq(dd.center.z,de.center.z)and cq(dd.GM,de.GM)end;local function df(dg,dh,di,dj,dk)assert(cU(dg),'Argument 1 (systemId) must be a number:'..type(dg))assert(cU(dh),'Argument 2 (id) must be a number:'..type(dh))assert(cU(di),'Argument 3 (radius) must be a number:'..type(di))assert(cV(dj),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dj))assert(cU(dk),'Argument 5 (GM) must be a number:'..type(dk))return setmetatable({systemId=z(dg),id=z(dh),radius=z(di),center=vec3(dj),GM=z(dk)},da)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,d4(p.latitude*d2),d4(p.longitude*d2),d4(p.altitude))end;MapPosition.__eq=function(dd,de)return dd.id==de.id and dd.systemId==de.systemId and cq(dd.latitude,de.latitude)and cq(dd.altitude,de.altitude)and(cq(dd.longitude,de.longitude)or cq(dd.latitude,math.pi/2)or cq(dd.latitude,-math.pi/2))end;local function dl(dm,dh,dn,dp,dq)local dg=dm;if cX(dm)and not dp and not dq and not dh and not dn then dg,dh,dn,dp,dq=o(dm,d3)assert(dg,'Argument 1 (position string) is malformed.')else assert(cU(dg),'Argument 1 (systemId) must be a number:'..type(dg))assert(cU(dh),'Argument 2 (id) must be a number:'..type(dh))assert(cU(dn),'Argument 3 (latitude) must be in degrees:'..type(dn))assert(cU(dp),'Argument 4 (longitude) must be in degrees:'..type(dp))assert(cU(dq),'Argument 5 (altitude) must be in meters:'..type(dq))end;dg=z(dg)dh=z(dh)dn=z(dn)dp=z(dp)dq=z(dq)if dh==0 then return setmetatable({latitude=dn,longitude=dp,altitude=dq,id=dh,systemId=dg},MapPosition)end;return setmetatable({latitude=d1*r(dn,-90,90),longitude=d1*(dp%360),altitude=dq,id=dh,systemId=dg},MapPosition)end;local dr={}dr.__index=dr;dr.__tostring=function(d7,db)local ds=db and db..'  'local dt={}local dc={}for cP in pairs(d7)do table.insert(dc,cP)end;table.sort(dc)for _,du in ipairs(dc)do bdy=d7[du]local dv=da.__tostring(bdy,ds)if db then table.insert(dt,f('[%s]={\n%s\n%s}',du,dv,db))else table.insert(dt,f('  [%s]=%s',du,dv))end end;if db then return f('\n%s%s%s',db,table.concat(dt,',\n'..db),db)end;return f('{\n%s\n}',table.concat(dt,',\n'))end;local function dw(dx)local b={}local pid;for _,cQ in pairs(dx)do local dh=cQ.planetarySystemId;if type(dh)~='number'then error('Invalid planetary system ID: '..tostring(dh))elseif pid and dh~=pid then error('Mistringmatch planetary system IDs: '..dh..' and '..pid)end;local dy=cQ.bodyId;if type(dy)~='number'then error('Invalid body ID: '..tostring(dy))elseif b[dy]then error('Duplicate body ID: '..tostring(dy))end;setmetatable(cQ.center,getmetatable(vec3.unit_x))b[dy]=setmetatable(cQ,da)pid=dh end;return setmetatable(b,dr)end;aQ={}local function dz(dx)return setmetatable({galaxyAtlas=dx or{}},aQ)end;aQ.__index=function(cW,i)if type(i)=='number'then local system=cW.galaxyAtlas[i]return dw(system)end;return rawget(aQ,i)end;aQ.__pairs=function(d7)return function(cW,cP)local dA,nv=next(cW,cP)return dA,nv and dw(nv)end,d7.galaxyAtlas,nil end;aQ.__tostring=function(d7)local dB={}for _,dC in pairs(d7 or{})do local dD=dC:getPlanetarySystemId()local dE=dr.__tostring(dC,'    ')table.insert(dB,f('  [%s]={%s\n  }',dD,dE))end;return f('{\n%s\n}\n',table.concat(dB,',\n'))end;aQ.BodyParameters=df;aQ.MapPosition=dl;aQ.PlanetarySystem=dw;function aQ.createBodyParameters(dg,dh,dF,dG,dH,dI,dJ)assert(cU(dg),'Argument 1 (systemId) must be a number:'..type(dg))assert(cU(dh),'Argument 2 (id) must be a number:'..type(dh))assert(cU(dF),'Argument 3 (surfaceArea) must be a number:'..type(dF))assert(cV(dG),'Argument 4 (aPosition) must be an array or vec3:'..type(dG))assert(cV(dH),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dH))assert(cU(dI),'Argument 6 (altitude) must be in meters:'..type(dI))assert(cU(dJ),'Argument 7 (gravityAtPosition) must be number:'..type(dJ))local di=y(dF/4/math.pi)local aj=di+dI;local dK=vec3(dG)+aj*vec3(dH)local dk=dJ*aj*aj;return df(dg,dh,di,dK,dk)end;aQ.isMapPosition=c_;function aQ:getPlanetarySystem(dm)if i==nil then i=0 end;if nv==nil then nv=0 end;local dg=dm;if c_(dm)then dg=dm.systemId end;if type(dg)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dr then system=dw(system)end;return system end end end;function dr:sizeCalculator(c1)return 1.05*c1.radius end;function dr:castIntersections(dL,dM,dN,dO,dP,dQ)local dR={}local dS=dP or self;for _,c1 in pairs(dS)do table.insert(dR,c1)end;if not dQ then table.sort(dR,function(dT,dU)return(dT.center-dL):len()<(dU.center-dL):len()end)end;local dV=dM:normalize()for _,c1 in ipairs(dR)do local dW=c1.center-dL;local di=self:sizeCalculator(c1)local dX=dW:dot(dV)local dY=dX^2-(dW:len2()-di^2)if dY>=0 then local dZ=y(dY)local b_=dX+dZ;local c0=dX-dZ;if c0>0 then return c1,b_,c0 elseif b_>0 then return c1,b_,nil end end end;return nil,nil,nil end;function dr:closestBody(d_)assert(type(d_)=='table','Invalid coordinates.')local e0,c1;local e1=vec3(d_)for _,e2 in pairs(self)do local e3=(e2.center-e1):len2()if(not c1 or e3<e0)and e2.name~="Space"then c1=e2;e0=e3 end end;return c1 end;function dr:convertToBodyIdAndWorldCoordinates(dm)local e4=dm;if cX(dm)then e4=dl(dm)end;if e4.id==0 then return 0,vec3(e4.latitude,e4.longitude,e4.altitude)end;local e2=self:getBodyParameters(e4)if e2 then return e4.id,e2:convertToWorldCoordinates(e4)end end;function dr:getBodyParameters(dm)local dh=dm;if c_(dm)then dh=dm.id end;assert(cU(dh),'Argument 1 (id) must be a number:'..type(dh))return self[dh]end;function dr:getPlanetarySystemId()local _,cQ=next(self)return cQ and cQ.systemId end;function da:convertToMapPosition(dj)assert(cV(dj),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dj))local e5=vec3(dj)if self.id==0 then return setmetatable({latitude=e5.x,longitude=e5.y,altitude=e5.z,id=0,systemId=self.systemId},MapPosition)end;local e6=e5-self.center;local aj=e6:len()local dq=aj-self.radius;local dn=0;local dp=0;if not cq(aj,0)then local e7=n(e6.y,e6.x)dp=e7>=0 and e7 or 2*math.pi+e7;dn=math.pi/2-math.acos(e6.z/aj)end;return setmetatable({latitude=dn,longitude=dp,altitude=dq,id=self.id,systemId=self.systemId},MapPosition)end;function da:convertToWorldCoordinates(dm)local e4=cX(dm)and dl(dm)or dm;if e4.id==0 then return vec3(e4.latitude,e4.longitude,e4.altitude)end;assert(c_(e4),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e4.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e4.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e8=math.cos(e4.latitude)return self.center+(self.radius+e4.altitude)*vec3(e8*math.cos(e4.longitude),e8*math.sin(e4.longitude),math.sin(e4.latitude))end;function da:getAltitude(dj)return(vec3(dj)-self.center):len()-self.radius end;function da:getDistance(dj)return(vec3(dj)-self.center):len()end;function da:getGravity(dj)local e9=self.center-vec3(dj)local ea=e9:len2()return self.GM/ea*e9/y(ea)end;return setmetatable(aQ,{__call=function(_,...)return dz(...)end})end;local function eb()local aS={}local ec=30000000/3600;local ed=ec*ec;local ee=100;function aS.computeAccelerationTime(ef,eg,eh)local ei=ec*math.asin(ef/ec)return(ec*math.asin(eh/ec)-ei)/eg end;function aS.computeDistanceAndTime(ef,eh,ej,ek,el,em)el=el or 0;em=em or 0;local en=ef<=eh;local eo=ek*(en and 1 or-1)/ej;local ep=-em/ej;local eq=eo+ep;if en and eq<=0 or not en and eq>=0 then return-1,-1 end;local er,es=0,0;if eo~=0 and el>0 then local ei=math.asin(ef/ec)local et=math.pi*(eo/2+ep)local eu=eo*el;local ev=ec*math.pi;local cQ=function(cW)local ew=(et*cW-eu*math.sin(math.pi*cW/2/el)+ev*ei)/ev;local ex=math.tan(ew)return ec*ex/y(ex*ex+1)end;local ey=en and function(cY)return cY>=eh end or function(cY)return cY<=eh end;es=2*el;if ey(cQ(es))then local ez=0;while d(es-ez)>0.5 do local cW=(es+ez)/2;if ey(cQ(cW))then es=cW else ez=cW end end end;local eA=ef;local eB=es/ee;for eC=1,ee do local eD=cQ(eC*eB)er=er+(eD+eA)*eB/2;eA=eD end;if es<2*el then return er,es end;ef=eA end;local ei=ec*math.asin(ef/ec)local E=(ec*math.asin(eh/ec)-ei)/eq;local eE=ed*math.cos(ei/ec)/eq;local aj=eE-ed*math.cos((eq*E+ei)/ec)/eq;return aj+er,E+es end;function aS.computeTravelTime(ef,eg,aj)if aj==0 then return 0 end;if eg>0 then local ei=ec*math.asin(ef/ec)local eE=ed*math.cos(ei/ec)/eg;return(ec*math.acos(eg*(eE-aj)/ed)-ei)/eg end;if ef==0 then return-1 end;assert(ef>0,'Acceleration and initial speed are both zero.')return aj/ef end;return aS end;local function eF()local vec3=require('cpml.vec3')local cR=cR()local function cX(cY)return type(cY)=='string'end;local function cV(cW)return type(cW)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dq)assert(self.body)local aj=dq+self.body.radius;if not cq(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dm,eG)assert(self.body)assert(cV(dm)or cX(dm))assert(cV(eG))local eH=(cX(dm)or cR.isMapPosition(dm))and self.body:convertToWorldCoordinates(dm)or vec3(dm)local cQ=vec3(eG)local eI=eH-self.body.center;local eJ=cQ:len2()local eK=eI:len()local eL=self.body.GM;local eM=((eJ-eL/eK)*eI-eI:dot(cQ)*cQ)/eL;local cr=eL/(2*eL/eK-eJ)local eN=eM:len()local dV=eM:normalize()local eO=cr*(1-eN)local eP=cr*(1+eN)local eQ=eO*dV+self.body.center;local eR=eN<=1 and-eP*dV+self.body.center or nil;local eS=y(cr*eL*(1-eN*eN))local eT=eR and 2*math.pi*y(cr^3/eL)local eU=math.acos(eM:dot(eI)/(eN*eK))if eI:dot(cQ)<0 then eU=-(eU-2*math.pi)end;local eV=math.acos((math.cos(eU)+eN)/(1+eN*math.cos(eU)))local eW=eV;if eW<0 then eW=eW+2*math.pi end;local eX=eW-eN*math.sin(eW)local eY=0;local eZ=0;local e_=0;if eT~=nil then eY=eX/(2*math.pi/eT)eZ=eT-eY;e_=eZ+eT/2;if eU-math.pi>0 then eZ=eY;e_=eZ+eT/2 end;if e_>eT then e_=e_-eT end end;return{periapsis={position=eQ,speed=eS/eO,circularOrbitSpeed=y(eL/eO),altitude=eO-self.body.radius},apoapsis=eR and{position=eR,speed=eS/eP,circularOrbitSpeed=y(eL/eP),altitude=eP-self.body.radius},currentVelocity=cQ,currentPosition=eH,eccentricity=eN,period=eT,eccentricAnomaly=eV,meanAnomaly=eX,timeToPeriapsis=eZ,timeToApoapsis=e_}end;local function f0(f1)local e2=cR.BodyParameters(f1.systemId,f1.id,f1.radius,f1.center,f1.GM)return setmetatable({body=e2},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f0(...)end})end;local function f2()local f3={}local f4={}local f5={XS=13,S=27,M=55,L=110,XL=221}local f6={}local f7;local f8;local f9;local fa;local fb;local function fc()local function fd(fe,ff,fg,fh,fi,fj,fk,fl)ff,fh,fj,fl=vec3(ff),vec3(fh),vec3(fj),vec3(fl)local fm,fn,fo=fe*fe,fg*fg,fi*fi;local eJ=fh-ff;local fp=eJ:normalize()local fq=eJ:len()local fr=fj-ff;local fs=(fr-fr:project_on(fp)):normalize()local ft,fu=fr:dot(fp),fr:dot(fs)local fv=ft*ft+fu*fu;local fw=fp:cross(fs)local ch=(fm-fn+fq*fq)/(2*fq)local ci=(fm-fo+fv-2*ft*ch)/(2*fu)local d0=fm-ch^2-ci^2;local fx=y(d0)local fy=ff+fp*ch+fs*ci+fw*fx;local fz=ff+fp*ch+fs*ci-fw*fx;if d((fl-fy):len()-fk)<d((fl-fz):len()-fk)then return fy else return fz end end;local function fA()local function fB()local fC=core.getConstructWorldOrientationRight()local eJ=core.getConstructWorldOrientationForward()local fr=core.getConstructWorldOrientationUp()local fD=library.systemResolution3(fC,eJ,fr,{1,0,0})local fE=library.systemResolution3(fC,eJ,fr,{0,1,0})local fF=library.systemResolution3(fC,eJ,fr,{0,0,1})return function(fG)return library.systemResolution3(fD,fE,fF,fG)end end;local fH=fB()local fI=core.getConstructWorldPos()local eH=core.getElementPositionById(1)local fJ={eH[1],eH[2],eH[3]}local fK=fH(fJ)local fL={fI[1]-fK[1],fI[2]-fK[2],fI[3]-fK[3]}return fL end;local function fM(fN,eK,fO)local fP=fN.pts;local fQ=#fP;local fR=fN.ref;if fQ>3 then local fS,fT,fU,fV=fP[fQ],fP[fQ-1],fP[fQ-2],fP[fQ-3]fN.ref=fO;local eH=fd(fS[1],fS[2],fT[1],fT[2],fU[1],fU[2],fV[1],fV[2])local ch,ci,fx=eH.x,eH.y,eH.z;if ch==ch and ci==ci and fx==fx then ch=ch+fR[1]ci=ci+fR[2]fx=fx+fR[3]local fW=vec3(ch,ci,fx)if not fN.lastPos then fN.center=fW elseif(fN.lastPos-fW):len()<2 then fN.center=fW;fN.skipCalc=true end;fN.lastPos=fW end;fN.pts={}else local fX={fO[1]-fR[1],fO[2]-fR[2],fO[3]-fR[3]}fP[fQ+1]={eK,fX}end end;if bP[1]then f7=#bP[1].getConstructIds()local fY=bP[1].getData()local fZ=fY:gmatch('{"constructId[^}]*}[^}]*}')if f7>0 then local fO=fA()local f_,g0=0,0;fb,fa=0,0;for cQ in fZ do local dh,aj,g1=cQ:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g2=f5[g1]aj=z(aj)if bP[1].hasMatchingTransponder(dh)==1 then table.insert(f4,dh)end;local g3=bP[1].getConstructType(dh)if CollisionSystem then if g2>27 or g3=="static"or g3=="space"then fb=fb+1;local g4=bP[1].getConstructName(dh)local fN=bL[dh]if fN==nil then g2=g2+G;bL[dh]={pts={},ref=fO,name=g4,i=0,radius=g2,skipCalc=false}fN=bL[dh]end;if not fN.skipCalc then fM(fN,aj,fO)g0=g0+1 end;if fN.center then table.insert(f6,fN)end end;f_=f_+1;if bM and f_>700 or g0>70 or(not bM and f_>300 or g0>30)then coroutine.yield()f_,g0=0,0 end end end;fa=#f6;if fa>0 and bs>20 then local c1,g5,g6,g7;local g8=0;local g9=aR:getPlanetarySystem(0)g7=br:normalize()while g8<fa do coroutine.yield()local ga={table.unpack(f6,g8,math.min(g8+75,fa))}c1,g5,g6=g9:castIntersections(bv,g7,nil,nil,ga,true)if c1 and g6 then bO={c1,g5,g6}break end;g8=g8+75 end;if not c1 then bO=nil end else bO=nil end;f6={}f8=fY:find('identifiedConstructs":%[%]')else f9=fY:find('worksInEnvironment":false')end end end;local function gb()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function f3.pickType()gb()end;function f3.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then gb()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then gb()end end end;function f3.UpdateRadar()local gc=coroutine.status(UpdateRadarCoroutine)if gc=="suspended"then local cn,gd=coroutine.resume(UpdateRadarCoroutine)if gd then system.print("ERROR UPDATE RADAR: "..gd)end elseif gc=="dead"then UpdateRadarCoroutine=coroutine.create(fc)local cn,gd=coroutine.resume(UpdateRadarCoroutine)end end;function f3.GetRadarHud()local ge=f4;f4={}return f8,f9,f7,fa,fb,ge end;UpdateRadarCoroutine=coroutine.create(fc)return f3 end;local function gf()local gg=9.80665;local gh=vec3({13771471,7435803,-128971})local gi=18000000;local gj=500000;local gk,gl=math.huge;local gm;local function gn(go)gk=vec3(go):dist(gh)if gk<gi then return true,d(gk-gi)end;gl=vec3(go):dist(vec3(planet.center))if gl<gj then gm=true else gm=false end;if d(gl-gj)<d(gk-gi)then return gm,d(gl-gj)else return gm,d(gk-gi)end end;local function gp(cQ)if aG==1920 then return cQ else return A(aG*cQ/1920,0)end end;local function gq(cQ)if aH==1080 then return cQ else return A(aH*cQ/1080,0)end end;local function gr()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gs()local gt="TRAVEL"if not bA then gt="CRUISE"end;if Autopilot then gt="AUTOPILOT"end;return gt end;local gu=""local gv=""local gw=""local gx=1;local gy=2;local gz=3;local gA=4;local gB=5;local gC=6;local gD=""local gE=0;local gF=e(1/apTickRate)*2*hudTickRate;local gG={}local gH={}local gI={}local gJ={}local gK={}local gL={}local function gM(ch,gN,gO,gP,gQ,gR)local gS=tankY;local gT=tankY+5;if not BarFuelDisplay then gT=gT+5 end;if m()==1 and not RemoteHud then gS=gS-50;gT=gT-50 end;if gO=="ATMO"then gD="atmofueltank"elseif gO=="SPACE"then gD="spacefueltank"else gD="rocketfueltank"end;gE=_G[gD.."_size"]if#gP>0 then for i=1,#gP do local g4=string.sub(gP[i][gy],1,12)local gU=0;for gV=1,gE do if gP[i][gy]==g(unit[gD.."_"..gV].getData()).name then gU=gV;break end end;local gW=q()if gQ[i]==nil or gR[i]==nil or gW-gP[i][gC]>gF then local gX;local gY=0;if gU~=0 then gR[i]=g(unit[gD.."_"..gU].getData()).percentage;gQ[i]=g(unit[gD.."_"..gU].getData()).timeLeft;if gQ[i]=="n/a"then gQ[i]=0 end else gY=l(gP[i][gx])-gP[i][gA]gR[i]=e(0.5+gY*100/gP[i][gz])gX=gP[i][gB]if gX<=gY then gQ[i]=0 else gQ[i]=e(0.5+gY/((gX-gY)/(gW-gP[i][gC])))end;gP[i][gB]=gY;gP[i][gC]=gW end end;if g4==gN then g4=f("%s %d",gO,i)end;if gU==0 then g4=g4 .." *"end;local gZ;if gQ[i]==0 then gZ=""else gZ=cG(gQ[i])end;if gR[i]~=nil then local g_=e(gR[i]*2.55)local h0=f("rgb(%d,%d,%d)",255-g_,g_,0)local ck=""if gZ~=""and gQ[i]<120 or gR[i]<5 then ck="red "end;if BarFuelDisplay then gv=gv..f([[
                                            <g class="pdim">                        
                                            <rect fill=#222222 class="bar" x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%% %s</text>
                                            </g>]],ch,gT,h0,e(gR[i]*1.7+0.5),ch,gT,ch+5,gT+14,g4,gR[i],gZ)gS=gS-22;gT=gT-22 else gv=gv..cg(ch,gS,g4,ck.."pdim txtfuel")gv=gv..cg(ch,gT,f("%d%% %s",gR[i],gZ),"pdim txtfuel","fill:"..h0)gS=gS+30;gT=gT+30 end end end end;tankY=gS end;local function h1(h2,dq)if dq<200000 and not aq or dq and aq then local h3=0;if d(bu)>1 then h3=45*math.log(d(bu),10)if bu<0 then h3=-h3 end end;h2[#h2+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(h3))end;return h2 end;local function h4(h5)local h6=-bt;h5=h5-h5:project_on(h6)local h7=vec3(0,0,1)h7=h7-h7:project_on(h6)local h8=h7:cross(h6)local h3=h7:angle_between(h5)*constants.rad2deg;if h5:dot(h8)<0 then h3=360-h3 end;return h3 end;local function h9(h2,centerX,centerY,ha,hb,bM)local hc=circleRad;local hd=20;local he=e(ha)if bM then for i=-45,45,5 do local hf=i;h2[#h2+1]=f([[<g transform="rotate(%f,%d,%d)">]],hf,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;h2[#h2+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hc+hd-len,centerX,centerY+hc+hd)end;h2[#h2+1]=cg(centerX,centerY+hc+hd-35,hb,"pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY+hc+hd-25,he.." deg","pdim txt txtmid")h2[#h2+1]=f([[<g transform="rotate(%f,%d,%d)">]],-ha,centerX,centerY)h2[#h2+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hc+hd-20,centerX+5,centerY+hc+hd-20,centerX,centerY+hc+hd-15)h2[#h2+1]="</g>"end;h2[#h2+1]=[[<g style="clip-path: url(#headingClip);">]]local hg=he;if bM then hg=h4(bo)end;local hh=20;local hi=e(hg)local hj=0;local hk=centerY+hc+hd+20;local hl=centerX;if hb~="YAW"then hk=gq(130)hl=gp(960)end;local hm=[[<path class="txttick line" d="]]local hn=e(hi-(hh+10)-hi%5+0.5)for i=hn+70,hn,-5 do local ch=hl-(-i*5+hg*5)if i%10==0 then hj=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;h2[#h2+1]=cg(ch,hk+15,B,"txtmid bright")elseif i%5==0 then hj=5 end;if hj==10 then hm=f([[%s M %f %f v %d]],hm,ch,hk-5,hj)else hm=f([[%s M %f %f v %d]],hm,ch,hk-2.5,hj)end end;h2[#h2+1]=hm..[["/>]]h2[#h2+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],hl-5,hk-20,hl+5,hk-20,hl,hk-10)if bM then hb="HDG"end;h2[#h2+1]=cg(960,100,hi.."Â°","dim txt txtmid size14","")h2[#h2+1]=cg(960,85,hb,"dim txt txtmid size20","")h2[#h2+1]=[[</g>]]end;local function ho(h2,hp,ha,centerX,centerY,bM,hq,eD)local hc=circleRad;local hr=e(hc*3/5)if hc>0 then local hs=e(hp)local len=0;local hm=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*ha,centerX,centerY)if not aq then hm=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;h2[#h2+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hc-1,centerX,centerY)h2[#h2+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hs-30-hs%5+0.5),e(hs+30+hs%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local ci=centerY+-i*5+hp*5;if len==30 then hm=f([[%s M %d %f h %d]],hm,centerX-hr-len,ci,len)if aq then h2[#h2+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*ha,centerX,centerY,centerX-hr+10,ci+4,i)h2[#h2+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*ha,centerX,centerY,centerX+hr-10,ci+4,i)if i==0 or i==180 or i==-180 then h2[#h2+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*ha,centerX,centerY,centerX-hr+20,ci,hr*2-40)end else h2[#h2+1]=cg(centerX-hr+10,ci,i,"pdim txt txtmid")h2[#h2+1]=cg(centerX+hr-10,ci,i,"pdim txt txtmid")end;hm=f([[%s M %d %f h %d]],hm,centerX+hr,ci,len)else hm=f([[%s M %d %f h %d]],hm,centerX-hr-len,ci,len)hm=f([[%s M %d %f h %d]],hm,centerX+hr,ci,len)end end;h2[#h2+1]=hm..[["/>]]local ht="PITCH"if not bM then ht="REL PITCH"end;if hp>90 and not aq then hp=90-(hp-90)elseif hp<-90 and not aq then hp=-90-(hp+90)end;if hc>200 then if aq then if eD>Q then h2[#h2+1]=cg(centerX,centerY-15,"Yaw","pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY+20,hq,"pdim txt txtmid")end;h2[#h2+1]=f([[<g transform="rotate(%f,%d,%d)">]],-ha,centerX,centerY)else h2[#h2+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;h2[#h2+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hr+25,centerY-5,centerX-hr+20,centerY,centerX-hr+25,centerY+5,centerX-hr+50,centerY+4,hs)h2[#h2+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hr-25,centerY-5,centerX+hr-20,centerY,centerX+hr-25,centerY+5,centerX+hr-30,centerY+4,hs)h2[#h2+1]="</g>"end;local hu=e(hc/3)h2[#h2+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hu,centerY,hc-hu)if not aq and bM then h2[#h2+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*ha,centerX,centerY,centerX-hr+10,centerY,hr*2-20)end;h2[#h2+1]="</g>"if hc<200 then if aq and eD>Q then h2[#h2+1]=cg(centerX,centerY-hc,ht,"pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY-hc+10,hs,"pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY-15,"Yaw","pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY+20,hq,"pdim txt txtmid")else h2[#h2+1]=cg(centerX,centerY-hc,ht,"pdim txt txtmid")h2[#h2+1]=cg(centerX,centerY-hc+15,hs,"pdim txt txtmid")end end end end;local function hv(h2,dq,bM)local hw=altMeterX;local hx=altMeterY;local hy=78;local hz=19;local hA=ao;if ao~=-1 then h2[#h2+1]=cg(hw+hy,hx+hz+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dq<200000 and not aq or dq and aq)then table.insert(h2,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hw-1,hx-4,hy+2,hz+6,hw+1,hx-1,hy-4,hz))local fQ=0;local hB=1;local hC=0;local hD=dq<0;local hE=dq<planet.surfaceMaxAltitude;local hF=9;if hD then hF=0 end;local dq=d(dq)while fQ<6 do local hG=11;local hH=16;local hI=9;local hJ=14;local ck="altsm"if fQ>2 then hH=hH+3;hG=hG+2;hJ=hJ+2;hI=hI-6;ck="altbig"end;if hD then ck=ck.." red"elseif hE then ck=ck.." orange"end;local hK=dq/hB%10;local hL=e(hK)local hM=e((hL+1)%10)local hN=hC;if fQ==0 then hN=hK-hL;if hD then hN=1-hN end end;if hD and(fQ==0 or hC~=0)then local hO=hM;hM=hL;hL=hO end;local hP=hH*(hN-1)local hQ=hP+hH;local ch=hw+hI+(6-fQ)*hG;local ci=hx+hJ;h2[#h2+1]=cg(ch,ci+hP,hM,ck)h2[#h2+1]=cg(ch,ci+hQ,hL,ck)fQ=fQ+1;hB=hB*10;if hL==hF then hC=hN else hC=0 end end;table.insert(h2,[[</g></g>]])end end;local function hR(eG)local hS=-math.deg(n(eG.y,eG.z))+180;hS=hS-90;if hS<0 then hS=360+hS end;if hS>180 then hS=-180+hS-180 end;return-hS end;local function hT(eG)local hg=math.deg(n(eG.y,eG.x))-90;if hg<-180 then hg=360+hg end;return hg end;local function hU(h2,eG,eD,centerX,centerY)if eD>5 and not aq or eD>Q then local hc=circleRad;local hV=20;local hW=20;local hX=hR(eG)local hY=hT(eG)local hZ=14;local h_=hZ/2;local i0=-hY/hW*hc;local i1=hX/hV*hc;local ch=centerX+i0;local ci=centerY+i1;local aj=y(i0^2+i1^2)local i2=[[<circle
                            cx="]]..ch..[["
                            cy="]]..ci..[["
                            r="]]..h_/hZ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ch..[["
                            cy="]]..ci..[["
                            r="]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ch-hZ..[[,]]..ci..[[ h ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ch+h_..[[,]]..ci..[[ h ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ch..[[,]]..ci-hZ..[[ v ]]..h_..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<hc then h2[#h2+1]=i2 else local h3=n(i1,i0)local i3=4;local i4=centerX+hc*math.cos(h3)local i5=centerY+hc*math.sin(h3)h2[#h2+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',h3*180/math.pi,i4,i5,i4-i3,i5-i3/2,i3*2,i3,i4+i3,i5-i3,i3,i3,-i3,i3)end;if not aq then local i6=vec3(eG)hX=hR(-i6)hY=hT(-i6)i0=-hY/hW*hc;i1=hX/hV*hc;ch=centerX+i0;ci=centerY+i1;aj=y(i0^2+i1^2)if aj<hc then local i7=[[<circle
                                    cx="]]..ch..[["
                                    cy="]]..ci..[["
                                    r="]]..h_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ch..[[,]]..ci-hZ..[[ v ]]..h_..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ch..[[,]]..ci..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ch..[[,]]..ci..[[)" />
                                <path
                                    d="M ]]..ch-h_..[[,]]..ci..[[ h ]]..hZ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ch..[[,]]..ci..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ch..[[,]]..ci..[[)"/>]]h2[#h2+1]=i7 end end end end;local function i8(h2,gt,i9,ia)i9=e(i9+0.5)local gS=throtPosY+10;local gT=throtPosY+20;if m()==1 and not RemoteHud then gS=55;gT=65 end;local ib="CRUISE"local unit="km/h"local cn=ia;if gt=="TRAVEL"or gt=="AUTOPILOT"then ib="THROT"unit="%"cn=i9;local ic="dim"if i9<0 then ic="red"end;h2[#h2+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],ic,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(i9),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;h2[#h2+1]=cg(throtPosX+10,gS,ib,"pbright txtstart")h2[#h2+1]=cg(throtPosX+10,gT,f("%.0f %s",cn,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then i9=e(N*100+0.5)local ic="red"if i9<0 then ic="red"end;h2[#h2+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],ic,1-d(i9),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)h2[#h2+1]=cg(throtPosX+10,gS+40,"LIMIT","pbright txtstart")h2[#h2+1]=cg(throtPosX+10,gT+40,i9 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then h2[#h2+1]=cg(throtPosX+10,gS-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then h2[#h2+1]=cg(throtPosX+10,gS-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function id(h2,ie)local ig=throtPosY-10;local ih=throtPosX+10;h2[#h2+1]=cg(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then ig=75 end;h2[#h2+1]=cg(ih,ig,e(ie).." km/h","pbright txtbig txtstart")end;local function ii(h2)h2[#h2+1]=cg(gp(1900),gq(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")h2[#h2+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then h2[#h2+1]=cg(gp(960),gq(550),"Warning: Invalid Control Scheme Detected","warnings")h2[#h2+1]=cg(gp(960),gq(600),"Keyboard Scheme must be selected","warnings")h2[#h2+1]=cg(gp(960),gq(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ij=gp(960)local ik=gq(860)local il=gq(880)local im=gq(900)local io=gq(960)local ip=gq(200)local iq=gq(250)local ir=gq(960)if m()==1 and not RemoteHud then ik=gq(135)il=gq(155)im=gq(175)ip=gq(115)iq=gq(95)end;local is="#222222"local it="white"local iu="dimmer"local iv="pbright"local iw="#110000"local ix=is;local iy=iu;if BrakeIsOn then h2[#h2+1]=cg(ij,ik,"Brake Engaged","warnings")iw="#440000"ix=it;iy=iv elseif L>0 then h2[#h2+1]=cg(ij,ik,"Auto-Brake Engaged","warnings","opacity:"..L)end;local iz="#110000"local iA=is;local iB=iu;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then h2[#h2+1]=cg(ij,ip+50,"** STALL WARNING **","warnings")iz="#ff0000"iA=it;iB=iv;c3("stall","SW",2)end end;if bK then h2[#h2+1]=cg(ij,ip+90,"Flight Assist in Progress","warnings")end;if ax then h2[#h2+1]=cg(ij,ir,"Gyro Enabled","warnings")end;local iC="#111100"local iD=is;local iE=iu;if GearExtended then iC="#775500"iD=it;iE=iv;if S then h2[#h2+1]=cg(ij,il,"Gear Extended","warn")else h2[#h2+1]=cg(ij,il,"Landed (G: Takeoff)","warnings")end;local iF=ct(a:getTargetGroundAltitude())h2[#h2+1]=cg(ij,im,"Hover Height: "..iF,"warn")end;local iG="#000011"local iH=is;local iI=iu;if a7 then iG="#0000DD"iH=it;iI=iv;h2[#h2+1]=cg(ij,io+20,"ROCKET BOOST ENABLED","warn")end;local iJ="#001100"local iK=is;local iL=iu;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then iJ="#00DD00"iK=it;iL=iv;if d(as-antigrav.getBaseAltitude())<501 then h2[#h2+1]=cg(ij,ip+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else h2[#h2+1]=cg(ij,ip+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then h2[#h2+1]=cg(ij,ip+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then h2[#h2+1]=cg(ij,ip+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then h2[#h2+1]=cg(ij,ip+20,"Follow Mode Engaged","warn")elseif Reentry or an then h2[#h2+1]=cg(ij,ip+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iF=ct(HoldAltitude,2)if VertTakeOff then if by then iF=ct(antigrav.getBaseAltitude(),2).." AGG singularity height"end;h2[#h2+1]=cg(ij,ip,"VTO to "..iF,"warn")elseif AutoTakeoff and not IntoOrbit then if am then h2[#h2+1]=cg(ij,ip,"Takeoff to "..AutopilotTargetName,"warn")else h2[#h2+1]=cg(ij,ip,"Takeoff to "..iF,"warn")end;if BrakeIsOn and not VertTakeOff then h2[#h2+1]=cg(ij,ip+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else h2[#h2+1]=cg(ij,ip,"Altitude Hold: "..iF,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then h2[#h2+1]=cg(ij,ip+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then h2[#h2+1]=cg(ij,ip+20,"Aligning trajectory","warn")elseif ar<0.05 then h2[#h2+1]=cg(ij,ip+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then h2[#h2+1]=cg(ij,ip,b9,"warn")end end;if BrakeLanding then if StrongBrakes then h2[#h2+1]=cg(ij,ip,"Brake-Landing","warnings")else h2[#h2+1]=cg(ij,ip,"Coast-Landing","warnings")end end;if ProgradeIsOn then h2[#h2+1]=cg(ij,ip,"Prograde Alignment","crit")end;if RetrogradeIsOn then h2[#h2+1]=cg(ij,ip,"Retrograde Alignment","crit")end;local iM="#110000"local iN=is;local iO=iu;if bN then iM="#FF0000"iN=it;iO=iv;local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;h2[#h2+1]=cg(ij,iq+20,bN,type)elseif ar==0 then local bZ,c2=bX(br:normalize())if c2~=nil then iO=iv;iM="#FF0000"iN=it;local iF=ct(c2)local travelTime=aS.computeTravelTime(bs,0,c2)local iP="Collision"if bZ.noAtmosphericDensityAltitude>0 then iP="Atmosphere"end;h2[#h2+1]=cg(ij,iq+20,bZ.name.." "..iP.." "..cG(travelTime).." In "..iF,"crit")end end;if VectorToTarget and not IntoOrbit then h2[#h2+1]=cg(ij,ip+35,VectorStatus,"warn")end;local iQ="#111100"local iR=is;local iS=iu;if passengers and#passengers>1 then iQ="#DDDD00"iR=it;iS=iv end;local iT=gp;local iU=gq;local iu="topButton"local iV="topButtonActive"local iW=iu;if Autopilot or VectorToTarget or am or IntoOrbit then iW=iV end;local iX=iu;if ProgradeIsOn then iX=iV end;local iY=iu;if BrakeLanding or GearExtended then iY=iV end;local iZ=iu;if AltitudeHold or VectorToTarget then iZ=iV end;local i_=iu;if RetrogradeIsOn then i_=iV end;local j0=iu;if IntoOrbit or bi and Autopilot then j0=iV end;local j1=iU(30)h2[#h2+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 -53 l -120 0 l 25 50 Z"/>
                                ]],iW,iT(960),iU(54))h2[#h2+1]=cg(iT(910),j1,"AUTOPILOT")h2[#h2+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l -25 -50 l -110 0 l 25 46 Z"/>
                                ]],iX,iT(865),iU(51))h2[#h2+1]=cg(iT(800),j1,"PROGRADE")h2[#h2+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l -25 -46 l -98 0 l 44 44 Z"/>
                                ]],iY,iT(755),iU(47))h2[#h2+1]=cg(iT(700),j1,"LAND")h2[#h2+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 0 -53 l 120 0 l -25 50 Z"/>
                                ]],iZ,iT(960),iU(54))h2[#h2+1]=cg(iT(1010),j1,"ALT HOLD")h2[#h2+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 25 -50 l 110 0 l -25 46 Z"/>
                                ]],i_,iT(1055),iU(51))h2[#h2+1]=cg(iT(1122),j1,"RETROGRADE")h2[#h2+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 25 -46 l 98 0 l -44 44 Z"/>
                                ]],j0,iT(1165),iU(47))h2[#h2+1]=cg(iT(1220),j1,"ORBIT")h2[#h2+1]=[[
                                </g>
                            </g>]]h2[#h2+1]="</g>"return h2 end;local function j2(eD)return e(A(eD*3.6,0)+0.5).." km/h"end;local function j3(h2)local j4=OrbitMapX;local j5=OrbitMapY;local j6=OrbitMapSize;local j7=4;local j8=15;local ch=0;local ci=0;local j9,ja,jb,jc;local function jd(type)local je,E,eD,jf;if type=="Periapsis"then je=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;eD=orbit.periapsis.speed;jf=35 else je=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;eD=orbit.apoapsis.speed;jf=-35 end;h2[#h2+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ch+jf,ci-5,j4+j6/2-j9+jc,ci-5)h2[#h2+1]=cg(ch,ci,type)ci=ci+j8;local iF=ct(je)h2[#h2+1]=cg(ch,ci,iF)ci=ci+j8;h2[#h2+1]=cg(ch,ci,cG(E))ci=ci+j8;h2[#h2+1]=cg(ch,ci,j2(eD))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then j5=j5+j7;ch=j4+j6+j4/2+j7;ci=j5+j6/2+5+j7;j9=j6/4;jc=0;h2[#h2+1]=[[<g class="pbright txtorb txtmid">]]h2[#h2+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',j6+j4*2,j6+j5,j7,j7)if orbit.periapsis~=nil and orbit.apoapsis~=nil then jb=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(j9*2)ja=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/jb*(1-orbit.eccentricity)jc=j9-orbit.periapsis.altitude/jb-planet.radius/jb;local jg=""if orbit.periapsis.altitude<=0 then jg='redout'end;h2[#h2+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jg,j4+j6/2+jc+j7,j5+j6/2+j7,j9,ja)h2[#h2+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',j4+j6/2+j7,j5+j6/2+j7,planet.radius/jb)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then jd("Apoapsis")end;ci=j5+j6/2+5+j7;ch=j4-j4/2+10+j7;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then jd("Periapsis")end;h2[#h2+1]=cg(j4+j6/2+j7,planet.name,20+j7,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local jh=orbit.timeToApoapsis/orbit.period*2*math.pi;local ji=j9*math.cos(jh)local jj=ja*math.sin(jh)h2[#h2+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',j4+j6/2+ji+jc+j7,j5+j6/2+jj+j7)end;h2[#h2+1]=[[</g>]]return h2 else return h2 end end;local function jk(h2)local ch=30;local ci=275;local jl={}local jm={"Alt-4: AutoTakeoff to Target"}local jn={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local jo={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local jp={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(jl,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then c6(jl,jm)if ac and planet and ac.name==planet.name then table.insert(jl,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(jl,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(jl,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(jl,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(jl,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(jl,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(jl,"G: Takeoff to hover height, raise gear")else table.insert(jl,"G: Lowergear and Land")end else c6(jl,jn)table.insert(jl,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(jl,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c6(jl,jo)if shield_1 then table.insert(jl,"Alt-Shift-5: Toggle shield off and on")table.insert(jl,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(jl,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(jl,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(jl,"Alt-Spacebar/C will raise/lower target height")table.insert(jl,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(jl,"LALT+Mousewheel will lower/raise speed limit")end;c6(jl,jp)for i=1,#jl do ci=ci+12;h2[#h2+1]=cg(ch,ci,jl[i],"pdim txttick txtstart")end end;local function jq(jr,js)local jt;local ju=(js-jr):normalize()local eI=(bv-jr):dot(ju)/ju:dot(ju)if eI<=0.then return(bv-jr):len()elseif eI>=(js-jr):len()then return(bv-js):len()end;local jv=jr+eI*ju;jt=(jv-bv):len()return jt end;local function jw()local jt;local jx=nil;local jy=nil;local jz=nil;for cP,jA in pairs(b[0])do if jA.hasAtmosphere then local aj=jq(planet.center,jA.center)if jx==nil or aj<jx then jy=jA;jx=aj;jz=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local e3=jq(ac.center,jA.center)if e3<jx then jy=jA;jx=e3;jz=ac end end end end;local jB=gp(1770)local jC=gq(330)if jx then local jD="txttick "local jE=500000;if jx<jy.radius+jE or jx<jz.radius+jE then if bH then jD="txttick red "else jD="txttick orange "end end;jt=ct(jx,2)bJ=cg(jB,jC,"Pipe ("..jz.name.."--"..jy.name.."): "..jt,jD.."pbright txtmid")end end;local jF={}local jG=nil;function jF.HUDPrologue(h2)bH,bI=gn(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local jH=ay;local jI=az;local jJ=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.3+0.5)..[[)]]local jK=ay;local jL=az;if gr()and not brightHud then jH=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]jI=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iT=gp;local iU=gq;h2[#h2+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:%s;opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.8" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="30%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.2"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],jH,jH,jH,jK,jK,jI,jI,jL,jL,jI,jH,jJ,jL,jH,jL,jH,jJ,jJ,aG,aH,jI,jI,jI,jI,jI,jJ,jJ,jI)if not jG then jG=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iT(630),iU(0),iT(675),iU(45),iT(960),iU(55),iT(1245),iU(45),iT(1290),iU(0),iT(1000),iU(105),iT(1040),iU(59),iT(1250),iU(51),iT(1300),iU(0),iT(1920),iU(0),iT(1920),iU(20),iT(1400),iU(20),iT(1300),iU(105),iT(920),iU(105),iT(880),iU(59),iT(670),iU(51),iT(620),iU(0),iT(0),iU(0),iT(0),iU(20),iT(520),iU(20),iT(620),iU(105),iT(890),iU(59),iT(960),iU(62),iT(1030),iU(59),iT(985),iU(112),iT(1150),iU(112),iT(1100),iU(152),iT(820),iU(152),iT(780),iU(112),iT(935),iU(112),iT(890),iU(59),iT(960),iU(62),iT(1030),iU(59),iT(985),iU(112),iT(1150),iU(112),iT(1100),iU(152),iT(820),iU(152),iT(780),iU(112),iT(935),iU(112))end;h2[#h2+1]=jG;return h2 end;function jF.DrawVerticalSpeed(h2,dq)h1(h2,dq)end;function jF.UpdateHud(h2)local hS=bB;local jM=bC;local ha=jM;local hp=hS;local i9=e(unit.getThrottle())local ie=bs*3.6;local ia=unit.getAxisCommandValue(0)local jN=gp(1770)local jO=gq(310)if AtmoSpeedAssist and bA then ia=K;i9=K*100 end;local gt=gs()local hb="ROLL"if i9==nil then i9=0 end;if not bM then if bs>5 then hS=hR(bq)jM=hT(bq)else hS=0;jM=0 end;hb="YAW"end;if bI>50000 and not aq then local jP;jP=ct(bI)h2[#h2+1]=cg(jN,jO,"PvP Boundary: "..jP,"pbright txtbig txtmid")end;h2[#h2+1]=ak;h2[#h2+1]=aD;h2[#h2+1]=gu;if bJ~=""then h2[#h2+1]=bJ end;if gv~=""then h2[#h2+1]=gv end;if gw~=""then h2[#h2+1]=gw end;h1(h2,as)if m()==0 or RemoteHud then if bM then h9(h2,centerX,centerY,ha,hb,bM)else h9(h2,centerX,centerY,jM,hb,bM)end;if not gr()or brightHud then if bM then h9(h2,centerX,centerY,ha,hb,bM)ho(h2,hp,ha,centerX,centerY,bM,e(hT(bq)),bs)else h9(h2,centerX,centerY,jM,hb,bM)ho(h2,hS,jM,centerX,centerY,bM,e(jM),bs)end;hv(h2,as,bM)hU(h2,bq,bs,centerX,centerY)end end;i8(h2,gt,i9,ia)id(h2,ie)ii(h2)j3(h2)if showHelp then jk(h2)end;return h2 end;function jF.HUDEpilogue(h2)h2[#h2+1]="</svg>"return h2 end;function jF.ExtraData(h2)local jQ=gp(1240)local jR=gq(55)local jS=jR+10;local jT;local iT=gp;local iU=gq;local jU=0;local gt=gs()local jV=iT(99)local jW=iT(80)local jX=iU(85)local jY=iU(31)local jZ=0;local j_=0;local k0=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then jU=LastMaxBrakeInAtmo else jU=LastMaxBrake end;local k1,k2=aS.computeDistanceAndTime(bs,0,av,0,0,jU)if k1<0 then k1=0 end;jU=A(jU/(av*gg),2).."g"local k3=a:maxForceForward()jT=core.g()if jT>0.1 then j_=av*jT;j_=A(j_/(av*gg),2).."g"jZ=0.5*k3/jT;jZ=jZ>1000000 and A(jZ/1000000,2).."kT"or A(jZ/1000,2).."T"end;k3=A(k3/(av*gg),2).."g"local k4=vec3(core.getWorldAcceleration()):len()/9.80665;jT=core.g()h2[#h2+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then jQ=gp(1120)jR=gq(55)jS=jR+10 elseif aq then local k5=gp(770)h2[#h2+1]=cg(iT(895),jV,"ATMO","")h2[#h2+1]=f([[<path class="linethin dimstroke"  d="M %f %f l -80 0"/>]],iT(895),jX)h2[#h2+1]=cg(iT(815),jW,f("%.1f%%",ar*100),"txtstart size20")end;h2[#h2+1]=cg(iT(1025),jV,"GRAVITY","txtstart")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iT(1025),jX)h2[#h2+1]=cg(iT(1105),jW,f("%.2fg",jT/9.80665),"size20")h2[#h2+1]=cg(iT(1125),jV,"ACCEL","txtstart")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iT(1125),jX)h2[#h2+1]=cg(iT(1205),jW,f("%.2fg",k4),"size20")h2[#h2+1]=cg(iT(695),jV,"BRAKE","")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l -80 0"/>]],iT(695),jX)h2[#h2+1]=cg(iT(615),jW,f("%s",cG(k2)),"txtstart size20")h2[#h2+1]=cg(iT(635),iU(45),"TRIP","")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l -90 0"/>]],iT(635),iU(31))if travelTime then h2[#h2+1]=cg(iT(532),iU(23),f("%s",cG(travelTime)),"txtstart size20")end;h2[#h2+1]=cg(iT(795),jV,"BRAKE","")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l -80 0"/>]],iT(795),jX)h2[#h2+1]=cg(iT(715),jW,f("%s",ct(k1)),"txtstart size20")h2[#h2+1]=cg(iT(1285),iU(45),"MASS","txtstart")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l 90 0"/>]],iT(1285),iU(31))h2[#h2+1]=cg(iT(1388),iU(23),f("%s",k0),"size20")h2[#h2+1]=cg(iT(1220),jV,"THRUST","txtstart")h2[#h2+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iT(1220),jX)h2[#h2+1]=cg(iT(1300),jW,f("%s",k3),"size20")h2[#h2+1]=cg(gp(960),gq(175),gt,"pbright txtbig txtmid size20")h2[#h2+1]="</g>"end;function jF.DrawOdometer(h2,ad,TotalDistanceTravelled,ae)return h2 end;function jF.DrawWarnings(h2)return ii(h2)end;function jF.DisplayOrbitScreen(h2)return j3(h2)end;function jF.DisplayMessage(h2,iF)if iF~="empty"then local ci=310;for k6 in string.gmatch(iF,"([^\n]+)")do ci=ci+35;h2[#h2+1]=cg("50%",ci,k6,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function jF.DrawDeadZone(h2)h2[#h2+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function jF.UpdatePipe()if aq then bJ=""return end;jw()end;function jF.DrawSettings(h2)if#bE>0 then local ch=gp(640)local ci=gq(200)h2[#h2+1]=[[<g class="pbright txtvspd txtstart">]]for cP,cQ in pairs(bE)do h2[#h2+1]=cg(ch,ci,cQ..": ".._G[cQ])ci=ci+20;if cP%12==0 then ch=ch+gp(350)ci=gq(200)end end;h2[#h2+1]=cg(gp(640),gq(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")h2[#h2+1]="</g>"end;return h2 end;local k7;local k8=gp(1770)local k9=gq(350)local ka=gq(15)local kb=gp(1370)local bT,kc;local kd=0;function jF.DrawRadarInfo()local function ke()if radarPanelID~=nil and kd==0 then t(radarPanelID)radarPanelID=nil;if k7~=nil then t(k7)k7=nil end else if kd==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")k7=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kd=0 end end;local f8,f9,f7,fa,fb,f4=aY.GetRadarHud()local B=fa or 0;if f7>0 then if CollisionSystem then bT=B.."/"..fb.." Plotted : "..f7-fb.." Ignored"else bT="Radar Contacts: "..f7 end;gu=cg(k8,k9,bT,"pbright txtbig txtmid")if#f4>0 then gu=gu..cg(kb,ka,"Friendlies In Range","pbright txtbig txtmid")for cP,cQ in pairs(f4)do ka=ka+20;gu=gu..cg(kb,ka,bP[1].getConstructName(cQ),"pdim txtmid")end end;if f8==nil and k7==nil then kd=1;ke()end;if f8~=nil and k7~=nil then ke()end;if radarPanelID==nil then ke()end else if f9 then gu=cg(k8,k9,bQ.." Radar: Jammed","pbright txtbig txtmid")else gu=cg(k8,k9,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kd=0;ke()end end end;function jF.DrawTanks()if fuelX~=0 and fuelY~=0 then gv=cg(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gM(fuelX,"Atmospheric ","ATMO",aI,gK,gL)gM(fuelX,"Space Fuel T","SPACE",aJ,gI,gJ)gM(fuelX,"Rocket Fuel ","ROCKET",aK,gG,gH)end end;function jF.DrawShield()local kf=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local kg=core.getPvPTimer()local kh=shield_1.getResistances()local ki="A: "..10+kh[1]*100 .."% / E: "..10+kh[2]*100 .."% / K:"..10+kh[3]*100 .."% / T: "..10+kh[4]*100 .."%"local ch,ci=shieldX-60,shieldY+30;local kj=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local g_=e(kj*2.55)local h0=f("rgb(%d,%d,%d)",255-g_,g_,0)local ck=""gw=cg(ch,ci,"","txtmid pdim txtfuel")if kj<10 and kf~="Shield Disabled"then ck="red "end;kg=kg>0 and"   PvPTime: "..cG(kg)or""gw=gw..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ch,ci,h0,kj*2,ch,ci,ch+2,ci+10,kj,kg)gw=gw..cg(ch,ci-5,kf,ck.."txtstart pbright txtbig")gw=gw..cg(ch,ci+30,ki,ck.."txtstart pbright txtsmall")end;return jF end;local function kk()local function kl(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function km()local function kn(ko,kp)return ko.name<kp.name end;bG={}for cP,cQ in pairs(b[0])do bG[#bG+1]={name=cQ.name,index=cP}end;table.sort(bG,kn)end;local function kq(kr)for cP,cQ in pairs(kr)do if cQ.name and cQ.name==CustomTarget.name then return cP end end;return-1 end;local function ks()bS=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local kt=bG[AutopilotTargetIndex].index;local ku=b[0][kt]if ku.center then AutopilotTargetName=ku.name;ac=aR[0][kt]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=ku;for _,cQ in pairs(aR[0])do if cQ.name==CustomTarget.planetname then ac=cQ;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function kv(h6)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if h6==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then ks()else local kt=bG[AutopilotTargetIndex].index;local ku=b[0][kt]if ku~=nil and ku.name=="Space"or iphCondition=="Custom Only"and ku.center or iphCondition=="No Moons"and string.find(ku.name,"Moon")~=nil then if h6==nil then kv()else kv(1)end else ks()end end else a2="Disengage autopilot before changing Interplanetary Helper"c3("iph","AP")end end;local function kw()local fQ=-1;fQ=kq(b[0])if fQ>-1 then table.remove(b[0],fQ)end;fQ=-1;fQ=kq(SavedLocations)if fQ~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fQ)end;kv()km()end;local function kx(g4,position,hO,ky)if dbHud_1 or hO then local p=kl(position)local jT=p.gravity;if ky then jT=unit.getClosestPlanetInfluence()end;local kz={position=position,name=g4,planetname=p.name,gravity=jT,safe=ky}if not hO then SavedLocations[#SavedLocations+1]=kz else for cP,cQ in pairs(b[0])do if cQ.name and g4==cQ.name then table.remove(b[0],cP)end end end;table.insert(b[0],kz)km()ks()a2="Location saved as "..g4 .."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local kA={}function kA.UpdateAtlasLocationsList()km()end;function kA.UpdateAutopilotTarget()ks()end;function kA.adjustAutopilotTargetIndex(h6)kv(h6)end;function kA.findAtlasIndex(kr)kq(kr)end;function kA.UpdatePosition(kB)local fQ=kq(SavedLocations)if fQ~=-1 then if kB~=nil then SavedLocations[fQ].name=kB;AutopilotTargetIndex=AutopilotTargetIndex-1;kv()else local kC=SavedLocations[fQ]kC.gravity=unit.getClosestPlanetInfluence()kC.position=bv;kC.safe=true end;a2=SavedLocations[fQ].name.." position updated ("..SavedLocations[fQ].planetname..")"else a2="Name Not Found"end end;function kA.AddNewLocation(g4,position,hO,ky)kx(g4,position,hO,ky)end;function kA.ClearCurrentPosition()kw()end;for cP,cQ in pairs(SavedLocations)do table.insert(b[0],cQ)end;km()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;kA.UpdateAutopilotTarget()return kA end;local function kD()local cA={}local function kE(eD)local kF=AutopilotEndSpeed;if not Autopilot then kF=0 end;if not aq then return aS.computeDistanceAndTime(eD,kF,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eD,kF,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function kG(eD)local kF=AutopilotEndSpeed;if not Autopilot then kF=0 end;return aS.computeDistanceAndTime(eD,kF,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local kH=false;local kI=0;function cA.GetAutopilotBrakeDistanceAndTime(eD)return kE(eD)end;function cA.GetAutopilotTBBrakeDistanceAndTime(eD)return kG(eD)end;local function kJ(kK,kL,kM)kL=kL:project_on_plane(kK)kM=kM:project_on_plane(kK)return n(kL:cross(kM):dot(kK),kL:dot(kM))end;local function kN()local function kO()local kP=-1;local kQ=-1;if vBooster then kP=vBooster.getDistance()end;if hover then kQ=hover.getDistance()end;if kP~=-1 and kQ~=-1 then if kP<kQ then return kP else return kQ end elseif kP~=-1 then return kP elseif kQ~=-1 then return kQ else return-1 end end;local kR=kO()local kS=-1;if telemeter_1 then kS=telemeter_1.getDistance()end;if kR~=-1 and kS~=-1 then if kR<kS then return kR else return kS end elseif kR~=-1 then return kR else return kS end end;local function kT(planet,d_,kU)local function kV(kW,dj)local e5=vec3(dj)if kW.id==0 then return setmetatable({latitude=e5.x,longitude=e5.y,altitude=e5.z,id=0,systemId=kW.systemId},MapPosition)end;local e6=e5-kW.center;local aj=e6:len()local dq=aj-kW.radius;local dn=0;local dp=0;if not cq(aj,0)then local e7=n(e6.y,e6.x)dp=e7>=0 and e7 or 2*math.pi+e7;dn=math.pi/2-math.acos(e6.z/aj)end;return setmetatable({latitude=math.deg(dn),longitude=math.deg(dp),altitude=dq,id=kW.id,systemId=kW.systemId},MapPosition)end;local kX=kV(planet,d_)kX="::pos{"..kX.systemId..","..kX.id..","..kX.latitude..","..kX.longitude..","..kX.altitude.."}"if kU then return kX else system.setWaypoint(kX)return true end end;local kY=false;function cA.showWayPoint(planet,d_,kU)return kT(planet,d_,kU)end;function cA.APTick()local function kZ()if bO and not BrakeLanding then local c1=bO[1]local g5,g6=bO[2],bO[3]local k_=math.min(g5,g6 or g5)local l0=k_/bs;local l1=AutoTakeoff and(bs<42 or ao~=-1)local l2=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if l2 and not l1 and(a8*1.5>k_ or l0<1)then BrakeIsOn=true;cm(0)if AltitudeHold then cy()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cB()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if l0<11 then bN=c1.name.." COLLISION "..cG(l0).." / "..ct(k_,2)else bN=c1.name.." collision "..cG(l0)end;if l0<6 then c3("alarm","AL",2)end else bN=false end end;local function l3(bY,l4,l5)local function l6(bY,dM)bY=vec3(bY)dM=vec3(dM):normalize()local d5=bY*dM;return d5.x+d5.y+d5.z end;local l7=0.001;local l8=1;if not aq or not b2 or ao~=-1 or bs<Q then if l5==nil then l5=DampingMultiplier end;if l4==nil then l4=l7 end;bY=vec3(bY):normalize()local l9=vec3()-bY;local la=-l6(l9,core.getConstructWorldOrientationRight())*l8;local lb=-l6(l9,core.getConstructWorldOrientationUp())*l8;if aB==0 then aB=la/2 end;if aC==0 then aC=lb/2 end;if d(la)<0.1 then V=V-la*2 else V=V-(la+(la-aB)*l5)end;if d(lb)<0.1 then U=U+lb*2 else U=U+lb+(lb-aC)*l5 end;aB=la;aC=lb;if d(la)<l4 and d(lb)<l4 then return true end;return false elseif b2 and ao==-1 then bY=br;if l5==nil then l5=DampingMultiplier end;if l4==nil then l4=l7 end;bY=vec3(bY):normalize()local l9=bo-bY;local la=-l6(l9,core.getConstructWorldOrientationRight())*l8;local lb=-l6(l9,core.getConstructWorldOrientationUp())*l8;if aB==0 then aB=la/2 end;if aC==0 then aC=lb/2 end;if d(la)<0.1 then V=V-la*5 else V=V-(la+(la-aB)*l5)end;if d(lb)<0.1 then U=U+lb*5 else U=U+lb+(lb-aC)*l5 end;aB=la;aC=lb;if d(la)<l4 and d(lb)<l4 then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=kN()E=q()b3=E;if CollisionSystem then kZ()end;if antigrav then by=antigrav.getState()==1 end;local lc=1;local ld=1;local le=E-b3;local lf=-math.deg(kJ(bn,br,bo))local lg=math.deg(kJ(bp,br,bo))local h6=bt*-1;b2=aq and lf<-YawStallAngle or lf>YawStallAngle or lg<-PitchStallAngle or lg>PitchStallAngle;local lh=system.getMouseDeltaX()local li=system.getMouseDeltaY()if InvertMouse and not a1 then li=-li end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local jT=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+lh;ah=ah+li end else ag=0;ah=0 end else ag=ag+lh;ah=ah+li;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(li,-100,100)+0.5)*2*lc;V=(-utils.smoothstep(lh,-100,100)+0.5)*2*ld end end end end;local lj=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not lj then a2="Space Speed Engine Shutoff reached"cm(0)end;if not lj and LastIsWarping then if not BrakeIsOn then cD()end;if Autopilot then cB()end end;LastIsWarping=lj;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not kH then BrakeIsOn=true;kH=true elseif not AtmoSpeedAssist and kH then if bs<b7/3.6 then BrakeIsOn=false;kH=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local lk=false;if CustomTarget~=nil and al~=1 then lk=l3(CustomTarget.position-bv,0.1)else lk=l3(vec3(br),0.01)end;b0=true;if lk then cp(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cE()end elseif aq and AtmoSpeedAssist then cm(1)end elseif bs>Q then l3(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then l3(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cE()al=false;an=true else al=false;cB()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cB()an=false end;if VertTakeOff then b0=true;local ll=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then ll=antigrav.getBaseAltitude()end;if as<ll-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=ll then if by then if Autopilot or VectorToTarget then cw()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"c3("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"c3("vtoc","VT")cw()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;cp(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=ll;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local lm=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(lm)local ln=r(vTpitchPID:get(),-1,1)U=ln end end;if IntoOrbit then local l9;local lo=false;local lp=ct(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then l9=CustomTarget.position-bv end;local lq,lr=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local ls=bC;if not bc then local lt=false;local lu=false;cm(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..lp;if be.VectorToTarget then l3(l9:normalize():project_on_plane(bt))lo=bo:dot(l9:project_on_plane(bn):normalize())>0.95 else l3(br)lo=lf<0.5;if bs<150 then lo=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then lt=true else lt=false end;if ls<=bb+1 and ls>=bb-1 then lu=true else lu=false end;if lt and lu and lo then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then l3(l9:normalize():project_on_plane(bt))elseif bs>150 then l3(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and l9:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or l9:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"c3("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cx()cE()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cm(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"c3("orCom","OB")cx()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..lp;bd=true;cp(lr*3.6+1)local lv=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(lv-bu*r(utils.smoothstep(2000-lv,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local lw=2.75;local lx=d(A(lq*lw))local ly=lx%50;if ly>0 then lx=lx-ly+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..lp;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..lp;lx=lx*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..lp;lx=lx*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..lp;ba=-65;local lz=utils.map(bu,-150,-400,1,0.55)lx=lx*lz end;cp(e(lx))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local lA=ba-bB;OrbitPitchPID:inject(lA)local lB=r(OrbitPitchPID:get(),-0.5,0.5)U=lB end end;if Autopilot and ar==0 and not al then local function lC(bT,orbit)system.print(bT)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cm(0)P=false;a2=bT;c3("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cx()end end;local lD,lE=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local lF=(CustomTarget.position-ac.center):normalize()local lG=lF:project_on_plane((ac.center-bv):normalize()):normalize()local lH=ac.center+lG*(ac.radius+AutopilotTargetOrbit)local lI=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-lH):len()<(bv-lI):len()then lD=lH else lD=lI;AutopilotEndSpeed=0 end;AutopilotTargetCoords=lD;aX.showWayPoint(ac,AutopilotTargetCoords)lE=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;lE=true;AutopilotRealigned=true;TargetSet=true;lD=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=lD end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local lF=(bv+br*100000-ac.center):normalize()local lG=lF:project_on_plane((ac.center-bv):normalize()):normalize()if lG:len()<1 then lF=(bv+bo*100000-ac.center):normalize()lG=lF:project_on_plane((ac.center-bv):normalize()):normalize()end;lD=ac.center+lG*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=lD;TargetSet=true;lE=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(lD)-bv):len()local bZ,b_,c0=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(c1)if c1.noAtmosphericDensityAltitude>0 then return c1.radius+c1.noAtmosphericDensityAltitude else return c1.radius+c1.surfaceMaxAltitude*1.5 end end)local c2=b_;if c0~=nil and b_~=nil then c2=math.min(c0,b_)end;if c2~=nil and c2<AutopilotDistance and bZ.name==ac.name then AutopilotDistance=c2 end;local lk=true;local lJ=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local iF=ct(lJ)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iF..'"}')local a8,a9;if not TurnBurn then a8,a9=kE(bs)else a8,a9=kG(bs)end;if bs>50 and AutopilotAccelerating then local l9=vec3(lD)-bv;local lK=r(math.deg(kJ(bn,br:normalize(),l9:normalize()))*bs/500,-90,90)local lL=r(math.deg(kJ(bp,br:normalize(),l9:normalize()))*bs/500,-90,90)if d(lK)<20 and d(lL)<20 then lK=lK*2;lL=lL*2 end;if d(lK)<2 and d(lL)<2 then lK=lK*2;lL=lL*2 end;local lf=-math.deg(kJ(bn,bo,br:normalize()))local lg=-math.deg(kJ(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(lL-lg)local lM=r(apPitchPID:get(),-1,1)U=U+lM;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(lK-lf)local lN=r(apYawPID:get(),-1,1)V=V+lN;lE=true;if d(lK)>2 or d(lL)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c3("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c3("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then l3((lD-bv):normalize())end;if lJ<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(lJ)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bZ,c2=bX((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if bZ~=nil and ac.name~=bZ.name and c2<AutopilotDistance then a2="Collision with "..bZ.name.." in "..ct(c2).."\nClear LOS to continue."ai=5;kY=true else kY=false;a2=""end end end;if not kY then if not AutopilotCruising and not AutopilotBraking and not lE then lk=l3((lD-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then lk=l3(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cm(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local lO=unit.getThrottle()if AtmoSpeedAssist then lO=K end;local lP=99999;local k4=-vec3(core.getWorldAcceleration()):dot(br:normalize())local lQ=r(br:dot((lD-bv):normalize()),0,bs)if lQ>0 or k4>0 then lP=aS.computeTravelTime(lQ,k4,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or lO==0 and P or warmup/4>lP then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c3("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cm(0)end;local lR=AutopilotDistance;if lR<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<kI and bI>2000 then cB()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;kI=bI else kI=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c3("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cm(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cm(1,true)end;local _,lr=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local l9;if CustomTarget~=nil then l9=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then lC("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=lr and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then lC("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif CustomTarget.planetname~="Space"and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c3("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=lr then if CustomTarget~=nil then if br:normalize():dot(l9:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c3("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else lC("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else lC("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then lC("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local lR=AutopilotDistance;if lR<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<kI and bI>2000 then cB()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;kI=bI else kI=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c3("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local lO=unit.getThrottle()if AtmoSpeedAssist then lO=K end;if lO>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c3("apAcc","AP")end;AutopilotCruising=false end else if lk then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif lk and not kY then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c3("apAcc","AP")end;if not P then cm(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"c3("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cm(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local lL=0;local eH=bv+vec3(unit.getMasterPlayerRelativePosition())local lS=eH-bv;local lT=vec3(lS):project_on(bo):len()local lU=vec3(lS):project_on(bp):len()local aj=y(lT*lT+lU*lU)l3(lS:normalize())local lV=40;local lW=aj<lV;local lX=100;local lY=r((aj-lV)/2,10,lX)U=0;local lk=d(V)<0.1;if lk and bs<lY and not lW then BrakeIsOn=false;lL=-20 else BrakeIsOn=true;lL=0 end;local lZ=0;if d(lL-bB)>lZ then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(lL-bB)local lM=pitchPID:get()U=lM end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l_=LastMaxBrakeInAtmo;if l_ then l_=l_*r(bs/100,0.1,1)*ar else l_=LastMaxBrake end;if ar<0.01 then l_=LastMaxBrake end;local m0=bo:project_on_plane(bt):normalize():dot(br)local m1=vec3(core.getWorldAirFrictionAcceleration())local m2=m1:len()*av;if m0>100 then a8,a9=aS.computeDistanceAndTime(m0,100,av,0,0,l_)local m3,m4=aS.computeDistanceAndTime(100,0,av,0,0,l_*0.55)a8=a8+m3 else a8,a9=aS.computeDistanceAndTime(m0,0,av,0,0,l_*0.55)end;local lv=HoldAltitude-as-bu;local m5=200+bs;if Reentry or al then minMax=2000+bs end;local m6=1;if AutoTakeoff then m6=r(bs/100,0.1,1)end;local lL=(utils.smoothstep(lv,-m5,m5)-0.5)*2*MaxPitch*m6;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then lL=(utils.smoothstep(lv,-m5*r(20-19*ar*10,1,20),m5*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*m6 end;if not AltitudeHold then lL=0 end;if LockPitch~=nil then if bM and not IntoOrbit then lL=LockPitch else LockPitch=nil end end;b0=true;local m7=U;if Reentry then local m8=e(b7)local m9,ma=aS.computeDistanceAndTime(bs,m8/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)m9=m9==-1 and 5000 or m9;local mb=as-(planet.noAtmosphericDensityAltitude+m9)local mc=as>planet.noAtmosphericDensityAltitude+m9*1.35;if mc then lL=ReEntryPitch;if bs<=m8/3.6 and bs>m8/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cm(1)end elseif bA and not mc and not aq then cp(m8,true)end;if bA then if bs>m8/3.6 and not mc then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then lL=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;lL=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and mc then b0=true elseif not mc then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=m8)then cp(m8)end;if bs<m8/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then l3(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local l9;if bK then if type(bK)=="table"then l9=bK elseif bK<3 and bK>0 then l9=-bt:cross(br)*5000 elseif bK>=3 then l9=bt:cross(br)*5000 elseif bK<0 then l9=br*25000 end elseif CustomTarget~=nil then l9=CustomTarget.position-bv else l9=ac.center-bv end;local lK=math.deg(kJ(bt:normalize(),br,l9))*2;local md=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local me=1000+bs;local mf=(utils.smoothstep(lv-bu*10,-me,me)-0.5)*2*MaxPitch;local mg=r(90-mf,0,180)b4=r(lK*2,-mg,mg)local mh=lK;lK=r(r(lK,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(md)+4*(bB-lL)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local mi=1;if b4~=0 then mi=d(md/b4)end;mi=(90-r(d(b4-bC),0,90))/90;local mj=lL;if d(bC)>90 then mj=-mj end;lL=mi*r(r(mj*math.cos(md),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(mh)*math.sin(md),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;lK=r(lK,-YawStallAngle*0.80,YawStallAngle*0.80)end;local mk=lf-lK;if bK and d(mk)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cy()end;bK=nil;c3("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(mk)local lN=r(yawPID:get(),-1,1)V=V+lN elseif aq and ao>-1 or bs<minRollVelocity then l3(l9)elseif b2 and ar>0.01 then if(lf<-YawStallAngle or lf>YawStallAngle)and ar>0.01 then l3(br)end;if(lg<-PitchStallAngle or lg>PitchStallAngle)and ar>0.01 then lL=r(bB-lg,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local ll=planet:getAltitude(CustomTarget.position)local mb=l9:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and mb<=a8 and(br:project_on_plane(bt):normalize():dot(l9:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cm(0)if AltitudeHold then cy()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(m0<0.1 or mb<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<mb)then if not by then c3("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=mb end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local l9=CustomTarget.position-bv;local ll=planet:getAltitude(CustomTarget.position)local mb=y(l9:len()^2-(as-ll)^2)local l_=LastMaxBrakeInAtmo;if l_ then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,l_/2)StrongBrakes=true;if mb<=a8+bs*le/2 and br:project_on_plane(bt):normalize():dot(l9:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cE()end end;LastDistanceToTarget=mb end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cx()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then l3(br)lL=r(bB-lg,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=m7;local kS=-1;if BrakeLanding then lL=0;local ml=false;local mm=30;if aT~=nil and aT>0 then local mn=r(ar,0.4,2)local l_=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*mn;local mo=aT*mn+l_-jT;local mp=l_/2-jT;local mq=bs-y(d(mp/2)*20/(0.5*av))*utils.sign(mp)if mq<0 then mq=0 end;local mr;if bs>100 then local ms,_=aS.computeDistanceAndTime(bs,100,av,0,0,l_)local mt,_=aS.computeDistanceAndTime(100,0,av,0,0,y(l_))mr=ms+mt else mr=aS.computeDistanceAndTime(bs,0,av,0,0,y(l_))end;if mr<20 then BrakeIsOn=false else local mu=0;if mq>100 then local mv,_=aS.computeDistanceAndTime(mq,100,av,0,0,mo)local mw,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*mn+y(l_)-jT)mu=mv+mw else mu,_=aS.computeDistanceAndTime(mq,0,av,0,0,aT*mn+y(l_)-jT)end;mu=(mu+15+bs*le)*1.1;local mx=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if mx then local ll=planet:getAltitude(CustomTarget.position)local my=as-ll-100;local l9=CustomTarget.position-bv;local mz=y(l9:len()^2-(as-ll)^2)if mz>100 then mx=false elseif my<=mu or mu==-1 then BrakeIsOn=true;ml=true else BrakeIsOn=false;ml=true end end;if not mx and CalculateBrakeLandingSpeed then if mu>=mm then BrakeIsOn=true else BrakeIsOn=false end;ml=true end end end;if not bA then cm(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;kS=ao;if kS>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()c3("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-h6)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not ml then BrakeIsOn=true elseif not ml then BrakeIsOn=false end end;if AutoTakeoff or am then local bZ,c0,b_;if AutopilotTargetCoords~=nil then bZ,c0,b_=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(c1)return c1.radius+c1.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cm(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(lL)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cm(0)elseif am then cm(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bZ==nil or bZ.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cm(0)end;AutopilotAccelerating=true end end;local mA=ao>-1;local mB=bB;if(VectorToTarget or am or bK)and not mA and bs>minRollVelocity and ar>0.01 then local md=math.rad(d(bC))mB=bB*d(math.cos(md))+lg*math.sin(md)end;local mC=r(lL-mB,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then mC=r(lL-mB,-85,MaxPitch)elseif ar<0.01 then mC=r(lL-mB,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or mA or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(mC)local lM=pitchPID:get()U=U+lM end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=kN()return cA end;function script.onStart()local mD={}local mE={}local mF=false;local function mG()local function mH(mI)local mJ=dbHud_1.hasKey;for cP,cQ in pairs(mI)do if mJ(cQ)then local d5=g(dbHud_1.getStringValue(cQ))if d5~=nil then _G[cQ]=d5;mF=true end end end end;if dbHud_1 then if not useTheseSettings then mH(c9())coroutine.yield()mH(c)else mH(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;mF=false end;coroutine.yield()if mF then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function mK()local function mL(mM,mN)if mM>mN then mN=mM end;local mO,mP=0,0;if ContainerOptimization>0 then mO=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then mP=FuelTankOptimization*0.05 end;mN=mN*(1-(mO+mP))return mN end;local mQ=core.getElementNameById;local mR=fuelX~=0 and fuelY~=0;for cP in pairs(at)do local type=core.getElementTypeById(at[cP])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cP])),'^.*vertical.*$')and core.getElementForwardById(at[cP])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cP])),'^.*vertical.*$')then local mS=core.getElementForwardById(at[cP])if mS[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local mT=j(at[cP])if mT>10000 then G=110 elseif mT>1000 then G=55 elseif mT>150 then G=27 end end;aL=aL+j(at[cP])if mR and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local mT=j(at[cP])local k0=l(at[cP])local mM=0;local gW=q()if type=="Atmospheric Fuel Tank"then local mN=400;local mU=35.03;if mT>10000 then mN=51200;mU=5480 elseif mT>1300 then mN=6400;mU=988.67 elseif mT>150 then mN=1600;mU=182.67 end;mM=k0-mU;if fuelTankHandlingAtmo>0 then mN=mN+mN*fuelTankHandlingAtmo*0.2 end;mN=mL(mM,mN)aI[#aI+1]={at[cP],mQ(at[cP]),mN,mU,mM,gW}end;if type=="Rocket Fuel Tank"then local mN=320;local mU=173.42;if mT>65000 then mN=40000;mU=25740 elseif mT>6000 then mN=5120;mU=4720 elseif mT>700 then mN=640;mU=886.72 end;mM=k0-mU;if fuelTankHandlingRocket>0 then mN=mN+mN*fuelTankHandlingRocket*0.1 end;mN=mL(mM,mN)aK[#aK+1]={at[cP],mQ(at[cP]),mN,mU,mM,gW}end;if type=="Space Fuel Tank"then local mN=600;local mU=35.03;if mT>10000 then mN=76800;mU=5480 elseif mT>1300 then mN=9600;mU=988.67 elseif mT>150 then mN=2400;mU=182.67 end;mM=k0-mU;if fuelTankHandlingSpace>0 then mN=mN+mN*fuelTankHandlingSpace*0.2 end;mN=mL(mM,mN)aJ[#aJ+1]={at[cP],mQ(at[cP]),mN,mU,mM,gW}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function mV()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cQ in pairs(door)do cQ.toggle()end end;if switch then for _,cQ in pairs(switch)do cQ.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cQ in pairs(forcefield)do cQ.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function mW(mX,mY,mZ,m_,ch,ci,n0,n1,n2,n3)local n4={enableName=mX,disableName=mY,width=mZ,height=m_,x=ch,y=ci,toggleVar=n0,toggleFunction=n1,drawCondition=n2,hovered=false}if n3 then table.insert(mE,n4)else table.insert(mD,n4)end;return n4 end;local function n5(n6)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif n6=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif n6=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif n6=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c9(n6)showHud=false else bE={}showHud=true end end;local function n7()bD=not bD;if bD then aF=mE;a2="Hold SHIFT to see Settings"bF=showHud else aF=mD;a2="Hold SHIFT to see Control Buttons"n5()showHud=bF end end;local function n8(cQ)_G[cQ]=not _G[cQ]if _G[cQ]then a2=cQ.." set to true"else a2=cQ.." set to false"end;if cQ=="showHud"then bF=_G[cQ]elseif cQ=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function n9()local na=50;local nb=340;local ch=500;local ci=aH/2-400;local nc=0;for cP,cQ in pairs(c9("boolean"))do if type(_G[cQ])=="boolean"then mW(cQ,cQ,nb,na,ch,ci,function()return _G[cQ]end,function()n8(cQ)end,function()return true end,true)ci=ci+na+20;if nc==9 then ch=ch+nb+20;ci=aH/2-400;nc=0 else nc=nc+1 end end end;mW("Control View","Control View",nb,na,10,aH/2-500,function()return true end,n7,function()return true end,true)mW("View Handling Settings",'Hide Handling Settings',nb,na,10,aH/2-(500-na),function()return showHandlingVariables end,function()n5("handling")end,function()return true end,true)mW("View Hud Settings",'Hide Hud Settings',nb,na,10,aH/2-(500-na*2),function()return showHudVariables end,function()n5("hud")end,function()return true end,true)mW("View Physics Settings",'Hide Physics Settings',nb,na,10,aH/2-(500-na*3),function()return showPhysicsVariables end,function()n5("physics")end,function()return true end,true)end;local function nd()local function kx()local position=bv;local g4=planet.name..". "..#SavedLocations;if bP[1]then local dh,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dh~=nil and dh~=""then g4=g4 .." "..bP[1].getConstructName(dh)end end;return aW.AddNewLocation(g4,position,false,true)end;local function ne()TurnBurn=not TurnBurn end;local function nf(ng)if ng==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function nh()aW.UpdatePosition()end;local function kw()aW.ClearCurrentPosition()end;local function ni(fQ)local g4=AutopilotTargetName;if fQ~=nil and type(fQ)=="number"then if fQ==0 then return"None"end;g4=bG[fQ].name end;if g4==nil then g4=CustomTarget.name end;if g4==nil then g4="None"end;return g4 end;local function nj(fQ)return"Engage Autopilot: "..ni(fQ)end;local function nk(fQ)return"Disable Autopilot: "..ni(fQ)end;local function nl()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)c3("folOn","F")else c3("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local na=50;local nb=260;local nm=mW("Enable Brake Toggle","Disable Brake Toggle",nb,na,aG/2-nb/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)mW("Align Prograde","Disable Prograde",nb,na,aG/2-nb/2-50-nm.width,aH/2-na+380,function()return ProgradeIsOn end,function()nf(1)end)mW("Align Retrograde","Disable Retrograde",nb,na,aG/2-nb/2+nm.width+50,aH/2-na+380,function()return RetrogradeIsOn end,nf,function()return ar==0 end)apbutton=mW(nj,nk,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function nn(no)local fQ=bS+no;if fQ>#bG then fQ=fQ-#bG-1 end;if fQ<0 then fQ=#bG+fQ end;return fQ end;apExtraButtons={}for i=0,10 do local button=mW(function(cs)local fQ=nn(cs.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..ni(fQ)end;return nj(fQ)end,function(cs)local fQ=nn(cs.apExtraIndex)return nk(fQ)end,600,60,aG/2-600/2,aH/2-60/2-400+60*i,function(cs)local fQ=nn(cs.apExtraIndex)return fQ==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(cs)local fQ=nn(cs.apExtraIndex)local np=AutopilotTargetIndex==fQ;AutopilotTargetIndex=fQ;aW.UpdateAutopilotTarget()cB()if not np and not(Autopilot or VectorToTarget or am or IntoOrbit)then cB()end end,function()return bR end)button.apExtraIndex=i;apExtraButtons[i]=button end;mW("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kx,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)mW("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,nh,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mW("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kw,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)na=60;nb=300;local ch=10;local ci=aH/2-500;mW("Show Help","Hide Help",nb,na,ch,ci,function()return showHelp end,function()showHelp=not showHelp end)ci=ci+na+20;mW("View Settings","View Settings",nb,na,ch,ci,function()return true end,n7)local ci=aH/2-300;mW("Enable Turn and Burn","Disable Turn and Burn",nb,na,ch,ci,function()return TurnBurn end,ne)mW("Horizontal Takeoff Mode","Vertical Takeoff Mode",nb,na,ch+nb+20,ci,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)ci=ci+na+20;mW("Show Orbit Display","Hide Orbit Display",nb,na,ch,ci,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)mW("Engage Orbiting","Cancel Orbiting",nb,na,ch+nb+20,ci,function()return IntoOrbit end,cx,function()return ar==0 and bM end)ci=ci+na+20;mW("Glide Re-Entry","Cancel Glide Re-Entry",nb,na,ch,ci,function()return Reentry end,function()al=1;nf(1)end,function()return planet.hasAtmosphere and not aq end)mW("Parachute Re-Entry","Cancel Parachute Re-Entry",nb,na,ch+nb+20,ci,function()return Reentry end,cE,function()return planet.hasAtmosphere and not aq end)ci=ci+na+20;mW("Engage Follow Mode","Disable Follow Mode",nb,na,ch,ci,function()return a0 end,nl,function()return m()==1 end)mW("Enable Repair Arrows","Disable Repair Arrows",nb,na,ch+nb+20,ci,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)ci=ci+na+20;if not ExternalAGG then mW("Enable AGG","Disable AGG",nb,na,ch,ci,function()return by end,cF,function()return antigrav~=nil end)end;mW(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,nb*2,na,ch,ci,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)ci=ci+na+20;mW(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,nb*2,na,ch,ci,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;local function nq()local nr={}local function ns()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local nt={[1]=4480,[6]=4480,[7]=6270}for nu,nw in pairs(b)do b[nu][0]=ns()b[nu][0].systemId=nu;nr[nu]={}for nx,planet in pairs(b[nu])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=nt[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=nu;planet.bodyId=planet.id;nr[nu][nx]=planet end end;aQ=cR()aR=aQ(nr)aS=eb()aU=eF()aY=f2()aV=gf()aW=kk()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})mG()coroutine.yield()mK()coroutine.yield()aX=kD()mV()n9()nd()aF=mD;coroutine.yield()nq()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;c3("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cQ in pairs(door)do cQ.toggle()end end;if switch then for _,cQ in pairs(switch)do cQ.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cQ in pairs(forcefield)do cQ.toggle()end end;cL()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;c3("stop","SU")end;function script.onTick(ny)local nz=nil;if ny=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"c3("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif ny=="tenthSecond"then local function nA()local nB=system.createData;local nC=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=nC(panelInterplanetary,"value")interplanetaryHeaderText=nB('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=nC(panelInterplanetary,"value")widgetDistanceText=nB('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=nC(panelInterplanetary,"value")widgetTravelTimeText=nB('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=nC(panelInterplanetary,"value")widgetMaxMassText=nB('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=nC(panelInterplanetary,"value")widgetTargetOrbitText=nB('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=nC(panelInterplanetary,"value")widgetCurBrakeDistanceText=nB('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=nC(panelInterplanetary,"value")widgetCurBrakeTimeText=nB('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=nC(panelInterplanetary,"value")widgetMaxBrakeDistanceText=nB('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=nC(panelInterplanetary,"value")widgetMaxBrakeTimeText=nB('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=nC(panelInterplanetary,"value")widgetTrajectoryAltitudeText=nB('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function nD()t(panelInterplanetary)panelInterplanetary=nil end;local function nE()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eD=bs;local lO=unit.getThrottle()/100;if AtmoSpeedAssist then lO=K end;local nF,nG=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*lO,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,nH;if not TurnBurn and eD>0 then _,nH=aX.GetAutopilotBrakeDistanceAndTime(eD)else _,nH=aX.GetAutopilotTBBrakeDistanceAndTime(eD)end;local nI=0;local nJ=0;if AutopilotCruising or not Autopilot and eD>5 then nJ=aS.computeTravelTime(eD,0,AutopilotDistance)elseif a8+nF<AutopilotDistance then nI=AutopilotDistance-(a8+nF)nJ=aS.computeTravelTime(8333.0556,0,nI)else local nK=(AutopilotDistance-a8)/nF;nF=AutopilotDistance-a8;nG=nG*nK end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return nJ elseif AutopilotBraking then return nH elseif AutopilotCruising then return nJ+nH else return nG+a9+nJ end end;local function nL(jT,nM)if jT==nil then jT=core.g()end;jT=A(jT,5)if nM~=nil and nM or(nz==nil or nz~=jT)then local eD=bq:len()local nN=g(unit.getData()).maxBrake;if nN~=nil and nN>0 and aq then nN=nN/r(eD/100,0.1,1)nN=nN/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+nN)/2 else LastMaxBrakeInAtmo=nN end end end;if nN~=nil and nN>0 then LastMaxBrake=nN end;nz=jT end end;nL(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then cp(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then nA()end;if AutopilotTargetName~=nil then local nO=CustomTarget~=nil;local nP=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()nP=nP>1000000 and A(nP/1000000,2).." kTons"or A(nP/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=nE()if nO and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iF=ct(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..iF..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cG(travelTime)..'", "unit":""}')iF=ct(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iF..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cG(a9)..'", "unit":""}')iF=ct(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iF..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cG(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",nP)..'", "unit":""}')iF=ct(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iF..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cm(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else nD()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif ny=="oneSecond"then local function nQ(h2)local function nR()for cP,cQ in pairs(c9())do dbHud_1.setStringValue(cQ,h(nil))end;for cP,cQ in pairs(c)do dbHud_1.setStringValue(cQ,h(nil))end;a2="Databank wiped"ai=5 end;local nS=0;aD=""local nT=aL;local nU=0;local nV=0;local nW=0;local g_=0;local h0=""local nX=core.getElementHitPointsById;for cP in pairs(at)do local mT=0;local nY=0;nY=j(at[cP])mT=nX(at[cP])nU=nU+mT;if mT<nY then if mT==0 then nW=nW+1 else nV=nV+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cP]))local ch=position.x;local ci=position.y;local fx=position.z;table.insert(aA,core.spawnArrowSticker(ch,ci,fx+1,"down"))table.insert(aA,core.spawnArrowSticker(ch,ci,fx+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(ch+1,ci,fx,"north"))table.insert(aA,core.spawnArrowSticker(ch+1,ci,fx,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(ch-1,ci,fx,"south"))table.insert(aA,core.spawnArrowSticker(ch-1,ci,fx,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(ch,ci-1,fx,"east"))table.insert(aA,core.spawnArrowSticker(ch,ci-1,fx,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(ch,ci+1,fx,"west"))table.insert(aA,core.spawnArrowSticker(ch,ci+1,fx,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cP])end elseif aM and#aA>0 and aA[11]==at[cP]then for gV in pairs(aA)do core.deleteSticker(aA[gV])end;aA={}end end;nS=e(nU/nT*100)if nS<100 then if nS>0 and nS<WipeDamage then nR()end;h2[#h2+1]=cg(0,0,"","pbright txt")g_=e(nS*2.55)h0=f("rgb(%d,%d,%d)",255-g_,g_,0)if nS<100 then h2[#h2+1]=cg("50%",1035,"Elemental Integrity: "..nS.."%","txtbig txtmid","fill:"..h0)if nW>0 then h2[#h2+1]=cg("50%",1055,"Disabled Modules: "..nW.." Damaged Modules: "..nV,"txtbig txtmid","fill:"..h0)elseif nV>0 then h2[#h2+1]=cg("50%",1055,"Damaged Modules: "..nV,"txtbig txtmid","fill:"..h0)end end end end;local function nZ()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function n_()local gW=q()local ie=bs;local o0=gW-au;if ie>1.38889 then ie=ie/1000;local o1=ie*(gW-au)TotalDistanceTravelled=TotalDistanceTravelled+o1;ad=ad+o1 end;ae=ae+o0;TotalFlightTime=TotalFlightTime+o0;au=gW end;n_()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()nZ()local h2={}aV.ExtraData(h2)if ShowOdometer then h2=aV.DrawOdometer(h2,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then nQ(h2)end;ak=table.concat(h2,"")collectgarbage("collect")elseif ny=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local d5=g(dbHud_1.getStringValue("SavedLocations"))if d5~=nil then _G["SavedLocations"]=d5;local fQ=-1;local kz;for cP,cQ in pairs(SavedLocations)do if cQ.name and cQ.name=="SatNav Location"then fQ=cP;break end end;if fQ~=-1 then kz=SavedLocations[fQ]fQ=-1;for cP,cQ in pairs(b[0])do if cQ.name and cQ.name=="SatNav Location"then fQ=cP;break end end;if fQ>-1 then b[0][fQ]=kz end;aW.UpdateAtlasLocationsList()a2=kz.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif ny=="msgTick"then local h2={}aV.DisplayMessage(h2,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif ny=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif ny=="hudTick"then if not planet then return end;local function o2(h2)local o3=e(r(aj/(aG/4)*255,0,255))h2[#h2+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+o3,e(J+0.5)-o3,e(I+0.5)-o3)end;local function o4()for _,cQ in pairs(aF)do if cQ.hovered then if not cQ.drawCondition or cQ.drawCondition(cQ)then cQ.toggleFunction(cQ)end;cQ.hovered=false end end end;local function o5()local function o6(o7,o8,ch,ci,mZ,m_)if o7>=ch and o7<=ch+mZ and o8>=ci and o8<=ci+m_ then return true else return false end end;local ch=ag+aG/2;local ci=ah+aH/2;for _,cQ in pairs(aF)do cQ.hovered=o6(ch,ci,cQ.x,cQ.y,cQ.width,cQ.height)end;if bR then local o9=false;for _,cs in ipairs(apExtraButtons)do if cs.hovered then o9=true;break end end;if apbutton.hovered then o9=true end;bR=o9 else bR=apbutton.hovered;if not bR then bS=AutopilotTargetIndex end end end;local function oa(h2)local function ob(h2,oc,hover,ch,ci,ew,od,oe,of,og,oh,button)if type(og)=="function"then og=og(button)end;if type(oh)=="function"then oh=oh(button)end;h2[#h2+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",ch,ci,ew,od)if oc then h2[#h2+1]=f("%s'",oe)else h2[#h2+1]=of end;if hover then h2[#h2+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else h2[#h2+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;h2[#h2+1]=" rx='5'></rect>"h2[#h2+1]=f("<text x='%f' y='%f' font-size='24' fill='",ch+ew/2,ci+od/2+5)if oc then h2[#h2+1]="black"else h2[#h2+1]="white"end;h2[#h2+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oc then h2[#h2+1]=f("%s</text>",og)else h2[#h2+1]=f("%s</text>",oh)end end;local oi=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local oj=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local ok=ob;for _,cQ in pairs(aF)do local mY=cQ.disableName;local mX=cQ.enableName;if type(mY)=="function"then mY=mY(cQ)end;if type(mX)=="function"then mX=mX(cQ)end;if not cQ.drawCondition or cQ.drawCondition(cQ)then ok(h2,cQ.toggleVar(cQ),cQ.hovered,cQ.x,cQ.y,cQ.width,cQ.height,oj,oi,mY,mX,cQ)end end end;local ol=A(ResolutionX/2,0)local om=A(ResolutionY/2,0)local h2={}aV.HUDPrologue(h2)if showHud then aV.UpdateHud(h2)else if AlwaysVSpd then aV.DrawVerticalSpeed(h2,as)end;aV.DisplayOrbitScreen(h2)aV.DrawWarnings(h2)end;if bD and bE~={}then aV.DrawSettings(h2)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(h2)h2[#h2+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(h2,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(h2)end end;if x()==0 then if m()==1 and a1 then if not AltIsOn then o5()oa(h2)end;if not aZ and not a_ then local on=table.concat(h2,"")h2={}h2[#h2+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h2[#h2+1]=on;h2[#h2+1]="</body>"aZ=true;h2[#h2+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(h2,"")system.setScreen(content)elseif a_ then local on=table.concat(h2,"")h2={}h2[#h2+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h2[#h2+1]=on;h2[#h2+1]="</body>"end;if not aZ then h2[#h2+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ol,om,ag,ah)end else o4()end else if not a1 and m()==0 then o4()if aj>DeadZone then if DisplayDeadZone then o2(h2)end end elseif not AltIsOn or AltIsOn and a1 then o5()oa(h2)end;h2[#h2+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ol,om,ag,ah)end;h2[#h2+1]=[[</svg></body>]]content=table.concat(h2,"")elseif ny=="apTick"then aX.APTick()elseif ny=="radarTick"then aY.UpdateRadar()elseif ny=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oo(op,lY)local oq=vec3()local os=vec3()if op==axisCommandId.longitudinal then oq=vec3(core.getConstructOrientationForward())os=bo elseif op==axisCommandId.vertical then oq=vec3(core.getConstructOrientationUp())os=bn elseif op==axisCommandId.lateral then oq=vec3(core.getConstructOrientationRight())os=bp else return vec3()end;local ot=vec3(core.getWorldGravity())local ou=ot:dot(os)local ov=vec3(core.getWorldAirFrictionAcceleration())local ow=ov:dot(os)local ox=bq:dot(oq)local oy=lY*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(oy-ox)local oz=targetSpeedPID2:get()local oA=(oz-ow-ou)*os;return oA end;local function oB(op,lY)local oq=vec3()local os=vec3()if op==axisCommandId.longitudinal then oq=vec3(core.getConstructOrientationForward())os=bo elseif op==axisCommandId.vertical then oq=vec3(core.getConstructOrientationUp())os=bn elseif op==axisCommandId.lateral then oq=vec3(core.getConstructOrientationRight())os=bp else return vec3()end;local ot=vec3(core.getWorldGravity())local ou=ot:dot(os)local ov=vec3(core.getWorldAirFrictionAcceleration())local ow=ov:dot(os)local ox=bq:dot(oq)local oy=lY*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(oy-ox)local oz=targetSpeedPID:get()local oA=(oz-ow-ou)*os;return oA end;local function oC(oD,h5,kp)local oE=oD:cross(kp):normalize_inplace()local hS=math.acos(r(oE:dot(-h5),-1,1))*constants.rad2deg;if oE:cross(-h5):dot(kp)<0 then hS=-hS end;return hS end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cm(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local oF=r(T+U+system.getControlDeviceForwardInput(),-1,1)local oG=r(W+Z+system.getControlDeviceYawInput(),-1,1)local oH=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local oI=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local oJ=bC/180*math.pi;local oK=math.cos(oJ)local oL=math.sin(oJ)bB=oC(bt,bo,bp*oK+bn*oL)local oM=br:normalize()local oN=d(bC)local oO=utils.sign(bC)local oP=vec3(core.getWorldAngularVelocity())local oQ=oF*pitchSpeedFactor*bp+oG*rollSpeedFactor*bo+oH*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local oR=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and oR>0 or ar>0.0 and oR<autoRollRollThreshold and autoRollPreference)and oG==0 and d(bB)<85 then local oS=b4;local oT=autoRollFactor;if ar==0 then oT=oT/4;b4=0;oS=0 end;if rollPID==nil then rollPID=pid.new(oT*0.01,0,oT*0.1)end;rollPID:inject(oS-bC)local oU=rollPID:get()oQ=oQ+oU*bo end end;local oV=1;local oW=0;local oX=1;local oY=system.getMouseWheel()if oY>0 then bU()elseif oY<0 then bU(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local oZ=throttlePID:get()N=r(oZ,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local o_=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=o_ end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local p0=''local p1=vec3()local p2=oo(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",p2,oW)local p3='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then p3=p3 ..ExtraLongitudeTags end;local p4=s:getAxisCommandType(axisCommandId.longitudinal)local p5=s:composeAxisAccelerationFromThrottle(p3,axisCommandId.longitudinal)local p6=oB(axisCommandId.lateral,LeftAmount*1000)p0=p0 ..' , '.."lateral airfoil , lateral ground "p1=p1+p6;if p1:len()>constants.epsilon then a:setEngineForceCommand(p0,p1,oW,'','','',oX)end;a:setEngineForceCommand(p3,p5,oV)local p7='thrust analog vertical fueled 'local p8='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then p8=p8 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then p7=p7 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(p7,p2,oV)else a:setEngineForceCommand(p7,vec3(),oV)end;if LeftAmount~=0 then a:setEngineForceCommand(p8,p6,oV)else a:setEngineForceCommand(p8,vec3(),oV)end;if oI==0 then oI=L end;local p9=-oI*(brakeSpeedFactor*br+brakeFlatFactor*oM)a:setEngineForceCommand('brake',p9)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local lY=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-lY/3.6)local o_=r(brakePID:get(),0,1)oI=r(oI+o_,0,1)end;local p9=-oI*(brakeSpeedFactor*br+brakeFlatFactor*oM)a:setEngineForceCommand('brake',p9)local p0=''local p1=vec3()local pa=false;local p3='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then p3=p3 ..ExtraLongitudeTags end;local p4=s:getAxisCommandType(axisCommandId.longitudinal)if p4==axisCommandType.byThrottle then local p5=s:composeAxisAccelerationFromThrottle(p3,axisCommandId.longitudinal)a:setEngineForceCommand(p3,p5,oV)elseif p4==axisCommandType.byTargetSpeed then local p5=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)p0=p0 ..' , '..p3;p1=p1+p5;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pa=true end end;local p8='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then p8=p8 ..ExtraLateralTags end;local pb=s:getAxisCommandType(axisCommandId.lateral)if pb==axisCommandType.byThrottle then local pc=s:composeAxisAccelerationFromThrottle(p8,axisCommandId.lateral)a:setEngineForceCommand(p8,pc,oV)elseif pb==axisCommandType.byTargetSpeed then local p6=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)p0=p0 ..' , '..p8;p1=p1+p6 end;local p7='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then p7=p7 ..ExtraVerticalTags end;local pd=s:getAxisCommandType(axisCommandId.vertical)if pd==axisCommandType.byThrottle then local p2=s:composeAxisAccelerationFromThrottle(p7,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(p7,p2,oV,'airfoil','ground','',oX)else a:setEngineForceCommand(p7,vec3(),oV)a:setEngineForceCommand('airfoil vertical',p2,oV,'airfoil','','',oX)a:setEngineForceCommand('ground vertical',p2,oV,'ground','','',oX)end elseif pd==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),oV)end;local pe=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)p0=p0 ..' , '..p7;p1=p1+pe end;if p1:len()>constants.epsilon then if Y~=0 or pa or d(oM:dot(bo))<0.5 then p0=p0 ..', brake'end;a:setEngineForceCommand(p0,p1,oW,'','','',oX)end end;local pf=torqueFactor*(oQ-oP)local pg=vec3(core.getWorldAirFrictionAngularAcceleration())pf=pf-pg;a:setEngineTorqueCommand('torque',pf,oV,'airfoil','','',oX)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local eD=bq:len()local ph=0.15;if not bA then local pi=s:getTargetSpeed(axisCommandId.longitudinal)if eD*3.6>pi*(1-ph)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eD*3.6<pi*(1-ph)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lO=unit.getThrottle()if AtmoSpeedAssist then lO=K*100 end;local lY=lO/100;if k==0 then lY=lY*MaxGameVelocity;if eD>=lY*(1-ph)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eD<lY*(1-ph)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local m8=e(b7)lY=lY*m8/3.6;if eD>=lY*(1-ph)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eD<lY*(1-ph)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gc=coroutine.status(beginSetup)if gc=="suspended"then local cn,gd=coroutine.resume(beginSetup)if gd then system.print("ERROR STARTUP: "..gd)end elseif gc=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pj)local function pk(bV)local D=1;local function pl(pm,bV)local pn={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local po=pm;for _,cQ in ipairs(pn)do if bV and po>cQ then pm=cQ elseif pm<cQ and not bV then pm=cQ;break end end;return pm end;if bV then D=-1 end;if not ExternalAGG and by then if a1 and bV then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=pl(bg,bV)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=pl(HoldAltitude,bV)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function pp(pq)if not aq then a2="Flight Assist in Atmo only"return end;local cW=type(pq)if bK==nil then if cW=="table"then if Autopilot or VectorToTarget then cB()end;c3("180On","BR")elseif pq==1 then c3("bnkLft","BR")else c3("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cy()if cW~="table"then pq=pq+1 end end;bK=pq else c3("180Off","BR")bK=nil end end;if pj=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cm(0)if vBooster or hover then if aq and ao==-1 then c3("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then c3("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then c3("grOut","LG",1)a.control.extendLandingGears()end else if S then c3("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pj=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pj=="forward"then T=T-1 elseif pj=="backward"then if AltIsOn then pp(-br*5000)else T=T+1 end elseif pj=="left"then if AltIsOn then pp(1)else W=W-1 end elseif pj=="right"then if AltIsOn then pp(3)else W=W+1 end elseif pj=="yawright"then X=X-1 elseif pj=="yawleft"then X=X+1 elseif pj=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pj=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pj=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pj=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pj=="groundaltitudeup"then pk()elseif pj=="groundaltitudedown"then pk(true)elseif pj=="option1"then toggleView=false;if AltIsOn and a1 then local pr=""for i=1,#passengers do pr=pr.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..pr)return end;aW.adjustAutopilotTargetIndex()elseif pj=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif pj=="option3"then local function ps()aE=not aE;if not aE then c3("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else c3("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local pr=""for i=1,#ships do pr=pr.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..pr)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ps()toggleView=false elseif pj=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cB()elseif pj=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then c3("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c3("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif pj=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local pt=shield_1.getVentingCooldown()if pt>0 then a2="Cannot vent again for "..pt.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cy()elseif pj=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif pj=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()c3("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c3("gsOn","GS")end;toggleView=false elseif pj=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cm(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then c3("gyOn","GA")else c3("gyOff","GA")end end;toggleView=false elseif pj=="lshift"then bR=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif pj=="brake"then if BrakeToggleStatus or AltIsOn then cD()elseif not BrakeIsOn then cD()else BrakeIsOn=true end elseif pj=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pj=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif pj=="stopengines"then local function pu()if E-F<1.5 then c3("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;pu()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cm(0)else cm(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then cp(AtmoSpeedLimit)else cp(MaxGameVelocity*3.6)end end end elseif pj=="speedup"then bU()elseif pj=="speeddown"then bU(true)elseif pj=="antigravity"and not ExternalAGG then if antigrav~=nil then cF()end end end;function script.onActionStop(pj)local function pv()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if pj=="forward"then T=0 elseif pj=="backward"then T=0 elseif pj=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif pj=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif pj=="yawright"then X=0 elseif pj=="yawleft"then X=0 elseif pj=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pj=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pj=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pj=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pj=="groundaltitudeup"then pv()toggleView=false elseif pj=="groundaltitudedown"then pv()toggleView=false elseif pj=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif pj=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cD()else BrakeIsOn=false end end elseif pj=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pj)local function pw(bV)local D=1;if bV then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function px(bV)local D=1;if bV then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if pj=="groundaltitudeup"then if not a1 then pw()end elseif pj=="groundaltitudedown"then if not a1 then pw(true)end elseif pj=="speedup"then px()elseif pj=="speeddown"then px(true)end end;function script.onInputText(cj)local function py(pz,eH,hO)local function pA(eH)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d3='::pos{'..B..','..B..','..B..','..B..','..B..'}'local dg,dh,dn,dp,dq=o(eH,d3)if dg=="0"and dh=="0"then return vec3(z(dn),z(dp),z(dq))end;dp=math.rad(dp)dn=math.rad(dn)local planet=b[z(dg)][z(dh)]local e8=math.cos(dn)local pB=vec3(e8*math.cos(dp),e8*math.sin(dp),math.sin(dn))return planet.center+(planet.radius+dq)*pB end;local position=pA(eH)return aW.AddNewLocation(pz,position,hO)end;local i;local pC,pD=nil,nil;local pE="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(cj," ")pC=cj;if i~=nil then pC=string.sub(cj,0,i-1)pD=string.sub(cj,i+1)end;if pC=="/help"or pC=="/commands"then for k6 in string.gmatch(pE,"([^\n]+)")do system.print(k6)end;return elseif pC=="/setname"then if pD==nil or pD==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(pD)else a2="Select a saved target to rename first"end elseif shield_1 and pC=="/resist"then if pD==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d3=B..', '..B..', '..B..', '..B;local pF,pG,pH,pI=o(pD,d3)if pI==nil or pF+pG+pH+pI>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(pF,pG,pH,pI)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif pC=="/addlocation"or string.find(cj,"::pos")~=nil then local hO=false;local pz="0-Temp"if pD==nil or pD==""then pD=pC;hO=true end;i=string.find(pD,"::")if not hO then pz=string.sub(pD,1,i-2)end;local eH=string.sub(pD,i)py(pz,eH,hO)elseif pC=="/agg"then if pD==nil or pD==""then a2="Usage: /agg targetheight"return end;pD=z(pD)if pD<1000 then pD=1000 end;AntigravTargetAltitude=pD;a2="AGG Target Height set to "..pD elseif pC=="/G"then if pD==nil or pD==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pD=="dump"then for cP,cQ in pairs(c9())do if type(_G[cQ])=="boolean"then if _G[cQ]==true then system.print(cQ.." true")else system.print(cQ.." false")end elseif _G[cQ]==nil then system.print(cQ.." nil")else system.print(cQ.." ".._G[cQ])end end;return end;i=string.find(pD," ")local pJ=string.sub(pD,0,i-1)local pK=string.sub(pD,i+1)for cP,cQ in pairs(c9())do if cQ==pJ then a2="Variable "..pJ.." changed to "..pK;local pL=type(_G[cQ])if pL=="number"then pK=z(pK)if cQ=="AtmoSpeedLimit"then b7=pK end elseif pL=="boolean"then if string.lower(pK)=="true"then pK=true else pK=false end end;_G[cQ]=pK;return end end;a2="No such global variable: "..pJ elseif pC=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif pC=="/copydatabank"then if dbHud_2 then cL(true)else a2="Spare Databank required to copy databank"end elseif pC=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(dh)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(dh)if bP[1]and CollisionSystem then if#bL>650 then dh=tostring(dh)bL[dh]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
