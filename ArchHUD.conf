name: ArchHud - Archaegeo v0.744 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.744;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},AtmoSpeedAssist={set=function(L)t=L end,get=function()return t end},ForceAlignment={set=function(L)u=L end,get=function()return u end},DisplayDeadZone={set=function(L)v=L end,get=function()return v end},showHud={set=function(L)w=L end,get=function()return w end},hideHudOnToggleWidgets={set=function(L)x=L end,get=function()return x end},ShiftShowsRemoteButtons={set=function(L)y=L end,get=function()return y end},SetWaypointOnExit={set=function(L)z=L end,get=function()return z end},AlwaysVSpd={set=function(L)A=L end,get=function()return A end},BarFuelDisplay={set=function(L)B=L end,get=function()return B end},voices={set=function(L)C=L end,get=function()return C end},alerts={set=function(L)D=L end,get=function()return D end},CollisionSystem={set=function(L)E=L end,get=function()return E end},AbandonedRadar={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},FullRadar={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)aa=L end,get=function()return aa end},AutopilotInterplanetaryThrottle={set=function(L)a0=L end,get=function()return a0 end},warmup={set=function(L)a1=L end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingSpace={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingRocket={set=function(L)a4=L end,get=function()return a4 end},ContainerOptimization={set=function(L)a5=L end,get=function()return a5 end},FuelTankOptimization={set=function(L)a6=L end,get=function()return a6 end},AutoShieldPercent={set=function(L)a7=L end,get=function()return a7 end},EmergencyWarp={set=function(L)a8=L end,get=function()return a8 end}}ab=1920;ac=1080;ad=400;ae=130;af=224;ag=255;ah=255;ai=0;aj=0;ak=960;al=540;am=1300;an=540;ao=1525;ap=325;aq=550;ar=540;as=30;at=700;au=1750;av=250;aw=1750;ax=350;ay=50;az=250;aA=0;aB=30;aC=100;aD={ResolutionX={set=function(L)ab=L end,get=function()return ab end},ResolutionY={set=function(L)ac=L end,get=function()return ac end},circleRad={set=function(L)ad=L end,get=function()return ad end},SafeR={set=function(L)ae=L end,get=function()return ae end},SafeG={set=function(L)af=L end,get=function()return af end},SafeB={set=function(L)ag=L end,get=function()return ag end},PvPR={set=function(L)ah=L end,get=function()return ah end},PvPG={set=function(L)ai=L end,get=function()return ai end},PvPB={set=function(L)aj=L end,get=function()return aj end},centerX={set=function(L)ak=L end,get=function()return ak end},centerY={set=function(L)al=L end,get=function()return al end},throtPosX={set=function(L)am=L end,get=function()return am end},throtPosY={set=function(L)an=L end,get=function()return an end},vSpdMeterX={set=function(L)ao=L end,get=function()return ao end},vSpdMeterY={set=function(L)ap=L end,get=function()return ap end},altMeterX={set=function(L)aq=L end,get=function()return aq end},altMeterY={set=function(L)ar=L end,get=function()return ar end},fuelX={set=function(L)as=L end,get=function()return as end},fuelY={set=function(L)at=L end,get=function()return at end},shieldX={set=function(L)au=L end,get=function()return au end},shieldY={set=function(L)av=L end,get=function()return av end},radarX={set=function(L)aw=L end,get=function()return aw end},radarY={set=function(L)ax=L end,get=function()return ax end},DeadZone={set=function(L)ay=L end,get=function()return ay end},OrbitMapSize={set=function(L)az=L end,get=function()return az end},OrbitMapX={set=function(L)aA=L end,get=function()return aA end},OrbitMapY={set=function(L)aB=L end,get=function()return aB end},soundVolume={set=function(L)aC=L end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=0.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(L)aE=L end,get=function()return aE end},speedChangeSmall={set=function(L)aF=L end,get=function()return aF end},MouseXSensitivity={set=function(L)aG=L end,get=function()return aG end},MouseYSensitivity={set=function(L)aH=L end,get=function()return aH end},autoRollFactor={set=function(L)aI=L end,get=function()return aI end},rollSpeedFactor={set=function(L)aJ=L end,get=function()return aJ end},autoRollRollThreshold={set=function(L)aK=L end,get=function()return aK end},minRollVelocity={set=function(L)aL=L end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(L)aM=L end,get=function()return aM end},torqueFactor={set=function(L)aN=L end,get=function()return aN end},pitchSpeedFactor={set=function(L)aO=L end,get=function()return aO end},yawSpeedFactor={set=function(L)aP=L end,get=function()return aP end},brakeSpeedFactor={set=function(L)aQ=L end,get=function()return aQ end},brakeFlatFactor={set=function(L)aR=L end,get=function()return aR end},DampingMultiplier={set=function(L)aS=L end,get=function()return aS end},hudTickRate={set=function(L)aT=L end,get=function()return aT end},ExtraEscapeThrust={set=function(L)aU=L end,get=function()return aU end},ExtraLongitudeTags={set=function(L)aV=L end,get=function()return aV end},ExtraLateralTags={set=function(L)aW=L end,get=function()return aW end},ExtraVerticalTags={set=function(L)aX=L end,get=function()return aX end}}aZ=j;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={VertTakeOff={set=function(L)b9=L end,get=function()return b9 end},VertTakeOffEngine={set=function(L)a_=L end,get=function()return a_ end},SpaceTarget={set=function(L)bx=L end,get=function()return bx end},BrakeToggleStatus={set=function(L)aZ=L end,get=function()return aZ end},BrakeIsOn={set=function(L)b0=L end,get=function()return b0 end},RetrogradeIsOn={set=function(L)b1=L end,get=function()return b1 end},ProgradeIsOn={set=function(L)b2=L end,get=function()return b2 end},Autopilot={set=function(L)b3=L end,get=function()return b3 end},TurnBurn={set=function(L)b4=L end,get=function()return b4 end},AltitudeHold={set=function(L)b5=L end,get=function()return b5 end},BrakeLanding={set=function(L)b6=L end,get=function()return b6 end},Reentry={set=function(L)b8=L end,get=function()return b8 end},AutoTakeoff={set=function(L)b7=L end,get=function()return b7 end},HoldAltitude={set=function(L)ba=L end,get=function()return ba end},AutopilotAccelerating={set=function(L)bb=L end,get=function()return bb end},AutopilotBraking={set=function(L)bd=L end,get=function()return bd end},AutopilotCruising={set=function(L)be=L end,get=function()return be end},AutopilotRealigned={set=function(L)bc=L end,get=function()return bc end},AutopilotEndSpeed={set=function(L)bf=L end,get=function()return bf end},AutopilotStatus={set=function(L)bg=L end,get=function()return bg end},AutopilotPlanetGravity={set=function(L)bh=L end,get=function()return bh end},PrevViewLock={set=function(L)bi=L end,get=function()return bi end},AutopilotTargetName={set=function(L)bj=L end,get=function()return bj end},AutopilotTargetCoords={set=function(L)bk=L end,get=function()return bk end},AutopilotTargetIndex={set=function(L)bl=L end,get=function()return bl end},TotalDistanceTravelled={set=function(L)bn=L end,get=function()return bn end},TotalFlightTime={set=function(L)bo=L end,get=function()return bo end},SavedLocations={set=function(L)bp=L end,get=function()return bp end},VectorToTarget={set=function(L)bq=L end,get=function()return bq end},LocationIndex={set=function(L)br=L end,get=function()return br end},LastMaxBrake={set=function(L)bs=L end,get=function()return bs end},LockPitch={set=function(L)bt=L end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(L)bu=L end,get=function()return bu end},AntigravTargetAltitude={set=function(L)bv=L end,get=function()return bv end},LastStartTime={set=function(L)bw=L end,get=function()return bw end},iphCondition={set=function(L)bA=L end,get=function()return bA end},stablized={set=function(L)bB=L end,get=function()return bB end},UseExtra={set=function(L)bC=L end,get=function()return bC end},SelectedTab={set=function(L)bH=L end,get=function()return bH end},saveRoute={set=function(L)bE=L end,get=function()return bE end},apRoute={set=function(L)bF=L end,get=function()return bF end}}local function bI(b,c,bJ,bK,bL)local a=DUSystem;local bM=DUConstruct;bN=bJ()bO=0;bP=0;bQ=false;bR=0;bS=false;bT=false;bU=0;bV=0;bW=0;bX=0;bY=false;bZ=false;b_=false;c0="empty"c1=3;c2=false;c3=0;c4=0;c5=nil;c6=0;c7=0;c8=0;c9=false;ca=false;cb=false;cc=-1;cd=bL()>0;ce=bL()cf=b.getAltitude()cg=DUConstruct.getMass()ch=nil;ci=ab;cj=ac;ck={}cl={}cm={}cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=false;cx=false;cy=p;cz=false;cA=V;cB=nil;cC=0;cD=false;cE=false;cF=false;cG=vec3(bM.getWorldOrientationForward())cH=vec3(bM.getWorldOrientationRight())cI=vec3(bM.getVelocity())cJ=vec3(bM.getWorldVelocity())cK=vec3(cJ):len()cL=vec3(b.getWorldVertical())cM=-cL:dot(cJ)cN=vec3(bM.getWorldPosition())cO=false;cP=false;cQ=true;cR=0;cS=0;cT={}cU=false;cV=50000;cW=nil;cX=c.getClosestPlanetInfluence()>0 or cf>0 and cf<200000;cY=false;cZ=nil;c_=false;d0=0;d1=nil;d2=nil;d3={}d4=90;d5=w;d6=nil;d7=nil;d8={}d9={}da=false;db=nil;dc=0;dd=false;de=bM.getMaxSpeed()if shield then df=bK(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dg(dh)a.print(bN..": "..dh)end;local function di(d,b,c,a,dj,dk,dl,dm,dn)local function dp(dq)return type(dq)=='number'end;local function dr(dq)return type(dl(dq))=='number'end;local function ds(dt)return type(dt)=='table'end;local function du(a)return type(a)=='string'end;local function dv(dw)return ds(dw)and dp(dw.x and dw.y and dw.z)end;local function dx(dy)return ds(dy)and dp(dy.latitude and dy.longitude and dy.altitude and dy.id and dy.systemId)end;local dz=math.pi/180;local dA=180/math.pi;local dB=1e-10;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local utils=utils;local vec3=vec3;local function dE(dq)local dF=string.gsub(string.reverse(dj('%.4f',dq)),'^0*%.?','')return dF==''and'0'or string.reverse(dF)end;local function dG(dH)if dv(dH)then return dj('{x=%.3f,y=%.3f,z=%.3f}',dH.x,dH.y,dH.z)end;if ds(dH)and not getmetatable(dH)then local dI={}local dJ=next(dH)if type(dJ)=='nil'or dJ==1 then dI=dH else for dK,dw in pairs(dH)do local dL=dG(dw)if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end end;return dj('{%s}',table.concat(dI,','))end;if du(dH)then return dj("'%s'",dH:gsub("'",[[\']]))end;return tostring(dH)end;local dM={}dM.__index=dM;dM.__tostring=function(dH,dN)local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)local dI={}for dP,dK in ipairs(dO)do local dL=dG(dH[dK])if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end;if dN then return dj('%s%s',dN,table.concat(dI,',\n'..dN))end;return dj('{%s}',table.concat(dI,','))end;dM.__eq=function(dQ,dR)return dQ.systemId==dR.systemId and dQ.id==dR.id and dn(dQ.radius,dR.radius)and dn(dQ.center.x,dR.center.x)and dn(dQ.center.y,dR.center.y)and dn(dQ.center.z,dR.center.z)and dn(dQ.GM,dR.GM)end;local function dS(dT,dU,dV,dW,dX)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(dV),'Argument 3 (radius) must be a number:'..type(dV))assert(ds(dW),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dW))assert(dr(dX),'Argument 5 (GM) must be a number:'..type(dX))return setmetatable({systemId=dl(dT),id=dl(dU),radius=dl(dV),center=vec3(dW),GM=dl(dX)},dM)end;local dY={}dY.__index=dY;dY.__tostring=function(dg)return dj('::pos{%d,%d,%s,%s,%s}',dg.systemId,dg.id,dE(dg.latitude*dA),dE(dg.longitude*dA),dE(dg.altitude))end;dY.__eq=function(dQ,dR)return dQ.id==dR.id and dQ.systemId==dR.systemId and dn(dQ.latitude,dR.latitude)and dn(dQ.altitude,dR.altitude)and(dn(dQ.longitude,dR.longitude)or dn(dQ.latitude,math.pi/2)or dn(dQ.latitude,-math.pi/2))end;local function dZ(d_,dU,e0,e1,e2)local dT=d_;if du(d_)and not e1 and not e2 and not dU and not e0 then dT,dU,e0,e1,e2=e3(d_,dD)assert(dT,'Argument 1 (position string) is malformed.')else assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(e0),'Argument 3 (latitude) must be in degrees:'..type(e0))assert(dr(e1),'Argument 4 (longitude) must be in degrees:'..type(e1))assert(dr(e2),'Argument 5 (altitude) must be in meters:'..type(e2))end;dT=dl(dT)dU=dl(dU)e0=dl(e0)e1=dl(e1)e2=dl(e2)if dU==0 then return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=dU,systemId=dT},dY)end;return setmetatable({latitude=dz*dk(e0,-90,90),longitude=dz*(e1%360),altitude=e2,id=dU,systemId=dT},dY)end;local e4={}e4.__index=e4;e4.__tostring=function(dH,dN)local e5=dN and dN..'  'local e6={}local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)for dP,e7 in ipairs(dO)do e8=dH[e7]local e9=dM.__tostring(e8,e5)if dN then table.insert(e6,dj('[%s]={\n%s\n%s}',e7,e9,dN))else table.insert(e6,dj('  [%s]=%s',e7,e9))end end;if dN then return dj('\n%s%s%s',dN,table.concat(e6,',\n'..dN),dN)end;return dj('{\n%s\n}',table.concat(e6,',\n'))end;local function ea(eb)local e={}local pid;for dP,dw in pairs(eb)do local dU=dw.planetarySystemId;if type(dU)~='number'then error('Invalid planetary s ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary s IDs: '..dU..' and '..pid)end;local ec=dw.bodyId;if type(ec)~='number'then error('Invalid body ID: '..tostring(ec))elseif e[ec]then error('Duplicate body ID: '..tostring(ec))end;setmetatable(dw.center,getmetatable(vec3.unit_x))e[ec]=setmetatable(dw,dM)pid=dU end;return setmetatable(e,e4)end;ed={}local function ee(eb)return setmetatable({galaxyAtlas=eb or{}},ed)end;ed.__index=function(dt,L)if type(L)=='number'then local a=dt.galaxyAtlas[L]return ea(a)end;return rawget(ed,L)end;ed.__pairs=function(dH)return function(dt,dK)local ef,eg=next(dt,dK)return ef,eg and ea(eg)end,dH.galaxyAtlas,nil end;ed.__tostring=function(dH)local eh={}for dP,ei in pairs(dH or{})do local ej=ei:getPlanetarySystemId()local ek=e4.__tostring(ei,'    ')table.insert(eh,dj('  [%s]={%s\n  }',ej,ek))end;return dj('{\n%s\n}\n',table.concat(eh,',\n'))end;ed.BodyParameters=dS;ed.MapPosition=dZ;ed.PlanetarySystem=ea;function ed.createBodyParameters(dT,dU,el,em,en,eo,ep)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(el),'Argument 3 (surfaceArea) must be a number:'..type(el))assert(ds(em),'Argument 4 (aPosition) must be an array or vec3:'..type(em))assert(ds(en),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(en))assert(dr(eo),'Argument 6 (altitude) must be in meters:'..type(eo))assert(dr(ep),'Argument 7 (gravityAtPosition) must be number:'..type(ep))local dV=dm(el/4/math.pi)local c8=dV+eo;local eq=vec3(em)+c8*vec3(en)local dX=ep*c8*c8;return dS(dT,dU,dV,eq,dX)end;ed.isMapPosition=dx;function ed:getPlanetarySystem(d_)if L==nil then L=0 end;if eg==nil then eg=0 end;local dT=d_;if dx(d_)then dT=d_.systemId end;if type(dT)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(eg)~=e4 then a=ea(a)end;return a end end end;function e4:sizeCalculator(er)return 1.05*er.radius end;function e4:castIntersections(es,et,eu,ev,ew,ex)local ey={}if ew then for dP,er in pairs(ew)do table.insert(ey,er)end else ey=d3 end;if not ex then table.sort(ey,function(ez,eA)local eB=ez.center;local eC=eA.center;return(eB.x-es.x)^2+(eB.y-es.y)^2+(eB.z-es.z)^2<(eC.x-es.x)^2+(eC.y-es.y)^2+(eC.z-es.z)^2 end)end;local eD=et:normalize()for dP,er in ipairs(ey)do local eE=er.center-es;local dV;if eu then dV=eu(er)else dV=self:sizeCalculator(er)end;local eF=eE:dot(eD)local eG=eF^2-(eE:len2()-dV^2)if eG>=0 then local eH=dm(eG)local eI=eF+eH;local eJ=eF-eH;if eJ>0 then return er,eI,eJ elseif eI>0 then return er,eI,nil end end end;return nil,nil,nil end;function e4:closestBody(eK)assert(type(eK)=='table','Invalid coordinates.')local eL,er;local eM=vec3(eK)for dP,eN in pairs(self)do local eO=(eN.center-eM):len2()if(not er or eO<eL)and eN.name~="Space"then er=eN;eL=eO end end;return er end;function e4:convertToBodyIdAndWorldCoordinates(d_)local eP=d_;if du(d_)then eP=dZ(d_)end;if eP.id==0 then return 0,vec3(eP.latitude,eP.longitude,eP.altitude)end;local eN=self:getBodyParameters(eP)if eN then return eP.id,eN:convertToWorldCoordinates(eP)end end;function e4:getBodyParameters(d_)local dU=d_;if dx(d_)then dU=d_.id end;assert(dr(dU),'Argument 1 (id) must be a number:'..type(dU))return self[dU]end;function e4:getPlanetarySystemId()local dP,dw=next(self)return dw and dw.systemId end;function dM:convertToMapPosition(dW)assert(ds(dW),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dW))local eQ=vec3(dW)if self.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=self.systemId},dY)end;local eR=eQ-self.center;local c8=eR:len()local e2=c8-self.radius;local e0=0;local e1=0;if not dn(c8,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/c8)end;return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=self.id,systemId=self.systemId},dY)end;function dM:convertToWorldCoordinates(d_)local eP=du(d_)and dZ(d_)or d_;if eP.id==0 then return vec3(eP.latitude,eP.longitude,eP.altitude)end;assert(dx(eP),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eP.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eP.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eU=math.cos(eP.latitude)return self.center+(self.radius+eP.altitude)*vec3(eU*math.cos(eP.longitude),eU*math.sin(eP.longitude),math.sin(eP.latitude))end;function dM:getAltitude(dW)return(vec3(dW)-self.center):len()-self.radius end;function dM:getDistance(dW)return(vec3(dW)-self.center):len()end;function dM:getGravity(dW)local eV=self.center-vec3(dW)local eW=eV:len2()return self.GM/eW*eV/dm(eW)end;return setmetatable(ed,{__call=function(dP,...)return ee(...)end})end;local function eX(d,b,c,a,dm,eY)local co={}local bM=100000000/3600;local eZ=bM*bM;local e_=100;function co.computeAccelerationTime(f0,f1,f2)local f3=bM*math.asin(f0/bM)return(bM*math.asin(f2/bM)-f3)/f1 end;function co.computeDistanceAndTime(f0,f2,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f0<=f2;local f9=f5*(f8 and 1 or-1)/f4;local fa=-f7/f4;local fb=f9+fa;if f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local f3=math.asin(f0/bM)local fe=math.pi*(f9/2+fa)local ff=f9*f6;local fg=bM*math.pi;local dw=function(dt)local fh=(fe*dt-ff*math.sin(math.pi*dt/2/f6)+fg*f3)/fg;local fi=math.tan(fh)return bM*fi/dm(fi*fi+1)end;local fj=f8 and function(a)return a>=f2 end or function(a)return a<=f2 end;fd=2*f6;if fj(dw(fd))then local fk=0;while eY(fd-fk)>0.5 do local dt=(fd+fk)/2;if fj(dw(dt))then fd=dt else fk=dt end end end;local fl=f0;local fm=fd/e_;for fn=1,e_ do local fo=dw(fn*fm)fc=fc+(fo+fl)*fm/2;fl=fo end;if fd<2*f6 then return fc,fd end;f0=fl end;local f3=bM*math.asin(f0/bM)local bN=(bM*math.asin(f2/bM)-f3)/fb;local fp=eZ*math.cos(f3/bM)/fb;local c8=fp-eZ*math.cos((fb*bN+f3)/bM)/fb;return c8+fc,bN+fd end;function co.computeTravelTime(f0,f1,c8)if c8==0 then return 0 end;if f1>0 then local f3=bM*math.asin(f0/bM)local fp=eZ*math.cos(f3/bM)/f1;return(bM*math.acos(f1*(fp-c8)/eZ)-f3)/f1 end;if f0==0 then return-1 end;assert(f0>0,'Acceleration and initial speed are both zero.')return c8/f0 end;return co end;local function fq(d,b,c,a,dj,dk,dl,dm,dn)local vec3=vec3;local di=di(d,b,c,a,dj,dk,dl,dm,dn)local function du(a)return type(a)=='string'end;local function ds(dt)return type(dt)=='table'end;fr={}fr.__index=fr;function fr:escapeAndOrbitalSpeed(e2)assert(self.body)local c8=e2+self.body.radius;if not dn(c8,0)then local fs=dm(self.body.GM/c8)return dm(2)*fs,fs end;return nil,nil end;function fr:orbitalParameters(d_,ft)assert(self.body)assert(ds(d_)or du(d_))assert(ds(ft))local fu=(du(d_)or di.isMapPosition(d_))and self.body:convertToWorldCoordinates(d_)or vec3(d_)local dw=vec3(ft)local fv=fu-self.body.center;local fw=dw:len2()local fx=fv:len()local fy=self.body.GM;local fz=((fw-fy/fx)*fv-fv:dot(dw)*dw)/fy;local eB=fy/(2*fy/fx-fw)local fA=fz:len()local eD=fz:normalize()local fB=eB*(1-fA)local fC=eB*(1+fA)local fD=fB*eD+self.body.center;local fE=fA<=1 and-fC*eD+self.body.center or nil;local fF=dm(eB*fy*(1-fA*fA))local fG=fE and 2*math.pi*dm(eB^3/fy)local fH=math.acos(fz:dot(fv)/(fA*fx))if fv:dot(dw)<0 then fH=-(fH-2*math.pi)end;local fI=math.acos((math.cos(fH)+fA)/(1+fA*math.cos(fH)))local fJ=fI;if fJ<0 then fJ=fJ+2*math.pi end;local fK=fJ-fA*math.sin(fJ)local fL=0;local fM=0;local fN=0;if fG~=nil then fL=fK/(2*math.pi/fG)fM=fG-fL;fN=fM+fG/2;if fH-math.pi>0 then fM=fL;fN=fM+fG/2 end;if fN>fG then fN=fN-fG end end;return{periapsis={position=fD,speed=fF/fB,circularOrbitSpeed=dm(fy/fB),altitude=fB-self.body.radius},apoapsis=fE and{position=fE,speed=fF/fC,circularOrbitSpeed=dm(fy/fC),altitude=fC-self.body.radius},currentVelocity=dw,currentPosition=fu,eccentricity=fA,period=fG,eccentricAnomaly=fI,meanAnomaly=fK,timeToPeriapsis=fM,timeToApoapsis=fN,trueAnomaly=fH}end;local function fO(fP)local eN=di.BodyParameters(fP.systemId,fP.id,fP.radius,fP.center,fP.GM)return setmetatable({body=eN},fr)end;return setmetatable(fr,{__call=function(dP,...)return fO(...)end})end;local function fQ(d,b,c,a,dbHud_1,e,fR,fS,bK,dl,dm,fT,fU)local function fV(fW)local dg=fX:closestBody(fW)if(fW-dg.center):len()>dg.radius+dg.noAtmosphericDensityAltitude then dg=e[0][0]end;return dg end;local function fY()local function fZ(f_,g0)return f_.name<g0.name end;cT={}for dK,dw in pairs(e[0])do cT[#cT+1]={name=dw.name,index=dK}end;table.sort(cT,fZ)end;local function g1(g2,g3)if not g3 then g3=g4.name end;for dK,dw in pairs(g2)do if dw.name and dw.name==g3 then return dK end end;return-1 end;local function g5()d0=bl;if bl==0 then bj="None"c5=nil;g4=nil;return true end;local g6=cT[bl].index;local g7=e[0][g6]if g7.center then bj=g7.name;c5=cn[0][g6]if g4~=nil then if ce==0 then if fR(g8,g9)~=1 then fS(g8,g9)end;if fR(ga,gb)~=1 then fS(ga,gb)end;if fR(gc,gd)~=1 then fS(gc,gd)end;if fR(ge,gf)~=1 then fS(ge,gf)end;if fR(gg,gh)~=1 then fS(gg,gh)end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end;if fR(gm,gn)~=1 then fS(gm,gn)end end;g4=nil else g4=g7;for dP,dw in pairs(cn[0])do if dw.name==g4.planetname then c5=dw;bj=g4.name;break end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end end;if g4==nil then bk=vec3(c5.center)else bk=g4.position end;if c5.planetname~="Space"then if c5.hasAtmosphere then go=bK(c5.radius*(T-1)+c5.noAtmosphericDensityAltitude)else go=bK(c5.radius*(T-1)+c5.surfaceMaxAltitude)end else go=S end;if g4~=nil and g4.planetname=="Space"then bf=0 else dP,bf=cp(c5):escapeAndOrbitalSpeed(go)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gp(gq)if not b3 and not bq and not ca and not bz and not b8 and not cb then if gq==nil then bl=bl+1;if bl>#cT then bl=0 end else bl=bl-1;if bl<0 then bl=#cT end end;if bl==0 then g5()else local g6=cT[bl].index;local g7=e[0][g6]if g7 and(g7~=nil and g7.name=="Space"or bA=="Custom Only"and g7.center or bA=="No Moons"and string.find(g7.name,"Moon")~=nil)then if gq==nil then gp()else gp(1)end else g5()end end else c0="Disengage autopilot before changing Interplanetary Helper"fT("iph","AP")end end;local function gr()local function gs(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=-1;gv=g1(e[0])if gv>-1 then table.remove(e[0],gv)end;gv=-1;gv=g1(gu)if gv~=-1 then c0=g4.name.." saved location cleared"table.remove(gu,gv)end;gp()fY()return gu end;if string.sub(bj,1,1)=="*"then d8=gs(true)else bp=gs(false)end end;local function gw(gx,fW,gy,gz)local function gA(gt)if gt then gu=d8 else gu=bp end;if dbHud_1 or gy or gt then local dg=fV(fW)local gB={position=fW,name=gx,planetname=dg.name,gravity=b.getGravityIntensity(),safe=gz}if not gy then gu[#gu+1]=gB else for dK,dw in pairs(e[0])do if dw.name and gx==dw.name then table.remove(e[0],dK)end end end;table.insert(e[0],gB)fY()g5()c0="Location saved as "..gx.."("..dg.name..")"return gu else c0="Databank must be installed to save permanent locations"end end;if string.sub(gx,1,1)=="*"then d8=gA(true)else bp=gA(false)end end;local gC={}function gC.UpdateAtlasLocationsList()fY()end;function gC.UpdateAutopilotTarget()g5()end;function gC.adjustAutopilotTargetIndex(gq)gp(gq)end;function gC.findAtlasIndex(g2,g3)return g1(g2,g3)end;function gC.UpdatePosition(gD,gE,gF)local function gG(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=g1(gu)if gv~=-1 then if gD~=nil then if gt then gD="*"..gD end;gu[gv].name=gD;bl=bl-1;gp()elseif gF~=nil then if gF then local gH=cf;if gH<1000 then gH=1000 end;gu[gv].agg=fU(gH,0)c0=gu[gv].name.." AGG Altitude:"..gu[gv].agg.." saved ("..gu[gv].planetname..")"return elseif gF==false then gu[gv].agg=nil;c0=gu[gv].name.." AGG Altitude cleared ("..gu[gv].planetname..")"return end else local gI=gu[gv]if gE then gI.heading=cH:cross(cL)*5000;c0=gu[gv].name.." heading saved ("..gu[gv].planetname..")"return elseif gE==false then gI.heading=nil;c0=gu[gv].name.." heading cleared ("..gu[gv].planetname..")"return end;gI.gravity=b.getGravityIntensity()gI.position=cN;gI.safe=true end;c0=gu[gv].name.." position updated ("..gu[gv].planetname..")"else c0="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gG(true)else gG(false)end end;function gC.AddNewLocation(gx,fW,gy,gz)gw(gx,fW,gy,gz)end;function gC.ClearCurrentPosition()gr()end;for dK,dw in pairs(d9)do table.insert(e[0],dw)end;if gJ then for dK,dw in pairs(gJ)do gC[dK]=dw end end;fY()if bl>#cT then bl=0 end;gC.UpdateAutopilotTarget()return gC end;local function gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)local gO={}local gP={}local gQ={XS=13,S=27,M=55,L=110,XL=221}local gR={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gS={}local gT=0;local gU;local gV;local gW;local gX;local gY={gX}local gZ="Atmo"local g_;local h0;local h1=0;local h2={}local h3;local h4=0;local vec3=vec3;local h5=table.insert;local h6=-4;local h7={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local function h8()local function h9(ha,hb,hc,hd,he,hf,hg,hh)hb,hd,hf,hh=vec3(hb),vec3(hd),vec3(hf),vec3(hh)local hi,hj,hk=ha*ha,hc*hc,he*he;local fw=hd-hb;local hl=fw:normalize()local hm=fw:len()local hn=hf-hb;local ho=(hn-hn:project_on(hl)):normalize()local hp,hq=hn:dot(hl),hn:dot(ho)local hr=hp*hp+hq*hq;local hs=hl:cross(ho)local ht=(hi-hj+hm*hm)/(2*hm)local hu=(hi-hk+hr-2*hp*ht)/(2*hq)local dy=hi-ht^2-hu^2;local hv=dm(dy)local hw=hb+hl*ht+ho*hu+hs*hv;local hx=hb+hl*ht+ho*hu-hs*hv;if eY((hh-hw):len()-hg)<eY((hh-hx):len()-hg)then return hw else return hx end end;local function hy(hz,fx,hA)local hB=hz.pts;local gv=#hB;local hC=hz.ref;if gv>3 then local hD,hE,hF,hG=hB[gv],hB[gv-1],hB[gv-2],hB[gv-3]hz.ref=hA;local fu=h9(hD[1],hD[2],hE[1],hE[2],hF[1],hF[2],hG[1],hG[2])local ht,hu,hv=fu.x,fu.y,fu.z;if ht==ht and hu==hu and hv==hv then ht=ht+hC[1]hu=hu+hC[2]hv=hv+hC[3]local hH=vec3(ht,hu,hv)hz.center=hH;if hz.lastPos then if(hz.lastPos-hH):len()<2 then local hI=(hH-vec3(hA)):len()if eY(hI-fx)<10 then hz.skipCalc=true end end end;hz.lastPos=hH end;hz.pts={}else local hJ={hA[1]-hC[1],hA[2]-hC[2],hA[3]-hC[3]}hB[gv+1]={fx,hJ}end end;if radar_1 or radar_2 then ct.assignRadar()end;if gX then gT=#gX.getConstructIds()if gT>0 then local hK=h3:gmatch('{"constructId[^}]*}[^}]*}')local hL=gX.hasMatchingTransponder;local hM=gX.getConstructKind;local hN=gX.isConstructAbandoned;local hO=gX.getConstructName;local hA={cN["x"],cN["y"],cN["z"]}local hP,hQ=0,0;local hR=cK*10;local cX=cX;gW,gV=0,0;gP={}for dw in hK do local dU,c8,hS=dw:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hT=gQ[hS]c8=dl(c8)if hL(dU)==1 then h5(gP,dU)end;if not cU and warpdrive and c8<a8 and warpdrive.getStatus()==15 then c0="INITIATING WARP"c1=7;warpdrive.initiate()end;if E then local hU=hM(dU)local hV=F and hN(dU)==1;if hV or c8<hR and(hT>27 or hU==4 or hU==6)then gW=gW+1;local gx=hO(dU)local hz=h2[dU]if hz==nil then hT=hT+gN;h2[dU]={pts={},ref=hA,name=gx,i=0,radius=hT,skipCalc=false}hz=h2[dU]end;if not hz.skipCalc then hy(hz,c8,hA)if hV and not hz.abandoned and hz.center then local bN=a.getArkTime()if h4+5<bN then h4=bN;fT("abRdr","RD")end;a.print("Abandoned Construct: "..gx.." ("..hS.." "..gR[hU]..") at estimated ::pos{0,0,"..hz.center.x..","..hz.center.y..","..hz.center.z.."}")c0="Abandoned Radar Contact ("..hS.." "..gR[hU]..") detected"hz.abandoned=true end;hQ=hQ+1 else h5(gS,hz)end end;hP=hP+1;if cX and hP>700 or hQ>70 or(not cX and hP>300 or hQ>30)then coroutine.yield()hP,hQ=0,0 end end end;gV=#gS;if gV>0 and(cK>20 or b6)then local er,hW,hX,hY;local hZ=0;local h_=cn:getPlanetarySystem(0)hY=cJ:normalize()while hZ<gV do coroutine.yield()local i0={table.unpack(gS,hZ,math.min(hZ+75,gV))}er,hW,hX=h_:castIntersections(cN,hY,nil,nil,i0,true)if er and hX then cZ={er,hW,hX}break end;hZ=hZ+75 end;if not er then cZ=nil end else cZ=nil end;gS={}gU=h3:find('identifiedConstructs":%[%]')end end end;local function i1()if gX then gZ="Atmo"if h3:find('worksInAtmosphere":false')then gZ="Space"end end end;function gO.pickType()i1()end;function gO.assignRadar()if radar_2 and h6~=1 then if h6==-1 then if gX==radar_2 then gX=radar_1 else gX=radar_2 end end;gY={gX}h3=gX.getWidgetData()i1()else h3=gX.getWidgetData()end;h6=gX.getOperationalState()end;function gO.UpdateRadar()local i2=coroutine.status(g_)if i2=="suspended"then local dL,i3=coroutine.resume(g_)if i3 then a.print("ERROR UPDATE RADAR: "..i3)end elseif i2=="dead"then g_=coroutine.create(h8)local dL,i3=coroutine.resume(g_)end end;function gO.GetRadarHud(i4,i5,aw,ax)local i6,dh;local dC=gV or 0;if gT>0 then if E then dh=dC.."/"..gW.." Plotted : "..gT-gW.." Ignored"else dh="Radar Contacts: "..gT end;i6=gM(aw,ax,dh,"pbright txtbig txtmid")if#gP>0 then i6=i6 ..gM(i4,i5,"Friendlies In Range","pbright txtbig txtmid")for dK,dw in pairs(gP)do i5=i5+20;i6=i6 ..gM(i4,i5,gX.getConstructName(dw),"pdim txtmid")end end;if gU==nil and h0==nil then h1=1;ct.ToggleRadarPanel()end;if gU~=nil and h0~=nil then ct.ToggleRadarPanel()end;if d7==nil then ct.ToggleRadarPanel()end else if h6~=1 then i6=gM(aw,ax,gZ.." Radar: "..h7[h6],"pbright txtbig txtmid")else i6=gM(aw,ax,"Radar: No "..gZ.." Contacts","pbright txtbig txtmid")end;if d7~=nil then h1=0;ct.ToggleRadarPanel()end end;return i6 end;function gO.GetClosestName(gx)if gX then local dU,dP=gX.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dU~=nil and dU~=""then gx=gx.." "..gX.getConstructName(dU)end end;return gx end;function gO.ToggleRadarPanel()if d7~=nil and h1==0 then gL(d7)d7=nil;if h0~=nil then gL(h0)h0=nil end else if h1==1 then gL(d7)d7=nil;_autoconf.displayCategoryPanel(gY,1,"Periscope","periscope")h0=_autoconf.panels[_autoconf.panels_size]end;if d7==nil then _autoconf.displayCategoryPanel(gY,1,"Radar","radar")d7=_autoconf.panels[_autoconf.panels_size]end;h1=0 end end;function gO.ContactTick()if not i7 then i7=0 end;if bN>i7+10 then c0="Radar Contact"fT("rdrCon","RC")i7=bN end;c.stopTimer("contact")end;function gO.onEnter(dU)if gX and not cd and not cU then c.setTimer("contact",0.1)end end;function gO.onLeave(dU)if gX and E then if#h2>650 then dU=tostring(dU)h2[dU]=nil end end end;local function i8()gX=nil;if radar_2 and radar_2.getOperationalState()==1 then gX=radar_2 else gX=radar_1 end;h6=gX.getOperationalState()gY={gX}h3=gX.getWidgetData()i1()g_=coroutine.create(h8)if i9 then for dK,dw in pairs(i9)do gO[dK]=dw end end end;i8()return gO end;local function ia(shield,e3,bK)local ib={}local ic=shield.getResistancesCooldown()local function id()local ie=shield.isActive()if G then if not cU and ie==0 and shield.isVenting()~=1 then shield.toggle()elseif cU and ie==1 then shield.toggle()end end end;local function ig()local ih=shield.getStressRatioRaw()local ii=0.5999;if ih[1]==0.0 and ih[2]==0.0 and ih[3]==0.0 and ih[4]==0.0 then return end;local ij=shield.setResistances(ii*ih[1],ii*ih[2],ii*ih[3],ii*ih[4])if ij==1 then c0="Shield Resistances updated"else c0="Value Exceeded. Failed to update Shield Resistances"end end;function ib.shieldTick()df=bK(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())id()ic=shield.getResistancesCooldown()if ic==0 and df<a7 then ig()end end;function ib.setResist(ik)if not shield then c0="No shield found"return elseif ik==nil or ic>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD=dC..', '..dC..', '..dC..', '..dC;local il,im,io,ip=e3(ik,dD)if ip==nil or il+im+io+ip>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(il,im,io,ip)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end end;function ib.ventShield()local iq=shield.getVentingCooldown()if iq>0 then c0="Cannot vent again for "..iq.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end end;if ir then for dK,dw in pairs(ir)do ib[dK]=dw end end;return ib end;local function is(d,b,c,a,e,antigrav,hover,shield,warpdrive,it,eY,bK,dj,iu,bL,iv,iw,eT,bJ,dk,ix,fS,fR,gL,iy,dm,fU,gM,fT,iz,iA,iB,iC,iD,iE)local bM=DUConstruct;local iF=9.80665;local iG={}local iH={}local iI={}local iJ={}local iK=nil;local iL=nil;local iM=nil;local iN=false;local iO="none"local iP=""local iQ=55;local iR=0;local iS=0;local iT=nil;local iU=ae;local iV=af;local iW=ag;local iX=[[rgb(]]..bK(iU+0.5)..","..bK(iV+0.5)..","..bK(iW+0.5)..[[)]]local iY=[[rgb(]]..bK(iU*0.9+0.5)..","..bK(iV*0.9+0.5)..","..bK(iW*0.9+0.5)..[[)]]local iZ=0;local i_=0;local j0=""local j1=bJ()local j2=false;local j3=false;local function j4(dw)if ci==1920 then return dw else return fU(ci*dw/1920,0)end end;local function j5(dw)if cj==1080 then return dw else return fU(cj*dw/1080,0)end end;local function j6()return iy()==0 and g~="keyboard"and iw()==0 end;local function j7()local j8="TRAVEL"if not cQ then j8="CRUISE"end;if b3 then j8="AUTOPILOT"end;return j8 end;local i6=""local j9=""local ja=""local jb=1;local jc=2;local jd=3;local je=4;local jf=5;local jg=6;local jh=7;local ji=""local jj=0;local jk=120.0*aT;local jl={}local jm={}local jn={}local jo={}local jp={}local jq={}local jr={}jr["atmofueltank"],jr["spacefueltank"],jr["rocketfueltank"]=0,0,0;local js=0;local function jt(ht,ju,jv,jw,jx,jy)local jz=js;local jA=js+5;if not B then jA=jA+5 end;if iw()==1 and not l then jz=jz-50;jA=jA-50 end;if jv=="ATMO"then ji="atmofueltank"elseif jv=="SPACE"then ji="spacefueltank"else ji="rocketfueltank"end;jj=_G[ji.."_size"]if#jw>0 then for L=1,#jw do local gx=jw[L][jc]local jB=jw[L][jh]for jC=1,jj do if jw[L][jc]==iu(c[ji.."_"..jC].getWidgetData()).name then jB=jC;break end end;local jD=bJ()if jx[L]==nil or jy[L]==nil or jD-jw[L][jg]>jk then local jE;local jF=0;jF=iv(jw[L][jb])-jw[L][je]jE=jw[L][jf]if jE>jF then jr[ji]=jr[ji]+jE-jF end;if jB~=0 then local jG=iu(c[ji.."_"..jB].getWidgetData())jy[L]=jG.percentage;jx[L]=jG.timeLeft;if jx[L]=="n/a"then jx[L]=0 end else jy[L]=bK(0.5+jF*100/jw[L][jd])if jE<=jF then jx[L]=0 else jx[L]=bK(0.5+jF/((jE-jF)/(jD-jw[L][jg])))end end;jw[L][jg]=jD;jw[L][jf]=jF end;if gx==ju then gx=dj("%s %d",jv,L)end;if jB==0 then gx=gx.." *"end;local jH;if jx[L]==0 then jH=""else jH=iC(jx[L])end;if jy[L]~=nil then local jI=bK(jy[L]*2.55)local jJ=dj("rgb(%d,%d,%d)",255-jI,jI,0)local jK=""if jH~=""and jx[L]<120 or jy[L]<5 then jK="red "end;local jL=dj("rgb(%d,%d,%d)",dk(bK((255-jI)/2.55),50,100),dk(bK(jI/2.55),0,50),50)local jM="rgb(196,0,255)"if jv=="ATMO"then jM="rgb(0,188,255)"elseif jv=="SPACE"then jM="rgb(239,255,0)"end;local jN=false;if jO~=jM then jN=true end;jO=jM;if B then if jN then jz=jz-5;jA=jA-5 end;j9=j9 ..dj([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jL,jM,ht,jA,jJ,bK(jy[L]*1.7+0.5)-2,ht+1,jA+1,ht+5,jA+14,gx,jy[L],jH)jz=jz-22;jA=jA-22 else j9=j9 ..gM(ht,jz,gx,jK.."pdim txtfuel")j9=j9 ..gM(ht,jA,dj("%d%% %s",jy[L],jH),"pdim txtfuel","fill:"..jJ)jz=jz+30;jA=jA+30 end end end end;js=jz end;local function jP(jQ,e2)if ao==0 and ap==0 then return end;if e2<200000 and not cd or e2 and cd then local jR=0;if eY(cM)>1 then jR=45*math.log(eY(cM),10)if cM<0 then jR=-jR end end;jQ[#jQ+1]=dj([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ao,ap,bK(cM),bK(jR))end;return jQ end;local function jS(jT)local gq=-cL;jT=jT-jT:project_on(gq)local jU=vec3(0,0,1)jU=jU-jU:project_on(gq)local jV=jU:cross(gq)local jR=jU:angle_between(jT)*constants.rad2deg;if jT:dot(jV)<0 then jR=360-jR end;return jR end;local function jW(jQ,ak,al,jX,jY,cX)if ad==0 then return end;local jZ=ad;local j_=20;local k0=bK(jX)if cX then for L=-45,45,5 do local k1=L;jQ[#jQ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],k1,ak,al)k2=5;if L%15==0 then k2=15 elseif L%10==0 then k2=10 end;jQ[#jQ+1]=dj([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ak,al+jZ+j_-k2,ak,al+jZ+j_)end;jQ[#jQ+1]=gM(ak,al+jZ+j_-35,jY,"pdim txt txtmid")jQ[#jQ+1]=gM(ak,al+jZ+j_-25,k0 .." deg","pdim txt txtmid")jQ[#jQ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-jX,ak,al)jQ[#jQ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ak-5,al+jZ+j_-20,ak+5,al+jZ+j_-20,ak,al+jZ+j_-15)jQ[#jQ+1]="</g>"end;jQ[#jQ+1]=[[<g style="clip-path: url(#headingClip);">]]local k3=k0;if cX then k3=jS(cG)end;local k4=20;local k5=bK(k3)local k6=0;local k7=al+jZ+j_+20;local k8=ak;if jY~="YAW"then k7=j5(130)k8=j4(960)end;local k9=[[<path class="txttick line" d="]]local ka=bK(k5-(k4+10)-k5%5+0.5)for L=ka+70,ka,-5 do local ht=k8-(-L*5+k3*5)if L%10==0 then k6=10;local dC=L;if dC==360 then dC=0 elseif dC>360 then dC=dC-360 elseif dC<0 then dC=dC+360 end;jQ[#jQ+1]=gM(ht,k7+15,dC,"txtmid bright")elseif L%5==0 then k6=5 end;if k6==10 then k9=dj([[%s M %f %f v %d]],k9,ht,k7-5,k6)else k9=dj([[%s M %f %f v %d]],k9,ht,k7-2.5,k6)end end;jQ[#jQ+1]=k9 ..[["/>]]jQ[#jQ+1]=dj([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k8-5,k7-20,k8+5,k7-20,k8,k7-10)if I then if cX then jY="HDG"end;jQ[#jQ+1]=gM(j4(960),j5(100),k5 .."°","dim txt txtmid size14","")jQ[#jQ+1]=gM(j4(960),j5(85),jY,"dim txt txtmid size20","")end;jQ[#jQ+1]=[[</g>]]end;local function kb(jQ,kc,jX,ak,al,cX,kd,fo)if ad==0 then return end;local jZ=ad;local ke=bK(jZ*3/5)if jZ>0 then local kf=bK(kc)local k2=0;local k9=dj([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jX,ak,al)if not cd then k9=dj([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ak,al)end;jQ[#jQ+1]=dj([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jZ-1,ak,al)jQ[#jQ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bK(kf-30-kf%5+0.5),bK(kf+30+kf%5+0.5),5 do if L%10==0 then k2=30 elseif L%5==0 then k2=20 end;local hu=al+-L*5+kc*5;if k2==30 then k9=dj([[%s M %d %f h %d]],k9,ak-ke-k2,hu,k2)if cd then jQ[#jQ+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jX,ak,al,ak-ke+10,hu+4,L)jQ[#jQ+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jX,ak,al,ak+ke-10,hu+4,L)if L==0 or L==180 or L==-180 then jQ[#jQ+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jX,ak,al,ak-ke+20,hu,ke*2-40)end else jQ[#jQ+1]=gM(ak-ke+10,hu,L,"pdim txt txtmid")jQ[#jQ+1]=gM(ak+ke-10,hu,L,"pdim txt txtmid")end;k9=dj([[%s M %d %f h %d]],k9,ak+ke,hu,k2)else k9=dj([[%s M %d %f h %d]],k9,ak-ke-k2,hu,k2)k9=dj([[%s M %d %f h %d]],k9,ak+ke,hu,k2)end end;jQ[#jQ+1]=k9 ..[["/>]]local kg="PITCH"if not cX then kg="REL PITCH"end;if kc>90 and not cd then kc=90-(kc-90)elseif kc<-90 and not cd then kc=-90-(kc+90)end;if jZ>200 then if cd then if fo>iQ then jQ[#jQ+1]=gM(ak,al-15,"Yaw","pdim txt txtmid")jQ[#jQ+1]=gM(ak,al+20,kd,"pdim txt txtmid")end;jQ[#jQ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-jX,ak,al)else jQ[#jQ+1]=dj([[<g transform="rotate(0,%d,%d)">]],ak,al)end;jQ[#jQ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ak-ke+25,al-5,ak-ke+20,al,ak-ke+25,al+5,ak-ke+50,al+4,kf)jQ[#jQ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ak+ke-25,al-5,ak+ke-20,al,ak+ke-25,al+5,ak+ke-30,al+4,kf)jQ[#jQ+1]="</g>"end;local kh=bK(jZ/3)jQ[#jQ+1]=dj([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ak-kh,al,jZ-kh)if not cd and cX then jQ[#jQ+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jX,ak,al,ak-ke+10,al,ke*2-20)end;jQ[#jQ+1]="</g>"if jZ<200 then if cd and fo>iQ then jQ[#jQ+1]=gM(ak,al-jZ,kg,"pdim txt txtmid")jQ[#jQ+1]=gM(ak,al-jZ+10,kf,"pdim txt txtmid")jQ[#jQ+1]=gM(ak,al-15,"Yaw","pdim txt txtmid")jQ[#jQ+1]=gM(ak,al+20,kd,"pdim txt txtmid")else jQ[#jQ+1]=gM(ak,al-jZ,kg,"pdim txt txtmid")jQ[#jQ+1]=gM(ak,al-jZ+15,kf,"pdim txt txtmid")end end end end;local function ki(jQ,e2,cX)local kj=aq;local kk=ar;if kj==0 and kk==0 then return end;local kl=78;local km=19;local kn=cc;if cc~=-1 then jQ[#jQ+1]=gM(kj+kl,kk+km+20,dj("AGL: %.1fm",cc),"pdim altsm txtend")end;if cX and(e2<200000 and not cd or e2 and cd)then table.insert(jQ,dj([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kj-1,kk-4,kl+2,km+6,kj+1,kk-1,kl-4,km))local gv=0;local ko=1;local kp=0;local kq=e2<0;local kr=e2<ks.surfaceMaxAltitude;local kt=9;if kq then kt=0 end;local e2=eY(e2)while gv<6 do local ku=11;local kv=16;local kw=9;local kx=14;local jK="altsm"if gv>2 then kv=kv+3;ku=ku+2;kx=kx+2;kw=kw-6;jK="altbig"end;if kq then jK=jK.." red"elseif kr then jK=jK.." orange"end;local ky=e2/ko%10;local kz=bK(ky)local kA=bK((kz+1)%10)local kB=kp;if gv==0 then kB=ky-kz;if kq then kB=1-kB end end;if kq and(gv==0 or kp~=0)then local gy=kA;kA=kz;kz=gy end;local kC=kv*(kB-1)local kD=kC+kv;local ht=kj+kw+(6-gv)*ku;local hu=kk+kx;jQ[#jQ+1]=gM(ht,hu+kC,kA,jK)jQ[#jQ+1]=gM(ht,hu+kD,kz,jK)gv=gv+1;ko=ko*10;if kz==kt then kp=kB else kp=0 end end;table.insert(jQ,[[</g></g>]])end end;local function kE(ft)local kF=-math.deg(eT(ft.y,ft.z))+180;kF=kF-90;if kF<0 then kF=360+kF end;if kF>180 then kF=-180+kF-180 end;return-kF end;local function kG(ft)local k3=math.deg(eT(ft.y,ft.x))-90;if k3<-180 then k3=360+k3 end;return k3 end;local function kH(jQ,ft,fo,ak,al)if fo>5 and not cd or fo>iQ then local jZ=ad;local kI=20;local kJ=20;local kK=kE(ft)local kL=kG(ft)local kM=14;local kN=kM/2;local kO=-kL/kJ*jZ;local kP=kK/kI*jZ;local ht=ak+kO;local hu=al+kP;local c8=dm(kO^2+kP^2)local kQ=[[<circle
                            cx="]]..ht..[["
                            cy="]]..hu..[["
                            r="]]..kN/kM..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ht..[["
                            cy="]]..hu..[["
                            r="]]..kN..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ht-kM..[[,]]..hu..[[ h ]]..kN..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ht+kN..[[,]]..hu..[[ h ]]..kN..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ht..[[,]]..hu-kM..[[ v ]]..kN..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c8<jZ then jQ[#jQ+1]=kQ else local jR=eT(kP,kO)local kR=4;local kS=ak+jZ*math.cos(jR)local kT=al+jZ*math.sin(jR)jQ[#jQ+1]=dj('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jR*180/math.pi,kS,kT,kS-kR,kT-kR/2,kR*2,kR,kS+kR,kT-kR,kR,kR,-kR,kR)end;if not cd then local kU=vec3(ft)kK=kE(-kU)kL=kG(-kU)kO=-kL/kJ*jZ;kP=kK/kI*jZ;ht=ak+kO;hu=al+kP;c8=dm(kO^2+kP^2)if c8<jZ then local kV=[[<circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ht..[[,]]..hu-kM..[[ v ]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ht..[[,]]..hu..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ht..[[,]]..hu..[[)" />
                                <path
                                    d="M ]]..ht-kN..[[,]]..hu..[[ h ]]..kM..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ht..[[,]]..hu..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ht..[[,]]..hu..[[)"/>]]jQ[#jQ+1]=kV end end end end;local function kW(jQ,j8,kX,kY)if am==0 and an==0 then return end;kX=bK(kX+0.5)local jz=an+10;local jA=an+20;if iw()==1 and not l then jz=55;jA=65 end;local kZ="CRUISE"local c="km/h"local dL=kY;if j8=="TRAVEL"or j8=="AUTOPILOT"then kZ="THROT"c="%"dL=kX;local k_="dim"if kX<0 then k_="red"end;jQ[#jQ+1]=dj([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],k_,am-7,an-50,am,an-50,am,an+50,am-7,an+50,1-eY(kX),am-10,an+50,am-15,an+53,am-15,an+47)end;jQ[#jQ+1]=gM(am+10,jz,kZ,"pbright txtstart")jQ[#jQ+1]=gM(am+10,jA,dj("%.0f %s",dL,c),"pbright txtstart")if cd and t and cQ and bQ then kX=bK(bR*100+0.5)local k_="red"if kX<0 then k_="red"end;jQ[#jQ+1]=dj([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],k_,1-eY(kX),am-10,an+50,am-15,an+53,am-15,an+47)jQ[#jQ+1]=gM(am+10,jz+40,"LIMIT","pbright txtstart")jQ[#jQ+1]=gM(am+10,jA+40,kX.."%","pbright txtstart")end;if cd and t or b8 then jQ[#jQ+1]=gM(am+10,jz-40,"LIMIT: "..cA.." km/h","dim txtstart")elseif not cd and b3 then jQ[#jQ+1]=gM(am+10,jz-40,"LIMIT: "..bK(aa*3.6+0.5).." km/h","dim txtstart")end end;local function l0(jQ,l1)if am==0 and an==0 then return end;local l2=an-10;local l3=am+10;jQ[#jQ+1]=gM(0,0,"","pdim txt txtend")if iw()==1 and not l then l2=75 end;jQ[#jQ+1]=gM(l3,l2,bK(l1).." km/h","pbright txtbig txtstart")end;local function l4(jQ)jQ[#jQ+1]=gM(j4(150),j5(1070),dj("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jQ[#jQ+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jQ[#jQ+1]=gM(j4(960),j5(550),"Warning: Invalid Control Scheme Detected","warnings")jQ[#jQ+1]=gM(j4(960),j5(600),"Keyboard Scheme must be selected","warnings")jQ[#jQ+1]=gM(j4(960),j5(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l5=j4(960)local l6=j5(860)local l7=j5(880)local l8=j5(900)local l9=j5(960)local la=j5(200)local lb=j5(250)local lc=j5(960)if iw()==1 and not l then l6=j5(135)l7=j5(155)l8=j5(175)la=j5(115)lb=j5(95)end;local ld="#222222"local le="white"local lf="dimmer"local lg="pbright"local lh="#110000"local li=ld;local lj=lf;if b0 then local lk=""if type(b0)=="string"then lk="-"..b0 end;jQ[#jQ+1]=gM(l5,l6,"Brake Engaged"..lk,"warnings")lh="#440000"li=le;lj=lg elseif bP>0 then jQ[#jQ+1]=gM(l5,l6,"Auto-Brake Engaged","warnings","opacity:"..bP)end;local ll="#110000"local lm=ld;local ln=lf;if cd and cz and cc==-1 then if not b3 and not bq and not b6 and not cP and not b9 and not b7 then jQ[#jQ+1]=gM(l5,la+50,"** STALL WARNING **","warnings")ll="#ff0000"lm=le;ln=lg;fT("stall","SW",2)end end;if cW then jQ[#jQ+1]=gM(l5,la+90,"Flight Assist in Progress","warnings")end;if ch then jQ[#jQ+1]=gM(l5,lc,"Gyro Enabled","warnings")end;local lo="#111100"local lp=ld;local lq=lf;if bm then lo="#775500"lp=le;lq=lg;if bT then jQ[#jQ+1]=gM(l5,l7,"Gear Extended","warn")else jQ[#jQ+1]=gM(l5,l7,"Landed (G: Takeoff)","warnings")end end;if cc>-1 and(not cP or cf<100)then local lr=iB(d:getTargetGroundAltitude())jQ[#jQ+1]=gM(l5,l8,"Hover Height: "..lr,"warn")end;local ls="#000011"local lt=ld;local lu=lf;if c2 then ls="#0000DD"lt=le;lu=lg;jQ[#jQ+1]=gM(l5,l9+20,"ROCKET BOOST ENABLED","warn")end;local lv="#001100"local lw=ld;local lx=lf;if antigrav and not q and cP and bv~=nil then lv="#00DD00"lw=le;lx=lg;local ly="warnings"if eY(cf-antigrav.getBaseAltitude())<501 then ly="warn"end;jQ[#jQ+1]=gM(l5,la+40,dj("Target Altitude: %d Singularity Altitude: %d",bK(bv),bK(antigrav.getBaseAltitude())),ly)end;if b3 and bj~="None"then jQ[#jQ+1]=gM(l5,la,"Autopilot "..bg,"warn")elseif bt~=nil then jQ[#jQ+1]=gM(l5,la+20,dj("LockedPitch: %d",bK(bt)),"warn")elseif bY then jQ[#jQ+1]=gM(l5,la+20,"Follow Mode Engaged","warn")elseif b8 or cb then jQ[#jQ+1]=gM(l5,la+20,"Re-entry in Progress","warn")end;if b5 or b9 then local lr=iB(ba,2)if b9 then if cP then lr=iB(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jQ[#jQ+1]=gM(l5,la,"VTO to "..lr,"warn")elseif b7 and not bz then if ca then jQ[#jQ+1]=gM(l5,la,"Takeoff to "..bj,"warn")else jQ[#jQ+1]=gM(l5,la,"Takeoff to "..lr,"warn")end;if b0 and not b9 then jQ[#jQ+1]=gM(l5,la+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jQ[#jQ+1]=gM(l5,la,"Altitude Hold: "..dj("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if ce>0.1 then jQ[#jQ+1]=gM(l5,la+20,"Beginning ascent","warn")elseif ce<0.09 and ce>0.05 then jQ[#jQ+1]=gM(l5,la+20,"Aligning trajectory","warn")elseif ce<0.05 then jQ[#jQ+1]=gM(l5,la+20,"Leaving atmosphere","warn")end end;if bz then if cB~=nil then jQ[#jQ+1]=gM(l5,la,cB,"warn")end end;if b6 then if lz then local lA="Brake Landing"if db then lA=lA.."-Aligning"end;if da then lA=lA.."-Drift Limited"end;jQ[#jQ+1]=gM(l5,la,lA,"warnings")else jQ[#jQ+1]=gM(l5,la,"Coast-Landing","warnings")end end;if b2 then jQ[#jQ+1]=gM(l5,la,"Prograde Alignment","crit")end;if b1 then jQ[#jQ+1]=gM(l5,la,"Retrograde Alignment","crit")end;local lB="#110000"local lC=ld;local lD=lf;if cY then lB="#FF0000"lC=le;lD=lg;local type;if string.find(cY,"COLLISION")then type="warnings"else type="crit"end;jQ[#jQ+1]=gM(l5,lb+20,cY,type)elseif ce==0 then local lE,lF=cs.checkLOS(cJ:normalize())if lF~=nil then lD=lg;lB="#FF0000"lC=le;local lr=iB(lF)local lG=co.computeTravelTime(cK,0,lF)local lH="Collision"if lE.noAtmosphericDensityAltitude>0 then lH="Atmosphere"end;jQ[#jQ+1]=gM(l5,lb+20,lE.name.." "..lH.." "..iC(lG).." In "..lr,"crit")end end;if bq and not bz then jQ[#jQ+1]=gM(l5,la+60,lI,"warn")end;local lJ="#111100"local lK=ld;local lL=lf;if d1 and#d1>1 then lJ="#DDDD00"lK=le;lL=lg end;local lM=j4;local lN=j5;local lf="topButton"local lO="topButtonActive"local lP=lf;if b3 or bq or ca or bz then lP=lO end;local lQ=lf;if b2 then lQ=lO end;local lR=lf;if b6 or bm then lR=lO end;local lS=lf;if b5 or bq then lS=lO end;local lT=lf;if b1 then lT=lO end;local lU=lf;if bz or cD and b3 then lU=lO end;if w and I then local lV=lN(30)jQ[#jQ+1]=dj([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lP,lM(960),lN(54),lN(-53),lM(-120),lM(25),lN(50))jQ[#jQ+1]=gM(lM(910),lV,"AUTOPILOT")jQ[#jQ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lM(865),lN(51),lM(-25),lN(-50),lM(-110),lM(25),lN(46))jQ[#jQ+1]=gM(lM(800),lV,"PROGRADE")jQ[#jQ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lM(755),lN(47),lM(-25),lN(-46),lM(-98),lM(44),lN(44))jQ[#jQ+1]=gM(lM(700),lV,"LAND")jQ[#jQ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lS,lM(960),lN(54),lN(-53),lM(120),lM(-25),lN(50))jQ[#jQ+1]=gM(lM(1010),lV,"ALT HOLD")jQ[#jQ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lT,lM(1055),lN(51),lM(25),lN(-50),lM(110),lM(-25),lN(46))jQ[#jQ+1]=gM(lM(1122),lV,"RETROGRADE")jQ[#jQ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lU,lM(1165),lN(47),lM(25),lN(-46),lM(98),lM(-44),lN(44))jQ[#jQ+1]=gM(lM(1220),lV,"ORBIT")jQ[#jQ+1]=[[
                                    </g>
                                </g>]]jQ[#jQ+1]="</g>"end;return jQ end;local function lW(fo)return bK(fU(fo*3.6,0)+0.5).." km/h"end;local function lX(gv)local gx=bj;if gv~=nil and type(gv)=="number"then if gv==0 then return"None"end;gx=cT[gv].name end;if gx==nil then gx=g4.name end;if gx==nil then gx="None"end;return gx end;local function lY(jQ)local lZ=cs.routeWP(true)if not lZ or#lZ==0 then return end;local ht=j4(750)local hu=j5(360)if b3 or bq then jQ[#jQ+1]=gM(ht,hu,"REMAINING ROUTE","pdim txtstart size20")else jQ[#jQ+1]=gM(ht,hu,"LOADED ROUTE","pdim txtstart size20")end;for dK,L in pairs(lZ)do hu=hu+20;jQ[#jQ+1]=gM(ht,hu,dK..". "..lZ[dK],"pdim txtstart size20")end end;local function l_(jQ)local ht=aA+10;local hu=aB+20;local m0={}local m1={"Alt-4: AutoTakeoff to Target"}local m2={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m3={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local m4={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(m0,"--------------DYNAMIC-----------------")if cd then if cc~=-1 then iz(m0,m1)if c5 and ks and c5.name==ks.name then table.insert(m0,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cP then table.insert(m0,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(m0,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(m0,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(m0,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(m0,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(m0,"G: Takeoff to hover height, raise gear")else table.insert(m0,"G: Lowergear and Land")end else iz(m0,m2)table.insert(m0,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(m0,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iz(m0,m3)if shield then table.insert(m0,"Alt-Shift-6: Vent shields")if not G then table.insert(m0,"Alt-Shift-7: Toggle shield off/on")end end end;if g4~=nil then table.insert(m0,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(m0,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(m0,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(m0,"Alt-Spacebar/C will raise/lower target height")table.insert(m0,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cd then table.insert(m0,"LALT+Mousewheel will lower/raise speed limit")end;iz(m0,m4)for L=1,#m0 do hu=hu+12;jQ[#jQ+1]=gM(ht,hu,m0[L],"pdim txtbig txtstart")end end;local function m5(jQ)local m6=aA;local m7=aB;local m8=az;local m9=4;local ma=15;local ht=0;local hu=0;local mb,mc,md,me;local mf;local function mg(type)local gH,bN,fo,mh,jK,mi;if type=="Periapsis"then gH=mf.periapsis.altitude;bN=mf.timeToPeriapsis;fo=mf.periapsis.speed;jK="txtend"mh=12;mi=math.min(ht,m6+m8-ks.radius/md-m9*2)else gH=mf.apoapsis.altitude;bN=mf.timeToApoapsis;fo=mf.apoapsis.speed;mh=-12;jK="txtstart"mi=ht end;if cK<1 then bN=0 end;jQ[#jQ+1]=dj([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mi+mh,hu-5,ht,hu-5)jQ[#jQ+1]=dj([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mi-mh*4,hu+2,ht,hu+2)jQ[#jQ+1]=gM(mi,hu,type,jK)ht=mi-mh*2;hu=hu+ma;local lr=iB(gH)jQ[#jQ+1]=gM(ht,hu,lr,jK)hu=hu+ma;jQ[#jQ+1]=gM(ht,hu,iC(bN),jK)hu=hu+ma;jQ[#jQ+1]=gM(ht,hu,lW(fo),jK)end;local mj=m8*1.5;if bH=="INFO"then mj=25*10 end;if bH~="HIDE"then jQ[#jQ+1]=[[<g class="pbright txtorb txtmid">]]jQ[#jQ+1]=dj('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m8*2,mj,m6,m7)jQ[#jQ+1]=dj([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m8*2,mj,m6,m7)end;local mk=m8*1.5;local ml=m8*2;local mm=mk/2;local mn=m8;local mo=m6+mn;local mp=m7+mm;local mq=m6+ml;local mr=m7+mk;if bH=="ORBIT"then m7=m7+m9;mb=m8/2;me=0;mf={}mf.periapsis={}mf.apoapsis={}if fs~=nil then if fs.periapsis~=nil then mf.periapsis.altitude=fs.periapsis.altitude;mf.periapsis.speed=fs.periapsis.speed end;if fs.apoapsis~=nil then mf.apoapsis.altitude=fs.apoapsis.altitude;mf.apoapsis.speed=fs.apoapsis.speed end;mf.period=fs.period;mf.eccentricity=fs.eccentricity;mf.timeToApoapsis=fs.timeToApoapsis;mf.timeToPeriapsis=fs.timeToPeriapsis;mf.eccentricAnomaly=fs.eccentricAnomaly;mf.trueAnomaly=fs.trueAnomaly end;if mf.periapsis==nil then mf.periapsis={}mf.periapsis.altitude=-ks.radius;mf.periapsis.speed=aa end;if mf.eccentricity==nil then mf.eccentricity=1 end;if mf.apoapsis==nil then mf.apoapsis={}mf.apoapsis.altitude=cf;mf.apoapsis.speed=0 end;if cK<1 then mf.apoapsis.altitude=cf;mf.apoapsis.speed=0 end;if mf.apoapsis.altitude then md=(mf.apoapsis.altitude+mf.periapsis.altitude+ks.radius*2)/(mb*2)mc=(ks.radius+mf.apoapsis.altitude)/md*(1-mf.eccentricity)me=mb-mf.periapsis.altitude/md-ks.radius/md;local ms=math.pi;if mf.period~=nil and mf.period>0 and mf.timeToApoapsis~=nil then ms=mf.eccentricAnomaly;if mf.timeToPeriapsis<mf.timeToApoapsis then ms=2*math.pi-ms end end;if cK<1 or ms~=ms then ms=math.pi end;local mt=-mb*math.cos(ms)+m6+mn+m9;local mu=mc*math.sin(ms)+m7+mm+m9;local mv=""jQ[#jQ+1]='<g clip-path="url(#orbitRect)">'jQ[#jQ+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mv,m6+m8+m9,m7+m8*1.5/2+m9,mb,mc)if mc<1 then jQ[#jQ+1]=dj([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m6+m8+m9-me,m7+m8*1.5/2+m9,mt,mu)end;jQ[#jQ+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m6+m8+m9-me,m7+m8*1.5/2+m9,(ks.radius+ks.noAtmosphericDensityAltitude)/md)jQ[#jQ+1]=dj('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m6+m8+m9-me,m7+m8*1.5/2+m9,(ks.radius+ks.noAtmosphericDensityAltitude)/md)jQ[#jQ+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m6+m8+m9,m7+m8*1.5/2+m9,mb,mc)jQ[#jQ+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m6+m8+m9-me,m7+m8*1.5/2+m9,ks.radius/md)jQ[#jQ+1]='</g>'local mw=math.floor(ks.radius/md+0.5)ht=m6+m8+m9*4+mb;hu=m7+m8*1.5/2+5+m9;if mf.apoapsis~=nil and mf.apoapsis.speed<aa then mg("Apoapsis")end;hu=m7+m8*1.5/2+5+m9;ht=m6+m8-m9*2-mb;if mf.periapsis~=nil and mf.periapsis.speed<aa and mf.periapsis.altitude>0 then mg("Periapsis")end;jQ[#jQ+1]=gM(m6+m8+m9,m7+20+m9,ks.name,"txtorbbig")jQ[#jQ+1]=dj('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mt,mu)jQ[#jQ+1]=[[</g>]]return jQ else jQ[#jQ+1]='<g clip-path="url(#orbitRect)">'local mx=""local my=1.2*(mz-mA)/(m8*2)local mB=1.4*(mC-mD)/(m8*1.5)for dK,dw in pairs(e[0])do if dw.center then local ht=m6+m8+dw.center.x/my;local hu=m7+m8*1.5/2+dw.center.y/mB;mx=mx..'<circle cx="'..ht..'" cy="'..hu..'" r="'..dw.radius/my*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dw.name,"Moon")and not string.match(dw.name,"Sanctuary")and not string.match(dw.name,"Space")then mx=mx.."<text x='"..ht.."' y='"..hu+dw.radius/my*30+20 .."' font-size='12' fill="..iX.." text-anchor='middle' font-family='Montserrat'>"..dw.name.."</text>"end end end;local fu=vec3(bM.getWorldPosition())local ht=m6+m8+fu.x/my;local hu=m7+m8*1.5/2+fu.y/mB;mx=mx..'<circle cx="'..ht..'" cy="'..hu..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mx=mx.."<text x='"..ht.."' y='"..hu-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iK=my;iL=mB;local mE=fu+cJ*1000000;local mF=m6+m8+mE.x/my;local jA=m7+m8*1.5/2+mE.y/mB;mx=mx..'<line x1="'..ht..'" y1="'..hu..'" x2="'..mF..'" y2="'..jA..'" stroke="purple" stroke-width="1"/>'jQ[#jQ+1]=mx;jQ[#jQ+1]='</g>'end elseif bH=="INFO"then jQ=cq.DrawOdometer(jQ,iZ,bn,i_)elseif bH=="HELP"then jQ=l_(jQ)elseif bH=="SCOPE"then jQ[#jQ+1]='<g clip-path="url(#orbitRect)">'local mG=d4;if ce>0 then table.sort(d3,function(ez,eA)local eB,eC=ez.center,eA.center;return(eB.x-cN.x)^2+(eB.y-cN.y)^2+(eB.z-cN.z)^2<(eC.x-cN.x)^2+(eC.y-cN.y)^2+(eC.z-cN.z)^2 end)end;local mH={}local mI={}local mJ=120;local mK=nil;local mL=nil;for L,dw in ipairs(d3)do local gU=dw.center-cN;local mM=gU:len()local mN=gU:normalize()local mO=gU:cross(cG):normalize()local mP=math.acos(mO:dot(cH))if mP~=mP then mP=0 end;if mO:cross(cH):dot(cG)<0 then mP=-mP end;local mQ=gU:project_on_plane(cG):len()local mR=math.sin(mP)*math.asin(mQ/mM)*constants.rad2deg;local mS=math.cos(mP)*math.asin(mQ/mM)*constants.rad2deg;if mN:dot(cG)<0 then mS=90*math.cos(mP)+90*math.cos(mP)-mS;mR=90*math.sin(mP)+90*math.sin(mP)-mR end;local ht=mo+mR/mG*mk;local hu=mp+mS/mG*mk;local mT=(ht-mo)*(ht-mo)+(hu-mp)*(hu-mp)local mU=math.asin((dw.radius+dw.surfaceMaxAltitude)/mM)*constants.rad2deg;if mU~=mU then mU=mG end;local hS=mU/mG*mk;local mV=math.asin(dw.atmosphereRadius/mM)*constants.rad2deg;if mV~=mV then mV=mU end;local mW=mV/mG*mk;local c8=iB(mM,1)local mX=dw.name;local mY=false;if hu>m7 then if hu>mr then if hu-mW<=mr then mY=true end else mY=true end else if hu+mW>=m7 then mY=true end end;local mZ=false;local m_=ht;if dw.systemId==0 then m_=ht+mJ else m_=ht-mJ end;if m_+mJ>m6 then if m_+mJ>mq then if m_-mW-mJ<=mq then mZ=true end else mZ=true end else if m_+mW+mJ>=m6 then mZ=true end end;local n0={}n0.x=ht;n0.y=hu;n0.planet=dw;n0.atmoSize=mW;if not mK or mT<mK then mK=mT;mL=n0 end;if mZ and mY then local n1=math.max(mW,5)if mT<n1*n1 then mX=mX.." - "..c8 end;n0.size=hS;n0.i=L;n0.displayString=mX;n0.distance=c8;n0.visible=true;mI[#mI+1]=n0 else n0.visible=false end end;local n2=false;table.sort(mI,function(eB,eC)return eB.y<eC.y end)for dK,fx in ipairs(mI)do local dw,hS,L,mW,ht,hu,mX,c8=fx.planet,fx.size,fx.i,fx.atmoSize,fx.x,fx.y,fx.displayString,fx.distance;local mi,n3,n4,n5;local n6=15;local jK="pdim"if dw.systemId~=0 then n4=j4(string.len(mX)*5)n6=-(15+n4)n5=j5(10)jK="pdimfill"else n4=j4(string.len(mX)*9)n5=j5(15)end;if hS*2>n4 then mi=dk(ht,m6+n4/2,mq-n4/2)n3=dk(hu,m7+n5,mr-5)mi=dk(mi,ht-hS+n4/2,ht+hS-n4/2)n3=dk(n3,hu-hS+n5,hu+hS)else mi=ht+n6;n3=hu end;for n7,fx in pairs(mH)do local n8=fx.textPositions;local n9=n8.y-n3;if n7~=L and eY(n9)<n8.height and n8.x+n8.width>mi and n8.x<mi+n4 then if hS>n4 then n3=dk(n3+n5,m7+15,mr-5)else n3=n8.y+n8.height+1 end end end;local na=mX~=dw.name or mi<=mo and mi+n4>=mo and n3-n5<=mp and n3>=mp;fx.hovered=na;local nb=1;if na then nb=2;if hS*2<n4 then nb=10 end;if mX==dw.name then mX=mX.." - "..c8 end;jK="pbright"if dw.systemId~=0 then n4=j4(string.len(mX)*5)n6=-(15+n4)else n4=j4(string.len(mX)*7)end;if hS*2>n4 then mi=dk(ht,m6+n4/2,mq-n4/2)mi=dk(mi,ht-hS+n4/2,ht+hS-n4/2)else mi=ht+n6 end end;mH[L]={}mH[L].textPositions={}mH[L].textPositions.y=n3;mH[L].textPositions.x=mi;mH[L].textPositions.width=n4;mH[L].textPositions.height=n5;mH[L].output=""if hS*2>n4 then jK=jK.." txtmid"else jK=jK.." txtstart"end;if mW-hS>2 then mH[L].output=dj('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',ht,hu,mW,iY,0.1*nb)end;mH[L].output=mH[L].output..dj('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',ht,hu,hS,iY,0.2*nb)if dw.systemId==0 then mH[L].output=mH[L].output..dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mi,n3,iX,jK,mX)if hS*2<=n4 then mH[L].output=mH[L].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mi+n4,n3+2,mi,n3+2,ht,hu)end else mH[L].output=mH[L].output..dj([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mi,n3,iY,jK,mX)if hS*2<=n4 then mH[L].output=mH[L].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mi,n3+2,mi+n4,n3+2,ht,hu)end end end;for dK=#d3,1,-1 do if mH[dK]then jQ[#jQ+1]=mH[dK].output end end;if mL~=nil and d4<90 and not mL.hovered then local nc=mL.planet.atmosphereRadius/mL.atmoSize;local nd=dm(mK)*nc;local ne=iB(nd,1)local n4=j4(math.max(string.len(ne)*7,string.len(mL.planet.name)*7))local n5=j5(12)local mi=dk(mL.x+(mo-mL.x)/2,m6+n4/2,mq-n4/2)local n3=dk(mL.y+(mp-mL.y)/2,m7+n5*2,mr-5)jQ[#jQ+1]=dj("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mL.x,mL.y,mo,mp)jQ[#jQ+1]=dj([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mi,n3,"white",ne)if not mL.visible then jQ[#jQ+1]=dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mi,n3-n5,"white",mL.planet.name)end end;if cK>1 then local gU=cJ;local mN=gU:normalize()local mQ=gU:project_on_plane(cG):len()local mO=gU:cross(cG):normalize()local mP=math.acos(mO:dot(cH))if mP~=mP then mP=0 end;if mO:cross(cH):dot(cG)<0 then mP=-mP end;local mR=math.sin(mP)*math.asin(mQ/gU:len())*constants.rad2deg;local mS=math.cos(mP)*math.asin(mQ/gU:len())*constants.rad2deg;if mN:dot(cG)<0 then mS=90*math.cos(mP)+90*math.cos(mP)-mS;mR=90*math.sin(mP)+90*math.sin(mP)-mR end;local ht=mo+mR/mG*mk;local hu=mp+mS/mG*mk;local kM=14;local kN=kM/2;local kQ=[[<circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kN/kM..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..ht..[["
                                    cy="]]..hu..[["
                                    r="]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ht-kM..[[,]]..hu..[[ h ]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ht+kN..[[,]]..hu..[[ h ]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ht..[[,]]..hu-kM..[[ v ]]..kN..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jQ[#jQ+1]=kQ end;jQ[#jQ+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mo,mp-10,mo,mp+10)jQ[#jQ+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mo-10,mp,mo+10,mp)jQ[#jQ+1]='</g>'else return jQ end end;local function nf(ng,nh)local ni;local nj=(nh-ng):normalize()local fv=(cN-ng):dot(nj)/nj:dot(nj)if fv<=0. then return(cN-ng):len()elseif fv>=(nh-ng):len()then return(cN-nh):len()end;local nk=ng+fv*nj;ni=(nk-cN):len()return ni end;local function nl()local ni;local nm=nil;local nn=nil;local no=nil;for dK,np in pairs(e[0])do if np.hasAtmosphere then local c8=nf(ks.center,np.center)if nm==nil or c8<nm then nn=np;nm=c8;no=ks end;if c5 and c5.hasAtmosphere and c5.name~=ks.name then local eO=nf(c5.center,np.center)if eO<nm then nn=np;nm=eO;no=c5 end end end end;local nq=j4(1770)local nr=j5(330)if nm then local ns="txttick "local nt=500000;if nm<nn.radius+nt or nm<no.radius+nt then if cU then ns="txttick red "else ns="txttick orange "end end;ni=iB(nm,2)iP=gM(nq,nr,"Pipe ("..no.name.."--"..nn.name.."): "..ni,ns.."pbright txtmid")end end;local function nu(ht,hu,nv,nw,kZ)local nx={x=ht,y=hu,width=nv,height=nw,label=kZ}iJ[kZ]=nx;return nx end;local function ny(nz,nA,nv,nw,ht,hu,nB,nC,nD,nE,jK)local nx={enableName=nz,disableName=nA,width=nv,height=nw,x=ht,y=hu,toggleVar=nB,toggleFunction=nC,drawCondition=nD,hovered=false,class=jK}if nE then table.insert(iI,nx)else table.insert(iH,nx)end;return nx end;local function nF(nG)if not iN then nH=false;nI=false;nJ=false;w=true;return elseif nG=="handling"then nH=not nH;nI=false;nJ=false elseif nG=="hud"then nI=not nI;nH=false;nJ=false elseif nG=="physics"then nJ=not nJ;nH=false;nI=false end;if nJ or nI or nH then iO=iA(nG)w=false else iO="none"w=true end end;local function nK()iN=not iN;if iN then iG=iI;c0="Tap SHIFT to see Settings"d5=w else iG=iH;c0="Tap SHIFT to see Control Buttons"nF()w=d5 end end;local function nL()local function nM(dw,dK)dw.set(not dw.get())if dw.get()then c0=dK.." set to true"else c0=dK.." set to false"end;if dK=="showHud"then d5=dw.get()elseif dK=="BrakeToggleDefault"then aZ=j end end;local nN=50;local nO=340;local ht=500;local hu=cj/2-400;local nP=0;for dK,dw in pairs(iA("boolean"))do if type(dw.get())=="boolean"then ny(dK,dK,nO,nN,ht,hu,function()return dw.get()end,function()nM(dw,dK)end,function()return true end,true)hu=hu+nN+20;if nP==9 then ht=ht+nO+20;hu=cj/2-400;nP=0 else nP=nP+1 end end end;ny("Control View","Control View",nO,nN,10,cj/2-500,function()return true end,nK,function()return true end,true)ny("View Handling Settings",'Hide Handling Settings',nO,nN,10,cj/2-(500-nN),function()return nH end,function()nF("handling")end,function()return true end,true)ny("View Hud Settings",'Hide Hud Settings',nO,nN,10,cj/2-(500-nN*2),function()return nI end,function()nF("hud")end,function()return true end,true)ny("View Physics Settings",'Hide Physics Settings',nO,nN,10,cj/2-(500-nN*3),function()return nJ end,function()nF("physics")end,function()return true end,true)end;local function nQ()local function gw()local fW=cN;local gx=ks.name..". "..#bp;if ct then gx=ct.GetClosestName(gx)end;return cr.AddNewLocation(gx,fW,false,true)end;local function nR()b4=not b4 end;local function nS(nT)if nT==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;bY=false;b6=false;bt=nil;b8=false;b7=false end;local function nU(nV,nW)cr.UpdatePosition(nil,nV,nW)end;local function gr()cr.ClearCurrentPosition()end;local function nX(gv)local lZ=cs.routeWP(true)if lZ and#lZ>0 then return"Engage Route: "..lZ[1]end;return"Engage Autopilot: "..lX(gv)end;local function nY(gv)local lZ=cs.routeWP(true)if lZ and#lZ>0 then return"Next Route Point: "..lZ[1]end;return"Disable Autopilot: "..lX(gv)end;local function nZ()if iw()==1 then bY=not bY;if bY then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;n_=bm;bm=false;d.control.retractLandingGears()ix:setTargetGroundAltitude(Y)fT("folOn","F")else fT("folOff","F")b0="Follow Off"cy=p;bm=n_;if bm then d.control.deployLandingGears()ix:setTargetGroundAltitude(Z)end end else c0="Follow Mode only works with Remote controller"bY=false end end;local nN=50;local nO=260;local o0=j4(30)local o1=aA+az*2+2;local o2=aB+1;ny("+","+",o0,o0,o1,o2+o0+1,function()return false end,function()d4=d4/8 end,function()return bH=="SCOPE"end,nil,"ZoomButton")ny("-","-",o0,o0,o1,o2,function()return false end,function()d4=math.min(d4*8,90)end,function()return bH=="SCOPE"end,nil,"ZoomButton")ny("0","0",o0,o0,o1,o2+o0*2+2,function()return false end,function()d4=90 end,function()return bH=="SCOPE"and d4~=90 end,nil,"ZoomButton")local o3=ny("Enable Brake Toggle","Disable Brake Toggle",nO,nN,ci/2-nO/2,cj/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)ny("Align Prograde","Disable Prograde",nO,nN,ci/2-nO/2-50-o3.width,cj/2-nN+380,function()return b2 end,function()nS(1)end)ny("Align Retrograde","Disable Retrograde",nO,nN,ci/2-nO/2+o3.width+50,cj/2-nN+380,function()return b1 end,nS,function()return ce==0 end)o4=ny(nX,nY,600,60,ci/2-600/2,cj/2-60/2-330,function()return b3 or bq or ca or bz end,function()end)local L;local function o5(o6)local gv=d0+o6;if gv>#cT then gv=gv-#cT-1 end;if gv<0 then gv=#cT+gv end;return gv end;o7={}for L=0,10 do local o8=ny(function(eC)local gv=o5(eC.apExtraIndex)if b3 or bq or ca or bz then return"Redirect: "..lX(gv)end;return nX(gv)end,function(eC)local gv=o5(eC.apExtraIndex)return nY(gv)end,600,60,ci/2-600/2,cj/2-60/2-330+60*L,function(eC)local gv=o5(eC.apExtraIndex)return gv==bl and(b3 or bq or ca or bz)end,function(eC)local gv=o5(eC.apExtraIndex)local o9=bl==gv;bl=gv;cr.UpdateAutopilotTarget()cs.ToggleAutopilot()if not o9 and not(b3 or bq or ca or bz)then cs.ToggleAutopilot()end end,function()return c_ and(#cs.routeWP(true)==0 or L==0)end)o8.apExtraIndex=L;o7[L]=o8 end;ny("Save Position","Save Position",200,o4.height,o4.x+o4.width+30,o4.y,function()return false end,gw,function()return bl==0 or g4==nil end)ny("Update Position","Update Position",200,o4.height,o4.x+o4.width+30,o4.y,function()return false end,function()nU(nil)end,function()return bl>0 and g4~=nil end)ny("Save Heading","Clear Heading",200,o4.height,o4.x+o4.width+30,o4.y+o4.height+20,function()return g4.heading~=nil end,function()if g4.heading~=nil then nU(false)else nU(true)end end,function()return bl>0 and g4~=nil end)ny("Save AGG Alt","Clear AGG Alt",200,o4.height,o4.x+o4.width+30,o4.y+o4.height*2+40,function()return g4.agg~=nil end,function()if g4.agg~=nil then nU(nil,false)else nU(nil,true)end end,function()return bl>0 and g4~=nil and antigrav end)ny("Clear Position","Clear Position",200,o4.height,o4.x-200-30,o4.y,function()return true end,gr,function()return bl>0 and g4~=nil end)ny("Save Route","Save Route",200,o4.height,o4.x-200-30,o4.y+o4.height*2+40,function()return false end,function()cs.routeWP(false,false,2)end,function()return#cs.routeWP(true)>0 end)ny("Load Route","Clear Route",200,o4.height,o4.x-200-30,o4.y+o4.height+20,function()return#cs.routeWP(true)>0 end,function()if#cs.routeWP(true)>0 then cs.routeWP(false,true)elseif b3 or bq then c0="Disable Autopilot before loading route"return else cs.routeWP(false,false,1)end end,function()return true end)nN=60;nO=300;local ht=0;local hu=cj/2-150;ny("Enable Check Damage","Disable Check Damage",nO,nN,ht,hu-nN-20,function()return s end,function()s=not s end)ny("View Settings","View Settings",nO,nN,ht,hu,function()return true end,nK)hu=hu+nN+20;ny("Enable Turn and Burn","Disable Turn and Burn",nO,nN,ht,hu,function()return b4 end,nR)ht=10;hu=cj/2-300;ny("Horizontal Takeoff Mode","Vertical Takeoff Mode",nO,nN,ci/2-nO/2,hu+20,function()return a_ end,function()a_=not a_;if a_ then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return cO end)hu=hu+nN+20;ny("Engage Orbiting","Cancel Orbiting",nO,nN,ht+nO+20,hu,function()return bz end,cs.ToggleIntoOrbit,function()return ce==0 and cX end)hu=cj/2-150;ny("Glide Re-Entry","Cancel Glide Re-Entry",nO,nN,ht+nO+20,hu,function()return b8 end,function()c9=1;nS(1)end,function()return ks.hasAtmosphere and not cd end)hu=hu+nN+20;ny("Parachute Re-Entry","Cancel Parachute Re-Entry",nO,nN,ht+nO+20,hu,function()return b8 end,function()c9=2;nS(1)end,function()return ks.hasAtmosphere and not cd end)hu=hu+nN+20;ny("Engage Follow Mode","Disable Follow Mode",nO,nN,ht,hu,function()return bY end,nZ,function()return iw()==1 end)ny("Enable Repair Arrows","Disable Repair Arrows",nO,nN,ht+nO+20,hu,function()return j2 end,function()j2=not j2;if j2 then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return iw()==1 end)hu=hu+nN+20;if not q then ny("Enable AGG","Disable AGG",nO,nN,ht,hu,function()return cP end,cs.ToggleAntigrav,function()return antigrav~=nil end)end;ny(function()return dj("Switch IPH Mode - Current: %s",bA)end,function()return dj("IPH Mode: %s",bA)end,nO*2,nN,ht,hu,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons"else bA="All"end;c0="IPH Mode: "..bA end)hu=hu+nN+20;ny(function()return dj("Toggle Control Scheme - Current: %s",g)end,function()return dj("Control Scheme: %s",g)end,nO*2,nN,ht,hu,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local oa=j5(20)local o8=nu(0,0,j4(70),oa,"HELP")o8=nu(o8.x+o8.width,o8.y,j4(80),oa,"INFO")o8=nu(o8.x+o8.width,o8.y,j4(70),oa,"ORBIT")o8=nu(o8.x+o8.width,o8.y,j4(70),oa,"SCOPE")nu(o8.x+o8.width,o8.y,j4(70),oa,"HIDE")end;local ob={}local oc=nil;function ob.HUDPrologue(jQ)if not cU then iU=ah;iV=ai;iW=aj else iU=ae;iV=af;iW=ag end;iX=[[rgb(]]..bK(iU+0.6)..","..bK(iV+0.6)..","..bK(iW+0.6)..[[)]]iY=[[rgb(]]..bK(iU*0.8+0.5)..","..bK(iV*0.8+0.5)..","..bK(iW*0.8+0.5)..[[)]]local od=iX;local oe=iY;local of=[[rgb(]]..bK(iU*0.4+0.5)..","..bK(iV*0.4+0.5)..","..bK(iW*0.4+0.5)..[[)]]local og=iX;local oh=iY;local oi=of;if j6()and not m then od=[[rgb(]]..bK(iU*0.5+0.5)..","..bK(iV*0.5+0.5)..","..bK(iW*0.5+0.5)..[[)]]oe=[[rgb(]]..bK(iU*0.3+0.5)..","..bK(iV*0.3+0.5)..","..bK(iW*0.2+0.5)..[[)]]of=[[rgb(]]..bK(iU*0.2+0.5)..","..bK(iV*0.2+0.5)..","..bK(iW*0.2+0.5)..[[)]]end;local lM=j4;local lN=j5;jQ[#jQ+1]=dj([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],od,od,od,og,og,oe,oe,oh,oh,oe,od,of,oh,od,od,of,of,oi,of,ci,cj,oe,oe,oe,oe,oe,og,oe,oh,oi,oh,oh,oi)if not oc then oc=dj([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lM(630),lN(0),lM(675),lN(45),lM(960),lN(55),lM(1245),lN(45),lM(1290),lN(0),lM(1000),lN(105),lM(1040),lN(59),lM(1250),lN(51),lM(1300),lN(0),lM(1920),lN(0),lM(1920),lN(20),lM(1400),lN(20),lM(1300),lN(105),lM(920),lN(105),lM(880),lN(59),lM(670),lN(51),lM(620),lN(0),lM(0),lN(0),lM(0),lN(20),lM(520),lN(20),lM(620),lN(105),lM(890),lN(59),lM(960),lN(62),lM(1030),lN(59),lM(985),lN(112),lM(1150),lN(112),lM(1100),lN(152),lM(820),lN(152),lM(780),lN(112),lM(935),lN(112),lM(890),lN(59),lM(960),lN(62),lM(1030),lN(59),lM(985),lN(112),lM(1150),lN(112),lM(1100),lN(152),lM(820),lN(152),lM(780),lN(112),lM(935),lN(112))end;if w and I then jQ[#jQ+1]=oc end;return jQ end;function ob.DrawVerticalSpeed(jQ,e2)jP(jQ,e2)end;function ob.UpdateHud(jQ)local kF=cR;local oj=cS;local jX=oj;local kc=kF;local kX=bK(c.getThrottle())local l1=cK*3.6;local kY=c.getAxisCommandValue(0)local ok=j4(1770)local ol=j5(310)if t and cQ then kY=bO;kX=bO*100 end;local j8=j7()local jY="ROLL"if kX==nil then kX=0 end;if not cX then if cK>5 then kF=kE(cI)oj=kG(cI)else kF=0;oj=0 end;jY="YAW"end;if cV>50000 and not cd then local om;om=iB(cV)jQ[#jQ+1]=gM(ok,ol,"PvP Boundary: "..om,"pbright txtbig txtmid")end;jQ[#jQ+1]=j0;jQ[#jQ+1]=i6;if iP~=""then jQ[#jQ+1]=iP end;if j9~=""then jQ[#jQ+1]=j9 end;if ja~=""then jQ[#jQ+1]=ja end;jP(jQ,cf)if iw()==0 or l then if not j6()or m then if cX then jW(jQ,ak,al,jX,jY,cX)kb(jQ,kc,jX,ak,al,cX,bK(kG(cI)),cK)else jW(jQ,ak,al,oj,jY,cX)kb(jQ,kF,oj,ak,al,cX,bK(oj),cK)end;ki(jQ,cf,cX)kH(jQ,cI,cK,ak,al)end end;kW(jQ,j8,kX,kY)l0(jQ,l1)l4(jQ)m5(jQ)if not iN and bZ then lY(jQ)end;return jQ end;function ob.HUDEpilogue(jQ)jQ[#jQ+1]="</svg>"return jQ end;function ob.ExtraData(jQ)local on=j4(1240)local oo=j5(55)local op=oo+10;local oq;local lM=j4;local lN=j5;local os=0;local j8=j7()if a_ then j8=j8 .."-VERTICAL"end;if E and not b7 and not b6 and cK>20 then j8=j8 .."-COLLISION ON"end;if bC~="Off"then j8="("..bC..")-"..j8 end;if b4 then j8="TB-"..j8 end;if not bB then j8=j8 .."-DeCoupled"end;local ot=lN(99)local ou=lN(80)local ov=lN(85)local ow=lN(31)local ox=0;local oy=0;local oz=cg>1000000 and fU(cg/1000000,2).."kT"or fU(cg/1000,2).."T"if cd then os=bu else os=bs end;local oA,oB=co.computeDistanceAndTime(cK,0,cg,0,0,os)if oA<0 then oA=0 end;os=fU(os/(cg*iF),2).."g"local oC=d:maxForceForward()oq=b.getGravityIntensity()if oq>0.1 then oy=cg*oq;oy=fU(oy/(cg*iF),2).."g"ox=0.5*oC/oq;ox=ox>1000000 and fU(ox/1000000,2).."kT"or fU(ox/1000,2).."T"end;oC=fU(oC/(cg*iF),2).."g"local oD=vec3(bM.getWorldAcceleration()):len()/9.80665;oq=b.getGravityIntensity()jQ[#jQ+1]=[[<g class="dim txt txtend size14">]]if iw()==1 and not l then on=j4(1120)oo=j5(55)op=oo+10 elseif cd and I then local oE=j4(770)jQ[#jQ+1]=gM(lM(895),ot,"ATMO","")jQ[#jQ+1]=dj([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lM(895),ov,lM(-80))jQ[#jQ+1]=gM(lM(815),ou,dj("%.1f%%",ce*100),"txtstart size20")end;if I then jQ[#jQ+1]=gM(lM(1025),ot,"GRAVITY","txtstart")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(1025),ov,lM(80))jQ[#jQ+1]=gM(lM(1105),ou,dj("%.2fg",oq/9.80665),"size20")jQ[#jQ+1]=gM(lM(1125),ot,"ACCEL","txtstart")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(1125),ov,lM(80))jQ[#jQ+1]=gM(lM(1205),ou,dj("%.2fg",oD),"size20")jQ[#jQ+1]=gM(lM(695),ot,"BRK TIME","")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(695),ov,lM(-80))jQ[#jQ+1]=gM(lM(615),ou,dj("%s",iC(oB)),"txtstart size20")jQ[#jQ+1]=gM(lM(635),lN(45),"TRIP","")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(635),lN(31),lM(-90))if lG then jQ[#jQ+1]=gM(lM(545),lN(26),dj("%s",iC(lG)),"txtstart size20")end;jQ[#jQ+1]=gM(lM(795),ot,"BRK DIST","")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(795),ov,lM(-80))jQ[#jQ+1]=gM(lM(715),ou,dj("%s",iB(oA)),"txtstart size20")jQ[#jQ+1]=gM(lM(1285),lN(45),"MASS","txtstart")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(1285),lN(31),lM(90))jQ[#jQ+1]=gM(lM(1375),lN(26),dj("%s",oz),"size20")jQ[#jQ+1]=gM(lM(1220),ot,"THRUST","txtstart")jQ[#jQ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lM(1220),ov,lM(80))jQ[#jQ+1]=gM(lM(1300),ou,dj("%s",oC),"size20")jQ[#jQ+1]=gM(j4(960),j5(175),j8,"pbright txtbig txtmid size20")end;jQ[#jQ+1]="</g>"end;local oF=1-(a5*0.05+a6*0.05)function ob.FuelUsed(oG)local oH;if oG=="atmofueltank"then oH=dj("Atmo Fuel Used: %.1f L",jr[oG]/(4*oF))elseif oG=="spacefueltank"then oH=dj("Space Fuel Used: %.1f L",jr[oG]/(6*oF))else oH=dj("Rocket Fuel Used: %.1f L",jr[oG]/(0.8*oF))end;return oH end;local oI,oJ,oK,oL,oM=0,0,0,{},0;function ob.DrawOdometer(jQ,iZ,bn,i_)if bH~="INFO"then return jQ end;local oq;local ox=0;local oy=0;local os=0;local oz=cg>1000000 and fU(cg/1000000,2).." kTons"or fU(cg/1000,2).." Tons"if cd then os=bu else os=bs end;local oA,oB=co.computeDistanceAndTime(cK,0,cg,0,0,os)os=fU(os/(cg*iF),2).." g"local oC=d:maxForceForward()oq=b.getGravityIntensity()if oq>0.1 then oy=cg*oq;oy=fU(oy/(cg*iF),2).." g"ox=0.5*oC/oq;ox=ox>1000000 and fU(ox/1000000,2).." kTons"or fU(ox/1000,2).." Tons"end;oC=fU(oC/(cg*iF),2).." g"if iw()==0 or l then local oN=j4(aA+10)local oO=j5(aB+20)local oP=j4(aA+10+az/1.25)local nw=25;local oQ=bK(1/aT)if oK<oQ then oM=oM+a.getActionUpdateDeltaTime()oK=oK+1 else oI=1/(oM/oQ)table.insert(oL,oI)oK,oM=0,0 end;oJ=0;for dK,dw in pairs(oL)do oJ=oJ+dw end;if#oL>0 then oJ=bK(oJ/#oL)end;if#oL>29 then table.remove(oL,1)end;jQ[#jQ+1]="<g class='txtstart size14 bright'>"jQ[#jQ+1]=gM(oN,oO,dj("BrkTime: %s",iC(oB)))jQ[#jQ+1]=gM(oP,oO,dj("Trip: %.2f km",iZ))jQ[#jQ+1]=gM(oN,oO+nw,dj("Lifetime: %.2f kSU",bn/200000))jQ[#jQ+1]=gM(oP,oO+nw,dj("BrkDist: %s",iB(oA)))jQ[#jQ+1]=gM(oN,oO+nw*2,"Trip Time: "..iC(i_))jQ[#jQ+1]=gM(oP,oO+nw*2,"Total Time: "..iC(bo))jQ[#jQ+1]=gM(oN,oO+nw*3,dj("Mass: %s",oz))jQ[#jQ+1]=gM(oP,oO+nw*3,dj("Max Brake: %s",os))jQ[#jQ+1]=gM(oN,oO+nw*4,dj("Max Thrust: %s",oC))if oq>0.1 then jQ[#jQ+1]=gM(oP,oO+nw*4,dj("Max Thrust Mass: %s",ox))jQ[#jQ+1]=gM(oN,oO+nw*5,dj("Req Thrust: %s",oy))else jQ[#jQ+1]=gM(oP,oO+nw*4,"Max Mass: n/a")jQ[#jQ+1]=gM(oN,oO+nw*5,"Req Thrust: n/a")end;jQ[#jQ+1]=gM(oP,oO+nw*5,cq.FuelUsed("atmofueltank"))jQ[#jQ+1]=gM(oN,oO+nw*6,cq.FuelUsed("spacefueltank"))jQ[#jQ+1]=gM(oP,oO+nw*6,cq.FuelUsed("rocketfueltank"))jQ[#jQ+1]=gM(oN,oO+nw*7,dj("Set Max Speed: %s",bK(aa*3.6+0.5)))jQ[#jQ+1]=gM(oP,oO+nw*7,dj("Actual Max Speed: %s",bK(de*3.6+0.5)))jQ[#jQ+1]=gM(oN,oO+nw*8,dj("Friction Burn Speed: %s",bK(bM.getFrictionBurnSpeed()*3.6)))jQ[#jQ+1]=gM(oP,oO+nw*8,dj("FPS (Avg): %s (%s)",bK(oI),oJ))end;jQ[#jQ+1]="</g></g>"return jQ end;function ob.DrawWarnings(jQ)return l4(jQ)end;function ob.DisplayOrbitScreen(jQ)return m5(jQ)end;function ob.DisplayMessage(jQ,lr)if lr~="empty"then local hu=310;for lA in string.gmatch(lr,"([^\n]+)")do hu=hu+35;jQ[#jQ+1]=gM("50%",hu,lA,"msg")end end;if c1~=0 then c.setTimer("msgTick",c1)c1=0 end end;function ob.DrawDeadZone(jQ)jQ[#jQ+1]=dj([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],ay)end;function ob.UpdatePipe()if cd then iP=""return end;nl()end;function ob.DrawSettings(jQ)local ht=j4(640)local hu=j5(200)jQ[#jQ+1]=[[<g class="pbright txtvspd txtstart">]]local hP=0;for dK,dw in pairs(iO)do hP=hP+1;jQ[#jQ+1]=gM(ht,hu,dK..": "..dw.get())hu=hu+20;if hP%12==0 then ht=ht+j4(350)hu=j5(200)end end;jQ[#jQ+1]=gM(j4(640),j5(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jQ[#jQ+1]="</g>"return jQ end;local i5=j5(125)local i4=j4(1225)function ob.DrawRadarInfo()i6=ct.GetRadarHud(i4,i5,aw,ax)end;function ob.DrawTanks()if as~=0 and at~=0 then j9=gM(as,at,"","txtstart pdim txtfuel")js=at;jt(as,"Atmospheric ","ATMO",ck,jp,jq)jt(as,"Space Fuel T","SPACE",cl,jn,jo)jt(as,"Rocket Fuel ","ROCKET",cm,jl,jm)end end;function ob.DrawShield()local ie=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oR=bM.getPvPTimer()local oS=shield.getResistances()local oT="A: "..10+oS[1]*100 .."% / E: "..10+oS[2]*100 .."% / K:"..10+oS[3]*100 .."% / T: "..10+oS[4]*100 .."%"local ht,hu=au-60,av+30;local jI=bK(df*2.55)local jJ=dj("rgb(%d,%d,%d)",255-jI,jI,0)local jK=""ja=gM(ht,hu,"","txtmid pdim txtfuel")if df<10 and ie~="Shield Disabled"then jK="red "end;oR=oR>0 and"   PvPTime: "..iC(oR)or""ja=ja..dj([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ht,hu,jJ,df*2,ht,hu,ht+2,hu+10,df,oR)ja=ja..gM(ht,hu-5,ie,jK.."txtstart pbright txtbig")ja=ja..gM(ht,hu+30,oT,jK.."txtstart pbright txtsmall")end;function ob.hudtick()if not ks then return end;local function oU(jQ)local jM=bK(dk(dc/(ci/4)*255,0,255))jQ[#jQ+1]=dj("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c6,c7,bK(iU+0.5)+jM,bK(iV+0.5)-jM,bK(iW+0.5)-jM)end;local function oV()if b_ then for dP,dw in pairs(iG)do if dw.hovered then if not dw.drawCondition or dw.drawCondition(dw)then dw.toggleFunction(dw)end;dw.hovered=false end end;for dP,dw in pairs(iJ)do if dw.hovered then bH=dw.label;dw.hovered=false end end;b_=false end end;local function oW()local function oX(oY,oZ,ht,hu,nv,nw)if oY>=ht and oY<=ht+nv and oZ>=hu and oZ<=hu+nw then return true else return false end end;local ht=c6+ci/2;local hu=c7+cj/2;for dP,dw in pairs(iG)do dw.hovered=oX(ht,hu,dw.x,dw.y,dw.width,dw.height)end;for dP,dw in pairs(iJ)do dw.hovered=oX(ht,hu,dw.x,dw.y,dw.width,dw.height)end;if c_ then local na=false;for dP,eC in ipairs(o7)do if eC.hovered then na=true;break end end;if o4.hovered then na=true end;c_=na else c_=o4.hovered;if not c_ then d0=bl end end end;local function o_(jQ)if not bH or bH==""then bH="HELP"end;if w then for dK,dw in pairs(iJ)do local jK="dim brightstroke"local p0=0.2;if bH==dK then jK="pbright dimstroke"p0=0.6 end;local p1=""if dw.hovered then p0=0.8;p1=";stroke:white"end;jQ[#jQ+1]=dj([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dw.width,dw.height,dw.x,dw.y,jK,p0,p1)jQ[#jQ+1]=gM(dw.x+dw.width/2,dw.y+dw.height/2+5,dw.label,"txt txtmid pdim")end end end;local function p2(jQ)local function p3(jQ,p4,hover,ht,hu,fh,p5,p6,p7,p8,p9,o8)if type(p8)=="function"then p8=p8(o8)end;if type(p9)=="function"then p9=p9(o8)end;jQ[#jQ+1]=dj("<rect x='%f' y='%f' width='%f' height='%f' fill='",ht,hu,fh,p5)if p4 then jQ[#jQ+1]=dj("%s'",p6)else jQ[#jQ+1]=p7 end;if hover then jQ[#jQ+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ae,af,ag)else jQ[#jQ+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fU(ae*0.5,0),fU(af*0.5,0),fU(ag*0.5,0))end;jQ[#jQ+1]=" rx='5'></rect>"jQ[#jQ+1]=dj("<text x='%f' y='%f' font-size='24' fill='",ht+fh/2,hu+p5/2+5)if p4 then jQ[#jQ+1]="black"else jQ[#jQ+1]="white"end;jQ[#jQ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if p4 then jQ[#jQ+1]=dj("%s</text>",p8)else jQ[#jQ+1]=dj("%s</text>",p9)end end;local pa=dj("rgb(%d,%d,%d)'",fU(ae*0.1,0),fU(af*0.1,0),fU(ag*0.1,0))local pb=dj("rgb(%d,%d,%d)",fU(ae*0.8,0),fU(af*0.8,0),fU(ag*0.8,0))local pc=p3;for dP,dw in pairs(iG)do local nA=dw.disableName;local nz=dw.enableName;if type(nA)=="function"then nA=nA(dw)end;if type(nz)=="function"then nz=nz(dw)end;if not dw.drawCondition or dw.drawCondition(dw)then pc(jQ,dw.toggleVar(dw),dw.hovered,dw.x,dw.y,dw.width,dw.height,pb,pa,nA,nz,dw)end end end;local pd=fU(ci/2,0)local pe=fU(cj/2,0)local jQ={}if pf then jQ[#jQ+1]=pf end;cq.HUDPrologue(jQ)if w then cq.UpdateHud(jQ)else if A then cq.DrawVerticalSpeed(jQ,cf)end;cq.DrawWarnings(jQ)end;if iN and iO~="none"then cq.DrawSettings(jQ)end;if ct then cq.DrawRadarInfo()else i6=""end;cq.HUDEpilogue(jQ)jQ[#jQ+1]=dj([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ci,cj)if c0~="empty"then cq.DisplayMessage(jQ,c0)end;if iw()==0 and g=="virtual joystick"then if v then cq.DrawDeadZone(jQ)end end;o_(jQ)if iy()==0 then if iw()==1 and bZ then if not pg then oW()p2(jQ)end;if not cw and not cx then local ph=table.concat(jQ,"")jQ={}jQ[#jQ+1]=dj("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ci,cj)jQ[#jQ+1]=ph;jQ[#jQ+1]="</body>"cw=true;jQ[#jQ+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cx then local ph=table.concat(jQ,"")jQ={}jQ[#jQ+1]=dj("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ci,cj)jQ[#jQ+1]=ph;jQ[#jQ+1]="</body>"end;if not cw then jQ[#jQ+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pd,pe,c6,c7)end else oV()end else if not bZ and iw()==0 then oV()if dc>ay then if v then oU(jQ)end end elseif bZ and(not pg or not i)then oW()p2(jQ)end;jQ[#jQ+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],pd,pe,c6,c7)end;jQ[#jQ+1]=[[</svg></body>]]pi=table.concat(jQ,"")end;function ob.TenthTick()local function pj()local pk=a.createData;local pl=a.createWidget;pm=a.createWidgetPanel("Interplanetary Helper")pn=pl(pm,"value")po=pk('{"label": "Target Planet", "value": "N/A", "unit":""}')fS(po,pn)pp=pl(pm,"value")pq=pk('{"label": "distance", "value": "N/A", "unit":""}')fS(pq,pp)gl=pl(pm,"value")gk=pk('{"label": "Travel Time", "value": "N/A", "unit":""}')fS(gk,gl)gj=pl(pm,"value")gi=pk('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fS(gi,gj)gn=pl(pm,"value")gm=pk('{"label": "Target Altitude", "value": "N/A", "unit":""}')fS(gm,gn)gf=pl(pm,"value")ge=pk('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gd=pl(pm,"value")gc=pk('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gb=pl(pm,"value")ga=pk('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g9=pl(pm,"value")g8=pk('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gh=pl(pm,"value")gg=pk('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cd then fS(ge,gf)fS(gc,gd)fS(ga,gb)fS(g8,g9)fS(gg,gh)end end;local function pr()gL(pm)pm=nil end;cq.DrawTanks()if shield then cq.DrawShield()end;if bj~="None"then if pm==nil then pj()end;if bj~=nil then local mM;local ps=g4~=nil;local pt=0.5*bu/c5:getGravity(c5.center+vec3(0,0,1)*c5.radius):len()pt=pt>1000000 and fU(pt/1000000,2).." kTons"or fU(pt/1000,2).." Tons"fR(po,'{"label": "Target", "value": "'..bj..'", "unit":""}')if ps and not b3 then mM=(cN-g4.position):len()else mM=(bk-cN):len()end;if not b4 then c3,c4=cs.GetAutopilotBrakeDistanceAndTime(cK)iR,iS=cs.GetAutopilotBrakeDistanceAndTime(aa)else c3,c4=cs.GetAutopilotTBBrakeDistanceAndTime(cK)iR,iS=cs.GetAutopilotTBBrakeDistanceAndTime(aa)end;local lr=iB(mM)fR(pq,'{"label": "distance", "value": "'..lr..'"}')fR(gk,'{"label": "Travel Time", "value": "'..iC(lG)..'", "unit":""}')lr=iB(c3)fR(ge,'{"label": "Cur Brake distance", "value": "'..lr..'"}')fR(gc,'{"label": "Cur Brake Time", "value": "'..iC(c4)..'", "unit":""}')lr=iB(iR)fR(ga,'{"label": "Max Brake distance", "value": "'..lr..'"}')fR(g8,'{"label": "Max Brake Time", "value": "'..iC(iS)..'", "unit":""}')fR(gi,'{"label": "Max Brake Mass", "value": "'..dj("%s",pt)..'", "unit":""}')lr=iB(go)fR(gm,'{"label": "Target Orbit", "value": "'..lr..'"}')if cd and not pu then a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)pu=true;if not cQ and t and(b5 or b8 or cb)then cs.cmdThrottle(1)b0=false;bS=false end end;if not cd and pu then if fR(g8,g9)==1 then fS(g8,g9)end;if fR(ga,gb)==1 then fS(ga,gb)end;if fR(gc,gd)==1 then fS(gc,gd)end;if fR(ge,gf)==1 then fS(ge,gf)end;if fR(gg,gh)==1 then fS(gg,gh)end;pu=false end end else pr()end;if warpdrive~=nil then local pv=iu(warpdrive.getWidgetData())if pv.destination~="Unknown"and pv.distance>400000 then if not j3 then warpdrive.showWidget()j3=true end elseif j3 then warpdrive.hideWidget()j3=false end end end;function ob.OneSecondTick()local function pw()local jD=bJ()local l1=cK;local px=jD-j1;if l1>1.38889 then l1=l1/1000;local py=l1*(jD-j1)bn=bn+py;iZ=iZ+py end;i_=i_+px;bo=bo+px;j1=jD end;local function pz(jQ)local pA=0;local pB=iE;local pC=0;local pD=0;local pE=0;local jI=0;local jJ=""local pF=b.getElementHitPointsById;local pG=b.getElementMaxHitPointsById;local pH={}for dK in pairs(iD)do local pI=0;local pJ=0;pJ=pG(iD[dK])pI=pF(iD[dK])pC=pC+pI;if pI+1<pJ then if pI==0 then pE=pE+1 else pD=pD+1 end;if j2 and#pH==0 then fW=vec3(b.getElementPositionById(iD[dK]))local ht=fW.x;local hu=fW.y;local hv=fW.z;table.insert(pH,b.spawnArrowSticker(ht,hu,hv+1,"down"))table.insert(pH,b.spawnArrowSticker(ht,hu,hv+1,"down"))b.rotateSticker(pH[2],0,0,90)table.insert(pH,b.spawnArrowSticker(ht+1,hu,hv,"north"))table.insert(pH,b.spawnArrowSticker(ht+1,hu,hv,"north"))b.rotateSticker(pH[4],90,90,0)table.insert(pH,b.spawnArrowSticker(ht-1,hu,hv,"south"))table.insert(pH,b.spawnArrowSticker(ht-1,hu,hv,"south"))b.rotateSticker(pH[6],90,-90,0)table.insert(pH,b.spawnArrowSticker(ht,hu-1,hv,"east"))table.insert(pH,b.spawnArrowSticker(ht,hu-1,hv,"east"))b.rotateSticker(pH[8],90,0,90)table.insert(pH,b.spawnArrowSticker(ht,hu+1,hv,"west"))table.insert(pH,b.spawnArrowSticker(ht,hu+1,hv,"west"))b.rotateSticker(pH[10],-90,0,90)table.insert(pH,iD[dK])end elseif j2 and#pH>0 and pH[11]==iD[dK]then for jC in pairs(pH)do b.deleteSticker(pH[jC])end;pH={}end end;pA=fU(pC/pB*100,2)if pE>0 or pD>0 then jQ[#jQ+1]=gM(0,0,"","pbright txt")jI=bK(pA*2.55)jJ=dj("rgb(%d,%d,%d)",255-jI,jI,0)jQ[#jQ+1]=gM("50%",1035,"Elemental Integrity: "..pA.."%","txtbig txtmid","fill:"..jJ)if pE>0 then jQ[#jQ+1]=gM("50%",1055,"Disabled Modules: "..pE.." Damaged Modules: "..pD,"txtbig txtmid","fill:"..jJ)elseif pD>0 then jQ[#jQ+1]=gM("50%",1055,"Damaged Modules: "..pD,"txtbig txtmid","fill:"..jJ)end end end;local function pK()if it then if iT==nil and(d7~=nil or bm)then _autoconf.displayCategoryPanel(it,weapon_size,"Weapons","weapon",true)iT=_autoconf.panels[_autoconf.panels_size]elseif iT~=nil and d7==nil and not bm then gL(iT)iT=nil end end end;d1=bM.getPlayersOnBoard()d2=bM.getDockedConstructs()local jQ={}pw()if s then pz(jQ)end;pK()cq.UpdatePipe()cq.ExtraData(jQ)j0=table.concat(jQ,"")end;function ob.AnimateTick()cx=true;cw=false;c6=0;c7=0;c.stopTimer("animateTick")end;function ob.MsgTick()local jQ={}cq.DisplayMessage(jQ,"empty")c0="empty"c.stopTimer("msgTick")c1=3 end;function ob.ButtonSetup()nL()nQ()iG=iH end;if pL then for dK,dw in pairs(pL)do ob[dK]=dw end end;return ob end;local function pM(d,b,c,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,eY,bK,bL,iw,eT,bJ,dk,ix,fR,iy,dm,fU,fT,iz,dn,iB,iC,pO,iu,dj,fS)local a=DUSystem;local bM=DUConstruct;local pP={}local pQ=false;local pR=0;local pS=0;local pT=0;local pU=bJ()local pV=0;local pW=0;local pX=0;local pY=0;local pZ=false;local p_=false;local q0=false;local q1=nil;local q2=0;local iQ=55;local q3=nil;local q4=false;local q5=false;local q6=false;local q7=0;local q8=0;local q9=0;local qa=0;local qb=0;local qc={VectorToTarget=false}local qd=vec3(bM.getWorldOrientationUp())local qe=nil;local qf=0;local qg=-1;local qh=-1;local qi=false;local qj=false;local qk=0;local ql=false;local qm=false;local qn=false;local qo=false;local qp=""local qq=false;local qr=false;local qs=""local qt=false;local qu=0;local function qv()return bM.isInPvPZone()~=1,eY(bM.getDistanceToSafeZone())end;local function qw(fo)local qx=bf;if not b3 then qx=0 end;local qy=bs;if cd then if bu and bu>0 then qy=bu else return 0,0 end end;return co.computeDistanceAndTime(fo,qx,cg,0,0,qy-bh*cg)end;local function qz(fo)local qx=bf;if not b3 then qx=0 end;return co.computeDistanceAndTime(fo,qx,cg,d:maxForceForward(),a1,bs-bh*cg)end;local function qA(qB,qC,qD)qC=qC:project_on_plane(qB)qD=qD:project_on_plane(qB)return eT(qC:cross(qD):dot(qB),qC:dot(qD))end;local function qE()local function qF()local qG=-1;local qH=-1;if vBooster then qG=vBooster.getDistance()end;if hover then qH=hover.getDistance()end;if qG~=-1 and qH~=-1 then if qG<qH then return qG else return qH end elseif qG~=-1 then return qG elseif qH~=-1 then return qH else return-1 end end;local qI=qF()local qJ=-1;if antigrav and antigrav.isActive()==1 and not q and cK<iQ then local qK=eY(cf-antigrav.getBaseAltitude())if qK<50 then return qK end end;if pN then qJ=pN.raycast().distance end;if qI~=-1 and qJ~=-1 then if qI<qJ then return qI else return qJ end elseif qI~=-1 then return qI else return qJ end end;local function qL(ks,eK,qM)local function qN(qO,dW)local eQ=vec3(dW)if qO.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=qO.systemId},dY)end;local eR=eQ-qO.center;local c8=eR:len()local e2=c8-qO.radius;local e0=0;local e1=0;if not dn(c8,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/c8)end;return setmetatable({latitude=math.deg(e0),longitude=math.deg(e1),altitude=e2,id=qO.id,systemId=qO.systemId},dY)end;local qP=qN(ks,eK)qP="::pos{"..qP.systemId..","..qP.id..","..qP.latitude..","..qP.longitude..","..qP.altitude.."}"if qM then return qP else qn=qP;return true end end;local function qQ(qR,qS,qT)local function qU(qR,et)qR=vec3(qR)et=vec3(et):normalize()local dF=qR*et;return dF.x+dF.y+dF.z end;local qV=0.001;local qW=1;if not cd or not cz or cc~=-1 or cK<iQ then if qT==nil then qT=aS end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=vec3()-qR;local qY=-qU(qX,bM.getWorldOrientationRight())*qW;local qZ=-qU(qX,bM.getWorldOrientationUp())*qW;if pS==0 then pS=qY/2 end;if pT==0 then pT=qZ/2 end;if eY(qY)<0.1 then q8=q8-qY*2 else q8=q8-(qY+(qY-pS)*qT)end;if eY(qZ)<0.1 then q7=q7+qZ*2 else q7=q7+qZ+(qZ-pT)*qT end;pS=qY;pT=qZ;if eY(qY)<qS and eY(qZ)<qS then return true end;return false elseif cz and cc==-1 then qR=cJ;if qT==nil then qT=aS end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=cG-qR;local qY=-qU(qX,bM.getWorldOrientationRight())*qW;local qZ=-qU(qX,bM.getWorldOrientationUp())*qW;if pS==0 then pS=qY/2 end;if pT==0 then pT=qZ/2 end;if eY(qY)<0.1 then q8=q8-qY*5 else q8=q8-(qY+(qY-pS)*qT)end;if eY(qZ)<0.1 then q7=q7+qZ*5 else q7=q7+qZ+(qZ-pT)*qT end;pS=qY;pT=qZ;if eY(qY)<qS and eY(qZ)<qS then return true end;return false end end;function pP.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cW=nil;b5=false;b8=false;b6=false;b7=false;b9=false;bY=false;q5=false;c9=false;ca=false;q6=false;cy=p;bq=false;b4=false;ch=false;bt=nil;bz=false;da=false;db=nil end;function pP.GetAutopilotBrakeDistanceAndTime(fo)return qw(fo)end;function pP.GetAutopilotTBBrakeDistanceAndTime(fo)return qz(fo)end;function pP.showWayPoint(ks,eK,qM)return qL(ks,eK,qM)end;function pP.APTick()local q_=a.getMouseWheel()if q_>0 then cs.changeSpd()elseif q_<0 then cs.changeSpd(true)else q4=true end;qk=iy()if qn then a.setWaypoint(qn)qn=false end;if qq then antigrav.setTargetAltitude(qq)qq=false end;if qo then fR(qo,qp)qo=false;qp=""end;if qh~=-1 then cs.cmdCruise(qh,qi)qi=false;qh=-1 end;if qe~=nil then if ix:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ix:getTargetSpeed(axisCommandId.longitudinal)~=qe then ix:setTargetSpeedCommand(axisCommandId.longitudinal,qe)else qe=nil end end;if qg~=-1 then cs.cmdThrottle(qg,qi)qi=false;qg=-1 end;if qj then cu.landingGear()qj=false end;if qr then cs.ToggleAutopilot()end end;function pP.ToggleIntoOrbit()cD=false;pX=nil;pY=nil;q2=0;if not cd then if bz then fT("orOff","AP")bz=false;pZ=false;q1=nil;cy=p;if b5 then b5=false;b7=false end;qc.VectorToTarget=false;qc.AutopilotAlign=false;q0=false elseif cX then fT("orOn","AP")bz=true;cy=true;if q1==nil then q1=ks end;if b5 then b5=false;b7=false end else c0="Unable to engage auto-orbit, not near a planet"end else bz=false;pZ=false;q1=nil;cy=p;if b5 then b5=false end;qc.VectorToTarget=false;qc.AutopilotAlign=false;q0=false end end;function pP.ToggleVerticalTakeoff()b5=false;if b9 then lz=true;b8=false;b7=false;b6=true;cy=true;bX=0;if cd and cc==-1 then b6=false;b5=true;bX=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qh=bK(cA)end else cD=false;bm=false;d.control.retractLandingGears()ix:setTargetGroundAltitude(Y)b0="VTO Takeoff"end;b9=not b9 end;function pP.checkLOS(qR)local lE,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,qR,function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lF=eI;if eJ~=nil and eI~=nil then lF=math.min(eJ,eI)end;if lF~=nil then return lE,lF else return nil,nil end end;function pP.ToggleAutopilot()local function r0(bx)cY=false;bq=not bq;if bq then b4=false;if not b5 and not bx then cs.ToggleAltitudeHold()end end;lI="Proceeding to Waypoint"end;local function r1(gx)if gx then for L,dK in pairs(cT)do if dK.name and dK.name==gx then return L end end else return 0 end end;local r2=false;if bN-pW<1.5 and cd then if not cF then if cd then ba=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude;fT("11","EP")pW=-1;if b3 or bq or bz then return end else c0="No space engines detected, Orbital Hop not supported"return end elseif ks.hasAtmosphere then if cd then ba=ks.noAtmosphericDensityAltitude+U;fT("orH","OH")end;pW=-1;if b3 or bq or bz then return end end else pW=bN end;r3=false;if(bl>0 or#bF>0)and not b3 and not bq and not ca and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cg then c0="WARNING: Heavy Loads may affect autopilot performance."c1=5 end;if#bF>0 and not cb then bl=r1(bF[1])cr.UpdateAutopilotTarget()c0="Route Autopilot in Progress"local qX=g4.position-cN;local r4=qX:project_on_plane(cL):len()if r4>50000 and g4.planetname==ks.name then r2=true end end;cr.UpdateAutopilotTarget()cs.showWayPoint(c5,bk)if g4~=nil then if g4.agg and not q and antigrav then if not cP then cs.ToggleAntigrav()end;bv=g4.agg end;bt=nil;bx=g4.planetname=="Space"if bx then fT("apSpc","AP")if cd then ca=true;cs.ToggleAltitudeHold()else b3=true end elseif ks.name==g4.planetname then lz=true;if cd then if not bq then fT("vtt","AP")r0(bx)if r2 then ba=ks.noAtmosphericDensityAltitude+U end end else fT("apOn","AP")if not(c5.name==ks.name and cf<go*1.5)then cD=false;b3=true elseif not cd then if bz then cs.ToggleIntoOrbit()end;cC=ks.noAtmosphericDensityAltitude+U;q0=true;qc.AutopilotAlign=true;qc.VectorToTarget=true;pZ=false;if not bz then cs.ToggleIntoOrbit()end end end else fT("apP","AP")b1=false;b2=false;if cd then ca=true;cs.ToggleAltitudeHold()else b3=true end end elseif not cd then if g4==nil and(c5.name==ks.name and cX)and not bz then r5=false;cD=false;pZ=false;cs.ToggleIntoOrbit()else fT("apP","AP")b3=true;b1=false;b2=false;bc=false;bY=false;b5=false;b6=false;b8=false;b7=false;q5=false;bt=nil;r5=false end else fT("apP","AP")ca=true;cs.ToggleAltitudeHold()end;qr=false else fT("apOff","AP")cs.ResetAutopilots(1)if qr==2 then qr=true end end end;function pP.routeWP(r6,r7,r8)if r8 then if r8==1 then bF={}bF=iz(bF,bE)if#bF>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return bF else bE={}bE=iz(bE,bF)c0="Route Saved"pO()return end end;if r6 then return bF end;if r7 then bF={}c0="Current Route Cleared"else bF[#bF+1]=g4.name;c0="Added "..g4.name.." to route. "end;return bF end;function pP.cmdThrottle(dL,r9)if ix:getAxisCommandType(0)~=axisCommandType.byThrottle and not r9 then d.control.cancelCurrentControlMasterMode()end;ix:setThrottleCommand(axisCommandId.longitudinal,dL)bO=dk(fU(dL*100,0)/100,-1,1)qe=nil end;function pP.cmdCruise(dL,r9)if ix:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r9 then d.control.cancelCurrentControlMasterMode()end;ix:setTargetSpeedCommand(axisCommandId.longitudinal,dL)qe=dL end;function pP.ToggleLockPitch()if bt==nil then fT("lkPOn","LP")if not bZ then bt=cR else bt=R end;b7=false;b5=false;b6=false else fT("lkPOff","LP")bt=nil end end;function pP.ToggleAltitudeHold()if bN-pV<1.5 then if ks.hasAtmosphere then if cd then ba=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude;fT("11","EP")else if cX then ba=ks.noAtmosphericDensityAltitude+U;cC=ba;q0=true;if not bz then cs.ToggleIntoOrbit()end;pZ=true end end;pV=-1;if b5 or bz or b9 then return end end else pV=bN end;if cX and not cd then cC=cf;q0=true;pZ=true;cs.ToggleIntoOrbit()if bz then pV=bN else pV=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;bY=false;cy=true;bt=nil;cD=false;if cc~=-1 and cK<20 then if bm then cu.landingGear()end;fT("lfs","LS")b7=true;if pV>-1 then ba=cf+X end;b0="ATO Hold"ix:setTargetGroundAltitude(Y)if a_ and cO then cs.ToggleVerticalTakeoff()end else fT("altOn","AH")b7=false;if pV>-1 then if cX then ba=cf end end;if b9 then cs.ToggleVerticalTakeoff()end end;if cP and not q then local ra=antigrav.getBaseAltitude()if bq and g4.agg and g4.agg>cf then ba=g4.agg elseif b7 then ba=ra end;if eY(cf-ra)<100 and cK<20 then ba=ra;b0="AGG Hold"qg=0 end end;if ca then ba=200000 end else fT("altOff","AH")if bz then cs.ToggleIntoOrbit()end;if b9 then cs.ToggleVerticalTakeoff()end;cy=p;b7=false;bq=false;pV=0 end end;function pP.ResetAutopilots(pP)if pP then ca=false;b3=false;bc=false;q5=false;ba=cf;r3=false;da=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;db=nil;rb=false;cW=nil;da=false;if not cP then b5=false;bt=nil end;if b9 then cs.ToggleVerticalTakeoff()end;if bz then cs.ToggleIntoOrbit()end;cy=p;c9=false;cb=false;bX=0 end;function pP.BrakeToggle(rc)if not b0 then if rc then b0=rc else b0=true end else b0=false end;if b6 then b6=false;cy=p;da=false end;if b0 then fT("bkOn","B",1)cs.ResetAutopilots()else fT("bkOff","B",1)end end;function pP.BeginReentry()if b8 then c0="Re-Entry cancelled"fT("reOff","RE")b8=false;cy=p;b5=false elseif not ks.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c1=5 elseif not q6 then b8=true;if ix:getAxisCommandType(0)~=rd.cruise then d.control.cancelCurrentControlMasterMode()end;cy=true;b0=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cA;fT("par","RE")else b8=true;b5=true;cy=true;b0=false;ba=ks.surfaceMaxAltitude+_;if ba>ks.spaceEngineMinAltitude then ba=ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude end;local re=iB(ba)c0="Beginning Re-entry.  Target speed: "..cA.." Target Altitude: "..re;fT("glide","RE")qh=bK(cA)end;b7=false end;function pP.ToggleAntigrav()if antigrav and not q then if cP then fT("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=cf end;if bv<1000 then bv=1000 end;fT("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pP.changeSpd(rf)local rg=1;if rf then rg=-1 end;if not bZ then if t and not pg and q4 then local rh=bO;bO=fU(dk(bO+rg*aE/100,-1,1),2)if bO>=0 and rh<0 then bO=0;q4=false end elseif pg then if cd or b8 then cA=dk(cA+rg*aE,0,V)elseif b3 then aa=dk(aa+rg*aE/3.6*100,0,de-0.2)end else ix:updateCommandFromActionStart(axisCommandId.longitudinal,rg*aE/10)end else if b3 or bq or ca or bz then d0=d0+1*rg*-1;if d0>#cT then d0=1 end;if d0<1 then d0=#cT end else if not rf then rg=1 else rg=nil end;cr.adjustAutopilotTargetIndex(rg)end end end;function pP.TenthTick()local function ri()if not b3 then if g4==nil or g4.planetname~=ks.name then rj=(c5.center-cN):len()else rj=(g4.position-cN):len()end end;local fo=cK;local rk=c.getThrottle()/100;if t then rk=bO end;local rl,rm=co.computeDistanceAndTime(cK,aa,cg,d:maxForceForward()*rk,a1,0)local c3,c4;if not b4 then c3,c4=cs.GetAutopilotBrakeDistanceAndTime(aa)else c3,c4=cs.GetAutopilotTBBrakeDistanceAndTime(aa)end;local dP,rn;if not b4 and fo>0 then dP,rn=cs.GetAutopilotBrakeDistanceAndTime(fo)else dP,rn=cs.GetAutopilotTBBrakeDistanceAndTime(fo)end;local ro=0;local rp=0;if be or not b3 and fo>5 then rp=co.computeTravelTime(fo,0,rj)elseif c3+rl<rj then ro=rj-(c3+rl)rp=co.computeTravelTime(8333.0556,0,ro)else local rq=(rj-c3)/rl;rl=rj-c3;rm=rm*rq end;if g4~=nil and g4.planetname==ks.name and not b3 then return rp elseif bd then return rn elseif be then return rp+rn else return rm+c4+rp end end;local function rr(oq,rs)if oq==nil then oq=b.getGravityIntensity()end;oq=fU(oq,5)if rs~=nil and rs or(q3==nil or q3~=oq)then local fo=cI:len()local rt=iu(c.getWidgetData()).maxBrake;if rt~=nil and rt>0 and cd then rt=rt/dk(fo/100,0.1,1)rt=rt/ce;if ce>0.10 then if bu then bu=(bu+rt)/2 else bu=rt end end end;if rt~=nil and rt>0 then bs=rt end;q3=oq end end;cU,cV=qv()de=bM.getMaxSpeed()if bj~="None"and(c5 or g4)then lG=ri()end;rr(nil,true)end;function pP.SatNavTick()if not r then return end;qs=dbHud_1.getStringValue("SPBAutopilotTargetName")if qs~=nil and qs~=""and qs~="SatNavNotChanged"then local dF=iu(dbHud_1.getStringValue("SavedLocations"))if dF~=nil then bp=dF;local gv=-1;local gB;for dK,dw in pairs(bp)do if dw.name and dw.name=="SatNav Location"then gv=dK;break end end;if gv~=-1 then gB=bp[gv]gv=-1;for dK,dw in pairs(e[0])do if dw.name and dw.name=="SatNav Location"then gv=dK;break end end;if gv>-1 then e[0][gv]=gB end;cr.UpdateAtlasLocationsList()c0=gB.name.." position updated"end end;for L=1,#cT do if cT[L].name==qs then bl=L;a.print("Index = "..bl.." "..cT[L].name)cr.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pP.onFlush()local function ru(rv,rw)local rx=vec3()local ry=vec3()if rv==axisCommandId.longitudinal then rx=vec3(bM.getOrientationForward())ry=cG elseif rv==axisCommandId.vertical then rx=vec3(bM.getOrientationUp())ry=qd elseif rv==axisCommandId.lateral then rx=vec3(bM.getOrientationRight())ry=cH else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bM.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cI:dot(rx)local rE=rw*constants.kph2m;if rF==nil then rF=pid.new(10,0,10.0)end;rF:inject(rE-rD)local rG=rF:get()local rH=(rG-rC-rA)*ry;return rH end;local function rI(rv,rw)local rx=vec3()local ry=vec3()if rv==axisCommandId.longitudinal then rx=vec3(bM.getOrientationForward())ry=cG elseif rv==axisCommandId.vertical then rx=vec3(bM.getOrientationUp())ry=qd elseif rv==axisCommandId.lateral then rx=vec3(bM.getOrientationRight())ry=cH else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bM.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cI:dot(rx)local rE=rw*constants.kph2m;if rJ==nil then rJ=pid.new(10,0,10.0)end;rJ:inject(rE-rD)local rG=rJ:get()local rH=(rG-rC-rA)*ry;return rH end;local function rK(rL,jT,g0)local rM=rL:cross(g0):normalize_inplace()local kF=math.acos(dk(rM:dot(-jT),-1,1))*constants.rad2deg;if rM:cross(-jT):dot(g0)<0 then kF=-kF end;return kF end;local function rN()if cZ and not b6 then local er=cZ[1]local hW,hX=cZ[2],cZ[3]local rO=math.min(hW,hX or hW)local rP=rO/cK;local rQ=b7 and(cK<42 or cc~=-1)local rR=b5 or bq or bt or b3;if rR and not rQ and(c3*1.5>rO or rP<1)then b0="Collision"bF={}qg=0;if b5 then cs.ToggleAltitudeHold()end;if bt then cs.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"a.print(er.name.." COLLISION "..iC(rP).." / "..iB(rO,2))cs.ResetAutopilots(1)lz=true;if cd then b6=true end;cy=true end;if rP<11 then cY=er.name.." COLLISION "..iC(rP).." / "..iB(rO,2)else cY=er.name.." collision "..iC(rP)end;if rP<6 then fT("alarm","AL",2)end else cY=false end end;if antigrav and not q then if not cP and antigrav.getBaseAltitude()~=bv then qq=bv end end;if dd then d:setEngineForceCommand('hover',vec3(),1)dd=false end;cQ=ix:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rS=dk(bU+q7+a.getControlDeviceForwardInput(),-1,1)local rT=dk(bV+q9+a.getControlDeviceYawInput(),-1,1)local rU=dk(bW+q8-a.getControlDeviceLeftRightInput(),-1,1)local rV=b0 and 1 or 0;cL=vec3(b.getWorldVertical())if cL==nil or cL:len()==0 then cL=(ks.center-cN):normalize()end;qd=vec3(bM.getWorldOrientationUp())cG=vec3(bM.getWorldOrientationForward())cH=vec3(bM.getWorldOrientationRight())cJ=vec3(bM.getWorldVelocity())cI=vec3(bM.getVelocity())cN=vec3(bM.getWorldPosition())cg=bM.getMass()cK=vec3(cJ):len()cM=-cL:dot(cJ)cS=getRoll(cL,cG,cH)local rW=cS/180*math.pi;local rX=math.cos(rW)local rY=math.sin(rW)cR=rK(cL,cG,cH*rX+qd*rY)local rZ=cJ:normalize()local r_=eY(cS)local s0=utils.sign(cS)local s1=vec3(bM.getWorldAngularVelocity())local s2=rS*aO*cH+rT*aJ*cG+rU*aP*qd;if cy==true and cL:len()>0.01 then local s3=eY(qa-cS)if((b2 or b8 or b6 or c9 or b5 or bz)and s3>0 or cd and s3<aK and p)and rT==0 and eY(cR)<85 then local s4=qa;local s5=aI;if not cd then s5=s5/4;qa=0;s4=0 end;if s6==nil then s6=pid.new(s5*0.01,0,s5*0.1)end;s6:inject(s4-cS)local s7=s6:get()s2=s2+s7*cG end end;local s8=1;local s9=0;local sa=1;bP=0;ce=bL()cd=false or cf<ks.noAtmosphericDensityAltitude and ce>0.00001;cf=b.getAltitude()cc=qE()bN=bJ()pU=bN;if bm and cc>-1 and cc-3<Z then if ix.targetGroundAltitudeActivated then ix:deactivateGroundEngineAltitudeStabilization()end end;if ct then qt=not qt;if qt then ct.UpdateRadar()end;if E then rN()end end;if antigrav then cP=antigrav.isActive()==1 end;local sb=1;local sc=1;local sd=bN-pU;local se=-math.deg(qA(qd,cJ,cG))local sf=math.deg(qA(cH,cJ,cG))local gq=cL*-1;cz=cd and se<-M or se>M or sf<-N or sf>N;local sg=a.getMouseDeltaX()local sh=a.getMouseDeltaY()if qu then local si=bJ()-qu;sg=sg*si/0.016;sh=sh*si/0.016 end;qu=bJ()if o and not bZ then sh=-sh end;q8=0;q9=0;q7=0;fX=cn[0]local sj=bM.getWorldPosition()ks=fX:closestBody(sj)sk=cp(ks)fs=sk:orbitalParameters(sj,cJ)if cf==0 then cf=(cN-ks.center):len()-ks.radius end;cX=c.getClosestPlanetInfluence()>0 or cf>0 and cf<200000;local oq=ks:getGravity(sj):len()*cg;qa=0;local sl=bM.getMaxThrustAlongAxis("ground",bM.getOrientationUp())[1]if qk==0 then if iw()==1 and bZ then if not cw then c6=dk(c6+sg/2,-ci/2,ci/2)c7=dk(c7+sh/2,-cj/2,cj/2)end else c6=0;c7=0 end else c6=dk(c6+sg/2,-ci/2,ci/2)c7=dk(c7+sh/2,-cj/2,cj/2)dc=dm(c6*c6+c7*c7)if not bZ and iw()==0 then local kO,kP=1,1;if bH=="SCOPE"then kO,kP=d4/90,d4/90 end;if g=="virtual joystick"then if dc>ay then q8=q8-dk(eY(c6)-ay,0,ci/2)*utils.sign(c6)*aG*kO;q7=q7-dk(eY(c7)-ay,0,cj/2)*utils.sign(c7)*aH*kP end else c6=0;c7=0;if g=="mouse"then q7=(-utils.smoothstep(sh,-100,100)+0.5)*2*sb;q8=(-utils.smoothstep(sg,-100,100)+0.5)*2*sc end end end end;local sm=cK>27777;if cK>W/3.6 and not cd and not b3 and not sm then c0="Space Speed Engine Shutoff reached"qg=0 end;if not sm and sn then if not b0 then cs.BrakeToggle()end;if b3 then cs.ResetAutopilots(1)end;qg=0 end;sn=sm;if ce>0.09 then if cK>cA/3.6 and not t and not pQ then b0="SpdLmt"pQ=true elseif not t and pQ then if cK<cA/3.6 then b0=false;pQ=false end end end;if b2 then if c9 then b0=false;local so=false;if g4 and c9==true then so=qQ(g4.position-cN,0.1)else so=qQ(vec3(cJ),0.01)end;cy=true;if so then qh=bK(cA)if(eY(cS)<2 or eY(cR)>85)and cK>=cA/3.6-1 then b0=false;b2=false;if c9~=2 then q6=true end;if c9==true then cb=true end;c9=false;b3=false;cs.BeginReentry()end elseif cd and t then qg=1 end elseif cK>iQ then qQ(vec3(cJ),0.01)end end;if b1 then if cd then b1=false elseif cK>iQ then qQ(-vec3(cJ))end end;if not b2 and c9 and not bz then if not cd then if c9~=2 then q6=true end;cs.BeginReentry()c9=false;cb=true else c9=false;if not qr then qr=true end end end;if cb and g4 and(cf<ba+250 and cf>ba-250)and cK*3.6>cA-250 and eY(cM)<25 and ce>=0.1 and(g4.position-cN):len()>2000+cf then if not qr then qr=true end;cb=false end;if b9 then cy=true;local sp=ba;if cM<-30 then c0="Unable to achieve lift. Safety Landing."bX=0;cy=p;b9=false;b6=true elseif not q and cP or ba<ks.spaceEngineMinAltitude then if cP then sp=antigrav.getBaseAltitude()end;if cf<sp-100 then qb=0;bX=15;b0=false elseif cM>0 then b0="VTO Limit"bX=0 elseif cM<-30 then b0="VTO Fall"bX=15 elseif cf>=sp then if cP then if b3 or bq then cs.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c0="Takeoff complete. Singularity engaged"fT("aggLk","AG")else b0=false;c0="VTO complete. Engaging Horizontal Flight"fT("vtoc","VT")cs.ToggleVerticalTakeoff()end;bX=0 end else if ce>0.08 then qb=0;b0=false;bX=20 elseif ce<0.08 and cd then b0=false;if cE then qb=0;bX=20 else bX=0;qb=36;qh=3500 end else cy=p;bz=true;cD=false;sq=false;pZ=false;pX=nil;pY=nil;if q1==nil then q1=ks end;cC=sp;q0=true;b9=false end end;if qb~=nil then if sr==nil then sr=pid.new(2*0.01,0,2*0.1)end;local ss=dk(qb-cR,-N*0.80,N*0.80)sr:inject(ss)local st=dk(sr:get(),-1,1)q7=st end end;if bz then local function su()if fs.periapsis.altitude>=cC*0.99 and fs.apoapsis.altitude>=cC*0.99 and fs.periapsis.altitude<fs.apoapsis.altitude and fs.periapsis.altitude*1.05>=fs.apoapsis.altitude and eY(cC-cf)<1000 then return true else return false end end;local qX;local sv=false;local sw=iB(cC)if q1==nil then q1=ks;if bq then q1=c5 end end;if not q0 then cC=bK(q1.radius+q1.surfaceMaxAltitude+U)if q1.hasAtmosphere then cC=bK(q1.radius+q1.noAtmosphericDensityAltitude+U)end;q0=true end;if qc.VectorToTarget and g4 then qX=g4.position-cN end;local sx,sy=cp(q1):escapeAndOrbitalSpeed((cN-q1.center):len()-q1.radius)local sz=cS;if not pZ then local sA=false;local sB=false;qg=0;pY=0;cB="Aligning to orbital path - OrbitHeight: "..sw;if qc.VectorToTarget then qQ(qX:normalize():project_on_plane(cL))sv=cG:dot(qX:project_on_plane(qd):normalize())>0.95 else qQ(cJ)sv=se<0.5;if cK<150 then sv=true end end;q7=0;pX=0;if cR<=pX+2 and cR>=pX-2 then sA=true else sA=false end;if sz<=pY+2 and sz>=pY-2 then sB=true else sB=false end;if sA and sB and sv then pX=nil;pY=nil;pZ=true end else if qc.VectorToTarget then qQ(qX:normalize():project_on_plane(cL))elseif cK>150 then qQ(cJ)end;q7=0;if qc.VectorToTarget and g4 then local c3,dP=co.computeDistanceAndTime(cK,cA/3.6,cg,0,0,bs)if cD and qX:len()>15000+c3+cf then cB="Orbiting to Target"if cf-100<=q1.noAtmosphericDensityAltitude or lG>fs.timeToPeriapsis and fs.periapsis.altitude<q1.noAtmosphericDensityAltitude or not su()and fs.eccentricity>0.1 then c0="Re-Aligning Orbit"cD=false end elseif cD or qX:len()<15000+c3+cf then c0="Orbit complete, proceeding with reentry"fT("orCom","OB")bk=g4.position;q6=true;cb=true;qc.VectorToTarget,qc.AutopilotAlign=false,false;cs.ToggleIntoOrbit()cs.BeginReentry()return end end;if fs.periapsis~=nil and fs.apoapsis~=nil and fs.eccentricity<1 and cf>cC*0.9 and cf<cC*1.4 then if fs.apoapsis~=nil then if su()or cD then if cD then b0=false;qg=0;pX=0;if not qc.VectorToTarget then c0="Orbit complete"fT("orCom","OB")cs.ToggleIntoOrbit()end else q2=q2+1;if q2>=2 then cD=true end end else cB="Adjusting Orbit - OrbitHeight: "..sw;p_=true;qh=sy*3.6+1;local sC=cC-cf;if sD==nil then sD=pid.new(0.1,0,1*0.1)end;sD:inject(sC-cM*dk(utils.smoothstep(2000-sC,-2000,2000)^6*10,1,10))pX=dk(sD:get(),-60,60)end end else local sE=2.75;local sF=eY(fU(sx*sE))local oF=sF%50;if oF>0 then sF=sF-oF+50 end;b0=false;if cf<cC*0.8 then cB="Escaping planet gravity - OrbitHeight: "..sw;pX=utils.map(cM,200,0,-15,80)elseif cf>=cC*0.8 and cf<cC*1.15 then cB="Approaching orbital corridor - OrbitHeight: "..sw;sF=sF*0.75;pX=utils.map(cM,100,-100,-15,65)elseif cf>=cC*1.15 and cf<cC*1.5 then cB="Approaching orbital corridor - OrbitHeight: "..sw;sF=sF*0.75;if cM<0 or p_ then pX=utils.map(cf,cC*1.5,cC*1.01,-30,0)else pX=utils.map(cf,cC*0.99,cC*1.5,0,30)end elseif cf>cC*1.5 then cB="Reentering orbital corridor - OrbitHeight: "..sw;pX=-65;local sG=utils.map(cM,-150,-400,1,0.55)sF=sF*sG end;qh=bK(sF)end end;if pX~=nil then if sH==nil then sH=pid.new(1*0.01,0,5*0.1)end;local sI=pX-cR;sH:inject(sI)local sJ=dk(sH:get(),-0.5,0.5)q7=sJ end end;if b3 and not cd and not c9 then local function sK(dh,fs)a.print(dh)b0=false;bd=false;b3=false;r3=false;bg="Aligning"qg=0;q5=false;c0=dh;fT("apCom","AP")if fs or c9 then if fs and go~=nil and not c9 then if not cf or cf==0 then return end;cC=cf;q0=true end;cs.ToggleIntoOrbit()end end;local sL,sM=bk,false;if g4 and g4.planetname~="Space"then bc=true;if not r3 then local sN=(g4.position-c5.center):normalize()local sO=sN:project_on_plane((c5.center-cN):normalize()):normalize()local sP=c5.center+sO*(c5.radius+go)local sQ=g4.position+(g4.position-c5.center):normalize()*(go-c5:getAltitude(g4.position))if(cN-sP):len()<(cN-sQ):len()then sL=sP else sL=sQ;bf=0 end;bk=sL;cs.showWayPoint(c5,bk)sM=true;r3=true end;bh=0 elseif g4 and g4.planetname=="Space"then if not r3 then bh=0;sM=true;bc=true;r3=true;sL=g4.position+(cN-g4.position):normalize()*S;bk=sL end elseif g4==nil then bh=0;if not r3 then local sN=(cN+cJ*100000-c5.center):normalize()local sO=sN:project_on_plane((c5.center-cN):normalize()):normalize()if sO:len()<1 then sN=(cN+cG*100000-c5.center):normalize()sO=sN:project_on_plane((c5.center-cN):normalize()):normalize()end;sL=c5.center+sO*(c5.radius+go)bk=sL;r3=true;sM=true;bc=true;cs.showWayPoint(c5,bk)end end;rj=(vec3(sL)-cN):len()local lE,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,cJ:normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lF=eI;if eJ~=nil and eI~=nil then lF=math.min(eJ,eI)end;if lF~=nil and lF<rj and lE.name==c5.name then rj=lF end;local so=true;local sR=(c5.center-(cN+vec3(cJ):normalize()*rj)):len()-c5.radius;local lr=iB(sR)qo=gg;qp='{"label": "Projected Altitude", "value": "'..lr..'"}'if cK>50 and bb then local qX=vec3(sL)-cN;local sS=dk(math.deg(qA(qd,cJ:normalize(),qX:normalize()))*cK/500,-90,90)local sT=dk(math.deg(qA(cH,cJ:normalize(),qX:normalize()))*cK/500,-90,90)if eY(sS)<20 and eY(sT)<20 then sS=sS*2;sT=sT*2 end;if eY(sS)<2 and eY(sT)<2 then sS=sS*2;sT=sT*2 end;local se=-math.deg(qA(qd,cG,cJ:normalize()))local sf=-math.deg(qA(cH,cG,cJ:normalize()))if sU==nil then sU=pid.new(2*0.01,0,2*0.1)end;sU:inject(sT-sf)local sV=dk(sU:get(),-1,1)q7=q7+sV;if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sS-se)local sX=dk(sW:get(),-1,1)q8=q8+sX;sM=true;if eY(sS)>2 or eY(sT)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fT("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end end elseif bb and cK<=50 then qQ((sL-cN):normalize())end;if sR<go*1.5 then bf=cA/3.6;if g4==nil then dP,bf=cp(c5):escapeAndOrbitalSpeed(sR)end end;local c3,c4;if not b4 then c3,c4=qw(cK)else c3,c4=qz(cK)end;if b3 and not bb and not be and not bd then local lE,lF=cs.checkLOS((bk-cN):normalize())if c5.name~=ks.name then if lE~=nil and c5.name~=lE.name and lF<rj then c0="Collision with "..lE.name.." in "..iB(lF).."\nClear LOS to continue."c1=5;ql=true else ql=false;c0=""end end end;if not ql then if not be and not bd and not sM then so=qQ((sL-cN):normalize())elseif b4 and(bd or be)then so=qQ(-vec3(cJ):normalize())end end;if bb then if not q5 then b0=false;qg=a0;bO=fU(a0,2)q5=true end;local rk=c.getThrottle()if t then rk=bO end;local sY=99999;local oD=-vec3(bM.getWorldAcceleration()):dot(cJ:normalize())local sZ=dk(cJ:dot((sL-cN):normalize()),0,cK)if sZ>0 or oD>0 then sY=co.computeTravelTime(sZ,oD,rj-c3)end;if aa>de then aa=de-0.2 end;if cI:len()>=aa or rk==0 and q5 or a1/4>sY then bb=false;if bg~="Cruising"then fT("apCru","AP")bg="Cruising"end;be=true;qg=0 end;local s_=rj;if s_<=c3 or H and cV<=c3+10000 and cU then if H and cV<=c3+10000 and cU then if cV<pR and cV>2000 then cs.ResetAutopilots(1)c0="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pR=cV else pR=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;qg=0;q5=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then qg=1;qi=true end;local dP,sy=cp(c5):escapeAndOrbitalSpeed((cN-ks.center):len()-ks.radius)local qX;if g4 then qX=g4.position-cN end;if g4 and g4.planetname=="Space"and cK<50 then if#bF>0 then if not qr then table.remove(bF,1)end;if#bF>0 then b0=false;if not qr then qr=2 end;return end end;sK("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g4 and g4.planetname~="Space"and cK<=sy and(fs.apoapsis==nil or fs.periapsis==nil or fs.apoapsis.altitude<=0 or fs.periapsis.altitude<=0)then sK("Autopilot complete, commencing reentry")bk=g4.position;c9=true;cs.showWayPoint(c5,bk)elseif(g4 and g4.planetname~="Space"or g4==nil)and fs.periapsis~=nil and fs.periapsis.altitude>0 and fs.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fT("apCir","AP")bg="Circularizing"end;if cK<=sy then if g4 then if cJ:normalize():dot(qX:normalize())>0.4 then if bg~="Orbiting to Target"then fT("apOrb","OB")bg="Orbiting to Target"end;if not r5 then b0=false;cs.showWayPoint(c5,g4.position)r5=true end else sK("Autopilot complete, proceeding with reentry")bk=g4.position;c9=true;cs.showWayPoint(c5,g4.position)r5=false end else sK("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sK("Autopilot complete, fixing Orbit",true)end elseif be then local s_=rj;if s_<=c3 or H and cV<=c3+10000 and cU then if H and cV<=c3+10000 and cU then if cV<pR and cV>2000 then if not qr then qr=true end;c0="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pR=cV else pR=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true end;local rk=c.getThrottle()if t then rk=bO end;if rk>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;be=false end else if so then if not bc and g4==nil or not bc and g4 and g4.planetname~="Space"then if not c9 then bk=vec3(c5.center)+(go+c5.radius)*cH;t0=qd;t1=cH end;bc=true elseif so and not ql then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;if not q5 then qg=a0;qi=true;bO=fU(a0,2)q5=true;b0=false end end end end elseif b3 and(g4~=nil and g4.planetname~="Space"and cd)then c0="Autopilot complete, starting reentry"fT("apCom","AP")bk=g4.position;b0=false;bd=false;b3=false;r3=false;bg="Aligning"qg=0;q5=false;b2=true;c9=true;cs.showWayPoint(c5,g4.position)end;if bY then cy=true;local sT=0;local fu=cN+vec3(c.getMasterPlayerRelativePosition())local t2=fu-cN;local t3=vec3(t2):project_on(cG):len()local t4=vec3(t2):project_on(cH):len()local c8=dm(t3*t3+t4*t4)qQ(t2:normalize())local mM=40;local t5=c8<mM;local t6=100;local rw=dk((c8-mM)/2,10,t6)q7=0;local so=eY(q8)<0.1;if so and cK<rw and not t5 then b0=false;sT=-20 else b0="Follow"sT=0 end;local t7=0;if eY(sT-cR)>t7 then if t8==nil then t8=pid.new(2*0.01,0,2*0.1)end;t8:inject(sT-cR)local sV=t8:get()q7=sV end end;if b5 or b6 or b8 or bq or bt~=nil then local t9=bu;if t9 then t9=t9*dk(cK/100,0.1,1)*ce else t9=bs end;if not cd then t9=bs end;qf=cG:project_on_plane(cL):normalize():dot(cJ)if qf>100 then c3,c4=co.computeDistanceAndTime(qf,100,cg,0,0,t9)local ta,tb=co.computeDistanceAndTime(100,0,cg,0,0,t9*0.55)c3=c3+ta else c3,c4=co.computeDistanceAndTime(qf,0,cg,0,0,t9*0.55)end;local sC=ba-cf-cM;local tc=200+cK;if b8 or c9 then td=2000+cK end;local te=1;if b7 then te=dk(cK/100,0.1,1)end;local sT=(utils.smoothstep(sC,-tc,tc)-0.5)*2*P*te;if not b8 and not c9 and not bq and cG:dot(cJ:normalize())<0.99 then sT=(utils.smoothstep(sC,-tc*dk(20-19*ce*10,1,20),tc*dk(20-19*ce*10,1,20))-0.5)*2*P*dk(2-ce*10,1,2)*te end;if not b5 then sT=0 end;if bt~=nil then if cX and not bz then sT=bt else bt=nil end end;cy=true;local tf=q7;if b8 then local tg=bK(cA)local th,ti=co.computeDistanceAndTime(cK,tg/3.6,cg,0,0,bs-ks.gravity*9.8*cg)th=th==-1 and 5000 or th;local r4=cf-(ks.noAtmosphericDensityAltitude+th)local tj=cf>ks.noAtmosphericDensityAltitude+th*1.35;if tj then sT=Q;if cK<=tg/3.6 and cK>tg/3.6-10 and eY(cJ:normalize():dot(cG))>0.9 and not cQ then bS=false;qg=1 end elseif(cQ or ix:getTargetSpeed(axisCommandId.longitudinal)~=tg)and not tj and not cd then qh=tg;qi=true end;if cQ then if cK>tg/3.6 and not tj then b0="Reentry Limit"if bO>0 then qg=0 end else b0=false end else b0=false end;if cM>0 then b0="Reentry vSpd"end;if not q6 then sT=-80;if cf<ks.surfaceMaxAltitude+(ks.atmosphereThickness-ks.surfaceMaxAltitude)*0.25 then c0="PARACHUTE DEPLOYED at "..fU(cf,0)b8=false;b6=true;lz=true;qg=0;sT=0;cy=p end elseif ks.noAtmosphericDensityAltitude>0 and tj then cy=true elseif not tj then if not cd and(cQ or ix:getTargetSpeed(axisCommandId.longitudinal)~=tg)then qh=tg end;if cK<tg/3.6+1 then b0=false;q6=false;b8=false;cy=true;qg=1 end end end;if cK>iQ and not ca and not bq and not b6 and u then qQ(vec3(cJ))end;if cW or(bq or ca)and bl>0 and cd then local qX;if cW then if type(cW)=="table"then qX=cW elseif cW<3 and cW>0 then qX=-cL:cross(cJ)*5000 elseif cW>=3 then qX=cL:cross(cJ)*5000 elseif cW<0 then qX=cJ*25000 end elseif g4~=nil then qX=g4.position-cN else qX=c5.center-cN end;local sS=math.deg(qA(cL:normalize(),cJ,qX))*2;local mP=math.rad(eY(cS))if cK>aL and cd then local tk=1000+cK;local tl=(utils.smoothstep(sC-cM*10,-tk,tk)-0.5)*2*P;local tm=dk(90-tl,0,180)qa=dk(sS*2,-tm,tm)local tn=sS;sS=dk(dk(sS,-M*0.80,M*0.80)*math.cos(mP)+4*(cR-sT)*math.sin(math.rad(cS)),-M*0.80,M*0.80)local to=1;if qa~=0 then to=eY(mP/qa)end;to=(90-dk(eY(qa-cS),0,90))/90;local tp=sT;if eY(cS)>90 then tp=-tp end;sT=to*dk(dk(tp*math.cos(mP),-N*0.8,N*0.8)+eY(dk(eY(tn)*math.sin(mP),-N*0.80,N*0.80)),-N*0.80,N*0.80)else qa=0;sS=dk(sS,-M*0.80,M*0.80)end;local tq=se-sS;if cW and eY(tq)<=0.0001 and(type(cW)=="table"or type(cW)~="table"and cW<0 and eY(cS)<1)then if cW==-2 then cs.ToggleAltitudeHold()end;cW=nil;fT("180Off","BR")return end;if not cz and cK>aL and cd then if tr==nil then tr=pid.new(2*0.01,0,2*0.1)end;tr:inject(tq)local sX=dk(tr:get(),-1,1)q8=q8+sX elseif cd and cc>-1 or cK<aL then qQ(qX)elseif cz and cd then if(se<-M or se>M)and cd then qQ(cJ)end;if(sf<-N or sf>N)and cd then sT=dk(cR-sf,cR-N*0.80,cR+N*0.80)end end;if g4~=nil and not ca then local sp=ks:getAltitude(g4.position)local r4=qX:project_on_plane(cL):len()lz=true;if ba<ks.noAtmosphericDensityAltitude and not ca and not b7 and not b8 and(r4<=c3 and qX:len()<ks.radius)and(cJ:project_on_plane(cL):normalize():dot(qX:project_on_plane(cL):normalize())>0.99 or lI=="Finalizing Approach")then lI="Finalizing Approach"if#bF>0 then if not qr then table.remove(bF,1)end;if#bF>0 then if not qr then qr=2 end;return end end;qg=0;if b5 then cs.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lI=="Finalizing Approach"and(qf<0.1 or r4<0.1 or ts~=nil and ts<r4)then fT("bklOn","BL")b6=true;da=true;if g4.heading then db=g4.heading else db=nil end;bq=false;lI="Proceeding to Waypoint"cY=false end;ts=r4 end elseif bq and not cd and ba>ks.noAtmosphericDensityAltitude and not(ca or b8)then if g4~=nil and c5.name==ks.name then local qX=g4.position-cN;local sp=ks:getAltitude(g4.position)local r4=dm(qX:len()^2-(cf-sp)^2)local t9=bu;if t9 then c3,c4=co.computeDistanceAndTime(cK,0,cg,0,0,t9/2)lz=true;if r4<=c3+cK*sd/2 and cJ:project_on_plane(cL):normalize():dot(qX:project_on_plane(cL):normalize())>0.99 then if ks.hasAtmosphere then b0=false;b2=false;q6=true;c9=false;cb=true;b3=false;cs.BeginReentry()end end;ts=r4 end end end;if not cd and(b5 and ba>ks.noAtmosphericDensityAltitude)and not(ca or bz or b8)then if not cD and not bz then cC=ba;q0=true;if bq then qc.VectorToTarget=true end;cs.ToggleIntoOrbit()bq=false;pZ=true end end;if cz and cd and cc==-1 and cK>aL and lI~="Finalizing Approach"then qQ(cJ)sT=dk(cR-sf,cR-N*0.80,cR+N*0.80)end;q7=tf;local qJ=-1;if b6 then if not qm then if not cQ then qg=0 end;ix:setTargetGroundAltitude(500)ix:activateGroundEngineAltitudeStabilization(500)bB=true;qm=true end;sT=0;local tt=false;local tu=math.abs(qf)if not q and cP then tt=antigrav.getBaseAltitude()if tt<ks.surfaceMaxAltitude and g4==nil or g4~=nil and ks:getAltitude(g4.position)>tt then tt=false end else tt=false end;if db then if tu<0.05 then if cM>-O then b0=false else b0="BL Align BLR"end;if qQ(db,0.001)then db=nil;cy=p else q7=0;cy=true end else b0="BL Align Hzn"end;if tt and eY(cf-tt)<250 then b0="AGG Align"end else local tv=false;local tw=30;if tu<10 and sl~=nil and sl>0 then local tx=dk(ce,0.4,2)local t9=bu*dk(cK/100,0.1,1)*tx;local ty=sl*tx+t9-oq;local tz=t9/2-oq;local tA=cK-dm(eY(tz/2)*20/(0.5*cg))*utils.sign(tz)if tA<0 then tA=0 end;local tB;if cK>100 then local tC,dP=co.computeDistanceAndTime(cK,100,cg,0,0,t9)local tD,dP=co.computeDistanceAndTime(100,0,cg,0,0,dm(t9))tB=tC+tD else tB=co.computeDistanceAndTime(cK,0,cg,0,0,dm(t9))end;if tB<20 then b0=false else local tE=0;if tA>100 then local tF,dP=co.computeDistanceAndTime(tA,100,cg,0,0,ty)local tG,dP=co.computeDistanceAndTime(100,0,cg,0,0,sl*tx+dm(t9)-oq)tE=tF+tG else tE,dP=co.computeDistanceAndTime(tA,0,cg,0,0,sl*tx+dm(t9)-oq)end;tE=(tE+15+cK*sd)*1.1;local tH=da and g4~=nil and ks:getAltitude(g4.position)>0 and g4.safe;local sp=nil;if tt and tt<cf then sp=tt elseif tH then sp=ks:getAltitude(g4.position)+250 elseif cf>ks.surfaceMaxAltitude then sp=ks.surfaceMaxAltitude end;if cZ then local tI=ks:getAltitude(cZ[1].center)if sp then if tI>sp then sp=tI end else sp=tI end end;if sp~=nil then local tJ=cf-sp;tv=true;if tJ<=tE or tE==-1 or tu>0.05 and da then if tu>0.05 and da then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qJ=cc;if qJ>-1 then if(cK<1 or cJ:normalize():dot(cL)<0)and not db then b6=false;b5=false;if not tt then qj=true;ix:setTargetGroundAltitude(Z)end;bX=0;b0="BL Complete"cy=p;da=false else b0="BL Slowing"end elseif not tv then if lz and cJ:normalize():dot(-gq)<0.999 then b0="BL Strong"qQ()elseif tu>10 or tu>0.05 and da then b0="BL hSpd"elseif cM<-O then b0="BL BLR"else b0=false end end end else qm=false end;if b7 or ca then local lE,eJ,eI;if bk~=nil then lE,eJ,eI=cn:getPlanetarySystem(0):castIntersections(cN,(bk-cN):normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)end;if cP and not ca then if cf>=ba-50 and cK>iQ then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"qg=0 end end elseif eY(sT)<15 and cf/ba>0.75 then b7=false;if not ca then if cQ and not t then d.control.cancelCurrentControlMasterMode()end elseif ca and cK<iQ then b3=true;ca=false;b5=false;b7=false;qg=0 elseif ca then qg=0;b0="ATO Space"end elseif ca and not cd and c5~=nil and(lE==nil or lE.name==c5.name)then b3=true;ca=false;b5=false;b7=false;if not cQ then qg=0 end;bb=true end end;local tK=cc>-1;local tL=cR;if(bq or ca or cW)and not tK and cK>aL and cd then local mP=math.rad(eY(cS))tL=cR*eY(math.cos(mP))+sf*math.sin(mP)end;local tM=dk(sT-tL,-N*0.80,N*0.80)if not cd and bq then tM=dk(sT-tL,-85,P)elseif not cd then tM=dk(sT-tL,-P,P)end;if eY(cS)<5 or bq or cW or b6 or tK or b5 then if t8==nil then t8=pid.new(5*0.01,0,5*0.1)end;t8:inject(tM)local sV=t8:get()q7=q7+sV end end;if antigrav~=nil and(antigrav and not q and cf<200000)then if bv==nil or bv<1000 then bv=1000 end;if tN~=bv then tN=bv;qq=tN end end;if(cd or b8 or cb)and t and cQ then if tO==nil then tO=pid.new(0.1,0,1)end;local tP=0;if aU>0 and not b8 and ce>0.005 and ce<0.1 and cM>-50 then tP=(0.1-ce)*cA*aU end;tO:inject(cA/3.6+tP-cJ:dot(cG))local tQ=tO:get()bR=dk(tQ,-1,1)if not d6 then if bR<bO and(ce>0.005 or b8 or cb)then bQ=true;d6=dk(bR,0.01,1)else bQ=false;d6=bO end end;if tR==nil then tR=pid.new(1*0.01,0,1*0.1)end;tR:inject(cJ:len()-cA/3.6-tP)local tS=dk(tR:get(),0,1)if cd and cM<-80 or(ce>0.005 or b8 or cb)then bP=tS end;if bP>0 then if bQ and bR==0.01 and not d6 then d6=0 end else bR=dk(bR,0.01,1)end;local tT=''local tU=vec3()local tV=ru(axisCommandId.vertical,bX*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tV,s9)local tW='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tW=tW..aV end;local tX=ix:getAxisCommandType(axisCommandId.longitudinal)local tY=ix:composeAxisAccelerationFromThrottle(tW,axisCommandId.longitudinal)local tZ=rI(axisCommandId.lateral,by*1000)tT=tT..' , '.."lateral airfoil , lateral ground "tU=tU+tZ;if tU:len()>constants.epsilon then d:setEngineForceCommand(tT,tU,s9,'','','',sa)end;d:setEngineForceCommand(tW,tY,s8)local t_='thrust analog vertical fueled 'local u0='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then u0=u0 ..aW end;if bC=="All"or bC=="Vertical"then t_=t_..aX end;if bX~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(t_,tV,s8)else d:setEngineForceCommand(t_,vec3(),s8)end;if by~=0 then d:setEngineForceCommand(u0,tZ,s8)else d:setEngineForceCommand(u0,vec3(),s8)end;if rV==0 then rV=bP end;local u1=-rV*(aQ*cJ+aR*rZ)d:setEngineForceCommand('brake',u1)else if t then if not d6 then d6=bO end end;local rw=c.getAxisCommandValue(0)if not cQ then if tR==nil then tR=pid.new(1*0.01,0,1*0.1)end;tR:inject(cJ:len()-rw/3.6)local tS=dk(tR:get(),0,1)rV=dk(rV+tS,0,1)end;local u1=-rV*(aQ*cJ+aR*rZ)d:setEngineForceCommand('brake',u1)local tT=''local tU=vec3()local u2=false;local tW='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tW=tW..aV end;local tX=ix:getAxisCommandType(axisCommandId.longitudinal)if tX==axisCommandType.byThrottle then local tY=ix:composeAxisAccelerationFromThrottle(tW,axisCommandId.longitudinal)d:setEngineForceCommand(tW,tY,s8)elseif tX==axisCommandType.byTargetSpeed then local tY=ix:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tT=tT..' , '..tW;tU=tU+tY;if ix:getTargetSpeed(axisCommandId.longitudinal)==0 or ix:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ix:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u2=true end end;local u0='thrust analog lateral 'if bC=="All"or bC=="Lateral"then u0=u0 ..aW end;local u3=ix:getAxisCommandType(axisCommandId.lateral)if u3==axisCommandType.byThrottle then local u4=ix:composeAxisAccelerationFromThrottle(u0,axisCommandId.lateral)d:setEngineForceCommand(u0,u4,s8)elseif u3==axisCommandType.byTargetSpeed then local tZ=ix:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tT=tT..' , '..u0;tU=tU+tZ end;local t_='thrust analog vertical 'if bC=="All"or bC=="Vertical"then t_=t_..aX end;local u5=ix:getAxisCommandType(axisCommandId.vertical)if u5==axisCommandType.byThrottle then local tV=ix:composeAxisAccelerationFromThrottle(t_,axisCommandId.vertical)if bX~=0 or b6 and b0 then d:setEngineForceCommand(t_,tV,s8,'airfoil','ground','',sa)else d:setEngineForceCommand(t_,vec3(),s8)d:setEngineForceCommand('airfoil vertical',tV,s8,'airfoil','','',sa)d:setEngineForceCommand('ground vertical',tV,s8,'ground','','',sa)end elseif u5==axisCommandType.byTargetSpeed then if bX<0 then d:setEngineForceCommand('hover',vec3(),s8)end;local u6=ix:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tT=tT..' , '..t_;tU=tU+u6 end;if tU:len()>constants.epsilon then if rV~=0 or u2 or eY(rZ:dot(cG))<0.5 then tT=tT..', brake'end;d:setEngineForceCommand(tT,tU,s9,'','','',sa)end end;local u7=aN*(s2-s1)local u8=vec3(bM.getWorldAirFrictionAngularAcceleration())u7=u7-u8;d:setEngineTorqueCommand('torque',u7,s8,'airfoil','','',sa)d:setBoosterCommand('rocket_engine')if c2 and not n then local fo=cI:len()local u9=0.15;if not cQ then local ua=ix:getTargetSpeed(axisCommandId.longitudinal)if fo*3.6>ua*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fo*3.6<ua*(1-u9)and not ub then ub=true;d:toggleBoosters()end else local rk=c.getThrottle()if t then rk=bO*100 end;local rw=rk/100;if not cd then rw=rw*aa;if fo>=rw*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fo<rw*(1-u9)and not ub then ub=true;d:toggleBoosters()end else local tg=bK(cA)rw=rw*tg/3.6;if fo>=rw*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fo<rw*(1-u9)and not ub then ub=true;d:toggleBoosters()end end end end end;if uc then for dK,dw in pairs(uc)do pP[dK]=dw end end;cc=qE()return pP end;local function ud(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ue,iw,ix,iy,uf,gL,fU,e3,dl,dk,fT,iA,pO)local bM=DUConstruct;local ug={}local uh=true;local ui=5;local uj=5;local uk=ui;local ul=uj;local um=bN;function ug.landingGear()bm=not bm;if bm then bq=false;bt=nil;cs.cmdThrottle(0)if vBooster or hover then if cd and cc==-1 then fT("bklOn","BL")lz=true;b8=false;b7=false;b9=false;b5=false;if b6 then da=not da end;b6=true;cy=true;bm=false else if bT then fT("grOut","LG",1)d.control.deployLandingGears()end;da=false;ix:setTargetGroundAltitude(Z)if cd then b0="Landing"end end elseif bT and not b6 then fT("grOut","LG",1)d.control.deployLandingGears()end else if bT then fT("grIn","LG",1)d.control.retractLandingGears()end;ix:activateGroundEngineAltitudeStabilization(un)if bB then if Z<ix.targetGroundAltitude then ix:setTargetGroundAltitude(ix.targetGroundAltitude)else ix:setTargetGroundAltitude(Y)end end end end;function ug.startControl(uo)local function up(rf)local rg=1;local function uq(ur,rf)local us={ks.surfaceMaxAltitude+100,ks.spaceEngineMinAltitude-0.01*ks.noAtmosphericDensityAltitude,ks.noAtmosphericDensityAltitude+U,ks.radius*(T-1)+ks.noAtmosphericDensityAltitude}local ut=ur;for dP,dw in ipairs(us)do if rf and ut>dw then ur=dw elseif ur<dw and not rf then ur=dw;break end end;return ur end;if rf then rg=-1 end;if not q and cP then if bZ and rf then bv=1000 elseif bv~=nil then bv=bv+rg*uj;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tN+rg*100 end elseif b5 or b9 or bz then if bz then if bZ then cC=uq(cC,rf)else cC=cC+rg*ui end;if cC<ks.noAtmosphericDensityAltitude then cC=ks.noAtmosphericDensityAltitude end else if bZ and cd then ba=uq(ba,rf)else ba=ba+rg*ui end end else ix:updateTargetGroundAltitudeFromActionStart(rg*1.0)end end;local function uu(uv)if not cd then c0="Flight Assist in Atmo only"return end;local dt=type(uv)if cW==nil then if dt=="table"then if b3 or bq then cs.ToggleAutopilot()end;fT("180On","BR")elseif uv==1 then fT("bnkLft","BR")else fT("bnkRht","BR")end;if not b5 and not b3 and not bq then cs.ToggleAltitudeHold()if dt~="table"then uv=uv+1 end end;cW=uv else fT("180Off","BR")cW=nil end end;local function uw()if iy()==1 then c6=0;c7=0;uf(bi)elseif iw()==1 and y then cx=false;cw=false end;bZ=false end;if uo=="gear"then cu.landingGear()elseif uo=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uo=="forward"then if pg and not cd and not b3 then b2=not b2;b1=false else bU=bU-1 end elseif uo=="backward"then if pg then if not cd then if not b3 then b1=not b1;b2=false else b4=not b4 end else uu(-cJ*5000)end else bU=bU+1 end elseif uo=="left"then if pg then uu(1)else bV=bV-1 end elseif uo=="right"then if pg then uu(3)else bV=bV+1 end elseif uo=="yawright"then bW=bW-1;db=nil elseif uo=="yawleft"then bW=bW+1;db=nil elseif uo=="straferight"then ix:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif uo=="strafeleft"then ix:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif uo=="up"then bX=bX+1;if cc-3<Z and cf>0 and bm then cu.landingGear()end;ix:deactivateGroundEngineAltitudeStabilization()ix:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif uo=="down"then bX=bX-1;ix:deactivateGroundEngineAltitudeStabilization()ix:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif uo=="groundaltitudeup"then up()elseif uo=="groundaltitudedown"then up(true)elseif uo=="option1"then ux=false;if pg and bZ then local uy=""for L=1,#d1 do uy=uy.."| Name: "..a.getPlayerName(d1[L]).." Mass: "..fU(bM.getBoardedPlayerMass(d1[L])/1000,1).."t "end;a.print("Onboard: "..uy)return end;cr.adjustAutopilotTargetIndex()elseif uo=="option2"then ux=false;if pg and bZ then for L=1,#d1 do bM.forceDeboard(d1[L])bM.forceInterruptVRSession(d1[L])end;c0="Deboarded All Passengers"return end;cr.adjustAutopilotTargetIndex(1)elseif uo=="option3"then local function uz()uh=not uh;if not uh then fT("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uA,atmofueltank_size,"Atmo Fuel","fuel_container")uB=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uC,spacefueltank_size,"Space Fuel","fuel_container")uD=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uE,rocketfueltank_size,"Rocket Fuel","fuel_container")uF=_autoconf.panels[_autoconf.panels_size]end;uG=a.createWidgetPanel("Docking")uH=a.createWidget(uG,"parenting")a.addDataToWidget(c.getWidgetDataId(),uH)uI=a.createWidgetPanel("Core combat stress")uJ=a.createWidget(uI,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uJ)if shield~=nil then shield.showWidget()end else fT("hud","DH")c.hideWidget()b.hideWidget()if uB~=nil then gL(uB)uB=nil end;if uG~=nil then gL(uG)uG=nil end;if uI~=nil then gL(uI)uI=nil end;if uD~=nil then gL(uD)uD=nil end;if uF~=nil then gL(uF)uF=nil end;if shield~=nil then shield.hideWidget()end end end;ux=false;if pg and bZ then local uy=""for L=1,#d2 do uy=uy.."| ID: "..d2[L].." Mass: "..fU(b.getDockedConstructMass(d2[L])/1000,1).."t "end;a.print("Docked Ships: "..uy)return end;if x then if w then w=false else w=true end end;uz()elseif uo=="option4"then ux=false;if pg and bZ then for L=1,#d2 do b.forceUndock(d2[L])end;c0="Undocked all ships"return end;cW=nil;cs.ToggleAutopilot()elseif uo=="option5"then ux=false;cs.ToggleLockPitch()elseif uo=="option6"then ux=false;if pg and bZ then if shield then cv.ventShield()else c0="No shield found"end;return end;cs.ToggleAltitudeHold()elseif uo=="option7"then ux=false;if pg and bZ then if shield then shield.toggle()return else c0="No shield found"return end end;E=not E;if E then c0="Collision System Enabled"else c0="Collision System Secured"end elseif uo=="option8"then ux=false;if pg and bZ then if bl>0 and g4~=nil then cs.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c0="DeCoupled Mode - Ground Stabilization off"ix:deactivateGroundEngineAltitudeStabilization()fT("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"ix:activateGroundEngineAltitudeStabilization(un)dd=true;fT("gsOn","GS")end elseif uo=="option9"then ux=false;if pg and bZ then ix:resetCommand(axisCommandId.longitudinal)ix:resetCommand(axisCommandId.lateral)ix:resetCommand(axisCommandId.vertical)cs.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ch=gyro.getState()==1;if ch then fT("gyOn","GA")else fT("gyOff","GA")end else c0="No gyro found"end elseif uo=="lshift"then c_=false;if pg then bZ=true elseif bZ then uw()else if iy()==1 then bZ=true;bi=iy()uf(1)elseif iw()==1 and y then bZ=true;cx=false;cw=false end end elseif uo=="brake"then if aZ or pg then cs.BrakeToggle("Manual")elseif not b0 then cs.BrakeToggle("Manual")else b0="Manual"end elseif uo=="lalt"then ux=true;pg=true;if iw()==0 and not i and g=="keyboard"then uf(1)end elseif uo=="booster"then if n then d:toggleBoosters()elseif not c2 then if not ub then d:toggleBoosters()ub=true end;c2=true else if ub then d:toggleBoosters()ub=false end;c2=false end elseif uo=="stopengines"then local function uK()if bN-um<1.5 then fT("clear","CA")cs.clearAll()end end;uK()um=bN;if ix:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bO~=0 then ix:resetCommand(axisCommandId.longitudinal)cs.cmdThrottle(0)else cs.cmdThrottle(100)end else if ix:getTargetSpeed(axisCommandId.longitudinal)~=0 then ix:resetCommand(axisCommandId.longitudinal)else if cd then cs.cmdCruise(cA)else cs.cmdCruise(aa*3.6)end end end elseif uo=="speedup"then if bZ and not pg then dg("RADAR OFF")return end;cs.changeSpd()elseif uo=="speeddown"then cs.changeSpd(true)elseif uo=="antigravity"and not q then if antigrav~=nil then cs.ToggleAntigrav()else c0="No antigrav found"end elseif uo=="leftmouse"then if pg and bZ then if ct then ct.ToggleRadarPanel()ct=nil;J=false;collectgarbage()else J=true;uL.radarSetup()end;ux=false elseif bZ then b_=true;uw()end end end;function ug.stopControl(uo)local function uM()if not q and cP then ul=uj end;if b5 or b9 or bz then uk=ui end end;if uo=="forward"then bU=0 elseif uo=="backward"then bU=0 elseif uo=="left"then if cW then if cW==2 then cW=-2 else cW=-1 end end;bV=0 elseif uo=="right"then if cW then if cW==4 then cW=-2 else cW=-1 end end;bV=0 elseif uo=="yawright"then bW=0 elseif uo=="yawleft"then bW=0 elseif uo=="straferight"then ix:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif uo=="strafeleft"then ix:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif uo=="up"then bX=0;ix:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bB then ix:activateGroundEngineAltitudeStabilization(un)dd=true end elseif uo=="down"then bX=0;ix:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bB then ix:activateGroundEngineAltitudeStabilization(un)dd=true end elseif uo=="groundaltitudeup"then uM()ux=false elseif uo=="groundaltitudedown"then uM()ux=false elseif uo=="brake"then if not aZ and not pg then if b0 then cs.BrakeToggle()else b0=false end end elseif uo=="lalt"then if bZ then bZ=false end;if iw()==0 and i then if ux then if iy()==1 then uf(0)else uf(1)end else ux=true end elseif iw()==0 and not i and g=="keyboard"then uf(0)end;pg=false end end;function ug.loopControl(uo)local function uN(rf)local rg=1;if rf then rg=-1 end;if not q and cP then if bv~=nil then bv=bv+rg*ul;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;ul=dk(ul*1.05,uj,50)else bv=tN+rg*100 end elseif b5 or b9 or bz then if bz then cC=cC+rg*uk;if cC<ks.noAtmosphericDensityAltitude then cC=ks.noAtmosphericDensityAltitude end else ba=ba+rg*uk end;uk=dk(uk*1.05,ui,50)else ix:updateTargetGroundAltitudeFromActionLoop(rg*1.0)end end;local function uO(rf)local rg=1;if rf then rg=-1 end;if not bZ then if t and not pg then bO=dk(bO+rg*aF/100,-1,1)else ix:updateCommandFromActionLoop(axisCommandId.longitudinal,rg*aF)end end end;if uo=="groundaltitudeup"then if not bZ then uN()end elseif uo=="groundaltitudedown"then if not bZ then uN(true)end elseif uo=="speedup"then uO()elseif uo=="speeddown"then uO(true)end end;function ug.inputTextControl(re)local function uP(uQ,fu,gy)local function uR(fu)local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local dT,dU,e0,e1,e2=e3(fu,dD)if dT=="0"and dU=="0"then return vec3(dl(e0),dl(e1),dl(e2))end;e1=math.rad(e1)e0=math.rad(e0)local ks=e[dl(dT)][dl(dU)]local eU=math.cos(e0)local uS=vec3(eU*math.cos(e1),eU*math.sin(e1),math.sin(e0))return ks.center+(ks.radius+e2)*uS end;local fW=uR(fu)return cr.AddNewLocation(uQ,fW,gy)end;local L;local uT,ik=nil,nil;local uU="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(re," ")uT=re;if L~=nil then uT=string.sub(re,0,L-1)ik=string.sub(re,L+1)end;if uT=="/help"or uT=="/commands"then for lA in string.gmatch(uU,"([^\n]+)")do a.print(lA)end;return elseif uT=="/setname"then if ik==nil or ik==""then c0="Usage: ah-setname Newname"return end;if bl>0 and g4~=nil then cr.UpdatePosition(ik)else c0="Select a saved target to rename first"end elseif shield and uT=="/resist"then cv.setResist(ik)elseif uT=="/addlocation"or string.find(re,"::pos")~=nil then local gy=false;local uQ="0-Temp"if ik==nil or ik==""or uT~="/addlocation"then ik=uT;gy=true end;L=string.find(ik,"::")if not gy then uQ=string.sub(ik,1,L-2)end;local fu=string.sub(ik,L)uP(uQ,fu,gy)elseif uT=="/agg"then if ik==nil or ik==""then c0="Usage: /agg targetheight"return end;ik=dl(ik)if ik<1000 then ik=1000 end;bv=ik;c0="AGG Target Height set to "..ik elseif uT=="/G"then if ik==nil or ik==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ik=="dump"then for dK,dw in pairs(iA())do if type(dw.get())=="boolean"then if dw.get()==true then a.print(dK.." true")else a.print(dK.." false")end elseif dw.get()==nil then a.print(dK.." nil")else a.print(dK.." "..dw.get())end end;return end;L=string.find(ik," ")local uV=string.sub(ik,0,L-1)local uW=string.sub(ik,L+1)for dK,dw in pairs(iA())do if dK==uV then local uX=type(dw.get())if uX=="number"then uW=dl(uW)if dK=="AtmoSpeedLimit"then cA=uW end end;c0="Variable "..uV.." changed to "..uW;if dK=="MaxGameVelocity"then uW=uW/3.6;if uW>de-0.2 then uW=de-0.2;c0="Variable "..uV.." changed to "..fU(uW*3.6,1)end end;if uX=="boolean"then if string.lower(uW)=="true"then uW=true else uW=false end end;dw.set(uW)return end end;c0="No such global variable: "..uV elseif uT=="/deletewp"then if bl>0 and g4~=nil then cr.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif uT=="/copydatabank"then if dbHud_2 then pO(true)else c0="Spare Databank required to copy databank"end elseif uT=="/iphWP"then if bl>0 then a.print(cs.showWayPoint(c5,bk,true))a.print(json.encode(bk))c0="::pos waypoint shown in lua chat in local and world format"else c0="No target selected in IPH"end elseif uT=="/createPrivate"then local uY="privatelocations = {\n"local uZ=""if#d8>0 then for dK,dw in pairs(d8)do uY=uY.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uY=uY.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uY=uY.."safe = true},\n"else uY=uY.."safe = false},\n"end end end;uZ=#d8 .."-Private "if ik=="all"then for dK,dw in pairs(bp)do uY=uY.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '*"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uY=uY.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uY=uY.." safe = true},\n"else uY=uY.."safe = false},\n"end end;uZ=uZ..#bp.."-Public "end;uY=uY.."}\n return privatelocations"if ue then ue.setHTML(uY)end;c0=uZ.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c1=7 end end;function ug.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c0="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if u_ then for dK,dw in pairs(u_)do ug[dK]=dw end end;return ug end;local function v0(d,b,c,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,it,ue)local a=DUSystem;local bM=DUConstruct;local v1=DUPlayer;local v2=DULibrary;local v3={}local dj=string.format;local iu=json.decode;local v4=json.encode;local pG=b.getElementMaxHitPointsById;local iv=b.getElementMassById;local iw=d.control.isRemoteControlled;local e3=string.match;local gL=a.destroyWidgetPanel;local fR=a.updateData;local fS=a.addDataToWidget;local uf=a.lockView;local iy=a.isViewLocked;local dm=math.sqrt;local dl=tonumber;local eY=math.abs;local bK=math.floor;local bL=c.getAtmosphereDensity;local eT=math.atan;local bJ=a.getArkTime;local dk=utils.clamp;local ix=d.axisCommandManager;local v5=Z;local gN=13;local iD=b.getElementIdList()local iE=0;local function dn(eB,eC)if eB==0 then return eY(eC)<1e-09 end;if eC==0 then return eY(eB)<1e-09 end;return eY(eB-eC)<math.max(eY(eB),eY(eC))*dB end;local function fU(dC,v6)local rg=10^(v6 or 0)return bK(dC*rg+0.5)/rg end;local function iz(v7,v8)for dK,dw in pairs(v8)do if type(dK)=="string"then v7[dK]=dw else v7[#v7+1]=v8[dK]end end;return v7 end;local function iA(v9)local va={}if not v9 then iz(va,K)iz(va,a9)iz(va,aD)iz(va,aY)return va elseif v9=="boolean"then return K elseif v9=="handling"then return a9 elseif v9=="hud"then return aD elseif v9=="physics"then return aY end end;local function pO(vb)local function vc(vd)for dK,dw in pairs(vd)do dbHud_1.setStringValue(dK,v4(dw.get()))if vb and dbHud_2 then dbHud_2.setStringValue(dK,v4(dw.get()))end end end;if dbHud_1 then vc(bG)vc(iA())a.print("Saved Variables to Datacore")if vb and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function fT(ve,vf,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..ve..".mp3")end;local function gM(ht,hu,re,jK,vg)if jK==nil then jK=""end;if vg==nil then vg=""end;return dj([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jK,ht,hu,vg,re)end;local function iB(c8,vh)local vi=c8>100000;if vh==nil then vh=1 end;if vi then return fU(c8/1000/200,vh).."SU"elseif c8<1000 then return fU(c8,vh).."M"else return fU(c8/1000,vh).."KM"end end;local function iC(vj)local vk=0;local vl=0;local vm=0;if vj<60 then vj=bK(vj)elseif vj<3600 then vk=bK(vj/60)vj=bK(vj%60)elseif vj<86400 then vl=bK(vj/3600)vk=bK(vj%3600/60)else vm=bK(vj/86400)vl=bK(vj%86400/3600)end;if vm>0 then return vm.."d "..vl.."h "elseif vl>0 then return vl.."h "..vk.."m "elseif vk>0 then return vk.."m "..vj.."s"elseif vj>0 then return vj.."s"else return"0s"end end;local function vn()if radar_1 and J then ct=gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)end end;function v3.radarSetup()vn()end;function v3.onStart()local vo=false;local function vp()local function vq(vr)local vs=dbHud_1.hasKey;for dK,dw in pairs(vr)do if vs(dK)then local dF=iu(dbHud_1.getStringValue(dK))if dF~=nil then dw.set(dF)vo=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vq(iA())coroutine.yield()vq(bG)else vq(bG)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"c1=5;vo=false end;coroutine.yield()if vo then c0="Loaded Saved Variables"elseif not f then c0="No Databank Saved Variables Found\nVariables will save to Databank on standing"c1=5 end;if#bp>0 then d9=iz(d9,bp)end else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;ci=ab;cj=ac;aZ=j;g=string.lower(g)cy=p;cA=V;if bw+180<bN then bu=0 end;bw=bN;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c1=7 end;if antigrav and not q then if bv==nil then bv=cf end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d8>0 then d9=iz(d9,d8)end end;lI="Proceeding to Waypoint"if not aa or aa<0 then aa=bM.getMaxSpeed()-0.1 end end;local function vt()local function vu(vv,vw)if vv>vw then vw=vv end;local vx,vy=0,0;if a5>0 then vx=a5*0.05 end;if a6>0 then vy=a6*0.05 end;vw=vw*(1-(vx+vy))return vw end;local vz=b.getElementNameById;local vA=as~=0 and at~=0;local vB=_G["atmofueltank_size"]local vC=_G["spacefueltank_size"]local vD=_G["rocketfueltank_size"]for dK in pairs(iD)do local type=b.getElementDisplayNameById(iD[dK])if e3(type,'^.*Atmospheric Engine$')then if e3(tostring(b.getElementTagsById(iD[dK])),'^.*vertical.*$')and b.getElementForwardById(iD[dK])[3]>0 then cO=true end end;if e3(type,'^.*Space Engine$')then cF=true;if e3(tostring(b.getElementTagsById(iD[dK])),'^.*vertical.*$')then local vE=b.getElementForwardById(iD[dK])if vE[3]<0 then vF=true else cE=true end end end;if type=="Landing Gear"then bT=true end;if type=="Dynamic Core Unit"then local pI=pG(iD[dK])if pI>10000 then gN=110 elseif pI>1000 then gN=55 elseif pI>150 then gN=27 end end;iE=iE+pG(iD[dK])if vA and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pI=pG(iD[dK])local oz=iv(iD[dK])local vv=0;local jD=bJ()if type=="Atmospheric Fuel Tank"then local vw=400;local vG=35.03;if pI>10000 then vw=51200;vG=5480 elseif pI>1300 then vw=6400;vG=988.67 elseif pI>150 then vw=1600;vG=182.67 end;vv=oz-vG;if a2>0 then vw=vw+vw*a2*0.2 end;vw=vu(vv,vw)local gx=vz(iD[dK])local jB=0;for jC=1,vB do if gx==iu(c["atmofueltank_"..jC].getWidgetData()).name then jB=jC;break end end;local vH={iD[dK],string.sub(gx,1,12),vw,vG,vv,jD,jB}ck[#ck+1]=vH end;if type=="Rocket Fuel Tank"then local vw=320;local vG=173.42;if pI>65000 then vw=40000;vG=25740 elseif pI>6000 then vw=5120;vG=4720 elseif pI>700 then vw=640;vG=886.72 end;vv=oz-vG;if a4>0 then vw=vw+vw*a4*0.1 end;vw=vu(vv,vw)local gx=vz(iD[dK])local jB=0;for jC=1,vD do if gx==iu(c["rocketfueltank_"..jC].getWidgetData()).name then jB=jC;break end end;local vH={iD[dK],string.sub(gx,1,12),vw,vG,vv,jD,jB}cm[#cm+1]=vH end;if type=="Space Fuel Tank"then local vw=600;local vG=35.03;if pI>10000 then vw=76800;vG=5480 elseif pI>1300 then vw=9600;vG=988.67 elseif pI>150 then vw=2400;vG=182.67 end;vv=oz-vG;if a3>0 then vw=vw+vw*a3*0.2 end;vw=vu(vv,vw)local gx=vz(iD[dK])local jB=0;for jC=1,vC do if gx==iu(c["spacefueltank_"..jC].getWidgetData()).name then jB=jC;break end end;local vH={iD[dK],string.sub(gx,1,12),vw,vG,vv,jD,jB}cl[#cl+1]=vH end end end;if not cO then b9,a_=false,false end end;local function vI()if gyro~=nil then ch=gyro.isActive()==1 end;if not bB then ix:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uf(1)else uf(0)end;if door and(cd or not cd and cf<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cd or not cd==0 and cf<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;if antigrav then cP=antigrav.isActive()==1;if cP and not q then antigrav.showWidget()end end;if iw()==1 and k then v1.freeze(1)else v1.freeze(0)end;if bT then if cc~=-1 and not cP then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or cc~=-1 and cc-3<Z;if cc~=-1 or not cd and cI:len()<50 then b0="Startup"else b0=false end;ix:setTargetGroundAltitude(v5)pu=cd end;local function vJ()local vK={}local function vL()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vM={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vN={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vO,vP in pairs(e)do e[vO][0]=vL()e[vO][0].systemId=vO;vK[vO]={}for vQ,ks in pairs(e[vO])do ks.gravity=ks.gravity/9.8;ks.center=vec3(ks.center)ks.name=ks.name[1]ks.noAtmosphericDensityAltitude=vN[ks.id]or ks.atmosphereThickness or ks.atmosphereRadius-ks.radius;ks.spaceEngineMinAltitude=vM[ks.id]or 0.68377*ks.atmosphereThickness;ks.planetarySystemId=vO;ks.bodyId=ks.id;vK[vO][vQ]=ks;if mA==nil or ks.center.x<mA then mA=ks.center.x end;if mz==nil or ks.center.x>mz then mz=ks.center.x end;if mD==nil or ks.center.y<mD then mD=ks.center.y end;if mC==nil or ks.center.y>mC then mC=ks.center.y end;if ks.center and ks.name~="Space"then d3[#d3+1]=ks end end end;ed=di(d,b,c,a,dj,dk,dl,dm,dn)cn=ed(vK)co=eX(d,b,c,a,dm,eY)cp=fq(d,b,c,a,dj,dk,dl,dm,dn)cr=fQ(d,b,c,a,dbHud_1,e,fR,fS,bK,dl,dm,fT,fU)ks=cn[0]:closestBody(bM.getWorldPosition())end;vR=false;vS=coroutine.create(function()ix:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vp()coroutine.yield()vt()coroutine.yield()cs=pM(d,b,c,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,eY,bK,bL,iw,eT,bJ,dk,ix,fR,iy,dm,fU,fT,iz,dn,iB,iC,pO,iu,dj,fS)vI()coroutine.yield()vJ()vn()if is then cq=is(d,b,c,a,e,antigrav,hover,shield,warpdrive,it,eY,bK,dj,iu,bL,iv,iw,eT,bJ,dk,ix,fS,fR,gL,iy,dm,fU,gM,fT,iz,iA,iB,iC,iD,iE)end;if cq then cq.ButtonSetup()end;cu=ud(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ue,iw,ix,iy,uf,gL,fU,e3,dl,dk,fT,iA,pO)if shield then cv=ia(shield,e3,bK)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ue then ue.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vT then uL.ExtraOnStart()end;fT("start","SU")end)coroutine.resume(vS)end;function v3.onUpdate()if not vR then local i2=coroutine.status(vS)if i2=="suspended"then local dL,i3=coroutine.resume(vS)if i3 then a.print("ERROR STARTUP: "..i3)end elseif i2=="dead"then vR=true end end;if vR then d:update()if cd and t and cQ then if cQ and bS then cs.cmdThrottle(0)bS=false elseif not cQ and not bS then bO=0;bS=true end end;if d6 then ix:setThrottleCommand(axisCommandId.longitudinal,d6)d6=nil end;if not cw and pi~=vU then a.setScreen(pi)end;vU=pi;if vT then uL.ExtraOnUpdate()end end end;function v3.onFlush()if vR then cs.onFlush()if vT then uL.ExtraOnFlush()end end end;function v3.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ce>0 or ce==0 and cf<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(ce>0 or ce==0 and cf<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;w=d5;pO()if o8 then o8.activate()end;if z then cs.showWayPoint(ks,cN)end;if cq then a.print(cq.FuelUsed("atmofueltank")..", "..cq.FuelUsed("spacefueltank")..", "..cq.FuelUsed("rocketfueltank"))end;if vT then uL.ExtraOnStop()end;fT("stop","SU")end;function v3.controlStart(uo)if vR then cu.startControl(uo)end end;function v3.controlStop(uo)if vR then cu.stopControl(uo)end end;function v3.controlLoop(uo)if vR then cu.loopControl(uo)end end;function v3.controlInput(re)if vR then cu.inputTextControl(re)end end;function v3.radarEnter(dU)if ct then ct.onEnter(dU)end end;function v3.radarLeave(dU)if ct then ct.onLeave(dU)end end;function v3.onTick(vV)if vV=="tenthSecond"then cs.TenthTick()if cq then cq.TenthTick()end elseif vV=="oneSecond"then if cq then cq.OneSecondTick()end elseif vV=="fiveSecond"then cs.SatNavTick()elseif vV=="msgTick"then if cq then cq.MsgTick()end elseif vV=="animateTick"then if cq then cq.AnimateTick()end elseif vV=="hudTick"then if cq then cq.hudtick()end elseif vV=="apTick"then cs.APTick()elseif vV=="shieldTick"then cv.shieldTick()elseif vV=="tagTick"then cu.tagTick()elseif vV=="contact"then ct.ContactTick()end end;if vT then for dK,dw in pairs(vT)do v3[dK]=dw end end;return v3 end;function script.onStart()uL.onStart()end;function script.onOnStop()uL.onStop()end;function script.onTick(vV)uL.onTick(vV)end;function script.onOnFlush()uL.onFlush()end;function script.onOnUpdate()uL.onUpdate()end;function script.onActionStart(uo)uL.controlStart(uo)end;function script.onActionStop(uo)uL.controlStop(uo)end;function script.onActionLoop(uo)uL.controlLoop(uo)end;function script.onInputText(re)uL.controlInput(re)end;function script.onEnter(dU)uL.radarEnter(dU)end;function script.onLeave(dU)uL.radarLeave(dU)end;bI(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)uL=v0(d,core,unit,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,it,ue)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
