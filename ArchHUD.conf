name: ArchHud - Archaegeo v0.711 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.711;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(K)t=K end,get=function()return t end},AtmoSpeedAssist={set=function(K)u=K end,get=function()return u end},ForceAlignment={set=function(K)v=K end,get=function()return v end},DisplayDeadZone={set=function(K)w=K end,get=function()return w end},showHud={set=function(K)x=K end,get=function()return x end},hideHudOnToggleWidgets={set=function(K)y=K end,get=function()return y end},ShiftShowsRemoteButtons={set=function(K)z=K end,get=function()return z end},SetWaypointOnExit={set=function(K)A=K end,get=function()return A end},AlwaysVSpd={set=function(K)B=K end,get=function()return B end},BarFuelDisplay={set=function(K)C=K end,get=function()return C end},voices={set=function(K)D=K end,get=function()return D end},alerts={set=function(K)E=K end,get=function()return E end},CollisionSystem={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end}}a8=1920;a9=1080;aa=400;ab=130;ac=224;ad=255;ae=255;af=0;ag=0;ah=960;ai=540;aj=1300;ak=540;al=1525;am=325;an=550;ao=540;ap=30;aq=700;ar=1750;as=250;at=50;au=250;av=0;aw=30;ax=100;ay={ResolutionX={set=function(K)a8=K end,get=function()return a8 end},ResolutionY={set=function(K)a9=K end,get=function()return a9 end},circleRad={set=function(K)aa=K end,get=function()return aa end},SafeR={set=function(K)ab=K end,get=function()return ab end},SafeG={set=function(K)ac=K end,get=function()return ac end},SafeB={set=function(K)ad=K end,get=function()return ad end},PvPR={set=function(K)ae=K end,get=function()return ae end},PvPG={set=function(K)af=K end,get=function()return af end},PvPB={set=function(K)ag=K end,get=function()return ag end},centerX={set=function(K)ah=K end,get=function()return ah end},centerY={set=function(K)ai=K end,get=function()return ai end},throtPosX={set=function(K)aj=K end,get=function()return aj end},throtPosY={set=function(K)ak=K end,get=function()return ak end},vSpdMeterX={set=function(K)al=K end,get=function()return al end},vSpdMeterY={set=function(K)am=K end,get=function()return am end},altMeterX={set=function(K)an=K end,get=function()return an end},altMeterY={set=function(K)ao=K end,get=function()return ao end},fuelX={set=function(K)ap=K end,get=function()return ap end},fuelY={set=function(K)aq=K end,get=function()return aq end},shieldX={set=function(K)ar=K end,get=function()return ar end},shieldY={set=function(K)as=K end,get=function()return as end},DeadZone={set=function(K)at=K end,get=function()return at end},OrbitMapSize={set=function(K)au=K end,get=function()return au end},OrbitMapX={set=function(K)av=K end,get=function()return av end},OrbitMapY={set=function(K)aw=K end,get=function()return aw end},soundVolume={set=function(K)ax=K end,get=function()return ax end}}az=5;aA=1;aB=0.003;aC=0.003;aD=2;aE=1.5;aF=180;aG=150;aH=0.002;aI=2;aJ=0.8;aK=1;aL=3;aM=1;aN=40;aO=0.0166667;aP=0.0666667;aQ="none"aR="none"aS="none"aT={speedChangeLarge={set=function(K)az=K end,get=function()return az end},speedChangeSmall={set=function(K)aA=K end,get=function()return aA end},MouseXSensitivity={set=function(K)aB=K end,get=function()return aB end},MouseYSensitivity={set=function(K)aC=K end,get=function()return aC end},autoRollFactor={set=function(K)aD=K end,get=function()return aD end},rollSpeedFactor={set=function(K)aE=K end,get=function()return aE end},autoRollRollThreshold={set=function(K)aF=K end,get=function()return aF end},minRollVelocity={set=function(K)aG=K end,get=function()return aG end},TrajectoryAlignmentStrength={set=function(K)aH=K end,get=function()return aH end},torqueFactor={set=function(K)aI=K end,get=function()return aI end},pitchSpeedFactor={set=function(K)aJ=K end,get=function()return aJ end},yawSpeedFactor={set=function(K)aK=K end,get=function()return aK end},brakeSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeFlatFactor={set=function(K)aM=K end,get=function()return aM end},DampingMultiplier={set=function(K)aN=K end,get=function()return aN end},apTickRate={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraLongitudeTags={set=function(K)aQ=K end,get=function()return aQ end},ExtraLateralTags={set=function(K)aR=K end,get=function()return aR end},ExtraVerticalTags={set=function(K)aS=K end,get=function()return aS end}}aU=j;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=1000;b6=false;b7=false;b8=false;b9=false;ba=0;bb="Aligning"bc=0;bd=1;be="None"bf=nil;bg=0;bh=nil;bi=0.0;bj=0;bk={}bl=false;bm=0;bn=0;bo=nil;bp=0;bq=1000;br=0;bs=false;bt=0;bu=false;bv="All"bw=true;bx="Off"by=0.000;bz={}bA={VertTakeOff={set=function(K)b4=K end,get=function()return b4 end},VertTakeOffEngine={set=function(K)aV=K end,get=function()return aV end},SpaceTarget={set=function(K)bs=K end,get=function()return bs end},BrakeToggleStatus={set=function(K)aU=K end,get=function()return aU end},BrakeIsOn={set=function(K)aW=K end,get=function()return aW end},RetrogradeIsOn={set=function(K)aX=K end,get=function()return aX end},ProgradeIsOn={set=function(K)aY=K end,get=function()return aY end},Autopilot={set=function(K)aZ=K end,get=function()return aZ end},TurnBurn={set=function(K)a_=K end,get=function()return a_ end},AltitudeHold={set=function(K)b0=K end,get=function()return b0 end},BrakeLanding={set=function(K)b1=K end,get=function()return b1 end},Reentry={set=function(K)b3=K end,get=function()return b3 end},AutoTakeoff={set=function(K)b2=K end,get=function()return b2 end},HoldAltitude={set=function(K)b5=K end,get=function()return b5 end},AutopilotAccelerating={set=function(K)b6=K end,get=function()return b6 end},AutopilotBraking={set=function(K)b8=K end,get=function()return b8 end},AutopilotCruising={set=function(K)b9=K end,get=function()return b9 end},AutopilotRealigned={set=function(K)b7=K end,get=function()return b7 end},AutopilotEndSpeed={set=function(K)ba=K end,get=function()return ba end},AutopilotStatus={set=function(K)bb=K end,get=function()return bb end},AutopilotPlanetGravity={set=function(K)bc=K end,get=function()return bc end},PrevViewLock={set=function(K)bd=K end,get=function()return bd end},AutopilotTargetName={set=function(K)be=K end,get=function()return be end},AutopilotTargetCoords={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetIndex={set=function(K)bg=K end,get=function()return bg end},TotalDistanceTravelled={set=function(K)bi=K end,get=function()return bi end},TotalFlightTime={set=function(K)bj=K end,get=function()return bj end},SavedLocations={set=function(K)bk=K end,get=function()return bk end},VectorToTarget={set=function(K)bl=K end,get=function()return bl end},LocationIndex={set=function(K)bm=K end,get=function()return bm end},LastMaxBrake={set=function(K)bn=K end,get=function()return bn end},LockPitch={set=function(K)bo=K end,get=function()return bo end},LastMaxBrakeInAtmo={set=function(K)bp=K end,get=function()return bp end},AntigravTargetAltitude={set=function(K)bq=K end,get=function()return bq end},LastStartTime={set=function(K)br=K end,get=function()return br end},iphCondition={set=function(K)bv=K end,get=function()return bv end},stablized={set=function(K)bw=K end,get=function()return bw end},UseExtra={set=function(K)bx=K end,get=function()return bx end},SelectedTab={set=function(K)bB=K end,get=function()return bB end},saveRoute={set=function(K)bz=K end,get=function()return bz end}}local function bC(a,b,c,bD,bE,bF)bG=bD()bH=ab;bI=ad;bJ=ac;bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=false;bR=false;bS=0;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=false;b_=false;bZ=false;b_=false;c0="empty"c1=false;c2=0;c3=0;c4=nil;c5=0;c6=0;c7=0;c8=0;c9=0;ca=3;cb=0;cc=""cd=false;ce=false;cf=false;cg=-1;ch=bF()>0;ci=bF()cj=b.getAltitude()ck=bD()cl=b.getConstructMass()cm=false;cn=nil;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]cq=a8;cr=a9;cs={}ct={}cu={}cv=false;cw=nil;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=false;cG=false;cH=p;cI=false;cJ=0;cK=U;cL=0;cM=nil;cN={VectorToTarget=false}cO=0;cP=false;cQ=false;cR=false;cS=vec3(b.getConstructWorldOrientationUp())cT=vec3(b.getConstructWorldOrientationForward())cU=vec3(b.getConstructWorldOrientationRight())cV=vec3(b.getVelocity())cW=vec3(b.getWorldVelocity())cX=vec3(cW):len()cY=vec3(b.getWorldVertical())cZ=-cY:dot(cW)c_=vec3(b.getConstructWorldPos())d0=false;d1=false;d2=nil;d3=true;d4=0;d5=0;d6={}d7=false;d8=50000;d9=nil;da={}db=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;dc=false;dd=nil;de=false;df=0;dg=nil;dh=nil;di={}dj=90;dk=x;dl=nil;dm=nil;dn={}dp={}end;local function dq(d,b,c,a,dr,ds,dt,du,dv)local function dw(dx)return type(dx)=='number'end;local function dy(dx)return type(dt(dx))=='number'end;local function dz(dA)return type(dA)=='table'end;local function dB(a)return type(a)=='string'end;local function dC(dD)return dz(dD)and dw(dD.x and dD.y and dD.z)end;local function dE(dF)return dz(dF)and dw(dF.latitude and dF.longitude and dF.altitude and dF.id and dF.systemId)end;local dG=math.pi/180;local dH=180/math.pi;local dI=1e-10;local dJ=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dK='::pos{'..dJ..','..dJ..','..dJ..','..dJ..','..dJ..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dL(dx)local dM=string.gsub(string.reverse(dr('%.4f',dx)),'^0*%.?','')return dM==''and'0'or string.reverse(dM)end;local function dN(dO)if dC(dO)then return dr('{x=%.3f,y=%.3f,z=%.3f}',dO.x,dO.y,dO.z)end;if dz(dO)and not getmetatable(dO)then local dP={}local dQ=next(dO)if type(dQ)=='nil'or dQ==1 then dP=dO else for dR,dD in pairs(dO)do local dS=dN(dD)if type(dR)=='number'then table.insert(dP,dr('[%s]=%s',dR,dS))else table.insert(dP,dr('%s=%s',dR,dS))end end end;return dr('{%s}',table.concat(dP,','))end;if dB(dO)then return dr("'%s'",dO:gsub("'",[[\']]))end;return tostring(dO)end;local dT={}dT.__index=dT;dT.__tostring=function(dO,dU)local dV={}for dR in pairs(dO)do table.insert(dV,dR)end;table.sort(dV)local dP={}for dW,dR in ipairs(dV)do local dS=dN(dO[dR])if type(dR)=='number'then table.insert(dP,dr('[%s]=%s',dR,dS))else table.insert(dP,dr('%s=%s',dR,dS))end end;if dU then return dr('%s%s',dU,table.concat(dP,',\n'..dU))end;return dr('{%s}',table.concat(dP,','))end;dT.__eq=function(dX,dY)return dX.systemId==dY.systemId and dX.id==dY.id and dv(dX.radius,dY.radius)and dv(dX.center.x,dY.center.x)and dv(dX.center.y,dY.center.y)and dv(dX.center.z,dY.center.z)and dv(dX.GM,dY.GM)end;local function dZ(d_,e0,e1,e2,e3)assert(dy(d_),'Argument 1 (systemId) must be a number:'..type(d_))assert(dy(e0),'Argument 2 (id) must be a number:'..type(e0))assert(dy(e1),'Argument 3 (radius) must be a number:'..type(e1))assert(dz(e2),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e2))assert(dy(e3),'Argument 5 (GM) must be a number:'..type(e3))return setmetatable({systemId=dt(d_),id=dt(e0),radius=dt(e1),center=vec3(e2),GM=dt(e3)},dT)end;local e4={}e4.__index=e4;e4.__tostring=function(e5)return dr('::pos{%d,%d,%s,%s,%s}',e5.systemId,e5.id,dL(e5.latitude*dH),dL(e5.longitude*dH),dL(e5.altitude))end;e4.__eq=function(dX,dY)return dX.id==dY.id and dX.systemId==dY.systemId and dv(dX.latitude,dY.latitude)and dv(dX.altitude,dY.altitude)and(dv(dX.longitude,dY.longitude)or dv(dX.latitude,math.pi/2)or dv(dX.latitude,-math.pi/2))end;local function e6(e7,e0,e8,e9,ea)local d_=e7;if dB(e7)and not e9 and not ea and not e0 and not e8 then d_,e0,e8,e9,ea=eb(e7,dK)assert(d_,'Argument 1 (position string) is malformed.')else assert(dy(d_),'Argument 1 (systemId) must be a number:'..type(d_))assert(dy(e0),'Argument 2 (id) must be a number:'..type(e0))assert(dy(e8),'Argument 3 (latitude) must be in degrees:'..type(e8))assert(dy(e9),'Argument 4 (longitude) must be in degrees:'..type(e9))assert(dy(ea),'Argument 5 (altitude) must be in meters:'..type(ea))end;d_=dt(d_)e0=dt(e0)e8=dt(e8)e9=dt(e9)ea=dt(ea)if e0==0 then return setmetatable({latitude=e8,longitude=e9,altitude=ea,id=e0,systemId=d_},e4)end;return setmetatable({latitude=dG*ds(e8,-90,90),longitude=dG*(e9%360),altitude=ea,id=e0,systemId=d_},e4)end;local ec={}ec.__index=ec;ec.__tostring=function(dO,dU)local ed=dU and dU..'  'local ee={}local dV={}for dR in pairs(dO)do table.insert(dV,dR)end;table.sort(dV)for dW,ef in ipairs(dV)do eg=dO[ef]local eh=dT.__tostring(eg,ed)if dU then table.insert(ee,dr('[%s]={\n%s\n%s}',ef,eh,dU))else table.insert(ee,dr('  [%s]=%s',ef,eh))end end;if dU then return dr('\n%s%s%s',dU,table.concat(ee,',\n'..dU),dU)end;return dr('{\n%s\n}',table.concat(ee,',\n'))end;local function ei(ej)local e={}local pid;for dW,dD in pairs(ej)do local e0=dD.planetarySystemId;if type(e0)~='number'then error('Invalid planetary s ID: '..tostring(e0))elseif pid and e0~=pid then error('Mistringmatch planetary s IDs: '..e0 ..' and '..pid)end;local ek=dD.bodyId;if type(ek)~='number'then error('Invalid body ID: '..tostring(ek))elseif e[ek]then error('Duplicate body ID: '..tostring(ek))end;setmetatable(dD.center,getmetatable(vec3.unit_x))e[ek]=setmetatable(dD,dT)pid=e0 end;return setmetatable(e,ec)end;el={}local function em(ej)return setmetatable({galaxyAtlas=ej or{}},el)end;el.__index=function(dA,K)if type(K)=='number'then local a=dA.galaxyAtlas[K]return ei(a)end;return rawget(el,K)end;el.__pairs=function(dO)return function(dA,dR)local en,eo=next(dA,dR)return en,eo and ei(eo)end,dO.galaxyAtlas,nil end;el.__tostring=function(dO)local ep={}for dW,eq in pairs(dO or{})do local er=eq:getPlanetarySystemId()local es=ec.__tostring(eq,'    ')table.insert(ep,dr('  [%s]={%s\n  }',er,es))end;return dr('{\n%s\n}\n',table.concat(ep,',\n'))end;el.BodyParameters=dZ;el.MapPosition=e6;el.PlanetarySystem=ei;function el.createBodyParameters(d_,e0,et,eu,ev,ew,ex)assert(dy(d_),'Argument 1 (systemId) must be a number:'..type(d_))assert(dy(e0),'Argument 2 (id) must be a number:'..type(e0))assert(dy(et),'Argument 3 (surfaceArea) must be a number:'..type(et))assert(dz(eu),'Argument 4 (aPosition) must be an array or vec3:'..type(eu))assert(dz(ev),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ev))assert(dy(ew),'Argument 6 (altitude) must be in meters:'..type(ew))assert(dy(ex),'Argument 7 (gravityAtPosition) must be number:'..type(ex))local e1=du(et/4/math.pi)local cb=e1+ew;local ey=vec3(eu)+cb*vec3(ev)local e3=ex*cb*cb;return dZ(d_,e0,e1,ey,e3)end;el.isMapPosition=dE;function el:getPlanetarySystem(e7)if K==nil then K=0 end;if eo==nil then eo=0 end;local d_=e7;if dE(e7)then d_=e7.systemId end;if type(d_)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(eo)~=ec then a=ei(a)end;return a end end end;function ec:sizeCalculator(ez)return 1.05*ez.radius end;function ec:castIntersections(eA,eB,eC,eD,eE,eF)local eG={}if eE then for dW,ez in pairs(eE)do table.insert(eG,ez)end else eG=di end;if not eF then table.sort(eG,function(eH,eI)local eJ=eH.center;local eK=eI.center;return(eJ.x-eA.x)^2+(eJ.y-eA.y)^2+(eJ.z-eA.z)^2<(eK.x-eA.x)^2+(eK.y-eA.y)^2+(eK.z-eA.z)^2 end)end;local eL=eB:normalize()for dW,ez in ipairs(eG)do local eM=ez.center-eA;local e1=self:sizeCalculator(ez)local eN=eM:dot(eL)local eO=eN^2-(eM:len2()-e1^2)if eO>=0 then local eP=du(eO)local eQ=eN+eP;local eR=eN-eP;if eR>0 then return ez,eQ,eR elseif eQ>0 then return ez,eQ,nil end end end;return nil,nil,nil end;function ec:closestBody(eS)assert(type(eS)=='table','Invalid coordinates.')local eT,ez;local eU=vec3(eS)for dW,eV in pairs(self)do local eW=(eV.center-eU):len2()if(not ez or eW<eT)and eV.name~="Space"then ez=eV;eT=eW end end;return ez end;function ec:convertToBodyIdAndWorldCoordinates(e7)local eX=e7;if dB(e7)then eX=e6(e7)end;if eX.id==0 then return 0,vec3(eX.latitude,eX.longitude,eX.altitude)end;local eV=self:getBodyParameters(eX)if eV then return eX.id,eV:convertToWorldCoordinates(eX)end end;function ec:getBodyParameters(e7)local e0=e7;if dE(e7)then e0=e7.id end;assert(dy(e0),'Argument 1 (id) must be a number:'..type(e0))return self[e0]end;function ec:getPlanetarySystemId()local dW,dD=next(self)return dD and dD.systemId end;function dT:convertToMapPosition(e2)assert(dz(e2),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e2))local eY=vec3(e2)if self.id==0 then return setmetatable({latitude=eY.x,longitude=eY.y,altitude=eY.z,id=0,systemId=self.systemId},e4)end;local eZ=eY-self.center;local cb=eZ:len()local ea=cb-self.radius;local e8=0;local e9=0;if not dv(cb,0)then local e_=f0(eZ.y,eZ.x)e9=e_>=0 and e_ or 2*math.pi+e_;e8=math.pi/2-math.acos(eZ.z/cb)end;return setmetatable({latitude=e8,longitude=e9,altitude=ea,id=self.id,systemId=self.systemId},e4)end;function dT:convertToWorldCoordinates(e7)local eX=dB(e7)and e6(e7)or e7;if eX.id==0 then return vec3(eX.latitude,eX.longitude,eX.altitude)end;assert(dE(eX),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eX.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eX.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f1=math.cos(eX.latitude)return self.center+(self.radius+eX.altitude)*vec3(f1*math.cos(eX.longitude),f1*math.sin(eX.longitude),math.sin(eX.latitude))end;function dT:getAltitude(e2)return(vec3(e2)-self.center):len()-self.radius end;function dT:getDistance(e2)return(vec3(e2)-self.center):len()end;function dT:getGravity(e2)local f2=self.center-vec3(e2)local f3=f2:len2()return self.GM/f3*f2/du(f3)end;return setmetatable(el,{__call=function(dW,...)return em(...)end})end;local function f4(d,b,c,a,du,f5)local cx={}local f6=30000000/3600;local f7=f6*f6;local f8=100;function cx.computeAccelerationTime(f9,fa,fb)local fc=f6*math.asin(f9/f6)return(f6*math.asin(fb/f6)-fc)/fa end;function cx.computeDistanceAndTime(f9,fb,fd,fe,ff,fg)ff=ff or 0;fg=fg or 0;local fh=f9<=fb;local fi=fe*(fh and 1 or-1)/fd;local fj=-fg/fd;local fk=fi+fj;if fh and fk<=0 or not fh and fk>=0 then return-1,-1 end;local fl,fm=0,0;if fi~=0 and ff>0 then local fc=math.asin(f9/f6)local fn=math.pi*(fi/2+fj)local fo=fi*ff;local fp=f6*math.pi;local dD=function(dA)local fq=(fn*dA-fo*math.sin(math.pi*dA/2/ff)+fp*fc)/fp;local fr=math.tan(fq)return f6*fr/du(fr*fr+1)end;local fs=fh and function(a)return a>=fb end or function(a)return a<=fb end;fm=2*ff;if fs(dD(fm))then local ft=0;while f5(fm-ft)>0.5 do local dA=(fm+ft)/2;if fs(dD(dA))then fm=dA else ft=dA end end end;local fu=f9;local fv=fm/f8;for fw=1,f8 do local fx=dD(fw*fv)fl=fl+(fx+fu)*fv/2;fu=fx end;if fm<2*ff then return fl,fm end;f9=fu end;local fc=f6*math.asin(f9/f6)local bG=(f6*math.asin(fb/f6)-fc)/fk;local fy=f7*math.cos(fc/f6)/fk;local cb=fy-f7*math.cos((fk*bG+fc)/f6)/fk;return cb+fl,bG+fm end;function cx.computeTravelTime(f9,fa,cb)if cb==0 then return 0 end;if fa>0 then local fc=f6*math.asin(f9/f6)local fy=f7*math.cos(fc/f6)/fa;return(f6*math.acos(fa*(fy-cb)/f7)-fc)/fa end;if f9==0 then return-1 end;assert(f9>0,'Acceleration and initial speed are both zero.')return cb/f9 end;return cx end;local function fz(d,b,c,a,dr,ds,dt,du,dv)local vec3=require('cpml.vec3')local dq=dq(d,b,c,a,dr,ds,dt,du,dv)local function dB(a)return type(a)=='string'end;local function dz(dA)return type(dA)=='table'end;fA={}fA.__index=fA;function fA:escapeAndOrbitalSpeed(ea)assert(self.body)local cb=ea+self.body.radius;if not dv(cb,0)then local fB=du(self.body.GM/cb)return du(2)*fB,fB end;return nil,nil end;function fA:orbitalParameters(e7,fC)assert(self.body)assert(dz(e7)or dB(e7))assert(dz(fC))local fD=(dB(e7)or dq.isMapPosition(e7))and self.body:convertToWorldCoordinates(e7)or vec3(e7)local dD=vec3(fC)local fE=fD-self.body.center;local fF=dD:len2()local fG=fE:len()local fH=self.body.GM;local fI=((fF-fH/fG)*fE-fE:dot(dD)*dD)/fH;local eJ=fH/(2*fH/fG-fF)local fJ=fI:len()local eL=fI:normalize()local fK=eJ*(1-fJ)local fL=eJ*(1+fJ)local fM=fK*eL+self.body.center;local fN=fJ<=1 and-fL*eL+self.body.center or nil;local fO=du(eJ*fH*(1-fJ*fJ))local fP=fN and 2*math.pi*du(eJ^3/fH)local fQ=math.acos(fI:dot(fE)/(fJ*fG))if fE:dot(dD)<0 then fQ=-(fQ-2*math.pi)end;local fR=math.acos((math.cos(fQ)+fJ)/(1+fJ*math.cos(fQ)))local fS=fR;if fS<0 then fS=fS+2*math.pi end;local fT=fS-fJ*math.sin(fS)local fU=0;local fV=0;local fW=0;if fP~=nil then fU=fT/(2*math.pi/fP)fV=fP-fU;fW=fV+fP/2;if fQ-math.pi>0 then fV=fU;fW=fV+fP/2 end;if fW>fP then fW=fW-fP end end;return{periapsis={position=fM,speed=fO/fK,circularOrbitSpeed=du(fH/fK),altitude=fK-self.body.radius},apoapsis=fN and{position=fN,speed=fO/fL,circularOrbitSpeed=du(fH/fL),altitude=fL-self.body.radius},currentVelocity=dD,currentPosition=fD,eccentricity=fJ,period=fP,eccentricAnomaly=fR,meanAnomaly=fT,timeToPeriapsis=fV,timeToApoapsis=fW,trueAnomaly=fQ}end;local function fX(fY)local eV=dq.BodyParameters(fY.systemId,fY.id,fY.radius,fY.center,fY.GM)return setmetatable({body=eV},fA)end;return setmetatable(fA,{__call=function(dW,...)return fX(...)end})end;local function fZ(d,b,c,a,dbHud_1,e,f_,g0,bE,dt,du,g1)local function g2(g3)local e5=g4:closestBody(g3)if(g3-e5.center):len()>e5.radius+e5.noAtmosphericDensityAltitude then e5=e[0][0]end;return e5 end;local function g5()local function g6(g7,g8)return g7.name<g8.name end;d6={}for dR,dD in pairs(e[0])do d6[#d6+1]={name=dD.name,index=dR}end;table.sort(d6,g6)end;local function g9(ga)for dR,dD in pairs(ga)do if dD.name and dD.name==gb.name then return dR end end;return-1 end;local function gc()df=bg;if bg==0 then be="None"c4=nil;gb=nil;return true end;local gd=d6[bg].index;local ge=e[0][gd]if ge.center then be=ge.name;c4=cw[0][gd]if gb~=nil then if ci==0 then if f_(gf,gg)~=1 then g0(gf,gg)end;if f_(gh,gi)~=1 then g0(gh,gi)end;if f_(gj,gk)~=1 then g0(gj,gk)end;if f_(gl,gm)~=1 then g0(gl,gm)end;if f_(gn,go)~=1 then g0(gn,go)end end;if f_(gp,gq)~=1 then g0(gp,gq)end;if f_(gr,gs)~=1 then g0(gr,gs)end;if f_(gt,gu)~=1 then g0(gt,gu)end end;gb=nil else gb=ge;for dW,dD in pairs(cw[0])do if dD.name==gb.planetname then c4=dD;be=gb.name;break end end;if f_(gp,gq)~=1 then g0(gp,gq)end;if f_(gr,gs)~=1 then g0(gr,gs)end end;if gb==nil then bf=vec3(c4.center)else bf=gb.position end;if c4.planetname~="Space"then if c4.hasAtmosphere then gv=bE(c4.radius*(S-1)+c4.noAtmosphericDensityAltitude)else gv=bE(c4.radius*(S-1)+c4.surfaceMaxAltitude)end else gv=R end;if gb~=nil and gb.planetname=="Space"then ba=0 else dW,ba=cz(c4):escapeAndOrbitalSpeed(gv)end;bc=0;b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"return true end;local function gw(gx)if not aZ and not bl and not ce and not bu and not b3 and not cf then if gx==nil then bg=bg+1;if bg>#d6 then bg=0 end else bg=bg-1;if bg<0 then bg=#d6 end end;if bg==0 then gc()else local gd=d6[bg].index;local ge=e[0][gd]if ge and(ge~=nil and ge.name=="Space"or bv=="Custom Only"and ge.center or bv=="No Moons"and string.find(ge.name,"Moon")~=nil)then if gx==nil then gw()else gw(1)end else gc()end end else c0="Disengage autopilot before changing Interplanetary Helper"g1("iph","AP")end end;local function gy()local function gz(gA)local gB;if gA then gB=dn else gB=bk end;local gC=-1;gC=g9(e[0])if gC>-1 then table.remove(e[0],gC)end;gC=-1;gC=g9(gB)if gC~=-1 then c0=gb.name.." saved location cleared"table.remove(gB,gC)end;gw()g5()return gB end;if string.sub(be,1,1)=="*"then dn=gz(true)else bk=gz(false)end end;local function gD(gE,g3,gF,gG)local function gH(gA)if gA then gB=dn else gB=bk end;if dbHud_1 or gF or gA then local e5=g2(g3)local gI=e5.gravity;if gG then gI=c.getClosestPlanetInfluence()end;local gJ={position=g3,name=gE,planetname=e5.name,gravity=gI,safe=gG}if not gF then gB[#gB+1]=gJ else for dR,dD in pairs(e[0])do if dD.name and gE==dD.name then table.remove(e[0],dR)end end end;table.insert(e[0],gJ)g5()gc()c0="Location saved as "..gE.."("..e5.name..")"return gB else c0="Databank must be installed to save permanent locations"end end;if string.sub(gE,1,1)=="*"then dn=gH(true)else bk=gH(false)end end;local gK={}function gK.UpdateAtlasLocationsList()g5()end;function gK.UpdateAutopilotTarget()gc()end;function gK.adjustAutopilotTargetIndex(gx)gw(gx)end;function gK.findAtlasIndex(ga)g9(ga)end;function gK.UpdatePosition(gL)local function gM(gA)local gB;if gA then gB=dn else gB=bk end;local gC=g9(gB)if gC~=-1 then if gL~=nil then if gA then gL="*"..gL end;gB[gC].name=gL;bg=bg-1;gw()else local gN=gB[gC]gN.gravity=c.getClosestPlanetInfluence()gN.position=c_;gN.safe=true end;c0=gB[gC].name.." position updated ("..gB[gC].planetname..")"else c0="Name Not Found"end end;if string.sub(be,1,1)=="*"then gM(true)else gM(false)end end;function gK.AddNewLocation(gE,g3,gF,gG)gD(gE,g3,gF,gG)end;function gK.ClearCurrentPosition()gy()end;for dR,dD in pairs(dp)do table.insert(e[0],dD)end;g5()if bg>#d6 then bg=0 end;gK.UpdateAutopilotTarget()return gK end;local function gO(b,a,c,library,radar_1,radar_2,f5,gP,du,gQ,dt,gR,g1)local gS={}local gT={}local gU={XS=13,S=27,M=55,L=110,XL=221}local gV={}local gW;local gX;local gY;local gZ;local g_;local h0={}local h1="Atmo"local h2;local h3;local h4=0;local function h5()local function h6(h7,h8,h9,ha,hb,hc,hd,he)h8,ha,hc,he=vec3(h8),vec3(ha),vec3(hc),vec3(he)local hf,hg,hh=h7*h7,h9*h9,hb*hb;local fF=ha-h8;local hi=fF:normalize()local hj=fF:len()local hk=hc-h8;local hl=(hk-hk:project_on(hi)):normalize()local hm,hn=hk:dot(hi),hk:dot(hl)local ho=hm*hm+hn*hn;local hp=hi:cross(hl)local hq=(hf-hg+hj*hj)/(2*hj)local hr=(hf-hh+ho-2*hm*hq)/(2*hn)local dF=hf-hq^2-hr^2;local hs=du(dF)local ht=h8+hi*hq+hl*hr+hp*hs;local hu=h8+hi*hq+hl*hr-hp*hs;if f5((he-ht):len()-hd)<f5((he-hu):len()-hd)then return ht else return hu end end;local function hv()local function hw()local hx=b.getConstructWorldOrientationRight()local fF=b.getConstructWorldOrientationForward()local hk=b.getConstructWorldOrientationUp()local hy=library.systemResolution3(hx,fF,hk,{1,0,0})local hz=library.systemResolution3(hx,fF,hk,{0,1,0})local hA=library.systemResolution3(hx,fF,hk,{0,0,1})return function(hB)return library.systemResolution3(hy,hz,hA,hB)end end;local hC=hw()local hD=b.getConstructWorldPos()local fD=b.getElementPositionById(1)local hE={fD[1],fD[2],fD[3]}local hF=hC(hE)local hG={hD[1]-hF[1],hD[2]-hF[2],hD[3]-hF[3]}return hG end;local function hH(hI,fG,hJ)local hK=hI.pts;local gC=#hK;local hL=hI.ref;if gC>3 then local hM,hN,hO,hP=hK[gC],hK[gC-1],hK[gC-2],hK[gC-3]hI.ref=hJ;local fD=h6(hM[1],hM[2],hN[1],hN[2],hO[1],hO[2],hP[1],hP[2])local hq,hr,hs=fD.x,fD.y,fD.z;if hq==hq and hr==hr and hs==hs then hq=hq+hL[1]hr=hr+hL[2]hs=hs+hL[3]local hQ=vec3(hq,hr,hs)if not hI.lastPos then hI.center=hQ elseif(hI.lastPos-hQ):len()<2 then hI.center=hQ;hI.skipCalc=true end;hI.lastPos=hQ end;hI.pts={}else local hR={hJ[1]-hL[1],hJ[2]-hL[2],hJ[3]-hL[3]}hK[gC+1]={fG,hR}end end;if radar_1 or radar_2 then cD.assignRadar()end;if h0[1]then gW=#h0[1].getConstructIds()local hS=h0[1].getData()local hT=hS:gmatch('{"constructId[^}]*}[^}]*}')if gW>0 then local hJ=hv()local hU,hV=0,0;g_,gZ=0,0;for dD in hT do local e0,cb,hW=dD:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hX=gU[hW]cb=dt(cb)if h0[1].hasMatchingTransponder(e0)==1 then table.insert(gT,e0)end;local hY=h0[1].getConstructType(e0)if F then if hX>27 or hY=="static"or hY=="space"then g_=g_+1;local gE=h0[1].getConstructName(e0)local hI=da[e0]if hI==nil then hX=hX+gR;da[e0]={pts={},ref=hJ,name=gE,i=0,radius=hX,skipCalc=false}hI=da[e0]end;if not hI.skipCalc then hH(hI,cb,hJ)hV=hV+1 end;if hI.center then table.insert(gV,hI)end end;hU=hU+1;if db and hU>700 or hV>70 or(not db and hU>300 or hV>30)then coroutine.yield()hU,hV=0,0 end end end;gZ=#gV;if gZ>0 and cX>20 then local ez,hZ,h_,i0;local i1=0;local i2=cw:getPlanetarySystem(0)i0=cW:normalize()while i1<gZ do coroutine.yield()local i3={table.unpack(gV,i1,math.min(i1+75,gZ))}ez,hZ,h_=i2:castIntersections(c_,i0,nil,nil,i3,true)if ez and h_ then dd={ez,hZ,h_}break end;i1=i1+75 end;if not ez then dd=nil end else dd=nil end;gV={}gX=hS:find('identifiedConstructs":%[%]')else gY=hS:find('worksInEnvironment":false')end end end;local function i4()if h0[1]then h1="Atmo"if h0[1].getData():find('worksInAtmosphere":false')then h1="Space"end end end;function gS.pickType()i4()end;function gS.assignRadar()if radar_1 and h0[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then h0[1]=radar_2 end;if h0[1]==radar_2 then i4()end elseif radar_2 and h0[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then h0[1]=radar_1 end;if h0[1]==radar_1 then i4()end end end;function gS.UpdateRadar()local i5=coroutine.status(h2)if i5=="suspended"then local dS,i6=coroutine.resume(h2)if i6 then a.print("ERROR UPDATE RADAR: "..i6)end elseif i5=="dead"then h2=coroutine.create(h5)local dS,i6=coroutine.resume(h2)end end;function gS.GetRadarHud(i7,i8,i9,ia)local ib=gT;local ic,id;gT={}local dJ=gZ or 0;if gW>0 then if F then id=dJ.."/"..g_.." Plotted : "..gW-g_.." Ignored"else id="Radar Contacts: "..gW end;ic=gQ(i9,ia,id,"pbright txtbig txtmid")if#gT>0 then ic=ic..gQ(i7,i8,"Friendlies In Range","pbright txtbig txtmid")for dR,dD in pairs(gT)do i8=i8+20;ic=ic..gQ(i7,i8,h0[1].getConstructName(dD),"pdim txtmid")end end;if gX==nil and h3==nil then h4=1;cD.ToggleRadarPanel()end;if gX~=nil and h3~=nil then cD.ToggleRadarPanel()end;if dm==nil then cD.ToggleRadarPanel()end else if gY then ic=gQ(i9,ia,h1 .." Radar: Jammed","pbright txtbig txtmid")else ic=gQ(i9,ia,"Radar: No "..h1 .." Contacts","pbright txtbig txtmid")end;if dm~=nil then h4=0;cD.ToggleRadarPanel()end end;return ic end;function gS.GetClosestName(gE)if h0[1]then local e0,dW=h0[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if e0~=nil and e0~=""then gE=gE.." "..h0[1].getConstructName(e0)end end;return gE end;function gS.ToggleRadarPanel()if dm~=nil and h4==0 then gP(dm)dm=nil;if h3~=nil then gP(h3)h3=nil end else if h4==1 then gP(dm)dm=nil;_autoconf.displayCategoryPanel(h0,1,"Periscope","periscope")h3=_autoconf.panels[_autoconf.panels_size]end;if dm==nil then _autoconf.displayCategoryPanel(h0,1,"Radar","radar")dm=_autoconf.panels[_autoconf.panels_size]end;h4=0 end end;function gS.ContactTick()if not ie then ie=0 end;if bG>ie+10 then c0="Radar Contact"g1("rdrCon","RC")ie=bG end;c.stopTimer("contact")end;function gS.onEnter(e0)if radar_1 and not ch and not d7 then c.setTimer("contact",0.1)end end;function gS.onLeave(e0)if radar_1 and F then if#da>650 then e0=tostring(e0)da[e0]=nil end end end;h0[1]=nil;if radar_1 then h0[1]=radar_1;i4()end;h2=coroutine.create(h5)return gS end;local function ig(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ih,warpdrive,ii,f5,bE,dr,ij,bF,ik,il,f0,bD,ds,im,g0,f_,gP,io,du,ip,gQ,g1,iq,ir,is,it,iu,iv)local iw=9.80665;local ix={}local iy={}local iz={}local iA={}local iB=nil;local iC=nil;local iD=nil;local iE=false;local iF="none"local iG=""local iH=55;local iI=0;local iJ=0;local iK=""local iL=nil;local iM=vec3({13771471,7435803,-128971})local iN=18000000;local iO=500000;local iP,iQ=math.huge;local iR;local function iS(iT)iP=vec3(iT):dist(iM)if iP<iN then return true,f5(iP-iN)end;iQ=vec3(iT):dist(vec3(iU.center))if iQ<iO then iR=true else iR=false end;if f5(iQ-iO)<f5(iP-iN)then return iR,f5(iQ-iO)else return iR,f5(iP-iN)end end;local function iV(dD)if cq==1920 then return dD else return ip(cq*dD/1920,0)end end;local function iW(dD)if cr==1080 then return dD else return ip(cr*dD/1080,0)end end;local function iX()return io()==0 and g~="keyboard"and il()==0 end;local function iY()local iZ="TRAVEL"if not d3 then iZ="CRUISE"end;if aZ then iZ="AUTOPILOT"end;return iZ end;local ic=""local i_=""local j0=""local j1=1;local j2=2;local j3=3;local j4=4;local j5=5;local j6=6;local j7=""local j8=0;local j9=bE(1/aO)*2*aP;local ja={}local jb={}local jc={}local jd={}local je={}local jf={}local jg={}jg["atmofueltank"],jg["spacefueltank"],jg["rocketfueltank"]=0,0,0;local jh=0;local function ji(hq,jj,jk,jl,jm,jn)local jo=jh;local jp=jh+5;if not C then jp=jp+5 end;if il()==1 and not l then jo=jo-50;jp=jp-50 end;if jk=="ATMO"then j7="atmofueltank"elseif jk=="SPACE"then j7="spacefueltank"else j7="rocketfueltank"end;j8=_G[j7 .."_size"]if#jl>0 then for K=1,#jl do local gE=string.sub(jl[K][j2],1,12)local jq=0;for jr=1,j8 do if jl[K][j2]==ij(c[j7 .."_"..jr].getData()).name then jq=jr;break end end;local js=bD()if jm[K]==nil or jn[K]==nil or js-jl[K][j6]>j9 then local jt;local ju=0;ju=ik(jl[K][j1])-jl[K][j4]jt=jl[K][j5]if jt>ju then jl[K][j6]=js;jg[j7]=jg[j7]+jt-ju end;jl[K][j5]=ju;if jq~=0 then jn[K]=ij(c[j7 .."_"..jq].getData()).percentage;jm[K]=ij(c[j7 .."_"..jq].getData()).timeLeft;if jm[K]=="n/a"then jm[K]=0 end else jn[K]=bE(0.5+ju*100/jl[K][j3])if jt<=ju then jm[K]=0 else jm[K]=bE(0.5+ju/((jt-ju)/(js-jl[K][j6])))end end end;if gE==jj then gE=dr("%s %d",jk,K)end;if jq==0 then gE=gE.." *"end;local jv;if jm[K]==0 then jv=""else jv=it(jm[K])end;if jn[K]~=nil then local jw=bE(jn[K]*2.55)local jx=dr("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""if jv~=""and jm[K]<120 or jn[K]<5 then jy="red "end;local jz=dr("rgb(%d,%d,%d)",ds(bE((255-jw)/2.55),50,100),ds(bE(jw/2.55),0,50),50)local jA="rgb(196,0,255)"if jk=="ATMO"then jA="rgb(0,188,255)"elseif jk=="SPACE"then jA="rgb(239,255,0)"end;local jB=false;if jC~=jA then jB=true end;jC=jA;if C then if jB then jo=jo-5;jp=jp-5 end;i_=i_..dr([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jz,jA,hq,jp,jx,bE(jn[K]*1.7+0.5)-2,hq+1,jp+1,hq+5,jp+14,gE,jn[K],jv)jo=jo-22;jp=jp-22 else i_=i_..gQ(hq,jo,gE,jy.."pdim txtfuel")i_=i_..gQ(hq,jp,dr("%d%% %s",jn[K],jv),"pdim txtfuel","fill:"..jx)jo=jo+30;jp=jp+30 end end end end;jh=jo end;local function jD(jE,ea)if al==0 and am==0 then return end;if ea<200000 and not ch or ea and ch then local jF=0;if f5(cZ)>1 then jF=45*math.log(f5(cZ),10)if cZ<0 then jF=-jF end end;jE[#jE+1]=dr([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],al,am,bE(cZ),bE(jF))end;return jE end;local function jG(jH)local gx=-cY;jH=jH-jH:project_on(gx)local jI=vec3(0,0,1)jI=jI-jI:project_on(gx)local jJ=jI:cross(gx)local jF=jI:angle_between(jH)*constants.rad2deg;if jH:dot(jJ)<0 then jF=360-jF end;return jF end;local function jK(jE,ah,ai,jL,jM,db)if aa==0 then return end;local jN=aa;local jO=20;local jP=bE(jL)if db then for K=-45,45,5 do local jQ=K;jE[#jE+1]=dr([[<g transform="rotate(%f,%d,%d)">]],jQ,ah,ai)jR=5;if K%15==0 then jR=15 elseif K%10==0 then jR=10 end;jE[#jE+1]=dr([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ah,ai+jN+jO-jR,ah,ai+jN+jO)end;jE[#jE+1]=gQ(ah,ai+jN+jO-35,jM,"pdim txt txtmid")jE[#jE+1]=gQ(ah,ai+jN+jO-25,jP.." deg","pdim txt txtmid")jE[#jE+1]=dr([[<g transform="rotate(%f,%d,%d)">]],-jL,ah,ai)jE[#jE+1]=dr([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ah-5,ai+jN+jO-20,ah+5,ai+jN+jO-20,ah,ai+jN+jO-15)jE[#jE+1]="</g>"end;jE[#jE+1]=[[<g style="clip-path: url(#headingClip);">]]local jS=jP;if db then jS=jG(cT)end;local jT=20;local jU=bE(jS)local jV=0;local jW=ai+jN+jO+20;local jX=ah;if jM~="YAW"then jW=iW(130)jX=iV(960)end;local jY=[[<path class="txttick line" d="]]local jZ=bE(jU-(jT+10)-jU%5+0.5)for K=jZ+70,jZ,-5 do local hq=jX-(-K*5+jS*5)if K%10==0 then jV=10;local dJ=K;if dJ==360 then dJ=0 elseif dJ>360 then dJ=dJ-360 elseif dJ<0 then dJ=dJ+360 end;jE[#jE+1]=gQ(hq,jW+15,dJ,"txtmid bright")elseif K%5==0 then jV=5 end;if jV==10 then jY=dr([[%s M %f %f v %d]],jY,hq,jW-5,jV)else jY=dr([[%s M %f %f v %d]],jY,hq,jW-2.5,jV)end end;jE[#jE+1]=jY..[["/>]]jE[#jE+1]=dr([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jX-5,jW-20,jX+5,jW-20,jX,jW-10)if I then if db then jM="HDG"end;jE[#jE+1]=gQ(iV(960),iW(100),jU.."°","dim txt txtmid size14","")jE[#jE+1]=gQ(iV(960),iW(85),jM,"dim txt txtmid size20","")end;jE[#jE+1]=[[</g>]]end;local function j_(jE,k0,jL,ah,ai,db,k1,fx)if aa==0 then return end;local jN=aa;local k2=bE(jN*3/5)if jN>0 then local k3=bE(k0)local jR=0;local jY=dr([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jL,ah,ai)if not ch then jY=dr([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ah,ai)end;jE[#jE+1]=dr([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jN-1,ah,ai)jE[#jE+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bE(k3-30-k3%5+0.5),bE(k3+30+k3%5+0.5),5 do if K%10==0 then jR=30 elseif K%5==0 then jR=20 end;local hr=ai+-K*5+k0*5;if jR==30 then jY=dr([[%s M %d %f h %d]],jY,ah-k2-jR,hr,jR)if ch then jE[#jE+1]=dr([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ah,ai,ah-k2+10,hr+4,K)jE[#jE+1]=dr([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ah,ai,ah+k2-10,hr+4,K)if K==0 or K==180 or K==-180 then jE[#jE+1]=dr([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ah,ai,ah-k2+20,hr,k2*2-40)end else jE[#jE+1]=gQ(ah-k2+10,hr,K,"pdim txt txtmid")jE[#jE+1]=gQ(ah+k2-10,hr,K,"pdim txt txtmid")end;jY=dr([[%s M %d %f h %d]],jY,ah+k2,hr,jR)else jY=dr([[%s M %d %f h %d]],jY,ah-k2-jR,hr,jR)jY=dr([[%s M %d %f h %d]],jY,ah+k2,hr,jR)end end;jE[#jE+1]=jY..[["/>]]local k4="PITCH"if not db then k4="REL PITCH"end;if k0>90 and not ch then k0=90-(k0-90)elseif k0<-90 and not ch then k0=-90-(k0+90)end;if jN>200 then if ch then if fx>iH then jE[#jE+1]=gQ(ah,ai-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gQ(ah,ai+20,k1,"pdim txt txtmid")end;jE[#jE+1]=dr([[<g transform="rotate(%f,%d,%d)">]],-jL,ah,ai)else jE[#jE+1]=dr([[<g transform="rotate(0,%d,%d)">]],ah,ai)end;jE[#jE+1]=dr([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah-k2+25,ai-5,ah-k2+20,ai,ah-k2+25,ai+5,ah-k2+50,ai+4,k3)jE[#jE+1]=dr([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah+k2-25,ai-5,ah+k2-20,ai,ah+k2-25,ai+5,ah+k2-30,ai+4,k3)jE[#jE+1]="</g>"end;local k5=bE(jN/3)jE[#jE+1]=dr([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ah-k5,ai,jN-k5)if not ch and db then jE[#jE+1]=dr([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ah,ai,ah-k2+10,ai,k2*2-20)end;jE[#jE+1]="</g>"if jN<200 then if ch and fx>iH then jE[#jE+1]=gQ(ah,ai-jN,k4,"pdim txt txtmid")jE[#jE+1]=gQ(ah,ai-jN+10,k3,"pdim txt txtmid")jE[#jE+1]=gQ(ah,ai-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gQ(ah,ai+20,k1,"pdim txt txtmid")else jE[#jE+1]=gQ(ah,ai-jN,k4,"pdim txt txtmid")jE[#jE+1]=gQ(ah,ai-jN+15,k3,"pdim txt txtmid")end end end end;local function k6(jE,ea,db)local k7=an;local k8=ao;if k7==0 and k8==0 then return end;local k9=78;local ka=19;local kb=cg;if cg~=-1 then jE[#jE+1]=gQ(k7+k9,k8+ka+20,dr("AGL: %.1fm",cg),"pdim altsm txtend")end;if db and(ea<200000 and not ch or ea and ch)then table.insert(jE,dr([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k7-1,k8-4,k9+2,ka+6,k7+1,k8-1,k9-4,ka))local gC=0;local kc=1;local kd=0;local ke=ea<0;local kf=ea<iU.surfaceMaxAltitude;local kg=9;if ke then kg=0 end;local ea=f5(ea)while gC<6 do local kh=11;local ki=16;local kj=9;local kk=14;local jy="altsm"if gC>2 then ki=ki+3;kh=kh+2;kk=kk+2;kj=kj-6;jy="altbig"end;if ke then jy=jy.." red"elseif kf then jy=jy.." orange"end;local kl=ea/kc%10;local km=bE(kl)local kn=bE((km+1)%10)local ko=kd;if gC==0 then ko=kl-km;if ke then ko=1-ko end end;if ke and(gC==0 or kd~=0)then local gF=kn;kn=km;km=gF end;local kp=ki*(ko-1)local kq=kp+ki;local hq=k7+kj+(6-gC)*kh;local hr=k8+kk;jE[#jE+1]=gQ(hq,hr+kp,kn,jy)jE[#jE+1]=gQ(hq,hr+kq,km,jy)gC=gC+1;kc=kc*10;if km==kg then kd=ko else kd=0 end end;table.insert(jE,[[</g></g>]])end end;local function kr(fC)local ks=-math.deg(f0(fC.y,fC.z))+180;ks=ks-90;if ks<0 then ks=360+ks end;if ks>180 then ks=-180+ks-180 end;return-ks end;local function kt(fC)local jS=math.deg(f0(fC.y,fC.x))-90;if jS<-180 then jS=360+jS end;return jS end;local function ku(jE,fC,fx,ah,ai)if fx>5 and not ch or fx>iH then local jN=aa;local kv=20;local kw=20;local kx=kr(fC)local ky=kt(fC)local kz=14;local kA=kz/2;local kB=-ky/kw*jN;local kC=kx/kv*jN;local hq=ah+kB;local hr=ai+kC;local cb=du(kB^2+kC^2)local kD=[[<circle
                            cx="]]..hq..[["
                            cy="]]..hr..[["
                            r="]]..kA/kz..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hq..[["
                            cy="]]..hr..[["
                            r="]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hq-kz..[[,]]..hr..[[ h ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hq+kA..[[,]]..hr..[[ h ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hq..[[,]]..hr-kz..[[ v ]]..kA..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<jN then jE[#jE+1]=kD else local jF=f0(kC,kB)local kE=4;local kF=ah+jN*math.cos(jF)local kG=ai+jN*math.sin(jF)jE[#jE+1]=dr('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jF*180/math.pi,kF,kG,kF-kE,kG-kE/2,kE*2,kE,kF+kE,kG-kE,kE,kE,-kE,kE)end;if not ch then local kH=vec3(fC)kx=kr(-kH)ky=kt(-kH)kB=-ky/kw*jN;kC=kx/kv*jN;hq=ah+kB;hr=ai+kC;cb=du(kB^2+kC^2)if cb<jN then local kI=[[<circle
                                    cx="]]..hq..[["
                                    cy="]]..hr..[["
                                    r="]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hq..[[,]]..hr-kz..[[ v ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hq..[[,]]..hr..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hq..[[,]]..hr..[[)" />
                                <path
                                    d="M ]]..hq-kA..[[,]]..hr..[[ h ]]..kz..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hq..[[,]]..hr..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hq..[[,]]..hr..[[)"/>]]jE[#jE+1]=kI end end end end;local function kJ(jE,iZ,kK,kL)if aj==0 and ak==0 then return end;kK=bE(kK+0.5)local jo=ak+10;local jp=ak+20;if il()==1 and not l then jo=55;jp=65 end;local kM="CRUISE"local c="km/h"local dS=kL;if iZ=="TRAVEL"or iZ=="AUTOPILOT"then kM="THROT"c="%"dS=kK;local kN="dim"if kK<0 then kN="red"end;jE[#jE+1]=dr([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kN,aj-7,ak-50,aj,ak-50,aj,ak+50,aj-7,ak+50,1-f5(kK),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)end;jE[#jE+1]=gQ(aj+10,jo,kM,"pbright txtstart")jE[#jE+1]=gQ(aj+10,jp,dr("%.0f %s",dS,c),"pbright txtstart")if ch and u and d3 and bM then kK=bE(bN*100+0.5)local kN="red"if kK<0 then kN="red"end;jE[#jE+1]=dr([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kN,1-f5(kK),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)jE[#jE+1]=gQ(aj+10,jo+40,"LIMIT","pbright txtstart")jE[#jE+1]=gQ(aj+10,jp+40,kK.."%","pbright txtstart")end;if ch and u or b3 then jE[#jE+1]=gQ(aj+10,jo-40,"LIMIT: "..cK.." km/h","dim txtstart")elseif not ch and aZ then jE[#jE+1]=gQ(aj+10,jo-40,"LIMIT: "..bE(_*3.6+0.5).." km/h","dim txtstart")end end;local function kO(jE,kP)if aj==0 and ak==0 then return end;local kQ=ak-10;local kR=aj+10;jE[#jE+1]=gQ(0,0,"","pdim txt txtend")if il()==1 and not l then kQ=75 end;jE[#jE+1]=gQ(kR,kQ,bE(kP).." km/h","pbright txtbig txtstart")end;local function kS(jE)jE[#jE+1]=gQ(iV(1900),iW(1070),dr("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jE[#jE+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jE[#jE+1]=gQ(iV(960),iW(550),"Warning: Invalid Control Scheme Detected","warnings")jE[#jE+1]=gQ(iV(960),iW(600),"Keyboard Scheme must be selected","warnings")jE[#jE+1]=gQ(iV(960),iW(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kT=iV(960)local kU=iW(860)local kV=iW(880)local kW=iW(900)local kX=iW(960)local kY=iW(200)local kZ=iW(250)local k_=iW(960)if il()==1 and not l then kU=iW(135)kV=iW(155)kW=iW(175)kY=iW(115)kZ=iW(95)end;local l0="#222222"local l1="white"local l2="dimmer"local l3="pbright"local l4="#110000"local l5=l0;local l6=l2;if aW then jE[#jE+1]=gQ(kT,kU,"Brake Engaged","warnings")l4="#440000"l5=l1;l6=l3 elseif bL>0 then jE[#jE+1]=gQ(kT,kU,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local l7="#110000"local l8=l0;local l9=l2;if ch and cI and cg==-1 then if not aZ and not bl and not b1 and not d1 and not b4 and not b2 then jE[#jE+1]=gQ(kT,kY+50,"** STALL WARNING **","warnings")l7="#ff0000"l8=l1;l9=l3;g1("stall","SW",2)end end;if d9 then jE[#jE+1]=gQ(kT,kY+90,"Flight Assist in Progress","warnings")end;if cn then jE[#jE+1]=gQ(kT,k_,"Gyro Enabled","warnings")end;local la="#111100"local lb=l0;local lc=l2;if bh then la="#775500"lb=l1;lc=l3;if bR then jE[#jE+1]=gQ(kT,kV,"Gear Extended","warn")else jE[#jE+1]=gQ(kT,kV,"Landed (G: Takeoff)","warnings")end;local ld=is(d:getTargetGroundAltitude())jE[#jE+1]=gQ(kT,kW,"Hover Height: "..ld,"warn")end;local le="#000011"local lf=l0;local lg=l2;if c1 then le="#0000DD"lf=l1;lg=l3;jE[#jE+1]=gQ(kT,kX+20,"ROCKET BOOST ENABLED","warn")end;local lh="#001100"local li=l0;local lj=l2;if antigrav and not q and d1 and bq~=nil then lh="#00DD00"li=l1;lj=l3;if f5(cj-antigrav.getBaseAltitude())<501 then jE[#jE+1]=gQ(kT,kY+15,dr("Target Altitude: %d Singularity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warn")else jE[#jE+1]=gQ(kT,kY+15,dr("Target Altitude: %d Singluarity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warnings")end elseif aZ and be~="None"then jE[#jE+1]=gQ(kT,kY+20,"Autopilot "..bb,"warn")elseif bo~=nil then jE[#jE+1]=gQ(kT,kY+20,dr("LockedPitch: %d",bE(bo)),"warn")elseif bZ then jE[#jE+1]=gQ(kT,kY+20,"Follow Mode Engaged","warn")elseif b3 or cf then jE[#jE+1]=gQ(kT,kY+20,"Re-entry in Progress","warn")end;if b0 or b4 then local ld=is(b5,2)if b4 then if d1 then ld=is(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jE[#jE+1]=gQ(kT,kY,"VTO to "..ld,"warn")elseif b2 and not bu then if ce then jE[#jE+1]=gQ(kT,kY,"Takeoff to "..be,"warn")else jE[#jE+1]=gQ(kT,kY,"Takeoff to "..ld,"warn")end;if aW and not b4 then jE[#jE+1]=gQ(kT,kY+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jE[#jE+1]=gQ(kT,kY,"Altitude Hold: "..ld,"warn")end end;if b4 and(antigrav~=nil and antigrav)then if ci>0.1 then jE[#jE+1]=gQ(kT,kY+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jE[#jE+1]=gQ(kT,kY+20,"Aligning trajectory","warn")elseif ci<0.05 then jE[#jE+1]=gQ(kT,kY+20,"Leaving atmosphere","warn")end end;if bu then if cM~=nil then jE[#jE+1]=gQ(kT,kY,cM,"warn")end end;if b1 then if lk then jE[#jE+1]=gQ(kT,kY,"Brake-Landing","warnings")else jE[#jE+1]=gQ(kT,kY,"Coast-Landing","warnings")end end;if aY then jE[#jE+1]=gQ(kT,kY,"Prograde Alignment","crit")end;if aX then jE[#jE+1]=gQ(kT,kY,"Retrograde Alignment","crit")end;local ll="#110000"local lm=l0;local ln=l2;if dc then ll="#FF0000"lm=l1;ln=l3;local type;if string.find(dc,"COLLISION")then type="warnings"else type="crit"end;jE[#jE+1]=gQ(kT,kZ+20,dc,type)elseif ci==0 then local lo,lp=cC.checkLOS(cW:normalize())if lp~=nil then ln=l3;ll="#FF0000"lm=l1;local ld=is(lp)local lq=cx.computeTravelTime(cX,0,lp)local lr="Collision"if lo.noAtmosphericDensityAltitude>0 then lr="Atmosphere"end;jE[#jE+1]=gQ(kT,kZ+20,lo.name.." "..lr.." "..it(lq).." In "..ld,"crit")end end;if bl and not bu then jE[#jE+1]=gQ(kT,kY+35,ls,"warn")end;local lt="#111100"local lu=l0;local lv=l2;if dg and#dg>1 then lt="#DDDD00"lu=l1;lv=l3 end;local lw=iV;local lx=iW;local l2="topButton"local ly="topButtonActive"local lz=l2;if aZ or bl or ce or bu then lz=ly end;local lA=l2;if aY then lA=ly end;local lB=l2;if b1 or bh then lB=ly end;local lC=l2;if b0 or bl then lC=ly end;local lD=l2;if aX then lD=ly end;local lE=l2;if bu or cP and aZ then lE=ly end;if x and I then local lF=lx(30)jE[#jE+1]=dr([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lz,lw(960),lx(54),lx(-53),lw(-120),lw(25),lx(50))jE[#jE+1]=gQ(lw(910),lF,"AUTOPILOT")jE[#jE+1]=dr([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,lw(865),lx(51),lw(-25),lx(-50),lw(-110),lw(25),lx(46))jE[#jE+1]=gQ(lw(800),lF,"PROGRADE")jE[#jE+1]=dr([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lB,lw(755),lx(47),lw(-25),lx(-46),lw(-98),lw(44),lx(44))jE[#jE+1]=gQ(lw(700),lF,"LAND")jE[#jE+1]=dr([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lC,lw(960),lx(54),lx(-53),lw(120),lw(-25),lx(50))jE[#jE+1]=gQ(lw(1010),lF,"ALT HOLD")jE[#jE+1]=dr([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lw(1055),lx(51),lw(25),lx(-50),lw(110),lw(-25),lx(46))jE[#jE+1]=gQ(lw(1122),lF,"RETROGRADE")jE[#jE+1]=dr([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lw(1165),lx(47),lw(25),lx(-46),lw(98),lw(-44),lx(44))jE[#jE+1]=gQ(lw(1220),lF,"ORBIT")jE[#jE+1]=[[
                                    </g>
                                </g>]]jE[#jE+1]="</g>"end;return jE end;local function lG(fx)return bE(ip(fx*3.6,0)+0.5).." km/h"end;local function lH(gC)local gE=be;if gC~=nil and type(gC)=="number"then if gC==0 then return"None"end;gE=d6[gC].name end;if gE==nil then gE=gb.name end;if gE==nil then gE="None"end;return gE end;local function lI(jE)local lJ=cC.routeWP(true)if not lJ or#lJ==0 then return end;local hq=iV(750)local hr=iW(360)if aZ or bl then jE[#jE+1]=gQ(hq,hr,"REMAINING ROUTE","pdim txtstart size20")else jE[#jE+1]=gQ(hq,hr,"LOADED ROUTE","pdim txtstart size20")end;for dR,K in pairs(lJ)do hr=hr+20;jE[#jE+1]=gQ(hq,hr,dR..". "..lH(lJ[dR]),"pdim txtstart size20")end end;local function lK(jE)local hq=av+10;local hr=aw+20;local lL={}local lM={"Alt-4: AutoTakeoff to Target"}local lN={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lO={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lP={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lL,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then iq(lL,lM)if c4 and iU and c4.name==iU.name then table.insert(lL,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aV then if antigrav then if d1 then table.insert(lL,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lL,"Turn on AGG to takeoff to AGG Height")end end;if aV then table.insert(lL,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lL,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lL,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bh then table.insert(lL,"G: Takeoff to hover height, raise gear")else table.insert(lL,"G: Lowergear and Land")end else iq(lL,lN)table.insert(lL,"G: Begin BrakeLanding or Land")end;if b4 then table.insert(lL,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iq(lL,lO)if ih then table.insert(lL,"Alt-Shift-6: Vent shields")table.insert(lL,"Alt-Shift-7: Toggle shied off/on")end end;if gb~=nil then table.insert(lL,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lL,"Alt-9: Activate Gyroscope")end;if aR~="none"or aQ~="none"or aS~="none"then table.insert(lL,"Alt-Shift-9: Cycles engines with Extra tags")end;if b0 then table.insert(lL,"Alt-Spacebar/C will raise/lower target height")table.insert(lL,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ch then table.insert(lL,"LALT+Mousewheel will lower/raise speed limit")end;iq(lL,lP)for K=1,#lL do hr=hr+12;jE[#jE+1]=gQ(hq,hr,lL[K],"pdim txtbig txtstart")end end;local function lQ(jE)local lR=av;local lS=aw;local lT=au;local lU=4;local lV=15;local hq=0;local hr=0;local lW,lX,lY,lZ;local l_;local function m0(type)local m1,bG,fx,m2,jy,m3;if type=="Periapsis"then m1=l_.periapsis.altitude;bG=l_.timeToPeriapsis;fx=l_.periapsis.speed;jy="txtend"m2=12;m3=math.min(hq,lR+lT-iU.radius/lY-lU*2)else m1=l_.apoapsis.altitude;bG=l_.timeToApoapsis;fx=l_.apoapsis.speed;m2=-12;jy="txtstart"m3=hq end;if cX<1 then bG=0 end;jE[#jE+1]=dr([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m3+m2,hr-5,hq,hr-5)jE[#jE+1]=dr([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m3-m2*4,hr+2,hq,hr+2)jE[#jE+1]=gQ(m3,hr,type,jy)hq=m3-m2*2;hr=hr+lV;local ld=is(m1)jE[#jE+1]=gQ(hq,hr,ld,jy)hr=hr+lV;jE[#jE+1]=gQ(hq,hr,it(bG),jy)hr=hr+lV;jE[#jE+1]=gQ(hq,hr,lG(fx),jy)end;local m4=lT*1.5;if bB=="INFO"then m4=25*9 end;if bB~="HIDE"then jE[#jE+1]=[[<g class="pbright txtorb txtmid">]]jE[#jE+1]=dr('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lT*2,m4,lR,lS)jE[#jE+1]=dr([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lT*2,m4,lR,lS)end;local m5=lT*1.5;local m6=lT*2;local m7=m5/2;local m8=lT;local m9=lR+m8;local ma=lS+m7;local mb=lR+m6;local mc=lS+m5;if bB=="ORBIT"then lS=lS+lU;lW=lT/2;lZ=0;l_={}l_.periapsis={}l_.apoapsis={}if fB~=nil then if fB.periapsis~=nil then l_.periapsis.altitude=fB.periapsis.altitude;l_.periapsis.speed=fB.periapsis.speed end;if fB.apoapsis~=nil then l_.apoapsis.altitude=fB.apoapsis.altitude;l_.apoapsis.speed=fB.apoapsis.speed end;l_.period=fB.period;l_.eccentricity=fB.eccentricity;l_.timeToApoapsis=fB.timeToApoapsis;l_.timeToPeriapsis=fB.timeToPeriapsis;l_.eccentricAnomaly=fB.eccentricAnomaly;l_.trueAnomaly=fB.trueAnomaly end;if l_.periapsis==nil then l_.periapsis={}l_.periapsis.altitude=-iU.radius;l_.periapsis.speed=_ end;if l_.eccentricity==nil then l_.eccentricity=1 end;if l_.apoapsis==nil then l_.apoapsis={}l_.apoapsis.altitude=cj;l_.apoapsis.speed=0 end;if cX<1 then l_.apoapsis.altitude=cj;l_.apoapsis.speed=0 end;if l_.apoapsis.altitude then lY=(l_.apoapsis.altitude+l_.periapsis.altitude+iU.radius*2)/(lW*2)lX=(iU.radius+l_.apoapsis.altitude)/lY*(1-l_.eccentricity)lZ=lW-l_.periapsis.altitude/lY-iU.radius/lY;local md=math.pi;if l_.period~=nil and l_.period>0 and l_.timeToApoapsis~=nil then md=l_.eccentricAnomaly;if l_.timeToPeriapsis<l_.timeToApoapsis then md=2*math.pi-md end end;if cX<1 or md~=md then md=math.pi end;local me=-lW*math.cos(md)+lR+m8+lU;local mf=lX*math.sin(md)+lS+m7+lU;local mg=""jE[#jE+1]='<g clip-path="url(#orbitRect)">'jE[#jE+1]=dr([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mg,lR+lT+lU,lS+lT*1.5/2+lU,lW,lX)if lX<1 then jE[#jE+1]=dr([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lR+lT+lU-lZ,lS+lT*1.5/2+lU,me,mf)end;jE[#jE+1]=dr('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lR+lT+lU-lZ,lS+lT*1.5/2+lU,(iU.radius+iU.noAtmosphericDensityAltitude)/lY)jE[#jE+1]=dr('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lR+lT+lU-lZ,lS+lT*1.5/2+lU,(iU.radius+iU.noAtmosphericDensityAltitude)/lY)jE[#jE+1]=dr([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lR+lT+lU,lS+lT*1.5/2+lU,lW,lX)jE[#jE+1]=dr('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lR+lT+lU-lZ,lS+lT*1.5/2+lU,iU.radius/lY)jE[#jE+1]='</g>'local mh=math.floor(iU.radius/lY+0.5)hq=lR+lT+lU*4+lW;hr=lS+lT*1.5/2+5+lU;if l_.apoapsis~=nil and l_.apoapsis.speed<_ then m0("Apoapsis")end;hr=lS+lT*1.5/2+5+lU;hq=lR+lT-lU*2-lW;if l_.periapsis~=nil and l_.periapsis.speed<_ and l_.periapsis.altitude>0 then m0("Periapsis")end;jE[#jE+1]=gQ(lR+lT+lU,lS+20+lU,iU.name,"txtorbbig")jE[#jE+1]=dr('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',me,mf)jE[#jE+1]=[[</g>]]return jE else jE[#jE+1]='<g clip-path="url(#orbitRect)">'local mi=""local mj=1.2*(mk-ml)/(lT*2)local mm=1.4*(mn-mo)/(lT*1.5)for dR,dD in pairs(e[0])do if dD.center then local hq=lR+lT+dD.center.x/mj;local hr=lS+lT*1.5/2+dD.center.y/mm;mi=mi..'<circle cx="'..hq..'" cy="'..hr..'" r="'..dD.radius/mj*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dD.name,"Moon")and not string.match(dD.name,"Sanctuary")and not string.match(dD.name,"Space")then mi=mi.."<text x='"..hq.."' y='"..hr+dD.radius/mj*30+20 .."' font-size='12' fill="..co.." text-anchor='middle' font-family='Montserrat'>"..dD.name.."</text>"end end end;local fD=vec3(b.getConstructWorldPos())local hq=lR+lT+fD.x/mj;local hr=lS+lT*1.5/2+fD.y/mm;mi=mi..'<circle cx="'..hq..'" cy="'..hr..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mi=mi.."<text x='"..hq.."' y='"..hr-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iB=mj;iC=mm;local mp=fD+cW*1000000;local mq=lR+lT+mp.x/mj;local jp=lS+lT*1.5/2+mp.y/mm;mi=mi..'<line x1="'..hq..'" y1="'..hr..'" x2="'..mq..'" y2="'..jp..'" stroke="purple" stroke-width="1"/>'jE[#jE+1]=mi;jE[#jE+1]='</g>'end elseif bB=="INFO"then jE=cA.DrawOdometer(jE,c5,bi,c6)elseif bB=="HELP"then jE=lK(jE)elseif bB=="SCOPE"then jE[#jE+1]='<g clip-path="url(#orbitRect)">'local mr=dj;if ci>0 then table.sort(di,function(eH,eI)local eJ,eK=eH.center,eI.center;return(eJ.x-c_.x)^2+(eJ.y-c_.y)^2+(eJ.z-c_.z)^2<(eK.x-c_.x)^2+(eK.y-c_.y)^2+(eK.z-c_.z)^2 end)end;local gY={}local ms={}local mt=120;local mu=nil;local mv=nil;for K,dD in ipairs(di)do local gX=dD.center-c_;local mw=gX:len()local mx=gX:normalize()local my=gX:cross(cT):normalize()local mz=math.acos(my:dot(cU))if mz~=mz then mz=0 end;if my:cross(cU):dot(cT)<0 then mz=-mz end;local mA=gX:project_on_plane(cT):len()local mB=math.sin(mz)*math.asin(mA/mw)*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/mw)*constants.rad2deg;if mx:dot(cT)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hq=m9+mB/mr*m5;local hr=ma+mC/mr*m5;local mD=(hq-m9)*(hq-m9)+(hr-ma)*(hr-ma)local mE=math.asin((dD.radius+dD.surfaceMaxAltitude)/mw)*constants.rad2deg;if mE~=mE then mE=mr end;local hW=mE/mr*m5;local mF=math.asin(dD.atmosphereRadius/mw)*constants.rad2deg;if mF~=mF then mF=mE end;local mG=mF/mr*m5;local cb=is(mw,1)local mH=dD.name;local mI=false;if hr>lS then if hr>mc then if hr-mG<=mc then mI=true end else mI=true end else if hr+mG>=lS then mI=true end end;local mJ=false;local mK=hq;if dD.systemId==0 then mK=hq+mt else mK=hq-mt end;if mK+mt>lR then if mK+mt>mb then if mK-mG-mt<=mb then mJ=true end else mJ=true end else if mK+mG+mt>=lR then mJ=true end end;local mL={}mL.x=hq;mL.y=hr;mL.planet=dD;mL.atmoSize=mG;if not mu or mD<mu then mu=mD;mv=mL end;if mJ and mI then local mM=math.max(mG,5)if mD<mM*mM then mH=mH.." - "..cb end;mL.size=hW;mL.i=K;mL.displayString=mH;mL.distance=cb;mL.visible=true;ms[#ms+1]=mL else mL.visible=false end end;local mN=false;table.sort(ms,function(eJ,eK)return eJ.y<eK.y end)for dR,fG in ipairs(ms)do local dD,hW,K,mG,hq,hr,mH,cb=fG.planet,fG.size,fG.i,fG.atmoSize,fG.x,fG.y,fG.displayString,fG.distance;local m3,mO,mP,mQ;local mR=15;local jy="pdim"if dD.systemId~=0 then mP=iV(string.len(mH)*5)mR=-(15+mP)mQ=iW(10)jy="pdimfill"else mP=iV(string.len(mH)*9)mQ=iW(15)end;if hW*2>mP then m3=ds(hq,lR+mP/2,mb-mP/2)mO=ds(hr,lS+mQ,mc-5)m3=ds(m3,hq-hW+mP/2,hq+hW-mP/2)mO=ds(mO,hr-hW+mQ,hr+hW)else m3=hq+mR;mO=hr end;for mS,fG in pairs(gY)do local mT=fG.textPositions;local mU=mT.y-mO;if mS~=K and f5(mU)<mT.height and mT.x+mT.width>m3 and mT.x<m3+mP then if hW>mP then mO=ds(mO+mQ,lS+15,mc-5)else mO=mT.y+mT.height+1 end end end;local mV=mH~=dD.name or m3<=m9 and m3+mP>=m9 and mO-mQ<=ma and mO>=ma;fG.hovered=mV;local mW=1;if mV then mW=2;if hW*2<mP then mW=10 end;if mH==dD.name then mH=mH.." - "..cb end;jy="pbright"if dD.systemId~=0 then mP=iV(string.len(mH)*5)mR=-(15+mP)else mP=iV(string.len(mH)*7)end;if hW*2>mP then m3=ds(hq,lR+mP/2,mb-mP/2)m3=ds(m3,hq-hW+mP/2,hq+hW-mP/2)else m3=hq+mR end end;gY[K]={}gY[K].textPositions={}gY[K].textPositions.y=mO;gY[K].textPositions.x=m3;gY[K].textPositions.width=mP;gY[K].textPositions.height=mQ;gY[K].output=""if hW*2>mP then jy=jy.." txtmid"else jy=jy.." txtstart"end;if mG-hW>2 then gY[K].output=dr('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hq,hr,mG,cp,0.1*mW)end;gY[K].output=gY[K].output..dr('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hq,hr,hW,cp,0.2*mW)if dD.systemId==0 then gY[K].output=gY[K].output..dr([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m3,mO,co,jy,mH)if hW*2<=mP then gY[K].output=gY[K].output..dr("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m3+mP,mO+2,m3,mO+2,hq,hr)end else gY[K].output=gY[K].output..dr([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m3,mO,cp,jy,mH)if hW*2<=mP then gY[K].output=gY[K].output..dr("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m3,mO+2,m3+mP,mO+2,hq,hr)end end end;for dR=#di,1,-1 do if gY[dR]then jE[#jE+1]=gY[dR].output end end;if mv~=nil and dj<90 and not mv.hovered then local mX=mv.planet.atmosphereRadius/mv.atmoSize;local mY=du(mu)*mX;local mZ=is(mY,1)local mP=iV(math.max(string.len(mZ)*7,string.len(mv.planet.name)*7))local mQ=iW(12)local m3=ds(mv.x+(m9-mv.x)/2,lR+mP/2,mb-mP/2)local mO=ds(mv.y+(ma-mv.y)/2,lS+mQ*2,mc-5)jE[#jE+1]=dr("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mv.x,mv.y,m9,ma)jE[#jE+1]=dr([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m3,mO,"white",mZ)if not mv.visible then jE[#jE+1]=dr([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m3,mO-mQ,"white",mv.planet.name)end end;if cX>1 then local gX=cW;local mx=gX:normalize()local mA=gX:project_on_plane(cT):len()local my=gX:cross(cT):normalize()local mz=math.acos(my:dot(cU))if mz~=mz then mz=0 end;if my:cross(cU):dot(cT)<0 then mz=-mz end;local mB=math.sin(mz)*math.asin(mA/gX:len())*constants.rad2deg;local mC=math.cos(mz)*math.asin(mA/gX:len())*constants.rad2deg;if mx:dot(cT)<0 then mC=90*math.cos(mz)+90*math.cos(mz)-mC;mB=90*math.sin(mz)+90*math.sin(mz)-mB end;local hq=m9+mB/mr*m5;local hr=ma+mC/mr*m5;local kz=14;local kA=kz/2;local kD=[[<circle
                                    cx="]]..hq..[["
                                    cy="]]..hr..[["
                                    r="]]..kA/kz..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hq..[["
                                    cy="]]..hr..[["
                                    r="]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hq-kz..[[,]]..hr..[[ h ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hq+kA..[[,]]..hr..[[ h ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hq..[[,]]..hr-kz..[[ v ]]..kA..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jE[#jE+1]=kD end;jE[#jE+1]=dr("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m9,ma-10,m9,ma+10)jE[#jE+1]=dr("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m9-10,ma,m9+10,ma)jE[#jE+1]='</g>'else return jE end end;local function m_(n0,n1)local n2;local n3=(n1-n0):normalize()local fE=(c_-n0):dot(n3)/n3:dot(n3)if fE<=0. then return(c_-n0):len()elseif fE>=(n1-n0):len()then return(c_-n1):len()end;local n4=n0+fE*n3;n2=(n4-c_):len()return n2 end;local function n5()local n2;local n6=nil;local n7=nil;local n8=nil;for dR,n9 in pairs(e[0])do if n9.hasAtmosphere then local cb=m_(iU.center,n9.center)if n6==nil or cb<n6 then n7=n9;n6=cb;n8=iU end;if c4 and c4.hasAtmosphere and c4.name~=iU.name then local eW=m_(c4.center,n9.center)if eW<n6 then n7=n9;n6=eW;n8=c4 end end end end;local na=iV(1770)local nb=iW(330)if n6 then local nc="txttick "local nd=500000;if n6<n7.radius+nd or n6<n8.radius+nd then if d7 then nc="txttick red "else nc="txttick orange "end end;n2=is(n6,2)iG=gQ(na,nb,"Pipe ("..n8.name.."--"..n7.name.."): "..n2,nc.."pbright txtmid")end end;local function ne(hq,hr,nf,ng,kM)local nh={x=hq,y=hr,width=nf,height=ng,label=kM}iA[kM]=nh;return nh end;local function ni(nj,nk,nf,ng,hq,hr,nl,nm,nn,no,jy)local nh={enableName=nj,disableName=nk,width=nf,height=ng,x=hq,y=hr,toggleVar=nl,toggleFunction=nm,drawCondition=nn,hovered=false,class=jy}if no then table.insert(iz,nh)else table.insert(iy,nh)end;return nh end;local function np(nq)if not iE then nr=false;ns=false;nt=false;x=true;return elseif nq=="handling"then nr=not nr;ns=false;nt=false elseif nq=="hud"then ns=not ns;nr=false;nt=false elseif nq=="physics"then nt=not nt;nr=false;ns=false end;if nt or ns or nr then iF=ir(nq)x=false else iF="none"x=true end end;local function nu()iE=not iE;if iE then ix=iz;c0="Hold SHIFT to see Settings"dk=x else ix=iy;c0="Hold SHIFT to see Control Buttons"np()x=dk end end;local function nv()local function nw(dD,dR)dD.set(not dD.get())if dD.get()then c0=dR.." set to true"else c0=dR.." set to false"end;if dR=="showHud"then dk=dD.get()elseif dR=="BrakeToggleDefault"then aU=j end end;local nx=50;local ny=340;local hq=500;local hr=cr/2-400;local nz=0;for dR,dD in pairs(ir("boolean"))do if type(dD.get())=="boolean"then ni(dR,dR,ny,nx,hq,hr,function()return dD.get()end,function()nw(dD,dR)end,function()return true end,true)hr=hr+nx+20;if nz==9 then hq=hq+ny+20;hr=cr/2-400;nz=0 else nz=nz+1 end end end;ni("Control View","Control View",ny,nx,10,cr/2-500,function()return true end,nu,function()return true end,true)ni("View Handling Settings",'Hide Handling Settings',ny,nx,10,cr/2-(500-nx),function()return nr end,function()np("handling")end,function()return true end,true)ni("View Hud Settings",'Hide Hud Settings',ny,nx,10,cr/2-(500-nx*2),function()return ns end,function()np("hud")end,function()return true end,true)ni("View Physics Settings",'Hide Physics Settings',ny,nx,10,cr/2-(500-nx*3),function()return nt end,function()np("physics")end,function()return true end,true)end;local function nA()local function gD()local g3=c_;local gE=iU.name..". "..#bk;if radar_1 then gE=cD.GetClosestName(gE)end;return cB.AddNewLocation(gE,g3,false,true)end;local function nB()a_=not a_ end;local function nC(nD)if nD==1 then aY=not aY;aX=false else aX=not aX;aY=false end;aZ=false;b0=false;bZ=false;b1=false;bo=nil;b3=false;b2=false end;local function nE()cB.UpdatePosition()end;local function gy()cB.ClearCurrentPosition()end;local function nF(gC)local lJ=cC.routeWP(true)if lJ and#lJ>0 then return"Engage Route: "..lH(lJ[1])end;return"Engage Autopilot: "..lH(gC)end;local function nG(gC)local lJ=cC.routeWP(true)if lJ and#lJ>0 then return"Next Route Point: "..lH(lJ[1])end;return"Disable Autopilot: "..lH(gC)end;local function nH()if il()==1 then bZ=not bZ;if bZ then aZ=false;aX=false;aY=false;b0=false;b3=false;b1=false;b2=false;nI=bh;bh=false;d.control.retractLandingGears()im:setTargetGroundAltitude(X)g1("folOn","F")else g1("folOff","F")aW=true;cH=p;bh=nI;if bh then d.control.extendLandingGears()im:setTargetGroundAltitude(Y)end end else c0="Follow Mode only works with Remote controller"bZ=false end end;local nx=50;local ny=260;local nJ=iV(30)local nK=av+au*2+2;local nL=aw+1;ni("+","+",nJ,nJ,nK,nL+nJ+1,function()return false end,function()dj=dj/8 end,function()return bB=="SCOPE"end,nil,"ZoomButton")ni("-","-",nJ,nJ,nK,nL,function()return false end,function()dj=math.min(dj*8,90)end,function()return bB=="SCOPE"end,nil,"ZoomButton")ni("0","0",nJ,nJ,nK,nL+nJ*2+2,function()return false end,function()dj=90 end,function()return bB=="SCOPE"and dj~=90 end,nil,"ZoomButton")local nM=ni("Enable Brake Toggle","Disable Brake Toggle",ny,nx,cq/2-ny/2,cr/2+350,function()return aU end,function()aU=not aU;if aU then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)ni("Align Prograde","Disable Prograde",ny,nx,cq/2-ny/2-50-nM.width,cr/2-nx+380,function()return aY end,function()nC(1)end)ni("Align Retrograde","Disable Retrograde",ny,nx,cq/2-ny/2+nM.width+50,cr/2-nx+380,function()return aX end,nC,function()return ci==0 end)nN=ni(nF,nG,600,60,cq/2-600/2,cr/2-60/2-330,function()return aZ or bl or ce or bu end,function()end)local K;local function nO(nP)local lJ=cC.routeWP(true)if lJ and#lJ>0 then return lJ[1]end;local gC=df+nP;if gC>#d6 then gC=gC-#d6-1 end;if gC<0 then gC=#d6+gC end;return gC end;nQ={}for K=0,10 do local nR=ni(function(eK)local gC=nO(eK.apExtraIndex)if aZ or bl or ce or bu then return"Redirect: "..lH(gC)end;return nF(gC)end,function(eK)local gC=nO(eK.apExtraIndex)return nG(gC)end,600,60,cq/2-600/2,cr/2-60/2-330+60*K,function(eK)local gC=nO(eK.apExtraIndex)return gC==bg and(aZ or bl or ce or bu)end,function(eK)local gC=nO(eK.apExtraIndex)local nS=bg==gC;bg=gC;cB.UpdateAutopilotTarget()cC.ToggleAutopilot()if not nS and not(aZ or bl or ce or bu)then cC.ToggleAutopilot()end end,function()return de and(#cC.routeWP(true)==0 or K==0)end)nR.apExtraIndex=K;nQ[K]=nR end;ni("Save Position","Save Position",200,nN.height,nN.x+nN.width+30,nN.y,function()return false end,gD,function()return bg==0 or gb==nil end)ni("Update Position","Update Position",200,nN.height,nN.x+nN.width+30,nN.y,function()return false end,nE,function()return bg>0 and gb~=nil end)ni("Clear Position","Clear Position",200,nN.height,nN.x-200-30,nN.y,function()return true end,gy,function()return bg>0 and gb~=nil end)ni("Save Route","Save Route",200,nN.height,nN.x+nN.width+30,nN.y+nN.height+20,function()return false end,function()cC.routeWP(false,false,2)end,function()return#cC.routeWP(true)>0 end)ni("Load Route","Clear Route",200,nN.height,nN.x-200-30,nN.y+nN.height+20,function()return#cC.routeWP(true)>0 end,function()if#cC.routeWP(true)>0 then cC.routeWP(false,true)elseif aZ or bl then c0="Disable Autopilot before loading route"return else cC.routeWP(false,false,1)end end,function()return true end)nx=60;ny=300;local hq=0;local hr=cr/2-150;ni("Enable Check Damage","Disable Check Damage",ny,nx,hq,hr-nx-20,function()return s end,function()s=not s end)ni("View Settings","View Settings",ny,nx,hq,hr,function()return true end,nu)hr=hr+nx+20;ni("Enable Turn and Burn","Disable Turn and Burn",ny,nx,hq,hr,function()return a_ end,nB)hq=10;hr=cr/2-300;ni("Horizontal Takeoff Mode","Vertical Takeoff Mode",ny,nx,hq+ny+20,hr,function()return aV end,function()aV=not aV;if aV then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return d0 end)hr=hr+nx+20;ni("Engage Orbiting","Cancel Orbiting",ny,nx,hq+ny+20,hr,function()return bu end,cC.ToggleIntoOrbit,function()return ci==0 and db end)hr=cr/2-150;ni("Glide Re-Entry","Cancel Glide Re-Entry",ny,nx,hq+ny+20,hr,function()return b3 end,function()cd=1;nC(1)end,function()return iU.hasAtmosphere and not ch end)hr=hr+nx+20;ni("Parachute Re-Entry","Cancel Parachute Re-Entry",ny,nx,hq+ny+20,hr,function()return b3 end,function()cd=2;nC(1)end,function()return iU.hasAtmosphere and not ch end)hr=hr+nx+20;ni("Engage Follow Mode","Disable Follow Mode",ny,nx,hq,hr,function()return bZ end,nH,function()return il()==1 end)ni("Enable Repair Arrows","Disable Repair Arrows",ny,nx,hq+ny+20,hr,function()return cv end,function()cv=not cv;if cv then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return il()==1 end)hr=hr+nx+20;if not q then ni("Enable AGG","Disable AGG",ny,nx,hq,hr,function()return d1 end,cC.ToggleAntigrav,function()return antigrav~=nil end)end;ni(function()return dr("Switch IPH Mode - Current: %s",bv)end,function()return dr("IPH Mode: %s",bv)end,ny*2,nx,hq,hr,function()return false end,function()if bv=="All"then bv="Custom Only"elseif bv=="Custom Only"then bv="No Moons"else bv="All"end;c0="IPH Mode: "..bv end)hr=hr+nx+20;ni(function()return dr("Toggle Control Scheme - Current: %s",g)end,function()return dr("Control Scheme: %s",g)end,ny*2,nx,hq,hr,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local nT=iW(20)local nR=ne(0,0,iV(70),nT,"HELP")nR=ne(nR.x+nR.width,nR.y,iV(80),nT,"INFO")nR=ne(nR.x+nR.width,nR.y,iV(70),nT,"ORBIT")nR=ne(nR.x+nR.width,nR.y,iV(70),nT,"SCOPE")ne(nR.x+nR.width,nR.y,iV(70),nT,"HIDE")end;local nU={}local nV=nil;function nU.HUDPrologue(jE)d7,d8=iS(c_)if not d7 then bH=ae;bJ=af;bI=ag;if ih and G and ih.getState()==0 then ih.toggle()end else bH=ab;bJ=ac;bI=ad;if ih and G and ih.getState()==1 then ih.toggle()end end;co=[[rgb(]]..bE(bH+0.6)..","..bE(bJ+0.6)..","..bE(bI+0.6)..[[)]]cp=[[rgb(]]..bE(bH*0.8+0.5)..","..bE(bJ*0.8+0.5)..","..bE(bI*0.8+0.5)..[[)]]local nW=co;local nX=cp;local nY=[[rgb(]]..bE(bH*0.4+0.5)..","..bE(bJ*0.4+0.5)..","..bE(bI*0.4+0.5)..[[)]]local nZ=co;local n_=cp;local o0=nY;if iX()and not m then nW=[[rgb(]]..bE(bH*0.5+0.5)..","..bE(bJ*0.5+0.5)..","..bE(bI*0.5+0.5)..[[)]]nX=[[rgb(]]..bE(bH*0.3+0.5)..","..bE(bJ*0.3+0.5)..","..bE(bI*0.2+0.5)..[[)]]nY=[[rgb(]]..bE(bH*0.2+0.5)..","..bE(bJ*0.2+0.5)..","..bE(bI*0.2+0.5)..[[)]]end;local lw=iV;local lx=iW;jE[#jE+1]=dr([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nW,nW,nW,nZ,nZ,nX,nX,n_,n_,nX,nW,nY,n_,nW,nW,nY,nY,o0,nY,cq,cr,nX,nX,nX,nX,nX,nZ,nX,n_,o0,n_,n_,o0)if not nV then nV=dr([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lw(630),lx(0),lw(675),lx(45),lw(960),lx(55),lw(1245),lx(45),lw(1290),lx(0),lw(1000),lx(105),lw(1040),lx(59),lw(1250),lx(51),lw(1300),lx(0),lw(1920),lx(0),lw(1920),lx(20),lw(1400),lx(20),lw(1300),lx(105),lw(920),lx(105),lw(880),lx(59),lw(670),lx(51),lw(620),lx(0),lw(0),lx(0),lw(0),lx(20),lw(520),lx(20),lw(620),lx(105),lw(890),lx(59),lw(960),lx(62),lw(1030),lx(59),lw(985),lx(112),lw(1150),lx(112),lw(1100),lx(152),lw(820),lx(152),lw(780),lx(112),lw(935),lx(112),lw(890),lx(59),lw(960),lx(62),lw(1030),lx(59),lw(985),lx(112),lw(1150),lx(112),lw(1100),lx(152),lw(820),lx(152),lw(780),lx(112),lw(935),lx(112))end;if x and I then jE[#jE+1]=nV end;return jE end;function nU.DrawVerticalSpeed(jE,ea)jD(jE,ea)end;function nU.UpdateHud(jE)local ks=d4;local o1=d5;local jL=o1;local k0=ks;local kK=bE(c.getThrottle())local kP=cX*3.6;local kL=c.getAxisCommandValue(0)local o2=iV(1770)local o3=iW(310)if u and d3 then kL=bK;kK=bK*100 end;local iZ=iY()local jM="ROLL"if kK==nil then kK=0 end;if not db then if cX>5 then ks=kr(cV)o1=kt(cV)else ks=0;o1=0 end;jM="YAW"end;if d8>50000 and not ch then local o4;o4=is(d8)jE[#jE+1]=gQ(o2,o3,"PvP Boundary: "..o4,"pbright txtbig txtmid")end;jE[#jE+1]=cc;jE[#jE+1]=iK;jE[#jE+1]=ic;if iG~=""then jE[#jE+1]=iG end;if i_~=""then jE[#jE+1]=i_ end;if j0~=""then jE[#jE+1]=j0 end;jD(jE,cj)if il()==0 or l then if db then jK(jE,ah,ai,jL,jM,db)else jK(jE,ah,ai,o1,jM,db)end;if not iX()or m then if db then jK(jE,ah,ai,jL,jM,db)j_(jE,k0,jL,ah,ai,db,bE(kt(cV)),cX)else jK(jE,ah,ai,o1,jM,db)j_(jE,ks,o1,ah,ai,db,bE(o1),cX)end;k6(jE,cj,db)ku(jE,cV,cX,ah,ai)end end;kJ(jE,iZ,kK,kL)kO(jE,kP)kS(jE)lQ(jE)if not iE and b_ then lI(jE)end;return jE end;function nU.HUDEpilogue(jE)jE[#jE+1]="</svg>"return jE end;function nU.ExtraData(jE)local o5=iV(1240)local o6=iW(55)local o7=o6+10;local gI;local lw=iV;local lx=iW;local o8=0;local iZ=iY()if aV then iZ=iZ.."-VERTICAL"end;if F and not b2 and not b1 and cX>20 then iZ=iZ.."-COLLISION ON"end;if bx~="Off"then iZ="("..bx..")-"..iZ end;if a_ then iZ="TB-"..iZ end;if not bw then iZ=iZ.."-DeCoupled"end;local o9=lx(99)local oa=lx(80)local ob=lx(85)local oc=lx(31)local od=0;local oe=0;local of=cl>1000000 and ip(cl/1000000,2).."kT"or ip(cl/1000,2).."T"if ch then o8=bp else o8=bn end;local og,oh=cx.computeDistanceAndTime(cX,0,cl,0,0,o8)if og<0 then og=0 end;o8=ip(o8/(cl*iw),2).."g"local oi=d:maxForceForward()gI=b.g()if gI>0.1 then oe=cl*gI;oe=ip(oe/(cl*iw),2).."g"od=0.5*oi/gI;od=od>1000000 and ip(od/1000000,2).."kT"or ip(od/1000,2).."T"end;oi=ip(oi/(cl*iw),2).."g"local oj=vec3(b.getWorldAcceleration()):len()/9.80665;gI=b.g()jE[#jE+1]=[[<g class="dim txt txtend size14">]]if il()==1 and not l then o5=iV(1120)o6=iW(55)o7=o6+10 elseif ch and I then local ok=iV(770)jE[#jE+1]=gQ(lw(895),o9,"ATMO","")jE[#jE+1]=dr([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lw(895),ob,lw(-80))jE[#jE+1]=gQ(lw(815),oa,dr("%.1f%%",ci*100),"txtstart size20")end;if I then jE[#jE+1]=gQ(lw(1025),o9,"GRAVITY","txtstart")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1025),ob,lw(80))jE[#jE+1]=gQ(lw(1105),oa,dr("%.2fg",gI/9.80665),"size20")jE[#jE+1]=gQ(lw(1125),o9,"ACCEL","txtstart")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1125),ob,lw(80))jE[#jE+1]=gQ(lw(1205),oa,dr("%.2fg",oj),"size20")jE[#jE+1]=gQ(lw(695),o9,"BRK TIME","")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(695),ob,lw(-80))jE[#jE+1]=gQ(lw(615),oa,dr("%s",it(oh)),"txtstart size20")jE[#jE+1]=gQ(lw(635),lx(45),"TRIP","")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(635),lx(31),lw(-90))if lq then jE[#jE+1]=gQ(lw(532),lx(23),dr("%s",it(lq)),"txtstart size20")end;jE[#jE+1]=gQ(lw(795),o9,"BRK DIST","")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(795),ob,lw(-80))jE[#jE+1]=gQ(lw(715),oa,dr("%s",is(og)),"txtstart size20")jE[#jE+1]=gQ(lw(1285),lx(45),"MASS","txtstart")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1285),lx(31),lw(90))jE[#jE+1]=gQ(lw(1388),lx(23),dr("%s",of),"size20")jE[#jE+1]=gQ(lw(1220),o9,"THRUST","txtstart")jE[#jE+1]=dr([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lw(1220),ob,lw(80))jE[#jE+1]=gQ(lw(1300),oa,dr("%s",oi),"size20")jE[#jE+1]=gQ(iV(960),iW(175),iZ,"pbright txtbig txtmid size20")end;jE[#jE+1]="</g>"end;local ol=1-(a5*0.05+a6*0.05)function nU.FuelUsed(om)local on;if om=="atmofueltank"then on=dr("Atmo Fuel Used: %.1f L",jg[om]/(4*ol))elseif om=="spacefueltank"then on=dr("Space Fuel Used: %.1f L",jg[om]/(6*ol))else on=dr("Rocket Fuel Used: %.1f L",jg[om]/(0.8*ol))end;return on end;function nU.DrawOdometer(jE,c5,bi,c6)if bB~="INFO"then return jE end;local gI;local od=0;local oe=0;local o8=0;local of=cl>1000000 and ip(cl/1000000,2).." kTons"or ip(cl/1000,2).." Tons"if ch then o8=bp else o8=bn end;local og,oh=cx.computeDistanceAndTime(cX,0,cl,0,0,o8)o8=ip(o8/(cl*iw),2).." g"local oi=d:maxForceForward()gI=b.g()if gI>0.1 then oe=cl*gI;oe=ip(oe/(cl*iw),2).." g"od=0.5*oi/gI;od=od>1000000 and ip(od/1000000,2).." kTons"or ip(od/1000,2).." Tons"end;oi=ip(oi/(cl*iw),2).." g"if il()==0 or l then local oo=iV(av+10)local op=iW(aw+20)local oq=iV(av+10+au/1.25)local ng=25;jE[#jE+1]="<g class='txtstart size14 bright'>"jE[#jE+1]=gQ(oo,op,dr("BrkTime: %s",it(oh)))jE[#jE+1]=gQ(oq,op,dr("Trip: %.2f km",c5))jE[#jE+1]=gQ(oo,op+ng,dr("Lifetime: %.2f kSU",bi/200000))jE[#jE+1]=gQ(oq,op+ng,dr("BrkDist: %s",is(og)))jE[#jE+1]=gQ(oo,op+ng*2,"Trip Time: "..it(c6))jE[#jE+1]=gQ(oq,op+ng*2,"Total Time: "..it(bj))jE[#jE+1]=gQ(oo,op+ng*3,dr("Mass: %s",of))jE[#jE+1]=gQ(oq,op+ng*3,dr("Max Brake: %s",o8))jE[#jE+1]=gQ(oo,op+ng*4,dr("Max Thrust: %s",oi))if gI>0.1 then jE[#jE+1]=gQ(oq,op+ng*4,dr("Max Thrust Mass: %s",od))jE[#jE+1]=gQ(oo,op+ng*5,dr("Req Thrust: %s",oe))else jE[#jE+1]=gQ(oq,op+ng*4,"Max Mass: n/a")jE[#jE+1]=gQ(oo,op+ng*5,"Req Thrust: n/a")end;jE[#jE+1]=gQ(oq,op+ng*5,cA.FuelUsed("atmofueltank"))jE[#jE+1]=gQ(oo,op+ng*6,cA.FuelUsed("spacefueltank"))jE[#jE+1]=gQ(oq,op+ng*6,cA.FuelUsed("rocketfueltank"))end;jE[#jE+1]="</g></g>"return jE end;function nU.DrawWarnings(jE)return kS(jE)end;function nU.DisplayOrbitScreen(jE)return lQ(jE)end;function nU.DisplayMessage(jE,ld)if ld~="empty"then local hr=310;for os in string.gmatch(ld,"([^\n]+)")do hr=hr+35;jE[#jE+1]=gQ("50%",hr,os,"msg")end end;if ca~=0 then c.setTimer("msgTick",ca)ca=0 end end;function nU.DrawDeadZone(jE)jE[#jE+1]=dr([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],at)end;function nU.UpdatePipe()if ch then iG=""return end;n5()end;function nU.DrawSettings(jE)local hq=iV(640)local hr=iW(200)jE[#jE+1]=[[<g class="pbright txtvspd txtstart">]]local hU=0;for dR,dD in pairs(iF)do hU=hU+1;jE[#jE+1]=gQ(hq,hr,dR..": "..dD.get())hr=hr+20;if hU%12==0 then hq=hq+iV(350)hr=iW(200)end end;jE[#jE+1]=gQ(iV(640),iW(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jE[#jE+1]="</g>"return jE end;local i9=iV(1770)local ia=iW(350)local i8=iW(15)local i7=iV(1370)local id,ot;function nU.DrawRadarInfo()ic=cD.GetRadarHud(i7,i8,i9,ia)end;function nU.DrawTanks()if ap~=0 and aq~=0 then i_=gQ(ap,aq,"","txtstart pdim txtfuel")jh=aq;ji(ap,"Atmospheric ","ATMO",cs,je,jf)ji(ap,"Space Fuel T","SPACE",ct,jc,jd)ji(ap,"Rocket Fuel ","ROCKET",cu,ja,jb)end end;function nU.DrawShield()local ou=ih.getState()==1 and"Shield Active"or"Shield Disabled"local ov=b.getPvPTimer()local ow=ih.getResistances()local ox="A: "..10+ow[1]*100 .."% / E: "..10+ow[2]*100 .."% / K:"..10+ow[3]*100 .."% / T: "..10+ow[4]*100 .."%"local hq,hr=ar-60,as+30;local oy=bE(0.5+ih.getShieldHitpoints()*100/ih.getMaxShieldHitpoints())local jw=bE(oy*2.55)local jx=dr("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""j0=gQ(hq,hr,"","txtmid pdim txtfuel")if oy<10 and ou~="Shield Disabled"then jy="red "end;ov=ov>0 and"   PvPTime: "..it(ov)or""j0=j0 ..dr([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hq,hr,jx,oy*2,hq,hr,hq+2,hr+10,oy,ov)j0=j0 ..gQ(hq,hr-5,ou,jy.."txtstart pbright txtbig")j0=j0 ..gQ(hq,hr+30,ox,jy.."txtstart pbright txtsmall")end;function nU.hudtick()if not iU then return end;local function oz(jE)local jA=bE(ds(cb/(cq/4)*255,0,255))jE[#jE+1]=dr("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bE(bH+0.5)+jA,bE(bJ+0.5)-jA,bE(bI+0.5)-jA)end;local function oA()for dW,dD in pairs(ix)do if dD.hovered then if not dD.drawCondition or dD.drawCondition(dD)then dD.toggleFunction(dD)end;dD.hovered=false end end;for dW,dD in pairs(iA)do if dD.hovered then bB=dD.label;dD.hovered=false end end end;local function oB()local function oC(oD,oE,hq,hr,nf,ng)if oD>=hq and oD<=hq+nf and oE>=hr and oE<=hr+ng then return true else return false end end;local hq=c8+cq/2;local hr=c9+cr/2;for dW,dD in pairs(ix)do dD.hovered=oC(hq,hr,dD.x,dD.y,dD.width,dD.height)end;for dW,dD in pairs(iA)do dD.hovered=oC(hq,hr,dD.x,dD.y,dD.width,dD.height)end;if de then local mV=false;for dW,eK in ipairs(nQ)do if eK.hovered then mV=true;break end end;if nN.hovered then mV=true end;de=mV else de=nN.hovered;if not de then df=bg end end end;local function oF(jE)if not bB or bB==""then bB="HELP"end;if x then for dR,dD in pairs(iA)do local jy="dim brightstroke"local oG=0.2;if bB==dR then jy="pbright dimstroke"oG=0.6 end;local oH=""if dD.hovered then oG=0.8;oH=";stroke:white"end;jE[#jE+1]=dr([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dD.width,dD.height,dD.x,dD.y,jy,oG,oH)jE[#jE+1]=gQ(dD.x+dD.width/2,dD.y+dD.height/2+5,dD.label,"txt txtmid pdim")end end end;local function oI(jE)local function oJ(jE,oK,hover,hq,hr,fq,oL,oM,oN,oO,oP,nR)if type(oO)=="function"then oO=oO(nR)end;if type(oP)=="function"then oP=oP(nR)end;jE[#jE+1]=dr("<rect x='%f' y='%f' width='%f' height='%f' fill='",hq,hr,fq,oL)if oK then jE[#jE+1]=dr("%s'",oM)else jE[#jE+1]=oN end;if hover then jE[#jE+1]=dr(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ab,ac,ad)else jE[#jE+1]=dr(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ip(ab*0.5,0),ip(ac*0.5,0),ip(ad*0.5,0))end;jE[#jE+1]=" rx='5'></rect>"jE[#jE+1]=dr("<text x='%f' y='%f' font-size='24' fill='",hq+fq/2,hr+oL/2+5)if oK then jE[#jE+1]="black"else jE[#jE+1]="white"end;jE[#jE+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oK then jE[#jE+1]=dr("%s</text>",oO)else jE[#jE+1]=dr("%s</text>",oP)end end;local oQ=dr("rgb(%d,%d,%d)'",ip(ab*0.1,0),ip(ac*0.1,0),ip(ad*0.1,0))local oR=dr("rgb(%d,%d,%d)",ip(ab*0.8,0),ip(ac*0.8,0),ip(ad*0.8,0))local oS=oJ;for dW,dD in pairs(ix)do local nk=dD.disableName;local nj=dD.enableName;if type(nk)=="function"then nk=nk(dD)end;if type(nj)=="function"then nj=nj(dD)end;if not dD.drawCondition or dD.drawCondition(dD)then oS(jE,dD.toggleVar(dD),dD.hovered,dD.x,dD.y,dD.width,dD.height,oR,oQ,nk,nj,dD)end end end;local oT=ip(cq/2,0)local oU=ip(cr/2,0)local jE={}cA.HUDPrologue(jE)if x then cA.UpdateHud(jE)else if B then cA.DrawVerticalSpeed(jE,cj)end;cA.DrawWarnings(jE)end;if iE and iF~="none"then cA.DrawSettings(jE)end;if radar_1 then cA.DrawRadarInfo()end;cA.HUDEpilogue(jE)jE[#jE+1]=dr([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cq,cr)if c0~="empty"then cA.DisplayMessage(jE,c0)end;if il()==0 and g=="virtual joystick"then if w then cA.DrawDeadZone(jE)end end;oF(jE)if io()==0 then if il()==1 and b_ then if not oV then oB()oI(jE)end;if not cF and not cG then local oW=table.concat(jE,"")jE={}jE[#jE+1]=dr("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cq,cr)jE[#jE+1]=oW;jE[#jE+1]="</body>"cF=true;jE[#jE+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oX=table.concat(jE,"")a.setScreen(oX)elseif cG then local oW=table.concat(jE,"")jE={}jE[#jE+1]=dr("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cq,cr)jE[#jE+1]=oW;jE[#jE+1]="</body>"end;if not cF then jE[#jE+1]=dr([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oT,oU,c8,c9)end else oA()end else if not b_ and il()==0 then oA()if cb>at then if w then oz(jE)end end elseif b_ and(not oV or not i)then oB()oI(jE)end;jE[#jE+1]=dr([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oT,oU,c8,c9)end;jE[#jE+1]=[[</svg></body>]]oX=table.concat(jE,"")end;function nU.TenthTick()local function oY()local oZ=a.createData;local o_=a.createWidget;p0=a.createWidgetPanel("Interplanetary Helper")p1=o_(p0,"value")p2=oZ('{"label": "Target Planet", "value": "N/A", "unit":""}')g0(p2,p1)p3=o_(p0,"value")p4=oZ('{"label": "distance", "value": "N/A", "unit":""}')g0(p4,p3)gs=o_(p0,"value")gr=oZ('{"label": "Travel Time", "value": "N/A", "unit":""}')g0(gr,gs)gq=o_(p0,"value")gp=oZ('{"label": "Maximum Mass", "value": "N/A", "unit":""}')g0(gp,gq)gu=o_(p0,"value")gt=oZ('{"label": "Target Altitude", "value": "N/A", "unit":""}')g0(gt,gu)gm=o_(p0,"value")gl=oZ('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gk=o_(p0,"value")gj=oZ('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gi=o_(p0,"value")gh=oZ('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gg=o_(p0,"value")gf=oZ('{"label": "Max Brake Time", "value": "N/A", "unit":""}')go=o_(p0,"value")gn=oZ('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then g0(gl,gm)g0(gj,gk)g0(gh,gi)g0(gf,gg)g0(gn,go)end end;local function p5()gP(p0)p0=nil end;local function p6()if not aZ then if gb==nil or gb.planetname~=iU.name then p7=(c4.center-c_):len()else p7=(gb.position-c_):len()end end;local fx=cX;local p8=c.getThrottle()/100;if u then p8=bK end;local p9,pa=cx.computeDistanceAndTime(cX,_,cl,d:maxForceForward()*p8,a1,0)local c2,c3;if not a_ then c2,c3=cC.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cC.GetAutopilotTBBrakeDistanceAndTime(_)end;local dW,pb;if not a_ and fx>0 then dW,pb=cC.GetAutopilotBrakeDistanceAndTime(fx)else dW,pb=cC.GetAutopilotTBBrakeDistanceAndTime(fx)end;local pc=0;local pd=0;if b9 or not aZ and fx>5 then pd=cx.computeTravelTime(fx,0,p7)elseif c2+p9<p7 then pc=p7-(c2+p9)pd=cx.computeTravelTime(8333.0556,0,pc)else local pe=(p7-c2)/p9;p9=p7-c2;pa=pa*pe end;if gb~=nil and gb.planetname==iU.name and not aZ then return pd elseif b8 then return pb elseif b9 then return pd+pb else return pa+c3+pd end end;cA.DrawTanks()if ih then cA.DrawShield()end;if be~="None"then if p0==nil then oY()end;if be~=nil then local pf=gb~=nil;local pg=0.5*bp/c4:getGravity(c4.center+vec3(0,0,1)*c4.radius):len()pg=pg>1000000 and ip(pg/1000000,2).." kTons"or ip(pg/1000,2).." Tons"f_(p2,'{"label": "Target", "value": "'..be..'", "unit":""}')lq=p6()if pf and not aZ then cb=(c_-gb.position):len()else cb=(bf-c_):len()end;if not a_ then c2,c3=cC.GetAutopilotBrakeDistanceAndTime(cX)iI,iJ=cC.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cC.GetAutopilotTBBrakeDistanceAndTime(cX)iI,iJ=cC.GetAutopilotTBBrakeDistanceAndTime(_)end;local ld=is(cb)f_(p4,'{"label": "distance", "value": "'..ld..'"}')f_(gr,'{"label": "Travel Time", "value": "'..it(lq)..'", "unit":""}')ld=is(c2)f_(gl,'{"label": "Cur Brake distance", "value": "'..ld..'"}')f_(gj,'{"label": "Cur Brake Time", "value": "'..it(c3)..'", "unit":""}')ld=is(iI)f_(gh,'{"label": "Max Brake distance", "value": "'..ld..'"}')f_(gf,'{"label": "Max Brake Time", "value": "'..it(iJ)..'", "unit":""}')f_(gp,'{"label": "Max Brake Mass", "value": "'..dr("%s",pg)..'", "unit":""}')ld=is(gv)f_(gt,'{"label": "Target Orbit", "value": "'..ld..'"}')if ci>0 and not ph then a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)a.removeDataFromWidget(gj,gk)a.removeDataFromWidget(gl,gm)a.removeDataFromWidget(gn,go)ph=true;if not d3 and u and(b0 or b3 or cf)then cC.cmdThrottle(1)aW=false;bO=false end end;if ci==0 and ph then if f_(gf,gg)==1 then g0(gf,gg)end;if f_(gh,gi)==1 then g0(gh,gi)end;if f_(gj,gk)==1 then g0(gj,gk)end;if f_(gl,gm)==1 then g0(gl,gm)end;if f_(gn,go)==1 then g0(gn,go)end;ph=false end end else p5()end;if warpdrive~=nil then if ij(warpdrive.getData()).destination~="Unknown"and ij(warpdrive.getData()).distance>400000 then warpdrive.show()pi=true else warpdrive.hide()pi=false end end end;function nU.OneSecondTick()local function pj()local js=bD()local kP=cX;local pk=js-ck;if kP>1.38889 then kP=kP/1000;local pl=kP*(js-ck)bi=bi+pl;c5=c5+pl end;c6=c6+pk;bj=bj+pk;ck=js end;local function pm(jE)local pn=0;iK=""local po=iv;local pp=0;local pq=0;local pr=0;local jw=0;local jx=""local ps=b.getElementHitPointsById;local pt=b.getElementMaxHitPointsById;local pu={}for dR in pairs(iu)do local pv=0;local pw=0;pw=pt(iu[dR])pv=ps(iu[dR])pp=pp+pv;if pv<pw then if pv==0 then pr=pr+1 else pq=pq+1 end;if cv and#pu==0 then g3=vec3(b.getElementPositionById(iu[dR]))local hq=g3.x;local hr=g3.y;local hs=g3.z;table.insert(pu,b.spawnArrowSticker(hq,hr,hs+1,"down"))table.insert(pu,b.spawnArrowSticker(hq,hr,hs+1,"down"))b.rotateSticker(pu[2],0,0,90)table.insert(pu,b.spawnArrowSticker(hq+1,hr,hs,"north"))table.insert(pu,b.spawnArrowSticker(hq+1,hr,hs,"north"))b.rotateSticker(pu[4],90,90,0)table.insert(pu,b.spawnArrowSticker(hq-1,hr,hs,"south"))table.insert(pu,b.spawnArrowSticker(hq-1,hr,hs,"south"))b.rotateSticker(pu[6],90,-90,0)table.insert(pu,b.spawnArrowSticker(hq,hr-1,hs,"east"))table.insert(pu,b.spawnArrowSticker(hq,hr-1,hs,"east"))b.rotateSticker(pu[8],90,0,90)table.insert(pu,b.spawnArrowSticker(hq,hr+1,hs,"west"))table.insert(pu,b.spawnArrowSticker(hq,hr+1,hs,"west"))b.rotateSticker(pu[10],-90,0,90)table.insert(pu,iu[dR])end elseif cv and#pu>0 and pu[11]==iu[dR]then for jr in pairs(pu)do b.deleteSticker(pu[jr])end;pu={}end end;pn=bE(pp/po*100)if pn<100 then jE[#jE+1]=gQ(0,0,"","pbright txt")jw=bE(pn*2.55)jx=dr("rgb(%d,%d,%d)",255-jw,jw,0)if pn<100 then jE[#jE+1]=gQ("50%",1035,"Elemental Integrity: "..pn.."%","txtbig txtmid","fill:"..jx)if pr>0 then jE[#jE+1]=gQ("50%",1055,"Disabled Modules: "..pr.." Damaged Modules: "..pq,"txtbig txtmid","fill:"..jx)elseif pq>0 then jE[#jE+1]=gQ("50%",1055,"Damaged Modules: "..pq,"txtbig txtmid","fill:"..jx)end end end end;local function px()if ii then if iL==nil and(dm~=nil or bh)then _autoconf.displayCategoryPanel(ii,weapon_size,"Weapons","weapon",true)iL=_autoconf.panels[_autoconf.panels_size]elseif iL~=nil and dm==nil and not bh then gP(iL)iL=nil end end end;dg=b.getPlayersOnBoard()dh=b.getDockedConstructs()local jE={}pj()if s then pm(jE)end;px()cA.UpdatePipe()cA.ExtraData(jE)cc=table.concat(jE,"")collectgarbage("collect")end;function nU.AnimateTick()cG=true;cF=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nU.MsgTick()local jE={}cA.DisplayMessage(jE,"empty")c0="empty"c.stopTimer("msgTick")ca=3 end;function nU.ButtonSetup()nv()nA()ix=iy end;return nU end;local function py(d,b,c,a,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,f5,bE,bF,il,f0,bD,ds,im,f_,io,du,ip,g1,iq,dv,is,it,pA,ij,dr,g0)local pB={}local function pC(fx)local pD=ba;if not aZ then pD=0 end;if not ch then return cx.computeDistanceAndTime(fx,pD,cl,0,0,bn-bc*cl)else if bp and bp>0 then return cx.computeDistanceAndTime(fx,pD,cl,0,0,bp-bc*cl)else return 0,0 end end end;local function pE(fx)local pD=ba;if not aZ then pD=0 end;return cx.computeDistanceAndTime(fx,pD,cl,d:maxForceForward(),a1,bn-bc*cl)end;local pF=false;local pG=0;local pH=0;local pI=0;local pJ=bD()local pK=0;local pL=0;local pM=0;local pN=0;local pO=false;local pP=false;local pQ=false;local pR=nil;local pS=0;local pT={}local iH=55;local pU=nil;local pV=""function pB.GetAutopilotBrakeDistanceAndTime(fx)return pC(fx)end;function pB.GetAutopilotTBBrakeDistanceAndTime(fx)return pE(fx)end;local function pW(pX,pY,pZ)pY=pY:project_on_plane(pX)pZ=pZ:project_on_plane(pX)return f0(pY:cross(pZ):dot(pX),pY:dot(pZ))end;local function p_()local function q0()local q1=-1;local q2=-1;if vBooster then q1=vBooster.getDistance()end;if hover then q2=hover.getDistance()end;if q1~=-1 and q2~=-1 then if q1<q2 then return q1 else return q2 end elseif q1~=-1 then return q1 elseif q2~=-1 then return q2 else return-1 end end;local q3=q0()local q4=-1;if pz then q4=pz.getDistance()end;if q3~=-1 and q4~=-1 then if q3<q4 then return q3 else return q4 end elseif q3~=-1 then return q3 else return q4 end end;local function q5(iU,eS,q6)local function q7(q8,e2)local eY=vec3(e2)if q8.id==0 then return setmetatable({latitude=eY.x,longitude=eY.y,altitude=eY.z,id=0,systemId=q8.systemId},e4)end;local eZ=eY-q8.center;local cb=eZ:len()local ea=cb-q8.radius;local e8=0;local e9=0;if not dv(cb,0)then local e_=f0(eZ.y,eZ.x)e9=e_>=0 and e_ or 2*math.pi+e_;e8=math.pi/2-math.acos(eZ.z/cb)end;return setmetatable({latitude=math.deg(e8),longitude=math.deg(e9),altitude=ea,id=q8.id,systemId=q8.systemId},e4)end;local q9=q7(iU,eS)q9="::pos{"..q9.systemId..","..q9.id..","..q9.latitude..","..q9.longitude..","..q9.altitude.."}"if q6 then return q9 else a.setWaypoint(q9)return true end end;local qa=false;function pB.showWayPoint(iU,eS,q6)return q5(iU,eS,q6)end;function pB.APTick()local function qb()if dd and not b1 then local ez=dd[1]local hZ,h_=dd[2],dd[3]local qc=math.min(hZ,h_ or hZ)local qd=qc/cX;local qe=b2 and(cX<42 or cg~=-1)local qf=b0 or bl or bo or aZ;if qf and not qe and(c2*1.5>qc or qd<1)then aW=true;pT={}cC.cmdThrottle(0)if b0 then cC.ToggleAltitudeHold()end;if bo then cC.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"if bl or aZ then cC.ToggleAutopilot()end;lk=true;b1=true;cH=true end;if qd<11 then dc=ez.name.." COLLISION "..it(qd).." / "..is(qc,2)else dc=ez.name.." collision "..it(qd)end;if qd<6 then g1("alarm","AL",2)end else dc=false end end;local function qg(qh,qi,qj)local function qk(qh,eB)qh=vec3(qh)eB=vec3(eB):normalize()local dM=qh*eB;return dM.x+dM.y+dM.z end;local ql=0.001;local qm=1;if not ch or not cI or cg~=-1 or cX<iH then if qj==nil then qj=aN end;if qi==nil then qi=ql end;qh=vec3(qh):normalize()local qn=vec3()-qh;local qo=-qk(qn,b.getConstructWorldOrientationRight())*qm;local qp=-qk(qn,b.getConstructWorldOrientationUp())*qm;if pH==0 then pH=qo/2 end;if pI==0 then pI=qp/2 end;if f5(qo)<0.1 then bU=bU-qo*2 else bU=bU-(qo+(qo-pH)*qj)end;if f5(qp)<0.1 then bT=bT+qp*2 else bT=bT+qp+(qp-pI)*qj end;pH=qo;pI=qp;if f5(qo)<qi and f5(qp)<qi then return true end;return false elseif cI and cg==-1 then qh=cW;if qj==nil then qj=aN end;if qi==nil then qi=ql end;qh=vec3(qh):normalize()local qn=cT-qh;local qo=-qk(qn,b.getConstructWorldOrientationRight())*qm;local qp=-qk(qn,b.getConstructWorldOrientationUp())*qm;if pH==0 then pH=qo/2 end;if pI==0 then pI=qp/2 end;if f5(qo)<0.1 then bU=bU-qo*5 else bU=bU-(qo+(qo-pH)*qj)end;if f5(qp)<0.1 then bT=bT+qp*5 else bT=bT+qp+(qp-pI)*qj end;pH=qo;pI=qp;if f5(qo)<qi and f5(qp)<qi then return true end;return false end end;ch=bF()>0;ci=bF()cj=b.getAltitude()cg=p_()bG=bD()pJ=bG;if F then qb()end;if antigrav then d1=antigrav.getState()==1 end;local qq=a.getMouseWheel()if qq>0 then cC.changeSpd()elseif qq<0 then cC.changeSpd(true)else cm=true end;local qr=1;local qs=1;local qt=bG-pJ;local qu=-math.deg(pW(cS,cW,cT))local qv=math.deg(pW(cU,cW,cT))local gx=cY*-1;cI=ch and qu<-L or qu>L or qv<-M or qv>M;local qw=a.getMouseDeltaX()local qx=a.getMouseDeltaY()if o and not b_ then qx=-qx end;bU=0;bY=0;bT=0;g4=cw[0]iU=g4:closestBody(b.getConstructWorldPos())qy=cz(iU)fB=qy:orbitalParameters(b.getConstructWorldPos(),cW)if cj==0 then cj=(c_-iU.center):len()-iU.radius end;db=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local gI=iU:getGravity(b.getConstructWorldPos()):len()*cl;cJ=0;cy=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if io()==0 then if il()==1 and b_ then if not cF then c8=ds(c8+qw,-cq/2,cq/2)c9=ds(c9+qx,-cr/2,cr/2)end else c8=0;c9=0 end else c8=ds(c8+qw,-cq/2,cq/2)c9=ds(c9+qx,-cr/2,cr/2)cb=du(c8*c8+c9*c9)if not b_ and il()==0 then local kB,kC=1,1;if bB=="SCOPE"then kB,kC=dj/90,dj/90 end;if g=="virtual joystick"then if c8>0 and c8>at then bU=bU-(c8-at)*aB*kB elseif c8<0 and c8<at*-1 then bU=bU-(c8+at)*aB*kB else bU=0 end;if c9>0 and c9>at then bT=bT-(c9-at)*aC*kC elseif c9<0 and c9<at*-1 then bT=bT-(c9+at)*aC*kC else bT=0 end else c8=0;c9=0;if g=="mouse"then bT=(-utils.smoothstep(qx,-100,100)+0.5)*2*qr;bU=(-utils.smoothstep(qw,-100,100)+0.5)*2*qs end end end end;local qz=cX>8334;if cX>V/3.6 and not ch and not aZ and not qz then c0="Space Speed Engine Shutoff reached"cC.cmdThrottle(0)end;if not qz and qA then if not aW then cC.BrakeToggle()end;if aZ then cC.ToggleAutopilot()end end;qA=qz;if ch and ci>0.09 then if cX>cK/3.6 and not u and not pF then aW=true;pF=true elseif not u and pF then if cX<cK/3.6 then aW=false;pF=false end end end;if aW then bX=1 else bX=0 end;if aY then if cd then aW=false;local qB=false;if gb and cd==true then qB=qg(gb.position-c_,0.1)else qB=qg(vec3(cW),0.01)end;cH=true;if qB then cC.cmdCruise(bE(cK))if(f5(d5)<2 or f5(d4)>85)and cX>=cK/3.6-1 then aW=false;aY=false;if cd~=2 then bQ=true end;if cd==true then cf=true end;cd=false;aZ=false;cC.BeginReentry()end elseif ch and u then cC.cmdThrottle(1)end elseif cX>iH then qg(vec3(cW),0.01)end end;if aX then if ch then aX=false elseif cX>iH then qg(-vec3(cW))end end;if not aY and cd and not bu then if ci==0 then if cd~=2 then bQ=true end;cC.BeginReentry()cd=false;cf=true else cd=false;cC.ToggleAutopilot()end end;if cf and gb and(cj<b5+250 and cj>b5-250)and cX*3.6>cK-250 and f5(cZ)<25 and ci>=0.1 and(gb.position-c_):len()>2000+cj then cC.ToggleAutopilot()cf=false end;if b4 then cH=true;local qC=b5;if cZ<-30 then c0="Unable to achieve lift. Safety Landing."c7=0;cH=p;b4=false;b1=true elseif not q and d1 or b5<iU.spaceEngineMinAltitude then if d1 then qC=antigrav.getBaseAltitude()end;if cj<qC-100 then cL=0;c7=15;aW=false elseif cZ>0 then aW=true;c7=0 elseif cZ<-30 then aW=true;c7=15 elseif cj>=qC then if d1 then if aZ or bl then cC.ToggleVerticalTakeoff()else aW=true;b4=false end;c0="Takeoff complete. Singularity engaged"g1("aggLk","AG")else aW=false;c0="VTO complete. Engaging Horizontal Flight"g1("vtoc","VT")cC.ToggleVerticalTakeoff()end;c7=0 end else if ci>0.08 then cL=0;aW=false;c7=20 elseif ci<0.08 and ci>0 then aW=false;if cQ then cL=0;c7=20 else c7=0;cL=36;cC.cmdCruise(3500)end else cH=p;bu=true;cP=false;qD=false;pO=false;pM=nil;pN=nil;if pR==nil then pR=iU end;cO=qC;pQ=true;b4=false end end;if cL~=nil then if qE==nil then qE=pid.new(2*0.01,0,2*0.1)end;local qF=ds(cL-d4,-M*0.80,M*0.80)qE:inject(qF)local qG=ds(qE:get(),-1,1)bT=qG end end;if bu then local qn;local qH=false;local qI=is(cO)if pR==nil then pR=iU;if bl then pR=c4 end end;if not pQ then cO=bE(pR.radius+pR.surfaceMaxAltitude+T)if pR.hasAtmosphere then cO=bE(pR.radius+pR.noAtmosphericDensityAltitude+T)end;pQ=true end;if cN.VectorToTarget and gb then qn=gb.position-c_ end;local qJ,qK=cz(pR):escapeAndOrbitalSpeed((c_-pR.center):len()-pR.radius)local qL=d5;if not pO then local qM=false;local qN=false;cC.cmdThrottle(0)pN=0;cM="Aligning to orbital path - OrbitHeight: "..qI;if cN.VectorToTarget then qg(qn:normalize():project_on_plane(cY))qH=cT:dot(qn:project_on_plane(cS):normalize())>0.95 else qg(cW)qH=qu<0.5;if cX<150 then qH=true end end;bT=0;pM=0;if d4<=pM+1 and d4>=pM-1 then qM=true else qM=false end;if qL<=pN+1 and qL>=pN-1 then qN=true else qN=false end;if qM and qN and qH then pM=nil;pN=nil;pO=true end else if cN.VectorToTarget then qg(qn:normalize():project_on_plane(cY))elseif cX>150 then qg(cW)end;bT=0;if cN.VectorToTarget and gb then local c2,dW=cx.computeDistanceAndTime(cX,cK/3.6,cl,0,0,bn)if cP and qn:len()>15000+c2+cj then cM="Orbiting to Target"if cj-100<=pR.noAtmosphericDensityAltitude or lq>fB.timeToPeriapsis and fB.periapsis.altitude<pR.noAtmosphericDensityAltitude then cP=false end elseif cP or qn:len()<15000+c2+cj then c0="Orbit complete, proceeding with reentry"g1("orCom","OB")bf=gb.position;bQ=true;cf=true;cN.VectorToTarget,cN.AutopilotAlign=false,false;cC.ToggleIntoOrbit()cC.BeginReentry()return end end;if fB.periapsis~=nil and fB.apoapsis~=nil and fB.eccentricity<1 and cj>cO*0.9 and cj<cO*1.4 then if fB.apoapsis~=nil then if fB.periapsis.altitude>=cO*0.99 and fB.apoapsis.altitude>=cO*0.99 and fB.periapsis.altitude<fB.apoapsis.altitude and fB.periapsis.altitude*1.05>=fB.apoapsis.altitude or cP then if cP then aW=false;cC.cmdThrottle(0)pM=0;if not cN.VectorToTarget then c0="Orbit complete"g1("orCom","OB")cC.ToggleIntoOrbit()end else pS=pS+1;if pS>=2 then cP=true end end else cM="Adjusting Orbit - OrbitHeight: "..qI;pP=true;cC.cmdCruise(qK*3.6+1)local qO=cO-cj;if qP==nil then qP=pid.new(0.1,0,1*0.1)end;qP:inject(qO-cZ*ds(utils.smoothstep(2000-qO,-2000,2000)^6*10,1,10))pM=ds(qP:get(),-60,60)end end else local qQ=2.75;local qR=f5(ip(qJ*qQ))local ol=qR%50;if ol>0 then qR=qR-ol+50 end;aW=false;if cj<cO*0.8 then cM="Escaping planet gravity - OrbitHeight: "..qI;pM=utils.map(cZ,200,0,-15,80)elseif cj>=cO*0.8 and cj<cO*1.15 then cM="Approaching orbital corridor - OrbitHeight: "..qI;qR=qR*0.75;pM=utils.map(cZ,100,-100,-15,65)elseif cj>=cO*1.15 and cj<cO*1.5 then cM="Approaching orbital corridor - OrbitHeight: "..qI;qR=qR*0.75;if cZ<0 or pP then pM=utils.map(cj,cO*1.5,cO*1.01,-30,0)else pM=utils.map(cj,cO*0.99,cO*1.5,0,30)end elseif cj>cO*1.5 then cM="Reentering orbital corridor - OrbitHeight: "..qI;pM=-65;local qS=utils.map(cZ,-150,-400,1,0.55)qR=qR*qS end;cC.cmdCruise(bE(qR))end end;if pM~=nil then if qT==nil then qT=pid.new(1*0.01,0,5*0.1)end;local qU=pM-d4;qT:inject(qU)local qV=ds(qT:get(),-0.5,0.5)bT=qV end end;if aZ and ci==0 and not cd then local function qW(id,fB)a.print(id)aW=false;b8=false;aZ=false;qX=false;bb="Aligning"cC.cmdThrottle(0)bP=false;c0=id;g1("apCom","AP")if fB or cd then if fB and gv~=nil and not cd then if not cj or cj==0 then return end;cO=cj;pQ=true end;cC.ToggleIntoOrbit()end end;local qY,qZ=bf,false;if gb and gb.planetname~="Space"then b7=true;if not qX then local q_=(gb.position-c4.center):normalize()local r0=q_:project_on_plane((c4.center-c_):normalize()):normalize()local r1=c4.center+r0*(c4.radius+gv)local r2=gb.position+(gb.position-c4.center):normalize()*(gv-c4:getAltitude(gb.position))if(c_-r1):len()<(c_-r2):len()then qY=r1 else qY=r2;ba=0 end;bf=qY;cC.showWayPoint(c4,bf)qZ=true;qX=true end;bc=0 elseif gb and gb.planetname=="Space"then if not qX then bc=0;qZ=true;b7=true;qX=true;qY=gb.position+(c_-gb.position):normalize()*R;bf=qY end elseif gb==nil then bc=0;if not qX then local q_=(c_+cW*100000-c4.center):normalize()local r0=q_:project_on_plane((c4.center-c_):normalize()):normalize()if r0:len()<1 then q_=(c_+cT*100000-c4.center):normalize()r0=q_:project_on_plane((c4.center-c_):normalize()):normalize()end;qY=c4.center+r0*(c4.radius+gv)bf=qY;qX=true;qZ=true;b7=true;cC.showWayPoint(c4,bf)end end;p7=(vec3(qY)-c_):len()local lo,eQ,eR=cw:getPlanetarySystem(0):castIntersections(c_,cW:normalize(),function(ez)if ez.noAtmosphericDensityAltitude>0 then return ez.radius+ez.noAtmosphericDensityAltitude else return ez.radius+ez.surfaceMaxAltitude*1.5 end end)local lp=eQ;if eR~=nil and eQ~=nil then lp=math.min(eR,eQ)end;if lp~=nil and lp<p7 and lo.name==c4.name then p7=lp end;local qB=true;local r3=(c4.center-(c_+vec3(cW):normalize()*p7)):len()-c4.radius;local ld=is(r3)f_(gn,'{"label": "Projected Altitude", "value": "'..ld..'"}')local c2,c3;if not a_ then c2,c3=pC(cX)else c2,c3=pE(cX)end;if cX>50 and b6 then local qn=vec3(qY)-c_;local r4=ds(math.deg(pW(cS,cW:normalize(),qn:normalize()))*cX/500,-90,90)local r5=ds(math.deg(pW(cU,cW:normalize(),qn:normalize()))*cX/500,-90,90)if f5(r4)<20 and f5(r5)<20 then r4=r4*2;r5=r5*2 end;if f5(r4)<2 and f5(r5)<2 then r4=r4*2;r5=r5*2 end;local qu=-math.deg(pW(cS,cT,cW:normalize()))local qv=-math.deg(pW(cU,cT,cW:normalize()))if r6==nil then r6=pid.new(2*0.01,0,2*0.1)end;r6:inject(r5-qv)local r7=ds(r6:get(),-1,1)bT=bT+r7;if r8==nil then r8=pid.new(2*0.01,0,2*0.1)end;r8:inject(r4-qu)local r9=ds(r8:get(),-1,1)bU=bU+r9;qZ=true;if f5(r4)>2 or f5(r5)>2 then if bb~="Adjusting Trajectory"then bb="Adjusting Trajectory"g1("apAdj","AP")end else if bb~="Accelerating"then bb="Accelerating"g1("apAcc","AP")end end elseif b6 and cX<=50 then qg((qY-c_):normalize())end;if r3<gv*1.5 then if gb and gb.planetname=="Space"then ba=0 elseif gb==nil then dW,ba=cz(c4):escapeAndOrbitalSpeed(r3)end end;if aZ and not b6 and not b9 and not b8 then local lo,lp=cC.checkLOS((bf-c_):normalize())if c4.name~=iU.name then if lo~=nil and c4.name~=lo.name and lp<p7 then c0="Collision with "..lo.name.." in "..is(lp).."\nClear LOS to continue."ca=5;qa=true else qa=false;c0=""end end end;if not qa then if not b9 and not b8 and not qZ then qB=qg((qY-c_):normalize())elseif a_ and(b8 or b9)then qB=qg(-vec3(cW):normalize())end end;if b6 then if not bP then aW=false;cC.cmdThrottle(a0)bK=ip(a0,2)bP=true end;local p8=c.getThrottle()if u then p8=bK end;local ra=99999;local oj=-vec3(b.getWorldAcceleration()):dot(cW:normalize())local rb=ds(cW:dot((qY-c_):normalize()),0,cX)if rb>0 or oj>0 then ra=cx.computeTravelTime(rb,oj,p7-c2)end;if cV:len()>=_ or p8==0 and bP or a1/4>ra then b6=false;if bb~="Cruising"then g1("apCru","AP")bb="Cruising"end;b9=true;cC.cmdThrottle(0)end;local rc=p7;if rc<=c2 or H and d8<=c2+10000 and d7 then if H and d8<=c2+10000 and d7 then if d8<pG and d8>2000 then cC.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pG=d8 else pG=d8;return end end;b6=false;if bb~="Braking"then g1("apBrk","AP")bb="Braking"end;b8=true;cC.cmdThrottle(0)bP=false end elseif b8 then if bb~="Orbiting to Target"then aW=true;bX=1 end;if a_ then cC.cmdThrottle(1,true)end;local dW,qK=cz(c4):escapeAndOrbitalSpeed((c_-iU.center):len()-iU.radius)local qn;if gb then qn=gb.position-c_ end;if gb and gb.planetname=="Space"and cX<50 then if#pT>0 then aW=false;cC.ToggleAutopilot()cC.ToggleAutopilot()return end;qW("Autopilot complete, arrived at space location")aW=true;bX=1 elseif gb and gb.planetname~="Space"and cX<=qK and(fB.apoapsis==nil or fB.periapsis==nil or fB.apoapsis.altitude<=0 or fB.periapsis.altitude<=0)then qW("Autopilot complete, commencing reentry")bf=gb.position;cd=true;cC.showWayPoint(c4,bf)elseif(gb and gb.planetname~="Space"or gb==nil)and fB.periapsis~=nil and fB.periapsis.altitude>0 and fB.eccentricity<1 or bb=="Circularizing"then if bb~="Circularizing"then g1("apCir","AP")bb="Circularizing"end;if cX<=qK then if gb then if cW:normalize():dot(qn:normalize())>0.4 then if bb~="Orbiting to Target"then g1("apOrb","OB")bb="Orbiting to Target"end;if not rd then aW=false;cC.showWayPoint(c4,gb.position)rd=true end else qW("Autopilot complete, proceeding with reentry")bf=gb.position;cd=true;cC.showWayPoint(c4,gb.position)rd=false end else qW("Autopilot completed, setting orbit",true)bX=0 end end elseif bb=="Circularizing"then qW("Autopilot complete, fixing Orbit",true)end elseif b9 then local rc=p7;if rc<=c2 or H and d8<=c2+10000 and d7 then if H and d8<=c2+10000 and d7 then if d8<pG and d8>2000 then cC.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;pG=d8 else pG=d8;return end end;b6=false;if bb~="Braking"then g1("apBrk","AP")bb="Braking"end;b8=true end;local p8=c.getThrottle()if u then p8=bK end;if p8>0 then b6=true;if bb~="Accelerating"then bb="Accelerating"g1("apAcc","AP")end;b9=false end else if qB then if not b7 and gb==nil or not b7 and gb and gb.planetname~="Space"then if not cd then bf=vec3(c4.center)+(gv+c4.radius)*cU;re=cS;rf=cU end;b7=true elseif qB and not qa then b6=true;if bb~="Accelerating"then bb="Accelerating"g1("apAcc","AP")end;if not bP then cC.cmdThrottle(a0,true)bK=ip(a0,2)bP=true;aW=false end end end end elseif aZ and(gb~=nil and gb.planetname~="Space"and ci>0)then c0="Autopilot complete, starting reentry"g1("apCom","AP")bf=gb.position;aW=false;b8=false;aZ=false;qX=false;bb="Aligning"bX=0;cC.cmdThrottle(0)bP=false;aY=true;cd=true;cC.showWayPoint(c4,gb.position)end;if bZ then cH=true;local r5=0;local fD=c_+vec3(c.getMasterPlayerRelativePosition())local rg=fD-c_;local rh=vec3(rg):project_on(cT):len()local ri=vec3(rg):project_on(cU):len()local cb=du(rh*rh+ri*ri)qg(rg:normalize())local mw=40;local rj=cb<mw;local rk=100;local rl=ds((cb-mw)/2,10,rk)bT=0;local qB=f5(bU)<0.1;if qB and cX<rl and not rj then aW=false;r5=-20 else aW=true;r5=0 end;local rm=0;if f5(r5-d4)>rm then if rn==nil then rn=pid.new(2*0.01,0,2*0.1)end;rn:inject(r5-d4)local r7=rn:get()bT=r7 end end;if b0 or b1 or b3 or bl or bo~=nil then local ro=bp;if ro then ro=ro*ds(cX/100,0.1,1)*ci else ro=bn end;if ci<0.01 then ro=bn end;local rp=cT:project_on_plane(cY):normalize():dot(cW)local rq=vec3(b.getWorldAirFrictionAcceleration())local rr=rq:len()*cl;if rp>100 then c2,c3=cx.computeDistanceAndTime(rp,100,cl,0,0,ro)local rs,rt=cx.computeDistanceAndTime(100,0,cl,0,0,ro*0.55)c2=c2+rs else c2,c3=cx.computeDistanceAndTime(rp,0,cl,0,0,ro*0.55)end;local qO=b5-cj-cZ;local ru=200+cX;if b3 or cd then rv=2000+cX end;local rw=1;if b2 then rw=ds(cX/100,0.1,1)end;local r5=(utils.smoothstep(qO,-ru,ru)-0.5)*2*O*rw;if not b3 and not cd and not bl and cT:dot(cW:normalize())<0.99 then r5=(utils.smoothstep(qO,-ru*ds(20-19*ci*10,1,20),ru*ds(20-19*ci*10,1,20))-0.5)*2*O*ds(2-ci*10,1,2)*rw end;if not b0 then r5=0 end;if bo~=nil then if db and not bu then r5=bo else bo=nil end end;cH=true;local rx=bT;if b3 then local ry=bE(cK)local rz,rA=cx.computeDistanceAndTime(cX,ry/3.6,cl,0,0,bn-iU.gravity*9.8*cl)rz=rz==-1 and 5000 or rz;local rB=cj-(iU.noAtmosphericDensityAltitude+rz)local rC=cj>iU.noAtmosphericDensityAltitude+rz*1.35;if rC then r5=P;if cX<=ry/3.6 and cX>ry/3.6-10 and f5(cW:normalize():dot(cT))>0.9 and not d3 then bO=false;cC.cmdThrottle(1)end elseif(d3 or im:getTargetSpeed(axisCommandId.longitudinal)~=ry)and not rC and not ch then cC.cmdCruise(ry,true)end;if d3 then if cX>ry/3.6 and not rC then aW=true else aW=false end else aW=false end;if cZ>0 then aW=true end;if not bQ then r5=-80;if cj<iU.surfaceMaxAltitude+(iU.atmosphereThickness-iU.surfaceMaxAltitude)*0.25 then c0="PARACHUTE DEPLOYED at "..ip(cj,0)b3=false;b1=true;lk=true;cC.cmdThrottle(0)r5=0;cH=p end elseif iU.noAtmosphericDensityAltitude>0 and rC then cH=true elseif not rC then if not ch and(d3 or im:getTargetSpeed(axisCommandId.longitudinal)~=ry)then cC.cmdCruise(ry)end;if cX<ry/3.6+1 then aW=false;bQ=false;b3=false;cH=true end end end;if cX>iH and not ce and not bl and not b1 and v then qg(vec3(cW))end;if d9 or(bl or ce)and bg>0 and ci>0.01 then local qn;if d9 then if type(d9)=="table"then qn=d9 elseif d9<3 and d9>0 then qn=-cY:cross(cW)*5000 elseif d9>=3 then qn=cY:cross(cW)*5000 elseif d9<0 then qn=cW*25000 end elseif gb~=nil then qn=gb.position-c_ else qn=c4.center-c_ end;local r4=math.deg(pW(cY:normalize(),cW,qn))*2;local mz=math.rad(f5(d5))if cX>aG and ci>0.01 then local rD=1000+cX;local rE=(utils.smoothstep(qO-cZ*10,-rD,rD)-0.5)*2*O;local rF=ds(90-rE,0,180)cJ=ds(r4*2,-rF,rF)local rG=r4;r4=ds(ds(r4,-L*0.80,L*0.80)*math.cos(mz)+4*(d4-r5)*math.sin(math.rad(d5)),-L*0.80,L*0.80)local rH=1;if cJ~=0 then rH=f5(mz/cJ)end;rH=(90-ds(f5(cJ-d5),0,90))/90;local rI=r5;if f5(d5)>90 then rI=-rI end;r5=rH*ds(ds(rI*math.cos(mz),-M*0.8,M*0.8)+f5(ds(f5(rG)*math.sin(mz),-M*0.80,M*0.80)),-M*0.80,M*0.80)else cJ=0;r4=ds(r4,-L*0.80,L*0.80)end;local rJ=qu-r4;if d9 and f5(rJ)<=0.0001 and(type(d9)=="table"or type(d9)~="table"and d9<0 and f5(d5)<1)then if d9==-2 then cC.ToggleAltitudeHold()end;d9=nil;g1("180Off","BR")return end;if not cI and cX>aG and ci>0.01 then if rK==nil then rK=pid.new(2*0.01,0,2*0.1)end;rK:inject(rJ)local r9=ds(rK:get(),-1,1)bU=bU+r9 elseif ch and cg>-1 or cX<aG then qg(qn)elseif cI and ci>0.01 then if(qu<-L or qu>L)and ci>0.01 then qg(cW)end;if(qv<-M or qv>M)and ci>0.01 then r5=ds(d4-qv,d4-M*0.80,d4+M*0.80)end end;if gb~=nil and not ce then local qC=iU:getAltitude(gb.position)local rB=qn:project_on_plane(cY):len()lk=true;if not ce and not b3 and rB<=c2 and(cW:project_on_plane(cY):normalize():dot(qn:project_on_plane(cY):normalize())>0.99 or ls=="Finalizing Approach")then ls="Finalizing Approach"if#pT>0 then cC.ToggleAutopilot()cC.ToggleAutopilot()return end;cC.cmdThrottle(0)if b0 then cC.ToggleAltitudeHold()bl=true end;aW=true elseif not b2 then aW=false end;if ls=="Finalizing Approach"and(rp<0.1 or rB<0.1 or rL~=nil and rL<rB)then if not d1 then g1("bklOn","BL")b1=true end;bl=false;ls="Proceeding to Waypoint"dc=false end;rL=rB end elseif bl and ci==0 and b5>iU.noAtmosphericDensityAltitude and not(ce or b3)then if gb~=nil and c4.name==iU.name then local qn=gb.position-c_;local qC=iU:getAltitude(gb.position)local rB=du(qn:len()^2-(cj-qC)^2)local ro=bp;if ro then c2,c3=cx.computeDistanceAndTime(cX,0,cl,0,0,ro/2)lk=true;if rB<=c2+cX*qt/2 and cW:project_on_plane(cY):normalize():dot(qn:project_on_plane(cY):normalize())>0.99 then if iU.hasAtmosphere then aW=false;aY=false;bQ=true;cd=false;cf=true;aZ=false;cC.BeginReentry()end end;rL=rB end end end;if ci==0 and(b0 and b5>iU.noAtmosphericDensityAltitude)and not(ce or bu or b3)then if not cP and not bu then cO=b5;pQ=true;if bl then cN.VectorToTarget=true end;cC.ToggleIntoOrbit()bl=false;pO=true end end;if cI and ci>0.01 and cg==-1 and cX>aG and ls~="Finalizing Approach"then qg(cW)r5=ds(d4-qv,d4-M*0.80,d4+M*0.80)end;bT=rx;local q4=-1;if b1 then r5=0;local rM=false;local rN=30;if cy~=nil and cy>0 then local rO=ds(ci,0.4,2)local ro=bp*ds(cX/100,0.1,1)*rO;local rP=cy*rO+ro-gI;local rQ=ro/2-gI;local rR=cX-du(f5(rQ/2)*20/(0.5*cl))*utils.sign(rQ)if rR<0 then rR=0 end;local rS;if cX>100 then local rT,dW=cx.computeDistanceAndTime(cX,100,cl,0,0,ro)local rU,dW=cx.computeDistanceAndTime(100,0,cl,0,0,du(ro))rS=rT+rU else rS=cx.computeDistanceAndTime(cX,0,cl,0,0,du(ro))end;if rS<20 then aW=false else local rV=0;if rR>100 then local rW,dW=cx.computeDistanceAndTime(rR,100,cl,0,0,rP)local rX,dW=cx.computeDistanceAndTime(100,0,cl,0,0,cy*rO+du(ro)-gI)rV=rW+rX else rV,dW=cx.computeDistanceAndTime(rR,0,cl,0,0,cy*rO+du(ro)-gI)end;rV=(rV+15+cX*qt)*1.1;local rY=gb~=nil and iU:getAltitude(gb.position)>0 and gb.safe;if rY then local qC=iU:getAltitude(gb.position)local rZ=cj-qC-100;local qn=gb.position-c_;local r_=du(qn:len()^2-(cj-qC)^2)if r_>100 then rY=false elseif rZ<=rV or rV==-1 then aW=true;rM=true else aW=false;rM=true end end;if not rY and t then if rV>=rN then aW=true else aW=false end;rM=true end end end;if not d3 then cC.cmdThrottle(0)end;im:setTargetGroundAltitude(500)im:activateGroundEngineAltitudeStabilization(500)bw=true;q4=cg;if q4>-1 then cH=p;if cX<1 or cW:normalize():dot(cY)<0 then b1=false;b0=false;bh=true;if bR then d.control.extendLandingGears()g1("grOut","LG",1)end;im:setTargetGroundAltitude(Y)c7=0;aW=true else aW=true end elseif lk and cW:normalize():dot(-gx)<0.999 then aW=true elseif cZ<-N and not rM then aW=true elseif not rM then aW=false end end;if b2 or ce then local lo,eR,eQ;if bf~=nil then lo,eR,eQ=cw:getPlanetarySystem(0):castIntersections(c_,(bf-c_):normalize(),function(ez)return ez.radius+ez.noAtmosphericDensityAltitude end)end;if d1 then if cj>=b5-50 then b2=false;if not aZ and not bl then aW=true;cC.cmdThrottle(0)end else b5=antigrav.getBaseAltitude()end elseif f5(r5)<15 and cj/b5>0.75 then b2=false;if not ce then if d3 and not u then d.control.cancelCurrentControlMasterMode()end elseif ce and cX<iH then aZ=true;ce=false;b0=false;b2=false;cC.cmdThrottle(0)elseif ce then cC.cmdThrottle(0)aW=true end elseif ce and ci==0 and c4~=nil and(lo==nil or lo.name==c4.name)then aZ=true;ce=false;b0=false;b2=false;if not d3 then cC.cmdThrottle(0)end;b6=true end end;local s0=cg>-1;local s1=d4;if(bl or ce or d9)and not s0 and cX>aG and ci>0.01 then local mz=math.rad(f5(d5))s1=d4*f5(math.cos(mz))+qv*math.sin(mz)end;local s2=ds(r5-s1,-M*0.80,M*0.80)if ci<0.01 and bl then s2=ds(r5-s1,-85,O)elseif ci<0.01 then s2=ds(r5-s1,-O,O)end;if f5(d5)<5 or bl or d9 or b1 or s0 or b0 then if rn==nil then rn=pid.new(5*0.01,0,5*0.1)end;rn:inject(s2)local r7=rn:get()bT=bT+r7 end end;if antigrav~=nil and(antigrav and not q and cj<200000)then if bq==nil or bq<1000 then bq=1000 end;if s3~=bq then s3=bq;antigrav.setBaseAltitude(s3)end end end;function pB.ToggleIntoOrbit()cP=false;pM=nil;pN=nil;pS=0;if ci==0 then if bu then g1("orOff","AP")bu=false;pO=false;pR=nil;cH=p;if b0 then b0=false;b2=false end;cN.VectorToTarget=false;cN.AutopilotAlign=false;pQ=false elseif db then g1("orOn","AP")bu=true;cH=true;if pR==nil then pR=iU end;if b0 then b0=false;b2=false end else c0="Unable to engage auto-orbit, not near a planet"end else bu=false;pO=false;pR=nil;cH=p;if b0 then b0=false end;cN.VectorToTarget=false;cN.AutopilotAlign=false;pQ=false end end;function pB.ToggleVerticalTakeoff()b0=false;if b4 then lk=true;b3=false;b2=false;b1=true;cH=true;c7=0;if ch and cg==-1 then b1=false;b0=true;c7=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cC.cmdCruise(bE(cK))end else cP=false;bh=false;d.control.retractLandingGears()im:setTargetGroundAltitude(X)aW=true end;b4=not b4 end;function pB.checkLOS(qh)local lo,eQ,eR=cw:getPlanetarySystem(0):castIntersections(c_,qh,function(ez)if ez.noAtmosphericDensityAltitude>0 then return ez.radius+ez.noAtmosphericDensityAltitude else return ez.radius+ez.surfaceMaxAltitude*1.5 end end)local lp=eQ;if eR~=nil and eQ~=nil then lp=math.min(eR,eQ)end;if lp~=nil then return lo,lp else return nil,nil end end;function pB.ToggleAutopilot()local function s4(bs)dc=false;bl=not bl;if bl then a_=false;if not b0 and not bs then cC.ToggleAltitudeHold()end end;ls="Proceeding to Waypoint"end;local s5=false;if bG-pL<1.5 and ci>0 then if not cR then c0="No space engines detected, Orbital Hop not supported"return end;if iU.hasAtmosphere then if ci>0 then b5=iU.noAtmosphericDensityAltitude+T;g1("orH","OH")end;pL=-1;if aZ or bl or bu then return end end else pL=bG end;qX=false;if(bg>0 or#pT>0)and not aZ and not bl and not ce and not bu then if 0.5*d:maxForceForward()/b.g()<cl then c0="WARNING: Heavy Loads may affect autopilot performance."ca=5 end;if#pT>0 and not cf then bg=pT[1]cB.UpdateAutopilotTarget()table.remove(pT,1)c0="Route Autopilot in Progress"local qn=gb.position-c_;local rB=qn:project_on_plane(cY):len()if rB>50000 and gb.planetname==iU.name then s5=true end end;cB.UpdateAutopilotTarget()cC.showWayPoint(c4,bf)if gb~=nil then bo=nil;bs=gb.planetname=="Space"if bs then g1("apSpc","AP")if ci~=0 then ce=true;cC.ToggleAltitudeHold()else aZ=true end elseif iU.name==gb.planetname then lk=true;if ci>0 then if not bl then g1("vtt","AP")s4(bs)if s5 then b5=iU.noAtmosphericDensityAltitude+T end end else g1("apOn","AP")if not(c4.name==iU.name and cj<gv*1.5)then cP=false;aZ=true elseif not ch then if bu then cC.ToggleIntoOrbit()end;cO=iU.noAtmosphericDensityAltitude+T;pQ=true;cN.AutopilotAlign=true;cN.VectorToTarget=true;pO=false;if not bu then cC.ToggleIntoOrbit()end end end else g1("apP","AP")aX=false;aY=false;if ci~=0 then ce=true;cC.ToggleAltitudeHold()else aZ=true end end elseif ci==0 then if gb==nil and(c4.name==iU.name and db)and not bu then rd=false;cP=false;pO=false;cC.ToggleIntoOrbit()else g1("apP","AP")aZ=true;aX=false;aY=false;b7=false;bZ=false;b0=false;b1=false;b3=false;b2=false;bP=false;bo=nil;rd=false end else g1("apP","AP")ce=true;cC.ToggleAltitudeHold()end else g1("apOff","AP")cC.ResetAutopilots(1)end end;function pB.routeWP(s6,s7,s8)if s8 then if s8==1 then pT={}pT=iq(pT,bz)if#pT>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return pT else bz={}bz=iq(bz,pT)c0="Route Saved"pA()return end end;if s6 then return pT end;if s7 then pT={}c0="Current Route Cleared"else pT[#pT+1]=bg;c0="Added "..gb.name.." to route. "end;return pT end;function pB.cmdThrottle(dS,s9)if im:getAxisCommandType(0)~=axisCommandType.byThrottle and not s9 then d.control.cancelCurrentControlMasterMode()end;im:setThrottleCommand(axisCommandId.longitudinal,dS)bK=ds(ip(dS*100,0)/100,-1,1)d2=nil end;function pB.cmdCruise(dS,s9)if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not s9 then d.control.cancelCurrentControlMasterMode()end;im:setTargetSpeedCommand(axisCommandId.longitudinal,dS)d2=dS end;function pB.ToggleLockPitch()if bo==nil then g1("lkPOn","LP")if not b_ then bo=d4 else bo=Q end;b2=false;b0=false;b1=false else g1("lkPOff","LP")bo=nil end end;function pB.ToggleAltitudeHold()if bG-pK<1.5 then if iU.hasAtmosphere then if ci>0 then b5=iU.spaceEngineMinAltitude-0.01*iU.noAtmosphericDensityAltitude;g1("11","EP")else if db then b5=iU.noAtmosphericDensityAltitude+T;cO=b5;pQ=true;if not bu then cC.ToggleIntoOrbit()end;pO=true end end;pK=-1;if b0 or bu or b4 then return end end else pK=bG end;if db and ci==0 then cO=cj;pQ=true;pO=true;cC.ToggleIntoOrbit()if bu then pK=bG else pK=0 end;return end;b0=not b0;b1=false;b3=false;if b0 then aZ=false;aY=false;aX=false;bZ=false;cH=true;bo=nil;cP=false;if cg~=-1 and cX<20 then g1("lfs","LS")b2=true;if pK>-1 then b5=cj+W end;bh=false;d.control.retractLandingGears()aW=true;im:setTargetGroundAltitude(X)if aV and d0 then cC.ToggleVerticalTakeoff()end else g1("altOn","AH")b2=false;if pK>-1 then if db then b5=cj end end;if b4 then cC.ToggleVerticalTakeoff()end end;if ce then b5=100000 end else g1("altOff","AH")if bu then cC.ToggleIntoOrbit()end;if b4 then cC.ToggleVerticalTakeoff()end;cH=p;b2=false;bl=false;pK=0 end end;function pB.ResetAutopilots(pB)if pB then ce=false;aZ=false;b7=false;bP=false;b5=cj;qX=false end;bl=false;b2=false;b3=false;aY=false;b1=false;sa=false;d9=nil;if not d1 then b0=false;bo=nil end;if b4 then cC.ToggleVerticalTakeoff()end;if bu then cC.ToggleIntoOrbit()end;cH=p;cd=false;cf=false;c7=0 end;function pB.BrakeToggle()aW=not aW;if b1 then b1=false;cH=p end;if aW then g1("bkOn","B",1)cC.ResetAutopilots()else g1("bkOff","B",1)end end;function pB.BeginReentry()if b3 then c0="Re-Entry cancelled"g1("reOff","RE")b3=false;cH=p;b0=false elseif not iU.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ca=5 elseif not bQ then b3=true;if im:getAxisCommandType(0)~=sb.cruise then d.control.cancelCurrentControlMasterMode()end;cH=true;aW=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cK;g1("par","RE")else b3=true;b0=true;cH=true;aW=false;b5=iU.surfaceMaxAltitude+Z;if b5>iU.spaceEngineMinAltitude then b5=iU.spaceEngineMinAltitude-0.01*iU.noAtmosphericDensityAltitude end;local sc=is(b5)c0="Beginning Re-entry.  Target speed: "..cK.." Target Altitude: "..sc;g1("glide","RE")cC.cmdCruise(bE(cK))end;b2=false end;function pB.ToggleAntigrav()if antigrav and not q then if d1 then g1("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bq==nil then bq=cj end;if bq<1000 then bq=1000 end;g1("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pB.changeSpd(sd)local se=1;if sd then se=-1 end;if not b_ then if u and not oV and cm then local sf=bK;bK=ip(ds(bK+se*az/100,-1,1),2)if bK>=0 and sf<0 then bK=0;cm=false end elseif oV then if ci>0 or b3 then cK=ds(cK+se*az,0,U)elseif aZ then _=ds(_+se*az/3.6*100,0,8333.00)end else im:updateCommandFromActionStart(axisCommandId.longitudinal,se*az/10)end else if aZ or bl or ce or bu then df=df+1*se*-1;if df>#d6 then df=1 end;if df<1 then df=#d6 end else if not sd then se=1 else se=nil end;cB.adjustAutopilotTargetIndex(se)end end end;function pB.TenthTick()local function sg(gI,sh)if gI==nil then gI=b.g()end;gI=ip(gI,5)if sh~=nil and sh or(pU==nil or pU~=gI)then local fx=cV:len()local si=ij(c.getData()).maxBrake;if si~=nil and si>0 and ch then si=si/ds(fx/100,0.1,1)si=si/ci;if ci>0.10 then if bp then bp=(bp+si)/2 else bp=si end end end;if si~=nil and si>0 then bn=si end;pU=gI end end;sg(nil,true)if d2~=nil then if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or im:getTargetSpeed(axisCommandId.longitudinal)~=d2 then cC.cmdCruise(d2)else d2=nil end end end;function pB.SatNavTick()if not r then return end;pV=dbHud_1.getStringValue("SPBAutopilotTargetName")if pV~=nil and pV~=""and pV~="SatNavNotChanged"then local dM=ij(dbHud_1.getStringValue("SavedLocations"))if dM~=nil then bk=dM;local gC=-1;local gJ;for dR,dD in pairs(bk)do if dD.name and dD.name=="SatNav Location"then gC=dR;break end end;if gC~=-1 then gJ=bk[gC]gC=-1;for dR,dD in pairs(e[0])do if dD.name and dD.name=="SatNav Location"then gC=dR;break end end;if gC>-1 then e[0][gC]=gJ end;cB.UpdateAtlasLocationsList()c0=gJ.name.." position updated"end end;for K=1,#d6 do if d6[K].name==pV then bg=K;a.print("Index = "..bg.." "..d6[K].name)cB.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;cg=p_()return pB end;local function sj(d,b,c,a,e,vBooster,hover,antigrav,ih,dbHud_2,gyro,screenHud_1,il,im,io,sk,gP,ip,eb,dt,ds,g1,ir,pA)local sl={}local sm=true;local sn=5;local so=5;local sp=sn;local sq=so;local sr=bG;function sl.startControl(ss)local function st(sd)local se=1;local function su(sv,sd)local sw={iU.surfaceMaxAltitude+100,iU.spaceEngineMinAltitude-0.01*iU.noAtmosphericDensityAltitude,iU.noAtmosphericDensityAltitude+T,iU.radius*(S-1)+iU.noAtmosphericDensityAltitude}local sx=sv;for dW,dD in ipairs(sw)do if sd and sx>dD then sv=dD elseif sv<dD and not sd then sv=dD;break end end;return sv end;if sd then se=-1 end;if not q and d1 then if b_ and sd then bq=1000 elseif bq~=nil then bq=bq+se*so;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end else bq=s3+se*100 end elseif b0 or b4 or bu then if bu then if b_ then cO=su(cO,sd)else cO=cO+se*sn end;if cO<iU.noAtmosphericDensityAltitude then cO=iU.noAtmosphericDensityAltitude end else if b_ and ch then b5=su(b5,sd)else b5=b5+se*sn end end else im:updateTargetGroundAltitudeFromActionStart(se*1.0)end end;local function sy(sz)if not ch then c0="Flight Assist in Atmo only"return end;local dA=type(sz)if d9==nil then if dA=="table"then if aZ or bl then cC.ToggleAutopilot()end;g1("180On","BR")elseif sz==1 then g1("bnkLft","BR")else g1("bnkRht","BR")end;if not b0 and not aZ and not bl then cC.ToggleAltitudeHold()if dA~="table"then sz=sz+1 end end;d9=sz else g1("180Off","BR")d9=nil end end;if ss=="gear"then bh=not bh;if bh then bl=false;bo=nil;cC.cmdThrottle(0)if vBooster or hover then if ch and cg==-1 then g1("bklOn","BL")lk=true;b3=false;b2=false;b4=false;b0=false;b1=true;cH=true;bh=false else if bR then g1("grOut","LG",1)d.control.extendLandingGears()end;im:setTargetGroundAltitude(Y)if ch then aW=true end end end;if bR and not b1 and not(vBooster or hover)then g1("grOut","LG",1)d.control.extendLandingGears()end else if bR then g1("grIn","LG",1)d.control.retractLandingGears()end;im:setTargetGroundAltitude(X)end elseif ss=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ss=="forward"then bS=bS-1 elseif ss=="backward"then if oV then sy(-cW*5000)else bS=bS+1 end elseif ss=="left"then if oV then sy(1)else bV=bV-1 end elseif ss=="right"then if oV then sy(3)else bV=bV+1 end elseif ss=="yawright"then bW=bW-1 elseif ss=="yawleft"then bW=bW+1 elseif ss=="straferight"then im:updateCommandFromActionStart(axisCommandId.lateral,1.0)bt=1 elseif ss=="strafeleft"then im:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bt=-1 elseif ss=="up"then c7=c7+1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ss=="down"then c7=c7-1;im:deactivateGroundEngineAltitudeStabilization()im:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ss=="groundaltitudeup"then st()elseif ss=="groundaltitudedown"then st(true)elseif ss=="option1"then sA=false;if oV and b_ then local sB=""for K=1,#dg do sB=sB.."| Name: "..a.getPlayerName(dg[K]).." Mass: "..ip(b.getBoardedPlayerMass(dg[K])/1000,1).."t "end;a.print("Onboard: "..sB)return end;cB.adjustAutopilotTargetIndex()elseif ss=="option2"then sA=false;if oV and b_ then for K=1,#dg do b.forceDeboard(dg[K])end;c0="Deboarded All Passengers"return end;cB.adjustAutopilotTargetIndex(1)elseif ss=="option3"then local function sC()sm=not sm;if not sm then g1("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sD,atmofueltank_size,"Atmo Fuel","fuel_container")sE=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sF,spacefueltank_size,"Space Fuel","fuel_container")sG=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sH,rocketfueltank_size,"Rocket Fuel","fuel_container")sI=_autoconf.panels[_autoconf.panels_size]end;sJ=a.createWidgetPanel("Docking")sK=a.createWidget(sJ,"parenting")a.addDataToWidget(c.getDataId(),sK)sL=a.createWidgetPanel("Core combat stress")sM=a.createWidget(sL,"core_stress")a.addDataToWidget(b.getDataId(),sM)if ih~=nil then ih.show()end else g1("hud","DH")c.hide()b.hide()if sE~=nil then gP(sE)sE=nil end;if sJ~=nil then gP(sJ)sJ=nil end;if sL~=nil then gP(sL)sL=nil end;if sG~=nil then gP(sG)sG=nil end;if sI~=nil then gP(sI)sI=nil end;if ih~=nil then ih.hide()end end end;sA=false;if oV and b_ then local sB=""for K=1,#dh do sB=sB.."| ID: "..dh[K].." Mass: "..ip(b.getDockedConstructMass(dh[K])/1000,1).."t "end;a.print("Docked Ships: "..sB)return end;if y then if x then x=false else x=true end end;sC()elseif ss=="option4"then sA=false;if oV and b_ then for K=1,#dh do b.forceUndock(dh[K])end;c0="Undocked all ships"return end;d9=nil;cC.ToggleAutopilot()elseif ss=="option5"then sA=false;cC.ToggleLockPitch()elseif ss=="option6"then sA=false;if oV and b_ then if ih then local sN=ih.getVentingCooldown()if sN>0 then c0="Cannot vent again for "..sN.." seconds"return end;if ih.getShieldHitpoints()<ih.getMaxShieldHitpoints()then ih.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end;return else c0="No shield found"return end end;cC.ToggleAltitudeHold()elseif ss=="option7"then sA=false;if oV and b_ then if ih then ih.toggle()return else c0="No shield found"return end end;F=not F;if F then c0="Collision System Enabled"else c0="Collision System Secured"end elseif ss=="option8"then sA=false;if oV and b_ then if bg>0 and gb~=nil then cC.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bw=not bw;if not bw then c0="DeCoupled Mode - Ground Stabilization off"im:deactivateGroundEngineAltitudeStabilization()g1("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"im:activateGroundEngineAltitudeStabilization(sO)d:setEngineForceCommand('hover',vec3(),1)g1("gsOn","GS")end elseif ss=="option9"then sA=false;if oV and b_ then im:resetCommand(axisCommandId.longitudinal)im:resetCommand(axisCommandId.lateral)im:resetCommand(axisCommandId.vertical)cC.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cn=gyro.getState()==1;if cn then g1("gyOn","GA")else g1("gyOff","GA")end else c0="No gyro found"end elseif ss=="lshift"then de=false;if oV then b_=true end;if io()==1 then b_=true;bd=io()sk(1)elseif il()==1 and z then b_=true;cG=false;cF=false end elseif ss=="brake"then if aU or oV then cC.BrakeToggle()elseif not aW then cC.BrakeToggle()else aW=true end elseif ss=="lalt"then sA=true;oV=true;if il()==0 and not i and g=="keyboard"then sk(1)end elseif ss=="booster"then if n then d:toggleBoosters()elseif not c1 then if not sP then d:toggleBoosters()sP=true end;c1=true else if sP then d:toggleBoosters()sP=false end;c1=false end elseif ss=="stopengines"then local function sQ()if bG-sr<1.5 then g1("clear","CA")b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"aX=false;aY=false;d9=nil;b0=false;b3=false;b1=false;aW=false;b2=false;b4=false;bZ=false;bP=false;cd=false;ce=false;bQ=false;cH=p;bl=false;a_=false;cn=false;bo=nil;bu=false end end;sQ()sr=bG;if im:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then im:resetCommand(axisCommandId.longitudinal)cC.cmdThrottle(0)else cC.cmdThrottle(100)end else if im:getTargetSpeed(axisCommandId.longitudinal)~=0 then im:resetCommand(axisCommandId.longitudinal)else if ch then cC.cmdCruise(U)else cC.cmdCruise(_*3.6)end end end elseif ss=="speedup"then cC.changeSpd()elseif ss=="speeddown"then cC.changeSpd(true)elseif ss=="antigravity"and not q then if antigrav~=nil then cC.ToggleAntigrav()else c0="No antigrav found"end end end;function sl.stopControl(ss)local function sR()if not q and d1 then sq=so end;if b0 or b4 or bu then sp=sn end end;if ss=="forward"then bS=0 elseif ss=="backward"then bS=0 elseif ss=="left"then if d9 then if d9==2 then d9=-2 else d9=-1 end end;bV=0 elseif ss=="right"then if d9 then if d9==4 then d9=-2 else d9=-1 end end;bV=0 elseif ss=="yawright"then bW=0 elseif ss=="yawleft"then bW=0 elseif ss=="straferight"then im:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bt=0 elseif ss=="strafeleft"then im:updateCommandFromActionStop(axisCommandId.lateral,1.0)bt=0 elseif ss=="up"then c7=0;im:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bw then im:activateGroundEngineAltitudeStabilization(sO)d:setEngineForceCommand('hover',vec3(),1)end elseif ss=="down"then c7=0;im:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bw then im:activateGroundEngineAltitudeStabilization(sO)d:setEngineForceCommand('hover',vec3(),1)end elseif ss=="groundaltitudeup"then sR()sA=false elseif ss=="groundaltitudedown"then sR()sA=false elseif ss=="lshift"then if io()==1 then c8=0;c9=0;sk(bd)elseif il()==1 and z then cG=false;cF=false end;b_=false elseif ss=="brake"then if not aU and not oV then if aW then cC.BrakeToggle()else aW=false end end elseif ss=="lalt"then if il()==0 and i then if sA then if io()==1 then sk(0)else sk(1)end else sA=true end elseif il()==0 and not i and g=="keyboard"then sk(0)end;oV=false end end;function sl.loopControl(ss)local function sS(sd)local se=1;if sd then se=-1 end;if not q and d1 then if bq~=nil then bq=bq+se*sq;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end;sq=ds(sq*1.05,so,50)else bq=s3+se*100 end elseif b0 or b4 or bu then if bu then cO=cO+se*sp;if cO<iU.noAtmosphericDensityAltitude then cO=iU.noAtmosphericDensityAltitude end else b5=b5+se*sp end;sp=ds(sp*1.05,sn,50)else im:updateTargetGroundAltitudeFromActionLoop(se*1.0)end end;local function sT(sd)local se=1;if sd then se=-1 end;if not b_ then if u and not oV then bK=ds(bK+se*aA/100,-1,1)else im:updateCommandFromActionLoop(axisCommandId.longitudinal,se*aA)end end end;if ss=="groundaltitudeup"then if not b_ then sS()end elseif ss=="groundaltitudedown"then if not b_ then sS(true)end elseif ss=="speedup"then sT()elseif ss=="speeddown"then sT(true)end end;function sl.inputTextControl(sc)local function sU(sV,fD,gF)local function sW(fD)local dJ=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dK='::pos{'..dJ..','..dJ..','..dJ..','..dJ..','..dJ..'}'local d_,e0,e8,e9,ea=eb(fD,dK)if d_=="0"and e0=="0"then return vec3(dt(e8),dt(e9),dt(ea))end;e9=math.rad(e9)e8=math.rad(e8)local iU=e[dt(d_)][dt(e0)]local f1=math.cos(e8)local sX=vec3(f1*math.cos(e9),f1*math.sin(e9),math.sin(e8))return iU.center+(iU.radius+ea)*sX end;local g3=sW(fD)return cB.AddNewLocation(sV,g3,gF)end;local K;local sY,sZ=nil,nil;local s_="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate - dumps all custom waypoints to logfile and a screen if present for cut and paste to privatelocations.lua"K=string.find(sc," ")sY=sc;if K~=nil then sY=string.sub(sc,0,K-1)sZ=string.sub(sc,K+1)end;if sY=="/help"or sY=="/commands"then for os in string.gmatch(s_,"([^\n]+)")do a.print(os)end;return elseif sY=="/setname"then if sZ==nil or sZ==""then c0="Usage: ah-setname Newname"return end;if bg>0 and gb~=nil then cB.UpdatePosition(sZ)else c0="Select a saved target to rename first"end elseif ih and sY=="/resist"then if not ih then c0="No shield found"return elseif sZ==nil or ih.getResistancesCooldown()>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dJ=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dK=dJ..', '..dJ..', '..dJ..', '..dJ;local t0,t1,t2,t3=eb(sZ,dK)if t3==nil or t0+t1+t2+t3>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if ih.setResistances(t0,t1,t2,t3)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end elseif sY=="/addlocation"or string.find(sc,"::pos")~=nil then local gF=false;local sV="0-Temp"if sZ==nil or sZ==""then sZ=sY;gF=true end;K=string.find(sZ,"::")if not gF then sV=string.sub(sZ,1,K-2)end;local fD=string.sub(sZ,K)sU(sV,fD,gF)elseif sY=="/agg"then if sZ==nil or sZ==""then c0="Usage: /agg targetheight"return end;sZ=dt(sZ)if sZ<1000 then sZ=1000 end;bq=sZ;c0="AGG Target Height set to "..sZ elseif sY=="/G"then if sZ==nil or sZ==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sZ=="dump"then for dR,dD in pairs(ir())do if type(dD.get())=="boolean"then if dD.get()==true then a.print(dR.." true")else a.print(dR.." false")end elseif dD.get()==nil then a.print(dR.." nil")else a.print(dR.." "..dD.get())end end;return end;K=string.find(sZ," ")local t4=string.sub(sZ,0,K-1)local t5=string.sub(sZ,K+1)for dR,dD in pairs(ir())do if dR==t4 then c0="Variable "..t4 .." changed to "..t5;local t6=type(dD.get())if t6=="number"then t5=dt(t5)if dR=="AtmoSpeedLimit"then cK=t5 end elseif t6=="boolean"then if string.lower(t5)=="true"then t5=true else t5=false end end;dD.set(t5)return end end;c0="No such global variable: "..t4 elseif sY=="/deletewp"then if bg>0 and gb~=nil then cB.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif sY=="/copydatabank"then if dbHud_2 then pA(true)else c0="Spare Databank required to copy databank"end elseif sY=="/iphWP"then if bg>0 then a.print(cC.showWayPoint(c4,bf,true))a.print(json.encode(bf))c0="::pos waypoint shown in lua chat in local and world format"else c0="No target selected in IPH"end elseif sY=="/createPrivate"then if#dn>0 then local t7="privatelocations = {"for dR,dD in pairs(dn)do t7=t7 .."{position = {x = "..dD.position.x..", y = "..dD.position.y..", z = "..dD.position.z.."}, ".."name = '"..dD.name.."', planetname = '"..dD.planetname.."', gravity = "..dD.gravity..", save = "if dD.safe then t7=t7 .."true},"else t7=t7 .."false},"end end;t7=t7 .."} return privatelocations"a.logInfo("PRIVATELOCATIONS:"..t7)if screenHud_1 then screenHud_1.setHTML(t7)end;c0="privatelocations.lua created in logfile and on attached screen if present"else c0="No private locations to save"end end end;function sl.tagTick()if bx=="Off"then bx="All"elseif bx=="All"then bx="Longitude"elseif bx=="Longitude"then bx="Lateral"elseif bx=="Lateral"then bx="Vertical"else bx="Off"end;c0="Extra Engine Tags: "..bx;c.stopTimer("tagTick")end;return sl end;local function t8(d,b,c,a,library,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ih,gyro,warpdrive,ii,screenHud_1)local t9={}local dr=string.format;local ij=json.decode;local ta=json.encode;local pt=b.getElementMaxHitPointsById;local ik=b.getElementMassById;local il=d.control.isRemoteControlled;local eb=string.match;local gP=a.destroyWidgetPanel;local f_=a.updateData;local g0=a.addDataToWidget;local sk=a.lockView;local io=a.isViewLocked;local du=math.sqrt;local dt=tonumber;local f5=math.abs;local bE=math.floor;local bF=c.getAtmosphereDensity;local f0=math.atan;local bD=a.getTime;local ds=utils.clamp;local im=d.axisCommandManager;local tb=Y;local gR=13;local iu=b.getElementIdList()local iv=0;local function dv(eJ,eK)if eJ==0 then return f5(eK)<1e-09 end;if eK==0 then return f5(eJ)<1e-09 end;return f5(eJ-eK)<math.max(f5(eJ),f5(eK))*dI end;local function ip(dJ,tc)local se=10^(tc or 0)return bE(dJ*se+0.5)/se end;local function iq(td,te)for dR,dD in pairs(te)do if type(dR)=="string"then td[dR]=dD else td[#td+1]=te[dR]end end;return td end;local function ir(tf)local tg={}if not tf then iq(tg,J)iq(tg,a7)iq(tg,ay)iq(tg,aT)return tg elseif tf=="boolean"then return J elseif tf=="handling"then return a7 elseif tf=="hud"then return ay elseif tf=="physics"then return aT end end;local function pA(th)local function ti(tj)for dR,dD in pairs(tj)do dbHud_1.setStringValue(dR,ta(dD.get()))if th and dbHud_2 then dbHud_2.setStringValue(dR,ta(dD.get()))end end end;if dbHud_1 then ti(bA)ti(ir())a.print("Saved Variables to Datacore")if th and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function g1(tk,tl,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..tk.."|"..tl.."|"..ax)else a.logInfo("sound_notification|audiopacks/"..h.."/"..tk.."|"..tl.."|"..ax)end else a.logInfo("sound_q|audiopacks/"..h.."/"..tk.."|"..tl.."|"..ax)end end;local function gQ(hq,hr,sc,jy,tm)if jy==nil then jy=""end;if tm==nil then tm=""end;return dr([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jy,hq,hr,tm,sc)end;local function is(cb,tn)local to=cb>100000;if tn==nil then tn=1 end;if to then return ip(cb/1000/200,tn).."SU"elseif cb<1000 then return ip(cb,tn).."M"else return ip(cb/1000,tn).."KM"end end;local function it(tp)local tq=0;local tr=0;local ts=0;if tp<60 then tp=bE(tp)elseif tp<3600 then tq=bE(tp/60)tp=bE(tp%60)elseif tp<86400 then tr=bE(tp/3600)tq=bE(tp%3600/60)else ts=bE(tp/86400)tr=bE(tp%86400/3600)end;if ts>0 then return ts.."d "..tr.."h "elseif tr>0 then return tr.."h "..tq.."m "elseif tq>0 then return tq.."m "..tp.."s"elseif tp>0 then return tp.."s"else return"0s"end end;function t9.onStart()local tt=false;local function tu()local function tv(tw)local tx=dbHud_1.hasKey;for dR,dD in pairs(tw)do if tx(dR)then local dM=ij(dbHud_1.getStringValue(dR))if dM~=nil then dD.set(dM)tt=true end end end end;if dbHud_1 then if not f then tv(ir())coroutine.yield()tv(bA)else tv(bA)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ca=5;tt=false end;coroutine.yield()if tt then c0="Loaded Saved Variables"cq=a8;cr=a9;aU=j;g=string.lower(g)cH=p;cK=U;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]elseif not f then c0="No Saved Variables Found - Exit HUD to save settings"end;if by<1.500 then if T<2000 then c0="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;by=VERSION_NUMBER;if#bk>0 then dp=iq(dp,bk)end else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if br+180<bG then bp=0 end;br=bG;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ca=7 end;if antigrav and not q then if bq==nil then bq=cj end;antigrav.setBaseAltitude(bq)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then dn=require("autoconf/custom/archhud/privatelocations")if#dn>0 then dp=iq(dp,dn)end end;ls="Proceeding to Waypoint"end;local function ty()local function tz(tA,tB)if tA>tB then tB=tA end;local tC,tD=0,0;if a5>0 then tC=a5*0.05 end;if a6>0 then tD=a6*0.05 end;tB=tB*(1-(tC+tD))return tB end;local tE=b.getElementNameById;local tF=ap~=0 and aq~=0;for dR in pairs(iu)do local type=b.getElementTypeById(iu[dR])if eb(type,'^.*Atmospheric Engine$')then if eb(tostring(b.getElementTagsById(iu[dR])),'^.*vertical.*$')and b.getElementForwardById(iu[dR])[3]>0 then d0=true end end;if eb(type,'^.*Space Engine$')then cR=true;if eb(tostring(b.getElementTagsById(iu[dR])),'^.*vertical.*$')then local tG=b.getElementForwardById(iu[dR])if tG[3]<0 then tH=true else cQ=true end end end;if type=="Landing Gear"then bR=true end;if type=="Dynamic Core Unit"then local pv=pt(iu[dR])if pv>10000 then gR=110 elseif pv>1000 then gR=55 elseif pv>150 then gR=27 end end;iv=iv+pt(iu[dR])if tF and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pv=pt(iu[dR])local of=ik(iu[dR])local tA=0;local js=bD()if type=="Atmospheric Fuel Tank"then local tB=400;local tI=35.03;if pv>10000 then tB=51200;tI=5480 elseif pv>1300 then tB=6400;tI=988.67 elseif pv>150 then tB=1600;tI=182.67 end;tA=of-tI;if a2>0 then tB=tB+tB*a2*0.2 end;tB=tz(tA,tB)cs[#cs+1]={iu[dR],tE(iu[dR]),tB,tI,tA,js}end;if type=="Rocket Fuel Tank"then local tB=320;local tI=173.42;if pv>65000 then tB=40000;tI=25740 elseif pv>6000 then tB=5120;tI=4720 elseif pv>700 then tB=640;tI=886.72 end;tA=of-tI;if a4>0 then tB=tB+tB*a4*0.1 end;tB=tz(tA,tB)cu[#cu+1]={iu[dR],tE(iu[dR]),tB,tI,tA,js}end;if type=="Space Fuel Tank"then local tB=600;local tI=35.03;if pv>10000 then tB=76800;tI=5480 elseif pv>1300 then tB=9600;tI=988.67 elseif pv>150 then tB=2400;tI=182.67 end;tA=of-tI;if a3>0 then tB=tB+tB*a3*0.2 end;tB=tz(tA,tB)ct[#ct+1]={iu[dR],tE(iu[dR]),tB,tI,tA,js}end end end;if not d0 then b4,aV=false,false end end;local function tJ()if gyro~=nil then cn=gyro.getState()==1 end;if not bw then im:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then sk(1)else sk(0)end;if door and(ch or not ch and cj<10000)then for dW,dD in pairs(door)do dD.toggle()end end;if switch then for dW,dD in pairs(switch)do dD.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dW,dD in pairs(forcefield)do dD.toggle()end end;if antigrav then d1=antigrav.getState()==1;if d1 and not q then antigrav.show()end end;if il()==1 and k then a.freeze(1)else a.freeze(0)end;if bR then bh=d.control.isAnyLandingGearExtended()==1;if bh then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if cg~=-1 or not ch and cV:len()<50 then aW=true;bh=true;if bR then d.control.extendLandingGears()end else aW=false end;im:setTargetGroundAltitude(tb)if ch and cg~=-1 then cy=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;ph=ch end;local function tK()local tL={}local function tM()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tN={[1]=4480,[6]=4480,[7]=6270}for tO,tP in pairs(e)do e[tO][0]=tM()e[tO][0].systemId=tO;tL[tO]={}for tQ,iU in pairs(e[tO])do iU.gravity=iU.gravity/9.8;iU.center=vec3(iU.center)iU.name=iU.name[1]iU.noAtmosphericDensityAltitude=iU.atmosphereThickness or iU.atmosphereRadius-iU.radius;iU.spaceEngineMinAltitude=tN[iU.id]or 0.68377*(iU.atmosphereThickness or iU.atmosphereRadius-iU.radius)iU.planetarySystemId=tO;iU.bodyId=iU.id;tL[tO][tQ]=iU;if ml==nil or iU.center.x<ml then ml=iU.center.x end;if mk==nil or iU.center.x>mk then mk=iU.center.x end;if mo==nil or iU.center.y<mo then mo=iU.center.y end;if mn==nil or iU.center.y>mn then mn=iU.center.y end;if iU.center and iU.name~="Space"then di[#di+1]=iU end end end;el=dq(d,b,c,a,dr,ds,dt,du,dv)cw=el(tL)cx=f4(d,b,c,a,du,f5)cz=fz(d,b,c,a,dr,ds,dt,du,dv)cB=fZ(d,b,c,a,dbHud_1,e,f_,g0,bE,dt,du,g1)end;tR=false;tS=coroutine.create(function()im:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})tu()coroutine.yield()ty()coroutine.yield()cC=py(d,b,c,a,e,vBooster,hover,pz,antigrav,warpdrive,dbHud_1,f5,bE,bF,il,f0,bD,ds,im,f_,io,du,ip,g1,iq,dv,is,it,pA,ij,dr,g0)tJ()coroutine.yield()tK()cD=gO(b,a,c,library,radar_1,radar_2,f5,gP,du,gQ,dt,gR,g1)cA=ig(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ih,warpdrive,ii,f5,bE,dr,ij,bF,ik,il,f0,bD,ds,im,g0,f_,gP,io,du,ip,gQ,g1,iq,ir,is,it,iu,iv)cA.ButtonSetup()cE=sj(d,b,c,a,e,vBooster,hover,antigrav,ih,dbHud_2,gyro,screenHud_1,il,im,io,sk,gP,ip,eb,dt,ds,g1,ir,pA)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aO)c.setTimer("radarTick",aO)c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)g1("start","SU")end)coroutine.resume(tS)end;function t9.onUpdate()if not tR then local i5=coroutine.status(tS)if i5=="suspended"then local dS,i6=coroutine.resume(tS)if i6 then a.print("ERROR STARTUP: "..i6)end elseif i5=="dead"then tR=true end end;if tR then d:update()if ch and u and d3 then if d3 and bO then cC.cmdThrottle(0)bO=false elseif not d3 and not bO then bK=0;bO=true end end;if dl then im:setThrottleCommand(axisCommandId.longitudinal,dl)dl=nil end;if not cF and oX~=tT then a.setScreen(oX)end;tT=oX end end;function t9.onFlush()local function tU(tV,rl)local tW=vec3()local tX=vec3()if tV==axisCommandId.longitudinal then tW=vec3(b.getConstructOrientationForward())tX=cT elseif tV==axisCommandId.vertical then tW=vec3(b.getConstructOrientationUp())tX=cS elseif tV==axisCommandId.lateral then tW=vec3(b.getConstructOrientationRight())tX=cU else return vec3()end;local tY=vec3(b.getWorldGravity())local tZ=tY:dot(tX)local t_=vec3(b.getWorldAirFrictionAcceleration())local u0=t_:dot(tX)local u1=cV:dot(tW)local u2=rl*constants.kph2m;if u3==nil then u3=pid.new(10,0,10.0)end;u3:inject(u2-u1)local u4=u3:get()local u5=(u4-u0-tZ)*tX;return u5 end;local function u6(tV,rl)local tW=vec3()local tX=vec3()if tV==axisCommandId.longitudinal then tW=vec3(b.getConstructOrientationForward())tX=cT elseif tV==axisCommandId.vertical then tW=vec3(b.getConstructOrientationUp())tX=cS elseif tV==axisCommandId.lateral then tW=vec3(b.getConstructOrientationRight())tX=cU else return vec3()end;local tY=vec3(b.getWorldGravity())local tZ=tY:dot(tX)local t_=vec3(b.getWorldAirFrictionAcceleration())local u0=t_:dot(tX)local u1=cV:dot(tW)local u2=rl*constants.kph2m;if u7==nil then u7=pid.new(10,0,10.0)end;u7:inject(u2-u1)local u4=u7:get()local u5=(u4-u0-tZ)*tX;return u5 end;local function u8(u9,jH,g8)local ua=u9:cross(g8):normalize_inplace()local ks=math.acos(ds(ua:dot(-jH),-1,1))*constants.rad2deg;if ua:cross(-jH):dot(g8)<0 then ks=-ks end;return ks end;if antigrav and not q then if not d1 and antigrav.getBaseAltitude()~=bq then antigrav.setBaseAltitude(bq)end end;d3=im:getAxisCommandType(0)==axisCommandType.byThrottle;aJ=math.max(aJ,0.01)aK=math.max(aK,0.01)aE=math.max(aE,0.01)aI=math.max(aI,0.01)aL=math.max(aL,0.01)aM=math.max(aM,0.01)aD=math.max(aD,0.01)local ub=ds(bS+bT+a.getControlDeviceForwardInput(),-1,1)local uc=ds(bV+bY+a.getControlDeviceYawInput(),-1,1)local ud=ds(bW+bU-a.getControlDeviceLeftRightInput(),-1,1)local ue=bX;cY=vec3(b.getWorldVertical())if cY==nil or cY:len()==0 then cY=(iU.center-c_):normalize()end;cS=vec3(b.getConstructWorldOrientationUp())cT=vec3(b.getConstructWorldOrientationForward())cU=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getWorldVelocity())cV=vec3(b.getVelocity())c_=vec3(b.getConstructWorldPos())cl=b.getConstructMass()cX=vec3(cW):len()cZ=-cY:dot(cW)d5=getRoll(cY,cT,cU)local uf=d5/180*math.pi;local ug=math.cos(uf)local uh=math.sin(uf)d4=u8(cY,cT,cU*ug+cS*uh)local ui=cW:normalize()local uj=f5(d5)local uk=utils.sign(d5)local ul=vec3(b.getWorldAngularVelocity())local um=ub*aJ*cU+uc*aE*cT+ud*aK*cS;if cH==true and cY:len()>0.01 then local un=f5(cJ-d5)if((aY or b3 or b1 or cd or b0 or bu)and un>0 or ci>0.0 and un<aF and p)and uc==0 and f5(d4)<85 then local uo=cJ;local up=aD;if ci==0 then up=up/4;cJ=0;uo=0 end;if uq==nil then uq=pid.new(up*0.01,0,up*0.1)end;uq:inject(uo-d5)local ur=uq:get()um=um+ur*cT end end;local us=1;local ut=0;local uu=1;bL=0;if ch and u and d3 then if uv==nil then uv=pid.new(0.1,0,1)end;uv:inject(cK/3.6-cW:dot(cT))local uw=uv:get()bN=ds(uw,-1,1)if not dl then if bN<bK and ci>0.005 then bM=true;dl=ds(bN,0.01,1)else bM=false;dl=bK end end;if ux==nil then ux=pid.new(1*0.01,0,1*0.1)end;ux:inject(cW:len()-cK/3.6)local uy=ds(ux:get(),0,1)if ci>0 and cZ<-80 or ci>0.005 then bL=uy end;if bL>0 then if bM and bN==0.01 and not dl then dl=0 end else bN=ds(bN,0.01,1)end;local uz=''local uA=vec3()local uB=tU(axisCommandId.vertical,c7*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uB,ut)local uC='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then uC=uC..aQ end;local uD=im:getAxisCommandType(axisCommandId.longitudinal)local uE=im:composeAxisAccelerationFromThrottle(uC,axisCommandId.longitudinal)local uF=u6(axisCommandId.lateral,bt*1000)uz=uz..' , '.."lateral airfoil , lateral ground "uA=uA+uF;if uA:len()>constants.epsilon then d:setEngineForceCommand(uz,uA,ut,'','','',uu)end;d:setEngineForceCommand(uC,uE,us)local uG='thrust analog vertical fueled 'local uH='thrust analog lateral fueled 'if bx=="All"or bx=="Lateral"then uH=uH..aR end;if bx=="All"or bx=="Vertical"then uG=uG..aS end;if c7~=0 or b1 and aW or not bh and not bw then d:setEngineForceCommand(uG,uB,us)else d:setEngineForceCommand(uG,vec3(),us)end;if bt~=0 then d:setEngineForceCommand(uH,uF,us)else d:setEngineForceCommand(uH,vec3(),us)end;if ue==0 then ue=bL end;local uI=-ue*(aL*cW+aM*ui)d:setEngineForceCommand('brake',uI)else if u then if not dl then dl=bK end end;local rl=c.getAxisCommandValue(0)if not d3 then if ux==nil then ux=pid.new(1*0.01,0,1*0.1)end;ux:inject(cW:len()-rl/3.6)local uy=ds(ux:get(),0,1)ue=ds(ue+uy,0,1)end;local uI=-ue*(aL*cW+aM*ui)d:setEngineForceCommand('brake',uI)local uz=''local uA=vec3()local uJ=false;local uC='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then uC=uC..aQ end;local uD=im:getAxisCommandType(axisCommandId.longitudinal)if uD==axisCommandType.byThrottle then local uE=im:composeAxisAccelerationFromThrottle(uC,axisCommandId.longitudinal)d:setEngineForceCommand(uC,uE,us)elseif uD==axisCommandType.byTargetSpeed then local uE=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)uz=uz..' , '..uC;uA=uA+uE;if im:getTargetSpeed(axisCommandId.longitudinal)==0 or im:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-im:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then uJ=true end end;local uH='thrust analog lateral 'if bx=="All"or bx=="Lateral"then uH=uH..aR end;local uK=im:getAxisCommandType(axisCommandId.lateral)if uK==axisCommandType.byThrottle then local uL=im:composeAxisAccelerationFromThrottle(uH,axisCommandId.lateral)d:setEngineForceCommand(uH,uL,us)elseif uK==axisCommandType.byTargetSpeed then local uF=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)uz=uz..' , '..uH;uA=uA+uF end;local uG='thrust analog vertical 'if bx=="All"or bx=="Vertical"then uG=uG..aS end;local uM=im:getAxisCommandType(axisCommandId.vertical)if uM==axisCommandType.byThrottle then local uB=im:composeAxisAccelerationFromThrottle(uG,axisCommandId.vertical)if c7~=0 or b1 and aW then d:setEngineForceCommand(uG,uB,us,'airfoil','ground','',uu)else d:setEngineForceCommand(uG,vec3(),us)d:setEngineForceCommand('airfoil vertical',uB,us,'airfoil','','',uu)d:setEngineForceCommand('ground vertical',uB,us,'ground','','',uu)end elseif uM==axisCommandType.byTargetSpeed then if c7<0 then d:setEngineForceCommand('hover',vec3(),us)end;local uN=im:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)uz=uz..' , '..uG;uA=uA+uN end;if uA:len()>constants.epsilon then if bX~=0 or uJ or f5(ui:dot(cT))<0.5 then uz=uz..', brake'end;d:setEngineForceCommand(uz,uA,ut,'','','',uu)end end;local uO=aI*(um-ul)local uP=vec3(b.getWorldAirFrictionAngularAcceleration())uO=uO-uP;d:setEngineTorqueCommand('torque',uO,us,'airfoil','','',uu)d:setBoosterCommand('rocket_engine')if c1 and not n then local fx=cV:len()local uQ=0.15;if not d3 then local uR=im:getTargetSpeed(axisCommandId.longitudinal)if fx*3.6>uR*(1-uQ)and sP then sP=false;d:toggleBoosters()elseif fx*3.6<uR*(1-uQ)and not sP then sP=true;d:toggleBoosters()end else local p8=c.getThrottle()if u then p8=bK*100 end;local rl=p8/100;if bF==0 then rl=rl*_;if fx>=rl*(1-uQ)and sP then sP=false;d:toggleBoosters()elseif fx<rl*(1-uQ)and not sP then sP=true;d:toggleBoosters()end else local ry=bE(cK)rl=rl*ry/3.6;if fx>=rl*(1-uQ)and sP then sP=false;d:toggleBoosters()elseif fx<rl*(1-uQ)and not sP then sP=true;d:toggleBoosters()end end end end end;function t9.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dW,dD in pairs(door)do dD.toggle()end end;if switch then for dW,dD in pairs(switch)do dD.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dW,dD in pairs(forcefield)do dD.toggle()end end;x=dk;pA()if nR then nR.activate()end;if A then cC.showWayPoint(iU,c_)end;local ol=1-(a5*0.05+a6*0.05)a.print(cA.FuelUsed("atmofueltank")..", "..cA.FuelUsed("spacefueltank")..", "..cA.FuelUsed("rocketfueltank"))g1("stop","SU")end;function t9.controlStart(ss)cE.startControl(ss)end;function t9.controlStop(ss)cE.stopControl(ss)end;function t9.controlLoop(ss)cE.loopControl(ss)end;function t9.controlInput(sc)cE.inputTextControl(sc)end;function t9.radarEnter(e0)cD.onEnter(e0)end;function t9.radarLeave(e0)cD.onLeave(e0)end;function t9.onTick(uS)if uS=="tenthSecond"then cC.TenthTick()cA.TenthTick()elseif uS=="oneSecond"then cA.OneSecondTick()elseif uS=="fiveSecond"then cC.SatNavTick()elseif uS=="msgTick"then cA.MsgTick()elseif uS=="animateTick"then cA.AnimateTick()elseif uS=="hudTick"then cA.hudtick()elseif uS=="apTick"then cC.APTick()elseif uS=="radarTick"then cD.UpdateRadar()elseif uS=="tagTick"then cE.tagTick()elseif uS=="contact"then cD.ContactTick()end end;return t9 end;function script.onStart()uT.onStart()end;function script.onStop()uT.onStop()end;function script.onTick(uS)uT.onTick(uS)end;function script.onFlush()uT.onFlush()end;function script.onUpdate()uT.onUpdate()end;function script.onActionStart(ss)uT.controlStart(ss)end;function script.onActionStop(ss)uT.controlStop(ss)end;function script.onActionLoop(ss)uT.controlLoop(ss)end;function script.onInputText(sc)uT.controlInput(sc)end;function script.onEnter(e0)uT.radarEnter(e0)end;function script.onLeave(e0)uT.radarLeave(e0)end;bC(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uT=t8(d,b,c,a,library,e,vBooster,hover,pz,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ih,gyro,warpdrive,ii,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
