name: ArchHud - Archaegeo v0.716 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.716;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},SaveStartingLocation={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(L)a9=L end,get=function()return a9 end},ResolutionY={set=function(L)aa=L end,get=function()return aa end},circleRad={set=function(L)ab=L end,get=function()return ab end},SafeR={set=function(L)ac=L end,get=function()return ac end},SafeG={set=function(L)ad=L end,get=function()return ad end},SafeB={set=function(L)ae=L end,get=function()return ae end},PvPR={set=function(L)af=L end,get=function()return af end},PvPG={set=function(L)ag=L end,get=function()return ag end},PvPB={set=function(L)ah=L end,get=function()return ah end},centerX={set=function(L)ai=L end,get=function()return ai end},centerY={set=function(L)aj=L end,get=function()return aj end},throtPosX={set=function(L)ak=L end,get=function()return ak end},throtPosY={set=function(L)al=L end,get=function()return al end},vSpdMeterX={set=function(L)am=L end,get=function()return am end},vSpdMeterY={set=function(L)an=L end,get=function()return an end},altMeterX={set=function(L)ao=L end,get=function()return ao end},altMeterY={set=function(L)ap=L end,get=function()return ap end},fuelX={set=function(L)aq=L end,get=function()return aq end},fuelY={set=function(L)ar=L end,get=function()return ar end},shieldX={set=function(L)as=L end,get=function()return as end},shieldY={set=function(L)at=L end,get=function()return at end},DeadZone={set=function(L)au=L end,get=function()return au end},OrbitMapSize={set=function(L)av=L end,get=function()return av end},OrbitMapX={set=function(L)aw=L end,get=function()return aw end},OrbitMapY={set=function(L)ax=L end,get=function()return ax end},soundVolume={set=function(L)ay=L end,get=function()return ay end}}aA=5;aB=1;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR=0.0;aS="none"aT="none"aU="none"aV={speedChangeLarge={set=function(L)aA=L end,get=function()return aA end},speedChangeSmall={set=function(L)aB=L end,get=function()return aB end},MouseXSensitivity={set=function(L)aC=L end,get=function()return aC end},MouseYSensitivity={set=function(L)aD=L end,get=function()return aD end},autoRollFactor={set=function(L)aE=L end,get=function()return aE end},rollSpeedFactor={set=function(L)aF=L end,get=function()return aF end},autoRollRollThreshold={set=function(L)aG=L end,get=function()return aG end},minRollVelocity={set=function(L)aH=L end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(L)aI=L end,get=function()return aI end},torqueFactor={set=function(L)aJ=L end,get=function()return aJ end},pitchSpeedFactor={set=function(L)aK=L end,get=function()return aK end},yawSpeedFactor={set=function(L)aL=L end,get=function()return aL end},brakeSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeFlatFactor={set=function(L)aN=L end,get=function()return aN end},DampingMultiplier={set=function(L)aO=L end,get=function()return aO end},apTickRate={set=function(L)aP=L end,get=function()return aP end},hudTickRate={set=function(L)aQ=L end,get=function()return aQ end},ExtraEscapeThrust={set=function(L)aR=L end,get=function()return aR end},ExtraLongitudeTags={set=function(L)aS=L end,get=function()return aS end},ExtraLateralTags={set=function(L)aT=L end,get=function()return aT end},ExtraVerticalTags={set=function(L)aU=L end,get=function()return aU end}}aW=j;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=1000;b8=false;b9=false;ba=false;bb=false;bc=0;bd="Aligning"be=0;bf=1;bg="None"bh=nil;bi=0;bj=nil;bk=0.0;bl=0;bm={}bn=false;bo=0;bp=0;bq=nil;br=0;bs=1000;bt=0;bu=false;bv=0;bw=false;bx="All"by=true;bz="Off"bA=0.000;bB={}bC={VertTakeOff={set=function(L)b6=L end,get=function()return b6 end},VertTakeOffEngine={set=function(L)aX=L end,get=function()return aX end},SpaceTarget={set=function(L)bu=L end,get=function()return bu end},BrakeToggleStatus={set=function(L)aW=L end,get=function()return aW end},BrakeIsOn={set=function(L)aY=L end,get=function()return aY end},RetrogradeIsOn={set=function(L)aZ=L end,get=function()return aZ end},ProgradeIsOn={set=function(L)a_=L end,get=function()return a_ end},Autopilot={set=function(L)b0=L end,get=function()return b0 end},TurnBurn={set=function(L)b1=L end,get=function()return b1 end},AltitudeHold={set=function(L)b2=L end,get=function()return b2 end},BrakeLanding={set=function(L)b3=L end,get=function()return b3 end},Reentry={set=function(L)b5=L end,get=function()return b5 end},AutoTakeoff={set=function(L)b4=L end,get=function()return b4 end},HoldAltitude={set=function(L)b7=L end,get=function()return b7 end},AutopilotAccelerating={set=function(L)b8=L end,get=function()return b8 end},AutopilotBraking={set=function(L)ba=L end,get=function()return ba end},AutopilotCruising={set=function(L)bb=L end,get=function()return bb end},AutopilotRealigned={set=function(L)b9=L end,get=function()return b9 end},AutopilotEndSpeed={set=function(L)bc=L end,get=function()return bc end},AutopilotStatus={set=function(L)bd=L end,get=function()return bd end},AutopilotPlanetGravity={set=function(L)be=L end,get=function()return be end},PrevViewLock={set=function(L)bf=L end,get=function()return bf end},AutopilotTargetName={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetCoords={set=function(L)bh=L end,get=function()return bh end},AutopilotTargetIndex={set=function(L)bi=L end,get=function()return bi end},TotalDistanceTravelled={set=function(L)bk=L end,get=function()return bk end},TotalFlightTime={set=function(L)bl=L end,get=function()return bl end},SavedLocations={set=function(L)bm=L end,get=function()return bm end},VectorToTarget={set=function(L)bn=L end,get=function()return bn end},LocationIndex={set=function(L)bo=L end,get=function()return bo end},LastMaxBrake={set=function(L)bp=L end,get=function()return bp end},LockPitch={set=function(L)bq=L end,get=function()return bq end},LastMaxBrakeInAtmo={set=function(L)br=L end,get=function()return br end},AntigravTargetAltitude={set=function(L)bs=L end,get=function()return bs end},LastStartTime={set=function(L)bt=L end,get=function()return bt end},iphCondition={set=function(L)bx=L end,get=function()return bx end},stablized={set=function(L)by=L end,get=function()return by end},UseExtra={set=function(L)bz=L end,get=function()return bz end},SelectedTab={set=function(L)bD=L end,get=function()return bD end},saveRoute={set=function(L)bB=L end,get=function()return bB end}}local function bE(a,b,c,bF,bG,bH)bI=bF()bJ=0;bK=0;bL=false;bM=0;bN=false;bO=false;bP=0;bQ=0;bR=0;bS=0;bT=false;bU=false;bV="empty"bW=3;bX=false;bY=0;bZ=0;b_=nil;c0=0;c1=0;c2=0;c3=false;c4=false;c5=false;c6=-1;c7=bH()>0;c8=bH()c9=b.getAltitude()ca=b.getConstructMass()cb=nil;cc=a9;cd=aa;ce={}cf={}cg={}ch=nil;ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=false;cr=false;cs=p;ct=false;cu=V;cv=nil;cw=0;cx=false;cy=false;cz=false;cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cC=vec3(b.getVelocity())cD=vec3(b.getWorldVelocity())cE=vec3(cD):len()cF=vec3(b.getWorldVertical())cG=-cF:dot(cD)cH=vec3(b.getConstructWorldPos())cI=false;cJ=false;cK=true;cL=0;cM=0;cN={}cO=false;cP=50000;cQ=nil;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;cS=false;cT=nil;cU=false;cV=0;cW=nil;cX=nil;cY={}cZ=90;c_=x;d0=nil;d1=nil;d2={}d3={}d4=false;d5=nil end;local function d6(d,b,c,a,d7,d8,d9,da,db)local function dc(dd)return type(dd)=='number'end;local function de(dd)return type(d9(dd))=='number'end;local function df(dg)return type(dg)=='table'end;local function dh(a)return type(a)=='string'end;local function di(dj)return df(dj)and dc(dj.x and dj.y and dj.z)end;local function dk(dl)return df(dl)and dc(dl.latitude and dl.longitude and dl.altitude and dl.id and dl.systemId)end;local dm=math.pi/180;local dn=180/math.pi;local dp=1e-10;local dq=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr='::pos{'..dq..','..dq..','..dq..','..dq..','..dq..'}'local utils=utils;local vec3=vec3;local function ds(dd)local dt=string.gsub(string.reverse(d7('%.4f',dd)),'^0*%.?','')return dt==''and'0'or string.reverse(dt)end;local function du(dv)if di(dv)then return d7('{x=%.3f,y=%.3f,z=%.3f}',dv.x,dv.y,dv.z)end;if df(dv)and not getmetatable(dv)then local dw={}local dx=next(dv)if type(dx)=='nil'or dx==1 then dw=dv else for dy,dj in pairs(dv)do local dz=du(dj)if type(dy)=='number'then table.insert(dw,d7('[%s]=%s',dy,dz))else table.insert(dw,d7('%s=%s',dy,dz))end end end;return d7('{%s}',table.concat(dw,','))end;if dh(dv)then return d7("'%s'",dv:gsub("'",[[\']]))end;return tostring(dv)end;local dA={}dA.__index=dA;dA.__tostring=function(dv,dB)local dC={}for dy in pairs(dv)do table.insert(dC,dy)end;table.sort(dC)local dw={}for dD,dy in ipairs(dC)do local dz=du(dv[dy])if type(dy)=='number'then table.insert(dw,d7('[%s]=%s',dy,dz))else table.insert(dw,d7('%s=%s',dy,dz))end end;if dB then return d7('%s%s',dB,table.concat(dw,',\n'..dB))end;return d7('{%s}',table.concat(dw,','))end;dA.__eq=function(dE,dF)return dE.systemId==dF.systemId and dE.id==dF.id and db(dE.radius,dF.radius)and db(dE.center.x,dF.center.x)and db(dE.center.y,dF.center.y)and db(dE.center.z,dF.center.z)and db(dE.GM,dF.GM)end;local function dG(dH,dI,dJ,dK,dL)assert(de(dH),'Argument 1 (systemId) must be a number:'..type(dH))assert(de(dI),'Argument 2 (id) must be a number:'..type(dI))assert(de(dJ),'Argument 3 (radius) must be a number:'..type(dJ))assert(df(dK),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dK))assert(de(dL),'Argument 5 (GM) must be a number:'..type(dL))return setmetatable({systemId=d9(dH),id=d9(dI),radius=d9(dJ),center=vec3(dK),GM=d9(dL)},dA)end;local dM={}dM.__index=dM;dM.__tostring=function(dN)return d7('::pos{%d,%d,%s,%s,%s}',dN.systemId,dN.id,ds(dN.latitude*dn),ds(dN.longitude*dn),ds(dN.altitude))end;dM.__eq=function(dE,dF)return dE.id==dF.id and dE.systemId==dF.systemId and db(dE.latitude,dF.latitude)and db(dE.altitude,dF.altitude)and(db(dE.longitude,dF.longitude)or db(dE.latitude,math.pi/2)or db(dE.latitude,-math.pi/2))end;local function dO(dP,dI,dQ,dR,dS)local dH=dP;if dh(dP)and not dR and not dS and not dI and not dQ then dH,dI,dQ,dR,dS=dT(dP,dr)assert(dH,'Argument 1 (position string) is malformed.')else assert(de(dH),'Argument 1 (systemId) must be a number:'..type(dH))assert(de(dI),'Argument 2 (id) must be a number:'..type(dI))assert(de(dQ),'Argument 3 (latitude) must be in degrees:'..type(dQ))assert(de(dR),'Argument 4 (longitude) must be in degrees:'..type(dR))assert(de(dS),'Argument 5 (altitude) must be in meters:'..type(dS))end;dH=d9(dH)dI=d9(dI)dQ=d9(dQ)dR=d9(dR)dS=d9(dS)if dI==0 then return setmetatable({latitude=dQ,longitude=dR,altitude=dS,id=dI,systemId=dH},dM)end;return setmetatable({latitude=dm*d8(dQ,-90,90),longitude=dm*(dR%360),altitude=dS,id=dI,systemId=dH},dM)end;local dU={}dU.__index=dU;dU.__tostring=function(dv,dB)local dV=dB and dB..'  'local dW={}local dC={}for dy in pairs(dv)do table.insert(dC,dy)end;table.sort(dC)for dD,dX in ipairs(dC)do dY=dv[dX]local dZ=dA.__tostring(dY,dV)if dB then table.insert(dW,d7('[%s]={\n%s\n%s}',dX,dZ,dB))else table.insert(dW,d7('  [%s]=%s',dX,dZ))end end;if dB then return d7('\n%s%s%s',dB,table.concat(dW,',\n'..dB),dB)end;return d7('{\n%s\n}',table.concat(dW,',\n'))end;local function d_(e0)local e={}local pid;for dD,dj in pairs(e0)do local dI=dj.planetarySystemId;if type(dI)~='number'then error('Invalid planetary s ID: '..tostring(dI))elseif pid and dI~=pid then error('Mistringmatch planetary s IDs: '..dI..' and '..pid)end;local e1=dj.bodyId;if type(e1)~='number'then error('Invalid body ID: '..tostring(e1))elseif e[e1]then error('Duplicate body ID: '..tostring(e1))end;setmetatable(dj.center,getmetatable(vec3.unit_x))e[e1]=setmetatable(dj,dA)pid=dI end;return setmetatable(e,dU)end;e2={}local function e3(e0)return setmetatable({galaxyAtlas=e0 or{}},e2)end;e2.__index=function(dg,L)if type(L)=='number'then local a=dg.galaxyAtlas[L]return d_(a)end;return rawget(e2,L)end;e2.__pairs=function(dv)return function(dg,dy)local e4,e5=next(dg,dy)return e4,e5 and d_(e5)end,dv.galaxyAtlas,nil end;e2.__tostring=function(dv)local e6={}for dD,e7 in pairs(dv or{})do local e8=e7:getPlanetarySystemId()local e9=dU.__tostring(e7,'    ')table.insert(e6,d7('  [%s]={%s\n  }',e8,e9))end;return d7('{\n%s\n}\n',table.concat(e6,',\n'))end;e2.BodyParameters=dG;e2.MapPosition=dO;e2.PlanetarySystem=d_;function e2.createBodyParameters(dH,dI,ea,eb,ec,ed,ee)assert(de(dH),'Argument 1 (systemId) must be a number:'..type(dH))assert(de(dI),'Argument 2 (id) must be a number:'..type(dI))assert(de(ea),'Argument 3 (surfaceArea) must be a number:'..type(ea))assert(df(eb),'Argument 4 (aPosition) must be an array or vec3:'..type(eb))assert(df(ec),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ec))assert(de(ed),'Argument 6 (altitude) must be in meters:'..type(ed))assert(de(ee),'Argument 7 (gravityAtPosition) must be number:'..type(ee))local dJ=da(ea/4/math.pi)local c2=dJ+ed;local ef=vec3(eb)+c2*vec3(ec)local dL=ee*c2*c2;return dG(dH,dI,dJ,ef,dL)end;e2.isMapPosition=dk;function e2:getPlanetarySystem(dP)if L==nil then L=0 end;if e5==nil then e5=0 end;local dH=dP;if dk(dP)then dH=dP.systemId end;if type(dH)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(e5)~=dU then a=d_(a)end;return a end end end;function dU:sizeCalculator(eg)return 1.05*eg.radius end;function dU:castIntersections(eh,ei,ej,ek,el,em)local en={}if el then for dD,eg in pairs(el)do table.insert(en,eg)end else en=cY end;if not em then table.sort(en,function(eo,ep)local eq=eo.center;local er=ep.center;return(eq.x-eh.x)^2+(eq.y-eh.y)^2+(eq.z-eh.z)^2<(er.x-eh.x)^2+(er.y-eh.y)^2+(er.z-eh.z)^2 end)end;local es=ei:normalize()for dD,eg in ipairs(en)do local et=eg.center-eh;local dJ=self:sizeCalculator(eg)local eu=et:dot(es)local ev=eu^2-(et:len2()-dJ^2)if ev>=0 then local ew=da(ev)local ex=eu+ew;local ey=eu-ew;if ey>0 then return eg,ex,ey elseif ex>0 then return eg,ex,nil end end end;return nil,nil,nil end;function dU:closestBody(ez)assert(type(ez)=='table','Invalid coordinates.')local eA,eg;local eB=vec3(ez)for dD,eC in pairs(self)do local eD=(eC.center-eB):len2()if(not eg or eD<eA)and eC.name~="Space"then eg=eC;eA=eD end end;return eg end;function dU:convertToBodyIdAndWorldCoordinates(dP)local eE=dP;if dh(dP)then eE=dO(dP)end;if eE.id==0 then return 0,vec3(eE.latitude,eE.longitude,eE.altitude)end;local eC=self:getBodyParameters(eE)if eC then return eE.id,eC:convertToWorldCoordinates(eE)end end;function dU:getBodyParameters(dP)local dI=dP;if dk(dP)then dI=dP.id end;assert(de(dI),'Argument 1 (id) must be a number:'..type(dI))return self[dI]end;function dU:getPlanetarySystemId()local dD,dj=next(self)return dj and dj.systemId end;function dA:convertToMapPosition(dK)assert(df(dK),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dK))local eF=vec3(dK)if self.id==0 then return setmetatable({latitude=eF.x,longitude=eF.y,altitude=eF.z,id=0,systemId=self.systemId},dM)end;local eG=eF-self.center;local c2=eG:len()local dS=c2-self.radius;local dQ=0;local dR=0;if not db(c2,0)then local eH=eI(eG.y,eG.x)dR=eH>=0 and eH or 2*math.pi+eH;dQ=math.pi/2-math.acos(eG.z/c2)end;return setmetatable({latitude=dQ,longitude=dR,altitude=dS,id=self.id,systemId=self.systemId},dM)end;function dA:convertToWorldCoordinates(dP)local eE=dh(dP)and dO(dP)or dP;if eE.id==0 then return vec3(eE.latitude,eE.longitude,eE.altitude)end;assert(dk(eE),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eE.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eE.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eJ=math.cos(eE.latitude)return self.center+(self.radius+eE.altitude)*vec3(eJ*math.cos(eE.longitude),eJ*math.sin(eE.longitude),math.sin(eE.latitude))end;function dA:getAltitude(dK)return(vec3(dK)-self.center):len()-self.radius end;function dA:getDistance(dK)return(vec3(dK)-self.center):len()end;function dA:getGravity(dK)local eK=self.center-vec3(dK)local eL=eK:len2()return self.GM/eL*eK/da(eL)end;return setmetatable(e2,{__call=function(dD,...)return e3(...)end})end;local function eM(d,b,c,a,da,eN)local ci={}local eO=30000000/3600;local eP=eO*eO;local eQ=100;function ci.computeAccelerationTime(eR,eS,eT)local eU=eO*math.asin(eR/eO)return(eO*math.asin(eT/eO)-eU)/eS end;function ci.computeDistanceAndTime(eR,eT,eV,eW,eX,eY)eX=eX or 0;eY=eY or 0;local eZ=eR<=eT;local e_=eW*(eZ and 1 or-1)/eV;local f0=-eY/eV;local f1=e_+f0;if eZ and f1<=0 or not eZ and f1>=0 then return-1,-1 end;local f2,f3=0,0;if e_~=0 and eX>0 then local eU=math.asin(eR/eO)local f4=math.pi*(e_/2+f0)local f5=e_*eX;local f6=eO*math.pi;local dj=function(dg)local f7=(f4*dg-f5*math.sin(math.pi*dg/2/eX)+f6*eU)/f6;local f8=math.tan(f7)return eO*f8/da(f8*f8+1)end;local f9=eZ and function(a)return a>=eT end or function(a)return a<=eT end;f3=2*eX;if f9(dj(f3))then local fa=0;while eN(f3-fa)>0.5 do local dg=(f3+fa)/2;if f9(dj(dg))then f3=dg else fa=dg end end end;local fb=eR;local fc=f3/eQ;for fd=1,eQ do local fe=dj(fd*fc)f2=f2+(fe+fb)*fc/2;fb=fe end;if f3<2*eX then return f2,f3 end;eR=fb end;local eU=eO*math.asin(eR/eO)local bI=(eO*math.asin(eT/eO)-eU)/f1;local ff=eP*math.cos(eU/eO)/f1;local c2=ff-eP*math.cos((f1*bI+eU)/eO)/f1;return c2+f2,bI+f3 end;function ci.computeTravelTime(eR,eS,c2)if c2==0 then return 0 end;if eS>0 then local eU=eO*math.asin(eR/eO)local ff=eP*math.cos(eU/eO)/eS;return(eO*math.acos(eS*(ff-c2)/eP)-eU)/eS end;if eR==0 then return-1 end;assert(eR>0,'Acceleration and initial speed are both zero.')return c2/eR end;return ci end;local function fg(d,b,c,a,d7,d8,d9,da,db)local vec3=vec3;local d6=d6(d,b,c,a,d7,d8,d9,da,db)local function dh(a)return type(a)=='string'end;local function df(dg)return type(dg)=='table'end;fh={}fh.__index=fh;function fh:escapeAndOrbitalSpeed(dS)assert(self.body)local c2=dS+self.body.radius;if not db(c2,0)then local fi=da(self.body.GM/c2)return da(2)*fi,fi end;return nil,nil end;function fh:orbitalParameters(dP,fj)assert(self.body)assert(df(dP)or dh(dP))assert(df(fj))local fk=(dh(dP)or d6.isMapPosition(dP))and self.body:convertToWorldCoordinates(dP)or vec3(dP)local dj=vec3(fj)local fl=fk-self.body.center;local fm=dj:len2()local fn=fl:len()local fo=self.body.GM;local fp=((fm-fo/fn)*fl-fl:dot(dj)*dj)/fo;local eq=fo/(2*fo/fn-fm)local fq=fp:len()local es=fp:normalize()local fr=eq*(1-fq)local fs=eq*(1+fq)local ft=fr*es+self.body.center;local fu=fq<=1 and-fs*es+self.body.center or nil;local fv=da(eq*fo*(1-fq*fq))local fw=fu and 2*math.pi*da(eq^3/fo)local fx=math.acos(fp:dot(fl)/(fq*fn))if fl:dot(dj)<0 then fx=-(fx-2*math.pi)end;local fy=math.acos((math.cos(fx)+fq)/(1+fq*math.cos(fx)))local fz=fy;if fz<0 then fz=fz+2*math.pi end;local fA=fz-fq*math.sin(fz)local fB=0;local fC=0;local fD=0;if fw~=nil then fB=fA/(2*math.pi/fw)fC=fw-fB;fD=fC+fw/2;if fx-math.pi>0 then fC=fB;fD=fC+fw/2 end;if fD>fw then fD=fD-fw end end;return{periapsis={position=ft,speed=fv/fr,circularOrbitSpeed=da(fo/fr),altitude=fr-self.body.radius},apoapsis=fu and{position=fu,speed=fv/fs,circularOrbitSpeed=da(fo/fs),altitude=fs-self.body.radius},currentVelocity=dj,currentPosition=fk,eccentricity=fq,period=fw,eccentricAnomaly=fy,meanAnomaly=fA,timeToPeriapsis=fC,timeToApoapsis=fD,trueAnomaly=fx}end;local function fE(fF)local eC=d6.BodyParameters(fF.systemId,fF.id,fF.radius,fF.center,fF.GM)return setmetatable({body=eC},fh)end;return setmetatable(fh,{__call=function(dD,...)return fE(...)end})end;local function fG(d,b,c,a,dbHud_1,e,fH,fI,bG,d9,da,fJ)local function fK(fL)local dN=fM:closestBody(fL)if(fL-dN.center):len()>dN.radius+dN.noAtmosphericDensityAltitude then dN=e[0][0]end;return dN end;local function fN()local function fO(fP,fQ)return fP.name<fQ.name end;cN={}for dy,dj in pairs(e[0])do cN[#cN+1]={name=dj.name,index=dy}end;table.sort(cN,fO)end;local function fR(fS,fT)if not fT then fT=fU.name end;for dy,dj in pairs(fS)do if dj.name and dj.name==fT then return dy end end;return-1 end;local function fV()cV=bi;if bi==0 then bg="None"b_=nil;fU=nil;return true end;local fW=cN[bi].index;local fX=e[0][fW]if fX.center then bg=fX.name;b_=ch[0][fW]if fU~=nil then if c8==0 then if fH(fY,fZ)~=1 then fI(fY,fZ)end;if fH(f_,g0)~=1 then fI(f_,g0)end;if fH(g1,g2)~=1 then fI(g1,g2)end;if fH(g3,g4)~=1 then fI(g3,g4)end;if fH(g5,g6)~=1 then fI(g5,g6)end end;if fH(g7,g8)~=1 then fI(g7,g8)end;if fH(g9,ga)~=1 then fI(g9,ga)end;if fH(gb,gc)~=1 then fI(gb,gc)end end;fU=nil else fU=fX;for dD,dj in pairs(ch[0])do if dj.name==fU.planetname then b_=dj;bg=fU.name;break end end;if fH(g7,g8)~=1 then fI(g7,g8)end;if fH(g9,ga)~=1 then fI(g9,ga)end end;if fU==nil then bh=vec3(b_.center)else bh=fU.position end;if b_.planetname~="Space"then if b_.hasAtmosphere then gd=bG(b_.radius*(T-1)+b_.noAtmosphericDensityAltitude)else gd=bG(b_.radius*(T-1)+b_.surfaceMaxAltitude)end else gd=S end;if fU~=nil and fU.planetname=="Space"then bc=0 else dD,bc=ck(b_):escapeAndOrbitalSpeed(gd)end;be=0;b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"return true end;local function ge(gf)if not b0 and not bn and not c4 and not bw and not b5 and not c5 then if gf==nil then bi=bi+1;if bi>#cN then bi=0 end else bi=bi-1;if bi<0 then bi=#cN end end;if bi==0 then fV()else local fW=cN[bi].index;local fX=e[0][fW]if fX and(fX~=nil and fX.name=="Space"or bx=="Custom Only"and fX.center or bx=="No Moons"and string.find(fX.name,"Moon")~=nil)then if gf==nil then ge()else ge(1)end else fV()end end else bV="Disengage autopilot before changing Interplanetary Helper"fJ("iph","AP")end end;local function gg()local function gh(gi)local gj;if gi then gj=d2 else gj=bm end;local gk=-1;gk=fR(e[0])if gk>-1 then table.remove(e[0],gk)end;gk=-1;gk=fR(gj)if gk~=-1 then bV=fU.name.." saved location cleared"table.remove(gj,gk)end;ge()fN()return gj end;if string.sub(bg,1,1)=="*"then d2=gh(true)else bm=gh(false)end end;local function gl(gm,fL,gn,go)local function gp(gi)if gi then gj=d2 else gj=bm end;if dbHud_1 or gn or gi then local dN=fK(fL)local gq=dN.gravity;if go then gq=c.getClosestPlanetInfluence()end;local gr={position=fL,name=gm,planetname=dN.name,gravity=gq,safe=go}if not gn then gj[#gj+1]=gr else for dy,dj in pairs(e[0])do if dj.name and gm==dj.name then table.remove(e[0],dy)end end end;table.insert(e[0],gr)fN()fV()bV="Location saved as "..gm.."("..dN.name..")"return gj else bV="Databank must be installed to save permanent locations"end end;if string.sub(gm,1,1)=="*"then d2=gp(true)else bm=gp(false)end end;local gs={}function gs.UpdateAtlasLocationsList()fN()end;function gs.UpdateAutopilotTarget()fV()end;function gs.adjustAutopilotTargetIndex(gf)ge(gf)end;function gs.findAtlasIndex(fS,fT)return fR(fS,fT)end;function gs.UpdatePosition(gt,gu)local function gv(gi)local gj;if gi then gj=d2 else gj=bm end;local gk=fR(gj)if gk~=-1 then if gt~=nil then if gi then gt="*"..gt end;gj[gk].name=gt;bi=bi-1;ge()else local gw=gj[gk]if gu then gw.heading=cB:cross(cF)*5000;bV=gj[gk].name.." heading saved ("..gj[gk].planetname..")"return elseif gu==false then gw.heading=nil;bV=gj[gk].name.." heading cleared ("..gj[gk].planetname..")"return end;gw.gravity=c.getClosestPlanetInfluence()gw.position=cH;gw.safe=true end;bV=gj[gk].name.." position updated ("..gj[gk].planetname..")"else bV="Name Not Found"end end;if string.sub(bg,1,1)=="*"then gv(true)else gv(false)end end;function gs.AddNewLocation(gm,fL,gn,go)gl(gm,fL,gn,go)end;function gs.ClearCurrentPosition()gg()end;for dy,dj in pairs(d3)do table.insert(e[0],dj)end;fN()if bi>#cN then bi=0 end;gs.UpdateAutopilotTarget()return gs end;local function gx(b,a,c,library,radar_1,radar_2,eN,gy,da,gz,d9,gA,fJ)local gB={}local gC={}local gD={XS=13,S=27,M=55,L=110,XL=221}local gE={}local gF;local gG;local gH;local gI;local gJ;local gK={}local gL="Atmo"local gM;local gN;local gO=0;local gP={}local function gQ()local function gR(gS,gT,gU,gV,gW,gX,gY,gZ)gT,gV,gX,gZ=vec3(gT),vec3(gV),vec3(gX),vec3(gZ)local g_,h0,h1=gS*gS,gU*gU,gW*gW;local fm=gV-gT;local h2=fm:normalize()local h3=fm:len()local h4=gX-gT;local h5=(h4-h4:project_on(h2)):normalize()local h6,h7=h4:dot(h2),h4:dot(h5)local h8=h6*h6+h7*h7;local h9=h2:cross(h5)local ha=(g_-h0+h3*h3)/(2*h3)local hb=(g_-h1+h8-2*h6*ha)/(2*h7)local dl=g_-ha^2-hb^2;local hc=da(dl)local hd=gT+h2*ha+h5*hb+h9*hc;local he=gT+h2*ha+h5*hb-h9*hc;if eN((gZ-hd):len()-gY)<eN((gZ-he):len()-gY)then return hd else return he end end;local function hf()local function hg()local hh=b.getConstructWorldOrientationRight()local fm=b.getConstructWorldOrientationForward()local h4=b.getConstructWorldOrientationUp()local hi=library.systemResolution3(hh,fm,h4,{1,0,0})local hj=library.systemResolution3(hh,fm,h4,{0,1,0})local hk=library.systemResolution3(hh,fm,h4,{0,0,1})return function(hl)return library.systemResolution3(hi,hj,hk,hl)end end;local hm=hg()local hn=b.getConstructWorldPos()local fk=b.getElementPositionById(1)local ho={fk[1],fk[2],fk[3]}local hp=hm(ho)local hq={hn[1]-hp[1],hn[2]-hp[2],hn[3]-hp[3]}return hq end;local function hr(hs,fn,ht)local hu=hs.pts;local gk=#hu;local hv=hs.ref;if gk>3 then local hw,hx,hy,hz=hu[gk],hu[gk-1],hu[gk-2],hu[gk-3]hs.ref=ht;local fk=gR(hw[1],hw[2],hx[1],hx[2],hy[1],hy[2],hz[1],hz[2])local ha,hb,hc=fk.x,fk.y,fk.z;if ha==ha and hb==hb and hc==hc then ha=ha+hv[1]hb=hb+hv[2]hc=hc+hv[3]local hA=vec3(ha,hb,hc)if not hs.lastPos then hs.center=hA elseif(hs.lastPos-hA):len()<2 then hs.center=hA;hs.skipCalc=true end;hs.lastPos=hA end;hs.pts={}else local hB={ht[1]-hv[1],ht[2]-hv[2],ht[3]-hv[3]}hu[gk+1]={fn,hB}end end;if radar_1 or radar_2 then co.assignRadar()end;if gK[1]then gF=#gK[1].getConstructIds()local hC=gK[1].getData()local hD=hC:gmatch('{"constructId[^}]*}[^}]*}')if gF>0 then local ht=hf()local hE,hF=0,0;gJ,gI=0,0;for dj in hD do local dI,c2,hG=dj:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gD[hG]c2=d9(c2)if gK[1].hasMatchingTransponder(dI)==1 then table.insert(gC,dI)end;local hI=gK[1].getConstructType(dI)if F then if hH>27 or hI=="static"or hI=="space"then gJ=gJ+1;local gm=gK[1].getConstructName(dI)local hs=gP[dI]if hs==nil then hH=hH+gA;gP[dI]={pts={},ref=ht,name=gm,i=0,radius=hH,skipCalc=false}hs=gP[dI]end;if not hs.skipCalc then hr(hs,c2,ht)hF=hF+1 end;if hs.center then table.insert(gE,hs)end end;hE=hE+1;if cR and hE>700 or hF>70 or(not cR and hE>300 or hF>30)then coroutine.yield()hE,hF=0,0 end end end;gI=#gE;if gI>0 and cE>20 then local eg,hJ,hK,hL;local hM=0;local hN=ch:getPlanetarySystem(0)hL=cD:normalize()while hM<gI do coroutine.yield()local hO={table.unpack(gE,hM,math.min(hM+75,gI))}eg,hJ,hK=hN:castIntersections(cH,hL,nil,nil,hO,true)if eg and hK then cT={eg,hJ,hK}break end;hM=hM+75 end;if not eg then cT=nil end else cT=nil end;gE={}gG=hC:find('identifiedConstructs":%[%]')else gH=hC:find('worksInEnvironment":false')end end end;local function hP()if gK[1]then gL="Atmo"if gK[1].getData():find('worksInAtmosphere":false')then gL="Space"end end end;function gB.pickType()hP()end;function gB.assignRadar()if radar_1 and gK[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gK[1]=radar_2 end;if gK[1]==radar_2 then hP()end elseif radar_2 and gK[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gK[1]=radar_1 end;if gK[1]==radar_1 then hP()end end end;function gB.UpdateRadar()local hQ=coroutine.status(gM)if hQ=="suspended"then local dz,hR=coroutine.resume(gM)if hR then a.print("ERROR UPDATE RADAR: "..hR)end elseif hQ=="dead"then gM=coroutine.create(gQ)local dz,hR=coroutine.resume(gM)end end;function gB.GetRadarHud(hS,hT,hU,hV)local hW=gC;local hX,hY;gC={}local dq=gI or 0;if gF>0 then if F then hY=dq.."/"..gJ.." Plotted : "..gF-gJ.." Ignored"else hY="Radar Contacts: "..gF end;hX=gz(hU,hV,hY,"pbright txtbig txtmid")if#gC>0 then hX=hX..gz(hS,hT,"Friendlies In Range","pbright txtbig txtmid")for dy,dj in pairs(gC)do hT=hT+20;hX=hX..gz(hS,hT,gK[1].getConstructName(dj),"pdim txtmid")end end;if gG==nil and gN==nil then gO=1;co.ToggleRadarPanel()end;if gG~=nil and gN~=nil then co.ToggleRadarPanel()end;if d1==nil then co.ToggleRadarPanel()end else if gH then hX=gz(hU,hV,gL.." Radar: Jammed","pbright txtbig txtmid")else hX=gz(hU,hV,"Radar: No "..gL.." Contacts","pbright txtbig txtmid")end;if d1~=nil then gO=0;co.ToggleRadarPanel()end end;return hX end;function gB.GetClosestName(gm)if gK[1]then local dI,dD=gK[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dI~=nil and dI~=""then gm=gm.." "..gK[1].getConstructName(dI)end end;return gm end;function gB.ToggleRadarPanel()if d1~=nil and gO==0 then gy(d1)d1=nil;if gN~=nil then gy(gN)gN=nil end else if gO==1 then gy(d1)d1=nil;_autoconf.displayCategoryPanel(gK,1,"Periscope","periscope")gN=_autoconf.panels[_autoconf.panels_size]end;if d1==nil then _autoconf.displayCategoryPanel(gK,1,"Radar","radar")d1=_autoconf.panels[_autoconf.panels_size]end;gO=0 end end;function gB.ContactTick()if not hZ then hZ=0 end;if bI>hZ+10 then bV="Radar Contact"fJ("rdrCon","RC")hZ=bI end;c.stopTimer("contact")end;function gB.onEnter(dI)if radar_1 and not c7 and not cO then c.setTimer("contact",0.1)end end;function gB.onLeave(dI)if radar_1 and F then if#gP>650 then dI=tostring(dI)gP[dI]=nil end end end;gK[1]=nil;if radar_1 then gK[1]=radar_1;hP()end;gM=coroutine.create(gQ)return gB end;local function h_(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i0,warpdrive,i1,eN,bG,d7,i2,bH,i3,i4,eI,bF,d8,i5,fI,fH,gy,i6,da,i7,gz,fJ,i8,i9,ia,ib,ic,id)local ie=9.80665;local ig={}local ih={}local ii={}local ij={}local ik=nil;local il=nil;local im=nil;local io=false;local ip="none"local iq=""local ir=55;local is=0;local it=0;local iu=""local iv=nil;local iw=ac;local ix=ad;local iy=ae;local iz=[[rgb(]]..bG(iw+0.5)..","..bG(ix+0.5)..","..bG(iy+0.5)..[[)]]local iA=[[rgb(]]..bG(iw*0.9+0.5)..","..bG(ix*0.9+0.5)..","..bG(iy*0.9+0.5)..[[)]]local iB=0;local iC=0;local iD=""local iE=bF()local iF=false;local iG=vec3({13771471,7435803,-128971})local iH=18000000;local iI=500000;local iJ,iK=math.huge;local iL;local function iM(iN)iJ=vec3(iN):dist(iG)if iJ<iH then return true,eN(iJ-iH)end;iK=vec3(iN):dist(vec3(iO.center))if iK<iI then iL=true else iL=false end;if eN(iK-iI)<eN(iJ-iH)then return iL,eN(iK-iI)else return iL,eN(iJ-iH)end end;local function iP(dj)if cc==1920 then return dj else return i7(cc*dj/1920,0)end end;local function iQ(dj)if cd==1080 then return dj else return i7(cd*dj/1080,0)end end;local function iR()return i6()==0 and g~="keyboard"and i4()==0 end;local function iS()local iT="TRAVEL"if not cK then iT="CRUISE"end;if b0 then iT="AUTOPILOT"end;return iT end;local hX=""local iU=""local iV=""local iW=1;local iX=2;local iY=3;local iZ=4;local i_=5;local j0=6;local j1=""local j2=0;local j3=bG(1/aP)*2*aQ;local j4={}local j5={}local j6={}local j7={}local j8={}local j9={}local ja={}ja["atmofueltank"],ja["spacefueltank"],ja["rocketfueltank"]=0,0,0;local jb=0;local function jc(ha,jd,je,jf,jg,jh)local ji=jb;local jj=jb+5;if not C then jj=jj+5 end;if i4()==1 and not l then ji=ji-50;jj=jj-50 end;if je=="ATMO"then j1="atmofueltank"elseif je=="SPACE"then j1="spacefueltank"else j1="rocketfueltank"end;j2=_G[j1 .."_size"]if#jf>0 then for L=1,#jf do local gm=string.sub(jf[L][iX],1,12)local jk=0;for jl=1,j2 do if jf[L][iX]==i2(c[j1 .."_"..jl].getData()).name then jk=jl;break end end;local jm=bF()if jg[L]==nil or jh[L]==nil or jm-jf[L][j0]>j3 then local jn;local jo=0;jo=i3(jf[L][iW])-jf[L][iZ]jn=jf[L][i_]if jn>jo then ja[j1]=ja[j1]+jn-jo end;if jk~=0 then jh[L]=i2(c[j1 .."_"..jk].getData()).percentage;jg[L]=i2(c[j1 .."_"..jk].getData()).timeLeft;if jg[L]=="n/a"then jg[L]=0 end else jh[L]=bG(0.5+jo*100/jf[L][iY])if jn<=jo then jg[L]=0 else jg[L]=bG(0.5+jo/((jn-jo)/(jm-jf[L][j0])))end end;jf[L][j0]=jm;jf[L][i_]=jo end;if gm==jd then gm=d7("%s %d",je,L)end;if jk==0 then gm=gm.." *"end;local jp;if jg[L]==0 then jp=""else jp=ib(jg[L])end;if jh[L]~=nil then local jq=bG(jh[L]*2.55)local jr=d7("rgb(%d,%d,%d)",255-jq,jq,0)local js=""if jp~=""and jg[L]<120 or jh[L]<5 then js="red "end;local jt=d7("rgb(%d,%d,%d)",d8(bG((255-jq)/2.55),50,100),d8(bG(jq/2.55),0,50),50)local ju="rgb(196,0,255)"if je=="ATMO"then ju="rgb(0,188,255)"elseif je=="SPACE"then ju="rgb(239,255,0)"end;local jv=false;if jw~=ju then jv=true end;jw=ju;if C then if jv then ji=ji-5;jj=jj-5 end;iU=iU..d7([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jt,ju,ha,jj,jr,bG(jh[L]*1.7+0.5)-2,ha+1,jj+1,ha+5,jj+14,gm,jh[L],jp)ji=ji-22;jj=jj-22 else iU=iU..gz(ha,ji,gm,js.."pdim txtfuel")iU=iU..gz(ha,jj,d7("%d%% %s",jh[L],jp),"pdim txtfuel","fill:"..jr)ji=ji+30;jj=jj+30 end end end end;jb=ji end;local function jx(jy,dS)if am==0 and an==0 then return end;if dS<200000 and not c7 or dS and c7 then local jz=0;if eN(cG)>1 then jz=45*math.log(eN(cG),10)if cG<0 then jz=-jz end end;jy[#jy+1]=d7([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bG(cG),bG(jz))end;return jy end;local function jA(jB)local gf=-cF;jB=jB-jB:project_on(gf)local jC=vec3(0,0,1)jC=jC-jC:project_on(gf)local jD=jC:cross(gf)local jz=jC:angle_between(jB)*constants.rad2deg;if jB:dot(jD)<0 then jz=360-jz end;return jz end;local function jE(jy,ai,aj,jF,jG,cR)if ab==0 then return end;local jH=ab;local jI=20;local jJ=bG(jF)if cR then for L=-45,45,5 do local jK=L;jy[#jy+1]=d7([[<g transform="rotate(%f,%d,%d)">]],jK,ai,aj)jL=5;if L%15==0 then jL=15 elseif L%10==0 then jL=10 end;jy[#jy+1]=d7([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jH+jI-jL,ai,aj+jH+jI)end;jy[#jy+1]=gz(ai,aj+jH+jI-35,jG,"pdim txt txtmid")jy[#jy+1]=gz(ai,aj+jH+jI-25,jJ.." deg","pdim txt txtmid")jy[#jy+1]=d7([[<g transform="rotate(%f,%d,%d)">]],-jF,ai,aj)jy[#jy+1]=d7([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jH+jI-20,ai+5,aj+jH+jI-20,ai,aj+jH+jI-15)jy[#jy+1]="</g>"end;jy[#jy+1]=[[<g style="clip-path: url(#headingClip);">]]local jM=jJ;if cR then jM=jA(cA)end;local jN=20;local jO=bG(jM)local jP=0;local jQ=aj+jH+jI+20;local jR=ai;if jG~="YAW"then jQ=iQ(130)jR=iP(960)end;local jS=[[<path class="txttick line" d="]]local jT=bG(jO-(jN+10)-jO%5+0.5)for L=jT+70,jT,-5 do local ha=jR-(-L*5+jM*5)if L%10==0 then jP=10;local dq=L;if dq==360 then dq=0 elseif dq>360 then dq=dq-360 elseif dq<0 then dq=dq+360 end;jy[#jy+1]=gz(ha,jQ+15,dq,"txtmid bright")elseif L%5==0 then jP=5 end;if jP==10 then jS=d7([[%s M %f %f v %d]],jS,ha,jQ-5,jP)else jS=d7([[%s M %f %f v %d]],jS,ha,jQ-2.5,jP)end end;jy[#jy+1]=jS..[["/>]]jy[#jy+1]=d7([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jR-5,jQ-20,jR+5,jQ-20,jR,jQ-10)if I then if cR then jG="HDG"end;jy[#jy+1]=gz(iP(960),iQ(100),jO.."°","dim txt txtmid size14","")jy[#jy+1]=gz(iP(960),iQ(85),jG,"dim txt txtmid size20","")end;jy[#jy+1]=[[</g>]]end;local function jU(jy,jV,jF,ai,aj,cR,jW,fe)if ab==0 then return end;local jH=ab;local jX=bG(jH*3/5)if jH>0 then local jY=bG(jV)local jL=0;local jS=d7([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jF,ai,aj)if not c7 then jS=d7([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jy[#jy+1]=d7([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jH-1,ai,aj)jy[#jy+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bG(jY-30-jY%5+0.5),bG(jY+30+jY%5+0.5),5 do if L%10==0 then jL=30 elseif L%5==0 then jL=20 end;local hb=aj+-L*5+jV*5;if jL==30 then jS=d7([[%s M %d %f h %d]],jS,ai-jX-jL,hb,jL)if c7 then jy[#jy+1]=d7([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jF,ai,aj,ai-jX+10,hb+4,L)jy[#jy+1]=d7([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jF,ai,aj,ai+jX-10,hb+4,L)if L==0 or L==180 or L==-180 then jy[#jy+1]=d7([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jF,ai,aj,ai-jX+20,hb,jX*2-40)end else jy[#jy+1]=gz(ai-jX+10,hb,L,"pdim txt txtmid")jy[#jy+1]=gz(ai+jX-10,hb,L,"pdim txt txtmid")end;jS=d7([[%s M %d %f h %d]],jS,ai+jX,hb,jL)else jS=d7([[%s M %d %f h %d]],jS,ai-jX-jL,hb,jL)jS=d7([[%s M %d %f h %d]],jS,ai+jX,hb,jL)end end;jy[#jy+1]=jS..[["/>]]local jZ="PITCH"if not cR then jZ="REL PITCH"end;if jV>90 and not c7 then jV=90-(jV-90)elseif jV<-90 and not c7 then jV=-90-(jV+90)end;if jH>200 then if c7 then if fe>ir then jy[#jy+1]=gz(ai,aj-15,"Yaw","pdim txt txtmid")jy[#jy+1]=gz(ai,aj+20,jW,"pdim txt txtmid")end;jy[#jy+1]=d7([[<g transform="rotate(%f,%d,%d)">]],-jF,ai,aj)else jy[#jy+1]=d7([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jy[#jy+1]=d7([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-jX+25,aj-5,ai-jX+20,aj,ai-jX+25,aj+5,ai-jX+50,aj+4,jY)jy[#jy+1]=d7([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+jX-25,aj-5,ai+jX-20,aj,ai+jX-25,aj+5,ai+jX-30,aj+4,jY)jy[#jy+1]="</g>"end;local j_=bG(jH/3)jy[#jy+1]=d7([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-j_,aj,jH-j_)if not c7 and cR then jy[#jy+1]=d7([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jF,ai,aj,ai-jX+10,aj,jX*2-20)end;jy[#jy+1]="</g>"if jH<200 then if c7 and fe>ir then jy[#jy+1]=gz(ai,aj-jH,jZ,"pdim txt txtmid")jy[#jy+1]=gz(ai,aj-jH+10,jY,"pdim txt txtmid")jy[#jy+1]=gz(ai,aj-15,"Yaw","pdim txt txtmid")jy[#jy+1]=gz(ai,aj+20,jW,"pdim txt txtmid")else jy[#jy+1]=gz(ai,aj-jH,jZ,"pdim txt txtmid")jy[#jy+1]=gz(ai,aj-jH+15,jY,"pdim txt txtmid")end end end end;local function k0(jy,dS,cR)local k1=ao;local k2=ap;if k1==0 and k2==0 then return end;local k3=78;local k4=19;local k5=c6;if c6~=-1 then jy[#jy+1]=gz(k1+k3,k2+k4+20,d7("AGL: %.1fm",c6),"pdim altsm txtend")end;if cR and(dS<200000 and not c7 or dS and c7)then table.insert(jy,d7([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k1-1,k2-4,k3+2,k4+6,k1+1,k2-1,k3-4,k4))local gk=0;local k6=1;local k7=0;local k8=dS<0;local k9=dS<iO.surfaceMaxAltitude;local ka=9;if k8 then ka=0 end;local dS=eN(dS)while gk<6 do local kb=11;local kc=16;local kd=9;local ke=14;local js="altsm"if gk>2 then kc=kc+3;kb=kb+2;ke=ke+2;kd=kd-6;js="altbig"end;if k8 then js=js.." red"elseif k9 then js=js.." orange"end;local kf=dS/k6%10;local kg=bG(kf)local kh=bG((kg+1)%10)local ki=k7;if gk==0 then ki=kf-kg;if k8 then ki=1-ki end end;if k8 and(gk==0 or k7~=0)then local gn=kh;kh=kg;kg=gn end;local kj=kc*(ki-1)local kk=kj+kc;local ha=k1+kd+(6-gk)*kb;local hb=k2+ke;jy[#jy+1]=gz(ha,hb+kj,kh,js)jy[#jy+1]=gz(ha,hb+kk,kg,js)gk=gk+1;k6=k6*10;if kg==ka then k7=ki else k7=0 end end;table.insert(jy,[[</g></g>]])end end;local function kl(fj)local km=-math.deg(eI(fj.y,fj.z))+180;km=km-90;if km<0 then km=360+km end;if km>180 then km=-180+km-180 end;return-km end;local function kn(fj)local jM=math.deg(eI(fj.y,fj.x))-90;if jM<-180 then jM=360+jM end;return jM end;local function ko(jy,fj,fe,ai,aj)if fe>5 and not c7 or fe>ir then local jH=ab;local kp=20;local kq=20;local kr=kl(fj)local ks=kn(fj)local kt=14;local ku=kt/2;local kv=-ks/kq*jH;local kw=kr/kp*jH;local ha=ai+kv;local hb=aj+kw;local c2=da(kv^2+kw^2)local kx=[[<circle
                            cx="]]..ha..[["
                            cy="]]..hb..[["
                            r="]]..ku/kt..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ha..[["
                            cy="]]..hb..[["
                            r="]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ha-kt..[[,]]..hb..[[ h ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ha+ku..[[,]]..hb..[[ h ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ha..[[,]]..hb-kt..[[ v ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c2<jH then jy[#jy+1]=kx else local jz=eI(kw,kv)local ky=4;local kz=ai+jH*math.cos(jz)local kA=aj+jH*math.sin(jz)jy[#jy+1]=d7('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jz*180/math.pi,kz,kA,kz-ky,kA-ky/2,ky*2,ky,kz+ky,kA-ky,ky,ky,-ky,ky)end;if not c7 then local kB=vec3(fj)kr=kl(-kB)ks=kn(-kB)kv=-ks/kq*jH;kw=kr/kp*jH;ha=ai+kv;hb=aj+kw;c2=da(kv^2+kw^2)if c2<jH then local kC=[[<circle
                                    cx="]]..ha..[["
                                    cy="]]..hb..[["
                                    r="]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ha..[[,]]..hb-kt..[[ v ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ha..[[,]]..hb..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ha..[[,]]..hb..[[)" />
                                <path
                                    d="M ]]..ha-ku..[[,]]..hb..[[ h ]]..kt..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ha..[[,]]..hb..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ha..[[,]]..hb..[[)"/>]]jy[#jy+1]=kC end end end end;local function kD(jy,iT,kE,kF)if ak==0 and al==0 then return end;kE=bG(kE+0.5)local ji=al+10;local jj=al+20;if i4()==1 and not l then ji=55;jj=65 end;local kG="CRUISE"local c="km/h"local dz=kF;if iT=="TRAVEL"or iT=="AUTOPILOT"then kG="THROT"c="%"dz=kE;local kH="dim"if kE<0 then kH="red"end;jy[#jy+1]=d7([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kH,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eN(kE),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jy[#jy+1]=gz(ak+10,ji,kG,"pbright txtstart")jy[#jy+1]=gz(ak+10,jj,d7("%.0f %s",dz,c),"pbright txtstart")if c7 and u and cK and bL then kE=bG(bM*100+0.5)local kH="red"if kE<0 then kH="red"end;jy[#jy+1]=d7([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kH,1-eN(kE),ak-10,al+50,ak-15,al+53,ak-15,al+47)jy[#jy+1]=gz(ak+10,ji+40,"LIMIT","pbright txtstart")jy[#jy+1]=gz(ak+10,jj+40,kE.."%","pbright txtstart")end;if c7 and u or b5 then jy[#jy+1]=gz(ak+10,ji-40,"LIMIT: "..cu.." km/h","dim txtstart")elseif not c7 and b0 then jy[#jy+1]=gz(ak+10,ji-40,"LIMIT: "..bG(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kI(jy,kJ)if ak==0 and al==0 then return end;local kK=al-10;local kL=ak+10;jy[#jy+1]=gz(0,0,"","pdim txt txtend")if i4()==1 and not l then kK=75 end;jy[#jy+1]=gz(kL,kK,bG(kJ).." km/h","pbright txtbig txtstart")end;local function kM(jy)jy[#jy+1]=gz(iP(1900),iQ(1070),d7("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jy[#jy+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jy[#jy+1]=gz(iP(960),iQ(550),"Warning: Invalid Control Scheme Detected","warnings")jy[#jy+1]=gz(iP(960),iQ(600),"Keyboard Scheme must be selected","warnings")jy[#jy+1]=gz(iP(960),iQ(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kN=iP(960)local kO=iQ(860)local kP=iQ(880)local kQ=iQ(900)local kR=iQ(960)local kS=iQ(200)local kT=iQ(250)local kU=iQ(960)if i4()==1 and not l then kO=iQ(135)kP=iQ(155)kQ=iQ(175)kS=iQ(115)kT=iQ(95)end;local kV="#222222"local kW="white"local kX="dimmer"local kY="pbright"local kZ="#110000"local k_=kV;local l0=kX;if aY then jy[#jy+1]=gz(kN,kO,"Brake Engaged","warnings")kZ="#440000"k_=kW;l0=kY elseif bK>0 then jy[#jy+1]=gz(kN,kO,"Auto-Brake Engaged","warnings","opacity:"..bK)end;local l1="#110000"local l2=kV;local l3=kX;if c7 and ct and c6==-1 then if not b0 and not bn and not b3 and not cJ and not b6 and not b4 then jy[#jy+1]=gz(kN,kS+50,"** STALL WARNING **","warnings")l1="#ff0000"l2=kW;l3=kY;fJ("stall","SW",2)end end;if cQ then jy[#jy+1]=gz(kN,kS+90,"Flight Assist in Progress","warnings")end;if cb then jy[#jy+1]=gz(kN,kU,"Gyro Enabled","warnings")end;local l4="#111100"local l5=kV;local l6=kX;if bj then l4="#775500"l5=kW;l6=kY;if bO then jy[#jy+1]=gz(kN,kP,"Gear Extended","warn")else jy[#jy+1]=gz(kN,kP,"Landed (G: Takeoff)","warnings")end;local l7=ia(d:getTargetGroundAltitude())jy[#jy+1]=gz(kN,kQ,"Hover Height: "..l7,"warn")end;local l8="#000011"local l9=kV;local la=kX;if bX then l8="#0000DD"l9=kW;la=kY;jy[#jy+1]=gz(kN,kR+20,"ROCKET BOOST ENABLED","warn")end;local lb="#001100"local lc=kV;local ld=kX;if antigrav and not q and cJ and bs~=nil then lb="#00DD00"lc=kW;ld=kY;if eN(c9-antigrav.getBaseAltitude())<501 then jy[#jy+1]=gz(kN,kS+15,d7("Target Altitude: %d Singularity Altitude: %d",bG(bs),bG(antigrav.getBaseAltitude())),"warn")else jy[#jy+1]=gz(kN,kS+15,d7("Target Altitude: %d Singluarity Altitude: %d",bG(bs),bG(antigrav.getBaseAltitude())),"warnings")end elseif b0 and bg~="None"then jy[#jy+1]=gz(kN,kS+20,"Autopilot "..bd,"warn")elseif bq~=nil then jy[#jy+1]=gz(kN,kS+20,d7("LockedPitch: %d",bG(bq)),"warn")elseif bT then jy[#jy+1]=gz(kN,kS+20,"Follow Mode Engaged","warn")elseif b5 or c5 then jy[#jy+1]=gz(kN,kS+20,"Re-entry in Progress","warn")end;if b2 or b6 then local l7=ia(b7,2)if b6 then if cJ then l7=ia(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jy[#jy+1]=gz(kN,kS,"VTO to "..l7,"warn")elseif b4 and not bw then if c4 then jy[#jy+1]=gz(kN,kS,"Takeoff to "..bg,"warn")else jy[#jy+1]=gz(kN,kS,"Takeoff to "..l7,"warn")end;if aY and not b6 then jy[#jy+1]=gz(kN,kS+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jy[#jy+1]=gz(kN,kS,"Altitude Hold: "..l7,"warn")end end;if b6 and(antigrav~=nil and antigrav)then if c8>0.1 then jy[#jy+1]=gz(kN,kS+20,"Beginning ascent","warn")elseif c8<0.09 and c8>0.05 then jy[#jy+1]=gz(kN,kS+20,"Aligning trajectory","warn")elseif c8<0.05 then jy[#jy+1]=gz(kN,kS+20,"Leaving atmosphere","warn")end end;if bw then if cv~=nil then jy[#jy+1]=gz(kN,kS,cv,"warn")end end;if b3 then if le then jy[#jy+1]=gz(kN,kS,"Brake-Landing","warnings")else jy[#jy+1]=gz(kN,kS,"Coast-Landing","warnings")end end;if a_ then jy[#jy+1]=gz(kN,kS,"Prograde Alignment","crit")end;if aZ then jy[#jy+1]=gz(kN,kS,"Retrograde Alignment","crit")end;local lf="#110000"local lg=kV;local lh=kX;if cS then lf="#FF0000"lg=kW;lh=kY;local type;if string.find(cS,"COLLISION")then type="warnings"else type="crit"end;jy[#jy+1]=gz(kN,kT+20,cS,type)elseif c8==0 then local li,lj=cn.checkLOS(cD:normalize())if lj~=nil then lh=kY;lf="#FF0000"lg=kW;local l7=ia(lj)local lk=ci.computeTravelTime(cE,0,lj)local ll="Collision"if li.noAtmosphericDensityAltitude>0 then ll="Atmosphere"end;jy[#jy+1]=gz(kN,kT+20,li.name.." "..ll.." "..ib(lk).." In "..l7,"crit")end end;if bn and not bw then jy[#jy+1]=gz(kN,kS+35,lm,"warn")end;local ln="#111100"local lo=kV;local lp=kX;if cW and#cW>1 then ln="#DDDD00"lo=kW;lp=kY end;local lq=iP;local lr=iQ;local kX="topButton"local ls="topButtonActive"local lt=kX;if b0 or bn or c4 or bw then lt=ls end;local lu=kX;if a_ then lu=ls end;local lv=kX;if b3 or bj then lv=ls end;local lw=kX;if b2 or bn then lw=ls end;local lx=kX;if aZ then lx=ls end;local ly=kX;if bw or cx and b0 then ly=ls end;if x and I then local lz=lr(30)jy[#jy+1]=d7([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lt,lq(960),lr(54),lr(-53),lq(-120),lq(25),lr(50))jy[#jy+1]=gz(lq(910),lz,"AUTOPILOT")jy[#jy+1]=d7([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lu,lq(865),lr(51),lq(-25),lr(-50),lq(-110),lq(25),lr(46))jy[#jy+1]=gz(lq(800),lz,"PROGRADE")jy[#jy+1]=d7([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lv,lq(755),lr(47),lq(-25),lr(-46),lq(-98),lq(44),lr(44))jy[#jy+1]=gz(lq(700),lz,"LAND")jy[#jy+1]=d7([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lw,lq(960),lr(54),lr(-53),lq(120),lq(-25),lr(50))jy[#jy+1]=gz(lq(1010),lz,"ALT HOLD")jy[#jy+1]=d7([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lx,lq(1055),lr(51),lq(25),lr(-50),lq(110),lq(-25),lr(46))jy[#jy+1]=gz(lq(1122),lz,"RETROGRADE")jy[#jy+1]=d7([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,lq(1165),lr(47),lq(25),lr(-46),lq(98),lq(-44),lr(44))jy[#jy+1]=gz(lq(1220),lz,"ORBIT")jy[#jy+1]=[[
                                    </g>
                                </g>]]jy[#jy+1]="</g>"end;return jy end;local function lA(fe)return bG(i7(fe*3.6,0)+0.5).." km/h"end;local function lB(gk)local gm=bg;if gk~=nil and type(gk)=="number"then if gk==0 then return"None"end;gm=cN[gk].name end;if gm==nil then gm=fU.name end;if gm==nil then gm="None"end;return gm end;local function lC(jy)local lD=cn.routeWP(true)if not lD or#lD==0 then return end;local ha=iP(750)local hb=iQ(360)if b0 or bn then jy[#jy+1]=gz(ha,hb,"REMAINING ROUTE","pdim txtstart size20")else jy[#jy+1]=gz(ha,hb,"LOADED ROUTE","pdim txtstart size20")end;for dy,L in pairs(lD)do hb=hb+20;jy[#jy+1]=gz(ha,hb,dy..". "..lD[dy],"pdim txtstart size20")end end;local function lE(jy)local ha=aw+10;local hb=ax+20;local lF={}local lG={"Alt-4: AutoTakeoff to Target"}local lH={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lI={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lJ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lF,"--------------DYNAMIC-----------------")if c7 then if c6~=-1 then i8(lF,lG)if b_ and iO and b_.name==iO.name then table.insert(lF,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aX then if antigrav then if cJ then table.insert(lF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lF,"Turn on AGG to takeoff to AGG Height")end end;if aX then table.insert(lF,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lF,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lF,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bj then table.insert(lF,"G: Takeoff to hover height, raise gear")else table.insert(lF,"G: Lowergear and Land")end else i8(lF,lH)table.insert(lF,"G: Begin BrakeLanding or Land")end;if b6 then table.insert(lF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else i8(lF,lI)if i0 then table.insert(lF,"Alt-Shift-6: Vent shields")table.insert(lF,"Alt-Shift-7: Toggle shied off/on")end end;if fU~=nil then table.insert(lF,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lF,"Alt-9: Activate Gyroscope")end;if aT~="none"or aS~="none"or aU~="none"then table.insert(lF,"Alt-Shift-9: Cycles engines with Extra tags")end;if b2 then table.insert(lF,"Alt-Spacebar/C will raise/lower target height")table.insert(lF,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not c7 then table.insert(lF,"LALT+Mousewheel will lower/raise speed limit")end;i8(lF,lJ)for L=1,#lF do hb=hb+12;jy[#jy+1]=gz(ha,hb,lF[L],"pdim txtbig txtstart")end end;local function lK(jy)local lL=aw;local lM=ax;local lN=av;local lO=4;local lP=15;local ha=0;local hb=0;local lQ,lR,lS,lT;local lU;local function lV(type)local lW,bI,fe,lX,js,lY;if type=="Periapsis"then lW=lU.periapsis.altitude;bI=lU.timeToPeriapsis;fe=lU.periapsis.speed;js="txtend"lX=12;lY=math.min(ha,lL+lN-iO.radius/lS-lO*2)else lW=lU.apoapsis.altitude;bI=lU.timeToApoapsis;fe=lU.apoapsis.speed;lX=-12;js="txtstart"lY=ha end;if cE<1 then bI=0 end;jy[#jy+1]=d7([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lY+lX,hb-5,ha,hb-5)jy[#jy+1]=d7([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lY-lX*4,hb+2,ha,hb+2)jy[#jy+1]=gz(lY,hb,type,js)ha=lY-lX*2;hb=hb+lP;local l7=ia(lW)jy[#jy+1]=gz(ha,hb,l7,js)hb=hb+lP;jy[#jy+1]=gz(ha,hb,ib(bI),js)hb=hb+lP;jy[#jy+1]=gz(ha,hb,lA(fe),js)end;local lZ=lN*1.5;if bD=="INFO"then lZ=25*9 end;if bD~="HIDE"then jy[#jy+1]=[[<g class="pbright txtorb txtmid">]]jy[#jy+1]=d7('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lN*2,lZ,lL,lM)jy[#jy+1]=d7([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lN*2,lZ,lL,lM)end;local l_=lN*1.5;local m0=lN*2;local m1=l_/2;local m2=lN;local m3=lL+m2;local m4=lM+m1;local m5=lL+m0;local m6=lM+l_;if bD=="ORBIT"then lM=lM+lO;lQ=lN/2;lT=0;lU={}lU.periapsis={}lU.apoapsis={}if fi~=nil then if fi.periapsis~=nil then lU.periapsis.altitude=fi.periapsis.altitude;lU.periapsis.speed=fi.periapsis.speed end;if fi.apoapsis~=nil then lU.apoapsis.altitude=fi.apoapsis.altitude;lU.apoapsis.speed=fi.apoapsis.speed end;lU.period=fi.period;lU.eccentricity=fi.eccentricity;lU.timeToApoapsis=fi.timeToApoapsis;lU.timeToPeriapsis=fi.timeToPeriapsis;lU.eccentricAnomaly=fi.eccentricAnomaly;lU.trueAnomaly=fi.trueAnomaly end;if lU.periapsis==nil then lU.periapsis={}lU.periapsis.altitude=-iO.radius;lU.periapsis.speed=a0 end;if lU.eccentricity==nil then lU.eccentricity=1 end;if lU.apoapsis==nil then lU.apoapsis={}lU.apoapsis.altitude=c9;lU.apoapsis.speed=0 end;if cE<1 then lU.apoapsis.altitude=c9;lU.apoapsis.speed=0 end;if lU.apoapsis.altitude then lS=(lU.apoapsis.altitude+lU.periapsis.altitude+iO.radius*2)/(lQ*2)lR=(iO.radius+lU.apoapsis.altitude)/lS*(1-lU.eccentricity)lT=lQ-lU.periapsis.altitude/lS-iO.radius/lS;local m7=math.pi;if lU.period~=nil and lU.period>0 and lU.timeToApoapsis~=nil then m7=lU.eccentricAnomaly;if lU.timeToPeriapsis<lU.timeToApoapsis then m7=2*math.pi-m7 end end;if cE<1 or m7~=m7 then m7=math.pi end;local m8=-lQ*math.cos(m7)+lL+m2+lO;local m9=lR*math.sin(m7)+lM+m1+lO;local ma=""jy[#jy+1]='<g clip-path="url(#orbitRect)">'jy[#jy+1]=d7([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ma,lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)if lR<1 then jy[#jy+1]=d7([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lL+lN+lO-lT,lM+lN*1.5/2+lO,m8,m9)end;jy[#jy+1]=d7('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,(iO.radius+iO.noAtmosphericDensityAltitude)/lS)jy[#jy+1]=d7('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lL+lN+lO-lT,lM+lN*1.5/2+lO,(iO.radius+iO.noAtmosphericDensityAltitude)/lS)jy[#jy+1]=d7([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)jy[#jy+1]=d7('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,iO.radius/lS)jy[#jy+1]='</g>'local mb=math.floor(iO.radius/lS+0.5)ha=lL+lN+lO*4+lQ;hb=lM+lN*1.5/2+5+lO;if lU.apoapsis~=nil and lU.apoapsis.speed<a0 then lV("Apoapsis")end;hb=lM+lN*1.5/2+5+lO;ha=lL+lN-lO*2-lQ;if lU.periapsis~=nil and lU.periapsis.speed<a0 and lU.periapsis.altitude>0 then lV("Periapsis")end;jy[#jy+1]=gz(lL+lN+lO,lM+20+lO,iO.name,"txtorbbig")jy[#jy+1]=d7('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m8,m9)jy[#jy+1]=[[</g>]]return jy else jy[#jy+1]='<g clip-path="url(#orbitRect)">'local mc=""local md=1.2*(me-mf)/(lN*2)local mg=1.4*(mh-mi)/(lN*1.5)for dy,dj in pairs(e[0])do if dj.center then local ha=lL+lN+dj.center.x/md;local hb=lM+lN*1.5/2+dj.center.y/mg;mc=mc..'<circle cx="'..ha..'" cy="'..hb..'" r="'..dj.radius/md*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dj.name,"Moon")and not string.match(dj.name,"Sanctuary")and not string.match(dj.name,"Space")then mc=mc.."<text x='"..ha.."' y='"..hb+dj.radius/md*30+20 .."' font-size='12' fill="..iz.." text-anchor='middle' font-family='Montserrat'>"..dj.name.."</text>"end end end;local fk=vec3(b.getConstructWorldPos())local ha=lL+lN+fk.x/md;local hb=lM+lN*1.5/2+fk.y/mg;mc=mc..'<circle cx="'..ha..'" cy="'..hb..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mc=mc.."<text x='"..ha.."' y='"..hb-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ik=md;il=mg;local mj=fk+cD*1000000;local mk=lL+lN+mj.x/md;local jj=lM+lN*1.5/2+mj.y/mg;mc=mc..'<line x1="'..ha..'" y1="'..hb..'" x2="'..mk..'" y2="'..jj..'" stroke="purple" stroke-width="1"/>'jy[#jy+1]=mc;jy[#jy+1]='</g>'end elseif bD=="INFO"then jy=cl.DrawOdometer(jy,iB,bk,iC)elseif bD=="HELP"then jy=lE(jy)elseif bD=="SCOPE"then jy[#jy+1]='<g clip-path="url(#orbitRect)">'local ml=cZ;if c8>0 then table.sort(cY,function(eo,ep)local eq,er=eo.center,ep.center;return(eq.x-cH.x)^2+(eq.y-cH.y)^2+(eq.z-cH.z)^2<(er.x-cH.x)^2+(er.y-cH.y)^2+(er.z-cH.z)^2 end)end;local gH={}local mm={}local mn=120;local mo=nil;local mp=nil;for L,dj in ipairs(cY)do local gG=dj.center-cH;local mq=gG:len()local mr=gG:normalize()local ms=gG:cross(cA):normalize()local mt=math.acos(ms:dot(cB))if mt~=mt then mt=0 end;if ms:cross(cB):dot(cA)<0 then mt=-mt end;local mu=gG:project_on_plane(cA):len()local mv=math.sin(mt)*math.asin(mu/mq)*constants.rad2deg;local mw=math.cos(mt)*math.asin(mu/mq)*constants.rad2deg;if mr:dot(cA)<0 then mw=90*math.cos(mt)+90*math.cos(mt)-mw;mv=90*math.sin(mt)+90*math.sin(mt)-mv end;local ha=m3+mv/ml*l_;local hb=m4+mw/ml*l_;local mx=(ha-m3)*(ha-m3)+(hb-m4)*(hb-m4)local my=math.asin((dj.radius+dj.surfaceMaxAltitude)/mq)*constants.rad2deg;if my~=my then my=ml end;local hG=my/ml*l_;local mz=math.asin(dj.atmosphereRadius/mq)*constants.rad2deg;if mz~=mz then mz=my end;local mA=mz/ml*l_;local c2=ia(mq,1)local mB=dj.name;local mC=false;if hb>lM then if hb>m6 then if hb-mA<=m6 then mC=true end else mC=true end else if hb+mA>=lM then mC=true end end;local mD=false;local mE=ha;if dj.systemId==0 then mE=ha+mn else mE=ha-mn end;if mE+mn>lL then if mE+mn>m5 then if mE-mA-mn<=m5 then mD=true end else mD=true end else if mE+mA+mn>=lL then mD=true end end;local mF={}mF.x=ha;mF.y=hb;mF.planet=dj;mF.atmoSize=mA;if not mo or mx<mo then mo=mx;mp=mF end;if mD and mC then local mG=math.max(mA,5)if mx<mG*mG then mB=mB.." - "..c2 end;mF.size=hG;mF.i=L;mF.displayString=mB;mF.distance=c2;mF.visible=true;mm[#mm+1]=mF else mF.visible=false end end;local mH=false;table.sort(mm,function(eq,er)return eq.y<er.y end)for dy,fn in ipairs(mm)do local dj,hG,L,mA,ha,hb,mB,c2=fn.planet,fn.size,fn.i,fn.atmoSize,fn.x,fn.y,fn.displayString,fn.distance;local lY,mI,mJ,mK;local mL=15;local js="pdim"if dj.systemId~=0 then mJ=iP(string.len(mB)*5)mL=-(15+mJ)mK=iQ(10)js="pdimfill"else mJ=iP(string.len(mB)*9)mK=iQ(15)end;if hG*2>mJ then lY=d8(ha,lL+mJ/2,m5-mJ/2)mI=d8(hb,lM+mK,m6-5)lY=d8(lY,ha-hG+mJ/2,ha+hG-mJ/2)mI=d8(mI,hb-hG+mK,hb+hG)else lY=ha+mL;mI=hb end;for mM,fn in pairs(gH)do local mN=fn.textPositions;local mO=mN.y-mI;if mM~=L and eN(mO)<mN.height and mN.x+mN.width>lY and mN.x<lY+mJ then if hG>mJ then mI=d8(mI+mK,lM+15,m6-5)else mI=mN.y+mN.height+1 end end end;local mP=mB~=dj.name or lY<=m3 and lY+mJ>=m3 and mI-mK<=m4 and mI>=m4;fn.hovered=mP;local mQ=1;if mP then mQ=2;if hG*2<mJ then mQ=10 end;if mB==dj.name then mB=mB.." - "..c2 end;js="pbright"if dj.systemId~=0 then mJ=iP(string.len(mB)*5)mL=-(15+mJ)else mJ=iP(string.len(mB)*7)end;if hG*2>mJ then lY=d8(ha,lL+mJ/2,m5-mJ/2)lY=d8(lY,ha-hG+mJ/2,ha+hG-mJ/2)else lY=ha+mL end end;gH[L]={}gH[L].textPositions={}gH[L].textPositions.y=mI;gH[L].textPositions.x=lY;gH[L].textPositions.width=mJ;gH[L].textPositions.height=mK;gH[L].output=""if hG*2>mJ then js=js.." txtmid"else js=js.." txtstart"end;if mA-hG>2 then gH[L].output=d7('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',ha,hb,mA,iA,0.1*mQ)end;gH[L].output=gH[L].output..d7('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',ha,hb,hG,iA,0.2*mQ)if dj.systemId==0 then gH[L].output=gH[L].output..d7([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lY,mI,iz,js,mB)if hG*2<=mJ then gH[L].output=gH[L].output..d7("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lY+mJ,mI+2,lY,mI+2,ha,hb)end else gH[L].output=gH[L].output..d7([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lY,mI,iA,js,mB)if hG*2<=mJ then gH[L].output=gH[L].output..d7("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lY,mI+2,lY+mJ,mI+2,ha,hb)end end end;for dy=#cY,1,-1 do if gH[dy]then jy[#jy+1]=gH[dy].output end end;if mp~=nil and cZ<90 and not mp.hovered then local mR=mp.planet.atmosphereRadius/mp.atmoSize;local mS=da(mo)*mR;local mT=ia(mS,1)local mJ=iP(math.max(string.len(mT)*7,string.len(mp.planet.name)*7))local mK=iQ(12)local lY=d8(mp.x+(m3-mp.x)/2,lL+mJ/2,m5-mJ/2)local mI=d8(mp.y+(m4-mp.y)/2,lM+mK*2,m6-5)jy[#jy+1]=d7("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mp.x,mp.y,m3,m4)jy[#jy+1]=d7([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lY,mI,"white",mT)if not mp.visible then jy[#jy+1]=d7([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lY,mI-mK,"white",mp.planet.name)end end;if cE>1 then local gG=cD;local mr=gG:normalize()local mu=gG:project_on_plane(cA):len()local ms=gG:cross(cA):normalize()local mt=math.acos(ms:dot(cB))if mt~=mt then mt=0 end;if ms:cross(cB):dot(cA)<0 then mt=-mt end;local mv=math.sin(mt)*math.asin(mu/gG:len())*constants.rad2deg;local mw=math.cos(mt)*math.asin(mu/gG:len())*constants.rad2deg;if mr:dot(cA)<0 then mw=90*math.cos(mt)+90*math.cos(mt)-mw;mv=90*math.sin(mt)+90*math.sin(mt)-mv end;local ha=m3+mv/ml*l_;local hb=m4+mw/ml*l_;local kt=14;local ku=kt/2;local kx=[[<circle
                                    cx="]]..ha..[["
                                    cy="]]..hb..[["
                                    r="]]..ku/kt..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..ha..[["
                                    cy="]]..hb..[["
                                    r="]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ha-kt..[[,]]..hb..[[ h ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ha+ku..[[,]]..hb..[[ h ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..ha..[[,]]..hb-kt..[[ v ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jy[#jy+1]=kx end;jy[#jy+1]=d7("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m3,m4-10,m3,m4+10)jy[#jy+1]=d7("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m3-10,m4,m3+10,m4)jy[#jy+1]='</g>'else return jy end end;local function mU(mV,mW)local mX;local mY=(mW-mV):normalize()local fl=(cH-mV):dot(mY)/mY:dot(mY)if fl<=0. then return(cH-mV):len()elseif fl>=(mW-mV):len()then return(cH-mW):len()end;local mZ=mV+fl*mY;mX=(mZ-cH):len()return mX end;local function m_()local mX;local n0=nil;local n1=nil;local n2=nil;for dy,n3 in pairs(e[0])do if n3.hasAtmosphere then local c2=mU(iO.center,n3.center)if n0==nil or c2<n0 then n1=n3;n0=c2;n2=iO end;if b_ and b_.hasAtmosphere and b_.name~=iO.name then local eD=mU(b_.center,n3.center)if eD<n0 then n1=n3;n0=eD;n2=b_ end end end end;local n4=iP(1770)local n5=iQ(330)if n0 then local n6="txttick "local n7=500000;if n0<n1.radius+n7 or n0<n2.radius+n7 then if cO then n6="txttick red "else n6="txttick orange "end end;mX=ia(n0,2)iq=gz(n4,n5,"Pipe ("..n2.name.."--"..n1.name.."): "..mX,n6 .."pbright txtmid")end end;local function n8(ha,hb,n9,na,kG)local nb={x=ha,y=hb,width=n9,height=na,label=kG}ij[kG]=nb;return nb end;local function nc(nd,ne,n9,na,ha,hb,nf,ng,nh,ni,js)local nb={enableName=nd,disableName=ne,width=n9,height=na,x=ha,y=hb,toggleVar=nf,toggleFunction=ng,drawCondition=nh,hovered=false,class=js}if ni then table.insert(ii,nb)else table.insert(ih,nb)end;return nb end;local function nj(nk)if not io then nl=false;nm=false;nn=false;x=true;return elseif nk=="handling"then nl=not nl;nm=false;nn=false elseif nk=="hud"then nm=not nm;nl=false;nn=false elseif nk=="physics"then nn=not nn;nl=false;nm=false end;if nn or nm or nl then ip=i9(nk)x=false else ip="none"x=true end end;local function no()io=not io;if io then ig=ii;bV="Hold SHIFT to see Settings"c_=x else ig=ih;bV="Hold SHIFT to see Control Buttons"nj()x=c_ end end;local function np()local function nq(dj,dy)dj.set(not dj.get())if dj.get()then bV=dy.." set to true"else bV=dy.." set to false"end;if dy=="showHud"then c_=dj.get()elseif dy=="BrakeToggleDefault"then aW=j end end;local nr=50;local ns=340;local ha=500;local hb=cd/2-400;local nt=0;for dy,dj in pairs(i9("boolean"))do if type(dj.get())=="boolean"then nc(dy,dy,ns,nr,ha,hb,function()return dj.get()end,function()nq(dj,dy)end,function()return true end,true)hb=hb+nr+20;if nt==9 then ha=ha+ns+20;hb=cd/2-400;nt=0 else nt=nt+1 end end end;nc("Control View","Control View",ns,nr,10,cd/2-500,function()return true end,no,function()return true end,true)nc("View Handling Settings",'Hide Handling Settings',ns,nr,10,cd/2-(500-nr),function()return nl end,function()nj("handling")end,function()return true end,true)nc("View Hud Settings",'Hide Hud Settings',ns,nr,10,cd/2-(500-nr*2),function()return nm end,function()nj("hud")end,function()return true end,true)nc("View Physics Settings",'Hide Physics Settings',ns,nr,10,cd/2-(500-nr*3),function()return nn end,function()nj("physics")end,function()return true end,true)end;local function nu()local function gl()local fL=cH;local gm=iO.name..". "..#bm;if radar_1 then gm=co.GetClosestName(gm)end;return cm.AddNewLocation(gm,fL,false,true)end;local function nv()b1=not b1 end;local function nw(nx)if nx==1 then a_=not a_;aZ=false else aZ=not aZ;a_=false end;b0=false;b2=false;bT=false;b3=false;bq=nil;b5=false;b4=false end;local function ny(nz)cm.UpdatePosition(nil,nz)end;local function gg()cm.ClearCurrentPosition()end;local function nA(gk)local lD=cn.routeWP(true)if lD and#lD>0 then return"Engage Route: "..lD[1]end;return"Engage Autopilot: "..lB(gk)end;local function nB(gk)local lD=cn.routeWP(true)if lD and#lD>0 then return"Next Route Point: "..lD[1]end;return"Disable Autopilot: "..lB(gk)end;local function nC()if i4()==1 then bT=not bT;if bT then b0=false;aZ=false;a_=false;b2=false;b5=false;b3=false;b4=false;nD=bj;bj=false;d.control.retractLandingGears()i5:setTargetGroundAltitude(Y)fJ("folOn","F")else fJ("folOff","F")aY=true;cs=p;bj=nD;if bj then d.control.extendLandingGears()i5:setTargetGroundAltitude(Z)end end else bV="Follow Mode only works with Remote controller"bT=false end end;local nr=50;local ns=260;local nE=iP(30)local nF=aw+av*2+2;local nG=ax+1;nc("+","+",nE,nE,nF,nG+nE+1,function()return false end,function()cZ=cZ/8 end,function()return bD=="SCOPE"end,nil,"ZoomButton")nc("-","-",nE,nE,nF,nG,function()return false end,function()cZ=math.min(cZ*8,90)end,function()return bD=="SCOPE"end,nil,"ZoomButton")nc("0","0",nE,nE,nF,nG+nE*2+2,function()return false end,function()cZ=90 end,function()return bD=="SCOPE"and cZ~=90 end,nil,"ZoomButton")local nH=nc("Enable Brake Toggle","Disable Brake Toggle",ns,nr,cc/2-ns/2,cd/2+350,function()return aW end,function()aW=not aW;if aW then bV="Brakes in Toggle Mode"else bV="Brakes in Default Mode"end end)nc("Align Prograde","Disable Prograde",ns,nr,cc/2-ns/2-50-nH.width,cd/2-nr+380,function()return a_ end,function()nw(1)end)nc("Align Retrograde","Disable Retrograde",ns,nr,cc/2-ns/2+nH.width+50,cd/2-nr+380,function()return aZ end,nw,function()return c8==0 end)nI=nc(nA,nB,600,60,cc/2-600/2,cd/2-60/2-330,function()return b0 or bn or c4 or bw end,function()end)local L;local function nJ(nK)local gk=cV+nK;if gk>#cN then gk=gk-#cN-1 end;if gk<0 then gk=#cN+gk end;return gk end;nL={}for L=0,10 do local nM=nc(function(er)local gk=nJ(er.apExtraIndex)if b0 or bn or c4 or bw then return"Redirect: "..lB(gk)end;return nA(gk)end,function(er)local gk=nJ(er.apExtraIndex)return nB(gk)end,600,60,cc/2-600/2,cd/2-60/2-330+60*L,function(er)local gk=nJ(er.apExtraIndex)return gk==bi and(b0 or bn or c4 or bw)end,function(er)local gk=nJ(er.apExtraIndex)local nN=bi==gk;bi=gk;cm.UpdateAutopilotTarget()cn.ToggleAutopilot()if not nN and not(b0 or bn or c4 or bw)then cn.ToggleAutopilot()end end,function()return cU and(#cn.routeWP(true)==0 or L==0)end)nM.apExtraIndex=L;nL[L]=nM end;nc("Save Position","Save Position",200,nI.height,nI.x+nI.width+30,nI.y,function()return false end,gl,function()return bi==0 or fU==nil end)nc("Update Position","Update Position",200,nI.height,nI.x+nI.width+30,nI.y,function()return false end,function()ny(nil)end,function()return bi>0 and fU~=nil end)nc("Save Heading","Clear Heading",200,nI.height,nI.x+nI.width+30,nI.y+nI.height+20,function()return fU.heading~=nil end,function()if fU.heading~=nil then ny(false)else ny(true)end end,function()return bi>0 and fU~=nil end)nc("Clear Position","Clear Position",200,nI.height,nI.x-200-30,nI.y,function()return true end,gg,function()return bi>0 and fU~=nil end)nc("Save Route","Save Route",200,nI.height,nI.x-200-30,nI.y+nI.height*2+40,function()return false end,function()cn.routeWP(false,false,2)end,function()return#cn.routeWP(true)>0 end)nc("Load Route","Clear Route",200,nI.height,nI.x-200-30,nI.y+nI.height+20,function()return#cn.routeWP(true)>0 end,function()if#cn.routeWP(true)>0 then cn.routeWP(false,true)elseif b0 or bn then bV="Disable Autopilot before loading route"return else cn.routeWP(false,false,1)end end,function()return true end)nr=60;ns=300;local ha=0;local hb=cd/2-150;nc("Enable Check Damage","Disable Check Damage",ns,nr,ha,hb-nr-20,function()return s end,function()s=not s end)nc("View Settings","View Settings",ns,nr,ha,hb,function()return true end,no)hb=hb+nr+20;nc("Enable Turn and Burn","Disable Turn and Burn",ns,nr,ha,hb,function()return b1 end,nv)ha=10;hb=cd/2-300;nc("Horizontal Takeoff Mode","Vertical Takeoff Mode",ns,nr,ha+ns+20,hb,function()return aX end,function()aX=not aX;if aX then bV="Vertical Takeoff Mode"else bV="Horizontal Takeoff Mode"end end,function()return cI end)hb=hb+nr+20;nc("Engage Orbiting","Cancel Orbiting",ns,nr,ha+ns+20,hb,function()return bw end,cn.ToggleIntoOrbit,function()return c8==0 and cR end)hb=cd/2-150;nc("Glide Re-Entry","Cancel Glide Re-Entry",ns,nr,ha+ns+20,hb,function()return b5 end,function()c3=1;nw(1)end,function()return iO.hasAtmosphere and not c7 end)hb=hb+nr+20;nc("Parachute Re-Entry","Cancel Parachute Re-Entry",ns,nr,ha+ns+20,hb,function()return b5 end,function()c3=2;nw(1)end,function()return iO.hasAtmosphere and not c7 end)hb=hb+nr+20;nc("Engage Follow Mode","Disable Follow Mode",ns,nr,ha,hb,function()return bT end,nC,function()return i4()==1 end)nc("Enable Repair Arrows","Disable Repair Arrows",ns,nr,ha+ns+20,hb,function()return iF end,function()iF=not iF;if iF then bV="Repair Arrows Enabled"else bV="Repair Arrows Diabled"end end,function()return i4()==1 end)hb=hb+nr+20;if not q then nc("Enable AGG","Disable AGG",ns,nr,ha,hb,function()return cJ end,cn.ToggleAntigrav,function()return antigrav~=nil end)end;nc(function()return d7("Switch IPH Mode - Current: %s",bx)end,function()return d7("IPH Mode: %s",bx)end,ns*2,nr,ha,hb,function()return false end,function()if bx=="All"then bx="Custom Only"elseif bx=="Custom Only"then bx="No Moons"else bx="All"end;bV="IPH Mode: "..bx end)hb=hb+nr+20;nc(function()return d7("Toggle Control Scheme - Current: %s",g)end,function()return d7("Control Scheme: %s",g)end,ns*2,nr,ha,hb,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bV="New Control Scheme: "..g end)local nO=iQ(20)local nM=n8(0,0,iP(70),nO,"HELP")nM=n8(nM.x+nM.width,nM.y,iP(80),nO,"INFO")nM=n8(nM.x+nM.width,nM.y,iP(70),nO,"ORBIT")nM=n8(nM.x+nM.width,nM.y,iP(70),nO,"SCOPE")n8(nM.x+nM.width,nM.y,iP(70),nO,"HIDE")end;local nP={}local nQ=nil;function nP.HUDPrologue(jy)cO,cP=iM(cH)if not cO then iw=af;ix=ag;iy=ah;if i0 and G and i0.getState()==0 then i0.toggle()end else iw=ac;ix=ad;iy=ae;if i0 and G and i0.getState()==1 then i0.toggle()end end;iz=[[rgb(]]..bG(iw+0.6)..","..bG(ix+0.6)..","..bG(iy+0.6)..[[)]]iA=[[rgb(]]..bG(iw*0.8+0.5)..","..bG(ix*0.8+0.5)..","..bG(iy*0.8+0.5)..[[)]]local nR=iz;local nS=iA;local nT=[[rgb(]]..bG(iw*0.4+0.5)..","..bG(ix*0.4+0.5)..","..bG(iy*0.4+0.5)..[[)]]local nU=iz;local nV=iA;local nW=nT;if iR()and not m then nR=[[rgb(]]..bG(iw*0.5+0.5)..","..bG(ix*0.5+0.5)..","..bG(iy*0.5+0.5)..[[)]]nS=[[rgb(]]..bG(iw*0.3+0.5)..","..bG(ix*0.3+0.5)..","..bG(iy*0.2+0.5)..[[)]]nT=[[rgb(]]..bG(iw*0.2+0.5)..","..bG(ix*0.2+0.5)..","..bG(iy*0.2+0.5)..[[)]]end;local lq=iP;local lr=iQ;jy[#jy+1]=d7([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nR,nR,nR,nU,nU,nS,nS,nV,nV,nS,nR,nT,nV,nR,nR,nT,nT,nW,nT,cc,cd,nS,nS,nS,nS,nS,nU,nS,nV,nW,nV,nV,nW)if not nQ then nQ=d7([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lq(630),lr(0),lq(675),lr(45),lq(960),lr(55),lq(1245),lr(45),lq(1290),lr(0),lq(1000),lr(105),lq(1040),lr(59),lq(1250),lr(51),lq(1300),lr(0),lq(1920),lr(0),lq(1920),lr(20),lq(1400),lr(20),lq(1300),lr(105),lq(920),lr(105),lq(880),lr(59),lq(670),lr(51),lq(620),lr(0),lq(0),lr(0),lq(0),lr(20),lq(520),lr(20),lq(620),lr(105),lq(890),lr(59),lq(960),lr(62),lq(1030),lr(59),lq(985),lr(112),lq(1150),lr(112),lq(1100),lr(152),lq(820),lr(152),lq(780),lr(112),lq(935),lr(112),lq(890),lr(59),lq(960),lr(62),lq(1030),lr(59),lq(985),lr(112),lq(1150),lr(112),lq(1100),lr(152),lq(820),lr(152),lq(780),lr(112),lq(935),lr(112))end;if x and I then jy[#jy+1]=nQ end;return jy end;function nP.DrawVerticalSpeed(jy,dS)jx(jy,dS)end;function nP.UpdateHud(jy)local km=cL;local nX=cM;local jF=nX;local jV=km;local kE=bG(c.getThrottle())local kJ=cE*3.6;local kF=c.getAxisCommandValue(0)local nY=iP(1770)local nZ=iQ(310)if u and cK then kF=bJ;kE=bJ*100 end;local iT=iS()local jG="ROLL"if kE==nil then kE=0 end;if not cR then if cE>5 then km=kl(cC)nX=kn(cC)else km=0;nX=0 end;jG="YAW"end;if cP>50000 and not c7 then local n_;n_=ia(cP)jy[#jy+1]=gz(nY,nZ,"PvP Boundary: "..n_,"pbright txtbig txtmid")end;jy[#jy+1]=iD;jy[#jy+1]=iu;jy[#jy+1]=hX;if iq~=""then jy[#jy+1]=iq end;if iU~=""then jy[#jy+1]=iU end;if iV~=""then jy[#jy+1]=iV end;jx(jy,c9)if i4()==0 or l then if cR then jE(jy,ai,aj,jF,jG,cR)else jE(jy,ai,aj,nX,jG,cR)end;if not iR()or m then if cR then jE(jy,ai,aj,jF,jG,cR)jU(jy,jV,jF,ai,aj,cR,bG(kn(cC)),cE)else jE(jy,ai,aj,nX,jG,cR)jU(jy,km,nX,ai,aj,cR,bG(nX),cE)end;k0(jy,c9,cR)ko(jy,cC,cE,ai,aj)end end;kD(jy,iT,kE,kF)kI(jy,kJ)kM(jy)lK(jy)if not io and bU then lC(jy)end;return jy end;function nP.HUDEpilogue(jy)jy[#jy+1]="</svg>"return jy end;function nP.ExtraData(jy)local o0=iP(1240)local o1=iQ(55)local o2=o1+10;local gq;local lq=iP;local lr=iQ;local o3=0;local iT=iS()if aX then iT=iT.."-VERTICAL"end;if F and not b4 and not b3 and cE>20 then iT=iT.."-COLLISION ON"end;if bz~="Off"then iT="("..bz..")-"..iT end;if b1 then iT="TB-"..iT end;if not by then iT=iT.."-DeCoupled"end;local o4=lr(99)local o5=lr(80)local o6=lr(85)local o7=lr(31)local o8=0;local o9=0;local oa=ca>1000000 and i7(ca/1000000,2).."kT"or i7(ca/1000,2).."T"if c7 then o3=br else o3=bp end;local ob,oc=ci.computeDistanceAndTime(cE,0,ca,0,0,o3)if ob<0 then ob=0 end;o3=i7(o3/(ca*ie),2).."g"local od=d:maxForceForward()gq=b.g()if gq>0.1 then o9=ca*gq;o9=i7(o9/(ca*ie),2).."g"o8=0.5*od/gq;o8=o8>1000000 and i7(o8/1000000,2).."kT"or i7(o8/1000,2).."T"end;od=i7(od/(ca*ie),2).."g"local oe=vec3(b.getWorldAcceleration()):len()/9.80665;gq=b.g()jy[#jy+1]=[[<g class="dim txt txtend size14">]]if i4()==1 and not l then o0=iP(1120)o1=iQ(55)o2=o1+10 elseif c7 and I then local of=iP(770)jy[#jy+1]=gz(lq(895),o4,"ATMO","")jy[#jy+1]=d7([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lq(895),o6,lq(-80))jy[#jy+1]=gz(lq(815),o5,d7("%.1f%%",c8*100),"txtstart size20")end;if I then jy[#jy+1]=gz(lq(1025),o4,"GRAVITY","txtstart")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1025),o6,lq(80))jy[#jy+1]=gz(lq(1105),o5,d7("%.2fg",gq/9.80665),"size20")jy[#jy+1]=gz(lq(1125),o4,"ACCEL","txtstart")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1125),o6,lq(80))jy[#jy+1]=gz(lq(1205),o5,d7("%.2fg",oe),"size20")jy[#jy+1]=gz(lq(695),o4,"BRK TIME","")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(695),o6,lq(-80))jy[#jy+1]=gz(lq(615),o5,d7("%s",ib(oc)),"txtstart size20")jy[#jy+1]=gz(lq(635),lr(45),"TRIP","")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(635),lr(31),lq(-90))if lk then jy[#jy+1]=gz(lq(545),lr(26),d7("%s",ib(lk)),"txtstart size20")end;jy[#jy+1]=gz(lq(795),o4,"BRK DIST","")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(795),o6,lq(-80))jy[#jy+1]=gz(lq(715),o5,d7("%s",ia(ob)),"txtstart size20")jy[#jy+1]=gz(lq(1285),lr(45),"MASS","txtstart")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1285),lr(31),lq(90))jy[#jy+1]=gz(lq(1375),lr(26),d7("%s",oa),"size20")jy[#jy+1]=gz(lq(1220),o4,"THRUST","txtstart")jy[#jy+1]=d7([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1220),o6,lq(80))jy[#jy+1]=gz(lq(1300),o5,d7("%s",od),"size20")jy[#jy+1]=gz(iP(960),iQ(175),iT,"pbright txtbig txtmid size20")end;jy[#jy+1]="</g>"end;local og=1-(a6*0.05+a7*0.05)function nP.FuelUsed(oh)local oi;if oh=="atmofueltank"then oi=d7("Atmo Fuel Used: %.1f L",ja[oh]/(4*og))elseif oh=="spacefueltank"then oi=d7("Space Fuel Used: %.1f L",ja[oh]/(6*og))else oi=d7("Rocket Fuel Used: %.1f L",ja[oh]/(0.8*og))end;return oi end;function nP.DrawOdometer(jy,iB,bk,iC)if bD~="INFO"then return jy end;local gq;local o8=0;local o9=0;local o3=0;local oa=ca>1000000 and i7(ca/1000000,2).." kTons"or i7(ca/1000,2).." Tons"if c7 then o3=br else o3=bp end;local ob,oc=ci.computeDistanceAndTime(cE,0,ca,0,0,o3)o3=i7(o3/(ca*ie),2).." g"local od=d:maxForceForward()gq=b.g()if gq>0.1 then o9=ca*gq;o9=i7(o9/(ca*ie),2).." g"o8=0.5*od/gq;o8=o8>1000000 and i7(o8/1000000,2).." kTons"or i7(o8/1000,2).." Tons"end;od=i7(od/(ca*ie),2).." g"if i4()==0 or l then local oj=iP(aw+10)local ok=iQ(ax+20)local ol=iP(aw+10+av/1.25)local na=25;jy[#jy+1]="<g class='txtstart size14 bright'>"jy[#jy+1]=gz(oj,ok,d7("BrkTime: %s",ib(oc)))jy[#jy+1]=gz(ol,ok,d7("Trip: %.2f km",iB))jy[#jy+1]=gz(oj,ok+na,d7("Lifetime: %.2f kSU",bk/200000))jy[#jy+1]=gz(ol,ok+na,d7("BrkDist: %s",ia(ob)))jy[#jy+1]=gz(oj,ok+na*2,"Trip Time: "..ib(iC))jy[#jy+1]=gz(ol,ok+na*2,"Total Time: "..ib(bl))jy[#jy+1]=gz(oj,ok+na*3,d7("Mass: %s",oa))jy[#jy+1]=gz(ol,ok+na*3,d7("Max Brake: %s",o3))jy[#jy+1]=gz(oj,ok+na*4,d7("Max Thrust: %s",od))if gq>0.1 then jy[#jy+1]=gz(ol,ok+na*4,d7("Max Thrust Mass: %s",o8))jy[#jy+1]=gz(oj,ok+na*5,d7("Req Thrust: %s",o9))else jy[#jy+1]=gz(ol,ok+na*4,"Max Mass: n/a")jy[#jy+1]=gz(oj,ok+na*5,"Req Thrust: n/a")end;jy[#jy+1]=gz(ol,ok+na*5,cl.FuelUsed("atmofueltank"))jy[#jy+1]=gz(oj,ok+na*6,cl.FuelUsed("spacefueltank"))jy[#jy+1]=gz(ol,ok+na*6,cl.FuelUsed("rocketfueltank"))if cE>833 then local om=ca/math.sqrt(1-(cE/8333.33)^2)local oa=om>1000000 and i7(om/1000000,2).." kTons"or i7(om/1000,2).." Tons"jy[#jy+1]=gz(ol,ok+na*7,d7("Rel. Mass: %s",oa))end end;jy[#jy+1]="</g></g>"return jy end;function nP.DrawWarnings(jy)return kM(jy)end;function nP.DisplayOrbitScreen(jy)return lK(jy)end;function nP.DisplayMessage(jy,l7)if l7~="empty"then local hb=310;for on in string.gmatch(l7,"([^\n]+)")do hb=hb+35;jy[#jy+1]=gz("50%",hb,on,"msg")end end;if bW~=0 then c.setTimer("msgTick",bW)bW=0 end end;function nP.DrawDeadZone(jy)jy[#jy+1]=d7([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function nP.UpdatePipe()if c7 then iq=""return end;m_()end;function nP.DrawSettings(jy)local ha=iP(640)local hb=iQ(200)jy[#jy+1]=[[<g class="pbright txtvspd txtstart">]]local hE=0;for dy,dj in pairs(ip)do hE=hE+1;jy[#jy+1]=gz(ha,hb,dy..": "..dj.get())hb=hb+20;if hE%12==0 then ha=ha+iP(350)hb=iQ(200)end end;jy[#jy+1]=gz(iP(640),iQ(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jy[#jy+1]="</g>"return jy end;local hU=iP(1770)local hV=iQ(350)local hT=iQ(15)local hS=iP(1370)local hY,oo;function nP.DrawRadarInfo()hX=co.GetRadarHud(hS,hT,hU,hV)end;function nP.DrawTanks()if aq~=0 and ar~=0 then iU=gz(aq,ar,"","txtstart pdim txtfuel")jb=ar;jc(aq,"Atmospheric ","ATMO",ce,j8,j9)jc(aq,"Space Fuel T","SPACE",cf,j6,j7)jc(aq,"Rocket Fuel ","ROCKET",cg,j4,j5)end end;function nP.DrawShield()local op=i0.getState()==1 and"Shield Active"or"Shield Disabled"local oq=b.getPvPTimer()local os=i0.getResistances()local ot="A: "..10+os[1]*100 .."% / E: "..10+os[2]*100 .."% / K:"..10+os[3]*100 .."% / T: "..10+os[4]*100 .."%"local ha,hb=as-60,at+30;local ou=bG(0.5+i0.getShieldHitpoints()*100/i0.getMaxShieldHitpoints())local jq=bG(ou*2.55)local jr=d7("rgb(%d,%d,%d)",255-jq,jq,0)local js=""iV=gz(ha,hb,"","txtmid pdim txtfuel")if ou<10 and op~="Shield Disabled"then js="red "end;oq=oq>0 and"   PvPTime: "..ib(oq)or""iV=iV..d7([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ha,hb,jr,ou*2,ha,hb,ha+2,hb+10,ou,oq)iV=iV..gz(ha,hb-5,op,js.."txtstart pbright txtbig")iV=iV..gz(ha,hb+30,ot,js.."txtstart pbright txtsmall")end;function nP.hudtick()if not iO then return end;local function ov(jy)local ju=bG(d8(c2/(cc/4)*255,0,255))jy[#jy+1]=d7("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c0,c1,bG(iw+0.5)+ju,bG(ix+0.5)-ju,bG(iy+0.5)-ju)end;local function ow()for dD,dj in pairs(ig)do if dj.hovered then if not dj.drawCondition or dj.drawCondition(dj)then dj.toggleFunction(dj)end;dj.hovered=false end end;for dD,dj in pairs(ij)do if dj.hovered then bD=dj.label;dj.hovered=false end end end;local function ox()local function oy(oz,oA,ha,hb,n9,na)if oz>=ha and oz<=ha+n9 and oA>=hb and oA<=hb+na then return true else return false end end;local ha=c0+cc/2;local hb=c1+cd/2;for dD,dj in pairs(ig)do dj.hovered=oy(ha,hb,dj.x,dj.y,dj.width,dj.height)end;for dD,dj in pairs(ij)do dj.hovered=oy(ha,hb,dj.x,dj.y,dj.width,dj.height)end;if cU then local mP=false;for dD,er in ipairs(nL)do if er.hovered then mP=true;break end end;if nI.hovered then mP=true end;cU=mP else cU=nI.hovered;if not cU then cV=bi end end end;local function oB(jy)if not bD or bD==""then bD="HELP"end;if x then for dy,dj in pairs(ij)do local js="dim brightstroke"local oC=0.2;if bD==dy then js="pbright dimstroke"oC=0.6 end;local oD=""if dj.hovered then oC=0.8;oD=";stroke:white"end;jy[#jy+1]=d7([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dj.width,dj.height,dj.x,dj.y,js,oC,oD)jy[#jy+1]=gz(dj.x+dj.width/2,dj.y+dj.height/2+5,dj.label,"txt txtmid pdim")end end end;local function oE(jy)local function oF(jy,oG,hover,ha,hb,f7,oH,oI,oJ,oK,oL,nM)if type(oK)=="function"then oK=oK(nM)end;if type(oL)=="function"then oL=oL(nM)end;jy[#jy+1]=d7("<rect x='%f' y='%f' width='%f' height='%f' fill='",ha,hb,f7,oH)if oG then jy[#jy+1]=d7("%s'",oI)else jy[#jy+1]=oJ end;if hover then jy[#jy+1]=d7(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jy[#jy+1]=d7(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",i7(ac*0.5,0),i7(ad*0.5,0),i7(ae*0.5,0))end;jy[#jy+1]=" rx='5'></rect>"jy[#jy+1]=d7("<text x='%f' y='%f' font-size='24' fill='",ha+f7/2,hb+oH/2+5)if oG then jy[#jy+1]="black"else jy[#jy+1]="white"end;jy[#jy+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oG then jy[#jy+1]=d7("%s</text>",oK)else jy[#jy+1]=d7("%s</text>",oL)end end;local oM=d7("rgb(%d,%d,%d)'",i7(ac*0.1,0),i7(ad*0.1,0),i7(ae*0.1,0))local oN=d7("rgb(%d,%d,%d)",i7(ac*0.8,0),i7(ad*0.8,0),i7(ae*0.8,0))local oO=oF;for dD,dj in pairs(ig)do local ne=dj.disableName;local nd=dj.enableName;if type(ne)=="function"then ne=ne(dj)end;if type(nd)=="function"then nd=nd(dj)end;if not dj.drawCondition or dj.drawCondition(dj)then oO(jy,dj.toggleVar(dj),dj.hovered,dj.x,dj.y,dj.width,dj.height,oN,oM,ne,nd,dj)end end end;local oP=i7(cc/2,0)local oQ=i7(cd/2,0)local jy={}cl.HUDPrologue(jy)if x then cl.UpdateHud(jy)else if B then cl.DrawVerticalSpeed(jy,c9)end;cl.DrawWarnings(jy)end;if io and ip~="none"then cl.DrawSettings(jy)end;if radar_1 then cl.DrawRadarInfo()end;cl.HUDEpilogue(jy)jy[#jy+1]=d7([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cc,cd)if bV~="empty"then cl.DisplayMessage(jy,bV)end;if i4()==0 and g=="virtual joystick"then if w then cl.DrawDeadZone(jy)end end;oB(jy)if i6()==0 then if i4()==1 and bU then if not oR then ox()oE(jy)end;if not cq and not cr then local oS=table.concat(jy,"")jy={}jy[#jy+1]=d7("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jy[#jy+1]=oS;jy[#jy+1]="</body>"cq=true;jy[#jy+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oT=table.concat(jy,"")a.setScreen(oT)elseif cr then local oS=table.concat(jy,"")jy={}jy[#jy+1]=d7("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jy[#jy+1]=oS;jy[#jy+1]="</body>"end;if not cq then jy[#jy+1]=d7([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oP,oQ,c0,c1)end else ow()end else if not bU and i4()==0 then ow()if c2>au then if w then ov(jy)end end elseif bU and(not oR or not i)then ox()oE(jy)end;jy[#jy+1]=d7([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oP,oQ,c0,c1)end;jy[#jy+1]=[[</svg></body>]]oT=table.concat(jy,"")end;function nP.TenthTick()local function oU()local oV=a.createData;local oW=a.createWidget;oX=a.createWidgetPanel("Interplanetary Helper")oY=oW(oX,"value")oZ=oV('{"label": "Target Planet", "value": "N/A", "unit":""}')fI(oZ,oY)o_=oW(oX,"value")p0=oV('{"label": "distance", "value": "N/A", "unit":""}')fI(p0,o_)ga=oW(oX,"value")g9=oV('{"label": "Travel Time", "value": "N/A", "unit":""}')fI(g9,ga)g8=oW(oX,"value")g7=oV('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fI(g7,g8)gc=oW(oX,"value")gb=oV('{"label": "Target Altitude", "value": "N/A", "unit":""}')fI(gb,gc)g4=oW(oX,"value")g3=oV('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g2=oW(oX,"value")g1=oV('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g0=oW(oX,"value")f_=oV('{"label": "Max Brake distance", "value": "N/A", "unit":""}')fZ=oW(oX,"value")fY=oV('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g6=oW(oX,"value")g5=oV('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c7 then fI(g3,g4)fI(g1,g2)fI(f_,g0)fI(fY,fZ)fI(g5,g6)end end;local function p1()gy(oX)oX=nil end;local function p2()if not b0 then if fU==nil or fU.planetname~=iO.name then p3=(b_.center-cH):len()else p3=(fU.position-cH):len()end end;local fe=cE;local p4=c.getThrottle()/100;if u then p4=bJ end;local p5,p6=ci.computeDistanceAndTime(cE,a0,ca,d:maxForceForward()*p4,a2,0)local bY,bZ;if not b1 then bY,bZ=cn.GetAutopilotBrakeDistanceAndTime(a0)else bY,bZ=cn.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dD,p7;if not b1 and fe>0 then dD,p7=cn.GetAutopilotBrakeDistanceAndTime(fe)else dD,p7=cn.GetAutopilotTBBrakeDistanceAndTime(fe)end;local p8=0;local p9=0;if bb or not b0 and fe>5 then p9=ci.computeTravelTime(fe,0,p3)elseif bY+p5<p3 then p8=p3-(bY+p5)p9=ci.computeTravelTime(8333.0556,0,p8)else local pa=(p3-bY)/p5;p5=p3-bY;p6=p6*pa end;if fU~=nil and fU.planetname==iO.name and not b0 then return p9 elseif ba then return p7 elseif bb then return p9+p7 else return p6+bZ+p9 end end;cl.DrawTanks()if i0 then cl.DrawShield()end;if bg~="None"then if oX==nil then oU()end;if bg~=nil then local pb=fU~=nil;local pc=0.5*br/b_:getGravity(b_.center+vec3(0,0,1)*b_.radius):len()pc=pc>1000000 and i7(pc/1000000,2).." kTons"or i7(pc/1000,2).." Tons"fH(oZ,'{"label": "Target", "value": "'..bg..'", "unit":""}')lk=p2()if pb and not b0 then c2=(cH-fU.position):len()else c2=(bh-cH):len()end;if not b1 then bY,bZ=cn.GetAutopilotBrakeDistanceAndTime(cE)is,it=cn.GetAutopilotBrakeDistanceAndTime(a0)else bY,bZ=cn.GetAutopilotTBBrakeDistanceAndTime(cE)is,it=cn.GetAutopilotTBBrakeDistanceAndTime(a0)end;local l7=ia(c2)fH(p0,'{"label": "distance", "value": "'..l7 ..'"}')fH(g9,'{"label": "Travel Time", "value": "'..ib(lk)..'", "unit":""}')l7=ia(bY)fH(g3,'{"label": "Cur Brake distance", "value": "'..l7 ..'"}')fH(g1,'{"label": "Cur Brake Time", "value": "'..ib(bZ)..'", "unit":""}')l7=ia(is)fH(f_,'{"label": "Max Brake distance", "value": "'..l7 ..'"}')fH(fY,'{"label": "Max Brake Time", "value": "'..ib(it)..'", "unit":""}')fH(g7,'{"label": "Max Brake Mass", "value": "'..d7("%s",pc)..'", "unit":""}')l7=ia(gd)fH(gb,'{"label": "Target Orbit", "value": "'..l7 ..'"}')if c8>0 and not pd then a.removeDataFromWidget(fY,fZ)a.removeDataFromWidget(f_,g0)a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)pd=true;if not cK and u and(b2 or b5 or c5)then cn.cmdThrottle(1)aY=false;bN=false end end;if c8==0 and pd then if fH(fY,fZ)==1 then fI(fY,fZ)end;if fH(f_,g0)==1 then fI(f_,g0)end;if fH(g1,g2)==1 then fI(g1,g2)end;if fH(g3,g4)==1 then fI(g3,g4)end;if fH(g5,g6)==1 then fI(g5,g6)end;pd=false end end else p1()end;if warpdrive~=nil then if i2(warpdrive.getData()).destination~="Unknown"and i2(warpdrive.getData()).distance>400000 then warpdrive.show()pe=true else warpdrive.hide()pe=false end end end;function nP.OneSecondTick()local function pf()local jm=bF()local kJ=cE;local pg=jm-iE;if kJ>1.38889 then kJ=kJ/1000;local ph=kJ*(jm-iE)bk=bk+ph;iB=iB+ph end;iC=iC+pg;bl=bl+pg;iE=jm end;local function pi(jy)local pj=0;iu=""local pk=id;local pl=0;local pm=0;local pn=0;local jq=0;local jr=""local po=b.getElementHitPointsById;local pp=b.getElementMaxHitPointsById;local pq={}for dy in pairs(ic)do local pr=0;local ps=0;ps=pp(ic[dy])pr=po(ic[dy])pl=pl+pr;if pr<ps then if pr==0 then pn=pn+1 else pm=pm+1 end;if iF and#pq==0 then fL=vec3(b.getElementPositionById(ic[dy]))local ha=fL.x;local hb=fL.y;local hc=fL.z;table.insert(pq,b.spawnArrowSticker(ha,hb,hc+1,"down"))table.insert(pq,b.spawnArrowSticker(ha,hb,hc+1,"down"))b.rotateSticker(pq[2],0,0,90)table.insert(pq,b.spawnArrowSticker(ha+1,hb,hc,"north"))table.insert(pq,b.spawnArrowSticker(ha+1,hb,hc,"north"))b.rotateSticker(pq[4],90,90,0)table.insert(pq,b.spawnArrowSticker(ha-1,hb,hc,"south"))table.insert(pq,b.spawnArrowSticker(ha-1,hb,hc,"south"))b.rotateSticker(pq[6],90,-90,0)table.insert(pq,b.spawnArrowSticker(ha,hb-1,hc,"east"))table.insert(pq,b.spawnArrowSticker(ha,hb-1,hc,"east"))b.rotateSticker(pq[8],90,0,90)table.insert(pq,b.spawnArrowSticker(ha,hb+1,hc,"west"))table.insert(pq,b.spawnArrowSticker(ha,hb+1,hc,"west"))b.rotateSticker(pq[10],-90,0,90)table.insert(pq,ic[dy])end elseif iF and#pq>0 and pq[11]==ic[dy]then for jl in pairs(pq)do b.deleteSticker(pq[jl])end;pq={}end end;pj=bG(pl/pk*100)if pj<100 then jy[#jy+1]=gz(0,0,"","pbright txt")jq=bG(pj*2.55)jr=d7("rgb(%d,%d,%d)",255-jq,jq,0)if pj<100 then jy[#jy+1]=gz("50%",1035,"Elemental Integrity: "..pj.."%","txtbig txtmid","fill:"..jr)if pn>0 then jy[#jy+1]=gz("50%",1055,"Disabled Modules: "..pn.." Damaged Modules: "..pm,"txtbig txtmid","fill:"..jr)elseif pm>0 then jy[#jy+1]=gz("50%",1055,"Damaged Modules: "..pm,"txtbig txtmid","fill:"..jr)end end end end;local function pt()if i1 then if iv==nil and(d1~=nil or bj)then _autoconf.displayCategoryPanel(i1,weapon_size,"Weapons","weapon",true)iv=_autoconf.panels[_autoconf.panels_size]elseif iv~=nil and d1==nil and not bj then gy(iv)iv=nil end end end;cW=b.getPlayersOnBoard()cX=b.getDockedConstructs()local jy={}pf()if s then pi(jy)end;pt()cl.UpdatePipe()cl.ExtraData(jy)iD=table.concat(jy,"")collectgarbage("collect")end;function nP.AnimateTick()cr=true;cq=false;c0=0;c1=0;c.stopTimer("animateTick")end;function nP.MsgTick()local jy={}cl.DisplayMessage(jy,"empty")bV="empty"c.stopTimer("msgTick")bW=3 end;function nP.ButtonSetup()np()nu()ig=ih end;return nP end;local function pu(d,b,c,a,e,vBooster,hover,pv,antigrav,warpdrive,dbHud_1,eN,bG,bH,i4,eI,bF,d8,i5,fH,i6,da,i7,fJ,i8,db,ia,ib,pw,i2,d7,fI)local px={}local function py(fe)local pz=bc;if not b0 then pz=0 end;if not c7 then return ci.computeDistanceAndTime(fe,pz,ca,0,0,bp-be*ca)else if br and br>0 then return ci.computeDistanceAndTime(fe,pz,ca,0,0,br-be*ca)else return 0,0 end end end;local function pA(fe)local pz=bc;if not b0 then pz=0 end;return ci.computeDistanceAndTime(fe,pz,ca,d:maxForceForward(),a2,bp-be*ca)end;local pB=false;local pC=0;local pD=0;local pE=0;local pF=bF()local pG=0;local pH=0;local pI=0;local pJ=0;local pK=false;local pL=false;local pM=false;local pN=nil;local pO=0;local pP={}local ir=55;local pQ=nil;local pR=false;local pS=false;local pT=false;local pU=0;local pV=0;local pW=0;local pX=0;local pY=0;local pZ=0;local p_={VectorToTarget=false}local q0=vec3(b.getConstructWorldOrientationUp())local q1=nil;local q2=""function px.clearAll()b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"aZ=false;a_=false;cQ=nil;b2=false;b5=false;b3=false;aY=false;b4=false;b6=false;bT=false;pS=false;c3=false;c4=false;pT=false;cs=p;bn=false;b1=false;cb=false;bq=nil;bw=false;d4=false;d5=nil end;function px.GetAutopilotBrakeDistanceAndTime(fe)return py(fe)end;function px.GetAutopilotTBBrakeDistanceAndTime(fe)return pA(fe)end;local function q3(q4,q5,q6)q5=q5:project_on_plane(q4)q6=q6:project_on_plane(q4)return eI(q5:cross(q6):dot(q4),q5:dot(q6))end;local function q7()local function q8()local q9=-1;local qa=-1;if vBooster then q9=vBooster.getDistance()end;if hover then qa=hover.getDistance()end;if q9~=-1 and qa~=-1 then if q9<qa then return q9 else return qa end elseif q9~=-1 then return q9 elseif qa~=-1 then return qa else return-1 end end;local qb=q8()local qc=-1;if pv then qc=pv.getDistance()end;if qb~=-1 and qc~=-1 then if qb<qc then return qb else return qc end elseif qb~=-1 then return qb else return qc end end;local function qd(iO,ez,qe)local function qf(qg,dK)local eF=vec3(dK)if qg.id==0 then return setmetatable({latitude=eF.x,longitude=eF.y,altitude=eF.z,id=0,systemId=qg.systemId},dM)end;local eG=eF-qg.center;local c2=eG:len()local dS=c2-qg.radius;local dQ=0;local dR=0;if not db(c2,0)then local eH=eI(eG.y,eG.x)dR=eH>=0 and eH or 2*math.pi+eH;dQ=math.pi/2-math.acos(eG.z/c2)end;return setmetatable({latitude=math.deg(dQ),longitude=math.deg(dR),altitude=dS,id=qg.id,systemId=qg.systemId},dM)end;local qh=qf(iO,ez)qh="::pos{"..qh.systemId..","..qh.id..","..qh.latitude..","..qh.longitude..","..qh.altitude.."}"if qe then return qh else a.setWaypoint(qh)return true end end;local qi=false;function px.showWayPoint(iO,ez,qe)return qd(iO,ez,qe)end;function px.APTick()local function qj()if cT and not b3 then local eg=cT[1]local hJ,hK=cT[2],cT[3]local qk=math.min(hJ,hK or hJ)local ql=qk/cE;local qm=b4 and(cE<42 or c6~=-1)local qn=b2 or bn or bq or b0;if qn and not qm and(bY*1.5>qk or ql<1)then aY=true;pP={}cn.cmdThrottle(0)if b2 then cn.ToggleAltitudeHold()end;if bq then cn.ToggleLockPitch()end;bV="Autopilot Cancelled due to possible collision"if bn or b0 then cn.ToggleAutopilot()end;le=true;b3=true;cs=true end;if ql<11 then cS=eg.name.." COLLISION "..ib(ql).." / "..ia(qk,2)else cS=eg.name.." collision "..ib(ql)end;if ql<6 then fJ("alarm","AL",2)end else cS=false end end;local function qo(qp,qq,qr)local function qs(qp,ei)qp=vec3(qp)ei=vec3(ei):normalize()local dt=qp*ei;return dt.x+dt.y+dt.z end;local qt=0.001;local qu=1;if not c7 or not ct or c6~=-1 or cE<ir then if qr==nil then qr=aO end;if qq==nil then qq=qt end;qp=vec3(qp):normalize()local qv=vec3()-qp;local qw=-qs(qv,b.getConstructWorldOrientationRight())*qu;local qx=-qs(qv,b.getConstructWorldOrientationUp())*qu;if pD==0 then pD=qw/2 end;if pE==0 then pE=qx/2 end;if eN(qw)<0.1 then pV=pV-qw*2 else pV=pV-(qw+(qw-pD)*qr)end;if eN(qx)<0.1 then pU=pU+qx*2 else pU=pU+qx+(qx-pE)*qr end;pD=qw;pE=qx;if eN(qw)<qq and eN(qx)<qq then return true end;return false elseif ct and c6==-1 then qp=cD;if qr==nil then qr=aO end;if qq==nil then qq=qt end;qp=vec3(qp):normalize()local qv=cA-qp;local qw=-qs(qv,b.getConstructWorldOrientationRight())*qu;local qx=-qs(qv,b.getConstructWorldOrientationUp())*qu;if pD==0 then pD=qw/2 end;if pE==0 then pE=qx/2 end;if eN(qw)<0.1 then pV=pV-qw*5 else pV=pV-(qw+(qw-pD)*qr)end;if eN(qx)<0.1 then pU=pU+qx*5 else pU=pU+qx+(qx-pE)*qr end;pD=qw;pE=qx;if eN(qw)<qq and eN(qx)<qq then return true end;return false end end;c7=bH()>0;c8=bH()c9=b.getAltitude()c6=q7()bI=bF()pF=bI;if F then qj()end;if antigrav then cJ=antigrav.getState()==1 end;local qy=a.getMouseWheel()if qy>0 then cn.changeSpd()elseif qy<0 then cn.changeSpd(true)else pR=true end;local qz=1;local qA=1;local qB=bI-pF;local qC=-math.deg(q3(q0,cD,cA))local qD=math.deg(q3(cB,cD,cA))local gf=cF*-1;ct=c7 and qC<-M or qC>M or qD<-N or qD>N;local qE=a.getMouseDeltaX()local qF=a.getMouseDeltaY()if o and not bU then qF=-qF end;pV=0;pX=0;pU=0;fM=ch[0]iO=fM:closestBody(b.getConstructWorldPos())qG=ck(iO)fi=qG:orbitalParameters(b.getConstructWorldPos(),cD)if c9==0 then c9=(cH-iO.center):len()-iO.radius end;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;local gq=iO:getGravity(b.getConstructWorldPos()):len()*ca;pY=0;cj=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if i6()==0 then if i4()==1 and bU then if not cq then c0=d8(c0+qE,-cc/2,cc/2)c1=d8(c1+qF,-cd/2,cd/2)end else c0=0;c1=0 end else c0=d8(c0+qE,-cc/2,cc/2)c1=d8(c1+qF,-cd/2,cd/2)c2=da(c0*c0+c1*c1)if not bU and i4()==0 then local kv,kw=1,1;if bD=="SCOPE"then kv,kw=cZ/90,cZ/90 end;if g=="virtual joystick"then if c0>0 and c0>au then pV=pV-(c0-au)*aC*kv elseif c0<0 and c0<au*-1 then pV=pV-(c0+au)*aC*kv else pV=0 end;if c1>0 and c1>au then pU=pU-(c1-au)*aD*kw elseif c1<0 and c1<au*-1 then pU=pU-(c1+au)*aD*kw else pU=0 end else c0=0;c1=0;if g=="mouse"then pU=(-utils.smoothstep(qF,-100,100)+0.5)*2*qz;pV=(-utils.smoothstep(qE,-100,100)+0.5)*2*qA end end end end;local qH=cE>8334;if cE>W/3.6 and not c7 and not b0 and not qH then bV="Space Speed Engine Shutoff reached"cn.cmdThrottle(0)end;if not qH and qI then if not aY then cn.BrakeToggle()end;if b0 then cn.ToggleAutopilot()end end;qI=qH;if c7 and c8>0.09 then if cE>cu/3.6 and not u and not pB then aY=true;pB=true elseif not u and pB then if cE<cu/3.6 then aY=false;pB=false end end end;if aY then pW=1 else pW=0 end;if a_ then if c3 then aY=false;local qJ=false;if fU and c3==true then qJ=qo(fU.position-cH,0.1)else qJ=qo(vec3(cD),0.01)end;cs=true;if qJ then cn.cmdCruise(bG(cu))if(eN(cM)<2 or eN(cL)>85)and cE>=cu/3.6-1 then aY=false;a_=false;if c3~=2 then pT=true end;if c3==true then c5=true end;c3=false;b0=false;cn.BeginReentry()end elseif c7 and u then cn.cmdThrottle(1)end elseif cE>ir then qo(vec3(cD),0.01)end end;if aZ then if c7 then aZ=false elseif cE>ir then qo(-vec3(cD))end end;if not a_ and c3 and not bw then if c8==0 then if c3~=2 then pT=true end;cn.BeginReentry()c3=false;c5=true else c3=false;cn.ToggleAutopilot()end end;if c5 and fU and(c9<b7+250 and c9>b7-250)and cE*3.6>cu-250 and eN(cG)<25 and c8>=0.1 and(fU.position-cH):len()>2000+c9 then cn.ToggleAutopilot()c5=false end;if b6 then cs=true;local qK=b7;if cG<-30 then bV="Unable to achieve lift. Safety Landing."bS=0;cs=p;b6=false;b3=true elseif not q and cJ or b7<iO.spaceEngineMinAltitude then if cJ then qK=antigrav.getBaseAltitude()end;if c9<qK-100 then pZ=0;bS=15;aY=false elseif cG>0 then aY=true;bS=0 elseif cG<-30 then aY=true;bS=15 elseif c9>=qK then if cJ then if b0 or bn then cn.ToggleVerticalTakeoff()else aY=true;b6=false end;bV="Takeoff complete. Singularity engaged"fJ("aggLk","AG")else aY=false;bV="VTO complete. Engaging Horizontal Flight"fJ("vtoc","VT")cn.ToggleVerticalTakeoff()end;bS=0 end else if c8>0.08 then pZ=0;aY=false;bS=20 elseif c8<0.08 and c8>0 then aY=false;if cy then pZ=0;bS=20 else bS=0;pZ=36;cn.cmdCruise(3500)end else cs=p;bw=true;cx=false;qL=false;pK=false;pI=nil;pJ=nil;if pN==nil then pN=iO end;cw=qK;pM=true;b6=false end end;if pZ~=nil then if qM==nil then qM=pid.new(2*0.01,0,2*0.1)end;local qN=d8(pZ-cL,-N*0.80,N*0.80)qM:inject(qN)local qO=d8(qM:get(),-1,1)pU=qO end end;if bw then local qv;local qP=false;local qQ=ia(cw)if pN==nil then pN=iO;if bn then pN=b_ end end;if not pM then cw=bG(pN.radius+pN.surfaceMaxAltitude+U)if pN.hasAtmosphere then cw=bG(pN.radius+pN.noAtmosphericDensityAltitude+U)end;pM=true end;if p_.VectorToTarget and fU then qv=fU.position-cH end;local qR,qS=ck(pN):escapeAndOrbitalSpeed((cH-pN.center):len()-pN.radius)local qT=cM;if not pK then local qU=false;local qV=false;cn.cmdThrottle(0)pJ=0;cv="Aligning to orbital path - OrbitHeight: "..qQ;if p_.VectorToTarget then qo(qv:normalize():project_on_plane(cF))qP=cA:dot(qv:project_on_plane(q0):normalize())>0.95 else qo(cD)qP=qC<0.5;if cE<150 then qP=true end end;pU=0;pI=0;if cL<=pI+2 and cL>=pI-2 then qU=true else qU=false end;if qT<=pJ+2 and qT>=pJ-2 then qV=true else qV=false end;if qU and qV and qP then pI=nil;pJ=nil;pK=true end else if p_.VectorToTarget then qo(qv:normalize():project_on_plane(cF))elseif cE>150 then qo(cD)end;pU=0;if p_.VectorToTarget and fU then local bY,dD=ci.computeDistanceAndTime(cE,cu/3.6,ca,0,0,bp)if cx and qv:len()>15000+bY+c9 then cv="Orbiting to Target"if c9-100<=pN.noAtmosphericDensityAltitude or lk>fi.timeToPeriapsis and fi.periapsis.altitude<pN.noAtmosphericDensityAltitude then cx=false end elseif cx or qv:len()<15000+bY+c9 then bV="Orbit complete, proceeding with reentry"fJ("orCom","OB")bh=fU.position;pT=true;c5=true;p_.VectorToTarget,p_.AutopilotAlign=false,false;cn.ToggleIntoOrbit()cn.BeginReentry()return end end;if fi.periapsis~=nil and fi.apoapsis~=nil and fi.eccentricity<1 and c9>cw*0.9 and c9<cw*1.4 then if fi.apoapsis~=nil then if fi.periapsis.altitude>=cw*0.99 and fi.apoapsis.altitude>=cw*0.99 and fi.periapsis.altitude<fi.apoapsis.altitude and fi.periapsis.altitude*1.05>=fi.apoapsis.altitude or cx then if cx then aY=false;cn.cmdThrottle(0)pI=0;if not p_.VectorToTarget then bV="Orbit complete"fJ("orCom","OB")cn.ToggleIntoOrbit()end else pO=pO+1;if pO>=2 then cx=true end end else cv="Adjusting Orbit - OrbitHeight: "..qQ;pL=true;cn.cmdCruise(qS*3.6+1)local qW=cw-c9;if qX==nil then qX=pid.new(0.1,0,1*0.1)end;qX:inject(qW-cG*d8(utils.smoothstep(2000-qW,-2000,2000)^6*10,1,10))pI=d8(qX:get(),-60,60)end end else local qY=2.75;local qZ=eN(i7(qR*qY))local og=qZ%50;if og>0 then qZ=qZ-og+50 end;aY=false;if c9<cw*0.8 then cv="Escaping planet gravity - OrbitHeight: "..qQ;pI=utils.map(cG,200,0,-15,80)elseif c9>=cw*0.8 and c9<cw*1.15 then cv="Approaching orbital corridor - OrbitHeight: "..qQ;qZ=qZ*0.75;pI=utils.map(cG,100,-100,-15,65)elseif c9>=cw*1.15 and c9<cw*1.5 then cv="Approaching orbital corridor - OrbitHeight: "..qQ;qZ=qZ*0.75;if cG<0 or pL then pI=utils.map(c9,cw*1.5,cw*1.01,-30,0)else pI=utils.map(c9,cw*0.99,cw*1.5,0,30)end elseif c9>cw*1.5 then cv="Reentering orbital corridor - OrbitHeight: "..qQ;pI=-65;local q_=utils.map(cG,-150,-400,1,0.55)qZ=qZ*q_ end;cn.cmdCruise(bG(qZ))end end;if pI~=nil then if r0==nil then r0=pid.new(1*0.01,0,5*0.1)end;local r1=pI-cL;r0:inject(r1)local r2=d8(r0:get(),-0.5,0.5)pU=r2 end end;if b0 and c8==0 and not c3 then local function r3(hY,fi)a.print(hY)aY=false;ba=false;b0=false;r4=false;bd="Aligning"cn.cmdThrottle(0)pS=false;bV=hY;fJ("apCom","AP")if fi or c3 then if fi and gd~=nil and not c3 then if not c9 or c9==0 then return end;cw=c9;pM=true end;cn.ToggleIntoOrbit()end end;local r5,r6=bh,false;if fU and fU.planetname~="Space"then b9=true;if not r4 then local r7=(fU.position-b_.center):normalize()local r8=r7:project_on_plane((b_.center-cH):normalize()):normalize()local r9=b_.center+r8*(b_.radius+gd)local ra=fU.position+(fU.position-b_.center):normalize()*(gd-b_:getAltitude(fU.position))if(cH-r9):len()<(cH-ra):len()then r5=r9 else r5=ra;bc=0 end;bh=r5;cn.showWayPoint(b_,bh)r6=true;r4=true end;be=0 elseif fU and fU.planetname=="Space"then if not r4 then be=0;r6=true;b9=true;r4=true;r5=fU.position+(cH-fU.position):normalize()*S;bh=r5 end elseif fU==nil then be=0;if not r4 then local r7=(cH+cD*100000-b_.center):normalize()local r8=r7:project_on_plane((b_.center-cH):normalize()):normalize()if r8:len()<1 then r7=(cH+cA*100000-b_.center):normalize()r8=r7:project_on_plane((b_.center-cH):normalize()):normalize()end;r5=b_.center+r8*(b_.radius+gd)bh=r5;r4=true;r6=true;b9=true;cn.showWayPoint(b_,bh)end end;p3=(vec3(r5)-cH):len()local li,ex,ey=ch:getPlanetarySystem(0):castIntersections(cH,cD:normalize(),function(eg)if eg.noAtmosphericDensityAltitude>0 then return eg.radius+eg.noAtmosphericDensityAltitude else return eg.radius+eg.surfaceMaxAltitude*1.5 end end)local lj=ex;if ey~=nil and ex~=nil then lj=math.min(ey,ex)end;if lj~=nil and lj<p3 and li.name==b_.name then p3=lj end;local qJ=true;local rb=(b_.center-(cH+vec3(cD):normalize()*p3)):len()-b_.radius;local l7=ia(rb)fH(g5,'{"label": "Projected Altitude", "value": "'..l7 ..'"}')local bY,bZ;if not b1 then bY,bZ=py(cE)else bY,bZ=pA(cE)end;if cE>50 and b8 then local qv=vec3(r5)-cH;local rc=d8(math.deg(q3(q0,cD:normalize(),qv:normalize()))*cE/500,-90,90)local rd=d8(math.deg(q3(cB,cD:normalize(),qv:normalize()))*cE/500,-90,90)if eN(rc)<20 and eN(rd)<20 then rc=rc*2;rd=rd*2 end;if eN(rc)<2 and eN(rd)<2 then rc=rc*2;rd=rd*2 end;local qC=-math.deg(q3(q0,cA,cD:normalize()))local qD=-math.deg(q3(cB,cA,cD:normalize()))if re==nil then re=pid.new(2*0.01,0,2*0.1)end;re:inject(rd-qD)local rf=d8(re:get(),-1,1)pU=pU+rf;if rg==nil then rg=pid.new(2*0.01,0,2*0.1)end;rg:inject(rc-qC)local rh=d8(rg:get(),-1,1)pV=pV+rh;r6=true;if eN(rc)>2 or eN(rd)>2 then if bd~="Adjusting Trajectory"then bd="Adjusting Trajectory"fJ("apAdj","AP")end else if bd~="Accelerating"then bd="Accelerating"fJ("apAcc","AP")end end elseif b8 and cE<=50 then qo((r5-cH):normalize())end;if rb<gd*1.5 then if fU and fU.planetname=="Space"then bc=0 elseif fU==nil then dD,bc=ck(b_):escapeAndOrbitalSpeed(rb)end end;if b0 and not b8 and not bb and not ba then local li,lj=cn.checkLOS((bh-cH):normalize())if b_.name~=iO.name then if li~=nil and b_.name~=li.name and lj<p3 then bV="Collision with "..li.name.." in "..ia(lj).."\nClear LOS to continue."bW=5;qi=true else qi=false;bV=""end end end;if not qi then if not bb and not ba and not r6 then qJ=qo((r5-cH):normalize())elseif b1 and(ba or bb)then qJ=qo(-vec3(cD):normalize())end end;if b8 then if not pS then aY=false;cn.cmdThrottle(a1)bJ=i7(a1,2)pS=true end;local p4=c.getThrottle()if u then p4=bJ end;local ri=99999;local oe=-vec3(b.getWorldAcceleration()):dot(cD:normalize())local rj=d8(cD:dot((r5-cH):normalize()),0,cE)if rj>0 or oe>0 then ri=ci.computeTravelTime(rj,oe,p3-bY)end;if cC:len()>=a0 or p4==0 and pS or a2/4>ri then b8=false;if bd~="Cruising"then fJ("apCru","AP")bd="Cruising"end;bb=true;cn.cmdThrottle(0)end;local rk=p3;if rk<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pC and cP>2000 then cn.ToggleAutopilot()bV="Autopilot cancelled to prevent crossing PvP Line"aY=true;pC=cP else pC=cP;return end end;b8=false;if bd~="Braking"then fJ("apBrk","AP")bd="Braking"end;ba=true;cn.cmdThrottle(0)pS=false end elseif ba then if bd~="Orbiting to Target"then aY=true;pW=1 end;if b1 then cn.cmdThrottle(1,true)end;local dD,qS=ck(b_):escapeAndOrbitalSpeed((cH-iO.center):len()-iO.radius)local qv;if fU then qv=fU.position-cH end;if fU and fU.planetname=="Space"and cE<50 then if#pP>0 then aY=false;cn.ToggleAutopilot()cn.ToggleAutopilot()return end;r3("Autopilot complete, arrived at space location")aY=true;pW=1 elseif fU and fU.planetname~="Space"and cE<=qS and(fi.apoapsis==nil or fi.periapsis==nil or fi.apoapsis.altitude<=0 or fi.periapsis.altitude<=0)then r3("Autopilot complete, commencing reentry")bh=fU.position;c3=true;cn.showWayPoint(b_,bh)elseif(fU and fU.planetname~="Space"or fU==nil)and fi.periapsis~=nil and fi.periapsis.altitude>0 and fi.eccentricity<1 or bd=="Circularizing"then if bd~="Circularizing"then fJ("apCir","AP")bd="Circularizing"end;if cE<=qS then if fU then if cD:normalize():dot(qv:normalize())>0.4 then if bd~="Orbiting to Target"then fJ("apOrb","OB")bd="Orbiting to Target"end;if not rl then aY=false;cn.showWayPoint(b_,fU.position)rl=true end else r3("Autopilot complete, proceeding with reentry")bh=fU.position;c3=true;cn.showWayPoint(b_,fU.position)rl=false end else r3("Autopilot completed, setting orbit",true)pW=0 end end elseif bd=="Circularizing"then r3("Autopilot complete, fixing Orbit",true)end elseif bb then local rk=p3;if rk<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pC and cP>2000 then cn.ToggleAutopilot()bV="Autopilot cancelled to prevent crossing PvP Line"aY=true;pC=cP else pC=cP;return end end;b8=false;if bd~="Braking"then fJ("apBrk","AP")bd="Braking"end;ba=true end;local p4=c.getThrottle()if u then p4=bJ end;if p4>0 then b8=true;if bd~="Accelerating"then bd="Accelerating"fJ("apAcc","AP")end;bb=false end else if qJ then if not b9 and fU==nil or not b9 and fU and fU.planetname~="Space"then if not c3 then bh=vec3(b_.center)+(gd+b_.radius)*cB;rm=q0;rn=cB end;b9=true elseif qJ and not qi then b8=true;if bd~="Accelerating"then bd="Accelerating"fJ("apAcc","AP")end;if not pS then cn.cmdThrottle(a1,true)bJ=i7(a1,2)pS=true;aY=false end end end end elseif b0 and(fU~=nil and fU.planetname~="Space"and c8>0)then bV="Autopilot complete, starting reentry"fJ("apCom","AP")bh=fU.position;aY=false;ba=false;b0=false;r4=false;bd="Aligning"pW=0;cn.cmdThrottle(0)pS=false;a_=true;c3=true;cn.showWayPoint(b_,fU.position)end;if bT then cs=true;local rd=0;local fk=cH+vec3(c.getMasterPlayerRelativePosition())local ro=fk-cH;local rp=vec3(ro):project_on(cA):len()local rq=vec3(ro):project_on(cB):len()local c2=da(rp*rp+rq*rq)qo(ro:normalize())local mq=40;local rr=c2<mq;local rs=100;local rt=d8((c2-mq)/2,10,rs)pU=0;local qJ=eN(pV)<0.1;if qJ and cE<rt and not rr then aY=false;rd=-20 else aY=true;rd=0 end;local ru=0;if eN(rd-cL)>ru then if rv==nil then rv=pid.new(2*0.01,0,2*0.1)end;rv:inject(rd-cL)local rf=rv:get()pU=rf end end;if b2 or b3 or b5 or bn or bq~=nil then local rw=br;if rw then rw=rw*d8(cE/100,0.1,1)*c8 else rw=bp end;if c8<0.01 then rw=bp end;local rx=cA:project_on_plane(cF):normalize():dot(cD)local ry=vec3(b.getWorldAirFrictionAcceleration())local rz=ry:len()*ca;if rx>100 then bY,bZ=ci.computeDistanceAndTime(rx,100,ca,0,0,rw)local rA,rB=ci.computeDistanceAndTime(100,0,ca,0,0,rw*0.55)bY=bY+rA else bY,bZ=ci.computeDistanceAndTime(rx,0,ca,0,0,rw*0.55)end;local qW=b7-c9-cG;local rC=200+cE;if b5 or c3 then rD=2000+cE end;local rE=1;if b4 then rE=d8(cE/100,0.1,1)end;local rd=(utils.smoothstep(qW,-rC,rC)-0.5)*2*P*rE;if not b5 and not c3 and not bn and cA:dot(cD:normalize())<0.99 then rd=(utils.smoothstep(qW,-rC*d8(20-19*c8*10,1,20),rC*d8(20-19*c8*10,1,20))-0.5)*2*P*d8(2-c8*10,1,2)*rE end;if not b2 then rd=0 end;if bq~=nil then if cR and not bw then rd=bq else bq=nil end end;cs=true;local rF=pU;if b5 then local rG=bG(cu)local rH,rI=ci.computeDistanceAndTime(cE,rG/3.6,ca,0,0,bp-iO.gravity*9.8*ca)rH=rH==-1 and 5000 or rH;local rJ=c9-(iO.noAtmosphericDensityAltitude+rH)local rK=c9>iO.noAtmosphericDensityAltitude+rH*1.35;if rK then rd=Q;if cE<=rG/3.6 and cE>rG/3.6-10 and eN(cD:normalize():dot(cA))>0.9 and not cK then bN=false;cn.cmdThrottle(1)end elseif(cK or i5:getTargetSpeed(axisCommandId.longitudinal)~=rG)and not rK and not c7 then cn.cmdCruise(rG,true)end;if cK then if cE>rG/3.6 and not rK then aY=true else aY=false end else aY=false end;if cG>0 then aY=true end;if not pT then rd=-80;if c9<iO.surfaceMaxAltitude+(iO.atmosphereThickness-iO.surfaceMaxAltitude)*0.25 then bV="PARACHUTE DEPLOYED at "..i7(c9,0)b5=false;b3=true;le=true;cn.cmdThrottle(0)rd=0;cs=p end elseif iO.noAtmosphericDensityAltitude>0 and rK then cs=true elseif not rK then if not c7 and(cK or i5:getTargetSpeed(axisCommandId.longitudinal)~=rG)then cn.cmdCruise(rG)end;if cE<rG/3.6+1 then aY=false;pT=false;b5=false;cs=true end end end;if cE>ir and not c4 and not bn and not b3 and v then qo(vec3(cD))end;if cQ or(bn or c4)and bi>0 and c8>0.01 then local qv;if cQ then if type(cQ)=="table"then qv=cQ elseif cQ<3 and cQ>0 then qv=-cF:cross(cD)*5000 elseif cQ>=3 then qv=cF:cross(cD)*5000 elseif cQ<0 then qv=cD*25000 end elseif fU~=nil then qv=fU.position-cH else qv=b_.center-cH end;local rc=math.deg(q3(cF:normalize(),cD,qv))*2;local mt=math.rad(eN(cM))if cE>aH and c8>0.01 then local rL=1000+cE;local rM=(utils.smoothstep(qW-cG*10,-rL,rL)-0.5)*2*P;local rN=d8(90-rM,0,180)pY=d8(rc*2,-rN,rN)local rO=rc;rc=d8(d8(rc,-M*0.80,M*0.80)*math.cos(mt)+4*(cL-rd)*math.sin(math.rad(cM)),-M*0.80,M*0.80)local rP=1;if pY~=0 then rP=eN(mt/pY)end;rP=(90-d8(eN(pY-cM),0,90))/90;local rQ=rd;if eN(cM)>90 then rQ=-rQ end;rd=rP*d8(d8(rQ*math.cos(mt),-N*0.8,N*0.8)+eN(d8(eN(rO)*math.sin(mt),-N*0.80,N*0.80)),-N*0.80,N*0.80)else pY=0;rc=d8(rc,-M*0.80,M*0.80)end;local rR=qC-rc;if cQ and eN(rR)<=0.0001 and(type(cQ)=="table"or type(cQ)~="table"and cQ<0 and eN(cM)<1)then if cQ==-2 then cn.ToggleAltitudeHold()end;cQ=nil;fJ("180Off","BR")return end;if not ct and cE>aH and c8>0.01 then if rS==nil then rS=pid.new(2*0.01,0,2*0.1)end;rS:inject(rR)local rh=d8(rS:get(),-1,1)pV=pV+rh elseif c7 and c6>-1 or cE<aH then qo(qv)elseif ct and c8>0.01 then if(qC<-M or qC>M)and c8>0.01 then qo(cD)end;if(qD<-N or qD>N)and c8>0.01 then rd=d8(cL-qD,cL-N*0.80,cL+N*0.80)end end;if fU~=nil and not c4 then local qK=iO:getAltitude(fU.position)local rJ=qv:project_on_plane(cF):len()le=true;if not c4 and not b5 and rJ<=bY and(cD:project_on_plane(cF):normalize():dot(qv:project_on_plane(cF):normalize())>0.99 or lm=="Finalizing Approach")then lm="Finalizing Approach"if#pP>0 then cn.ToggleAutopilot()cn.ToggleAutopilot()return end;cn.cmdThrottle(0)if b2 then cn.ToggleAltitudeHold()bn=true end;aY=true elseif not b4 then aY=false end;if lm=="Finalizing Approach"and(rx<0.1 or rJ<0.1 or rT~=nil and rT<rJ)then if not cJ then fJ("bklOn","BL")b3=true;d4=true;if fU.heading then d5=fU.heading else d5=nil end end;bn=false;if bg=="STARTINGPOINT"then cm.ClearCurrentPosition()end;lm="Proceeding to Waypoint"cS=false end;rT=rJ end elseif bn and c8==0 and b7>iO.noAtmosphericDensityAltitude and not(c4 or b5)then if fU~=nil and b_.name==iO.name then local qv=fU.position-cH;local qK=iO:getAltitude(fU.position)local rJ=da(qv:len()^2-(c9-qK)^2)local rw=br;if rw then bY,bZ=ci.computeDistanceAndTime(cE,0,ca,0,0,rw/2)le=true;if rJ<=bY+cE*qB/2 and cD:project_on_plane(cF):normalize():dot(qv:project_on_plane(cF):normalize())>0.99 then if iO.hasAtmosphere then aY=false;a_=false;pT=true;c3=false;c5=true;b0=false;cn.BeginReentry()end end;rT=rJ end end end;if c8==0 and(b2 and b7>iO.noAtmosphericDensityAltitude)and not(c4 or bw or b5)then if not cx and not bw then cw=b7;pM=true;if bn then p_.VectorToTarget=true end;cn.ToggleIntoOrbit()bn=false;pK=true end end;if ct and c8>0.01 and c6==-1 and cE>aH and lm~="Finalizing Approach"then qo(cD)rd=d8(cL-qD,cL-N*0.80,cL+N*0.80)end;pU=rF;local qc=-1;if b3 then rd=0;if d5 then if rx<0.05 and rx>-0.05 then if cG>-O then aY=false else aY=true end;if qo(d5,0.0001)then d5=nil;cs=p else pU=0;cs=true end else aY=true end else local rU=false;local rV=30;if cj~=nil and cj>0 then local rW=d8(c8,0.4,2)local rw=br*d8(cE/100,0.1,1)*rW;local rX=cj*rW+rw-gq;local rY=rw/2-gq;local rZ=cE-da(eN(rY/2)*20/(0.5*ca))*utils.sign(rY)if rZ<0 then rZ=0 end;local r_;if cE>100 then local s0,dD=ci.computeDistanceAndTime(cE,100,ca,0,0,rw)local s1,dD=ci.computeDistanceAndTime(100,0,ca,0,0,da(rw))r_=s0+s1 else r_=ci.computeDistanceAndTime(cE,0,ca,0,0,da(rw))end;if r_<20 then aY=false else local s2=0;if rZ>100 then local s3,dD=ci.computeDistanceAndTime(rZ,100,ca,0,0,rX)local s4,dD=ci.computeDistanceAndTime(100,0,ca,0,0,cj*rW+da(rw)-gq)s2=s3+s4 else s2,dD=ci.computeDistanceAndTime(rZ,0,ca,0,0,cj*rW+da(rw)-gq)end;s2=(s2+15+cE*qB)*1.1;local s5=fU~=nil and iO:getAltitude(fU.position)>0 and fU.safe;if s5 then local qK=iO:getAltitude(fU.position)local s6=c9-qK-100;local qv=fU.position-cH;local s7=da(qv:len()^2-(c9-qK)^2)if s7>100 then s5=false elseif s6<=s2 or s2==-1 then aY=true;rU=true else aY=false;rU=true end end;if not s5 and t then if s2>=rV then aY=true else aY=false end;rU=true end end end;if not cK then cn.cmdThrottle(0)end;i5:setTargetGroundAltitude(500)i5:activateGroundEngineAltitudeStabilization(500)by=true;qc=c6;if qc>-1 then if(cE<1 or cD:normalize():dot(cF)<0)and not d5 then b3=false;b2=false;bj=true;if bO then d.control.extendLandingGears()fJ("grOut","LG",1)end;i5:setTargetGroundAltitude(Z)bS=0;aY=true;cs=p;d4=false else aY=true end elseif le and cD:normalize():dot(-gf)<0.999 then aY=true;qo()elseif cG<-O and not rU or(rx>0.05 or rx<-0.05)and d4 then aY=true elseif not rU then aY=false end end end;if b4 or c4 then local li,ey,ex;if bh~=nil then li,ey,ex=ch:getPlanetarySystem(0):castIntersections(cH,(bh-cH):normalize(),function(eg)return eg.radius+eg.noAtmosphericDensityAltitude end)end;if cJ then if c9>=b7-50 then b4=false;if not b0 and not bn then aY=true;cn.cmdThrottle(0)end else b7=antigrav.getBaseAltitude()end elseif eN(rd)<15 and c9/b7>0.75 then b4=false;if not c4 then if cK and not u then d.control.cancelCurrentControlMasterMode()end elseif c4 and cE<ir then b0=true;c4=false;b2=false;b4=false;cn.cmdThrottle(0)elseif c4 then cn.cmdThrottle(0)aY=true end elseif c4 and c8==0 and b_~=nil and(li==nil or li.name==b_.name)then b0=true;c4=false;b2=false;b4=false;if not cK then cn.cmdThrottle(0)end;b8=true end end;local s8=c6>-1;local s9=cL;if(bn or c4 or cQ)and not s8 and cE>aH and c8>0.01 then local mt=math.rad(eN(cM))s9=cL*eN(math.cos(mt))+qD*math.sin(mt)end;local sa=d8(rd-s9,-N*0.80,N*0.80)if c8<0.01 and bn then sa=d8(rd-s9,-85,P)elseif c8<0.01 then sa=d8(rd-s9,-P,P)end;if eN(cM)<5 or bn or cQ or b3 or s8 or b2 then if rv==nil then rv=pid.new(5*0.01,0,5*0.1)end;rv:inject(sa)local rf=rv:get()pU=pU+rf end end;if antigrav~=nil and(antigrav and not q and c9<200000)then if bs==nil or bs<1000 then bs=1000 end;if sb~=bs then sb=bs;antigrav.setBaseAltitude(sb)end end end;function px.ToggleIntoOrbit()cx=false;pI=nil;pJ=nil;pO=0;if c8==0 then if bw then fJ("orOff","AP")bw=false;pK=false;pN=nil;cs=p;if b2 then b2=false;b4=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pM=false elseif cR then fJ("orOn","AP")bw=true;cs=true;if pN==nil then pN=iO end;if b2 then b2=false;b4=false end else bV="Unable to engage auto-orbit, not near a planet"end else bw=false;pK=false;pN=nil;cs=p;if b2 then b2=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pM=false end end;function px.ToggleVerticalTakeoff()b2=false;if b6 then le=true;b5=false;b4=false;b3=true;cs=true;bS=0;if c7 and c6==-1 then b3=false;b2=true;bS=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cn.cmdCruise(bG(cu))end else cx=false;bj=false;d.control.retractLandingGears()i5:setTargetGroundAltitude(Y)aY=true end;b6=not b6 end;function px.checkLOS(qp)local li,ex,ey=ch:getPlanetarySystem(0):castIntersections(cH,qp,function(eg)if eg.noAtmosphericDensityAltitude>0 then return eg.radius+eg.noAtmosphericDensityAltitude else return eg.radius+eg.surfaceMaxAltitude*1.5 end end)local lj=ex;if ey~=nil and ex~=nil then lj=math.min(ey,ex)end;if lj~=nil then return li,lj else return nil,nil end end;function px.ToggleAutopilot()local function sc(bu)cS=false;bn=not bn;if bn then b1=false;if not b2 and not bu then cn.ToggleAltitudeHold()end end;lm="Proceeding to Waypoint"end;local function sd(gm)if gm then for L,dy in pairs(cN)do if dy.name and dy.name==gm then return L end end else return 0 end end;local se=false;if bI-pH<1.5 and c8>0 then if not cz then bV="No space engines detected, Orbital Hop not supported"return end;if iO.hasAtmosphere then if c8>0 then b7=iO.noAtmosphericDensityAltitude+U;fJ("orH","OH")end;pH=-1;if b0 or bn or bw then return end end else pH=bI end;r4=false;if(bi>0 or#pP>0)and not b0 and not bn and not c4 and not bw then if 0.5*d:maxForceForward()/b.g()<ca then bV="WARNING: Heavy Loads may affect autopilot performance."bW=5 end;if#pP>0 and not c5 then bi=sd(pP[1])cm.UpdateAutopilotTarget()table.remove(pP,1)bV="Route Autopilot in Progress"local qv=fU.position-cH;local rJ=qv:project_on_plane(cF):len()if rJ>50000 and fU.planetname==iO.name then se=true end end;cm.UpdateAutopilotTarget()cn.showWayPoint(b_,bh)if J and#pP==0 and bg~="STARTINGPOINT"and cm.findAtlasIndex(bm,"STARTINGPOINT")==-1 and c6>-1 then cm.AddNewLocation("STARTINGPOINT",cH,false,false)end;if fU~=nil then bq=nil;bu=fU.planetname=="Space"if bu then fJ("apSpc","AP")if c8~=0 then c4=true;cn.ToggleAltitudeHold()else b0=true end elseif iO.name==fU.planetname then le=true;if c8>0 then if not bn then fJ("vtt","AP")sc(bu)if se then b7=iO.noAtmosphericDensityAltitude+U end end else fJ("apOn","AP")if not(b_.name==iO.name and c9<gd*1.5)then cx=false;b0=true elseif not c7 then if bw then cn.ToggleIntoOrbit()end;cw=iO.noAtmosphericDensityAltitude+U;pM=true;p_.AutopilotAlign=true;p_.VectorToTarget=true;pK=false;if not bw then cn.ToggleIntoOrbit()end end end else fJ("apP","AP")aZ=false;a_=false;if c8~=0 then c4=true;cn.ToggleAltitudeHold()else b0=true end end elseif c8==0 then if fU==nil and(b_.name==iO.name and cR)and not bw then rl=false;cx=false;pK=false;cn.ToggleIntoOrbit()else fJ("apP","AP")b0=true;aZ=false;a_=false;b9=false;bT=false;b2=false;b3=false;b5=false;b4=false;pS=false;bq=nil;rl=false end else fJ("apP","AP")c4=true;cn.ToggleAltitudeHold()end else fJ("apOff","AP")cn.ResetAutopilots(1)end end;function px.routeWP(sf,sg,sh)if sh then if sh==1 then pP={}pP=i8(pP,bB)if#pP>0 then bV="Route Loaded"else bV="No Saved Route found on Databank"end;return pP else bB={}bB=i8(bB,pP)bV="Route Saved"pw()return end end;if sf then return pP end;if sg then pP={}bV="Current Route Cleared"else pP[#pP+1]=fU.name;bV="Added "..fU.name.." to route. "end;return pP end;function px.cmdThrottle(dz,si)if i5:getAxisCommandType(0)~=axisCommandType.byThrottle and not si then d.control.cancelCurrentControlMasterMode()end;i5:setThrottleCommand(axisCommandId.longitudinal,dz)bJ=d8(i7(dz*100,0)/100,-1,1)q1=nil end;function px.cmdCruise(dz,si)if i5:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not si then d.control.cancelCurrentControlMasterMode()end;i5:setTargetSpeedCommand(axisCommandId.longitudinal,dz)q1=dz end;function px.ToggleLockPitch()if bq==nil then fJ("lkPOn","LP")if not bU then bq=cL else bq=R end;b4=false;b2=false;b3=false else fJ("lkPOff","LP")bq=nil end end;function px.ToggleAltitudeHold()if bI-pG<1.5 then if iO.hasAtmosphere then if c8>0 then b7=iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude;fJ("11","EP")else if cR then b7=iO.noAtmosphericDensityAltitude+U;cw=b7;pM=true;if not bw then cn.ToggleIntoOrbit()end;pK=true end end;pG=-1;if b2 or bw or b6 then return end end else pG=bI end;if cR and c8==0 then cw=c9;pM=true;pK=true;cn.ToggleIntoOrbit()if bw then pG=bI else pG=0 end;return end;b2=not b2;b3=false;b5=false;if b2 then b0=false;a_=false;aZ=false;bT=false;cs=true;bq=nil;cx=false;if c6~=-1 and cE<20 then fJ("lfs","LS")b4=true;if pG>-1 then b7=c9+X end;bj=false;d.control.retractLandingGears()aY=true;i5:setTargetGroundAltitude(Y)if aX and cI then cn.ToggleVerticalTakeoff()end else fJ("altOn","AH")b4=false;if pG>-1 then if cR then b7=c9 end end;if b6 then cn.ToggleVerticalTakeoff()end end;if c4 then b7=100000 end else fJ("altOff","AH")if bw then cn.ToggleIntoOrbit()end;if b6 then cn.ToggleVerticalTakeoff()end;cs=p;b4=false;bn=false;pG=0 end end;function px.ResetAutopilots(px)if px then c4=false;b0=false;b9=false;pS=false;b7=c9;r4=false;d4=false end;bn=false;b4=false;b5=false;a_=false;b3=false;d5=nil;sj=false;cQ=nil;d4=false;if not cJ then b2=false;bq=nil end;if b6 then cn.ToggleVerticalTakeoff()end;if bw then cn.ToggleIntoOrbit()end;cs=p;c3=false;c5=false;bS=0 end;function px.BrakeToggle()aY=not aY;if b3 then b3=false;cs=p end;if aY then fJ("bkOn","B",1)cn.ResetAutopilots()else fJ("bkOff","B",1)end end;function px.BeginReentry()if b5 then bV="Re-Entry cancelled"fJ("reOff","RE")b5=false;cs=p;b2=false elseif not iO.hasAtmosphere then bV="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bW=5 elseif not pT then b5=true;if i5:getAxisCommandType(0)~=sk.cruise then d.control.cancelCurrentControlMasterMode()end;cs=true;aY=false;bV="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cu;fJ("par","RE")else b5=true;b2=true;cs=true;aY=false;b7=iO.surfaceMaxAltitude+_;if b7>iO.spaceEngineMinAltitude then b7=iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude end;local sl=ia(b7)bV="Beginning Re-entry.  Target speed: "..cu.." Target Altitude: "..sl;fJ("glide","RE")cn.cmdCruise(bG(cu))end;b4=false end;function px.ToggleAntigrav()if antigrav and not q then if cJ then fJ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bs==nil then bs=c9 end;if bs<1000 then bs=1000 end;fJ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function px.changeSpd(sm)local sn=1;if sm then sn=-1 end;if not bU then if u and not oR and pR then local so=bJ;bJ=i7(d8(bJ+sn*aA/100,-1,1),2)if bJ>=0 and so<0 then bJ=0;pR=false end elseif oR then if c8>0 or b5 then cu=d8(cu+sn*aA,0,V)elseif b0 then a0=d8(a0+sn*aA/3.6*100,0,8333.00)end else i5:updateCommandFromActionStart(axisCommandId.longitudinal,sn*aA/10)end else if b0 or bn or c4 or bw then cV=cV+1*sn*-1;if cV>#cN then cV=1 end;if cV<1 then cV=#cN end else if not sm then sn=1 else sn=nil end;cm.adjustAutopilotTargetIndex(sn)end end end;function px.TenthTick()local function sp(gq,sq)if gq==nil then gq=b.g()end;gq=i7(gq,5)if sq~=nil and sq or(pQ==nil or pQ~=gq)then local fe=cC:len()local sr=i2(c.getData()).maxBrake;if sr~=nil and sr>0 and c7 then sr=sr/d8(fe/100,0.1,1)sr=sr/c8;if c8>0.10 then if br then br=(br+sr)/2 else br=sr end end end;if sr~=nil and sr>0 then bp=sr end;pQ=gq end end;sp(nil,true)if q1~=nil then if i5:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or i5:getTargetSpeed(axisCommandId.longitudinal)~=q1 then cn.cmdCruise(q1)else q1=nil end end end;function px.SatNavTick()if not r then return end;q2=dbHud_1.getStringValue("SPBAutopilotTargetName")if q2~=nil and q2~=""and q2~="SatNavNotChanged"then local dt=i2(dbHud_1.getStringValue("SavedLocations"))if dt~=nil then bm=dt;local gk=-1;local gr;for dy,dj in pairs(bm)do if dj.name and dj.name=="SatNav Location"then gk=dy;break end end;if gk~=-1 then gr=bm[gk]gk=-1;for dy,dj in pairs(e[0])do if dj.name and dj.name=="SatNav Location"then gk=dy;break end end;if gk>-1 then e[0][gk]=gr end;cm.UpdateAtlasLocationsList()bV=gr.name.." position updated"end end;for L=1,#cN do if cN[L].name==q2 then bi=L;a.print("Index = "..bi.." "..cN[L].name)cm.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function px.onFlush()local function ss(st,rt)local su=vec3()local sv=vec3()if st==axisCommandId.longitudinal then su=vec3(b.getConstructOrientationForward())sv=cA elseif st==axisCommandId.vertical then su=vec3(b.getConstructOrientationUp())sv=q0 elseif st==axisCommandId.lateral then su=vec3(b.getConstructOrientationRight())sv=cB else return vec3()end;local sw=vec3(b.getWorldGravity())local sx=sw:dot(sv)local sy=vec3(b.getWorldAirFrictionAcceleration())local sz=sy:dot(sv)local sA=cC:dot(su)local sB=rt*constants.kph2m;if sC==nil then sC=pid.new(10,0,10.0)end;sC:inject(sB-sA)local sD=sC:get()local sE=(sD-sz-sx)*sv;return sE end;local function sF(st,rt)local su=vec3()local sv=vec3()if st==axisCommandId.longitudinal then su=vec3(b.getConstructOrientationForward())sv=cA elseif st==axisCommandId.vertical then su=vec3(b.getConstructOrientationUp())sv=q0 elseif st==axisCommandId.lateral then su=vec3(b.getConstructOrientationRight())sv=cB else return vec3()end;local sw=vec3(b.getWorldGravity())local sx=sw:dot(sv)local sy=vec3(b.getWorldAirFrictionAcceleration())local sz=sy:dot(sv)local sA=cC:dot(su)local sB=rt*constants.kph2m;if sG==nil then sG=pid.new(10,0,10.0)end;sG:inject(sB-sA)local sD=sG:get()local sE=(sD-sz-sx)*sv;return sE end;local function sH(sI,jB,fQ)local sJ=sI:cross(fQ):normalize_inplace()local km=math.acos(d8(sJ:dot(-jB),-1,1))*constants.rad2deg;if sJ:cross(-jB):dot(fQ)<0 then km=-km end;return km end;if antigrav and not q then if not cJ and antigrav.getBaseAltitude()~=bs then antigrav.setBaseAltitude(bs)end end;cK=i5:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local sK=d8(bP+pU+a.getControlDeviceForwardInput(),-1,1)local sL=d8(bQ+pX+a.getControlDeviceYawInput(),-1,1)local sM=d8(bR+pV-a.getControlDeviceLeftRightInput(),-1,1)local sN=pW;cF=vec3(b.getWorldVertical())if cF==nil or cF:len()==0 then cF=(iO.center-cH):normalize()end;q0=vec3(b.getConstructWorldOrientationUp())cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getWorldVelocity())cC=vec3(b.getVelocity())cH=vec3(b.getConstructWorldPos())ca=b.getConstructMass()cE=vec3(cD):len()cG=-cF:dot(cD)cM=getRoll(cF,cA,cB)local sO=cM/180*math.pi;local sP=math.cos(sO)local sQ=math.sin(sO)cL=sH(cF,cA,cB*sP+q0*sQ)local sR=cD:normalize()local sS=eN(cM)local sT=utils.sign(cM)local sU=vec3(b.getWorldAngularVelocity())local sV=sK*aK*cB+sL*aF*cA+sM*aL*q0;if cs==true and cF:len()>0.01 then local sW=eN(pY-cM)if((a_ or b5 or b3 or c3 or b2 or bw)and sW>0 or c8>0.0 and sW<aG and p)and sL==0 and eN(cL)<85 then local sX=pY;local sY=aE;if c8==0 then sY=sY/4;pY=0;sX=0 end;if sZ==nil then sZ=pid.new(sY*0.01,0,sY*0.1)end;sZ:inject(sX-cM)local s_=sZ:get()sV=sV+s_*cA end end;local t0=1;local t1=0;local t2=1;bK=0;if c7 and u and cK then if t3==nil then t3=pid.new(0.1,0,1)end;local t4=0;if aR>0 and not b5 and c8>0.005 and c8<0.1 and cG>-50 then t4=(0.1-c8)*cu*aR end;t3:inject(cu/3.6+t4-cD:dot(cA))local t5=t3:get()bM=d8(t5,-1,1)if not d0 then if bM<bJ and c8>0.005 then bL=true;d0=d8(bM,0.01,1)else bL=false;d0=bJ end end;if t6==nil then t6=pid.new(1*0.01,0,1*0.1)end;t6:inject(cD:len()-cu/3.6-t4)local t7=d8(t6:get(),0,1)if c8>0 and cG<-80 or c8>0.005 then bK=t7 end;if bK>0 then if bL and bM==0.01 and not d0 then d0=0 end else bM=d8(bM,0.01,1)end;local t8=''local t9=vec3()local ta=ss(axisCommandId.vertical,bS*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",ta,t1)local tb='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tb=tb..aS end;local tc=i5:getAxisCommandType(axisCommandId.longitudinal)local td=i5:composeAxisAccelerationFromThrottle(tb,axisCommandId.longitudinal)local te=sF(axisCommandId.lateral,bv*1000)t8=t8 ..' , '.."lateral airfoil , lateral ground "t9=t9+te;if t9:len()>constants.epsilon then d:setEngineForceCommand(t8,t9,t1,'','','',t2)end;d:setEngineForceCommand(tb,td,t0)local tf='thrust analog vertical fueled 'local tg='thrust analog lateral fueled 'if bz=="All"or bz=="Lateral"then tg=tg..aT end;if bz=="All"or bz=="Vertical"then tf=tf..aU end;if bS~=0 or b3 and aY or not bj and not by then d:setEngineForceCommand(tf,ta,t0)else d:setEngineForceCommand(tf,vec3(),t0)end;if bv~=0 then d:setEngineForceCommand(tg,te,t0)else d:setEngineForceCommand(tg,vec3(),t0)end;if sN==0 then sN=bK end;local th=-sN*(aM*cD+aN*sR)d:setEngineForceCommand('brake',th)else if u then if not d0 then d0=bJ end end;local rt=c.getAxisCommandValue(0)if not cK then if t6==nil then t6=pid.new(1*0.01,0,1*0.1)end;t6:inject(cD:len()-rt/3.6)local t7=d8(t6:get(),0,1)sN=d8(sN+t7,0,1)end;local th=-sN*(aM*cD+aN*sR)d:setEngineForceCommand('brake',th)local t8=''local t9=vec3()local ti=false;local tb='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tb=tb..aS end;local tc=i5:getAxisCommandType(axisCommandId.longitudinal)if tc==axisCommandType.byThrottle then local td=i5:composeAxisAccelerationFromThrottle(tb,axisCommandId.longitudinal)d:setEngineForceCommand(tb,td,t0)elseif tc==axisCommandType.byTargetSpeed then local td=i5:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)t8=t8 ..' , '..tb;t9=t9+td;if i5:getTargetSpeed(axisCommandId.longitudinal)==0 or i5:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-i5:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ti=true end end;local tg='thrust analog lateral 'if bz=="All"or bz=="Lateral"then tg=tg..aT end;local tj=i5:getAxisCommandType(axisCommandId.lateral)if tj==axisCommandType.byThrottle then local tk=i5:composeAxisAccelerationFromThrottle(tg,axisCommandId.lateral)d:setEngineForceCommand(tg,tk,t0)elseif tj==axisCommandType.byTargetSpeed then local te=i5:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)t8=t8 ..' , '..tg;t9=t9+te end;local tf='thrust analog vertical 'if bz=="All"or bz=="Vertical"then tf=tf..aU end;local tl=i5:getAxisCommandType(axisCommandId.vertical)if tl==axisCommandType.byThrottle then local ta=i5:composeAxisAccelerationFromThrottle(tf,axisCommandId.vertical)if bS~=0 or b3 and aY then d:setEngineForceCommand(tf,ta,t0,'airfoil','ground','',t2)else d:setEngineForceCommand(tf,vec3(),t0)d:setEngineForceCommand('airfoil vertical',ta,t0,'airfoil','','',t2)d:setEngineForceCommand('ground vertical',ta,t0,'ground','','',t2)end elseif tl==axisCommandType.byTargetSpeed then if bS<0 then d:setEngineForceCommand('hover',vec3(),t0)end;local tm=i5:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)t8=t8 ..' , '..tf;t9=t9+tm end;if t9:len()>constants.epsilon then if pW~=0 or ti or eN(sR:dot(cA))<0.5 then t8=t8 ..', brake'end;d:setEngineForceCommand(t8,t9,t1,'','','',t2)end end;local tn=aJ*(sV-sU)local to=vec3(b.getWorldAirFrictionAngularAcceleration())tn=tn-to;d:setEngineTorqueCommand('torque',tn,t0,'airfoil','','',t2)d:setBoosterCommand('rocket_engine')if bX and not n then local fe=cC:len()local tp=0.15;if not cK then local tq=i5:getTargetSpeed(axisCommandId.longitudinal)if fe*3.6>tq*(1-tp)and tr then tr=false;d:toggleBoosters()elseif fe*3.6<tq*(1-tp)and not tr then tr=true;d:toggleBoosters()end else local p4=c.getThrottle()if u then p4=bJ*100 end;local rt=p4/100;if bH==0 then rt=rt*a0;if fe>=rt*(1-tp)and tr then tr=false;d:toggleBoosters()elseif fe<rt*(1-tp)and not tr then tr=true;d:toggleBoosters()end else local rG=bG(cu)rt=rt*rG/3.6;if fe>=rt*(1-tp)and tr then tr=false;d:toggleBoosters()elseif fe<rt*(1-tp)and not tr then tr=true;d:toggleBoosters()end end end end end;c6=q7()return px end;local function ts(d,b,c,a,e,vBooster,hover,antigrav,i0,dbHud_2,gyro,screenHud_1,i4,i5,i6,tt,gy,i7,dT,d9,d8,fJ,i9,pw)local tu={}local tv=true;local tw=5;local tx=5;local ty=tw;local tz=tx;local tA=bI;function tu.startControl(tB)local function tC(sm)local sn=1;local function tD(tE,sm)local tF={iO.surfaceMaxAltitude+100,iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude,iO.noAtmosphericDensityAltitude+U,iO.radius*(T-1)+iO.noAtmosphericDensityAltitude}local tG=tE;for dD,dj in ipairs(tF)do if sm and tG>dj then tE=dj elseif tE<dj and not sm then tE=dj;break end end;return tE end;if sm then sn=-1 end;if not q and cJ then if bU and sm then bs=1000 elseif bs~=nil then bs=bs+sn*tx;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end else bs=sb+sn*100 end elseif b2 or b6 or bw then if bw then if bU then cw=tD(cw,sm)else cw=cw+sn*tw end;if cw<iO.noAtmosphericDensityAltitude then cw=iO.noAtmosphericDensityAltitude end else if bU and c7 then b7=tD(b7,sm)else b7=b7+sn*tw end end else i5:updateTargetGroundAltitudeFromActionStart(sn*1.0)end end;local function tH(tI)if not c7 then bV="Flight Assist in Atmo only"return end;local dg=type(tI)if cQ==nil then if dg=="table"then if b0 or bn then cn.ToggleAutopilot()end;fJ("180On","BR")elseif tI==1 then fJ("bnkLft","BR")else fJ("bnkRht","BR")end;if not b2 and not b0 and not bn then cn.ToggleAltitudeHold()if dg~="table"then tI=tI+1 end end;cQ=tI else fJ("180Off","BR")cQ=nil end end;if tB=="gear"then bj=not bj;if bj then bn=false;bq=nil;cn.cmdThrottle(0)if vBooster or hover then if c7 and c6==-1 then fJ("bklOn","BL")le=true;b5=false;b4=false;b6=false;b2=false;b3=true;d4=false;cs=true;bj=false else if bO then fJ("grOut","LG",1)d.control.extendLandingGears()end;i5:setTargetGroundAltitude(Z)if c7 then aY=true end end end;if bO and not b3 and not(vBooster or hover)then fJ("grOut","LG",1)d.control.extendLandingGears()end else if bO then fJ("grIn","LG",1)d.control.retractLandingGears()end;i5:setTargetGroundAltitude(Y)end elseif tB=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif tB=="forward"then bP=bP-1 elseif tB=="backward"then if oR then tH(-cD*5000)else bP=bP+1 end elseif tB=="left"then if oR then tH(1)else bQ=bQ-1 end elseif tB=="right"then if oR then tH(3)else bQ=bQ+1 end elseif tB=="yawright"then bR=bR-1;d5=nil elseif tB=="yawleft"then bR=bR+1;d5=nil elseif tB=="straferight"then i5:updateCommandFromActionStart(axisCommandId.lateral,1.0)bv=1 elseif tB=="strafeleft"then i5:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bv=-1 elseif tB=="up"then bS=bS+1;i5:deactivateGroundEngineAltitudeStabilization()i5:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif tB=="down"then bS=bS-1;i5:deactivateGroundEngineAltitudeStabilization()i5:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif tB=="groundaltitudeup"then tC()elseif tB=="groundaltitudedown"then tC(true)elseif tB=="option1"then tJ=false;if oR and bU then local tK=""for L=1,#cW do tK=tK.."| Name: "..a.getPlayerName(cW[L]).." Mass: "..i7(b.getBoardedPlayerMass(cW[L])/1000,1).."t "end;a.print("Onboard: "..tK)return end;cm.adjustAutopilotTargetIndex()elseif tB=="option2"then tJ=false;if oR and bU then for L=1,#cW do b.forceDeboard(cW[L])end;bV="Deboarded All Passengers"return end;cm.adjustAutopilotTargetIndex(1)elseif tB=="option3"then local function tL()tv=not tv;if not tv then fJ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(tM,atmofueltank_size,"Atmo Fuel","fuel_container")tN=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(tO,spacefueltank_size,"Space Fuel","fuel_container")tP=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(tQ,rocketfueltank_size,"Rocket Fuel","fuel_container")tR=_autoconf.panels[_autoconf.panels_size]end;tS=a.createWidgetPanel("Docking")tT=a.createWidget(tS,"parenting")a.addDataToWidget(c.getDataId(),tT)tU=a.createWidgetPanel("Core combat stress")tV=a.createWidget(tU,"core_stress")a.addDataToWidget(b.getDataId(),tV)if i0~=nil then i0.show()end else fJ("hud","DH")c.hide()b.hide()if tN~=nil then gy(tN)tN=nil end;if tS~=nil then gy(tS)tS=nil end;if tU~=nil then gy(tU)tU=nil end;if tP~=nil then gy(tP)tP=nil end;if tR~=nil then gy(tR)tR=nil end;if i0~=nil then i0.hide()end end end;tJ=false;if oR and bU then local tK=""for L=1,#cX do tK=tK.."| ID: "..cX[L].." Mass: "..i7(b.getDockedConstructMass(cX[L])/1000,1).."t "end;a.print("Docked Ships: "..tK)return end;if y then if x then x=false else x=true end end;tL()elseif tB=="option4"then tJ=false;if oR and bU then for L=1,#cX do b.forceUndock(cX[L])end;bV="Undocked all ships"return end;cQ=nil;cn.ToggleAutopilot()elseif tB=="option5"then tJ=false;cn.ToggleLockPitch()elseif tB=="option6"then tJ=false;if oR and bU then if i0 then local tW=i0.getVentingCooldown()if tW>0 then bV="Cannot vent again for "..tW.." seconds"return end;if i0.getShieldHitpoints()<i0.getMaxShieldHitpoints()then i0.startVenting()bV="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bV="Shields already at max hitpoints"end;return else bV="No shield found"return end end;cn.ToggleAltitudeHold()elseif tB=="option7"then tJ=false;if oR and bU then if i0 then i0.toggle()return else bV="No shield found"return end end;F=not F;if F then bV="Collision System Enabled"else bV="Collision System Secured"end elseif tB=="option8"then tJ=false;if oR and bU then if bi>0 and fU~=nil then cn.routeWP()else bV="Select a saved wp on IPH to add to or remove from route"end;return end;by=not by;if not by then bV="DeCoupled Mode - Ground Stabilization off"i5:deactivateGroundEngineAltitudeStabilization()fJ("gsOff","GS")else bV="Coupled Mode - Ground Stabilization on"i5:activateGroundEngineAltitudeStabilization(tX)d:setEngineForceCommand('hover',vec3(),1)fJ("gsOn","GS")end elseif tB=="option9"then tJ=false;if oR and bU then i5:resetCommand(axisCommandId.longitudinal)i5:resetCommand(axisCommandId.lateral)i5:resetCommand(axisCommandId.vertical)cn.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cb=gyro.getState()==1;if cb then fJ("gyOn","GA")else fJ("gyOff","GA")end else bV="No gyro found"end elseif tB=="lshift"then cU=false;if oR then bU=true end;if i6()==1 then bU=true;bf=i6()tt(1)elseif i4()==1 and z then bU=true;cr=false;cq=false end elseif tB=="brake"then if aW or oR then cn.BrakeToggle()elseif not aY then cn.BrakeToggle()else aY=true end elseif tB=="lalt"then tJ=true;oR=true;if i4()==0 and not i and g=="keyboard"then tt(1)end elseif tB=="booster"then if n then d:toggleBoosters()elseif not bX then if not tr then d:toggleBoosters()tr=true end;bX=true else if tr then d:toggleBoosters()tr=false end;bX=false end elseif tB=="stopengines"then local function tY()if bI-tA<1.5 then fJ("clear","CA")cn.clearAll()end end;tY()tA=bI;if i5:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bJ~=0 then i5:resetCommand(axisCommandId.longitudinal)cn.cmdThrottle(0)else cn.cmdThrottle(100)end else if i5:getTargetSpeed(axisCommandId.longitudinal)~=0 then i5:resetCommand(axisCommandId.longitudinal)else if c7 then cn.cmdCruise(V)else cn.cmdCruise(a0*3.6)end end end elseif tB=="speedup"then cn.changeSpd()elseif tB=="speeddown"then cn.changeSpd(true)elseif tB=="antigravity"and not q then if antigrav~=nil then cn.ToggleAntigrav()else bV="No antigrav found"end end end;function tu.stopControl(tB)local function tZ()if not q and cJ then tz=tx end;if b2 or b6 or bw then ty=tw end end;if tB=="forward"then bP=0 elseif tB=="backward"then bP=0 elseif tB=="left"then if cQ then if cQ==2 then cQ=-2 else cQ=-1 end end;bQ=0 elseif tB=="right"then if cQ then if cQ==4 then cQ=-2 else cQ=-1 end end;bQ=0 elseif tB=="yawright"then bR=0 elseif tB=="yawleft"then bR=0 elseif tB=="straferight"then i5:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bv=0 elseif tB=="strafeleft"then i5:updateCommandFromActionStop(axisCommandId.lateral,1.0)bv=0 elseif tB=="up"then bS=0;i5:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if by then i5:activateGroundEngineAltitudeStabilization(tX)d:setEngineForceCommand('hover',vec3(),1)end elseif tB=="down"then bS=0;i5:updateCommandFromActionStop(axisCommandId.vertical,1.0)if by then i5:activateGroundEngineAltitudeStabilization(tX)d:setEngineForceCommand('hover',vec3(),1)end elseif tB=="groundaltitudeup"then tZ()tJ=false elseif tB=="groundaltitudedown"then tZ()tJ=false elseif tB=="lshift"then if i6()==1 then c0=0;c1=0;tt(bf)elseif i4()==1 and z then cr=false;cq=false end;bU=false elseif tB=="brake"then if not aW and not oR then if aY then cn.BrakeToggle()else aY=false end end elseif tB=="lalt"then if i4()==0 and i then if tJ then if i6()==1 then tt(0)else tt(1)end else tJ=true end elseif i4()==0 and not i and g=="keyboard"then tt(0)end;oR=false end end;function tu.loopControl(tB)local function t_(sm)local sn=1;if sm then sn=-1 end;if not q and cJ then if bs~=nil then bs=bs+sn*tz;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end;tz=d8(tz*1.05,tx,50)else bs=sb+sn*100 end elseif b2 or b6 or bw then if bw then cw=cw+sn*ty;if cw<iO.noAtmosphericDensityAltitude then cw=iO.noAtmosphericDensityAltitude end else b7=b7+sn*ty end;ty=d8(ty*1.05,tw,50)else i5:updateTargetGroundAltitudeFromActionLoop(sn*1.0)end end;local function u0(sm)local sn=1;if sm then sn=-1 end;if not bU then if u and not oR then bJ=d8(bJ+sn*aB/100,-1,1)else i5:updateCommandFromActionLoop(axisCommandId.longitudinal,sn*aB)end end end;if tB=="groundaltitudeup"then if not bU then t_()end elseif tB=="groundaltitudedown"then if not bU then t_(true)end elseif tB=="speedup"then u0()elseif tB=="speeddown"then u0(true)end end;function tu.inputTextControl(sl)local function u1(u2,fk,gn)local function u3(fk)local dq=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr='::pos{'..dq..','..dq..','..dq..','..dq..','..dq..'}'local dH,dI,dQ,dR,dS=dT(fk,dr)if dH=="0"and dI=="0"then return vec3(d9(dQ),d9(dR),d9(dS))end;dR=math.rad(dR)dQ=math.rad(dQ)local iO=e[d9(dH)][d9(dI)]local eJ=math.cos(dQ)local u4=vec3(eJ*math.cos(dR),eJ*math.sin(dR),math.sin(dQ))return iO.center+(iO.radius+dS)*u4 end;local fL=u3(fk)return cm.AddNewLocation(u2,fL,gn)end;local L;local u5,u6=nil,nil;local u7="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to logfile and screen to cut and paste to privatelocations.lua, all if present will make it include all databank locations."L=string.find(sl," ")u5=sl;if L~=nil then u5=string.sub(sl,0,L-1)u6=string.sub(sl,L+1)end;if u5=="/help"or u5=="/commands"then for on in string.gmatch(u7,"([^\n]+)")do a.print(on)end;return elseif u5=="/setname"then if u6==nil or u6==""then bV="Usage: ah-setname Newname"return end;if bi>0 and fU~=nil then cm.UpdatePosition(u6)else bV="Select a saved target to rename first"end elseif i0 and u5=="/resist"then if not i0 then bV="No shield found"return elseif u6==nil or i0.getResistancesCooldown()>0 then bV="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dq=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dr=dq..', '..dq..', '..dq..', '..dq;local u8,u9,ua,ub=dT(u6,dr)if ub==nil or u8+u9+ua+ub>0.6 then bV="Improperly formatted or total exceeds 0.6"return end;if i0.setResistances(u8,u9,ua,ub)==1 then bV="Shield Resistances set"else bV="Resistance setting failed."end elseif u5=="/addlocation"or string.find(sl,"::pos")~=nil then local gn=false;local u2="0-Temp"if u6==nil or u6==""then u6=u5;gn=true end;L=string.find(u6,"::")if not gn then u2=string.sub(u6,1,L-2)end;local fk=string.sub(u6,L)u1(u2,fk,gn)elseif u5=="/agg"then if u6==nil or u6==""then bV="Usage: /agg targetheight"return end;u6=d9(u6)if u6<1000 then u6=1000 end;bs=u6;bV="AGG Target Height set to "..u6 elseif u5=="/G"then if u6==nil or u6==""then bV="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if u6=="dump"then for dy,dj in pairs(i9())do if type(dj.get())=="boolean"then if dj.get()==true then a.print(dy.." true")else a.print(dy.." false")end elseif dj.get()==nil then a.print(dy.." nil")else a.print(dy.." "..dj.get())end end;return end;L=string.find(u6," ")local uc=string.sub(u6,0,L-1)local ud=string.sub(u6,L+1)for dy,dj in pairs(i9())do if dy==uc then bV="Variable "..uc.." changed to "..ud;local ue=type(dj.get())if ue=="number"then ud=d9(ud)if dy=="AtmoSpeedLimit"then cu=ud end elseif ue=="boolean"then if string.lower(ud)=="true"then ud=true else ud=false end end;dj.set(ud)return end end;bV="No such global variable: "..uc elseif u5=="/deletewp"then if bi>0 and fU~=nil then cm.ClearCurrentPosition()else bV="Select a custom wp to delete first in IPH"end elseif u5=="/copydatabank"then if dbHud_2 then pw(true)else bV="Spare Databank required to copy databank"end elseif u5=="/iphWP"then if bi>0 then a.print(cn.showWayPoint(b_,bh,true))a.print(json.encode(bh))bV="::pos waypoint shown in lua chat in local and world format"else bV="No target selected in IPH"end elseif u5=="/createPrivate"then local uf="privatelocations = {\n"local ug=""if#d2>0 then for dy,dj in pairs(d2)do uf=uf.."{position = {x = "..dj.position.x..", y = "..dj.position.y..", z = "..dj.position.z.."},\n ".."name = '"..dj.name.."',\n planetname = '"..dj.planetname.."',\n gravity = "..dj.gravity..",\n"if dj.heading then uf=uf.."heading = {x = "..dj.heading.x..", y = "..dj.heading.y..", z = "..dj.heading.z.."},\n"end;if dj.safe then uf=uf.."safe = true},\n"else uf=uf.."safe = false},\n"end end end;ug=#d2 .."-Private "if u6=="all"then for dy,dj in pairs(bm)do uf=uf.."{position = {x = "..dj.position.x..", y = "..dj.position.y..", z = "..dj.position.z.."},\n ".."name = '*"..dj.name.."',\n planetname = '"..dj.planetname.."',\n gravity = "..dj.gravity..",\n"if dj.heading then uf=uf.."heading = {x = "..dj.heading.x..", y = "..dj.heading.y..", z = "..dj.heading.z.."},\n"end;if dj.safe then uf=uf.."safe = true},\n"else uf=uf.."safe = false},\n"end end;ug=ug..#bm.."-Public "end;uf=uf.."}\n return privatelocations"a.logInfo("PRIVATELOCATIONS:"..uf)if screenHud_1 then screenHud_1.setHTML(uf)end;bV=ug.."locations dumped to logfile and screen if present.\n Cut and paste to privatelocations.lua to use"bW=7 end end;function tu.tagTick()if bz=="Off"then bz="All"elseif bz=="All"then bz="Longitude"elseif bz=="Longitude"then bz="Lateral"elseif bz=="Lateral"then bz="Vertical"else bz="Off"end;bV="Extra Engine Tags: "..bz;c.stopTimer("tagTick")end;return tu end;local function uh(d,b,c,a,library,e,vBooster,hover,pv,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i0,gyro,warpdrive,i1,screenHud_1)local ui={}local d7=string.format;local i2=json.decode;local uj=json.encode;local pp=b.getElementMaxHitPointsById;local i3=b.getElementMassById;local i4=d.control.isRemoteControlled;local dT=string.match;local gy=a.destroyWidgetPanel;local fH=a.updateData;local fI=a.addDataToWidget;local tt=a.lockView;local i6=a.isViewLocked;local da=math.sqrt;local d9=tonumber;local eN=math.abs;local bG=math.floor;local bH=c.getAtmosphereDensity;local eI=math.atan;local bF=a.getTime;local d8=utils.clamp;local i5=d.axisCommandManager;local uk=Z;local gA=13;local ic=b.getElementIdList()local id=0;local function db(eq,er)if eq==0 then return eN(er)<1e-09 end;if er==0 then return eN(eq)<1e-09 end;return eN(eq-er)<math.max(eN(eq),eN(er))*dp end;local function i7(dq,ul)local sn=10^(ul or 0)return bG(dq*sn+0.5)/sn end;local function i8(um,un)for dy,dj in pairs(un)do if type(dy)=="string"then um[dy]=dj else um[#um+1]=un[dy]end end;return um end;local function i9(uo)local up={}if not uo then i8(up,K)i8(up,a8)i8(up,az)i8(up,aV)return up elseif uo=="boolean"then return K elseif uo=="handling"then return a8 elseif uo=="hud"then return az elseif uo=="physics"then return aV end end;local function pw(uq)local function ur(us)for dy,dj in pairs(us)do dbHud_1.setStringValue(dy,uj(dj.get()))if uq and dbHud_2 then dbHud_2.setStringValue(dy,uj(dj.get()))end end end;if dbHud_1 then ur(bC)ur(i9())a.print("Saved Variables to Datacore")if uq and dbHud_2 then bV="Databank copied.  Remove copy when ready."end end end;local function fJ(ut,uu,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..ut.."|"..uu.."|"..ay)else a.logInfo("sound_notification|audiopacks/"..h.."/"..ut.."|"..uu.."|"..ay)end else a.logInfo("sound_q|audiopacks/"..h.."/"..ut.."|"..uu.."|"..ay)end end;local function gz(ha,hb,sl,js,uv)if js==nil then js=""end;if uv==nil then uv=""end;return d7([[<text class="%s" x=%s y=%s style="%s">%s</text>]],js,ha,hb,uv,sl)end;local function ia(c2,uw)local ux=c2>100000;if uw==nil then uw=1 end;if ux then return i7(c2/1000/200,uw).."SU"elseif c2<1000 then return i7(c2,uw).."M"else return i7(c2/1000,uw).."KM"end end;local function ib(uy)local uz=0;local uA=0;local uB=0;if uy<60 then uy=bG(uy)elseif uy<3600 then uz=bG(uy/60)uy=bG(uy%60)elseif uy<86400 then uA=bG(uy/3600)uz=bG(uy%3600/60)else uB=bG(uy/86400)uA=bG(uy%86400/3600)end;if uB>0 then return uB.."d "..uA.."h "elseif uA>0 then return uA.."h "..uz.."m "elseif uz>0 then return uz.."m "..uy.."s"elseif uy>0 then return uy.."s"else return"0s"end end;function ui.onStart()local uC=false;local function uD()local function uE(uF)local uG=dbHud_1.hasKey;for dy,dj in pairs(uF)do if uG(dy)then local dt=i2(dbHud_1.getStringValue(dy))if dt~=nil then dj.set(dt)uC=true end end end end;if dbHud_1 then if not f then uE(i9())coroutine.yield()uE(bC)else uE(bC)bV="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bW=5;uC=false end;coroutine.yield()if uC then bV="Loaded Saved Variables"cc=a9;cd=aa;aW=j;g=string.lower(g)cs=p;cu=V elseif not f then bV="No Saved Variables Found - Exit HUD to save settings"end;if bA<1.500 then if U<2000 then bV="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bA=VERSION_NUMBER;if#bm>0 then d3=i8(d3,bm)end else bV="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bt+180<bI then br=0 end;bt=bI;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bV="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bW=7 end;if antigrav and not q then if bs==nil then bs=c9 end;antigrav.setBaseAltitude(bs)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then d2=require("autoconf/custom/archhud/privatelocations")if#d2>0 then d3=i8(d3,d2)end end;lm="Proceeding to Waypoint"end;local function uH()local function uI(uJ,uK)if uJ>uK then uK=uJ end;local uL,uM=0,0;if a6>0 then uL=a6*0.05 end;if a7>0 then uM=a7*0.05 end;uK=uK*(1-(uL+uM))return uK end;local uN=b.getElementNameById;local uO=aq~=0 and ar~=0;for dy in pairs(ic)do local type=b.getElementTypeById(ic[dy])if dT(type,'^.*Atmospheric Engine$')then if dT(tostring(b.getElementTagsById(ic[dy])),'^.*vertical.*$')and b.getElementForwardById(ic[dy])[3]>0 then cI=true end end;if dT(type,'^.*Space Engine$')then cz=true;if dT(tostring(b.getElementTagsById(ic[dy])),'^.*vertical.*$')then local uP=b.getElementForwardById(ic[dy])if uP[3]<0 then uQ=true else cy=true end end end;if type=="Landing Gear"then bO=true end;if type=="Dynamic Core Unit"then local pr=pp(ic[dy])if pr>10000 then gA=110 elseif pr>1000 then gA=55 elseif pr>150 then gA=27 end end;id=id+pp(ic[dy])if uO and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pr=pp(ic[dy])local oa=i3(ic[dy])local uJ=0;local jm=bF()if type=="Atmospheric Fuel Tank"then local uK=400;local uR=35.03;if pr>10000 then uK=51200;uR=5480 elseif pr>1300 then uK=6400;uR=988.67 elseif pr>150 then uK=1600;uR=182.67 end;uJ=oa-uR;if a3>0 then uK=uK+uK*a3*0.2 end;uK=uI(uJ,uK)ce[#ce+1]={ic[dy],uN(ic[dy]),uK,uR,uJ,jm}end;if type=="Rocket Fuel Tank"then local uK=320;local uR=173.42;if pr>65000 then uK=40000;uR=25740 elseif pr>6000 then uK=5120;uR=4720 elseif pr>700 then uK=640;uR=886.72 end;uJ=oa-uR;if a5>0 then uK=uK+uK*a5*0.1 end;uK=uI(uJ,uK)cg[#cg+1]={ic[dy],uN(ic[dy]),uK,uR,uJ,jm}end;if type=="Space Fuel Tank"then local uK=600;local uR=35.03;if pr>10000 then uK=76800;uR=5480 elseif pr>1300 then uK=9600;uR=988.67 elseif pr>150 then uK=2400;uR=182.67 end;uJ=oa-uR;if a4>0 then uK=uK+uK*a4*0.2 end;uK=uI(uJ,uK)cf[#cf+1]={ic[dy],uN(ic[dy]),uK,uR,uJ,jm}end end end;if not cI then b6,aX=false,false end end;local function uS()if gyro~=nil then cb=gyro.getState()==1 end;if not by then i5:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then tt(1)else tt(0)end;if door and(c7 or not c7 and c9<10000)then for dD,dj in pairs(door)do dj.toggle()end end;if switch then for dD,dj in pairs(switch)do dj.toggle()end end;if forcefield and(c7 or not c7==0 and c9<10000)then for dD,dj in pairs(forcefield)do dj.toggle()end end;if antigrav then cJ=antigrav.getState()==1;if cJ and not q then antigrav.show()end end;if i4()==1 and k then a.freeze(1)else a.freeze(0)end;if bO then bj=d.control.isAnyLandingGearExtended()==1;if bj then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c6~=-1 or not c7 and cC:len()<50 then aY=true;bj=true;if bO then d.control.extendLandingGears()end else aY=false end;i5:setTargetGroundAltitude(uk)if c7 and c6~=-1 then cj=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;pd=c7 end;local function uT()local uU={}local function uV()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local uW={[1]=4480,[6]=4480,[7]=6270}for uX,uY in pairs(e)do e[uX][0]=uV()e[uX][0].systemId=uX;uU[uX]={}for uZ,iO in pairs(e[uX])do iO.gravity=iO.gravity/9.8;iO.center=vec3(iO.center)iO.name=iO.name[1]iO.noAtmosphericDensityAltitude=iO.atmosphereThickness or iO.atmosphereRadius-iO.radius;if iO.name=="Lacobus"then iO.noAtmosphericDensityAltitude=12510 end;iO.spaceEngineMinAltitude=uW[iO.id]or 0.68377*iO.atmosphereThickness;iO.planetarySystemId=uX;iO.bodyId=iO.id;uU[uX][uZ]=iO;if mf==nil or iO.center.x<mf then mf=iO.center.x end;if me==nil or iO.center.x>me then me=iO.center.x end;if mi==nil or iO.center.y<mi then mi=iO.center.y end;if mh==nil or iO.center.y>mh then mh=iO.center.y end;if iO.center and iO.name~="Space"then cY[#cY+1]=iO end end end;e2=d6(d,b,c,a,d7,d8,d9,da,db)ch=e2(uU)ci=eM(d,b,c,a,da,eN)ck=fg(d,b,c,a,d7,d8,d9,da,db)cm=fG(d,b,c,a,dbHud_1,e,fH,fI,bG,d9,da,fJ)end;u_=false;v0=coroutine.create(function()i5:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})uD()coroutine.yield()uH()coroutine.yield()cn=pu(d,b,c,a,e,vBooster,hover,pv,antigrav,warpdrive,dbHud_1,eN,bG,bH,i4,eI,bF,d8,i5,fH,i6,da,i7,fJ,i8,db,ia,ib,pw,i2,d7,fI)uS()coroutine.yield()uT()co=gx(b,a,c,library,radar_1,radar_2,eN,gy,da,gz,d9,gA,fJ)cl=h_(d,b,c,a,e,radar_1,radar_2,antigrav,hover,i0,warpdrive,i1,eN,bG,d7,i2,bH,i3,i4,eI,bF,d8,i5,fI,fH,gy,i6,da,i7,gz,fJ,i8,i9,ia,ib,ic,id)cl.ButtonSetup()cp=ts(d,b,c,a,e,vBooster,hover,antigrav,i0,dbHud_2,gyro,screenHud_1,i4,i5,i6,tt,gy,i7,dT,d9,d8,fJ,i9,pw)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)c.setTimer("radarTick",aP)c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)fJ("start","SU")end)coroutine.resume(v0)end;function ui.onUpdate()if not u_ then local hQ=coroutine.status(v0)if hQ=="suspended"then local dz,hR=coroutine.resume(v0)if hR then a.print("ERROR STARTUP: "..hR)end elseif hQ=="dead"then u_=true end end;if u_ then d:update()if c7 and u and cK then if cK and bN then cn.cmdThrottle(0)bN=false elseif not cK and not bN then bJ=0;bN=true end end;if d0 then i5:setThrottleCommand(axisCommandId.longitudinal,d0)d0=nil end;if not cq and oT~=v1 then a.setScreen(oT)end;v1=oT end end;function ui.onFlush()if u_ then cn.onFlush()end end;function ui.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c8>0 or c8==0 and c9<10000)then for dD,dj in pairs(door)do dj.toggle()end end;if switch then for dD,dj in pairs(switch)do dj.toggle()end end;if forcefield and(c8>0 or c8==0 and c9<10000)then for dD,dj in pairs(forcefield)do dj.toggle()end end;x=c_;pw()if nM then nM.activate()end;if A then cn.showWayPoint(iO,cH)end;local og=1-(a6*0.05+a7*0.05)a.print(cl.FuelUsed("atmofueltank")..", "..cl.FuelUsed("spacefueltank")..", "..cl.FuelUsed("rocketfueltank"))fJ("stop","SU")end;function ui.controlStart(tB)if u_ then cp.startControl(tB)end end;function ui.controlStop(tB)if u_ then cp.stopControl(tB)end end;function ui.controlLoop(tB)if u_ then cp.loopControl(tB)end end;function ui.controlInput(sl)if u_ then cp.inputTextControl(sl)end end;function ui.radarEnter(dI)co.onEnter(dI)end;function ui.radarLeave(dI)co.onLeave(dI)end;function ui.onTick(v2)if v2=="tenthSecond"then cn.TenthTick()cl.TenthTick()elseif v2=="oneSecond"then cl.OneSecondTick()elseif v2=="fiveSecond"then cn.SatNavTick()elseif v2=="msgTick"then cl.MsgTick()elseif v2=="animateTick"then cl.AnimateTick()elseif v2=="hudTick"then cl.hudtick()elseif v2=="apTick"then cn.APTick()elseif v2=="radarTick"then co.UpdateRadar()elseif v2=="tagTick"then cp.tagTick()elseif v2=="contact"then co.ContactTick()end end;return ui end;function script.onStart()v3.onStart()end;function script.onStop()v3.onStop()end;function script.onTick(v2)v3.onTick(v2)end;function script.onFlush()v3.onFlush()end;function script.onUpdate()v3.onUpdate()end;function script.onActionStart(tB)v3.controlStart(tB)end;function script.onActionStop(tB)v3.controlStop(tB)end;function script.onActionLoop(tB)v3.controlLoop(tB)end;function script.onInputText(sl)v3.controlInput(sl)end;function script.onEnter(dI)v3.radarEnter(dI)end;function script.onLeave(dI)v3.radarLeave(dI)end;bE(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)v3=uh(d,b,c,a,library,e,vBooster,hover,pv,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,i0,gyro,warpdrive,i1,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
