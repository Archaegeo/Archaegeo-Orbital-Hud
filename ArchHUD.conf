name: ArchHud - Archaegeo v1.144 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.144;SetWaypointOnExit=true;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=core.getConstructMass;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local tostring=tostring;local p=utils.round;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=SafeR;local D=SafeB;local E=SafeG;local F=false;local G=0;local H=0;local I=0;local J=false;local K=0;local L=false;local M=y(ResolutionX/2,0)local N=y(ResolutionY/2,0)local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=false;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=""local am=0;local an=false;local ao=false;local ap=false;local aq=-1;local ar=false;local as=""local at=j()>0;local au=j()local av=core.getAltitude()local aw=core.getElementIdList()local ax=q()local ay=nil;local az=false;local aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]local aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=0;local aP=nil;local aQ={}local aR={}local aS={}local aT=0;local aU=false;local aV={}local aW={}local aX=d(1/apTickRate)*2;local aY={}local aZ={}local a_={}local b0={}local b1=false;local b2=16;local b3=0;local b4=nil;local b5=""local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=nil;local bf=false;local bg=false;local bh=autoRollPreference;local bi=LandingGearGroundHeight;local bj=false;local bk=q()local bl=0;local bm=0;local bn=0;local bo=AtmoSpeedLimit;local bp=0;local bq=nil;local br=0;local bs=0;local bt=false;local bu=false;local bv={VectorToTarget=false}local bw=false;local bx=0;local by=nil;local bz=false;local bA=false;local bB=false;local bC=false;local bD=0;local bE=q()local bF=vec3(core.getConstructWorldOrientationUp())local bG=vec3(core.getConstructWorldOrientationForward())local bH=vec3(core.getConstructWorldOrientationRight())local bI=vec3(core.getWorldVelocity())local bJ=vec3(bI):len()local bK=vec3(core.getWorldVertical())local bL=-bK:dot(bI)local bM=vec3(core.getConstructWorldPos())local bN=false;local bO=false;local bP=nil;local bQ=true;local bR=0;local bS=0;local bT=false;local bU={}local bV=showHud;local function bW(bX,bY)for i=1,#bY do table.insert(bX,bY[i])end;return bX end;local function bZ(b_)local c0={}local c1={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit"}local c2={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c3={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c4={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not b_ then bW(c0,c1)bW(c0,c2)bW(c0,c3)bW(c0,c4)return c0 elseif b_=="boolean"then return c1 elseif b_=="handling"then return c2 elseif b_=="hud"then return c3 elseif b_=="physics"then return c4 end end;local function c5(c6,c7,c8,c9,ca)if c9==nil then c9=""end;if ca==nil then ca=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],c9,c6,c7,ca,c8)end;local function cb(cc,cd)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cd then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cc)H=r(y(cc*100,0)/100,-1,1)end;local function ce(cc,cd)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cd then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cc)bP=cc end;local function cf()AtlasOrdered={}for cg,ch in pairs(b4[0])do table.insert(AtlasOrdered,{name=ch.name,index=cg})end;local function ci(cj,ck)return cj.name<ck.name end;table.sort(AtlasOrdered,ci)end;local function cl(cm,cn)if cm==0 then return c(cn)<1e-09 end;if cn==0 then return c(cm)<1e-09 end;return c(cm-cn)<math.max(c(cm),c(cn))*epsilon end;local function co(aj,cp)local cq=aj>100000;local cr,cs=""if cp==nil then cp=1 end;if cq then cr,cs=y(aj/1000/200,cp),"SU"elseif aj<1000 then cr,cs=y(aj,cp),"M"else cr,cs=y(aj/1000,cp),"KM"end;return cr,cs end;local function ct(cu)for cg,ch in pairs(cu)do if ch.name and ch.name==CustomTarget.name then return cg end end;return-1 end;local function cv()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bh=true;af=0;if at and aq==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ce(d(bo))end else VertTakeOff=true;AltitudeHold=false;bz=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cw()bz=false;br=nil;bs=nil;bD=0;if au==0 then if IntoOrbit then IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bh=true;if by==nil then by=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bt=false;by=nil;bh=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bv.VectorToTarget=false;bv.AutopilotAlign=false;bw=false end end;local function cx()if bE-bm<1.5 then if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000;bx=HoldAltitude;bw=true;if not IntoOrbit then cw()end;bt=true end end;bm=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bm=bE end;if unit.getClosestPlanetInfluence()>0 and au==0 then bx=av;bw=true;bt=true;cw()if IntoOrbit then bm=bE else bm=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;bh=true;LockPitch=nil;bz=false;if aq==-1 then AutoTakeoff=false;if bm>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=av end end;if VertTakeOff then cv()end else AutoTakeoff=true;if bm>-1 then HoldAltitude=av+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bN then cv()end end;if ao then HoldAltitude=100000 end else if IntoOrbit then cw()end;if VertTakeOff then cv()end;bh=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bm=0 end end;local function cy()if m()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bh=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local function cz()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local cA=AtlasOrdered[AutopilotTargetIndex].index;local cB=b4[0][cA]if cB.center then AutopilotTargetName=cB.name;ab=ba[0][cA]if CustomTarget~=nil then if au==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=cB;for _,ch in pairs(ba[0])do if ch.name==CustomTarget.planetname then ab=ch;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=bd(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function cC(cD)if not Autopilot and not VectorToTarget and not ao and not IntoOrbit then if cD==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then cz()else local cA=AtlasOrdered[AutopilotTargetIndex].index;local cB=b4[0][cA]if cB.name=="Space"then if cD==nil then cC()else cC(1)end else cz()end end else a1="Disengage autopilot before changing Interplanetary Helper"end end;local function cE(planet,cF)local function cG(cH,cI)local cJ=vec3(cI)if cH.bodyId==0 then return setmetatable({latitude=cJ.x,longitude=cJ.y,altitude=cJ.z,bodyId=0,systemId=cH.planetarySystemId},MapPosition)end;local cK=cJ-cH.center;local aj=cK:len()local cL=aj-cH.radius;local cM=0;local cN=0;if not cl(aj,0)then local cO=n(cK.y,cK.x)cN=cO>=0 and cO or 2*math.pi+cO;cM=math.pi/2-math.acos(cK.z/aj)end;return setmetatable({latitude=math.deg(cM),longitude=math.deg(cN),altitude=cL,bodyId=cH.bodyId,systemId=cH.planetarySystemId},MapPosition)end;local cP=cG(planet,cF)cP="::pos{"..cP.systemId..","..cP.bodyId..","..cP.latitude..","..cP.longitude..","..cP.altitude.."}"system.setWaypoint(cP)end;local function cQ()local function cR(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cx()end end;VectorStatus="Proceeding to Waypoint"end;if bE-bn<1.5 and au>0 then if not bC then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if au>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+1000 end;bn=-1;if Autopilot or VectorToTarget then return end end else bn=bE end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ao then cz()cE(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if au~=0 then ao=true;cx()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if au>0 then if not VectorToTarget then cR(SpaceTarget)end else if av>AutopilotTargetOrbit*1.5 or av==0 then bz=false;Autopilot=true elseif not at then if IntoOrbit then cw()end;bx=planet.noAtmosphericDensityAltitude+1000;bw=true;bv.AutopilotAlign=true;bv.VectorToTarget=true;bt=false;if not IntoOrbit then cw()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if au~=0 then ao=true;cx()else Autopilot=true end end elseif au==0 then local cS=unit.getClosestPlanetInfluence()>0;if CustomTarget==nil and(ab.name==planet.name and cS)and not IntoOrbit then WaypointSet=false;bz=false;bt=false;cw()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else ao=true;cx()end else ao=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=av;TargetSet=false;Reentry=false;if IntoOrbit then cw()end end end;local function cT(cU)local cV=-1;local cW;cV=ct(SavedLocations)if cV~=-1 then local cX;if cU~=nil then cW={position=SavedLocations[cV].position,name=cU,atmosphere=SavedLocations[cV].atmosphere,planetname=SavedLocations[cV].planetname,gravity=SavedLocations[cV].gravity}else cW={position=bM,name=SavedLocations[cV].name,atmosphere=au,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cV]=cW;cV=-1;cV=ct(b4[0])if cV>-1 then b4[0][cV]=cW end;cf()a1=CustomTarget.name.." position updated"AutopilotTargetIndex=0;cz()else a1="Name Not Found"end end;local function cY()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bh=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then cv()end;if IntoOrbit then cw()end;LockPitch=nil;bh=autoRollPreference;an=false;ap=false;af=0 end end;local function cZ(c_,d0,d1)local function d2(c_,d3)c_=vec3(c_)d3=vec3(d3):normalize()local cr=c_*d3;return cr.x+cr.y+cr.z end;local d4=0.001;local d5=1;if not at or not bj or aq~=-1 or bJ<P then local d6=d1;if d6==nil then d6=DampingMultiplier end;if d0==nil then d0=d4 end;c_=vec3(c_):normalize()local d7=vec3()-c_;local d8=-d2(d7,core.getConstructWorldOrientationRight())*d5;local d9=-d2(d7,core.getConstructWorldOrientationUp())*d5;if aD==0 then aD=d8/2 end;if aE==0 then aE=d9/2 end;if c(d8)<0.1 then U=U-d8*2 else U=U-(d8+(d8-aD)*d6)end;if c(d9)<0.1 then T=T+d9*2 else T=T+d9+(d9-aE)*d6 end;aD=d8;aE=d9;if c(d8)<d0 and c(d9)<d0 then return true end;return false elseif bj and aq==-1 then c_=bI;local d6=d1;if d6==nil then d6=DampingMultiplier end;if d0==nil then d0=d4 end;c_=vec3(c_):normalize()local d7=bG-c_;local d8=-d2(d7,core.getConstructWorldOrientationRight())*d5;local d9=-d2(d7,core.getConstructWorldOrientationUp())*d5;if aD==0 then aD=d8/2 end;if aE==0 then aE=d9/2 end;if c(d8)<0.1 then U=U-d8*5 else U=U-(d8+(d8-aD)*d6)end;if c(d9)<0.1 then T=T+d9*5 else T=T+d9+(d9-aE)*d6 end;aD=d8;aE=d9;if c(d8)<d0 and c(d9)<d0 then return true end;return false end end;local function da()if Reentry then a1="Re-Entry cancelled"Reentry=false;bh=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not Q then StrongBrakes=planet.gravity*9.80665*l()<LastMaxBrakeInAtmo;if not StrongBrakes then a1="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bh=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bo end else Reentry=true;AltitudeHold=true;bh=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local c8,db=co(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bo.." Target Altitude: "..c8 ..db;ce(d(bo))end;AutoTakeoff=false end;local function dc()if antigrav and not ExternalAGG then if bO then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function dd(de)local df=0;local dg=0;local dh=0;if de<60 then de=d(de)elseif de<3600 then df=d(de/60)de=d(de%60)elseif de<86400 then dg=d(de/3600)df=d(de%3600/60)else dh=d(de/86400)dg=d(de%86400/3600)end;if dh>0 then return dh.."d "..dg.."h "elseif dg>0 then return dg.."h "..df.."m "elseif df>0 then return df.."m "..de.."s"elseif de>0 then return de.."s"else return"0s"end end;local function di()local dj=-1;if telemeter_1 then dj=telemeter_1.getDistance()end;if aq~=-1 and dj~=-1 then if aq<dj then return aq else return dj end elseif aq~=-1 then return aq else return dj end end;local function dk(dl)local function dm(dn)for cg,ch in pairs(dn)do dbHud_1.setStringValue(ch,g(_G[ch]))if dl and dbHud_2 then dbHud_2.setStringValue(ch,g(_G[ch]))end end end;if dbHud_1 then if not ae then dm(b)dm(bZ())system.print("Saved Variables to Datacore")if dl and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end end;local function dp()local dq=-1;local dr=-1;if vBooster then dq=vBooster.distance()end;if hover then dr=hover.distance()end;if dq~=-1 and dr~=-1 then if dq<dr then return dq else return dr end elseif dq~=-1 then return dq elseif dr~=-1 then return dr else return-1 end end;local function ds()local function dt(ch)if aK==1920 then return ch else return y(aK*ch/1920,0)end end;local function du(ch)if aL==1080 then return ch else return y(aL*ch/1080,0)end end;local function dv()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function dw()local dx="TRAVEL"if not bQ then dx="CRUISE"end;if Autopilot then dx="AUTOPILOT"end;return dx end;local function dy(dz,b1,c6,dA,dB,dC,dD,dE)local dF=1;local dG=2;local dH=3;local dI=4;local dJ=5;local dK=6;local dL=""local dM=0;local dN=fuelY;local dO=fuelY+10;if m()==1 and not RemoteHud then dN=dN-50;dO=dO-50 end;if dB=="ATMO"then dL="atmofueltank"elseif dB=="SPACE"then dL="spacefueltank"else dL="rocketfueltank"end;dM=_G[dL.."_size"]if#dC>0 then for i=1,#dC do local dP=string.sub(dC[i][dG],1,12)local dQ=0;for dR=1,dM do if dC[i][dG]==f(unit[dL.."_"..dR].getData()).name then dQ=dR;break end end;if b1 or dD[i]==nil or dE[i]==nil then local dS=0;local dT=0;local dU=0;local dV=0;local dW=q()if dQ~=0 then dE[i]=f(unit[dL.."_"..dQ].getData()).percentage;dD[i]=f(unit[dL.."_"..dQ].getData()).timeLeft;if dD[i]=="n/a"then dD[i]=0 end else dU=k(dC[i][dF])-dC[i][dI]dS=dC[i][dH]dE[i]=d(0.5+dU*100/dS)dT=dC[i][dJ]dV=dC[i][dK]if dT<=dU then dD[i]=0 else dD[i]=d(0.5+dU/((dT-dU)/(dW-dV)))end;dC[i][dJ]=dU;dC[i][dK]=dW end end;if dP==dA then dP=e("%s %d",dB,i)end;if dQ==0 then dP=dP.." *"end;local dX;if dD[i]==0 then dX="n/a"else dX=dd(dD[i])end;if dE[i]~=nil then local dY=d(dE[i]*2.55)local dZ=e("rgb(%d,%d,%d)",255-dY,dY,0)local c9=""if dX~="n/a"and dD[i]<120 or dE[i]<5 then if b1 then c9=[[class="red"]]end end;dz[#dz+1]=c5(c6,dN,dP,c9 .." pdim txtfuel")dz[#dz+1]=c5(c6,dO,e("%d%% %s",dE[i],dX),"pdim txtfuel","fill:"..dZ)dN=dN+30;dO=dO+30 end end end end;local function d_(dz,cL)if cL<200000 and not at or cL and at then local e0=0;if c(bL)>1 then e0=45*math.log(c(bL),10)if bL<0 then e0=-e0 end end;dz[#dz+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bL),d(e0))end;return dz end;local function e1(e2)local cD=-bK;e2=e2-e2:project_on(cD)local e3=vec3(0,0,1)e3=e3-e3:project_on(cD)local e4=e3:cross(cD)local e0=e3:angle_between(e2)*constants.rad2deg;if e2:dot(e4)<0 then e0=360-e0 end;return e0 end;local function e5(dz,centerX,centerY,e6,e7,cS)local e8=circleRad;local e9=20;local ea=d(e6)if cS then for i=-45,45,5 do local eb=i;dz[#dz+1]=e([[<g transform="rotate(%f,%d,%d)">]],eb,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;dz[#dz+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+e8+e9-len,centerX,centerY+e8+e9)end;dz[#dz+1]=c5(centerX,centerY+e8+e9-35,e7,"pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY+e8+e9-25,ea.." deg","pdim txt txtmid")dz[#dz+1]=e([[<g transform="rotate(%f,%d,%d)">]],-e6,centerX,centerY)dz[#dz+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+e8+e9-20,centerX+5,centerY+e8+e9-20,centerX,centerY+e8+e9-15)dz[#dz+1]="</g>"end;local ec=ea;if cS then ec=e1(bG)end;local ed=20;local ee=d(ec)local ef=0;local eg=centerY+e8+e9+20;local eh=centerX;if e7~="YAW"then eg=du(130)eh=dt(960)end;local ei=[[<path class="txttick line" d="]]for i=d(ee-(ed+10)-ee%5+0.5),d(ee+ed+10+ee%5+0.5),5 do local c6=eh+-i*5+ec*5;if i%10==0 then ef=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;dz[#dz+1]=c5(c6+5,eg-12,z)elseif i%5==0 then ef=5 end;if ef==10 then ei=e([[%s M %f %f v %d]],ei,c6,eg-5,ef)else ei=e([[%s M %f %f v %d]],ei,c6,eg-2.5,ef)end end;dz[#dz+1]=ei..[["/>]]dz[#dz+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],eh-5,eg+10,eh+5,eg+10,eh,eg+5)if cS then e7="HDG"end;dz[#dz+1]=c5(eh,eg+25,ee.."deg","pdim txt txtmid","")dz[#dz+1]=c5(eh,eg+35,e7,"pdim txt txtmid","")end;local function ej(dz,ek,e6,centerX,centerY,cS,el,em)local e8=circleRad;local en=d(e8*3/5)if e8>0 then local eo=d(ek)local len=0;local ei=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*e6,centerX,centerY)if not at then ei=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;dz[#dz+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],e8-1,centerX,centerY)dz[#dz+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(eo-30-eo%5+0.5),d(eo+30+eo%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c7=centerY+-i*5+ek*5;if len==30 then ei=e([[%s M %d %f h %d]],ei,centerX-en-len,c7,len)if at then dz[#dz+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*e6,centerX,centerY,centerX-en+10,c7,i)dz[#dz+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*e6,centerX,centerY,centerX+en-10,c7,i)if i==0 or i==180 or i==-180 then dz[#dz+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*e6,centerX,centerY,centerX-en+20,c7,en*2-40)end else dz[#dz+1]=c5(centerX-en+10,c7,i,"pdim txt txtmid")dz[#dz+1]=c5(centerX+en-10,c7,i,"pdim txt txtmid")end;ei=e([[%s M %d %f h %d]],ei,centerX+en,c7,len)else ei=e([[%s M %d %f h %d]],ei,centerX-en-len,c7,len)ei=e([[%s M %d %f h %d]],ei,centerX+en,c7,len)end end;dz[#dz+1]=ei..[["/>]]local ep="PITCH"if not cS then ep="REL PITCH"end;if ek>90 and not at then ek=90-(ek-90)elseif ek<-90 and not at then ek=-90-(ek+90)end;if e8>200 then if at then if em>P then dz[#dz+1]=c5(centerX,centerY-15,"Yaw","pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY+20,el,"pdim txt txtmid")end;dz[#dz+1]=e([[<g transform="rotate(%f,%d,%d)">]],-e6,centerX,centerY)else dz[#dz+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;dz[#dz+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-en+25,centerY-5,centerX-en+20,centerY,centerX-en+25,centerY+5,centerX-en+50,centerY+4,eo)dz[#dz+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+en-25,centerY-5,centerX+en-20,centerY,centerX+en-25,centerY+5,centerX+en-30,centerY+4,eo)dz[#dz+1]="</g>"end;local eq=d(e8/3)dz[#dz+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-eq,centerY,e8-eq)if not at and cS then dz[#dz+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*e6,centerX,centerY,centerX-en+10,centerY,en*2-20)end;dz[#dz+1]="</g>"if e8<200 then if at and em>P then dz[#dz+1]=c5(centerX,centerY-e8,ep,"pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY-e8+10,eo,"pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY-15,"Yaw","pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY+20,el,"pdim txt txtmid")else dz[#dz+1]=c5(centerX,centerY-e8,ep,"pdim txt txtmid")dz[#dz+1]=c5(centerX,centerY-e8+15,eo,"pdim txt txtmid")end end end end;local function er(dz,cL,cS)local es=altMeterX;local et=altMeterY;local eu=78;local ev=19;local ew=di()if ew~=-1 then dz[#dz+1]=c5(es+eu,et+ev+20,e("AGL: %.1fm",ew),"pdim altsm txtend")end;if cS and(cL<200000 and not at or cL and at)then table.insert(dz,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],es-1,et-4,eu+2,ev+6,es+1,et-1,eu-4,ev))local cV=0;local ex=1;local ey=0;local ez=cL<0;local eA=9;if ez then eA=0 end;local cL=c(cL)while cV<6 do local eB=11;local eC=16;local eD=9;local eE=14;local c9="altsm"if cV>2 then eC=eC+3;eB=eB+2;eE=eE+2;eD=eD-6;c9="altbig"end;if ez then c9=c9 .." red"end;local eF=cL/ex%10;local eG=d(eF)local eH=d((eG+1)%10)local eI=ey;if cV==0 then eI=eF-eG;if ez then eI=1-eI end end;if ez and(cV==0 or ey~=0)then local eJ=eH;eH=eG;eG=eJ end;local eK=eC*(eI-1)local eL=eK+eC;local c6=es+eD+(6-cV)*eB;local c7=et+eE;dz[#dz+1]=c5(c6,c7+eK,eH,c9)dz[#dz+1]=c5(c6,c7+eL,eG,c9)cV=cV+1;ex=ex*10;if eG==eA then ey=eI else ey=0 end end;table.insert(dz,[[</g></g>]])end end;local function eM(eN)eN=vec3(eN)local eO=-math.deg(n(eN.y,eN.z))+180;eO=eO-90;if eO<0 then eO=360+eO end;if eO>180 then eO=-180+eO-180 end;return-eO end;local function eP(eN)eN=vec3(eN)local ec=math.deg(n(eN.y,eN.x))-90;if ec<-180 then ec=360+ec end;return ec end;local function eQ(dz,eN,em,centerX,centerY)if em>5 and not at or em>P then local e8=circleRad;local eR=20;local eS=20;local eT=vec3(eN)local eU=eM(eT)local eV=eP(eT)local eW=14;local eX=eW/2;local eY=-eV/eS*e8;local eZ=eU/eR*e8;local c6=centerX+eY;local c7=centerY+eZ;local aj=math.sqrt(eY^2+eZ^2)local e_=[[<circle
                            cx="]]..c6 ..[["
                            cy="]]..c7 ..[["
                            r="]]..eX/eW..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c6 ..[["
                            cy="]]..c7 ..[["
                            r="]]..eX..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c6-eW..[[,]]..c7 ..[[ h ]]..eX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c6+eX..[[,]]..c7 ..[[ h ]]..eX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c6 ..[[,]]..c7-eW..[[ v ]]..eX..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<e8 then dz[#dz+1]=e_ else local e0=n(eZ,eY)local f0=4;local f1=centerX+e8*math.cos(e0)local f2=centerY+e8*math.sin(e0)dz[#dz+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',e0*180/math.pi,f1,f2,f1-f0,f2-f0/2,f0*2,f0,f1+f0,f2-f0,f0,f0,-f0,f0)end;if not at then eU=eM(-eT)eV=eP(-eT)eY=-eV/eS*e8;eZ=eU/eR*e8;c6=centerX+eY;c7=centerY+eZ;aj=math.sqrt(eY^2+eZ^2)if aj<e8 then local f3=[[<circle
                                    cx="]]..c6 ..[["
                                    cy="]]..c7 ..[["
                                    r="]]..eX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c6 ..[[,]]..c7-eW..[[ v ]]..eX..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c6 ..[[,]]..c7 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c6 ..[[,]]..c7 ..[[)" />
                                <path
                                    d="M ]]..c6-eX..[[,]]..c7 ..[[ h ]]..eW..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c6 ..[[,]]..c7 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c6 ..[[,]]..c7 ..[[)"/>]]dz[#dz+1]=f3 end end end end;local function f4(dz,dx,f5,f6)f5=d(f5+0.5)local dN=throtPosY+10;local dO=throtPosY+20;if m()==1 and not RemoteHud then dN=55;dO=65 end;local f7="CRUISE"local unit="km/h"local cc=f6;if dx=="TRAVEL"or dx=="AUTOPILOT"then f7="THROT"unit="%"cc=f5;local f8="dim"if f5<0 then f8="red"end;dz[#dz+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],f8,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(f5),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;dz[#dz+1]=c5(throtPosX+10,dN,f7,"pbright txtstart")dz[#dz+1]=c5(throtPosX+10,dO,e("%.0f %s",cc,unit),"pbright txtstart")if at and AtmoSpeedAssist and bQ and J then f5=d(K*100+0.5)local f8="red"if f5<0 then f8="red"end;dz[#dz+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],f8,1-c(f5),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)dz[#dz+1]=c5(throtPosX+10,dN+40,"LIMIT","pbright txtstart")dz[#dz+1]=c5(throtPosX+10,dO+40,f5 .."%","pbright txtstart")end;if at and AtmoSpeedAssist or Reentry then dz[#dz+1]=c5(throtPosX+10,dN-40,"LIMIT: "..bo.." km/h","dim txtstart")elseif not at and Autopilot then dz[#dz+1]=c5(throtPosX+10,dN-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function f9(dz,fa)local fb=throtPosY-10;local fc=throtPosX+10;dz[#dz+1]=c5(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then fb=75 end;dz[#dz+1]=c5(fc,fb,d(fa).." km/h","pbright txtbig txtstart")end;local function fd(dz)dz[#dz+1]=c5(dt(1900),du(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")dz[#dz+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then dz[#dz+1]=c5(dt(960),du(550),"Warning: Invalid Control Scheme Detected","warnings")dz[#dz+1]=c5(dt(960),du(600),"Keyboard Scheme must be selected","warnings")dz[#dz+1]=c5(dt(960),du(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local fe=dt(960)local ff=du(860)local fg=du(880)local fh=du(900)local fi=du(960)local fj=du(200)local fk=du(150)local fl=du(960)if m()==1 and not RemoteHud then ff=du(135)fg=du(155)fh=du(175)fj=du(115)fk=du(95)end;if BrakeIsOn then dz[#dz+1]=c5(fe,ff,"Brake Engaged","warnings")elseif I>0 then dz[#dz+1]=c5(fe,ff,"Auto-Brake Engaged","warnings","opacity:"..I)end;if at and bj and aq==-1 then dz[#dz+1]=c5(fe,fj+50,"** STALL WARNING **","warnings")end;if ay then dz[#dz+1]=c5(fe,fl,"Gyro Enabled","warnings")end;if GearExtended then if R then dz[#dz+1]=c5(fe,fg,"Gear Extended","warn")else dz[#dz+1]=c5(fe,fg,"Landed (G: Takeoff)","warnings")end;local fm,cs=co(a:getTargetGroundAltitude())dz[#dz+1]=c5(fe,fh,"Hover Height: "..fm..cs,"warn")end;if a6 then dz[#dz+1]=c5(fe,fi+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bO and AntigravTargetAltitude~=nil then if c(av-antigrav.getBaseAltitude())<501 then dz[#dz+1]=c5(fe,fj+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else dz[#dz+1]=c5(fe,fj+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then dz[#dz+1]=c5(fe,fj+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then dz[#dz+1]=c5(fe,fj+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then dz[#dz+1]=c5(fe,fj+20,"Follow Mode Engaged","warn")elseif Reentry then dz[#dz+1]=c5(fe,fj+20,"Re-entry in Progress","warn")end;local fn,fo,fp=ba:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(fq)if fq.noAtmosphericDensityAltitude>0 then return fq.radius+fq.noAtmosphericDensityAltitude else return fq.radius+fq.surfaceMaxAltitude*1.5 end end)local fr=fo;if fp~=nil and fo~=nil then fr=math.min(fp,fo)end;if AltitudeHold or VertTakeOff then local fm,cs=co(HoldAltitude,2)if VertTakeOff then if bO then fm,cs=co(antigrav.getBaseAltitude(),2)end;dz[#dz+1]=c5(fe,fj,"VTO to "..fm..cs,"warn")elseif AutoTakeoff and not IntoOrbit then dz[#dz+1]=c5(fe,fj,"Takeoff to "..fm..cs,"warn")if BrakeIsOn and not VertTakeOff then dz[#dz+1]=c5(fe,fj+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else dz[#dz+1]=c5(fe,fj,"Altitude Hold: "..fm..cs,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if au>0.1 then dz[#dz+1]=c5(fe,fj,"Beginning ascent","warn")elseif au<0.09 and au>0.05 then dz[#dz+1]=c5(fe,fj,"Aligning trajectory","warn")elseif au<0.05 then dz[#dz+1]=c5(fe,fj,"Leaving atmosphere","warn")end end;if IntoOrbit then if bq~=nil then dz[#dz+1]=c5(fe,fj,bq,"warn")end end;if BrakeLanding then if StrongBrakes then dz[#dz+1]=c5(fe,fj,"Brake-Landing","warnings")else dz[#dz+1]=c5(fe,fj,"Coast-Landing","warnings")end end;if ProgradeIsOn then dz[#dz+1]=c5(fe,fj,"Prograde Alignment","crit")end;if RetrogradeIsOn then dz[#dz+1]=c5(fe,fj,"Retrograde Alignment","crit")end;if fr~=nil and au==0 then local fm,cs=co(fr)local travelTime=bb.computeTravelTime(bJ,0,fr)local fs="Collision"if fn.noAtmosphericDensityAltitude>0 then fs="Atmosphere"end;dz[#dz+1]=c5(fe,fk,fn.name.." "..fs.." "..dd(travelTime).." In "..fm..cs,"crit")end;if VectorToTarget and not IntoOrbit then dz[#dz+1]=c5(fe,fj+35,VectorStatus,"warn")end;dz[#dz+1]="</g>"return dz end;local function ft(em)return d(y(em*3.6,0)+0.5).." km/h"end;local function fu(dz)local fv=OrbitMapX;local fw=OrbitMapY;local fx=OrbitMapSize;local fy=4;local fz=15;local c6=0;local c7=0;local fA,fB,fC,fD;local function fE(type)local fF,bE,em,fG;if type=="Periapsis"then fF=orbit.periapsis.altitude;bE=orbit.timeToPeriapsis;em=orbit.periapsis.speed;fG=35 else fF=orbit.apoapsis.altitude;bE=orbit.timeToApoapsis;em=orbit.apoapsis.speed;fG=-35 end;dz[#dz+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c6+fG,c7-5,fv+fx/2-fA+fD,c7-5)dz[#dz+1]=c5(c6,c7,type)c7=c7+fz;local fm,cs=co(fF)dz[#dz+1]=c5(c6,c7,fm..cs)c7=c7+fz;dz[#dz+1]=c5(c6,c7,dd(bE))c7=c7+fz;dz[#dz+1]=c5(c6,c7,ft(em))end;if orbit~=nil and au<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then fw=fw+fy;c6=fv+fx+fv/2+fy;c7=fw+fx/2+5+fy;fA=fx/4;fD=0;dz[#dz+1]=[[<g class="pbright txtorb txtmid">]]dz[#dz+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',fx+fv*2,fx+fw,fy,fy)if orbit.periapsis~=nil and orbit.apoapsis~=nil then fC=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(fA*2)fB=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/fC*(1-orbit.eccentricity)fD=fA-orbit.periapsis.altitude/fC-planet.radius/fC;local fH=""if orbit.periapsis.altitude<=0 then fH='redout'end;dz[#dz+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],fH,fv+fx/2+fD+fy,fw+fx/2+fy,fA,fB)dz[#dz+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',fv+fx/2+fy,fw+fx/2+fy,planet.radius/fC)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then fE("Apoapsis")end;c7=fw+fx/2+5+fy;c6=fv-fv/2+10+fy;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then fE("Periapsis")end;dz[#dz+1]=c5(fv+fx/2+fy,planet.name,20+fy,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local fI=orbit.timeToApoapsis/orbit.period*2*math.pi;local fJ=fA*math.cos(fI)local fK=fB*math.sin(fI)dz[#dz+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',fv+fx/2+fJ+fD+fy,fw+fx/2+fK+fy)end;dz[#dz+1]=[[</g>]]return dz else return dz end end;local function fL()if radarPanelID~=nil and am==0 then t(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then t(perisPanelID)perisPanelID=nil end else if am==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;am=0 end end;local function fM(dz)local c6=50;local c7=525;local fN={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local fO={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local fP={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local fQ={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if at then bW(fN,fO)table.insert(fN,"---------------------------------------")if VertTakeOff then table.insert(fN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if aq~=-1 then if antigrav then if bO then table.insert(fN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(fN,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(fN,"Alt-6: Begins Vertical Takeoff.")else table.insert(fN,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(fN,"G: Begin BrakeLanding or Land")end else bW(fN,fP)end;if AltitudeHold then table.insert(fN,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(fN,"---------------------------------------")bW(fN,fQ)for i=1,#fN do c7=c7+12;dz[#dz+1]=c5(c6,c7,fN[i],"pdim txttick txtstart")end end;local fR={}function fR.HUDPrologue(dz)if not F then C=PvPR;E=PvPG;D=PvPB else C=SafeR;E=SafeG;D=SafeB end;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local fS=aA;local fT=aB;local fU=aA;local fV=aB;if dv()and not brightHud then fS=[[rgb(]]..d(C*0.4+0.5)..","..d(E*0.4+0.5)..","..d(D*0.3+0.5)..[[)]]fT=[[rgb(]]..d(C*0.3+0.5)..","..d(E*0.3+0.5)..","..d(D*0.2+0.5)..[[)]]end;dz[#dz+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],fS,fS,fU,fU,fT,fT,fV,fV,aK,aL)return dz end;function fR.UpdateHud(dz)local cL=av;local eN=core.getVelocity()local em=vec3(eN):len()local eO=bR;local fW=bS;local e6=fW;local ek=bR;local f5=d(unit.getThrottle())local fa=em*3.6;local f6=unit.getAxisCommandValue(0)local fX=dt(1770)local fY=du(310)if AtmoSpeedAssist and bQ then f6=H;f5=H*100 end;local dx=dw()local e7="ROLL"local cS=unit.getClosestPlanetInfluence()>0;if f5==nil then f5=0 end;if not cS then if em>5 then eO=eM(eN)fW=eP(eN)else eO=0;fW=0 end;e7="YAW"end;if G>50000 and not at then local fZ;if G>200000 then fZ=y(G/200000,2).." su"else fZ=y(G/1000,1).." km"end;dz[#dz+1]=c5(fX,fY,"PvP Boundary: "..fZ,"pbright txtbig txtmid")end;dz[#dz+1]=al;dz[#dz+1]=aF;dz[#dz+1]=ak;if b3%aX==0 then b1=true end;if fuelX~=0 and fuelY~=0 then dy(dz,b1,fuelX,"Atmospheric ","ATMO",aQ,a_,b0)dy(dz,b1,fuelX+100,"Space fuel t","SPACE",aR,aY,aZ)dy(dz,b1,fuelX+200,"Rocket fuel ","ROCKET",aS,aV,aW)end;if b1 then b1=false;b3=0 end;b3=b3+1;d_(dz,cL)if m()==0 or RemoteHud then if not dv()or brightHud then if cS then e5(dz,centerX,centerY,e6,e7,cS)ej(dz,ek,e6,centerX,centerY,cS,d(eP(eN)),em)else e5(dz,centerX,centerY,fW,e7,cS)ej(dz,eO,fW,centerX,centerY,cS,d(fW),em)end;er(dz,cL,cS)eQ(dz,eN,em,centerX,centerY)end end;f4(dz,dx,f5,f6)f9(dz,fa)fd(dz)fu(dz)if showHelp then fM(dz)end;if screen_2 then local f_=bM;local c6=960+f_.x/b6;local c7=450+f_.y/b7;screen_2.moveContent(b8,(c6-80)/19.2,(c7-80)/10.8)end;return dz end;function fR.HUDEpilogue(dz)dz[#dz+1]="</svg>"return dz end;function fR.ExtraData(dz)local g0=dt(1240)local g1=du(55)local g2=g1+10;local g3;local g4=0;local dx=dw()if VertTakeOffEngine then dx=dx.."-VERTICAL"end;if TurnBurn then dx="TB-"..dx end;local g5=vec3(core.getWorldAcceleration()):len()/9.80665;g3=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()dz[#dz+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then g0=dt(1120)g1=du(55)g2=g1+10 elseif at then local g6=dt(770)dz[#dz+1]=c5(g6,g1,"ATMOSPHERE","pdim txt txtend")dz[#dz+1]=c5(g6,g2,e("%.2f",au),"pdim txt txtend","")end;dz[#dz+1]=c5(g0,g1,"GRAVITY","pdim txt txtend")dz[#dz+1]=c5(g0,g2,e("%.2f",g3/9.80665),"pdim txt txtend")dz[#dz+1]=c5(g0,g1+20,"ACCEL","pdim txt txtend")dz[#dz+1]=c5(g0,g2+20,e("%.2f",g5),"pdim txt txtend")dz[#dz+1]=c5(dt(960),du(180),dx,"txtbig txtmid")end;function fR.DrawOdometer(dz,ac,TotalDistanceTravelled,ad)local g3;local g7=0;local g8=0;local g4=0;if at then g4=LastMaxBrakeInAtmo else g4=LastMaxBrake end;maxThrust=a:maxForceForward()aO=l()g3=planet:getGravity(planet.center+vec3(0,0,1)*planet.radius):len()if g3>0.1 then g8=aO*g3;g7=maxThrust/g3 end;dz[#dz+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],dt(660),dt(700),du(35),dt(960),du(55),dt(1240),du(35),dt(1280))if m()==0 or RemoteHud then dz[#dz+1]=c5(dt(700),du(20),e("Trip: %.2f km",ac),"txtstart")dz[#dz+1]=c5(dt(700),du(30),e("Lifetime: %.2f Mm",TotalDistanceTravelled/1000),"txtstart")dz[#dz+1]=c5(dt(830),du(20),"Trip Time: "..dd(ad),"txtstart")dz[#dz+1]=c5(dt(830),du(30),"Total Time: "..dd(TotalFlightTime),"txtstart")dz[#dz+1]=c5(dt(970),du(20),e("Mass: %.2f Tons",aO/1000),"txtstart")dz[#dz+1]=c5(dt(1240),du(10),e("Max Brake: %.2f kN",g4/1000),"txtend")dz[#dz+1]=c5(dt(1240),du(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if g3>0.1 then dz[#dz+1]=c5(dt(970),du(30),e("Max Mass: %.2f Tons",g7/1000),"txtstart")dz[#dz+1]=c5(dt(1240),du(20),e("Req Thrust: %.2f kN",g8/1000),"txtend")else dz[#dz+1]=c5(dt(970),du(30),"Max Mass: n/a","txtstart")dz[#dz+1]=c5(dt(1240),du(20),"Req Thrust: n/a","txtend")end end;dz[#dz+1]="</g>"return dz end;function fR.DrawWarnings(dz)return fd(dz)end;function fR.DisplayOrbitScreen(dz)return fu(dz)end;function fR.DisplayMessage(dz,fm)if fm~="empty"then local c7=310;for g9 in string.gmatch(fm,"([^\n]+)")do c7=c7+35;dz[#dz+1]=c5("50%",c7,g9,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function fR.DrawDeadZone(dz)dz[#dz+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function fR.UpdateRadar()if radar_1 then local ga=radar_1.getEntries()local gb=radar_1.getData()local gc=dt(1770)local gd=du(330)if#ga>0 then local ge=gb:find('identifiedConstructs":%[%]')if ge==nil and perisPanelID==nil then am=1;fL()end;if ge~=nil and perisPanelID~=nil then fL()end;if radarPanelID==nil then fL()end;ak=c5(gc,gd,"Radar: "..#ga.." contacts","pbright txtbig txtmid")local gf={}for cg,ch in pairs(ga)do if radar_1.hasMatchingTransponder(ch)==1 then table.insert(gf,ch)end end;if#gf>0 then local c7=du(15)local c6=dt(1370)ak=ak..c5(c6,c7,"Friendlies In Range","pbright txtbig txtmid")for cg,ch in pairs(gf)do c7=c7+20;ak=ak..c5(c6,c7,radar_1.getConstructName(ch),"pdim txtmid")end end else local gg;gg=gb:find('worksInEnvironment":false')if gg then ak=c5(gc,gd,"Radar: Jammed","pbright txtbig txtmid")else ak=c5(gc,gd,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then am=0;fL()end end end end;function fR.DrawSettings(dz)if#bU>0 then local c6=dt(640)local c7=du(200)dz[#dz+1]=[[<g class="pbright txtvspd txtstart">]]for cg,ch in pairs(bU)do dz[#dz+1]=c5(c6,c7,ch..": ".._G[ch])c7=c7+20;if cg%12==0 then c6=c6+dt(350)c7=du(200)end end;dz[#dz+1]=c5(dt(640),du(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")dz[#dz+1]="</g>"end;return dz end;return fR end;local function gh()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function gi()local function gj(gk)return type(gk)=='number'end;local function gl(gk)return type(tonumber(gk))=='number'end;local function gm(gn)return type(gn)=='table'end;local function go(gp)return type(gp)=='string'end;local function gq(ch)return gm(ch)and gj(ch.x and ch.y and ch.z)end;local function gr(gs)return gm(gs)and gj(gs.latitude and gs.longitude and gs.altitude and gs.bodyId and gs.systemId)end;local gt=math.pi/180;local gu=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gv='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local gw=r;local function cl(cm,cn)if cm==0 then return c(cn)<1e-09 end;if cn==0 then return c(cm)<1e-09 end;return c(cm-cn)<math.max(c(cm),c(cn))*epsilon end;local function gx(gk)local cr=string.gsub(string.reverse(e('%.4f',gk)),'^0*%.?','')return cr==''and'0'or string.reverse(cr)end;local function gy(gz)if gq(gz)then return e('{x=%.3f,y=%.3f,z=%.3f}',gz.x,gz.y,gz.z)end;if gm(gz)and not getmetatable(gz)then local gA={}local gB=next(gz)if type(gB)=='nil'or gB==1 then gA=gz else for cg,ch in pairs(gz)do local cc=gy(ch)if type(cg)=='number'then table.insert(gA,e('[%s]=%s',cg,cc))else table.insert(gA,e('%s=%s',cg,cc))end end end;return e('{%s}',table.concat(gA,','))end;if go(gz)then return e("'%s'",gz:gsub("'",[[\']]))end;return tostring(gz)end;local gC={}gC.__index=gC;gC.__tostring=function(gz,gD)local gE={}for cg in pairs(gz)do table.insert(gE,cg)end;table.sort(gE)local gA={}for _,cg in ipairs(gE)do local cc=gy(gz[cg])if type(cg)=='number'then table.insert(gA,e('[%s]=%s',cg,cc))else table.insert(gA,e('%s=%s',cg,cc))end end;if gD then return e('%s%s',gD,table.concat(gA,',\n'..gD))end;return e('{%s}',table.concat(gA,','))end;gC.__eq=function(gF,gG)return gF.planetarySystemId==gG.planetarySystemId and gF.bodyId==gG.bodyId and cl(gF.radius,gG.radius)and cl(gF.center.x,gG.center.x)and cl(gF.center.y,gG.center.y)and cl(gF.center.z,gG.center.z)and cl(gF.GM,gG.GM)end;local function gH(gI,gJ,gK,cI,gL)assert(gl(gI),'Argument 1 (planetarySystemId) must be a number:'..type(gI))assert(gl(gJ),'Argument 2 (bodyId) must be a number:'..type(gJ))assert(gl(gK),'Argument 3 (radius) must be a number:'..type(gK))assert(gm(cI),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cI))assert(gl(gL),'Argument 5 (GM) must be a number:'..type(gL))return setmetatable({planetarySystemId=tonumber(gI),bodyId=tonumber(gJ),radius=tonumber(gK),center=vec3(cI),GM=tonumber(gL)},gC)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(gM)return e('::pos{%d,%d,%s,%s,%s}',gM.systemId,gM.bodyId,gx(gM.latitude*gu),gx(gM.longitude*gu),gx(gM.altitude))end;MapPosition.__eq=function(gF,gG)return gF.bodyId==gG.bodyId and gF.systemId==gG.systemId and cl(gF.latitude,gG.latitude)and cl(gF.altitude,gG.altitude)and(cl(gF.longitude,gG.longitude)or cl(gF.latitude,math.pi/2)or cl(gF.latitude,-math.pi/2))end;local function gN(gO,gJ,cM,cN,cL)local gI=gO;if go(gO)and not cN and not cL and not gJ and not cM then gI,gJ,cM,cN,cL=o(gO,gv)assert(gI,'Argument 1 (position string) is malformed.')else assert(gl(gI),'Argument 1 (systemId) must be a number:'..type(gI))assert(gl(gJ),'Argument 2 (bodyId) must be a number:'..type(gJ))assert(gl(cM),'Argument 3 (latitude) must be in degrees:'..type(cM))assert(gl(cN),'Argument 4 (longitude) must be in degrees:'..type(cN))assert(gl(cL),'Argument 5 (altitude) must be in meters:'..type(cL))end;gI=tonumber(gI)gJ=tonumber(gJ)cM=tonumber(cM)cN=tonumber(cN)cL=tonumber(cL)if gJ==0 then return setmetatable({latitude=cM,longitude=cN,altitude=cL,bodyId=gJ,systemId=gI},MapPosition)end;return setmetatable({latitude=gt*gw(cM,-90,90),longitude=gt*(cN%360),altitude=cL,bodyId=gJ,systemId=gI},MapPosition)end;local gP={}gP.__index=gP;gP.__tostring=function(gz,gD)local gQ=gD and gD..'  'local gR={}local gE={}for cg in pairs(gz)do table.insert(gE,cg)end;table.sort(gE)for _,gS in ipairs(gE)do bdy=gz[gS]local gT=gC.__tostring(bdy,gQ)if gD then table.insert(gR,e('[%s]={\n%s\n%s}',gS,gT,gD))else table.insert(gR,e('  [%s]=%s',gS,gT))end end;if gD then return e('\n%s%s%s',gD,table.concat(gR,',\n'..gD),gD)end;return e('{\n%s\n}',table.concat(gR,',\n'))end;local function gU(gV)local b4={}local pid;for _,ch in pairs(gV)do local gW=ch.planetarySystemId;if type(gW)~='number'then error('Invalid planetary system ID: '..tostring(gW))elseif pid and gW~=pid then error('Mistringmatch planetary system IDs: '..gW..' and '..pid)end;local gX=ch.bodyId;if type(gX)~='number'then error('Invalid body ID: '..tostring(gX))elseif b4[gX]then error('Duplicate body ID: '..tostring(gX))end;setmetatable(ch.center,getmetatable(vec3.unit_x))b4[gX]=setmetatable(ch,gC)pid=gW end;return setmetatable(b4,gP)end;b9={}local function gY(gV)return setmetatable({galaxyAtlas=gV or{}},b9)end;b9.__index=function(gn,i)if type(i)=='number'then local system=gn.galaxyAtlas[i]return gU(system)end;return rawget(b9,i)end;b9.__pairs=function(gz)return function(gn,cg)local gZ,nv=next(gn,cg)return gZ,nv and gU(nv)end,gz.galaxyAtlas,nil end;b9.__tostring=function(gz)local g_={}for _,h0 in pairs(gz or{})do local h1=h0:getPlanetarySystemId()local h2=gP.__tostring(h0,'    ')table.insert(g_,e('  [%s]={%s\n  }',h1,h2))end;return e('{\n%s\n}\n',table.concat(g_,',\n'))end;b9.BodyParameters=gH;b9.MapPosition=gN;b9.PlanetarySystem=gU;function b9.createBodyParameters(h3,gJ,h4,h5,h6,h7,h8)assert(gl(h3),'Argument 1 (planetarySystemId) must be a number:'..type(h3))assert(gl(gJ),'Argument 2 (bodyId) must be a number:'..type(gJ))assert(gl(h4),'Argument 3 (surfaceArea) must be a number:'..type(h4))assert(gm(h5),'Argument 4 (aPosition) must be an array or vec3:'..type(h5))assert(gm(h6),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(h6))assert(gl(h7),'Argument 6 (altitude) must be in meters:'..type(h7))assert(gl(h8),'Argument 7 (gravityAtPosition) must be number:'..type(h8))local gK=math.sqrt(h4/4/math.pi)local aj=gK+h7;local h9=vec3(h5)+aj*vec3(h6)local gL=h8*aj*aj;return gH(h3,gJ,gK,h9,gL)end;b9.isMapPosition=gr;function b9:getPlanetarySystem(gO)if i==nil then i=0 end;if nv==nil then nv=0 end;local h3=gO;if gr(gO)then h3=gO.systemId end;if type(h3)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=gP then system=gU(system)end;return system end end end;function gP:castIntersections(ha,d3,hb,hc)local hb=hb or function(fq)return 1.05*fq.radius end;local hd={}if hc then for _,i in ipairs(hc)do hd[i]=self[i]end else hc={}for cg,fq in pairs(self)do table.insert(hc,cg)hd[cg]=fq end end;local function he(hf,hg)local hh=hd[hf].center-ha;local hi=hd[hg].center-ha;return hh:len()<hi:len()end;table.sort(hc,he)local hj=d3:normalize()for i,gW in ipairs(hc)do local fq=hd[gW]local hk=fq.center-ha;local gK=hb(fq)local hl=hk:dot(hj)local hm=hl^2-(hk:len2()-gK^2)if hm>=0 then local hn=math.sqrt(hm)local fo=hl+hn;local fp=hl-hn;if fp>0 then return fq,fo,fp elseif fo>0 then return fq,fo,nil end end end;return nil,nil,nil end;function gP:closestBody(cF)assert(type(cF)=='table','Invalid coordinates.')local ho,fq;local hp=vec3(cF)for _,hq in pairs(self)do local hr=(hq.center-hp):len2()if(not fq or hr<ho)and hq.name~="Space"then fq=hq;ho=hr end end;return fq end;function gP:convertToBodyIdAndWorldCoordinates(gO)local hs=gO;if go(gO)then hs=gN(gO)end;if hs.bodyId==0 then return 0,vec3(hs.latitude,hs.longitude,hs.altitude)end;local hq=self:getBodyParameters(hs)if hq then return hs.bodyId,hq:convertToWorldCoordinates(hs)end end;function gP:getBodyParameters(gO)local gJ=gO;if gr(gO)then gJ=gO.bodyId end;assert(gl(gJ),'Argument 1 (bodyId) must be a number:'..type(gJ))return self[gJ]end;function gP:getPlanetarySystemId()local _,ch=next(self)return ch and ch.planetarySystemId end;function gC:convertToMapPosition(cI)assert(gm(cI),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cI))local cJ=vec3(cI)if self.bodyId==0 then return setmetatable({latitude=cJ.x,longitude=cJ.y,altitude=cJ.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local cK=cJ-self.center;local aj=cK:len()local cL=aj-self.radius;local cM=0;local cN=0;if not cl(aj,0)then local cO=n(cK.y,cK.x)cN=cO>=0 and cO or 2*math.pi+cO;cM=math.pi/2-math.acos(cK.z/aj)end;return setmetatable({latitude=cM,longitude=cN,altitude=cL,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function gC:convertToWorldCoordinates(gO)local hs=go(gO)and gN(gO)or gO;if hs.bodyId==0 then return vec3(hs.latitude,hs.longitude,hs.altitude)end;assert(gr(hs),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(hs.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(hs.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local ht=math.cos(hs.latitude)return self.center+(self.radius+hs.altitude)*vec3(ht*math.cos(hs.longitude),ht*math.sin(hs.longitude),math.sin(hs.latitude))end;function gC:getAltitude(cI)return(vec3(cI)-self.center):len()-self.radius end;function gC:getDistance(cI)return(vec3(cI)-self.center):len()end;function gC:getGravity(cI)local hu=self.center-vec3(cI)local hv=hu:len2()return self.GM/hv*hu/math.sqrt(hv)end;return setmetatable(b9,{__call=function(_,...)return gY(...)end})end;function script.onStart()local function hw()local function hx(hy)local hz=dbHud_1.hasKey;for cg,ch in pairs(hy)do if hz(ch)then local cr=f(dbHud_1.getStringValue(ch))if cr~=nil then _G[ch]=cr;aM=true end end end end;if dbHud_1 then local hz=dbHud_1.hasKey;if not useTheseSettings then hx(bZ())else a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5 end;coroutine.yield()hx(b)if aM then a1="Loaded Saved Variables\n(see Lua Chat Tab for list)"M=y(ResolutionX/2,0)N=y(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bh=autoRollPreference;bo=AtmoSpeedLimit;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]else a1="No Saved Variables Found - Stand up / leave remote to save settings"end else a1="No databank found, install one anywhere and rerun the autoconfigure to save variables"end;if LastStartTime+180<bE then LastMaxBrakeInAtmo=0 end;LastStartTime=bE;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.  Change userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=5 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=av end;antigrav.setBaseAltitude(AntigravTargetAltitude)end end;local function hA()local function hB(hC,hD)if hC>hD then hD=hC end;if ContainerOptimization>0 then hD=hD-hD*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then hD=hD-hD*FuelTankOptimization*0.05 end;return hD end;local hE=core.getElementNameById;local hF=fuelX~=0 and fuelY~=0;for cg in pairs(aw)do local type=core.getElementTypeById(aw[cg])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(aw[cg])),'^.*vertical.*$')then bN=true end end;if o(type,'^.*Space Engine$')then bC=true;if o(tostring(core.getElementTagsById(aw[cg])),'^.*vertical.*$')then local hG=core.getElementRotationById(aw[cg])if hG[4]<0 then if p(-hG[4],0.1)==0.5 then bA=true end else if p(hG[4],0.1)==0.5 then bB=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local hH=h(aw[cg])if hH>10000 then b2=128 elseif hH>1000 then b2=64 elseif hH>150 then b2=32 end end;aT=aT+h(aw[cg])if hF and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local hH=h(aw[cg])local hI=k(aw[cg])local hC=0;local dW=q()if type=="Atmospheric Fuel Tank"then local hD=400;local hJ=35.03;if hH>10000 then hD=51200;hJ=5480 elseif hH>1300 then hD=6400;hJ=988.67 elseif hH>150 then hD=1600;hJ=182.67 end;hC=hI-hJ;if fuelTankHandlingAtmo>0 then hD=hD+hD*fuelTankHandlingAtmo*0.2 end;hD=hB(hC,hD)aQ[#aQ+1]={aw[cg],hE(aw[cg]),hD,hJ,hC,dW}end;if type=="Rocket Fuel Tank"then local hD=320;local hJ=173.42;if hH>65000 then hD=40000;hJ=25740 elseif hH>6000 then hD=5120;hJ=4720 elseif hH>700 then hD=640;hJ=886.72 end;hC=hI-hJ;if fuelTankHandlingRocket>0 then hD=hD+hD*fuelTankHandlingRocket*0.1 end;hD=hB(hC,hD)aS[#aS+1]={aw[cg],hE(aw[cg]),hD,hJ,hC,dW}end;if type=="Space Fuel Tank"then local hD=2400;local hJ=182.67;if hH>10000 then hD=76800;hJ=5480 elseif hH>1300 then hD=9600;hJ=988.67 end;hC=hI-hJ;if fuelTankHandlingSpace>0 then hD=hD+hD*fuelTankHandlingSpace*0.2 end;hD=hB(hC,hD)aR[#aR+1]={aw[cg],hE(aw[cg]),hD,hJ,hC,dW}end end end;if not bN then VertTakeOff,VertTakeOffEngine=false,false end end;local function hK()aq=dp()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(at or not at and av<10000)then for _,ch in pairs(door)do ch.toggle()end end;if switch then for _,ch in pairs(switch)do ch.toggle()end end;if forcefield and(at or not at==0 and av<10000)then for _,ch in pairs(forcefield)do ch.toggle()end end;if antigrav then bO=antigrav.getState()==1;if bO and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;local hL=di()if hL~=-1 or not at and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not R then GearExtended=true end else BrakeIsOn=false end;if bi~=nil then s:setTargetGroundAltitude(bi)if bi==0 and not R then GearExtended=true;BrakeIsOn=true end else bi=a:getTargetGroundAltitude()if GearExtended then s:setTargetGroundAltitude(LandingGearGroundHeight)else s:setTargetGroundAltitude(TargetHoverHeight)end end;if at and hL~=-1 then bc=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=at end;local function hM(hN,hO,hP,hQ,c6,c7,hR,hS,hT,hU)local hV={enableName=hN,disableName=hO,width=hP,height=hQ,x=c6,y=c7,toggleVar=hR,toggleFunction=hS,drawCondition=hT,hovered=false}if hU then table.insert(aJ,hV)else table.insert(aI,hV)end;return hV end;local function hW(hX)if not bT then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif hX=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif hX=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif hX=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bU=bZ(hX)showHud=false else bU={}showHud=true end end;local function hY()bT=not bT;if bT then aH=aJ;a1="Hold SHIFT to see Settings"bV=showHud else aH=aI;a1="Hold SHIFT to see Control Buttons"hW()showHud=bV end end;local function hZ()local h_=50;local i0=340;local c6=500;local c7=aL/2-400;local i1=0;for cg,ch in pairs(bZ("boolean"))do if type(_G[ch])=="boolean"then if ch~="showHud"then hM(ch,ch,i0,h_,c6,c7,function()return _G[ch]end,function()_G[ch]=not _G[ch]if _G[ch]then a1=ch.." set to true"else a1=ch.." set to false"end end,function()return true end,true)else hM(ch,ch,i0,h_,c6,c7,function()return _G[ch]end,function()_G[ch]=not _G[ch]if _G[ch]then a1=ch.." set to true"else a1=ch.." set to false"end;bV=_G[ch]end,function()return true end,true)end;c7=c7+h_+20;if i1==7 then c6=c6+i0+20;c7=aL/2-400;i1=0 else i1=i1+1 end end end;hM("Control View","Control View",i0,h_,10,aL/2-500,function()return true end,hY,function()return true end,true)hM("View Handling Settings",'Hide Handling Settings',i0,h_,10,aL/2-(500-h_),function()return showHandlingVariables end,function()hW("handling")end,function()return true end,true)hM("View Hud Settings",'Hide Hud Settings',i0,h_,10,aL/2-(500-h_*2),function()return showHudVariables end,function()hW("hud")end,function()return true end,true)hM("View Physics Settings",'Hide Physics Settings',i0,h_,10,aL/2-(500-h_*3),function()return showPhysicsVariables end,function()hW("physics")end,function()return true end,true)end;local function i2()local function i3()if dbHud_1 then local position=bM;local dP=planet.name..". "..#SavedLocations;if radar_1 then local gW,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if gW~=nil and gW~=""then dP=dP.." "..radar_1.getConstructName(gW)end end;local cW={}cW={position=position,name=dP,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cW;table.insert(b4[0],cW)cf()a1="Location saved as "..dP else a1="Databank must be installed to save locations"end end;local function i4()TurnBurn=not TurnBurn end;local function i5(i6)if i6==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function i7()i5(1)end;local function i8()local cV=-1;cV=ct(b4[0])if cV>-1 then table.remove(b4[0],cV)end;cV=-1;cV=ct(SavedLocations)if cV~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cV)end;cC()cf()end;local function i9()local dP=AutopilotTargetName;if dP==nil then local fm,cs=co((bM-CustomTarget.position):len())dP=CustomTarget.name.." "..fm..cs end;if dP==nil then dP="None"end;return"Engage Autopilot: "..dP end;local function ia()local dP=AutopilotTargetName;if dP==nil then dP=CustomTarget.name end;if dP==nil then dP="None"end;return"Disable Autopilot: "..dP end;local h_=50;local i0=260;local ib=hM("Enable Brake Toggle","Disable Brake Toggle",i0,h_,aK/2-i0/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)hM("Align Prograde","Disable Prograde",i0,h_,aK/2-i0/2-50-ib.width,aL/2-h_+380,function()return ProgradeIsOn end,i7)hM("Align Retrograde","Disable Retrograde",i0,h_,aK/2-i0/2+ib.width+50,aL/2-h_+380,function()return RetrogradeIsOn end,i5,function()return au==0 end)local ic=hM(i9,ia,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,cQ)hM("Save Position","Save Position",200,ic.height,ic.x+ic.width+30,ic.y,function()return false end,i3,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)hM("Update Position","Update Position",200,ic.height,ic.x+ic.width+30,ic.y,function()return false end,cT,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)hM("Clear Position","Clear Position",200,ic.height,ic.x-200-30,ic.y,function()return true end,i8,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)h_=60;i0=300;local c6=10;local c7=aL/2-500;hM("Show Help","Hide Help",i0,h_,c6,c7,function()return showHelp end,function()showHelp=not showHelp end)c7=c7+h_+20;hM("View Settings","View Settings",i0,h_,c6,c7,function()return true end,hY)local c7=aL/2-300;hM("Enable Turn and Burn","Disable Turn and Burn",i0,h_,c6,c7,function()return TurnBurn end,i4)hM("Horizontal Takeoff Mode","Vertical Takeoff Mode",i0,h_,c6+i0+20,c7,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bN end)c7=c7+h_+20;hM("Show Orbit Display","Hide Orbit Display",i0,h_,c6,c7,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)hM("Engage Orbiting","Cancel Orbiting",i0,h_,c6+i0+20,c7,function()return IntoOrbit end,cw,function()return au==0 and unit.getClosestPlanetInfluence()>0 end)c7=c7+h_+20;hM("Glide Re-Entry","Cancel Glide Re-Entry",i0,h_,c6,c7,function()return Reentry end,function()an=true;i7()end,function()return planet.hasAtmosphere and not at end)hM("Parachute Re-Entry","Cancel Parachute Re-Entry",i0,h_,c6+i0+20,c7,function()return Reentry end,da,function()return planet.hasAtmosphere and not at end)c7=c7+h_+20;hM("Engage Follow Mode","Disable Follow Mode",i0,h_,c6,c7,function()return Z end,cy,function()return m()==1 end)hM("Enable Repair Arrows","Disable Repair Arrows",i0,h_,c6+i0+20,c7,function()return aU end,function()aU=not aU;if aU then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return m()==1 end)c7=c7+h_+20;if not ExternalAGG then hM("Enable AGG","Disable AGG",i0,h_,c6,c7,function()return bO end,dc,function()return antigrav~=nil end)end;c7=c7+h_+20;hM(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,i0*2,h_,c6,c7,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;local function id()local ie=nil;local ig=nil;local ih=nil;local ii=nil;b4=gh()for cg,ch in pairs(b4[0])do if ie==nil or ch.center.x<ie then ie=ch.center.x end;if ig==nil or ch.center.x>ig then ig=ch.center.x end;if ih==nil or ch.center.y<ih then ih=ch.center.y end;if ii==nil or ch.center.y>ii then ii=ch.center.y end end;b5=""local ij=1.1*(ig-ie)/1920;local ik=1.4*(ii-ih)/1080;for cg,ch in pairs(b4[0])do local c6=960+ch.center.x/ij;local c7=540+ch.center.y/ik;b5=b5 ..'<circle cx="'..c6 ..'" cy="'..c7 ..'" r="'..ch.radius/ij*30 ..'" stroke="white" stroke-width="3" fill="blue" />'if not o(ch.name,"Moon")and not o(ch.name,"Sanctuary")and not o(ch.name,"Space")then b5=b5 .."<text x='"..c6 .."' y='"..c7+ch.radius/ij*30+20 .."' font-size='28' fill="..aA.." text-anchor='middle' font-family='Montserrat'>"..ch.name.."</text>"end end;local f_=bM;local c6=960+f_.x/ij;local c7=540+f_.y/ik;b5=b5 ..'<circle cx="'..c6 ..'" cy="'..c7 ..'" r="5" stroke="white" stroke-width="3" fill="red"/>'b5=b5 .."<text x='"..c6 .."' y='"..c7-50 .."' font-size='36' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"b5=b5 ..[[</svg>]]b6=ij;b7=ik;if screen_2 then screen_2.setHTML('<svg width="100%" height="100%" viewBox="0 0 1920 1080">'..b5)local f_=bM;local c6=960+f_.x/ij;local c7=540+f_.y/ik;b5='<svg><circle cx="80" cy="80" r="5" stroke="white" stroke-width="3" fill="red"/>'b5=b5 .."<text x='80' y='105' font-size='18' fill="..aA.." text-anchor='middle' font-family='Montserrat''>You Are Here</text></svg>"b8=screen_2.addContent((c6-80)/19.20,(c7-80)/10.80,b5)end end;local function il()for cg,ch in pairs(SavedLocations)do table.insert(b4[0],ch)end;cf()end;local function im()local bb={}local io=30000000/3600;local ip=io*io;local iq=100;local function ir(ch)return 1/math.sqrt(1-ch*ch/ip)end;function bb.computeAccelerationTime(is,it,iu)local iv=io*math.asin(is/io)return(io*math.asin(iu/io)-iv)/it end;function bb.computeDistanceAndTime(is,iu,iw,ix,iy,iz)iy=iy or 0;iz=iz or 0;local iA=is<=iu;local iB=ix*(iA and 1 or-1)/iw;local iC=-iz/iw;local iD=iB+iC;if iA and iD<=0 or not iA and iD>=0 then return-1,-1 end;local iE,iF=0,0;if iB~=0 and iy>0 then local iv=math.asin(is/io)local iG=math.pi*(iB/2+iC)local iH=iB*iy;local iI=io*math.pi;local ch=function(gn)local iJ=(iG*gn-iH*math.sin(math.pi*gn/2/iy)+iI*iv)/iI;local iK=math.tan(iJ)return io*iK/math.sqrt(iK*iK+1)end;local iL=iA and function(gp)return gp>=iu end or function(gp)return gp<=iu end;iF=2*iy;if iL(ch(iF))then local iM=0;while c(iF-iM)>0.5 do local gn=(iF+iM)/2;if iL(ch(gn))then iF=gn else iM=gn end end end;local iN=is;local iO=iF/iq;for iP=1,iq do local em=ch(iP*iO)iE=iE+(em+iN)*iO/2;iN=em end;if iF<2*iy then return iE,iF end;is=iN end;local iv=io*math.asin(is/io)local bE=(io*math.asin(iu/io)-iv)/iD;local iQ=ip*math.cos(iv/io)/iD;local aj=iQ-ip*math.cos((iD*bE+iv)/io)/iD;return aj+iE,bE+iF end;function bb.computeTravelTime(is,it,aj)if aj==0 then return 0 end;if it>0 then local iv=io*math.asin(is/io)local iQ=ip*math.cos(iv/io)/it;return(io*math.acos(it*(iQ-aj)/ip)-iv)/it end;if is==0 then return-1 end;assert(is>0,'Acceleration and initial speed are both zero.')return aj/is end;function bb.lorentz(ch)return ir(ch)end;return bb end;local function iR()local vec3=require('cpml.vec3')local gi=gi()local function go(gp)return type(gp)=='string'end;local function gm(gn)return type(gn)=='table'end;local function cl(cm,cn)if cm==0 then return c(cn)<1e-09 end;if cn==0 then return c(cm)<1e-09 end;return c(cm-cn)<math.max(c(cm),c(cn))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cL)assert(self.body)local aj=cL+self.body.radius;if not cl(aj,0)then local orbit=math.sqrt(self.body.GM/aj)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(gO,eN)assert(self.body)assert(gm(gO)or go(gO))assert(gm(eN))local f_=(go(gO)or gi.isMapPosition(gO))and self.body:convertToWorldCoordinates(gO)or vec3(gO)local ch=vec3(eN)local iS=f_-self.body.center;local hi=ch:len2()local iT=iS:len()local iU=self.body.GM;local iV=((hi-iU/iT)*iS-iS:dot(ch)*ch)/iU;local cm=iU/(2*iU/iT-hi)local iW=iV:len()local hj=iV:normalize()local iX=cm*(1-iW)local iY=cm*(1+iW)local iZ=iX*hj+self.body.center;local i_=iW<=1 and-iY*hj+self.body.center or nil;local j0=math.sqrt(cm*iU*(1-iW*iW))local j1=i_ and 2*math.pi*math.sqrt(cm^3/iU)local j2=math.acos(iV:dot(iS)/(iW*iT))if iS:dot(ch)<0 then j2=-(j2-2*math.pi)end;local j3=math.acos((math.cos(j2)+iW)/(1+iW*math.cos(j2)))local j4=j3;if j4<0 then j4=j4+2*math.pi end;local j5=j4-iW*math.sin(j4)local j6=0;local j7=0;local j8=0;if j1~=nil then j6=j5/(2*math.pi/j1)j7=j1-j6;j8=j7+j1/2;if j2-math.pi>0 then j7=j6;j8=j7+j1/2 end;if j8>j1 then j8=j8-j1 end end;return{periapsis={position=iZ,speed=j0/iX,circularOrbitSpeed=math.sqrt(iU/iX),altitude=iX-self.body.radius},apoapsis=i_ and{position=i_,speed=j0/iY,circularOrbitSpeed=math.sqrt(iU/iY),altitude=iY-self.body.radius},currentVelocity=ch,currentPosition=f_,eccentricity=iW,period=j1,eccentricAnomaly=j3,meanAnomaly=j5,timeToPeriapsis=j7,timeToApoapsis=j8}end;local function j9(ja)local hq=gi.BodyParameters(ja.planetarySystemId,ja.bodyId,ja.radius,ja.center,ja.GM)return setmetatable({body=hq},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return j9(...)end})end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})hw()coroutine.yield()hA()coroutine.yield()hK()hZ()i2()aH=aI;coroutine.yield()id()b9=gi()ba=b9(gh())bb=im()bd=iR()be=ds()il()cf()cz()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(au>0 or au==0 and av<10000)then for _,ch in pairs(door)do ch.toggle()end end;if switch then for _,ch in pairs(switch)do ch.toggle()end end;if forcefield and(au>0 or au==0 and av<10000)then for _,ch in pairs(forcefield)do ch.toggle()end end;dk()if button then button.activate()end;if SetWaypointOnExit then cE(planet,bM)end end;function script.onTick(jb)local function jc(em)if not at then return bb.computeDistanceAndTime(em,AutopilotEndSpeed,l(),0,0,LastMaxBrake-AutopilotPlanetGravity*l())else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return bb.computeDistanceAndTime(em,AutopilotEndSpeed,l(),0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*l())else return 0,0 end end end;local function jd(em)return bb.computeDistanceAndTime(em,AutopilotEndSpeed,l(),a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*l())end;if jb=="tenthSecond"then local function je()local jf=system.createData;local jg=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=jg(panelInterplanetary,"value")interplanetaryHeaderText=jf('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=jg(panelInterplanetary,"value")widgetDistanceText=jf('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=jg(panelInterplanetary,"value")widgetTravelTimeText=jf('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=jg(panelInterplanetary,"value")widgetMaxMassText=jf('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=jg(panelInterplanetary,"value")widgetTargetOrbitText=jf('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=jg(panelInterplanetary,"value")widgetCurBrakeDistanceText=jf('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=jg(panelInterplanetary,"value")widgetCurBrakeTimeText=jf('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=jg(panelInterplanetary,"value")widgetMaxBrakeDistanceText=jf('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=jg(panelInterplanetary,"value")widgetMaxBrakeTimeText=jf('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=jg(panelInterplanetary,"value")widgetTrajectoryAltitudeText=jf('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not at then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function jh()t(panelInterplanetary)panelInterplanetary=nil end;local function ji()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bM):len()else AutopilotDistance=(CustomTarget.position-bM):len()end end;local em=bJ;local jj=unit.getThrottle()/100;if AtmoSpeedAssist then jj=H end;local jk,jl=bb.computeDistanceAndTime(bJ,MaxGameVelocity,l(),a:maxForceForward()*jj,warmup,0)local a7,a8;if not TurnBurn then a7,a8=jc(MaxGameVelocity)else a7,a8=jd(MaxGameVelocity)end;local _,jm;if not TurnBurn and em>0 then _,jm=jc(em)else _,jm=jd(em)end;local jn=0;local jo=0;if AutopilotCruising or not Autopilot and em>5 then jo=bb.computeTravelTime(em,0,AutopilotDistance)elseif a7+jk<AutopilotDistance then jn=AutopilotDistance-(a7+jk)jo=bb.computeTravelTime(8333.0556,0,jn)else local jp=(AutopilotDistance-a7)/jk;jk=AutopilotDistance-a7;jl=jl*jp end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return jo elseif AutopilotBraking then return jm elseif AutopilotCruising then return jo+jm else return jl+a8+jo end end;local function jq()local jr=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()return jr end;if au>0 and not WasInAtmo then if not bQ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cb(1)L=false end end;if bP~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bP then ce(bP,TRUE)else bP=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then je()end;if AutopilotTargetName~=nil then local js=CustomTarget~=nil;planetMaxMass=jq()u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=ji()if js and not Autopilot then aj=(bM-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bM):len()end;if not TurnBurn then a7,a8=jc(bJ)a9,aa=jc(MaxGameVelocity)else a7,a8=jd(bJ)a9,aa=jd(MaxGameVelocity)end;local fm,cs=co(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..fm..'", "unit":"'..cs..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..dd(travelTime)..'", "unit":""}')fm,cs=co(a7)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..fm..'", "unit":"'..cs..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..dd(a8)..'", "unit":""}')fm,cs=co(a9)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..fm..'", "unit":"'..cs..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..dd(aa)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')fm,cs=co(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",fm)..'", "unit":"'..cs..'"}')if au>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if au==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else jh()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif jb=="oneSecond"then local function jt(g3,ju)if g3==nil then g3=core.g()end;g3=y(g3,5)if ju~=nil and ju or(aP==nil or aP~=g3)then local eN=core.getVelocity()local em=vec3(eN):len()local jv=f(unit.getData()).maxBrake;if jv~=nil and jv>0 and at then jv=jv/r(em/100,0.1,1)jv=jv/au;if au>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+jv)/2 else LastMaxBrakeInAtmo=jv end end end;if jv~=nil and jv>0 then LastMaxBrake=jv end;aP=g3 end end;local function jw(dz)local jx=0;aF=""local jy=aT;local jz=0;local jA=0;local jB=0;local dY=0;local dZ=""local jC=core.getElementHitPointsById;for cg in pairs(aw)do local hH=0;local jD=0;jD=h(aw[cg])hH=jC(aw[cg])jz=jz+hH;if hH<jD then if hH==0 then jB=jB+1 else jA=jA+1 end;if aU and#aC==0 then position=vec3(core.getElementPositionById(aw[cg]))local c6=position.x-b2;local c7=position.y-b2;local jE=position.z-b2;table.insert(aC,core.spawnArrowSticker(c6,c7,jE+1,"down"))table.insert(aC,core.spawnArrowSticker(c6,c7,jE+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c6+1,c7,jE,"north"))table.insert(aC,core.spawnArrowSticker(c6+1,c7,jE,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c6-1,c7,jE,"south"))table.insert(aC,core.spawnArrowSticker(c6-1,c7,jE,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c6,c7-1,jE,"east"))table.insert(aC,core.spawnArrowSticker(c6,c7-1,jE,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c6,c7+1,jE,"west"))table.insert(aC,core.spawnArrowSticker(c6,c7+1,jE,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,aw[cg])end elseif aU and#aC>0 and aC[11]==aw[cg]then for dR in pairs(aC)do core.deleteSticker(aC[dR])end;aC={}end end;jx=d(jz/jy*100)if jx<100 then dz[#dz+1]=c5(0,0,"","pbright txt")dY=d(jx*2.55)dZ=e("rgb(%d,%d,%d)",255-dY,dY,0)if jx<100 then dz[#dz+1]=c5("50%",1035,"Elemental Integrity: "..jx.."%","txtbig txtmid","fill:"..dZ)if jB>0 then dz[#dz+1]=c5("50%",1055,"Disabled Modules: "..jB.." Damaged Modules: "..jA,"txtbig txtmid","fill:"..dZ)elseif jA>0 then dz[#dz+1]=c5("50%",1055,"Damaged Modules: "..jA,"txtbig txtmid","fill:"..dZ)end end end end;local function jF()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function jG()local dW=q()local fa=bJ;local jH=dW-ax;if fa>1.38889 then fa=fa/1000;local jI=fa*(dW-ax)TotalDistanceTravelled=TotalDistanceTravelled+jI;ac=ac+jI end;ad=ad+jH;TotalFlightTime=TotalFlightTime+jH;ax=dW end;ar=false;jt(nil,true)jG()be.UpdateRadar()jF()local dz={}be.ExtraData(dz)if ShowOdometer then dz=be.DrawOdometer(dz,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then jw(dz)end;al=table.concat(dz,"")collectgarbage("collect")elseif jb=="fiveSecond"then as=dbHud_1.getStringValue("SPBAutopilotTargetName")if as~=nil and as~=""and as~="SatNavNotChanged"then local cr=f(dbHud_1.getStringValue("SavedLocations"))if cr~=nil then _G["SavedLocations"]=cr;local cV=-1;local cW;for cg,ch in pairs(SavedLocations)do if ch.name and ch.name=="SatNav Location"then cV=cg;break end end;if cV~=-1 then cW=SavedLocations[cV]cV=-1;for cg,ch in pairs(b4[0])do if ch.name and ch.name=="SatNav Location"then cV=cg;break end end;if cV>-1 then b4[0][cV]=cW end;cf()a1=cW.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==as then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)cz()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif jb=="msgTick"then local dz={}be.DisplayMessage(dz,"empty")a1="empty"unit.stopTimer("msgTick")ai=3 elseif jb=="animateTick"then bg=true;bf=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif jb=="hudTick"then local function jJ(dz)local jK=d(r(aj/(aK/4)*255,0,255))dz[#dz+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,d(C+0.5)+jK,d(E+0.5)-jK,d(D+0.5)-jK)end;local function jL()for _,ch in pairs(aH)do if ch.hovered then if not ch.drawCondition or ch.drawCondition()then ch.toggleFunction()end;ch.hovered=false end end end;local function jM()local function jN(jO,jP,c6,c7,hP,hQ)if jO>c6 and jO<c6+hP and jP>c7 and jP<c7+hQ then return true else return false end end;local c6=ag+aK/2;local c7=ah+aL/2;for _,ch in pairs(aH)do ch.hovered=jN(c6,c7,ch.x,ch.y,ch.width,ch.height)end end;local function jQ(dz)local function jR(dz,jS,hover,c6,c7,iJ,jT,jU,jV,jW,jX)if type(jW)=="function"then jW=jW()end;if type(jX)=="function"then jX=jX()end;dz[#dz+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c6,c7,iJ,jT)if jS then dz[#dz+1]=e("%s'",jU)else dz[#dz+1]=jV end;if hover then dz[#dz+1]=" style='stroke:white; stroke-width:2'"else dz[#dz+1]=" style='stroke:black; stroke-width:1'"end;dz[#dz+1]="></rect>"dz[#dz+1]=e("<text x='%f' y='%f' font-size='24' fill='",c6+iJ/2,c7+jT/2+5)if jS then dz[#dz+1]="black"else dz[#dz+1]="white"end;dz[#dz+1]="' text-anchor='middle' font-family='Montserrat'>"if jS then dz[#dz+1]=e("%s</text>",jW)else dz[#dz+1]=e("%s</text>",jX)end end;local jY="rgb(50,50,50)'"local jZ="rgb(210,200,200)"local j_=jR;for _,ch in pairs(aH)do local hO=ch.disableName;local hN=ch.enableName;if type(hO)=="function"then hO=hO()end;if type(hN)=="function"then hN=hN()end;if not ch.drawCondition or ch.drawCondition()then j_(dz,ch.toggleVar(),ch.hovered,ch.x,ch.y,ch.width,ch.height,jZ,jY,hO,hN)end end end;local dz={}be.HUDPrologue(dz)if showHud then be.UpdateHud(dz)else be.DisplayOrbitScreen(dz)be.DrawWarnings(dz)end;if bT and bU~={}then be.DrawSettings(dz)end;be.HUDEpilogue(dz)dz[#dz+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if a1~="empty"then be.DisplayMessage(dz,a1)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then be.DrawDeadZone(dz)end end;if m()==1 and screen_1 and screen_1.getMouseY()~=-1 then jM()jQ(dz)if screen_1.getMouseState()==1 then jL()end;dz[#dz+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)elseif x()==0 then if m()==1 and a0 then jM()jQ(dz)if not bf and not bg then local k0=table.concat(dz,"")dz={}dz[#dz+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)dz[#dz+1]=b5;dz[#dz+1]=k0;dz[#dz+1]="</body>"bf=true;dz[#dz+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(dz,"")system.setScreen(content)elseif bg then local k0=table.concat(dz,"")dz={}dz[#dz+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)dz[#dz+1]=b5;dz[#dz+1]=k0;dz[#dz+1]="</body>"end;if not bf then dz[#dz+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end else jL()end else if not a0 and m()==0 then jL()if aj>DeadZone then if DisplayDeadZone then jJ(dz)end end else jM()jQ(dz)end;dz[#dz+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],M,N,ag,ah)end;dz[#dz+1]=[[</svg></body>]]content=table.concat(dz,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif jb=="apTick"then local function k1(k2)local gK=500000;local k3,k4,k5=math.huge;local k6=false;local k7=vec3({13771471,7435803,-128971})local k8=18000000;k3=vec3(k2):dist(k7)if k3<k8 then return true,c(k3-k8),"Safe Zone",0 end;k4=vec3(k2):dist(vec3(planet.center))if k4<gK then k6=true end;if c(k4-gK)<c(k3-k8)then return k6,c(k4-gK),planet.name,planet.bodyId else return k6,c(k3-k8),"Safe Zone",0 end end;local function k9(ka,kb,kc)kb=kb:project_on_plane(ka)kc=kc:project_on_plane(ka)return n(kb:cross(kc):dot(ka),kb:dot(kc))end;at=j()>0;au=j()av=core.getAltitude()aq=dp()bE=q()bk=bE;if antigrav then bO=antigrav.getState()==1 end;local kd=1;local ke=1;local kf=bE-bk;local kg=-math.deg(k9(bF,bI,bG))local kh=math.deg(k9(bH,bI,bG))local cD=bK*-1;bj=at and kg<-YawStallAngle or kg>YawStallAngle or kh<-PitchStallAngle or kh>PitchStallAngle;local ki=system.getMouseDeltaX()local kj=system.getMouseDeltaY()if InvertMouse and not a0 then kj=-kj end;U=0;Y=0;T=0;sys=ba[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=bd(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bI)if av==0 then av=(bM-planet.center):len()-planet.radius end;local g3=planet:getGravity(core.getConstructWorldPos()):len()*l()bl=0;bc=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if not at then F,G,_,_=k1(bM)else F=true end;ag=ag+ki;ah=ah+kj;if m()==1 and screen_1 and screen_1.getMouseY()~=-1 then ag=screen_1.getMouseX()*aK;ah=screen_1.getMouseY()*aL elseif x()==0 then if not m()==1 and not a0 then ag=0;ah=0 end else aj=math.sqrt(ag*ag+ah*ah)if not a0 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then U=U-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then U=U-(ag+DeadZone)*MouseXSensitivity else U=0 end;if ah>0 and ah>DeadZone then T=T-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then T=T-(ah+DeadZone)*MouseYSensitivity else T=0 end else ag=0;ah=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(kj,-100,100)+0.5)*2*kd;U=(-utils.smoothstep(ki,-100,100)+0.5)*2*ke end end end end;local kk=bJ>8334;if bJ>SpaceSpeedLimit/3.6 and not at and not Autopilot and not kk then a1="Space Speed Engine Shutoff reached"cb(0)end;if not kk and LastIsWarping then if not BrakeIsOn then cY()end;if Autopilot then cQ()end end;LastIsWarping=kk;if at and au>0.09 then if bJ>bo/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bJ<bo/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if an then BrakeIsOn=false;local kl=false;if CustomTarget~=nil then kl=cZ(CustomTarget.position-bM,0.01)else kl=cZ(vec3(bI),0.01)end;bh=true;if kl and(c(bS)<2 or c(bR)>85)and bJ>=bo/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;da()elseif at and AtmoSpeedAssist then cb(1)else ce(d(bo))end elseif bJ>P then cZ(vec3(bI),0.01)end end;if RetrogradeIsOn then if at then RetrogradeIsOn=false elseif bJ>P then cZ(-vec3(bI))end end;if not ProgradeIsOn and an and not IntoOrbit then if au==0 then Q=true;da()an=false;ap=true else an=false;cQ()end end;if ap and CustomTarget~=nil and(av<HoldAltitude+200 and av>HoldAltitude-200)and bJ*3.6>bo-100 and c(bL)<20 and au>=0.1 and(CustomTarget.position-bM):len()>2000+av then cQ()ap=false end;if VertTakeOff then bh=true;local km=HoldAltitude;if bL<-30 then a1="Unable to achieve lift. Safety Landing."af=0;bh=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bO or HoldAltitude<planet.spaceEngineMinAltitude then if bO then km=antigrav.getBaseAltitude()end;if av<km-100 then bp=0;af=15;BrakeIsOn=false elseif bL>0 then BrakeIsOn=true;af=0 elseif bL<-30 then BrakeIsOn=true;af=15 elseif av>=km then if bO then if Autopilot or VectorToTarget then cv()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"cv()end;af=0 end else if au>0.08 then bp=0;BrakeIsOn=false;af=20 elseif au<0.08 and au>0 then BrakeIsOn=false;if bB then bp=0;af=20 else af=0;bp=36;ce(3500)end else bh=autoRollPreference;IntoOrbit=true;bz=false;CancelIntoOrbit=false;bt=false;br=nil;bs=nil;if by==nil then by=planet end;bx=km;bw=true;VertTakeOff=false end end;if bp~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kn=r(bp-bR,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kn)local ko=r(vTpitchPID:get(),-1,1)T=ko end end;if IntoOrbit then local d7;local kp=false;local kq,kr=co(bx)local ks=kq..kr;if by==nil then by=planet;if VectorToTarget then by=ab end end;if not bw then bx=math.floor(by.radius+by.surfaceMaxAltitude+1000)if by.hasAtmosphere then bx=math.floor(by.radius+by.noAtmosphericDensityAltitude+1000)end;bw=true end;if bv.VectorToTarget then d7=CustomTarget.position-bM end;local kt,ku=bd(by):escapeAndOrbitalSpeed((bM-by.center):len()-by.radius)local kv=bS;if not bt then local kw=false;local kx=false;cb(0)bs=0;bq="Aligning to orbital path - OrbitHeight: "..ks;if bv.VectorToTarget then cZ(d7:normalize():project_on_plane(bK))kp=bG:dot(d7:project_on_plane(bF):normalize())>0.95 else cZ(bI)kp=kg<0.5;if bJ<150 then kp=true end end;T=0;br=0;if bR<=br+1 and bR>=br-1 then kw=true else kw=false end;if kv<=bs+1 and kv>=bs-1 then kx=true else kx=false end;if kw and kx and kp then br=nil;bs=nil;bt=true end else if bv.VectorToTarget then cZ(d7:normalize():project_on_plane(bK))elseif bJ>150 then cZ(bI)end;T=0;if bv.VectorToTarget then local a7,_=bb.computeDistanceAndTime(bJ,bo/3.6,l(),0,0,LastMaxBrake)if bz and d7:len()>15000+a7+av then bq="Orbiting to Target"if orbit.periapsis.altitude<by.noAtmosphericDensityAltitude then bz=false end elseif bz or d7:len()<15000+a7+av then a1="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;Q=true;ap=true;bv.VectorToTarget,bv.AutopilotAlign=false,false;cw()da()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and av>bx*0.9 and av<bx*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bx*0.99 and orbit.apoapsis.altitude>=bx*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bz then if bz then BrakeIsOn=false;cb(0)br=0;if not bv.VectorToTarget then a1="Orbit complete"cw()end else bD=bD+1;if bD>=2 then bz=true end end else bq="Adjusting Orbit - OrbitHeight: "..ks;bu=true;ce(ku*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local ky=bL;local kz=av-bx;local kA=c(kz)if bL<10 and c(bR)<10 and kA<100 then ky=bL*2 end;if ky<10 and c(bR)<10 and kA<100 then ky=ky*2 end;if ky<5 and c(bR)<5 and kA<100 then ky=ky*4 end;VSpdPID:inject(ky)br=r(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kz)br=r(br-r(OrbitAltPID:get(),-15,15),-90,90)end end else local kB=2.75;local kC=c(p(kt*kB))local kD=kC%50;if kD>0 then kC=kC-kD+50 end;BrakeIsOn=false;if av<bx*0.8 then bq="Escaping planet gravity - OrbitHeight: "..ks;br=utils.map(bL,200,0,-15,80)elseif av>=bx*0.8 and av<bx*1.15 then bq="Approaching orbital corridor - OrbitHeight: "..ks;kC=kC*0.75;br=utils.map(bL,100,-100,-15,65)elseif av>=bx*1.15 and av<bx*1.5 then bq="Approaching orbital corridor - OrbitHeight: "..ks;kC=kC*0.75;if bL<0 or bu then br=utils.map(av,bx*1.5,bx*1.01,-30,0)else br=utils.map(av,bx*0.99,bx*1.5,0,30)end elseif av>bx*1.5 then bq="Reentering orbital corridor - OrbitHeight: "..ks;br=-85;local kE=utils.map(bL,-150,-400,1,0.55)kC=kC*kE end;ce(d(kC))end end;if br~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kF=br-bR;OrbitPitchPID:inject(kF)local kG=r(OrbitPitchPID:get(),-0.5,0.5)T=kG end end;if Autopilot and au==0 and not an then local kH,kI=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kJ=(CustomTarget.position-ab.center):normalize()local kK=kJ:project_on_plane((ab.center-bM):normalize()):normalize()local kL=ab.center+kK*(ab.radius+AutopilotTargetOrbit)local kM=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bM-kL):len()<(bM-kM):len()then kH=kL;AutopilotTargetCoords=kH else kH=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))AutopilotTargetCoords=kH end;cE(ab,AutopilotTargetCoords)kI=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kI=true;TargetSet=true;AutopilotRealigned=true;kH=CustomTarget.position+(bM-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kJ=(bM+bI*100000-ab.center):normalize()local kK=kJ:project_on_plane((ab.center-bM):normalize()):normalize()if kK:len()<1 then kJ=(bM+bG*100000-ab.center):normalize()kK=kJ:project_on_plane((ab.center-bM):normalize()):normalize()end;kH=ab.center+kK*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kH;TargetSet=true;kI=true;AutopilotRealigned=true;cE(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kH)-bM):len()local fn,fo,fp=ba:getPlanetarySystem(0):castIntersections(bM,bI:normalize(),function(fq)if fq.noAtmosphericDensityAltitude>0 then return fq.radius+fq.noAtmosphericDensityAltitude else return fq.radius+fq.surfaceMaxAltitude*1.5 end end)local fr=fo;if fp~=nil and fo~=nil then fr=math.min(fp,fo)end;if fr~=nil and fr<AutopilotDistance and fn.name==ab.name then AutopilotDistance=fr end;local kl=true;local kN=(ab.center-(bM+vec3(bI):normalize()*AutopilotDistance)):len()-ab.radius;local fm,cs=co(kN)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..fm..'", "unit":"'..cs..'"}')local a7,a8;if not TurnBurn then a7,a8=jc(bJ)else a7,a8=jd(bJ)end;if bJ>300 and AutopilotAccelerating then local d7=vec3(kH)-bM;local kO=r(math.deg(k9(bF,bI:normalize(),d7:normalize()))*bJ/500,-90,90)local kP=r(math.deg(k9(bH,bI:normalize(),d7:normalize()))*bJ/500,-90,90)if c(kO)<20 and c(kP)<20 then kO=kO*2;kP=kP*2 end;if c(kO)<2 and c(kP)<2 then kO=kO*2;kP=kP*2 end;local kg=-math.deg(k9(bF,bG,bI:normalize()))local kh=-math.deg(k9(bH,bG,bI:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kP-kh)local kQ=r(apPitchPID:get(),-1,1)T=T+kQ;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kO-kg)local kR=r(apYawPID:get(),-1,1)U=U+kR;kI=true;if c(kO)>2 or c(kP)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if kN<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=bd(ab):escapeAndOrbitalSpeed(kN)end end;if not AutopilotCruising and not AutopilotBraking and not kI then kl=cZ((kH-bM):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kl=cZ(-vec3(bI):normalize())end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cb(AutopilotInterplanetaryThrottle)H=y(AutopilotInterplanetaryThrottle,2)O=true end;local jj=unit.getThrottle()if AtmoSpeedAssist then jj=H end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jj==0 and O then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cb(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cb(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cb(1,true)end;local _,ku=bd(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)local d7;if CustomTarget~=nil then d7=CustomTarget.position-bM end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bJ<50 then a1="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bJ<=ku and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cb(0)O=false;ProgradeIsOn=true;an=true;cE(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,ku=bd(ab):escapeAndOrbitalSpeed((bM-planet.center):len()-planet.radius)if bJ<=ku then if CustomTarget~=nil then if bI:normalize():dot(d7:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;cE(ab,CustomTarget.position)WaypointSet=true end else a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cb(0)O=false;ProgradeIsOn=true;an=true;BrakeIsOn=false;cE(ab,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"a1="Autopilot completed, orbit established"X=0;cb(0)O=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;an=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jj=unit.getThrottle()if AtmoSpeedAssist then jj=H end;if jj>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if kl then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not an then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bH;AutopilotShipUp=bF;AutopilotShipRight=bH end;AutopilotRealigned=true elseif kl then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not O then cb(AutopilotInterplanetaryThrottle,true)H=y(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and au>0)then a1="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cb(0)O=false;ProgradeIsOn=true;an=true;cE(ab,CustomTarget.position)end;if Z then bh=true;local kP=0;local f_=bM+vec3(unit.getMasterPlayerRelativePosition())local kS=f_-bM;local kT=vec3(kS):project_on(bG):len()local kU=vec3(kS):project_on(bH):len()local aj=math.sqrt(kT*kT+kU*kU)cZ(kS:normalize())local kV=40;local kW=aj<kV;local kX=100;local kY=r((aj-kV)/2,10,kX)T=0;local kl=c(U)<0.1;if kl and bJ<kY and not kW then BrakeIsOn=false;kP=-20 else BrakeIsOn=true;kP=0 end;local kZ=0;if c(kP-bR)>kZ then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kP-bR)local kQ=pitchPID:get()T=kQ end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cS=unit.getClosestPlanetInfluence()>0;local k_=HoldAltitude-av;local l0=500+bJ;local l1=1;if AutoTakeoff then l1=r(bJ/100,0.1,1)end;local kP=(utils.smoothstep(k_,-l0,l0)-0.5)*2*MaxPitch*l1;if not Reentry and not an and not VectorToTarget and bG:dot(bI:normalize())<0.99 then kP=(utils.smoothstep(k_,-l0*r(20-19*au*10,1,20),l0*r(20-19*au*10,1,20))-0.5)*2*MaxPitch*r(2-au*10,1,2)*l1 end;if not AltitudeHold then kP=0 end;if LockPitch~=nil then if cS and not IntoOrbit then kP=LockPitch else LockPitch=nil end end;bh=true;local l2=T;if Reentry then local l3=d(bo)local l4,l5=bb.computeDistanceAndTime(bJ,l3/3.6,l(),0,0,LastMaxBrake-planet.gravity*9.8*l())local l6=av-(planet.noAtmosphericDensityAltitude+5000)if not bQ and av>planet.noAtmosphericDensityAltitude+5000 and bJ<=l3/3.6 and bJ>l3/3.6-10 and c(bI:normalize():dot(bG))>0.9 then cb(0)elseif bQ and(l4>-1 and l6<=l4 or av<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;ce(l3,true)if not Q then kP=-80;if au>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kP=0;bh=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and av>planet.noAtmosphericDensityAltitude+5000 then bh=true elseif av<=planet.noAtmosphericDensityAltitude+5000 then ce(l3)if not bQ and s:getTargetSpeed(axisCommandId.longitudinal)==bo then Q=false;Reentry=false;bh=true end end end;if bJ>P and not ao and not VectorToTarget and not BrakeLanding and ForceAlignment then cZ(vec3(bI))end;if(VectorToTarget or ao)and AutopilotTargetIndex>0 and au>0.01 then local d7;if CustomTarget~=nil then d7=CustomTarget.position-bM else d7=ab.center-bM end;local kO=math.deg(k9(bK:normalize(),bI,d7))*2;local l7=math.rad(c(bS))if bJ>minRollVelocity and au>0.01 then local l8=r(90-kP*2,-90,90)bl=r(kO*2,-l8,l8)local l9=kO;kO=r(r(kO,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(l7)+4*(bR-kP)*math.sin(math.rad(bS)),-YawStallAngle*0.80,YawStallAngle*0.80)kP=r(r(kP*math.cos(l7),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(r(c(l9)*math.sin(l7),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bl=0;kO=r(kO,-YawStallAngle*0.80,YawStallAngle*0.80)end;local la=kg-kO;if not bj and bJ>minRollVelocity and au>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(la)local kR=r(yawPID:get(),-1,1)U=U+kR elseif at and aq>-1 or bJ<minRollVelocity then cZ(d7)elseif bj and au>0.01 then if(kg<-YawStallAngle or kg>YawStallAngle)and au>0.01 then cZ(bI)end;if(kh<-PitchStallAngle or kh>PitchStallAngle)and au>0.01 then kP=r(bR-kh,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ao then local km=planet:getAltitude(CustomTarget.position)local l6=math.sqrt(d7:len()^2-(av-km)^2)local lb=LastMaxBrakeInAtmo;if lb then lb=lb*r(bJ/100,0.1,1)*au else lb=LastMaxBrake end;if au<0.01 then lb=LastMaxBrake end;local lc=bI:len()-c(bL)local ld=vec3(core.getWorldAirFrictionAcceleration())local le=math.sqrt(ld:len()-ld:project_on(cD):len())*l()if bJ>100 then a7,a8=bb.computeDistanceAndTime(bJ,100,l(),0,0,lb+le)local lf,lg=bb.computeDistanceAndTime(100,0,l(),0,0,lb/2)a7=a7+lf else a7,a8=bb.computeDistanceAndTime(bJ,0,l(),0,0,lb/2)end;StrongBrakes=true;if not ao and not Reentry and l6<=a7+bJ*kf/2 and(bI:project_on_plane(bK):normalize():dot(d7:project_on_plane(bK):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cb(0)if AltitudeHold then cx()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lc<0.1 or l6<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<l6)then if not bO then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=l6 end elseif VectorToTarget and au==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ao or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local d7=CustomTarget.position-bM;local km=planet:getAltitude(CustomTarget.position)local l6=math.sqrt(d7:len()^2-(av-km)^2)local lb=LastMaxBrakeInAtmo;if lb then a7,a8=bb.computeDistanceAndTime(bJ,0,l(),0,0,lb/2)StrongBrakes=true;if l6<=a7+bJ*kf/2 and bI:project_on_plane(bK):normalize():dot(d7:project_on_plane(bK):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;an=false;ap=true;Autopilot=false;da()end end;LastDistanceToTarget=l6 end end end;if au==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ao or IntoOrbit or Reentry)then if not bz and not IntoOrbit then bx=HoldAltitude;bw=true;if VectorToTarget then bv.VectorToTarget=true end;cw()VectorToTarget=false;bt=true end end;if bj and au>0.01 and aq==-1 and bJ>minRollVelocity and VectorStatus~="Finalizing Approach"then cZ(bI)kP=r(bR-kh,bR-PitchStallAngle*0.80,bR+PitchStallAngle*0.80)end;T=l2;local dj=-1;if BrakeLanding then kP=0;local lh=false;local li=30;if bc~=nil and bc>0 then local le=0;local lj=r(au,0.4,2)local lb=LastMaxBrakeInAtmo*r(bJ/100,0.1,1)*lj;local lk=bc*lj+lb+le-g3;local ll=lb/2+le-g3;local lm=bJ-math.sqrt(c(ll/2)*20/(0.5*l()))*utils.sign(ll)if lm<0 then lm=0 end;local ln;if bJ>100 then local lo,_=bb.computeDistanceAndTime(bJ,100,l(),0,0,lb)local lp,_=bb.computeDistanceAndTime(100,0,l(),0,0,math.sqrt(lb))ln=lo+lp else ln=bb.computeDistanceAndTime(bJ,0,l(),0,0,math.sqrt(lb))end;if ln<20 then BrakeIsOn=false else local lq=0;if lm>100 then local lr,_=bb.computeDistanceAndTime(lm,100,l(),0,0,lk)local ls,_=bb.computeDistanceAndTime(100,0,l(),0,0,bc*lj+math.sqrt(lb)+le-g3)lq=lr+ls else lq,_=bb.computeDistanceAndTime(lm,0,l(),0,0,bc*lj+math.sqrt(lb)+le-g3)end;lq=(lq+15+bJ*kf)*1.1;local lt=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lt then local km=planet:getAltitude(CustomTarget.position)local lu=av-km-100;local d7=CustomTarget.position-bM;local lv=math.sqrt(d7:len()^2-(av-km)^2)if lv>100 then lt=false elseif lu<=lq or lq==-1 then BrakeIsOn=true;lh=true else BrakeIsOn=false;lh=true end end;if not lt and CalculateBrakeLandingSpeed then if lq>=li then BrakeIsOn=true else BrakeIsOn=false end;lh=true end end end;if not bQ then cb(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)dj=aq;if dj>-1 then bh=autoRollPreference;if bJ<1 or bI:normalize():dot(bK)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bI:normalize():dot(-cD)<0.999 then BrakeIsOn=true elseif bL<-brakeLandingRate and not lh then BrakeIsOn=true elseif not lh then BrakeIsOn=false end end;if AutoTakeoff or ao then local fn,fp,fo;if AutopilotTargetCoords~=nil then fn,fp,fo=ba:getPlanetarySystem(0):castIntersections(bM,(AutopilotTargetCoords-bM):normalize(),function(fq)return fq.radius+fq.noAtmosphericDensityAltitude end)end;if bO then if av>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cb(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kP)<15 and av/HoldAltitude>0.75 then AutoTakeoff=false;if not ao then if bQ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ao and bJ<P then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;cb(0)elseif ao then cb(0)BrakeIsOn=true end elseif ao and au==0 and ab~=nil and(fn==nil or fn.name==ab.name)then Autopilot=true;ao=false;AltitudeHold=false;AutoTakeoff=false;if not bQ then cb(0)end;AutopilotAccelerating=true end end;local lw=aq>-1;local lx=bR;if(VectorToTarget or ao)and not lw and bJ>minRollVelocity and au>0.01 then local l7=math.rad(c(bS))lx=bR*c(math.cos(l7))+kh*math.sin(l7)end;local ly=r(kP-lx,-PitchStallAngle*0.80,PitchStallAngle*0.80)if au<0.01 and VectorToTarget then ly=r(kP-lx,-85,MaxPitch)elseif au<0.01 then ly=r(kP-lx,-MaxPitch,MaxPitch)end;if c(bS)<5 or VectorToTarget or BrakeLanding or lw or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(ly)local kQ=pitchPID:get()T=T+kQ end end;if antigrav~=nil and(antigrav and not ExternalAGG and av<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end end;function script.onFlush()local function lz(lA,kY)local lB=vec3()local lC=vec3()if lA==axisCommandId.longitudinal then lB=vec3(core.getConstructOrientationForward())lC=bG elseif lA==axisCommandId.vertical then lB=vec3(core.getConstructOrientationUp())lC=bF elseif lA==axisCommandId.lateral then lB=vec3(core.getConstructOrientationRight())lC=bH else return vec3()end;local lD=vec3(core.getWorldGravity())local lE=lD:dot(lC)local lF=vec3(core.getWorldAirFrictionAcceleration())local lG=lF:dot(lC)local lH=vec3(core.getVelocity())local lI=lH:dot(lB)local lJ=kY*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lJ-lI)local lK=targetSpeedPID2:get()local lL=(lK-lG-lE)*lC;return lL end;local function lM(lA,kY)local lB=vec3()local lC=vec3()if lA==axisCommandId.longitudinal then lB=vec3(core.getConstructOrientationForward())lC=bG elseif lA==axisCommandId.vertical then lB=vec3(core.getConstructOrientationUp())lC=bF elseif lA==axisCommandId.lateral then lB=vec3(core.getConstructOrientationRight())lC=bH else return vec3()end;local lD=vec3(core.getWorldGravity())local lE=lD:dot(lC)local lF=vec3(core.getWorldAirFrictionAcceleration())local lG=lF:dot(lC)local lH=vec3(core.getVelocity())local lI=lH:dot(lB)local lJ=kY*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lJ-lI)local lK=targetSpeedPID:get()local lL=(lK-lG-lE)*lC;return lL end;local function lN(lO,e2,ck)local lP=lO:cross(ck):normalize_inplace()local eO=math.acos(r(lP:dot(-e2),-1,1))*constants.rad2deg;if lP:cross(-e2):dot(ck)<0 then eO=-eO end;return eO end;if antigrav~=nil and(antigrav and not ExternalAGG)then if not bO and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bQ=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bQ and L then cb(0)L=false elseif not bQ and not L then H=0;L=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lQ=r(S+T+system.getControlDeviceForwardInput(),-1,1)local lR=r(V+Y+system.getControlDeviceYawInput(),-1,1)local lS=r(W+U-system.getControlDeviceLeftRightInput(),-1,1)local lT=X;bK=vec3(core.getWorldVertical())if bK==nil or bK:len()==0 then bK=(planet.center-bM):normalize()end;bM=vec3(core.getConstructWorldPos())bF=vec3(core.getConstructWorldOrientationUp())bG=vec3(core.getConstructWorldOrientationForward())bH=vec3(core.getConstructWorldOrientationRight())bI=vec3(core.getWorldVelocity())bJ=vec3(bI):len()bL=-bK:dot(bI)bS=getRoll(bK,bG,bH)local lU=bS/180*math.pi;local lV=math.cos(lU)local lW=math.sin(lU)bR=lN(bK,bG,bH*lV+bF*lW)local lX=bI:normalize()local lY=getRoll(bK,bG,bH)local lZ=c(lY)local l_=utils.sign(lY)local m0=vec3(core.getWorldAngularVelocity())local m1=lQ*pitchSpeedFactor*bH+lR*rollSpeedFactor*bG+lS*yawSpeedFactor*bF;if bK:len()>0.01 and(au>0.0 or ProgradeIsOn or Reentry or an or AltitudeHold or IntoOrbit)then if bh==true and c(bl-lY)>autoRollRollThreshold and lR==0 and c(bR)<85 then local m2=bl;local m3=autoRollFactor;if au==0 then m3=m3/4;bl=0;m2=0 end;if rollPID==nil then rollPID=pid.new(m3*0.01,0,m3*0.1)end;rollPID:inject(m2-lY)local m4=rollPID:get()m1=m1+m4*bG end end;if bK:len()>0.01 and au>0.0 then local m5=20.0;if turnAssist==true and lZ>m5 and lQ==0 and lS==0 then local m6=turnAssistFactor*0.1;local m7=turnAssistFactor*0.025;local m8=(lZ-m5)/(180-m5)*180;local m9=0;if m8<90 then m9=m8/90 elseif m8<180 then m9=(180-m8)/90 end;m9=m9*m9;local ma=-l_*m7*(1.0-m9)local mb=m6*m9;m1=m1+mb*bH+ma*bF end end;local mc=1;local md=0;local me=1;if system.getMouseWheel()>0 then if AltIsOn then if au>0 or Reentry then bo=r(bo+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H+speedChangeLarge/100,-1,1),2)end elseif system.getMouseWheel()<0 then if AltIsOn then if au>0 or Reentry then bo=r(bo-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end else H=y(r(H-speedChangeLarge/100,-1,1),2)end end;I=0;if at and AtmoSpeedAssist and bQ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bo/3.6-bI:dot(bG))local mf=throttlePID:get()K=r(mf,-1,1)if K<H and au>0.005 then J=true;s:setThrottleCommand(axisCommandId.longitudinal,r(K,0.01,1))else J=false;s:setThrottleCommand(axisCommandId.longitudinal,H)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-bo/3.6)local mg=r(brakePID:get(),0,1)if au>0 and bL<-80 or au>0.005 then I=mg end;if I>0 then if J and K==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else K=r(K,0.01,1)end;local mh=''local mi=vec3()local mj=lz(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",mj,md)local mk='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mk=mk..ExtraLongitudeTags end;local ml=s:getAxisCommandType(axisCommandId.longitudinal)local mm=s:composeAxisAccelerationFromThrottle(mk,axisCommandId.longitudinal)local mn=lM(axisCommandId.lateral,LeftAmount*1000)mh=mh..' , '.."lateral airfoil , lateral ground "mi=mi+mn;if mi:len()>constants.epsilon then a:setEngineForceCommand(mh,mi,md,'','','',me)end;a:setEngineForceCommand(mk,mm,mc)local mo='thrust analog vertical fueled 'local mp='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mp=mp..ExtraLateralTags end;if ExtraVerticalTags~="none"then mo=mo..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mo,mj,mc)else a:setEngineForceCommand(mo,vec3(),mc)end;if LeftAmount~=0 then a:setEngineForceCommand(mp,mn,mc)else a:setEngineForceCommand(mp,vec3(),mc)end;if lT==0 then lT=I end;local mq=-lT*(brakeSpeedFactor*bI+brakeFlatFactor*lX)a:setEngineForceCommand('brake',mq)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,H)end;local kY=unit.getAxisCommandValue(0)if not bQ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bI:len()-kY/3.6)local mg=r(brakePID:get(),0,1)lT=r(lT+mg,0,1)end;local mq=-lT*(brakeSpeedFactor*bI+brakeFlatFactor*lX)a:setEngineForceCommand('brake',mq)local mh=''local mi=vec3()local mr=false;local mk='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then mk=mk..ExtraLongitudeTags end;local ml=s:getAxisCommandType(axisCommandId.longitudinal)if ml==axisCommandType.byThrottle then local mm=s:composeAxisAccelerationFromThrottle(mk,axisCommandId.longitudinal)a:setEngineForceCommand(mk,mm,mc)elseif ml==axisCommandType.byTargetSpeed then local mm=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)mh=mh..' , '..mk;mi=mi+mm;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then mr=true end end;local mp='thrust analog lateral 'if ExtraLateralTags~="none"then mp=mp..ExtraLateralTags end;local ms=s:getAxisCommandType(axisCommandId.lateral)if ms==axisCommandType.byThrottle then local mt=s:composeAxisAccelerationFromThrottle(mp,axisCommandId.lateral)a:setEngineForceCommand(mp,mt,mc)elseif ms==axisCommandType.byTargetSpeed then local mn=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)mh=mh..' , '..mp;mi=mi+mn end;local mo='thrust analog vertical 'if ExtraVerticalTags~="none"then mo=mo..ExtraVerticalTags end;local mu=s:getAxisCommandType(axisCommandId.vertical)if mu==axisCommandType.byThrottle then local mj=s:composeAxisAccelerationFromThrottle(mo,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mo,mj,mc,'airfoil','ground','',me)else a:setEngineForceCommand(mo,vec3(),mc)a:setEngineForceCommand('airfoil vertical',mj,mc,'airfoil','','',me)a:setEngineForceCommand('ground vertical',mj,mc,'ground','','',me)end elseif mu==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),mc)end;local mv=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)mh=mh..' , '..mo;mi=mi+mv end;if mi:len()>constants.epsilon then if X~=0 or mr or c(lX:dot(bG))<0.8 then mh=mh..', brake'end;a:setEngineForceCommand(mh,mi,md,'','','',me)end end;local mw=torqueFactor*(m1-m0)local mx=vec3(core.getWorldAirFrictionAngularAcceleration())mw=mw-mx;a:setEngineTorqueCommand('torque',mw,mc,'airfoil','','',me)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local em=vec3(core.getVelocity()):len()local my=0.15;if not bQ then local mz=s:getTargetSpeed(axisCommandId.longitudinal)if em*3.6>mz*(1-my)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif em*3.6<mz*(1-my)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jj=unit.getThrottle()if AtmoSpeedAssist then jj=H*100 end;local kY=jj/100;if j==0 then kY=kY*MaxGameVelocity;if em>=kY*(1-my)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif em<kY*(1-my)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local l3=d(bo)kY=kY*l3/3.6;if em>=kY*(1-my)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif em<kY*(1-my)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cr=coroutine.resume(beginSetup)if cr then SetupComplete=true end else a:update()if not bf and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mA)local B=1;local function mB(mC)if mC then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a2;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a2 end else s:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function mD(mC)if mC then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if mC then B=1 else B=nil end;cC(B)end end;if mA=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cb(0)if(vBooster or hover)and aq==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bh=true;GearExtended=false else BrakeIsOn=true;a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end;if R and not BrakeLanding then a.control.extendLandingGears()end else if R then a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif mA=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mA=="forward"then S=S-1 elseif mA=="backward"then S=S+1 elseif mA=="left"then V=V-1 elseif mA=="right"then V=V+1 elseif mA=="yawright"then W=W-1 elseif mA=="yawleft"then W=W+1 elseif mA=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mA=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mA=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mA=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mA=="groundaltitudeup"then mB()elseif mA=="groundaltitudedown"then mB(true)elseif mA=="option1"then cC()toggleView=false elseif mA=="option2"then cC(1)toggleView=false elseif mA=="option3"then local function mE()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mE()toggleView=false elseif mA=="option4"then cQ()toggleView=false elseif mA=="option5"then local function mF()if LockPitch==nil then LockPitch=bR;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mF()toggleView=false elseif mA=="option6"then cx()toggleView=false elseif mA=="option7"then toggleView=false elseif mA=="option8"then cy()toggleView=false elseif mA=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mA=="lshift"then if x()==1 then a0=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a0=true;bg=false;bf=false end elseif mA=="brake"then if BrakeToggleStatus then cY()elseif not BrakeIsOn then cY()else BrakeIsOn=true end elseif mA=="lalt"then AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif mA=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif mA=="stopengines"then local function mG()if ar then ar=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;an=false;ao=false;Q=false;bh=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else ar=true end end;s:resetCommand(axisCommandId.longitudinal)mG()H=0 elseif mA=="speedup"then mD()elseif mA=="speeddown"then mD(true)elseif mA=="antigravity"and not ExternalAGG then if antigrav~=nil then dc()end end end;function script.onActionStop(mA)local function mH()if not ExternalAGG and bO then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if mA=="forward"then S=0 elseif mA=="backward"then S=0 elseif mA=="left"then V=0 elseif mA=="right"then V=0 elseif mA=="yawright"then W=0 elseif mA=="yawleft"then W=0 elseif mA=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mA=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mA=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mA=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mA=="groundaltitudeup"then mH()toggleView=false elseif mA=="groundaltitudedown"then mH()toggleView=false elseif mA=="lshift"then if x()==1 then a0=false;ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a0=false;bg=false;bf=false end elseif mA=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cY()else BrakeIsOn=false end end elseif mA=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(mA)local B=1;local function mI(mC)if mC then B=-1 end;if not ExternalAGG and bO then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=a5*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bx=bx+B*a4;if bx<planet.noAtmosphericDensityAltitude then bx=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=a4*1.05 else s:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function mJ(mC)if mC then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then H=r(H+B*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if mA=="groundaltitudeup"then mI()elseif mA=="groundaltitudedown"then mI(true)elseif mA=="speedup"then mJ()elseif mA=="speeddown"then mJ(true)end end;function script.onInputText(c8)local function mK()for cg,ch in pairs(bZ())do dbHud_1.setStringValue(ch,g(nil))end;for cg,ch in pairs(b)do if ch~="SavedLocations"then dbHud_1.setStringValue(ch,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5;aM=false;ae=true end;local function mL(mM,planet,f_)local function mN(f_)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gv='::pos{'..z..','..z..','..z..','..z..','..z..'}'local gI,gJ,cM,cN,cL=o(f_,gv)if gI=="0"and gJ=="0"then return vec3(tonumber(cM),tonumber(cN),tonumber(cL))end;cN=math.rad(cN)cM=math.rad(cM)local planet=b4[tonumber(gI)][tonumber(gJ)]local ht=math.cos(cM)local mO=vec3(ht*math.cos(cN),ht*math.sin(cN),math.sin(cM))return planet.center+(planet.radius+cL)*mO end;if dbHud_1 then local cW={}local position=mN(f_)if planet.name=="Space"then cW={position=position,name=mM,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cW={position=position,name=mM,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cW;table.insert(b4[0],cW)cf()else a1="Databank must be installed to save locations"end end;local i;local mP="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank"local mQ,mR=nil,nil;local mS="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables"i=string.find(c8," ")mQ=c8;if i~=nil then mQ=string.sub(c8,0,i-1)mR=string.sub(c8,i+1)end;if mQ=="/help"or mQ=="/commands"then for g9 in string.gmatch(mS,"([^\n]+)")do system.print(g9)end;return elseif mQ=="/setname"then if mR==nil or mR==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cT(mR)else a1="Select a saved target to rename first"end elseif mQ=="/addlocation"then if mR==nil or mR==""or string.find(mR,"::")==nil then a1="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mR,"::")local mM=string.sub(mR,1,i-2)local f_=string.sub(mR,i)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local gv='::pos{'..z..','..z..','..z..','..z..','..z..'}'local gI,gJ,cM,cN,cL=o(f_,gv)local planet=b4[tonumber(gI)][tonumber(gJ)]mL(mM,planet,f_)a1="Added "..mM.." to saved locations,\nplanet "..planet.name.." at "..f_;ai=5 elseif mQ=="/agg"then if mR==nil or mR==""then a1="Usage: ah-agg targetheight"return end;mR=tonumber(mR)if mR<1000 then mR=1000 end;AntigravTargetAltitude=mR;a1="AGG Target Height set to "..mR elseif mQ=="/G"then if mR==nil or mR==""then a1="Usage: ah-G VariableName variablevalue\nah-G dump - shows all variables"return end;if mR=="dump"then for cg,ch in pairs(bZ())do if type(_G[ch])=="boolean"then if _G[ch]==true then system.print(ch.." true")else system.print(ch.." false")end elseif _G[ch]==nil then system.print(ch.." nil")else system.print(ch.." ".._G[ch])end end;return end;i=string.find(mR," ")local mT=string.sub(mR,0,i-1)local mU=string.sub(mR,i+1)for cg,ch in pairs(bZ())do if ch==mT then a1="Variable "..mT.." changed to "..mU;local mV=type(_G[ch])if mV=="number"then mU=tonumber(mU)elseif mV=="boolean"then if string.lower(mU)=="true"then mU=true else mU=false end end;_G[ch]=mU;return end end;a1="No such global variable: "..mT elseif mQ=="/copydatabank"then if dbHud_2 then dk(true)else a1="Spare Databank required to copy databank"end elseif mQ=="/wipedatabank"then if dbHud_1 then mK()else a1="No databank found."end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
