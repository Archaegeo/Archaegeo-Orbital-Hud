name: ArchHud - Archaegeo v1.5162 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5162;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu={}local bv="Atmo"local bw=false;local bx=0;local by={}local bz=nil;local bA=nil;function p(bB)system.print(E..": "..bB)end;local function bC(bD)local D=1;if bD then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bE=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bE<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bx=bx+1*D*-1;if bx>#bm then bx=1 end;if bx<1 then bx=#bm end else if not bD then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bF(bG,bH,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bG.."|"..bH.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bG.."|"..bH.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bG.."|"..bH.."|"..soundVolume)end end;local function bI(bJ,bK)for i=1,#bK do bJ[#bJ+1]=bK[i]end;return bJ end;local function bL(bM)local bN={}local bO={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local bP={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bQ={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bR={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bM then bI(bN,bO)bI(bN,bP)bI(bN,bQ)bI(bN,bR)return bN elseif bM=="boolean"then return bO elseif bM=="handling"then return bP elseif bM=="hud"then return bQ elseif bM=="physics"then return bR end end;local function bS(bT,bU,bV,bW,bX)if bW==nil then bW=""end;if bX==nil then bX=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bW,bT,bU,bX,bV)end;local function bY(bZ,b_)if bZ==0 then return d(b_)<1e-09 end;if b_==0 then return d(bZ)<1e-09 end;return d(bZ-b_)<math.max(d(bZ),d(b_))*epsilon end;local function c0(aj,c1)local c2=aj>100000;if c1==nil then c1=1 end;if c2 then return A(aj/1000/200,c1).."SU"elseif aj<1000 then return A(aj,c1).."M"else return A(aj/1000,c1).."KM"end end;local function c3(c4)local c5=0;local c6=0;local c7=0;if c4<60 then c4=e(c4)elseif c4<3600 then c5=e(c4/60)c4=e(c4%60)elseif c4<86400 then c6=e(c4/3600)c5=e(c4%3600/60)else c7=e(c4/86400)c6=e(c4%86400/3600)end;if c7>0 then return c7 .."d "..c6 .."h "elseif c6>0 then return c6 .."h "..c5 .."m "elseif c5>0 then return c5 .."m "..c4 .."s"elseif c4>0 then return c4 .."s"else return"0s"end end;local function c8(c9)local function ca(cb)for cc,cd in pairs(cb)do dbHud_1.setStringValue(cd,h(_G[cd]))if c9 and dbHud_2 then dbHud_2.setStringValue(cd,h(_G[cd]))end end end;if dbHud_1 then ca(c)ca(bL())system.print("Saved Variables to Datacore")if c9 and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function ce()local function cf(cg)return type(cg)=='number'end;local function ch(cg)return type(z(cg))=='number'end;local function ci(cj)return type(cj)=='table'end;local function ck(cl)return type(cl)=='string'end;local function cm(cd)return ci(cd)and cf(cd.x and cd.y and cd.z)end;local function cn(co)return ci(co)and cf(co.latitude and co.longitude and co.altitude and co.id and co.systemId)end;local cp=math.pi/180;local cq=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cr='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cs(cg)local ct=string.gsub(string.reverse(f('%.4f',cg)),'^0*%.?','')return ct==''and'0'or string.reverse(ct)end;local function cu(cv)if cm(cv)then return f('{x=%.3f,y=%.3f,z=%.3f}',cv.x,cv.y,cv.z)end;if ci(cv)and not getmetatable(cv)then local cw={}local cx=next(cv)if type(cx)=='nil'or cx==1 then cw=cv else for cc,cd in pairs(cv)do local cy=cu(cd)if type(cc)=='number'then table.insert(cw,f('[%s]=%s',cc,cy))else table.insert(cw,f('%s=%s',cc,cy))end end end;return f('{%s}',table.concat(cw,','))end;if ck(cv)then return f("'%s'",cv:gsub("'",[[\']]))end;return tostring(cv)end;local cz={}cz.__index=cz;cz.__tostring=function(cv,cA)local cB={}for cc in pairs(cv)do table.insert(cB,cc)end;table.sort(cB)local cw={}for _,cc in ipairs(cB)do local cy=cu(cv[cc])if type(cc)=='number'then table.insert(cw,f('[%s]=%s',cc,cy))else table.insert(cw,f('%s=%s',cc,cy))end end;if cA then return f('%s%s',cA,table.concat(cw,',\n'..cA))end;return f('{%s}',table.concat(cw,','))end;cz.__eq=function(cC,cD)return cC.systemId==cD.systemId and cC.id==cD.id and bY(cC.radius,cD.radius)and bY(cC.center.x,cD.center.x)and bY(cC.center.y,cD.center.y)and bY(cC.center.z,cD.center.z)and bY(cC.GM,cD.GM)end;local function cE(cF,cG,cH,cI,cJ)assert(ch(cF),'Argument 1 (systemId) must be a number:'..type(cF))assert(ch(cG),'Argument 2 (id) must be a number:'..type(cG))assert(ch(cH),'Argument 3 (radius) must be a number:'..type(cH))assert(ci(cI),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cI))assert(ch(cJ),'Argument 5 (GM) must be a number:'..type(cJ))return setmetatable({systemId=z(cF),id=z(cG),radius=z(cH),center=vec3(cI),GM=z(cJ)},cz)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cs(p.latitude*cq),cs(p.longitude*cq),cs(p.altitude))end;MapPosition.__eq=function(cC,cD)return cC.id==cD.id and cC.systemId==cD.systemId and bY(cC.latitude,cD.latitude)and bY(cC.altitude,cD.altitude)and(bY(cC.longitude,cD.longitude)or bY(cC.latitude,math.pi/2)or bY(cC.latitude,-math.pi/2))end;local function cK(cL,cG,cM,cN,cO)local cF=cL;if ck(cL)and not cN and not cO and not cG and not cM then cF,cG,cM,cN,cO=o(cL,cr)assert(cF,'Argument 1 (position string) is malformed.')else assert(ch(cF),'Argument 1 (systemId) must be a number:'..type(cF))assert(ch(cG),'Argument 2 (id) must be a number:'..type(cG))assert(ch(cM),'Argument 3 (latitude) must be in degrees:'..type(cM))assert(ch(cN),'Argument 4 (longitude) must be in degrees:'..type(cN))assert(ch(cO),'Argument 5 (altitude) must be in meters:'..type(cO))end;cF=z(cF)cG=z(cG)cM=z(cM)cN=z(cN)cO=z(cO)if cG==0 then return setmetatable({latitude=cM,longitude=cN,altitude=cO,id=cG,systemId=cF},MapPosition)end;return setmetatable({latitude=cp*r(cM,-90,90),longitude=cp*(cN%360),altitude=cO,id=cG,systemId=cF},MapPosition)end;local cP={}cP.__index=cP;cP.__tostring=function(cv,cA)local cQ=cA and cA..'  'local cR={}local cB={}for cc in pairs(cv)do table.insert(cB,cc)end;table.sort(cB)for _,cS in ipairs(cB)do bdy=cv[cS]local cT=cz.__tostring(bdy,cQ)if cA then table.insert(cR,f('[%s]={\n%s\n%s}',cS,cT,cA))else table.insert(cR,f('  [%s]=%s',cS,cT))end end;if cA then return f('\n%s%s%s',cA,table.concat(cR,',\n'..cA),cA)end;return f('{\n%s\n}',table.concat(cR,',\n'))end;local function cU(cV)local b={}local pid;for _,cd in pairs(cV)do local cG=cd.planetarySystemId;if type(cG)~='number'then error('Invalid planetary system ID: '..tostring(cG))elseif pid and cG~=pid then error('Mistringmatch planetary system IDs: '..cG..' and '..pid)end;local cW=cd.bodyId;if type(cW)~='number'then error('Invalid body ID: '..tostring(cW))elseif b[cW]then error('Duplicate body ID: '..tostring(cW))end;setmetatable(cd.center,getmetatable(vec3.unit_x))b[cW]=setmetatable(cd,cz)pid=cG end;return setmetatable(b,cP)end;aK={}local function cX(cV)return setmetatable({galaxyAtlas=cV or{}},aK)end;aK.__index=function(cj,i)if type(i)=='number'then local system=cj.galaxyAtlas[i]return cU(system)end;return rawget(aK,i)end;aK.__pairs=function(cv)return function(cj,cc)local cY,nv=next(cj,cc)return cY,nv and cU(nv)end,cv.galaxyAtlas,nil end;aK.__tostring=function(cv)local cZ={}for _,c_ in pairs(cv or{})do local d0=c_:getPlanetarySystemId()local d1=cP.__tostring(c_,'    ')table.insert(cZ,f('  [%s]={%s\n  }',d0,d1))end;return f('{\n%s\n}\n',table.concat(cZ,',\n'))end;aK.BodyParameters=cE;aK.MapPosition=cK;aK.PlanetarySystem=cU;function aK.createBodyParameters(cF,cG,d2,d3,d4,d5,d6)assert(ch(cF),'Argument 1 (systemId) must be a number:'..type(cF))assert(ch(cG),'Argument 2 (id) must be a number:'..type(cG))assert(ch(d2),'Argument 3 (surfaceArea) must be a number:'..type(d2))assert(ci(d3),'Argument 4 (aPosition) must be an array or vec3:'..type(d3))assert(ci(d4),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d4))assert(ch(d5),'Argument 6 (altitude) must be in meters:'..type(d5))assert(ch(d6),'Argument 7 (gravityAtPosition) must be number:'..type(d6))local cH=y(d2/4/math.pi)local aj=cH+d5;local d7=vec3(d3)+aj*vec3(d4)local cJ=d6*aj*aj;return cE(cF,cG,cH,d7,cJ)end;aK.isMapPosition=cn;function aK:getPlanetarySystem(cL)if i==nil then i=0 end;if nv==nil then nv=0 end;local cF=cL;if cn(cL)then cF=cL.systemId end;if type(cF)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cP then system=cU(system)end;return system end end end;function cP:sizeCalculator(d8)return 1.05*d8.radius end;function cP:castIntersections(d9,da,db,dc,dd,de)local df={}local dg=dd or self;for _,d8 in pairs(dg)do table.insert(df,d8)end;if not de then table.sort(df,function(dh,di)return(dh.center-d9):len()<(di.center-d9):len()end)end;local dj=da:normalize()for _,d8 in ipairs(df)do local dk=d8.center-d9;local cH=self:sizeCalculator(d8)local dl=dk:dot(dj)local dm=dl^2-(dk:len2()-cH^2)if dm>=0 then local dn=y(dm)local dp=dl+dn;local dq=dl-dn;if dq>0 then return d8,dp,dq elseif dp>0 then return d8,dp,nil end end end;return nil,nil,nil end;function cP:closestBody(dr)assert(type(dr)=='table','Invalid coordinates.')local ds,d8;local dt=vec3(dr)for _,du in pairs(self)do local dv=(du.center-dt):len2()if(not d8 or dv<ds)and du.name~="Space"then d8=du;ds=dv end end;return d8 end;function cP:convertToBodyIdAndWorldCoordinates(cL)local dw=cL;if ck(cL)then dw=cK(cL)end;if dw.id==0 then return 0,vec3(dw.latitude,dw.longitude,dw.altitude)end;local du=self:getBodyParameters(dw)if du then return dw.id,du:convertToWorldCoordinates(dw)end end;function cP:getBodyParameters(cL)local cG=cL;if cn(cL)then cG=cL.id end;assert(ch(cG),'Argument 1 (id) must be a number:'..type(cG))return self[cG]end;function cP:getPlanetarySystemId()local _,cd=next(self)return cd and cd.systemId end;function cz:convertToMapPosition(cI)assert(ci(cI),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cI))local dx=vec3(cI)if self.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=self.systemId},MapPosition)end;local dy=dx-self.center;local aj=dy:len()local cO=aj-self.radius;local cM=0;local cN=0;if not bY(aj,0)then local dz=n(dy.y,dy.x)cN=dz>=0 and dz or 2*math.pi+dz;cM=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=cM,longitude=cN,altitude=cO,id=self.id,systemId=self.systemId},MapPosition)end;function cz:convertToWorldCoordinates(cL)local dw=ck(cL)and cK(cL)or cL;if dw.id==0 then return vec3(dw.latitude,dw.longitude,dw.altitude)end;assert(cn(dw),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dw.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dw.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dA=math.cos(dw.latitude)return self.center+(self.radius+dw.altitude)*vec3(dA*math.cos(dw.longitude),dA*math.sin(dw.longitude),math.sin(dw.latitude))end;function cz:getAltitude(cI)return(vec3(cI)-self.center):len()-self.radius end;function cz:getDistance(cI)return(vec3(cI)-self.center):len()end;function cz:getGravity(cI)local dB=self.center-vec3(cI)local dC=dB:len2()return self.GM/dC*dB/y(dC)end;return setmetatable(aK,{__call=function(_,...)return cX(...)end})end;local function dD()local aM={}local dE=30000000/3600;local dF=dE*dE;local dG=100;function aM.computeAccelerationTime(dH,dI,dJ)local dK=dE*math.asin(dH/dE)return(dE*math.asin(dJ/dE)-dK)/dI end;function aM.computeDistanceAndTime(dH,dJ,dL,dM,dN,dO)dN=dN or 0;dO=dO or 0;local dP=dH<=dJ;local dQ=dM*(dP and 1 or-1)/dL;local dR=-dO/dL;local dS=dQ+dR;if dP and dS<=0 or not dP and dS>=0 then return-1,-1 end;local dT,dU=0,0;if dQ~=0 and dN>0 then local dK=math.asin(dH/dE)local dV=math.pi*(dQ/2+dR)local dW=dQ*dN;local dX=dE*math.pi;local cd=function(cj)local dY=(dV*cj-dW*math.sin(math.pi*cj/2/dN)+dX*dK)/dX;local dZ=math.tan(dY)return dE*dZ/y(dZ*dZ+1)end;local d_=dP and function(cl)return cl>=dJ end or function(cl)return cl<=dJ end;dU=2*dN;if d_(cd(dU))then local e0=0;while d(dU-e0)>0.5 do local cj=(dU+e0)/2;if d_(cd(cj))then dU=cj else e0=cj end end end;local e1=dH;local e2=dU/dG;for e3=1,dG do local e4=cd(e3*e2)dT=dT+(e4+e1)*e2/2;e1=e4 end;if dU<2*dN then return dT,dU end;dH=e1 end;local dK=dE*math.asin(dH/dE)local E=(dE*math.asin(dJ/dE)-dK)/dS;local e5=dF*math.cos(dK/dE)/dS;local aj=e5-dF*math.cos((dS*E+dK)/dE)/dS;return aj+dT,E+dU end;function aM.computeTravelTime(dH,dI,aj)if aj==0 then return 0 end;if dI>0 then local dK=dE*math.asin(dH/dE)local e5=dF*math.cos(dK/dE)/dI;return(dE*math.acos(dI*(e5-aj)/dF)-dK)/dI end;if dH==0 then return-1 end;assert(dH>0,'Acceleration and initial speed are both zero.')return aj/dH end;return aM end;local function e6()local vec3=require('cpml.vec3')local ce=ce()local function ck(cl)return type(cl)=='string'end;local function ci(cj)return type(cj)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cO)assert(self.body)local aj=cO+self.body.radius;if not bY(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cL,e7)assert(self.body)assert(ci(cL)or ck(cL))assert(ci(e7))local e8=(ck(cL)or ce.isMapPosition(cL))and self.body:convertToWorldCoordinates(cL)or vec3(cL)local cd=vec3(e7)local e9=e8-self.body.center;local ea=cd:len2()local eb=e9:len()local ec=self.body.GM;local ed=((ea-ec/eb)*e9-e9:dot(cd)*cd)/ec;local bZ=ec/(2*ec/eb-ea)local ee=ed:len()local dj=ed:normalize()local ef=bZ*(1-ee)local eg=bZ*(1+ee)local eh=ef*dj+self.body.center;local ei=ee<=1 and-eg*dj+self.body.center or nil;local ej=y(bZ*ec*(1-ee*ee))local ek=ei and 2*math.pi*y(bZ^3/ec)local el=math.acos(ed:dot(e9)/(ee*eb))if e9:dot(cd)<0 then el=-(el-2*math.pi)end;local em=math.acos((math.cos(el)+ee)/(1+ee*math.cos(el)))local en=em;if en<0 then en=en+2*math.pi end;local eo=en-ee*math.sin(en)local ep=0;local eq=0;local er=0;if ek~=nil then ep=eo/(2*math.pi/ek)eq=ek-ep;er=eq+ek/2;if el-math.pi>0 then eq=ep;er=eq+ek/2 end;if er>ek then er=er-ek end end;return{periapsis={position=eh,speed=ej/ef,circularOrbitSpeed=y(ec/ef),altitude=ef-self.body.radius},apoapsis=ei and{position=ei,speed=ej/eg,circularOrbitSpeed=y(ec/eg),altitude=eg-self.body.radius},currentVelocity=cd,currentPosition=e8,eccentricity=ee,period=ek,eccentricAnomaly=em,meanAnomaly=eo,timeToPeriapsis=eq,timeToApoapsis=er,trueAnomaly=el}end;local function es(et)local du=ce.BodyParameters(et.systemId,et.id,et.radius,et.center,et.GM)return setmetatable({body=du},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return es(...)end})end;local function eu()local ev={}local ew={}local ex={XS=13,S=27,M=55,L=110,XL=221}local ey={}local ez;local eA;local eB;local eC;local eD;local function eE()local function eF(eG,eH,eI,eJ,eK,eL,eM,eN)eH,eJ,eL,eN=vec3(eH),vec3(eJ),vec3(eL),vec3(eN)local eO,eP,eQ=eG*eG,eI*eI,eK*eK;local ea=eJ-eH;local eR=ea:normalize()local eS=ea:len()local eT=eL-eH;local eU=(eT-eT:project_on(eR)):normalize()local eV,eW=eT:dot(eR),eT:dot(eU)local eX=eV*eV+eW*eW;local eY=eR:cross(eU)local bT=(eO-eP+eS*eS)/(2*eS)local bU=(eO-eQ+eX-2*eV*bT)/(2*eW)local co=eO-bT^2-bU^2;local eZ=y(co)local e_=eH+eR*bT+eU*bU+eY*eZ;local f0=eH+eR*bT+eU*bU-eY*eZ;if d((eN-e_):len()-eM)<d((eN-f0):len()-eM)then return e_ else return f0 end end;local function f1()local function f2()local f3=core.getConstructWorldOrientationRight()local ea=core.getConstructWorldOrientationForward()local eT=core.getConstructWorldOrientationUp()local f4=library.systemResolution3(f3,ea,eT,{1,0,0})local f5=library.systemResolution3(f3,ea,eT,{0,1,0})local f6=library.systemResolution3(f3,ea,eT,{0,0,1})return function(f7)return library.systemResolution3(f4,f5,f6,f7)end end;local f8=f2()local f9=core.getConstructWorldPos()local e8=core.getElementPositionById(1)local fa={e8[1],e8[2],e8[3]}local fb=f8(fa)local fc={f9[1]-fb[1],f9[2]-fb[2],f9[3]-fb[3]}return fc end;local function fd(fe,eb,ff)local fg=fe.pts;local fh=#fg;local fi=fe.ref;if fh>3 then local fj,fk,fl,fm=fg[fh],fg[fh-1],fg[fh-2],fg[fh-3]fe.ref=ff;local e8=eF(fj[1],fj[2],fk[1],fk[2],fl[1],fl[2],fm[1],fm[2])local bT,bU,eZ=e8.x,e8.y,e8.z;if bT==bT and bU==bU and eZ==eZ then bT=bT+fi[1]bU=bU+fi[2]eZ=eZ+fi[3]local fn=vec3(bT,bU,eZ)if not fe.lastPos then fe.center=fn elseif(fe.lastPos-fn):len()<2 then fe.center=fn;fe.skipCalc=true end;fe.lastPos=fn end;fe.pts={}else local fo={ff[1]-fi[1],ff[2]-fi[2],ff[3]-fi[3]}fg[fh+1]={eb,fo}end end;if bu[1]then ez=#bu[1].getConstructIds()local fp=bu[1].getData()local fq=fp:gmatch('{"constructId[^}]*}[^}]*}')if ez>0 then local ff=f1()local fr,fs=0,0;eD,eC=0,0;for cd in fq do local cG,aj,ft=cd:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fu=ex[ft]aj=z(aj)if bu[1].hasMatchingTransponder(cG)==1 then table.insert(ew,cG)end;local fv=bu[1].getConstructType(cG)if CollisionSystem then if fu>27 or fv=="static"or fv=="space"then eD=eD+1;local fw=bu[1].getConstructName(cG)local fe=bq[cG]if fe==nil then fu=fu+G;bq[cG]={pts={},ref=ff,name=fw,i=0,radius=fu,skipCalc=false}fe=bq[cG]end;if not fe.skipCalc then fd(fe,aj,ff)fs=fs+1 end;if fe.center then table.insert(ey,fe)end end;fr=fr+1;if br and fr>700 or fs>70 or(not br and fr>300 or fs>30)then coroutine.yield()fr,fs=0,0 end end end;eC=#ey;if eC>0 and bc>20 then local d8,fx,fy,fz;local fA=0;local fB=aL:getPlanetarySystem(0)fz=bb:normalize()while fA<eC do coroutine.yield()local fC={table.unpack(ey,fA,math.min(fA+75,eC))}d8,fx,fy=fB:castIntersections(bf,fz,nil,nil,fC,true)if d8 and fy then bt={d8,fx,fy}break end;fA=fA+75 end;if not d8 then bt=nil end else bt=nil end;ey={}eA=fp:find('identifiedConstructs":%[%]')else eB=fp:find('worksInEnvironment":false')end end end;local function fD()if bu[1]then bv="Atmo"if bu[1].getData():find('worksInAtmosphere":false')then bv="Space"end end end;function ev.pickType()fD()end;function ev.assignRadar()if radar_1 and bu[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bu[1]=radar_2 end;if bu[1]==radar_2 then fD()end elseif radar_2 and bu[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bu[1]=radar_1 end;if bu[1]==radar_1 then fD()end end end;function ev.UpdateRadar()local fE=coroutine.status(UpdateRadarCoroutine)if fE=="suspended"then local cy,fF=coroutine.resume(UpdateRadarCoroutine)if fF then system.print("ERROR UPDATE RADAR: "..fF)end elseif fE=="dead"then UpdateRadarCoroutine=coroutine.create(eE)local cy,fF=coroutine.resume(UpdateRadarCoroutine)end end;function ev.GetRadarHud()local fG=ew;ew={}return eA,eB,ez,eC,eD,fG end;UpdateRadarCoroutine=coroutine.create(eE)return ev end;local function fH()local fI=9.80665;local fJ={}local fK={}local fL={}local by={}local fM=nil;local fN=nil;local fO=nil;local fP=false;local fQ={}local fR=showHud;local fS=""local fT=vec3({13771471,7435803,-128971})local fU=18000000;local fV=500000;local fW,fX=math.huge;local fY;local function fZ(f_)fW=vec3(f_):dist(fT)if fW<fU then return true,d(fW-fU)end;fX=vec3(f_):dist(vec3(planet.center))if fX<fV then fY=true else fY=false end;if d(fX-fV)<d(fW-fU)then return fY,d(fX-fV)else return fY,d(fW-fU)end end;local function g0(cd)if aD==1920 then return cd else return A(aD*cd/1920,0)end end;local function g1(cd)if aE==1080 then return cd else return A(aE*cd/1080,0)end end;local function g2()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g3()local g4="TRAVEL"if not bj then g4="CRUISE"end;if Autopilot then g4="AUTOPILOT"end;return g4 end;local g5={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local g6=""local g7=""local g8=""local g9=1;local ga=2;local gb=3;local gc=4;local gd=5;local ge=6;local gf=""local gg=0;local gh=e(1/apTickRate)*2*hudTickRate;local gi={}local gj={}local gk={}local gl={}local gm={}local gn={}local function go(bT,gp,gq,gr,gs,gt)local gu=tankY;local gv=tankY+5;if not BarFuelDisplay then gv=gv+5 end;if m()==1 and not RemoteHud then gu=gu-50;gv=gv-50 end;if gq=="ATMO"then gf="atmofueltank"elseif gq=="SPACE"then gf="spacefueltank"else gf="rocketfueltank"end;gg=_G[gf.."_size"]if#gr>0 then for i=1,#gr do local fw=string.sub(gr[i][ga],1,12)local gw=0;for gx=1,gg do if gr[i][ga]==g(unit[gf.."_"..gx].getData()).name then gw=gx;break end end;local gy=q()if gs[i]==nil or gt[i]==nil or gy-gr[i][ge]>gh then local gz;local gA=0;if gw~=0 then gt[i]=g(unit[gf.."_"..gw].getData()).percentage;gs[i]=g(unit[gf.."_"..gw].getData()).timeLeft;if gs[i]=="n/a"then gs[i]=0 end else gA=l(gr[i][g9])-gr[i][gc]gt[i]=e(0.5+gA*100/gr[i][gb])gz=gr[i][gd]if gz<=gA then gs[i]=0 else gs[i]=e(0.5+gA/((gz-gA)/(gy-gr[i][ge])))end;gr[i][gd]=gA;gr[i][ge]=gy end end;if fw==gp then fw=f("%s %d",gq,i)end;if gw==0 then fw=fw.." *"end;local gB;if gs[i]==0 then gB=""else gB=c3(gs[i])end;if gt[i]~=nil then local gC=e(gt[i]*2.55)local gD=f("rgb(%d,%d,%d)",255-gC,gC,0)local bW=""if gB~=""and gs[i]<120 or gt[i]<5 then bW="red "end;local gE=f("rgb(%d,%d,%d)",r(e((255-gC)/2.55),50,100),r(e(gC/2.55),0,50),50)local gF="rgb(196,0,255)"if gq=="ATMO"then gF="rgb(0,188,255)"elseif gq=="SPACE"then gF="rgb(239,255,0)"end;local gG=false;if previous~=gF then gG=true end;previous=gF;if BarFuelDisplay then if gG then gu=gu-5;gv=gv-5 end;g7=g7 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gE,gF,bT,gv,gD,e(gt[i]*1.7+0.5),bT,gv,bT+5,gv+14,fw,gt[i],gB)gu=gu-22;gv=gv-22 else g7=g7 ..bS(bT,gu,fw,bW.."pdim txtfuel")g7=g7 ..bS(bT,gv,f("%d%% %s",gt[i],gB),"pdim txtfuel","fill:"..gD)gu=gu+30;gv=gv+30 end end end end;tankY=gu end;local function gH(gI,cO)if cO<200000 and not aq or cO and aq then local gJ=0;if d(be)>1 then gJ=45*math.log(d(be),10)if be<0 then gJ=-gJ end end;gI[#gI+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gJ))end;return gI end;local function gK(gL)local gM=-bd;gL=gL-gL:project_on(gM)local gN=vec3(0,0,1)gN=gN-gN:project_on(gM)local gO=gN:cross(gM)local gJ=gN:angle_between(gL)*constants.rad2deg;if gL:dot(gO)<0 then gJ=360-gJ end;return gJ end;local function gP(gI,centerX,centerY,gQ,gR,br)local gS=circleRad;local gT=20;local gU=e(gQ)if br then for i=-45,45,5 do local gV=i;gI[#gI+1]=f([[<g transform="rotate(%f,%d,%d)">]],gV,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gI[#gI+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gS+gT-len,centerX,centerY+gS+gT)end;gI[#gI+1]=bS(centerX,centerY+gS+gT-35,gR,"pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY+gS+gT-25,gU.." deg","pdim txt txtmid")gI[#gI+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gQ,centerX,centerY)gI[#gI+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gS+gT-20,centerX+5,centerY+gS+gT-20,centerX,centerY+gS+gT-15)gI[#gI+1]="</g>"end;gI[#gI+1]=[[<g style="clip-path: url(#headingClip);">]]local gW=gU;if br then gW=gK(b8)end;local gX=20;local gY=e(gW)local gZ=0;local g_=centerY+gS+gT+20;local h0=centerX;if gR~="YAW"then g_=g1(130)h0=g0(960)end;local h1=[[<path class="txttick line" d="]]local h2=e(gY-(gX+10)-gY%5+0.5)for i=h2+70,h2,-5 do local bT=h0-(-i*5+gW*5)if i%10==0 then gZ=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gI[#gI+1]=bS(bT,g_+15,B,"txtmid bright")elseif i%5==0 then gZ=5 end;if gZ==10 then h1=f([[%s M %f %f v %d]],h1,bT,g_-5,gZ)else h1=f([[%s M %f %f v %d]],h1,bT,g_-2.5,gZ)end end;gI[#gI+1]=h1 ..[["/>]]gI[#gI+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h0-5,g_-20,h0+5,g_-20,h0,g_-10)if br then gR="HDG"end;gI[#gI+1]=bS(g0(960),g1(100),gY.."°","dim txt txtmid size14","")gI[#gI+1]=bS(g0(960),g1(85),gR,"dim txt txtmid size20","")gI[#gI+1]=[[</g>]]end;local function h3(gI,h4,gQ,centerX,centerY,br,h5,e4)local gS=circleRad;local h6=e(gS*3/5)if gS>0 then local h7=e(h4)local len=0;local h1=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gQ,centerX,centerY)if not aq then h1=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gI[#gI+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gS-1,centerX,centerY)gI[#gI+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h7-30-h7%5+0.5),e(h7+30+h7%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bU=centerY+-i*5+h4*5;if len==30 then h1=f([[%s M %d %f h %d]],h1,centerX-h6-len,bU,len)if aq then gI[#gI+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gQ,centerX,centerY,centerX-h6+10,bU+4,i)gI[#gI+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gQ,centerX,centerY,centerX+h6-10,bU+4,i)if i==0 or i==180 or i==-180 then gI[#gI+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gQ,centerX,centerY,centerX-h6+20,bU,h6*2-40)end else gI[#gI+1]=bS(centerX-h6+10,bU,i,"pdim txt txtmid")gI[#gI+1]=bS(centerX+h6-10,bU,i,"pdim txt txtmid")end;h1=f([[%s M %d %f h %d]],h1,centerX+h6,bU,len)else h1=f([[%s M %d %f h %d]],h1,centerX-h6-len,bU,len)h1=f([[%s M %d %f h %d]],h1,centerX+h6,bU,len)end end;gI[#gI+1]=h1 ..[["/>]]local h8="PITCH"if not br then h8="REL PITCH"end;if h4>90 and not aq then h4=90-(h4-90)elseif h4<-90 and not aq then h4=-90-(h4+90)end;if gS>200 then if aq then if e4>Q then gI[#gI+1]=bS(centerX,centerY-15,"Yaw","pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY+20,h5,"pdim txt txtmid")end;gI[#gI+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gQ,centerX,centerY)else gI[#gI+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gI[#gI+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h6+25,centerY-5,centerX-h6+20,centerY,centerX-h6+25,centerY+5,centerX-h6+50,centerY+4,h7)gI[#gI+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h6-25,centerY-5,centerX+h6-20,centerY,centerX+h6-25,centerY+5,centerX+h6-30,centerY+4,h7)gI[#gI+1]="</g>"end;local h9=e(gS/3)gI[#gI+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-h9,centerY,gS-h9)if not aq and br then gI[#gI+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gQ,centerX,centerY,centerX-h6+10,centerY,h6*2-20)end;gI[#gI+1]="</g>"if gS<200 then if aq and e4>Q then gI[#gI+1]=bS(centerX,centerY-gS,h8,"pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY-gS+10,h7,"pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY-15,"Yaw","pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY+20,h5,"pdim txt txtmid")else gI[#gI+1]=bS(centerX,centerY-gS,h8,"pdim txt txtmid")gI[#gI+1]=bS(centerX,centerY-gS+15,h7,"pdim txt txtmid")end end end end;local function ha(gI,cO,br)local hb=altMeterX;local hc=altMeterY;local hd=78;local he=19;local hf=ao;if ao~=-1 then gI[#gI+1]=bS(hb+hd,hc+he+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cO<200000 and not aq or cO and aq)then table.insert(gI,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hb-1,hc-4,hd+2,he+6,hb+1,hc-1,hd-4,he))local fh=0;local hg=1;local hh=0;local hi=cO<0;local hj=cO<planet.surfaceMaxAltitude;local hk=9;if hi then hk=0 end;local cO=d(cO)while fh<6 do local hl=11;local hm=16;local hn=9;local ho=14;local bW="altsm"if fh>2 then hm=hm+3;hl=hl+2;ho=ho+2;hn=hn-6;bW="altbig"end;if hi then bW=bW.." red"elseif hj then bW=bW.." orange"end;local hp=cO/hg%10;local hq=e(hp)local hr=e((hq+1)%10)local hs=hh;if fh==0 then hs=hp-hq;if hi then hs=1-hs end end;if hi and(fh==0 or hh~=0)then local ht=hr;hr=hq;hq=ht end;local hu=hm*(hs-1)local hv=hu+hm;local bT=hb+hn+(6-fh)*hl;local bU=hc+ho;gI[#gI+1]=bS(bT,bU+hu,hr,bW)gI[#gI+1]=bS(bT,bU+hv,hq,bW)fh=fh+1;hg=hg*10;if hq==hk then hh=hs else hh=0 end end;table.insert(gI,[[</g></g>]])end end;local function hw(e7)local hx=-math.deg(n(e7.y,e7.z))+180;hx=hx-90;if hx<0 then hx=360+hx end;if hx>180 then hx=-180+hx-180 end;return-hx end;local function hy(e7)local gW=math.deg(n(e7.y,e7.x))-90;if gW<-180 then gW=360+gW end;return gW end;local function hz(gI,e7,e4,centerX,centerY)if e4>5 and not aq or e4>Q then local gS=circleRad;local hA=20;local hB=20;local hC=hw(e7)local hD=hy(e7)local hE=14;local hF=hE/2;local hG=-hD/hB*gS;local hH=hC/hA*gS;local bT=centerX+hG;local bU=centerY+hH;local aj=y(hG^2+hH^2)local hI=[[<circle
                            cx="]]..bT..[["
                            cy="]]..bU..[["
                            r="]]..hF/hE..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bT..[["
                            cy="]]..bU..[["
                            r="]]..hF..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bT-hE..[[,]]..bU..[[ h ]]..hF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bT+hF..[[,]]..bU..[[ h ]]..hF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bT..[[,]]..bU-hE..[[ v ]]..hF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gS then gI[#gI+1]=hI else local gJ=n(hH,hG)local hJ=4;local hK=centerX+gS*math.cos(gJ)local hL=centerY+gS*math.sin(gJ)gI[#gI+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gJ*180/math.pi,hK,hL,hK-hJ,hL-hJ/2,hJ*2,hJ,hK+hJ,hL-hJ,hJ,hJ,-hJ,hJ)end;if not aq then local hM=vec3(e7)hC=hw(-hM)hD=hy(-hM)hG=-hD/hB*gS;hH=hC/hA*gS;bT=centerX+hG;bU=centerY+hH;aj=y(hG^2+hH^2)if aj<gS then local hN=[[<circle
                                    cx="]]..bT..[["
                                    cy="]]..bU..[["
                                    r="]]..hF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bT..[[,]]..bU-hE..[[ v ]]..hF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bT..[[,]]..bU..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bT..[[,]]..bU..[[)" />
                                <path
                                    d="M ]]..bT-hF..[[,]]..bU..[[ h ]]..hE..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bT..[[,]]..bU..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bT..[[,]]..bU..[[)"/>]]gI[#gI+1]=hN end end end end;local function hO(gI,g4,hP,hQ)hP=e(hP+0.5)local gu=throtPosY+10;local gv=throtPosY+20;if m()==1 and not RemoteHud then gu=55;gv=65 end;local hR="CRUISE"local unit="km/h"local cy=hQ;if g4=="TRAVEL"or g4=="AUTOPILOT"then hR="THROT"unit="%"cy=hP;local hS="dim"if hP<0 then hS="red"end;gI[#gI+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hS,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hP),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gI[#gI+1]=bS(throtPosX+10,gu,hR,"pbright txtstart")gI[#gI+1]=bS(throtPosX+10,gv,f("%.0f %s",cy,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hP=e(N*100+0.5)local hS="red"if hP<0 then hS="red"end;gI[#gI+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hS,1-d(hP),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gI[#gI+1]=bS(throtPosX+10,gu+40,"LIMIT","pbright txtstart")gI[#gI+1]=bS(throtPosX+10,gv+40,hP.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gI[#gI+1]=bS(throtPosX+10,gu-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gI[#gI+1]=bS(throtPosX+10,gu-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hT(gI,hU)local hV=throtPosY-10;local hW=throtPosX+10;gI[#gI+1]=bS(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hV=75 end;gI[#gI+1]=bS(hW,hV,e(hU).." km/h","pbright txtbig txtstart")end;local function hX(gI)gI[#gI+1]=bS(g0(1900),g1(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gI[#gI+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gI[#gI+1]=bS(g0(960),g1(550),"Warning: Invalid Control Scheme Detected","warnings")gI[#gI+1]=bS(g0(960),g1(600),"Keyboard Scheme must be selected","warnings")gI[#gI+1]=bS(g0(960),g1(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hY=g0(960)local hZ=g1(860)local h_=g1(880)local i0=g1(900)local i1=g1(960)local i2=g1(200)local i3=g1(250)local i4=g1(960)if m()==1 and not RemoteHud then hZ=g1(135)h_=g1(155)i0=g1(175)i2=g1(115)i3=g1(95)end;local i5="#222222"local i6="white"local i7="dimmer"local i8="pbright"local i9="#110000"local ia=i5;local ib=i7;if BrakeIsOn then gI[#gI+1]=bS(hY,hZ,"Brake Engaged","warnings")i9="#440000"ia=i6;ib=i8 elseif L>0 then gI[#gI+1]=bS(hY,hZ,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ic="#110000"local id=i5;local ie=i7;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gI[#gI+1]=bS(hY,i2+50,"** STALL WARNING **","warnings")ic="#ff0000"id=i6;ie=i8;bF("stall","SW",2)end end;if bp then gI[#gI+1]=bS(hY,i2+90,"Flight Assist in Progress","warnings")end;if ax then gI[#gI+1]=bS(hY,i4,"Gyro Enabled","warnings")end;local ig="#111100"local ih=i5;local ii=i7;if GearExtended then ig="#775500"ih=i6;ii=i8;if S then gI[#gI+1]=bS(hY,h_,"Gear Extended","warn")else gI[#gI+1]=bS(hY,h_,"Landed (G: Takeoff)","warnings")end;local ij=c0(a:getTargetGroundAltitude())gI[#gI+1]=bS(hY,i0,"Hover Height: "..ij,"warn")end;local ik="#000011"local il=i5;local im=i7;if a7 then ik="#0000DD"il=i6;im=i8;gI[#gI+1]=bS(hY,i1+20,"ROCKET BOOST ENABLED","warn")end;local io="#001100"local ip=i5;local iq=i7;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then io="#00DD00"ip=i6;iq=i8;if d(as-antigrav.getBaseAltitude())<501 then gI[#gI+1]=bS(hY,i2+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gI[#gI+1]=bS(hY,i2+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gI[#gI+1]=bS(hY,i2+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gI[#gI+1]=bS(hY,i2+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gI[#gI+1]=bS(hY,i2+20,"Follow Mode Engaged","warn")elseif Reentry or an then gI[#gI+1]=bS(hY,i2+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ij=c0(HoldAltitude,2)if VertTakeOff then if bh then ij=c0(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gI[#gI+1]=bS(hY,i2,"VTO to "..ij,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gI[#gI+1]=bS(hY,i2,"Takeoff to "..AutopilotTargetName,"warn")else gI[#gI+1]=bS(hY,i2,"Takeoff to "..ij,"warn")end;if BrakeIsOn and not VertTakeOff then gI[#gI+1]=bS(hY,i2+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gI[#gI+1]=bS(hY,i2,"Altitude Hold: "..ij,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gI[#gI+1]=bS(hY,i2+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gI[#gI+1]=bS(hY,i2+20,"Aligning trajectory","warn")elseif ar<0.05 then gI[#gI+1]=bS(hY,i2+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gI[#gI+1]=bS(hY,i2,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gI[#gI+1]=bS(hY,i2,"Brake-Landing","warnings")else gI[#gI+1]=bS(hY,i2,"Coast-Landing","warnings")end end;if ProgradeIsOn then gI[#gI+1]=bS(hY,i2,"Prograde Alignment","crit")end;if RetrogradeIsOn then gI[#gI+1]=bS(hY,i2,"Retrograde Alignment","crit")end;local ir="#110000"local is=i5;local it=i7;if bs then ir="#FF0000"is=i6;it=i8;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gI[#gI+1]=bS(hY,i3+20,bs,type)elseif ar==0 then local iu,iv=aR.checkLOS(bb:normalize())if iv~=nil then it=i8;ir="#FF0000"is=i6;local ij=c0(iv)local travelTime=aM.computeTravelTime(bc,0,iv)local iw="Collision"if iu.noAtmosphericDensityAltitude>0 then iw="Atmosphere"end;gI[#gI+1]=bS(hY,i3+20,iu.name.." "..iw.." "..c3(travelTime).." In "..ij,"crit")end end;if VectorToTarget and not IntoOrbit then gI[#gI+1]=bS(hY,i2+35,VectorStatus,"warn")end;local ix="#111100"local iy=i5;local iz=i7;if bz and#bz>1 then ix="#DDDD00"iy=i6;iz=i8 end;local iA=g0;local iB=g1;local i7="topButton"local iC="topButtonActive"local iD=i7;if Autopilot or VectorToTarget or am or IntoOrbit then iD=iC end;local iE=i7;if ProgradeIsOn then iE=iC end;local iF=i7;if BrakeLanding or GearExtended then iF=iC end;local iG=i7;if AltitudeHold or VectorToTarget then iG=iC end;local iH=i7;if RetrogradeIsOn then iH=iC end;local iI=i7;if IntoOrbit or b3 and Autopilot then iI=iC end;local iJ=iB(30)gI[#gI+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iD,iA(960),iB(54),iB(-53),iA(-120),iA(25),iB(50))gI[#gI+1]=bS(iA(910),iJ,"AUTOPILOT")gI[#gI+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iE,iA(865),iB(51),iA(-25),iB(-50),iA(-110),iA(25),iB(46))gI[#gI+1]=bS(iA(800),iJ,"PROGRADE")gI[#gI+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iF,iA(755),iB(47),iA(-25),iB(-46),iA(-98),iA(44),iB(44))gI[#gI+1]=bS(iA(700),iJ,"LAND")gI[#gI+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iG,iA(960),iB(54),iB(-53),iA(120),iA(-25),iB(50))gI[#gI+1]=bS(iA(1010),iJ,"ALT HOLD")gI[#gI+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iH,iA(1055),iB(51),iA(25),iB(-50),iA(110),iA(-25),iB(46))gI[#gI+1]=bS(iA(1122),iJ,"RETROGRADE")gI[#gI+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iI,iA(1165),iB(47),iA(25),iB(-46),iA(98),iA(-44),iB(44))gI[#gI+1]=bS(iA(1220),iJ,"ORBIT")gI[#gI+1]=[[
                                </g>
                            </g>]]gI[#gI+1]="</g>"return gI end;local function iK(e4)return e(A(e4*3.6,0)+0.5).." km/h"end;local function iL(gI)local bT=OrbitMapX+10;local bU=OrbitMapY+20;local iM={}local iN={"Alt-4: AutoTakeoff to Target"}local iO={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iP={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iQ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iM,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bI(iM,iN)if ac and planet and ac.name==planet.name then table.insert(iM,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iM,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iM,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iM,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iM,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iM,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iM,"G: Takeoff to hover height, raise gear")else table.insert(iM,"G: Lowergear and Land")end else bI(iM,iO)table.insert(iM,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iM,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bI(iM,iP)if shield_1 then table.insert(iM,"Alt-Shift-5: Toggle shield off and on")table.insert(iM,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iM,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iM,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iM,"Alt-Spacebar/C will raise/lower target height")table.insert(iM,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iM,"LALT+Mousewheel will lower/raise speed limit")end;bI(iM,iQ)for i=1,#iM do bU=bU+12;gI[#gI+1]=bS(bT,bU,iM[i],"pdim txtbig txtstart")end end;local function iR(gI)local iS=g0(OrbitMapX)local iT=g1(OrbitMapY)local iU=OrbitMapSize;local iV=4;local iW=15;local bT=0;local bU=0;local iX,iY,iZ,i_;local j0;local function j1(type)local j2,E,e4,j3,bW,j4;if type=="Periapsis"then j2=j0.periapsis.altitude;E=j0.timeToPeriapsis;e4=j0.periapsis.speed;bW="txtend"j3=12;j4=math.min(bT,iS+iU-planet.radius/iZ-iV*2)else j2=j0.apoapsis.altitude;E=j0.timeToApoapsis;e4=j0.apoapsis.speed;j3=-12;bW="txtstart"j4=bT end;if bc<1 then E=0 end;gI[#gI+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j4+j3,bU-5,bT,bU-5)gI[#gI+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j4-j3*4,bU+2,bT,bU+2)gI[#gI+1]=bS(j4,bU,type,bW)bT=j4-j3*2;bU=bU+iW;local ij=c0(j2)gI[#gI+1]=bS(bT,bU,ij,bW)bU=bU+iW;gI[#gI+1]=bS(bT,bU,c3(E),bW)bU=bU+iW;gI[#gI+1]=bS(bT,bU,iK(e4),bW)end;local j5=iU*1.5;if SelectedTab=="INFO"then j5=25*7 end;if SelectedTab~="HIDE"then gI[#gI+1]=[[<g class="pbright txtorb txtmid">]]gI[#gI+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iU*2,j5,iS,iT)gI[#gI+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iU*2,j5,iS,iT)end;if SelectedTab=="ORBIT"then iT=iT+iV;iX=iU/2;i_=0;j0={}j0.periapsis={}j0.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j0.periapsis.altitude=orbit.periapsis.altitude;j0.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j0.apoapsis.altitude=orbit.apoapsis.altitude;j0.apoapsis.speed=orbit.apoapsis.speed end;j0.period=orbit.period;j0.eccentricity=orbit.eccentricity;j0.timeToApoapsis=orbit.timeToApoapsis;j0.timeToPeriapsis=orbit.timeToPeriapsis;j0.eccentricAnomaly=orbit.eccentricAnomaly;j0.trueAnomaly=orbit.trueAnomaly end;if j0.periapsis==nil then j0.periapsis={}j0.periapsis.altitude=-planet.radius;j0.periapsis.speed=MaxGameVelocity end;if j0.eccentricity==nil then j0.eccentricity=1 end;if j0.apoapsis==nil then j0.apoapsis={}j0.apoapsis.altitude=as;j0.apoapsis.speed=0 end;if bc<1 then j0.apoapsis.altitude=as;j0.apoapsis.speed=0 end;if j0.apoapsis.altitude then iZ=(j0.apoapsis.altitude+j0.periapsis.altitude+planet.radius*2)/(iX*2)iY=(planet.radius+j0.apoapsis.altitude)/iZ*(1-j0.eccentricity)i_=iX-j0.periapsis.altitude/iZ-planet.radius/iZ;local j6=math.pi;if j0.period~=nil and j0.period>0 and j0.timeToApoapsis~=nil then j6=j0.eccentricAnomaly;if j0.timeToPeriapsis<j0.timeToApoapsis then j6=2*math.pi-j6 end end;if bc<1 or j6~=j6 then j6=math.pi end;local j7=-iX*math.cos(j6)+iS+iU+iV;local j8=iY*math.sin(j6)+iT+iU*1.5/2+iV;local j9=""gI[#gI+1]='<g clip-path="url(#orbitRect)">'gI[#gI+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],j9,iS+iU+iV,iT+iU*1.5/2+iV,iX,iY)if iY<1 then gI[#gI+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iS+iU+iV-i_,iT+iU*1.5/2+iV,j7,j8)end;gI[#gI+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iS+iU+iV-i_,iT+iU*1.5/2+iV,(planet.radius+planet.noAtmosphericDensityAltitude)/iZ)gI[#gI+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iS+iU+iV-i_,iT+iU*1.5/2+iV,(planet.radius+planet.noAtmosphericDensityAltitude)/iZ)gI[#gI+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iS+iU+iV,iT+iU*1.5/2+iV,iX,iY)gI[#gI+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iS+iU+iV-i_,iT+iU*1.5/2+iV,planet.radius/iZ)gI[#gI+1]='</g>'local ja=math.floor(planet.radius/iZ+0.5)local jb=g5.Generic_Moon;if g5[planet.name]then jb=g5[planet.name]end;bT=iS+iU+iV*4+iX;bU=iT+iU*1.5/2+5+iV;if j0.apoapsis~=nil and j0.apoapsis.speed<MaxGameVelocity then j1("Apoapsis")end;bU=iT+iU*1.5/2+5+iV;bT=iS+iU-iV*2-iX;if j0.periapsis~=nil and j0.periapsis.speed<MaxGameVelocity and j0.periapsis.altitude>0 then j1("Periapsis")end;gI[#gI+1]=bS(iS+iU+iV,iT+20+iV,planet.name,"txtorbbig")gI[#gI+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',j7,j8)gI[#gI+1]=[[</g>]]return gI else gI[#gI+1]='<g clip-path="url(#orbitRect)">'local jc=""local jd=1.2*(maxAtlasX-minAtlasX)/(iU*2)local je=1.4*(maxAtlasY-minAtlasY)/(iU*1.5)for cc,cd in pairs(b[0])do if cd.center then local bT=iS+iU+cd.center.x/jd;local bU=iT+iU*1.5/2+cd.center.y/je;jc=jc..'<circle cx="'..bT..'" cy="'..bU..'" r="'..cd.radius/jd*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cd.name,"Moon")and not string.match(cd.name,"Sanctuary")and not string.match(cd.name,"Space")then jc=jc.."<text x='"..bT.."' y='"..bU+cd.radius/jd*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cd.name.."</text>"end end end;local e8=vec3(core.getConstructWorldPos())local bT=iS+iU+e8.x/jd;local bU=iT+iU*1.5/2+e8.y/je;jc=jc..'<circle cx="'..bT..'" cy="'..bU..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jc=jc.."<text x='"..bT.."' y='"..bU-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fM=jd;fN=je;local jf=e8+bb*1000000;local jg=iS+iU+jf.x/jd;local gv=iT+iU*1.5/2+jf.y/je;jc=jc..'<line x1="'..bT..'" y1="'..bU..'" x2="'..jg..'" y2="'..gv..'" stroke="purple" stroke-width="1"/>'gI[#gI+1]=jc;gI[#gI+1]='</g>'end elseif SelectedTab=="INFO"then gI=aP.DrawOdometer(gI,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gI=iL(gI)else return gI end end;local function jh(ji,jj)local jk;local jl=(jj-ji):normalize()local e9=(bf-ji):dot(jl)/jl:dot(jl)if e9<=0.then return(bf-ji):len()elseif e9>=(jj-ji):len()then return(bf-jj):len()end;local jm=ji+e9*jl;jk=(jm-bf):len()return jk end;local function jn()local jk;local jo=nil;local jp=nil;local jq=nil;for cc,jr in pairs(b[0])do if jr.hasAtmosphere then local aj=jh(planet.center,jr.center)if jo==nil or aj<jo then jp=jr;jo=aj;jq=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dv=jh(ac.center,jr.center)if dv<jo then jp=jr;jo=dv;jq=ac end end end end;local js=g0(1770)local jt=g1(330)if jo then local ju="txttick "local jv=500000;if jo<jp.radius+jv or jo<jq.radius+jv then if bn then ju="txttick red "else ju="txttick orange "end end;jk=c0(jo,2)fS=bS(js,jt,"Pipe ("..jq.name.."--"..jp.name.."): "..jk,ju.."pbright txtmid")end end;local function jw(bT,bU,jx,jy,hR)local jz={x=bT,y=bU,width=jx,height=jy,label=hR}by[hR]=jz;return jz end;local function jA(jB,jC,jx,jy,bT,bU,jD,jE,jF,jG)local jz={enableName=jB,disableName=jC,width=jx,height=jy,x=bT,y=bU,toggleVar=jD,toggleFunction=jE,drawCondition=jF,hovered=false}if jG then table.insert(fL,jz)else table.insert(fK,jz)end;return jz end;local function jH(jI)if not fP then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif jI=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif jI=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif jI=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fQ=bL(jI)showHud=false else fQ={}showHud=true end end;local function jJ()fP=not fP;if fP then fJ=fL;a2="Hold SHIFT to see Settings"fR=showHud else fJ=fK;a2="Hold SHIFT to see Control Buttons"jH()showHud=fR end end;local function jK()local function jL(cd)_G[cd]=not _G[cd]if _G[cd]then a2=cd.." set to true"else a2=cd.." set to false"end;if cd=="showHud"then fR=_G[cd]elseif cd=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local jM=50;local jN=340;local bT=500;local bU=aE/2-400;local jO=0;for cc,cd in pairs(bL("boolean"))do if type(_G[cd])=="boolean"then jA(cd,cd,jN,jM,bT,bU,function()return _G[cd]end,function()jL(cd)end,function()return true end,true)bU=bU+jM+20;if jO==9 then bT=bT+jN+20;bU=aE/2-400;jO=0 else jO=jO+1 end end end;jA("Control View","Control View",jN,jM,10,aE/2-500,function()return true end,jJ,function()return true end,true)jA("View Handling Settings",'Hide Handling Settings',jN,jM,10,aE/2-(500-jM),function()return showHandlingVariables end,function()jH("handling")end,function()return true end,true)jA("View Hud Settings",'Hide Hud Settings',jN,jM,10,aE/2-(500-jM*2),function()return showHudVariables end,function()jH("hud")end,function()return true end,true)jA("View Physics Settings",'Hide Physics Settings',jN,jM,10,aE/2-(500-jM*3),function()return showPhysicsVariables end,function()jH("physics")end,function()return true end,true)end;local function jP()local function jQ()local position=bf;local fw=planet.name..". "..#SavedLocations;if bu[1]then local cG,_=bu[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cG~=nil and cG~=""then fw=fw.." "..bu[1].getConstructName(cG)end end;return aQ.AddNewLocation(fw,position,false,true)end;local function jR()TurnBurn=not TurnBurn end;local function jS(jT)if jT==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function jU()aQ.UpdatePosition()end;local function jV()aQ.ClearCurrentPosition()end;local function jW(fh)local fw=AutopilotTargetName;if fh~=nil and type(fh)=="number"then if fh==0 then return"None"end;fw=bm[fh].name end;if fw==nil then fw=CustomTarget.name end;if fw==nil then fw="None"end;return fw end;local function jX(fh)return"Engage Autopilot: "..jW(fh)end;local function jY(fh)return"Disable Autopilot: "..jW(fh)end;local function jZ()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bF("folOn","F")else bF("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local jM=50;local jN=260;local j_=jA("Enable Brake Toggle","Disable Brake Toggle",jN,jM,aD/2-jN/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)jA("Align Prograde","Disable Prograde",jN,jM,aD/2-jN/2-50-j_.width,aE/2-jM+380,function()return ProgradeIsOn end,function()jS(1)end)jA("Align Retrograde","Disable Retrograde",jN,jM,aD/2-jN/2+j_.width+50,aE/2-jM+380,function()return RetrogradeIsOn end,jS,function()return ar==0 end)apbutton=jA(jX,jY,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function k0(k1)local fh=bx+k1;if fh>#bm then fh=fh-#bm-1 end;if fh<0 then fh=#bm+fh end;return fh end;apExtraButtons={}for i=0,10 do local button=jA(function(b_)local fh=k0(b_.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..jW(fh)end;return jX(fh)end,function(b_)local fh=k0(b_.apExtraIndex)return jY(fh)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(b_)local fh=k0(b_.apExtraIndex)return fh==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(b_)local fh=k0(b_.apExtraIndex)local k2=AutopilotTargetIndex==fh;AutopilotTargetIndex=fh;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not k2 and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bw end)button.apExtraIndex=i;apExtraButtons[i]=button end;jA("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,jQ,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)jA("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,jU,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)jA("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,jV,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)jM=60;jN=300;local bT=0;local bU=aE/2-150;jA("View Settings","View Settings",jN,jM,bT,bU,function()return true end,jJ)bU=bU+jM+20;jA("Enable Turn and Burn","Disable Turn and Burn",jN,jM,bT,bU,function()return TurnBurn end,jR)bT=10;bU=aE/2-300;jA("Horizontal Takeoff Mode","Vertical Takeoff Mode",jN,jM,bT+jN+20,bU,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bU=bU+jM+20;jA("Engage Orbiting","Cancel Orbiting",jN,jM,bT+jN+20,bU,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bU=bU+jM+20;jA("Glide Re-Entry","Cancel Glide Re-Entry",jN,jM,bT,bU,function()return Reentry end,function()al=1;jS(1)end,function()return planet.hasAtmosphere and not aq end)jA("Parachute Re-Entry","Cancel Parachute Re-Entry",jN,jM,bT+jN+20,bU,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bU=bU+jM+20;jA("Engage Follow Mode","Disable Follow Mode",jN,jM,bT,bU,function()return a0 end,jZ,function()return m()==1 end)jA("Enable Repair Arrows","Disable Repair Arrows",jN,jM,bT+jN+20,bU,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bU=bU+jM+20;if not ExternalAGG then jA("Enable AGG","Disable AGG",jN,jM,bT,bU,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;jA(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,jN*2,jM,bT,bU,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bU=bU+jM+20;jA(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,jN*2,jM,bT,bU,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local k3=g1(20)local button=jw(0,0,g0(70),k3,"INFO")button=jw(button.x+button.width,button.y,g0(80),k3,"ORBIT")button=jw(button.x+button.width,button.y,g0(70),k3,"HELP")jw(button.x+button.width,button.y,g0(70),k3,"HIDE")end;local k4={}local k5=nil;function k4.HUDPrologue(gI)bn,bo=fZ(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local k6=ay;local k7=az;local k8=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.3+0.5)..[[)]]local k9=ay;local ka=az;if g2()and not brightHud then k6=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]k7=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iA=g0;local iB=g1;gI[#gI+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],k6,k6,k6,k9,k9,k7,k7,ka,ka,k7,k6,k8,ka,k6,k6,k8,k8,k8,aD,aE,k7,k7,k7,k7,k7,k9,k7)if not k5 then k5=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iA(630),iB(0),iA(675),iB(45),iA(960),iB(55),iA(1245),iB(45),iA(1290),iB(0),iA(1000),iB(105),iA(1040),iB(59),iA(1250),iB(51),iA(1300),iB(0),iA(1920),iB(0),iA(1920),iB(20),iA(1400),iB(20),iA(1300),iB(105),iA(920),iB(105),iA(880),iB(59),iA(670),iB(51),iA(620),iB(0),iA(0),iB(0),iA(0),iB(20),iA(520),iB(20),iA(620),iB(105),iA(890),iB(59),iA(960),iB(62),iA(1030),iB(59),iA(985),iB(112),iA(1150),iB(112),iA(1100),iB(152),iA(820),iB(152),iA(780),iB(112),iA(935),iB(112),iA(890),iB(59),iA(960),iB(62),iA(1030),iB(59),iA(985),iB(112),iA(1150),iB(112),iA(1100),iB(152),iA(820),iB(152),iA(780),iB(112),iA(935),iB(112))end;gI[#gI+1]=k5;return gI end;function k4.DrawVerticalSpeed(gI,cO)gH(gI,cO)end;function k4.UpdateHud(gI)local hx=bk;local kb=bl;local gQ=kb;local h4=hx;local hP=e(unit.getThrottle())local hU=bc*3.6;local hQ=unit.getAxisCommandValue(0)local kc=g0(1770)local kd=g1(310)if AtmoSpeedAssist and bj then hQ=K;hP=K*100 end;local g4=g3()local gR="ROLL"if hP==nil then hP=0 end;if not br then if bc>5 then hx=hw(ba)kb=hy(ba)else hx=0;kb=0 end;gR="YAW"end;if bo>50000 and not aq then local ke;ke=c0(bo)gI[#gI+1]=bS(kc,kd,"PvP Boundary: "..ke,"pbright txtbig txtmid")end;gI[#gI+1]=ak;gI[#gI+1]=aB;gI[#gI+1]=g6;if fS~=""then gI[#gI+1]=fS end;if g7~=""then gI[#gI+1]=g7 end;if g8~=""then gI[#gI+1]=g8 end;gH(gI,as)if m()==0 or RemoteHud then if br then gP(gI,centerX,centerY,gQ,gR,br)else gP(gI,centerX,centerY,kb,gR,br)end;if not g2()or brightHud then if br then gP(gI,centerX,centerY,gQ,gR,br)h3(gI,h4,gQ,centerX,centerY,br,e(hy(ba)),bc)else gP(gI,centerX,centerY,kb,gR,br)h3(gI,hx,kb,centerX,centerY,br,e(kb),bc)end;ha(gI,as,br)hz(gI,ba,bc,centerX,centerY)end end;hO(gI,g4,hP,hQ)hT(gI,hU)hX(gI)iR(gI)return gI end;function k4.HUDEpilogue(gI)gI[#gI+1]="</svg>"return gI end;function k4.ExtraData(gI)local kf=g0(1240)local kg=g1(55)local kh=kg+10;local ki;local iA=g0;local iB=g1;local kj=0;local g4=g3()local kk=iB(99)local kl=iB(80)local km=iB(85)local kn=iB(31)local ko=0;local kp=0;local kq=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then kj=LastMaxBrakeInAtmo else kj=LastMaxBrake end;local kr,ks=aM.computeDistanceAndTime(bc,0,av,0,0,kj)if kr<0 then kr=0 end;kj=A(kj/(av*fI),2).."g"local kt=a:maxForceForward()ki=core.g()if ki>0.1 then kp=av*ki;kp=A(kp/(av*fI),2).."g"ko=0.5*kt/ki;ko=ko>1000000 and A(ko/1000000,2).."kT"or A(ko/1000,2).."T"end;kt=A(kt/(av*fI),2).."g"local ku=vec3(core.getWorldAcceleration()):len()/9.80665;ki=core.g()gI[#gI+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then kf=g0(1120)kg=g1(55)kh=kg+10 elseif aq then local kv=g0(770)gI[#gI+1]=bS(iA(895),kk,"ATMO","")gI[#gI+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iA(895),km,iA(-80))gI[#gI+1]=bS(iA(815),kl,f("%.1f%%",ar*100),"txtstart size20")end;gI[#gI+1]=bS(iA(1025),kk,"GRAVITY","txtstart")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(1025),km,iA(80))gI[#gI+1]=bS(iA(1105),kl,f("%.2fg",ki/9.80665),"size20")gI[#gI+1]=bS(iA(1125),kk,"ACCEL","txtstart")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(1125),km,iA(80))gI[#gI+1]=bS(iA(1205),kl,f("%.2fg",ku),"size20")gI[#gI+1]=bS(iA(695),kk,"BRK TIME","")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(695),km,iA(-80))gI[#gI+1]=bS(iA(615),kl,f("%s",c3(ks)),"txtstart size20")gI[#gI+1]=bS(iA(635),iB(45),"TRIP","")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(635),iB(31),iA(-90))if travelTime then gI[#gI+1]=bS(iA(532),iB(23),f("%s",c3(travelTime)),"txtstart size20")end;gI[#gI+1]=bS(iA(795),kk,"BRK DIST","")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(795),km,iA(-80))gI[#gI+1]=bS(iA(715),kl,f("%s",c0(kr)),"txtstart size20")gI[#gI+1]=bS(iA(1285),iB(45),"MASS","txtstart")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(1285),iB(31),iA(90))gI[#gI+1]=bS(iA(1388),iB(23),f("%s",kq),"size20")gI[#gI+1]=bS(iA(1220),kk,"THRUST","txtstart")gI[#gI+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iA(1220),km,iA(80))gI[#gI+1]=bS(iA(1300),kl,f("%s",kt),"size20")gI[#gI+1]=bS(g0(960),g1(175),g4,"pbright txtbig txtmid size20")gI[#gI+1]="</g>"end;function k4.DrawOdometer(gI,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gI end;local ki;local ko=0;local kp=0;local kj=0;local kq=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then kj=LastMaxBrakeInAtmo else kj=LastMaxBrake end;local kr,ks=aM.computeDistanceAndTime(bc,0,av,0,0,kj)kj=A(kj/(av*fI),2).." g"local kt=a:maxForceForward()ki=core.g()if ki>0.1 then kp=av*ki;kp=A(kp/(av*fI),2).." g"ko=0.5*kt/ki;ko=ko>1000000 and A(ko/1000000,2).." kTons"or A(ko/1000,2).." Tons"end;kt=A(kt/(av*fI),2).." g"if m()==0 or RemoteHud then local kw=g0(OrbitMapX+10)local kx=g1(OrbitMapY+20)local ky=g0(OrbitMapX+10+OrbitMapSize/1.25)local jy=25;gI[#gI+1]="<g class='txtstart size14 bright'>"gI[#gI+1]=bS(kw,kx,f("BrkTime: %s",c3(ks)))gI[#gI+1]=bS(ky,kx,f("Trip: %.2f km",ad))gI[#gI+1]=bS(kw,kx+jy,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gI[#gI+1]=bS(ky,kx+jy,f("BrkDist: %s",c0(kr)))gI[#gI+1]=bS(kw,kx+jy*2,"Trip Time: "..c3(ae))gI[#gI+1]=bS(ky,kx+jy*2,"Total Time: "..c3(TotalFlightTime))gI[#gI+1]=bS(kw,kx+jy*3,f("Mass: %s",kq))gI[#gI+1]=bS(ky,kx+jy*3,f("Max Brake: %s",kj))gI[#gI+1]=bS(kw,kx+jy*4,f("Max Thrust: %s",kt))if ki>0.1 then gI[#gI+1]=bS(ky,kx+jy*4,f("Max Thrust Mass: %s",ko))gI[#gI+1]=bS(kw,kx+jy*5,f("Req Thrust: %s",kp))else gI[#gI+1]=bS(ky,kx+jy*5,"Max Mass: n/a")gI[#gI+1]=bS(kw,kx+jy*6,"Req Thrust: n/a")end end;gI[#gI+1]="</g></g>"return gI end;function k4.DrawWarnings(gI)return hX(gI)end;function k4.DisplayOrbitScreen(gI)return iR(gI)end;function k4.DisplayMessage(gI,ij)if ij~="empty"then local bU=310;for kz in string.gmatch(ij,"([^\n]+)")do bU=bU+35;gI[#gI+1]=bS("50%",bU,kz,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function k4.DrawDeadZone(gI)gI[#gI+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function k4.UpdatePipe()if aq then fS=""return end;jn()end;function k4.DrawSettings(gI)if#fQ>0 then local bT=g0(640)local bU=g1(200)gI[#gI+1]=[[<g class="pbright txtvspd txtstart">]]for cc,cd in pairs(fQ)do gI[#gI+1]=bS(bT,bU,cd..": ".._G[cd])bU=bU+20;if cc%12==0 then bT=bT+g0(350)bU=g1(200)end end;gI[#gI+1]=bS(g0(640),g1(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gI[#gI+1]="</g>"end;return gI end;local kA;local kB=g0(1770)local kC=g1(350)local kD=g1(15)local kE=g0(1370)local bB,kF;local kG=0;function k4.DrawRadarInfo()local function kH()if radarPanelID~=nil and kG==0 then t(radarPanelID)radarPanelID=nil;if kA~=nil then t(kA)kA=nil end else if kG==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bu,1,"Periscope","periscope")kA=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bu,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kG=0 end end;local eA,eB,ez,eC,eD,ew=aS.GetRadarHud()local B=eC or 0;if ez>0 then if CollisionSystem then bB=B.."/"..eD.." Plotted : "..ez-eD.." Ignored"else bB="Radar Contacts: "..ez end;g6=bS(kB,kC,bB,"pbright txtbig txtmid")if#ew>0 then g6=g6 ..bS(kE,kD,"Friendlies In Range","pbright txtbig txtmid")for cc,cd in pairs(ew)do kD=kD+20;g6=g6 ..bS(kE,kD,bu[1].getConstructName(cd),"pdim txtmid")end end;if eA==nil and kA==nil then kG=1;kH()end;if eA~=nil and kA~=nil then kH()end;if radarPanelID==nil then kH()end else if eB then g6=bS(kB,kC,bv.." Radar: Jammed","pbright txtbig txtmid")else g6=bS(kB,kC,"Radar: No "..bv.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kG=0;kH()end end end;function k4.DrawTanks()if fuelX~=0 and fuelY~=0 then g7=bS(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;go(fuelX,"Atmospheric ","ATMO",aF,gm,gn)go(fuelX,"Space Fuel T","SPACE",aG,gk,gl)go(fuelX,"Rocket Fuel ","ROCKET",aH,gi,gj)end end;function k4.DrawShield()local kI=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local kJ=core.getPvPTimer()local kK=shield_1.getResistances()local kL="A: "..10+kK[1]*100 .."% / E: "..10+kK[2]*100 .."% / K:"..10+kK[3]*100 .."% / T: "..10+kK[4]*100 .."%"local bT,bU=shieldX-60,shieldY+30;local kM=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gC=e(kM*2.55)local gD=f("rgb(%d,%d,%d)",255-gC,gC,0)local bW=""g8=bS(bT,bU,"","txtmid pdim txtfuel")if kM<10 and kI~="Shield Disabled"then bW="red "end;kJ=kJ>0 and"   PvPTime: "..c3(kJ)or""g8=g8 ..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bT,bU,gD,kM*2,bT,bU,bT+2,bU+10,kM,kJ)g8=g8 ..bS(bT,bU-5,kI,bW.."txtstart pbright txtbig")g8=g8 ..bS(bT,bU+30,kL,bW.."txtstart pbright txtsmall")end;function k4.hudtick()if not planet then return end;local function kN(gI)local gF=e(r(aj/(aD/4)*255,0,255))gI[#gI+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gF,e(J+0.5)-gF,e(I+0.5)-gF)end;local function kO()for _,cd in pairs(fJ)do if cd.hovered then if not cd.drawCondition or cd.drawCondition(cd)then cd.toggleFunction(cd)end;cd.hovered=false end end;for _,cd in pairs(by)do if cd.hovered then SelectedTab=cd.label;cd.hovered=false end end end;local function kP()local function kQ(kR,kS,bT,bU,jx,jy)if kR>=bT and kR<=bT+jx and kS>=bU and kS<=bU+jy then return true else return false end end;local bT=ag+aD/2;local bU=ah+aE/2;for _,cd in pairs(fJ)do cd.hovered=kQ(bT,bU,cd.x,cd.y,cd.width,cd.height)end;for _,cd in pairs(by)do cd.hovered=kQ(bT,bU,cd.x,cd.y,cd.width,cd.height)end;if bw then local kT=false;for _,b_ in ipairs(apExtraButtons)do if b_.hovered then kT=true;break end end;if apbutton.hovered then kT=true end;bw=kT else bw=apbutton.hovered;if not bw then bx=AutopilotTargetIndex end end end;local function kU(gI)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cc,cd in pairs(by)do local bW="dim brightstroke"local kV=0.2;if SelectedTab==cc then bW="pbright dimstroke"kV=0.6 end;local kW=""if cd.hovered then kV=0.8;kW=";stroke:white"end;gI[#gI+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cd.width,cd.height,cd.x,cd.y,bW,kV,kW)gI[#gI+1]=bS(cd.x+cd.width/2,cd.y+cd.height/2+5,cd.label,"txt txtmid pdim")end end;local function kX(gI)local function kY(gI,kZ,hover,bT,bU,dY,k_,l0,l1,l2,l3,button)if type(l2)=="function"then l2=l2(button)end;if type(l3)=="function"then l3=l3(button)end;gI[#gI+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bT,bU,dY,k_)if kZ then gI[#gI+1]=f("%s'",l0)else gI[#gI+1]=l1 end;if hover then gI[#gI+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gI[#gI+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gI[#gI+1]=" rx='5'></rect>"gI[#gI+1]=f("<text x='%f' y='%f' font-size='24' fill='",bT+dY/2,bU+k_/2+5)if kZ then gI[#gI+1]="black"else gI[#gI+1]="white"end;gI[#gI+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if kZ then gI[#gI+1]=f("%s</text>",l2)else gI[#gI+1]=f("%s</text>",l3)end end;local l4=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local l5=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local l6=kY;for _,cd in pairs(fJ)do local jC=cd.disableName;local jB=cd.enableName;if type(jC)=="function"then jC=jC(cd)end;if type(jB)=="function"then jB=jB(cd)end;if not cd.drawCondition or cd.drawCondition(cd)then l6(gI,cd.toggleVar(cd),cd.hovered,cd.x,cd.y,cd.width,cd.height,l5,l4,jC,jB,cd)end end end;local l7=A(ResolutionX/2,0)local l8=A(ResolutionY/2,0)local gI={}aP.HUDPrologue(gI)if showHud then aP.UpdateHud(gI)else if AlwaysVSpd then aP.DrawVerticalSpeed(gI,as)end;aP.DisplayOrbitScreen(gI)aP.DrawWarnings(gI)end;if fP and fQ~={}then aP.DrawSettings(gI)end;if radar_1 or radar_2 then aS.assignRadar()end;if bu[1]then aP.DrawRadarInfo()end;aP.HUDEpilogue(gI)gI[#gI+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gI,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gI)end end;kU(gI)if x()==0 then if m()==1 and a1 then if not AltIsOn then kP()kX(gI)end;if not aT and not aU then local l9=table.concat(gI,"")gI={}gI[#gI+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gI[#gI+1]=l9;gI[#gI+1]="</body>"aT=true;gI[#gI+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gI,"")system.setScreen(content)elseif aU then local l9=table.concat(gI,"")gI={}gI[#gI+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gI[#gI+1]=l9;gI[#gI+1]="</body>"end;if not aT then gI[#gI+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],l7,l8,ag,ah)end else kO()end else if not a1 and m()==0 then kO()if aj>DeadZone then if DisplayDeadZone then kN(gI)end end elseif a1 and(not AltIsOn or not freeLookToggle)then kP()kX(gI)end;gI[#gI+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],l7,l8,ag,ah)end;gI[#gI+1]=[[</svg></body>]]content=table.concat(gI,"")end;function k4.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function k4.OneSecond(gI)local function la()local gy=q()local hU=bc;local lb=gy-au;if hU>1.38889 then hU=hU/1000;local lc=hU*(gy-au)TotalDistanceTravelled=TotalDistanceTravelled+lc;ad=ad+lc end;ae=ae+lb;TotalFlightTime=TotalFlightTime+lb;au=gy end;la()aP.UpdatePipe()aP.ExtraData(gI)end;function k4.ButtonSetup()jK()jP()fJ=fK end;return k4 end;local function ld()local function le(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function lf()local function lg(lh,li)return lh.name<li.name end;bm={}for cc,cd in pairs(b[0])do bm[#bm+1]={name=cd.name,index=cc}end;table.sort(bm,lg)end;local function lj(lk)for cc,cd in pairs(lk)do if cd.name and cd.name==CustomTarget.name then return cc end end;return-1 end;local function ll()bx=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local lm=bm[AutopilotTargetIndex].index;local ln=b[0][lm]if ln.center then AutopilotTargetName=ln.name;ac=aL[0][lm]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=ln;for _,cd in pairs(aL[0])do if cd.name==CustomTarget.planetname then ac=cd;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function lo(gM)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gM==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then ll()else local lm=bm[AutopilotTargetIndex].index;local ln=b[0][lm]if ln~=nil and ln.name=="Space"or iphCondition=="Custom Only"and ln.center or iphCondition=="No Moons"and string.find(ln.name,"Moon")~=nil then if gM==nil then lo()else lo(1)end else ll()end end else a2="Disengage autopilot before changing Interplanetary Helper"bF("iph","AP")end end;local function jV()local fh=-1;fh=lj(b[0])if fh>-1 then table.remove(b[0],fh)end;fh=-1;fh=lj(SavedLocations)if fh~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fh)end;lo()lf()end;local function jQ(fw,position,ht,lp)if dbHud_1 or ht then local p=le(position)local ki=p.gravity;if lp then ki=unit.getClosestPlanetInfluence()end;local lq={position=position,name=fw,planetname=p.name,gravity=ki,safe=lp}if not ht then SavedLocations[#SavedLocations+1]=lq else for cc,cd in pairs(b[0])do if cd.name and fw==cd.name then table.remove(b[0],cc)end end end;table.insert(b[0],lq)lf()ll()a2="Location saved as "..fw.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local lr={}function lr.UpdateAtlasLocationsList()lf()end;function lr.UpdateAutopilotTarget()ll()end;function lr.adjustAutopilotTargetIndex(gM)lo(gM)end;function lr.findAtlasIndex(lk)lj(lk)end;function lr.UpdatePosition(ls)local fh=lj(SavedLocations)if fh~=-1 then if ls~=nil then SavedLocations[fh].name=ls;AutopilotTargetIndex=AutopilotTargetIndex-1;lo()else local lt=SavedLocations[fh]lt.gravity=unit.getClosestPlanetInfluence()lt.position=bf;lt.safe=true end;a2=SavedLocations[fh].name.." position updated ("..SavedLocations[fh].planetname..")"else a2="Name Not Found"end end;function lr.AddNewLocation(fw,position,ht,lp)jQ(fw,position,ht,lp)end;function lr.ClearCurrentPosition()jV()end;for cc,cd in pairs(SavedLocations)do table.insert(b[0],cd)end;lf()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;lr.UpdateAutopilotTarget()return lr end;local function lu()local lv={}local function lw(e4)local lx=AutopilotEndSpeed;if not Autopilot then lx=0 end;if not aq then return aM.computeDistanceAndTime(e4,lx,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e4,lx,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function ly(e4)local lx=AutopilotEndSpeed;if not Autopilot then lx=0 end;return aM.computeDistanceAndTime(e4,lx,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local lz=false;local lA=0;local lB=0;local lC=0;local lD=q()local lE=0;local lF=0;local lG=0;local lH=0;local lI=false;local lJ=false;local lK=false;local lL=nil;local lM=0;function lv.GetAutopilotBrakeDistanceAndTime(e4)return lw(e4)end;function lv.GetAutopilotTBBrakeDistanceAndTime(e4)return ly(e4)end;local function lN(lO,lP,lQ)lP=lP:project_on_plane(lO)lQ=lQ:project_on_plane(lO)return n(lP:cross(lQ):dot(lO),lP:dot(lQ))end;local function lR()local function lS()local lT=-1;local lU=-1;if vBooster then lT=vBooster.getDistance()end;if hover then lU=hover.getDistance()end;if lT~=-1 and lU~=-1 then if lT<lU then return lT else return lU end elseif lT~=-1 then return lT elseif lU~=-1 then return lU else return-1 end end;local lV=lS()local lW=-1;if telemeter_1 then lW=telemeter_1.getDistance()end;if lV~=-1 and lW~=-1 then if lV<lW then return lV else return lW end elseif lV~=-1 then return lV else return lW end end;local function lX(planet,dr,lY)local function lZ(l_,cI)local dx=vec3(cI)if l_.id==0 then return setmetatable({latitude=dx.x,longitude=dx.y,altitude=dx.z,id=0,systemId=l_.systemId},MapPosition)end;local dy=dx-l_.center;local aj=dy:len()local cO=aj-l_.radius;local cM=0;local cN=0;if not bY(aj,0)then local dz=n(dy.y,dy.x)cN=dz>=0 and dz or 2*math.pi+dz;cM=math.pi/2-math.acos(dy.z/aj)end;return setmetatable({latitude=math.deg(cM),longitude=math.deg(cN),altitude=cO,id=l_.id,systemId=l_.systemId},MapPosition)end;local m0=lZ(planet,dr)m0="::pos{"..m0.systemId..","..m0.id..","..m0.latitude..","..m0.longitude..","..m0.altitude.."}"if lY then return m0 else system.setWaypoint(m0)return true end end;local m1=false;function lv.showWayPoint(planet,dr,lY)return lX(planet,dr,lY)end;function lv.APTick()local function m2()if bt and not BrakeLanding then local d8=bt[1]local fx,fy=bt[2],bt[3]local m3=math.min(fx,fy or fx)local m4=m3/bc;local m5=AutoTakeoff and(bc<42 or ao~=-1)local m6=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if m6 and not m5 and(a8*1.5>m3 or m4<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if m4<11 then bs=d8.name.." COLLISION "..c3(m4).." / "..c0(m3,2)else bs=d8.name.." collision "..c3(m4)end;if m4<6 then bF("alarm","AL",2)end else bs=false end end;local function m7(m8,m9,ma)local function mb(m8,da)m8=vec3(m8)da=vec3(da):normalize()local ct=m8*da;return ct.x+ct.y+ct.z end;local mc=0.001;local md=1;if not aq or not aX or ao~=-1 or bc<Q then if ma==nil then ma=DampingMultiplier end;if m9==nil then m9=mc end;m8=vec3(m8):normalize()local me=vec3()-m8;local mf=-mb(me,core.getConstructWorldOrientationRight())*md;local mg=-mb(me,core.getConstructWorldOrientationUp())*md;if lB==0 then lB=mf/2 end;if lC==0 then lC=mg/2 end;if d(mf)<0.1 then V=V-mf*2 else V=V-(mf+(mf-lB)*ma)end;if d(mg)<0.1 then U=U+mg*2 else U=U+mg+(mg-lC)*ma end;lB=mf;lC=mg;if d(mf)<m9 and d(mg)<m9 then return true end;return false elseif aX and ao==-1 then m8=bb;if ma==nil then ma=DampingMultiplier end;if m9==nil then m9=mc end;m8=vec3(m8):normalize()local me=b8-m8;local mf=-mb(me,core.getConstructWorldOrientationRight())*md;local mg=-mb(me,core.getConstructWorldOrientationUp())*md;if lB==0 then lB=mf/2 end;if lC==0 then lC=mg/2 end;if d(mf)<0.1 then V=V-mf*5 else V=V-(mf+(mf-lB)*ma)end;if d(mg)<0.1 then U=U+mg*5 else U=U+mg+(mg-lC)*ma end;lB=mf;lC=mg;if d(mf)<m9 and d(mg)<m9 then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=lR()E=q()lD=E;if CollisionSystem then m2()end;if antigrav then bh=antigrav.getState()==1 end;local mh=1;local mi=1;local mj=E-lD;local mk=-math.deg(lN(b7,bb,b8))local ml=math.deg(lN(b9,bb,b8))local gM=bd*-1;aX=aq and mk<-YawStallAngle or mk>YawStallAngle or ml<-PitchStallAngle or ml>PitchStallAngle;local mm=system.getMouseDeltaX()local mn=system.getMouseDeltaY()if InvertMouse and not a1 then mn=-mn end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local ki=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+mm,-aD/2,aD/2)ah=r(ah+mn,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+mm,-aD/2,aD/2)ah=r(ah+mn,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(mn,-100,100)+0.5)*2*mh;V=(-utils.smoothstep(mm,-100,100)+0.5)*2*mi end end end end;local mo=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not mo then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not mo and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=mo;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not lz then BrakeIsOn=true;lz=true elseif not AtmoSpeedAssist and lz then if bc<aZ/3.6 then BrakeIsOn=false;lz=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local mp=false;if CustomTarget and al~=1 then mp=m7(CustomTarget.position-bf,0.1)else mp=m7(vec3(bb),0.01)end;aV=true;if mp then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then m7(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then m7(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local mq=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then mq=antigrav.getBaseAltitude()end;if as<mq-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=mq then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bF("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bF("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;lI=false;lG=nil;lH=nil;if lL==nil then lL=planet end;b2=mq;lK=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local mr=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(mr)local ms=r(vTpitchPID:get(),-1,1)U=ms end end;if IntoOrbit then local me;local mt=false;local mu=c0(b2)if lL==nil then lL=planet;if VectorToTarget then lL=ac end end;if not lK then b2=e(lL.radius+lL.surfaceMaxAltitude+LowOrbitHeight)if lL.hasAtmosphere then b2=e(lL.radius+lL.noAtmosphericDensityAltitude+LowOrbitHeight)end;lK=true end;if b1.VectorToTarget and CustomTarget then me=CustomTarget.position-bf end;local mv,mw=aO(lL):escapeAndOrbitalSpeed((bf-lL.center):len()-lL.radius)local mx=bl;if not lI then local my=false;local mz=false;aR.cmdThrottle(0)lH=0;b0="Aligning to orbital path - OrbitHeight: "..mu;if b1.VectorToTarget then m7(me:normalize():project_on_plane(bd))mt=b8:dot(me:project_on_plane(b7):normalize())>0.95 else m7(bb)mt=mk<0.5;if bc<150 then mt=true end end;U=0;lG=0;if bk<=lG+1 and bk>=lG-1 then my=true else my=false end;if mx<=lH+1 and mx>=lH-1 then mz=true else mz=false end;if my and mz and mt then lG=nil;lH=nil;lI=true end else if b1.VectorToTarget then m7(me:normalize():project_on_plane(bd))elseif bc>150 then m7(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and me:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=lL.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<lL.noAtmosphericDensityAltitude then b3=false end elseif b3 or me:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bF("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)lG=0;if not b1.VectorToTarget then a2="Orbit complete"bF("orCom","OB")aR.ToggleIntoOrbit()end else lM=lM+1;if lM>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..mu;lJ=true;aR.cmdCruise(mw*3.6+1)local mA=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(mA-be*r(utils.smoothstep(2000-mA,-2000,2000)^6*10,1,10))lG=r(VSpdPID:get(),-60,60)end end else local mB=2.75;local mC=d(A(mv*mB))local mD=mC%50;if mD>0 then mC=mC-mD+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..mu;lG=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..mu;mC=mC*0.75;lG=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..mu;mC=mC*0.75;if be<0 or lJ then lG=utils.map(as,b2*1.5,b2*1.01,-30,0)else lG=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..mu;lG=-65;local mE=utils.map(be,-150,-400,1,0.55)mC=mC*mE end;aR.cmdCruise(e(mC))end end;if lG~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local mF=lG-bk;OrbitPitchPID:inject(mF)local mG=r(OrbitPitchPID:get(),-0.5,0.5)U=mG end end;if Autopilot and ar==0 and not al then local function mH(bB,orbit)system.print(bB)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bB;bF("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;lK=true end;aR.ToggleIntoOrbit()end end;local mI,mJ=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local mK=(CustomTarget.position-ac.center):normalize()local mL=mK:project_on_plane((ac.center-bf):normalize()):normalize()local mM=ac.center+mL*(ac.radius+AutopilotTargetOrbit)local mN=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-mM):len()<(bf-mN):len()then mI=mM else mI=mN;AutopilotEndSpeed=0 end;AutopilotTargetCoords=mI;aR.showWayPoint(ac,AutopilotTargetCoords)mJ=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;mJ=true;AutopilotRealigned=true;TargetSet=true;mI=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=mI end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local mK=(bf+bb*100000-ac.center):normalize()local mL=mK:project_on_plane((ac.center-bf):normalize()):normalize()if mL:len()<1 then mK=(bf+b8*100000-ac.center):normalize()mL=mK:project_on_plane((ac.center-bf):normalize()):normalize()end;mI=ac.center+mL*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=mI;TargetSet=true;mJ=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(mI)-bf):len()local iu,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(d8)if d8.noAtmosphericDensityAltitude>0 then return d8.radius+d8.noAtmosphericDensityAltitude else return d8.radius+d8.surfaceMaxAltitude*1.5 end end)local iv=dp;if dq~=nil and dp~=nil then iv=math.min(dq,dp)end;if iv~=nil and iv<AutopilotDistance and iu.name==ac.name then AutopilotDistance=iv end;local mp=true;local mO=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local ij=c0(mO)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ij..'"}')local a8,a9;if not TurnBurn then a8,a9=lw(bc)else a8,a9=ly(bc)end;if bc>50 and AutopilotAccelerating then local me=vec3(mI)-bf;local mP=r(math.deg(lN(b7,bb:normalize(),me:normalize()))*bc/500,-90,90)local mQ=r(math.deg(lN(b9,bb:normalize(),me:normalize()))*bc/500,-90,90)if d(mP)<20 and d(mQ)<20 then mP=mP*2;mQ=mQ*2 end;if d(mP)<2 and d(mQ)<2 then mP=mP*2;mQ=mQ*2 end;local mk=-math.deg(lN(b7,b8,bb:normalize()))local ml=-math.deg(lN(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(mQ-ml)local mR=r(apPitchPID:get(),-1,1)U=U+mR;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(mP-mk)local mS=r(apYawPID:get(),-1,1)V=V+mS;mJ=true;if d(mP)>2 or d(mQ)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bF("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bF("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then m7((mI-bf):normalize())end;if mO<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(mO)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iu,iv=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iu~=nil and ac.name~=iu.name and iv<AutopilotDistance then a2="Collision with "..iu.name.." in "..c0(iv).."\nClear LOS to continue."ai=5;m1=true else m1=false;a2=""end end end;if not m1 then if not AutopilotCruising and not AutopilotBraking and not mJ then mp=m7((mI-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then mp=m7(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local mT=unit.getThrottle()if AtmoSpeedAssist then mT=K end;local mU=99999;local ku=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local mV=r(bb:dot((mI-bf):normalize()),0,bc)if mV>0 or ku>0 then mU=aM.computeTravelTime(mV,ku,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or mT==0 and P or warmup/4>mU then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bF("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local mW=AutopilotDistance;if mW<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<lA and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lA=bo else lA=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bF("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,mw=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local me;if CustomTarget then me=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then mH("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=mw and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then mH("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bF("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=mw then if CustomTarget then if bb:normalize():dot(me:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bF("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else mH("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else mH("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then mH("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local mW=AutopilotDistance;if mW<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<lA and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lA=bo else lA=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bF("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local mT=unit.getThrottle()if AtmoSpeedAssist then mT=K end;if mT>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bF("apAcc","AP")end;AutopilotCruising=false end else if mp then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif mp and not m1 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bF("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bF("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local mQ=0;local e8=bf+vec3(unit.getMasterPlayerRelativePosition())local mX=e8-bf;local mY=vec3(mX):project_on(b8):len()local mZ=vec3(mX):project_on(b9):len()local aj=y(mY*mY+mZ*mZ)m7(mX:normalize())local m_=40;local n0=aj<m_;local n1=100;local n2=r((aj-m_)/2,10,n1)U=0;local mp=d(V)<0.1;if mp and bc<n2 and not n0 then BrakeIsOn=false;mQ=-20 else BrakeIsOn=true;mQ=0 end;local n3=0;if d(mQ-bk)>n3 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(mQ-bk)local mR=pitchPID:get()U=mR end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local n4=LastMaxBrakeInAtmo;if n4 then n4=n4*r(bc/100,0.1,1)*ar else n4=LastMaxBrake end;if ar<0.01 then n4=LastMaxBrake end;local n5=b8:project_on_plane(bd):normalize():dot(bb)local n6=vec3(core.getWorldAirFrictionAcceleration())local n7=n6:len()*av;if n5>100 then a8,a9=aM.computeDistanceAndTime(n5,100,av,0,0,n4)local n8,n9=aM.computeDistanceAndTime(100,0,av,0,0,n4*0.55)a8=a8+n8 else a8,a9=aM.computeDistanceAndTime(n5,0,av,0,0,n4*0.55)end;local mA=HoldAltitude-as-be;local na=200+bc;if Reentry or al then minMax=2000+bc end;local nb=1;if AutoTakeoff then nb=r(bc/100,0.1,1)end;local mQ=(utils.smoothstep(mA,-na,na)-0.5)*2*MaxPitch*nb;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then mQ=(utils.smoothstep(mA,-na*r(20-19*ar*10,1,20),na*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nb end;if not AltitudeHold then mQ=0 end;if LockPitch~=nil then if br and not IntoOrbit then mQ=LockPitch else LockPitch=nil end end;aV=true;local nc=U;if Reentry then local nd=e(aZ)local ne,nf=aM.computeDistanceAndTime(bc,nd/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)ne=ne==-1 and 5000 or ne;local ng=as-(planet.noAtmosphericDensityAltitude+ne)local nh=as>planet.noAtmosphericDensityAltitude+ne*1.35;if nh then mQ=ReEntryPitch;if bc<=nd/3.6 and bc>nd/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not nh and not aq then aR.cmdCruise(nd,true)end;if bj then if bc>nd/3.6 and not nh then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then mQ=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;mQ=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and nh then aV=true elseif not nh then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=nd)then aR.cmdCruise(nd)end;if bc<nd/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then m7(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local me;if bp then if type(bp)=="table"then me=bp elseif bp<3 and bp>0 then me=-bd:cross(bb)*5000 elseif bp>=3 then me=bd:cross(bb)*5000 elseif bp<0 then me=bb*25000 end elseif CustomTarget~=nil then me=CustomTarget.position-bf else me=ac.center-bf end;local mP=math.deg(lN(bd:normalize(),bb,me))*2;local ni=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local nj=1000+bc;local nk=(utils.smoothstep(mA-be*10,-nj,nj)-0.5)*2*MaxPitch;local nl=r(90-nk,0,180)aY=r(mP*2,-nl,nl)local nm=mP;mP=r(r(mP,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(ni)+4*(bk-mQ)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local nn=1;if aY~=0 then nn=d(ni/aY)end;nn=(90-r(d(aY-bl),0,90))/90;local no=mQ;if d(bl)>90 then no=-no end;mQ=nn*r(r(no*math.cos(ni),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(nm)*math.sin(ni),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;mP=r(mP,-YawStallAngle*0.80,YawStallAngle*0.80)end;local np=mk-mP;if bp and d(np)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bF("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(np)local mS=r(yawPID:get(),-1,1)V=V+mS elseif aq and ao>-1 or bc<minRollVelocity then m7(me)elseif aX and ar>0.01 then if(mk<-YawStallAngle or mk>YawStallAngle)and ar>0.01 then m7(bb)end;if(ml<-PitchStallAngle or ml>PitchStallAngle)and ar>0.01 then mQ=r(bk-ml,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local mq=planet:getAltitude(CustomTarget.position)local ng=me:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and ng<=a8 and(bb:project_on_plane(bd):normalize():dot(me:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(n5<0.1 or ng<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<ng)then if not bh then bF("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=ng end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local me=CustomTarget.position-bf;local mq=planet:getAltitude(CustomTarget.position)local ng=y(me:len()^2-(as-mq)^2)local n4=LastMaxBrakeInAtmo;if n4 then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,n4/2)StrongBrakes=true;if ng<=a8+bc*mj/2 and bb:project_on_plane(bd):normalize():dot(me:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=ng end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;lK=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;lI=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then m7(bb)mQ=r(bk-ml,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=nc;local lW=-1;if BrakeLanding then mQ=0;local nq=false;local nr=30;if aN~=nil and aN>0 then local ns=r(ar,0.4,2)local n4=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*ns;local nt=aN*ns+n4-ki;local nu=n4/2-ki;local nw=bc-y(d(nu/2)*20/(0.5*av))*utils.sign(nu)if nw<0 then nw=0 end;local nx;if bc>100 then local ny,_=aM.computeDistanceAndTime(bc,100,av,0,0,n4)local nz,_=aM.computeDistanceAndTime(100,0,av,0,0,y(n4))nx=ny+nz else nx=aM.computeDistanceAndTime(bc,0,av,0,0,y(n4))end;if nx<20 then BrakeIsOn=false else local nA=0;if nw>100 then local nB,_=aM.computeDistanceAndTime(nw,100,av,0,0,nt)local nC,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*ns+y(n4)-ki)nA=nB+nC else nA,_=aM.computeDistanceAndTime(nw,0,av,0,0,aN*ns+y(n4)-ki)end;nA=(nA+15+bc*mj)*1.1;local nD=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if nD then local mq=planet:getAltitude(CustomTarget.position)local nE=as-mq-100;local me=CustomTarget.position-bf;local nF=y(me:len()^2-(as-mq)^2)if nF>100 then nD=false elseif nE<=nA or nA==-1 then BrakeIsOn=true;nq=true else BrakeIsOn=false;nq=true end end;if not nD and CalculateBrakeLandingSpeed then if nA>=nr then BrakeIsOn=true else BrakeIsOn=false end;nq=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;lW=ao;if lW>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bF("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gM)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not nq then BrakeIsOn=true elseif not nq then BrakeIsOn=false end end;if AutoTakeoff or am then local iu,dq,dp;if AutopilotTargetCoords~=nil then iu,dq,dp=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(d8)return d8.radius+d8.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(mQ)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iu==nil or iu.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local nG=ao>-1;local nH=bk;if(VectorToTarget or am or bp)and not nG and bc>minRollVelocity and ar>0.01 then local ni=math.rad(d(bl))nH=bk*d(math.cos(ni))+ml*math.sin(ni)end;local nI=r(mQ-nH,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then nI=r(mQ-nH,-85,MaxPitch)elseif ar<0.01 then nI=r(mQ-nH,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or nG or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(nI)local mR=pitchPID:get()U=U+mR end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function lv.ToggleIntoOrbit()b3=false;lG=nil;lH=nil;lM=0;if ar==0 then if IntoOrbit then bF("orOff","AP")IntoOrbit=false;lI=false;lL=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;lK=false elseif br then bF("orOn","AP")IntoOrbit=true;aV=true;if lL==nil then lL=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;lI=false;lL=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;lK=false end end;function lv.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function lv.checkLOS(m8)local iu,dp,dq=aL:getPlanetarySystem(0):castIntersections(bf,m8,function(d8)if d8.noAtmosphericDensityAltitude>0 then return d8.radius+d8.noAtmosphericDensityAltitude else return d8.radius+d8.surfaceMaxAltitude*1.5 end end)local iv=dp;if dq~=nil and dp~=nil then iv=math.min(dq,dp)end;if iv~=nil then return iu,iv else return nil,nil end end;function lv.ToggleAutopilot()local function nJ(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-lF<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bF("orH","OH")end;lF=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else lF=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bF("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bF("vtt","AP")nJ(SpaceTarget)end else bF("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;lK=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;lI=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bF("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;lI=false;aR.ToggleIntoOrbit()else bF("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bF("apP","AP")am=true;aR.ToggleAltitudeHold()end else bF("apOff","AP")aR.ResetAutopilots(1)end end;function lv.cmdThrottle(cy,nK)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not nK then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cy)K=r(A(cy*100,0)/100,-1,1)bi=nil end;function lv.cmdCruise(cy,nK)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not nK then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cy)bi=cy end;function lv.ToggleLockPitch()if LockPitch==nil then bF("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bF("lkPOff","LP")LockPitch=nil end end;function lv.ToggleAltitudeHold()if E-lE<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bF("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;lK=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;lI=true end end;lE=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else lE=E end;if br and ar==0 then b2=as;lK=true;lI=true;aR.ToggleIntoOrbit()if IntoOrbit then lE=E else lE=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bF("lfs","LS")AutoTakeoff=true;if lE>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bF("altOn","AH")AutoTakeoff=false;if lE>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bF("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;lE=0 end end;function lv.ResetAutopilots(lv)if lv then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function lv.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bF("bkOn","B",1)aR.ResetAutopilots()else bF("bkOff","B",1)end end;function lv.BeginReentry()if Reentry then a2="Re-Entry cancelled"bF("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bF("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bV=c0(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bV;bF("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function lv.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bF("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bF("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=lR()return lv end;function script.onStart()local nL=false;local function nM()local function nN(nO)local nP=dbHud_1.hasKey;for cc,cd in pairs(nO)do if nP(cd)then local ct=g(dbHud_1.getStringValue(cd))if ct~=nil then _G[cd]=ct;nL=true end end end end;if dbHud_1 then if not useTheseSettings then nN(bL())coroutine.yield()nN(c)else nN(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;nL=false end;coroutine.yield()if nL then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function nQ()local function nR(nS,nT)if nS>nT then nT=nS end;local nU,nV=0,0;if ContainerOptimization>0 then nU=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then nV=FuelTankOptimization*0.05 end;nT=nT*(1-(nU+nV))return nT end;local nW=core.getElementNameById;local nX=fuelX~=0 and fuelY~=0;for cc in pairs(at)do local type=core.getElementTypeById(at[cc])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cc])),'^.*vertical.*$')and core.getElementForwardById(at[cc])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cc])),'^.*vertical.*$')then local nY=core.getElementForwardById(at[cc])if nY[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local nZ=j(at[cc])if nZ>10000 then G=110 elseif nZ>1000 then G=55 elseif nZ>150 then G=27 end end;aI=aI+j(at[cc])if nX and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local nZ=j(at[cc])local kq=l(at[cc])local nS=0;local gy=q()if type=="Atmospheric Fuel Tank"then local nT=400;local n_=35.03;if nZ>10000 then nT=51200;n_=5480 elseif nZ>1300 then nT=6400;n_=988.67 elseif nZ>150 then nT=1600;n_=182.67 end;nS=kq-n_;if fuelTankHandlingAtmo>0 then nT=nT+nT*fuelTankHandlingAtmo*0.2 end;nT=nR(nS,nT)aF[#aF+1]={at[cc],nW(at[cc]),nT,n_,nS,gy}end;if type=="Rocket Fuel Tank"then local nT=320;local n_=173.42;if nZ>65000 then nT=40000;n_=25740 elseif nZ>6000 then nT=5120;n_=4720 elseif nZ>700 then nT=640;n_=886.72 end;nS=kq-n_;if fuelTankHandlingRocket>0 then nT=nT+nT*fuelTankHandlingRocket*0.1 end;nT=nR(nS,nT)aH[#aH+1]={at[cc],nW(at[cc]),nT,n_,nS,gy}end;if type=="Space Fuel Tank"then local nT=600;local n_=35.03;if nZ>10000 then nT=76800;n_=5480 elseif nZ>1300 then nT=9600;n_=988.67 elseif nZ>150 then nT=2400;n_=182.67 end;nS=kq-n_;if fuelTankHandlingSpace>0 then nT=nT+nT*fuelTankHandlingSpace*0.2 end;nT=nR(nS,nT)aG[#aG+1]={at[cc],nW(at[cc]),nT,n_,nS,gy}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function o0()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cd in pairs(door)do cd.toggle()end end;if switch then for _,cd in pairs(switch)do cd.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cd in pairs(forcefield)do cd.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function o1()local o2={}local function o3()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local o4={[1]=4480,[6]=4480,[7]=6270}for o5,o6 in pairs(b)do b[o5][0]=o3()b[o5][0].systemId=o5;o2[o5]={}for o7,planet in pairs(b[o5])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=o4[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=o5;planet.bodyId=planet.id;o2[o5][o7]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end end end;aK=ce()aL=aK(o2)aM=dD()aO=e6()aQ=ld()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})nM()coroutine.yield()nQ()coroutine.yield()aR=lu()o0()coroutine.yield()o1()aS=eu()aP=fH()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bu[1]=nil;if radar_1 then bu[1]=radar_1;aS.pickType()end;bF("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cd in pairs(door)do cd.toggle()end end;if switch then for _,cd in pairs(switch)do cd.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cd in pairs(forcefield)do cd.toggle()end end;c8()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bF("stop","SU")end;function script.onTick(o8)local o9=nil;if o8=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bF("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif o8=="tenthSecond"then local function oa()local ob=system.createData;local oc=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=oc(panelInterplanetary,"value")interplanetaryHeaderText=ob('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=oc(panelInterplanetary,"value")widgetDistanceText=ob('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=oc(panelInterplanetary,"value")widgetTravelTimeText=ob('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=oc(panelInterplanetary,"value")widgetMaxMassText=ob('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=oc(panelInterplanetary,"value")widgetTargetOrbitText=ob('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=oc(panelInterplanetary,"value")widgetCurBrakeDistanceText=ob('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=oc(panelInterplanetary,"value")widgetCurBrakeTimeText=ob('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=oc(panelInterplanetary,"value")widgetMaxBrakeDistanceText=ob('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=oc(panelInterplanetary,"value")widgetMaxBrakeTimeText=ob('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=oc(panelInterplanetary,"value")widgetTrajectoryAltitudeText=ob('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function od()t(panelInterplanetary)panelInterplanetary=nil end;local function oe()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e4=bc;local mT=unit.getThrottle()/100;if AtmoSpeedAssist then mT=K end;local of,og=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*mT,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oh;if not TurnBurn and e4>0 then _,oh=aR.GetAutopilotBrakeDistanceAndTime(e4)else _,oh=aR.GetAutopilotTBBrakeDistanceAndTime(e4)end;local oi=0;local oj=0;if AutopilotCruising or not Autopilot and e4>5 then oj=aM.computeTravelTime(e4,0,AutopilotDistance)elseif a8+of<AutopilotDistance then oi=AutopilotDistance-(a8+of)oj=aM.computeTravelTime(8333.0556,0,oi)else local ok=(AutopilotDistance-a8)/of;of=AutopilotDistance-a8;og=og*ok end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return oj elseif AutopilotBraking then return oh elseif AutopilotCruising then return oj+oh else return og+a9+oj end end;local function ol(ki,om)if ki==nil then ki=core.g()end;ki=A(ki,5)if om~=nil and om or(o9==nil or o9~=ki)then local e4=ba:len()local on=g(unit.getData()).maxBrake;if on~=nil and on>0 and aq then on=on/r(e4/100,0.1,1)on=on/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+on)/2 else LastMaxBrakeInAtmo=on end end end;if on~=nil and on>0 then LastMaxBrake=on end;o9=ki end end;ol(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oa()end;if AutopilotTargetName~=nil then local oo=CustomTarget~=nil;local op=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()op=op>1000000 and A(op/1000000,2).." kTons"or A(op/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=oe()if oo and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ij=c0(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ij..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c3(travelTime)..'", "unit":""}')ij=c0(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ij..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c3(a9)..'", "unit":""}')ij=c0(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ij..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c3(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",op)..'", "unit":""}')ij=c0(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ij..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else od()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif o8=="oneSecond"then local function oq(gI)local os=0;aB=""local ot=aI;local ou=0;local ov=0;local ow=0;local gC=0;local gD=""local ox=core.getElementHitPointsById;for cc in pairs(at)do local nZ=0;local oy=0;oy=j(at[cc])nZ=ox(at[cc])ou=ou+nZ;if nZ<oy then if nZ==0 then ow=ow+1 else ov=ov+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cc]))local bT=position.x;local bU=position.y;local eZ=position.z;table.insert(aA,core.spawnArrowSticker(bT,bU,eZ+1,"down"))table.insert(aA,core.spawnArrowSticker(bT,bU,eZ+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bT+1,bU,eZ,"north"))table.insert(aA,core.spawnArrowSticker(bT+1,bU,eZ,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bT-1,bU,eZ,"south"))table.insert(aA,core.spawnArrowSticker(bT-1,bU,eZ,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bT,bU-1,eZ,"east"))table.insert(aA,core.spawnArrowSticker(bT,bU-1,eZ,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bT,bU+1,eZ,"west"))table.insert(aA,core.spawnArrowSticker(bT,bU+1,eZ,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cc])end elseif aJ and#aA>0 and aA[11]==at[cc]then for gx in pairs(aA)do core.deleteSticker(aA[gx])end;aA={}end end;os=e(ou/ot*100)if os<100 then gI[#gI+1]=bS(0,0,"","pbright txt")gC=e(os*2.55)gD=f("rgb(%d,%d,%d)",255-gC,gC,0)if os<100 then gI[#gI+1]=bS("50%",1035,"Elemental Integrity: "..os.."%","txtbig txtmid","fill:"..gD)if ow>0 then gI[#gI+1]=bS("50%",1055,"Disabled Modules: "..ow.." Damaged Modules: "..ov,"txtbig txtmid","fill:"..gD)elseif ov>0 then gI[#gI+1]=bS("50%",1055,"Damaged Modules: "..ov,"txtbig txtmid","fill:"..gD)end end end end;local function oz()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bz=core.getPlayersOnBoard()bA=core.getDockedConstructs()oz()local gI={}aP.OneSecond(gI)if ShouldCheckDamage then oq(gI)end;ak=table.concat(gI,"")collectgarbage("collect")elseif o8=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local ct=g(dbHud_1.getStringValue("SavedLocations"))if ct~=nil then _G["SavedLocations"]=ct;local fh=-1;local lq;for cc,cd in pairs(SavedLocations)do if cd.name and cd.name=="SatNav Location"then fh=cc;break end end;if fh~=-1 then lq=SavedLocations[fh]fh=-1;for cc,cd in pairs(b[0])do if cd.name and cd.name=="SatNav Location"then fh=cc;break end end;if fh>-1 then b[0][fh]=lq end;aQ.UpdateAtlasLocationsList()a2=lq.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif o8=="msgTick"then local gI={}aP.DisplayMessage(gI,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif o8=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif o8=="hudTick"then aP.hudtick()elseif o8=="apTick"then aR.APTick()elseif o8=="radarTick"then aS.UpdateRadar()elseif o8=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oA(oB,n2)local oC=vec3()local oD=vec3()if oB==axisCommandId.longitudinal then oC=vec3(core.getConstructOrientationForward())oD=b8 elseif oB==axisCommandId.vertical then oC=vec3(core.getConstructOrientationUp())oD=b7 elseif oB==axisCommandId.lateral then oC=vec3(core.getConstructOrientationRight())oD=b9 else return vec3()end;local oE=vec3(core.getWorldGravity())local oF=oE:dot(oD)local oG=vec3(core.getWorldAirFrictionAcceleration())local oH=oG:dot(oD)local oI=ba:dot(oC)local oJ=n2*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(oJ-oI)local oK=targetSpeedPID2:get()local oL=(oK-oH-oF)*oD;return oL end;local function oM(oB,n2)local oC=vec3()local oD=vec3()if oB==axisCommandId.longitudinal then oC=vec3(core.getConstructOrientationForward())oD=b8 elseif oB==axisCommandId.vertical then oC=vec3(core.getConstructOrientationUp())oD=b7 elseif oB==axisCommandId.lateral then oC=vec3(core.getConstructOrientationRight())oD=b9 else return vec3()end;local oE=vec3(core.getWorldGravity())local oF=oE:dot(oD)local oG=vec3(core.getWorldAirFrictionAcceleration())local oH=oG:dot(oD)local oI=ba:dot(oC)local oJ=n2*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(oJ-oI)local oK=targetSpeedPID:get()local oL=(oK-oH-oF)*oD;return oL end;local function oN(oO,gL,li)local oP=oO:cross(li):normalize_inplace()local hx=math.acos(r(oP:dot(-gL),-1,1))*constants.rad2deg;if oP:cross(-gL):dot(li)<0 then hx=-hx end;return hx end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local oQ=r(T+U+system.getControlDeviceForwardInput(),-1,1)local oR=r(W+Z+system.getControlDeviceYawInput(),-1,1)local oS=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local oT=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local oU=bl/180*math.pi;local oV=math.cos(oU)local oW=math.sin(oU)bk=oN(bd,b8,b9*oV+b7*oW)local oX=bb:normalize()local oY=d(bl)local oZ=utils.sign(bl)local o_=vec3(core.getWorldAngularVelocity())local p0=oQ*pitchSpeedFactor*b9+oR*rollSpeedFactor*b8+oS*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local p1=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and p1>0 or ar>0.0 and p1<autoRollRollThreshold and autoRollPreference)and oR==0 and d(bk)<85 then local p2=aY;local p3=autoRollFactor;if ar==0 then p3=p3/4;aY=0;p2=0 end;if rollPID==nil then rollPID=pid.new(p3*0.01,0,p3*0.1)end;rollPID:inject(p2-bl)local p4=rollPID:get()p0=p0+p4*b8 end end;local p5=1;local p6=0;local p7=1;local p8=system.getMouseWheel()if p8>0 then bC()elseif p8<0 then bC(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local p9=throttlePID:get()N=r(p9,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pa=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pa end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pb=''local pc=vec3()local pd=oA(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pd,p6)local pe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pe=pe..ExtraLongitudeTags end;local pf=s:getAxisCommandType(axisCommandId.longitudinal)local pg=s:composeAxisAccelerationFromThrottle(pe,axisCommandId.longitudinal)local ph=oM(axisCommandId.lateral,LeftAmount*1000)pb=pb..' , '.."lateral airfoil , lateral ground "pc=pc+ph;if pc:len()>constants.epsilon then a:setEngineForceCommand(pb,pc,p6,'','','',p7)end;a:setEngineForceCommand(pe,pg,p5)local pi='thrust analog vertical fueled 'local pj='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pj=pj..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pi=pi..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pi,pd,p5)else a:setEngineForceCommand(pi,vec3(),p5)end;if LeftAmount~=0 then a:setEngineForceCommand(pj,ph,p5)else a:setEngineForceCommand(pj,vec3(),p5)end;if oT==0 then oT=L end;local pk=-oT*(brakeSpeedFactor*bb+brakeFlatFactor*oX)a:setEngineForceCommand('brake',pk)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local n2=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-n2/3.6)local pa=r(brakePID:get(),0,1)oT=r(oT+pa,0,1)end;local pk=-oT*(brakeSpeedFactor*bb+brakeFlatFactor*oX)a:setEngineForceCommand('brake',pk)local pb=''local pc=vec3()local pl=false;local pe='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pe=pe..ExtraLongitudeTags end;local pf=s:getAxisCommandType(axisCommandId.longitudinal)if pf==axisCommandType.byThrottle then local pg=s:composeAxisAccelerationFromThrottle(pe,axisCommandId.longitudinal)a:setEngineForceCommand(pe,pg,p5)elseif pf==axisCommandType.byTargetSpeed then local pg=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pb=pb..' , '..pe;pc=pc+pg;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pl=true end end;local pj='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pj=pj..ExtraLateralTags end;local pm=s:getAxisCommandType(axisCommandId.lateral)if pm==axisCommandType.byThrottle then local pn=s:composeAxisAccelerationFromThrottle(pj,axisCommandId.lateral)a:setEngineForceCommand(pj,pn,p5)elseif pm==axisCommandType.byTargetSpeed then local ph=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pb=pb..' , '..pj;pc=pc+ph end;local pi='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pi=pi..ExtraVerticalTags end;local po=s:getAxisCommandType(axisCommandId.vertical)if po==axisCommandType.byThrottle then local pd=s:composeAxisAccelerationFromThrottle(pi,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pi,pd,p5,'airfoil','ground','',p7)else a:setEngineForceCommand(pi,vec3(),p5)a:setEngineForceCommand('airfoil vertical',pd,p5,'airfoil','','',p7)a:setEngineForceCommand('ground vertical',pd,p5,'ground','','',p7)end elseif po==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),p5)end;local pp=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pb=pb..' , '..pi;pc=pc+pp end;if pc:len()>constants.epsilon then if Y~=0 or pl or d(oX:dot(b8))<0.5 then pb=pb..', brake'end;a:setEngineForceCommand(pb,pc,p6,'','','',p7)end end;local pq=torqueFactor*(p0-o_)local pr=vec3(core.getWorldAirFrictionAngularAcceleration())pq=pq-pr;a:setEngineTorqueCommand('torque',pq,p5,'airfoil','','',p7)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e4=ba:len()local ps=0.15;if not bj then local pt=s:getTargetSpeed(axisCommandId.longitudinal)if e4*3.6>pt*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4*3.6<pt*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local mT=unit.getThrottle()if AtmoSpeedAssist then mT=K*100 end;local n2=mT/100;if k==0 then n2=n2*MaxGameVelocity;if e4>=n2*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<n2*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nd=e(aZ)n2=n2*nd/3.6;if e4>=n2*(1-ps)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e4<n2*(1-ps)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fE=coroutine.status(beginSetup)if fE=="suspended"then local cy,fF=coroutine.resume(beginSetup)if fF then system.print("ERROR STARTUP: "..fF)end elseif fE=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pu)local function pv(bD)local D=1;local function pw(px,bD)local py={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local pz=px;for _,cd in ipairs(py)do if bD and pz>cd then px=cd elseif px<cd and not bD then px=cd;break end end;return px end;if bD then D=-1 end;if not ExternalAGG and bh then if a1 and bD then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=pw(b2,bD)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=pw(HoldAltitude,bD)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function pA(pB)if not aq then a2="Flight Assist in Atmo only"return end;local cj=type(pB)if bp==nil then if cj=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bF("180On","BR")elseif pB==1 then bF("bnkLft","BR")else bF("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if cj~="table"then pB=pB+1 end end;bp=pB else bF("180Off","BR")bp=nil end end;if pu=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bF("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bF("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bF("grOut","LG",1)a.control.extendLandingGears()end else if S then bF("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pu=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pu=="forward"then T=T-1 elseif pu=="backward"then if AltIsOn then pA(-bb*5000)else T=T+1 end elseif pu=="left"then if AltIsOn then pA(1)else W=W-1 end elseif pu=="right"then if AltIsOn then pA(3)else W=W+1 end elseif pu=="yawright"then X=X-1 elseif pu=="yawleft"then X=X+1 elseif pu=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pu=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pu=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pu=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pu=="groundaltitudeup"then pv()elseif pu=="groundaltitudedown"then pv(true)elseif pu=="option1"then toggleView=false;if AltIsOn and a1 then local pC=""for i=1,#bz do pC=pC.."| Name: "..system.getPlayerName(bz[i]).." Mass: "..A(core.getBoardedPlayerMass(bz[i])/1000,1).."t "end;system.print("Onboard: "..pC)return end;aQ.adjustAutopilotTargetIndex()elseif pu=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bz do core.forceDeboard(bz[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif pu=="option3"then local function pD()aC=not aC;if not aC then bF("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bF("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local pC=""for i=1,#bA do pC=pC.."| ID: "..bA[i].." Mass: "..A(core.getDockedConstructMass(bA[i])/1000,1).."t "end;system.print("Docked Ships: "..pC)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;pD()toggleView=false elseif pu=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bA do core.forceUndock(bA[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif pu=="option5"then toggleView=false;aR.ToggleLockPitch()elseif pu=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local pE=shield_1.getVentingCooldown()if pE>0 then a2="Cannot vent again for "..pE.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif pu=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif pu=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bF("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bF("gsOn","GS")end;toggleView=false elseif pu=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bF("gyOn","GA")else bF("gyOff","GA")end end;toggleView=false elseif pu=="lshift"then bw=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif pu=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif pu=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pu=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif pu=="stopengines"then local function pF()if E-F<1.5 then bF("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;pF()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif pu=="speedup"then bC()elseif pu=="speeddown"then bC(true)elseif pu=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(pu)local function pG()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if pu=="forward"then T=0 elseif pu=="backward"then T=0 elseif pu=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif pu=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif pu=="yawright"then X=0 elseif pu=="yawleft"then X=0 elseif pu=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pu=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pu=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pu=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pu=="groundaltitudeup"then pG()toggleView=false elseif pu=="groundaltitudedown"then pG()toggleView=false elseif pu=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif pu=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif pu=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pu)local function pH(bD)local D=1;if bD then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function pI(bD)local D=1;if bD then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if pu=="groundaltitudeup"then if not a1 then pH()end elseif pu=="groundaltitudedown"then if not a1 then pH(true)end elseif pu=="speedup"then pI()elseif pu=="speeddown"then pI(true)end end;function script.onInputText(bV)local function pJ(pK,e8,ht)local function pL(e8)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cr='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cF,cG,cM,cN,cO=o(e8,cr)if cF=="0"and cG=="0"then return vec3(z(cM),z(cN),z(cO))end;cN=math.rad(cN)cM=math.rad(cM)local planet=b[z(cF)][z(cG)]local dA=math.cos(cM)local pM=vec3(dA*math.cos(cN),dA*math.sin(cN),math.sin(cM))return planet.center+(planet.radius+cO)*pM end;local position=pL(e8)return aQ.AddNewLocation(pK,position,ht)end;local i;local pN,pO=nil,nil;local pP="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bV," ")pN=bV;if i~=nil then pN=string.sub(bV,0,i-1)pO=string.sub(bV,i+1)end;if pN=="/help"or pN=="/commands"then for kz in string.gmatch(pP,"([^\n]+)")do system.print(kz)end;return elseif pN=="/setname"then if pO==nil or pO==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(pO)else a2="Select a saved target to rename first"end elseif shield_1 and pN=="/resist"then if pO==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cr=B..', '..B..', '..B..', '..B;local pQ,pR,pS,pT=o(pO,cr)if pT==nil or pQ+pR+pS+pT>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(pQ,pR,pS,pT)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif pN=="/addlocation"or string.find(bV,"::pos")~=nil then local ht=false;local pK="0-Temp"if pO==nil or pO==""then pO=pN;ht=true end;i=string.find(pO,"::")if not ht then pK=string.sub(pO,1,i-2)end;local e8=string.sub(pO,i)pJ(pK,e8,ht)elseif pN=="/agg"then if pO==nil or pO==""then a2="Usage: /agg targetheight"return end;pO=z(pO)if pO<1000 then pO=1000 end;AntigravTargetAltitude=pO;a2="AGG Target Height set to "..pO elseif pN=="/G"then if pO==nil or pO==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pO=="dump"then for cc,cd in pairs(bL())do if type(_G[cd])=="boolean"then if _G[cd]==true then system.print(cd.." true")else system.print(cd.." false")end elseif _G[cd]==nil then system.print(cd.." nil")else system.print(cd.." ".._G[cd])end end;return end;i=string.find(pO," ")local pU=string.sub(pO,0,i-1)local pV=string.sub(pO,i+1)for cc,cd in pairs(bL())do if cd==pU then a2="Variable "..pU.." changed to "..pV;local pW=type(_G[cd])if pW=="number"then pV=z(pV)if cd=="AtmoSpeedLimit"then aZ=pV end elseif pW=="boolean"then if string.lower(pV)=="true"then pV=true else pV=false end end;_G[cd]=pV;return end end;a2="No such global variable: "..pU elseif pN=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif pN=="/copydatabank"then if dbHud_2 then c8(true)else a2="Spare Databank required to copy databank"end elseif pN=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cG)if bu[1]and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cG)if bu[1]and CollisionSystem then if#bq>650 then cG=tostring(cG)bq[cG]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
