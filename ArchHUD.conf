name: ArchHud - Archaegeo v1.400 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.400;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local p=utils.clamp;local q=a.axisCommandManager;local r=system.destroyWidgetPanel;local s=system.updateData;local t=system.addDataToWidget;local u=system.lockView;local v=system.isViewLocked;local w=math.sqrt;local x=tonumber;local core=core;local function y(z,A)local B=10^(A or 0)return d(z*B+0.5)/B end;local C=o()local D=o()local E=16;local F=13;local G=SafeR;local H=SafeB;local I=SafeG;local J=0;local K=0;local L=false;local M=0;local N=false;local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=false;local al=false;local am=false;local an=-1;local ao=""local ap=j()>0;local aq=j()local ar=core.getAltitude()local as=core.getElementIdList()local at=o()local au=core.getConstructMass()local av=false;local aw=nil;local ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]local ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local az={}local aA=0;local aB=0;local aC=""local aD=true;local aE={}local aF=ResolutionX;local aG=ResolutionY;local aH={}local aI={}local aJ={}local aK=0;local aL=false;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=o()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=""local bJ=nil;local bK={}local bL=unit.getClosestPlanetInfluence()>0;local bM=false;local bN=nil;function Log(bO,bP)local self={}self.Name=bO or'Log'self.Value=bP=='number'and 0 or{}self.Type=bP or'mean'function self.Update(bQ)if self.Type=='number'then self.Value=bQ else self.Value[#self.Value]=bQ end end;function self.getString()if self.Type=='number'then return tostring(self.Value)elseif self.Type=='time'then return utils.round(self.getMean()*1000,0.0001)..'ms ('..#self.Value..")"elseif self.Type=='mean'then return tostring(utils.round(self.getMean(),0.01))end end;function self.getValue()if self.Type=='number'then return self.value else return self.getMean()end end;function self.addValue(bQ)if self.Type=='number'then return end;table.insert(self.Value,1,bQ)if#self.Value>1000 then self.Value[1001]=nil end end;function self.getMean()local bR=0;for i=1,#self.Value do bR=bR+self.Value[i]end;return bR/#self.Value end;return self end;function Logger()local self={}self.Logs={}function self.CreateLog(bO,type)local bS=Log(bO,type)Register(bS)return bS end;function self.getLogs()local bT={}for _,bU in pairs(self.Logs)do bT[#bT+1]=bU.Name..': '..bU.getString()end;return bT end;function Register(bS)self.Logs[#self.Logs+1]=bS end;return self end;local function bV(bW)local bX,bY,bZ=aR:getPlanetarySystem(0):castIntersections(bv,bW,function(b_)if b_.noAtmosphericDensityAltitude>0 then return b_.radius+b_.noAtmosphericDensityAltitude else return b_.radius+b_.surfaceMaxAltitude*1.5 end end)local c0=bY;if bZ~=nil and bY~=nil then c0=math.min(bZ,bY)end;if c0~=nil then return bX,c0 else return nil,nil end end;local function c1(c2,c3,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c2 .."|"..c3 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c2 .."|"..c3 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c2 .."|"..c3 .."|"..soundVolume)end end;local function c4(c5,c6)for i=1,#c6 do c5[#c5+1]=c6[i]end;return c5 end;local function c7(c8)local c9={}local ca={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cb={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local cc={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cd={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c8 then c4(c9,ca)c4(c9,cb)c4(c9,cc)c4(c9,cd)return c9 elseif c8=="boolean"then return ca elseif c8=="handling"then return cb elseif c8=="hud"then return cc elseif c8=="physics"then return cd end end;local function ce(cf,cg,ch,ci,cj)if ci==nil then ci=""end;if cj==nil then cj=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ci,cf,cg,cj,ch)end;local function ck(cl,cm)if q:getAxisCommandType(0)~=axisCommandType.byThrottle and not cm then a.control.cancelCurrentControlMasterMode()end;q:setThrottleCommand(axisCommandId.longitudinal,cl)J=p(y(cl*100,0)/100,-1,1)end;local function cn(cl,cm)if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cm then a.control.cancelCurrentControlMasterMode()end;q:setTargetSpeedCommand(axisCommandId.longitudinal,cl)bz=cl end;local function co(cp,cq)if cp==0 then return c(cq)<1e-09 end;if cq==0 then return c(cp)<1e-09 end;return c(cp-cq)<math.max(c(cp),c(cq))*epsilon end;local function cr(ai,cs)local ct=ai>100000;if cs==nil then cs=1 end;if ct then return y(ai/1000/200,cs).."SU"elseif ai<1000 then return y(ai,cs).."M"else return y(ai/1000,cs).."KM"end end;local function cu()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;ae=0;if ap and an==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cn(d(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cv()bi=false;ba=nil;bb=nil;bm=0;if aq==0 then if IntoOrbit then c1("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bL then c1("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cw()if C-b5<1.5 then if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;c1("11","EP")else if bL then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cv()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=C end;if bL and aq==0 then bg=ar;bf=true;bc=true;cv()if IntoOrbit then b5=C else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;b0=true;LockPitch=nil;bi=false;if an==-1 then c1("altOn","AH")AutoTakeoff=false;if b5>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=ar end end;if VertTakeOff then cu()end else c1("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=ar+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;q:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cu()end end;if al then HoldAltitude=100000 end else c1("altOff","AH")if IntoOrbit then cv()end;if VertTakeOff then cu()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cx()local function cy(SpaceTarget)bM=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cw()end end;VectorStatus="Proceeding to Waypoint"end;if C-b6<1.5 and aq>0 then if not bl then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c1("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=C end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not al and not IntoOrbit then aW.UpdateAutopilotTarget()aX.showWayPoint(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c1("apSpc","AP")if aq~=0 then al=true;cw()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if aq>0 then if not VectorToTarget then c1("vtt","AP")cy(SpaceTarget)end else c1("apOn","AP")if not(ab.name==planet.name and bL)then bi=false;Autopilot=true elseif not ap then if IntoOrbit then cv()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cv()end end end else c1("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if aq~=0 then al=true;cw()else Autopilot=true end end elseif aq==0 then if CustomTarget==nil and(ab.name==planet.name and bL)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cv()else c1("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else c1("apP","AP")al=true;cw()end else c1("apOff","AP")al=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=ar;TargetSet=false;Reentry=false;if IntoOrbit then cv()end end end;local function cz()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then c1("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bJ=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cu()end;if IntoOrbit then cv()end;b0=autoRollPreference;ak=false;am=false;ae=0 else c1("bkOff","B",1)end end;local function cA()if Reentry then a1="Re-Entry cancelled"c1("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not Q then Reentry=true;if q:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;c1("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local ch=cr(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..ch;c1("glide","RE")cn(d(b7))end;AutoTakeoff=false end;local function cB()if antigrav and not ExternalAGG then if by then c1("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c1("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cC(cD)local cE=0;local cF=0;local cG=0;if cD<60 then cD=d(cD)elseif cD<3600 then cE=d(cD/60)cD=d(cD%60)elseif cD<86400 then cF=d(cD/3600)cE=d(cD%3600/60)else cG=d(cD/86400)cF=d(cD%86400/3600)end;if cG>0 then return cG.."d "..cF.."h "elseif cF>0 then return cF.."h "..cE.."m "elseif cE>0 then return cE.."m "..cD.."s"elseif cD>0 then return cD.."s"else return"0s"end end;local function cH(cI)local function cJ(cK)for cL,bQ in pairs(cK)do dbHud_1.setStringValue(bQ,g(_G[bQ]))if cI and dbHud_2 then dbHud_2.setStringValue(bQ,g(_G[bQ]))end end end;if dbHud_1 then cJ(b)cJ(c7())system.print("Saved Variables to Datacore")if cI and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end;local function cM()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cN()local function cO(cP)return type(cP)=='number'end;local function cQ(cP)return type(x(cP))=='number'end;local function cR(cS)return type(cS)=='table'end;local function cT(cU)return type(cU)=='string'end;local function cV(bQ)return cR(bQ)and cO(bQ.x and bQ.y and bQ.z)end;local function cW(bR)return cR(bR)and cO(bR.latitude and bR.longitude and bR.altitude and bR.bodyId and bR.systemId)end;local cX=math.pi/180;local cY=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cZ='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function c_(cP)local d0=string.gsub(string.reverse(e('%.4f',cP)),'^0*%.?','')return d0==''and'0'or string.reverse(d0)end;local function d1(d2)if cV(d2)then return e('{x=%.3f,y=%.3f,z=%.3f}',d2.x,d2.y,d2.z)end;if cR(d2)and not getmetatable(d2)then local d3={}local d4=next(d2)if type(d4)=='nil'or d4==1 then d3=d2 else for cL,bQ in pairs(d2)do local cl=d1(bQ)if type(cL)=='number'then table.insert(d3,e('[%s]=%s',cL,cl))else table.insert(d3,e('%s=%s',cL,cl))end end end;return e('{%s}',table.concat(d3,','))end;if cT(d2)then return e("'%s'",d2:gsub("'",[[\']]))end;return tostring(d2)end;local d5={}d5.__index=d5;d5.__tostring=function(d2,d6)local d7={}for cL in pairs(d2)do table.insert(d7,cL)end;table.sort(d7)local d3={}for _,cL in ipairs(d7)do local cl=d1(d2[cL])if type(cL)=='number'then table.insert(d3,e('[%s]=%s',cL,cl))else table.insert(d3,e('%s=%s',cL,cl))end end;if d6 then return e('%s%s',d6,table.concat(d3,',\n'..d6))end;return e('{%s}',table.concat(d3,','))end;d5.__eq=function(d8,d9)return d8.planetarySystemId==d9.planetarySystemId and d8.bodyId==d9.bodyId and co(d8.radius,d9.radius)and co(d8.center.x,d9.center.x)and co(d8.center.y,d9.center.y)and co(d8.center.z,d9.center.z)and co(d8.GM,d9.GM)end;local function da(db,dc,dd,de,df)assert(cQ(db),'Argument 1 (planetarySystemId) must be a number:'..type(db))assert(cQ(dc),'Argument 2 (bodyId) must be a number:'..type(dc))assert(cQ(dd),'Argument 3 (radius) must be a number:'..type(dd))assert(cR(de),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(de))assert(cQ(df),'Argument 5 (GM) must be a number:'..type(df))return setmetatable({planetarySystemId=x(db),bodyId=x(dc),radius=x(dd),center=vec3(de),GM=x(df)},d5)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dg)return e('::pos{%d,%d,%s,%s,%s}',dg.systemId,dg.bodyId,c_(dg.latitude*cY),c_(dg.longitude*cY),c_(dg.altitude))end;MapPosition.__eq=function(d8,d9)return d8.bodyId==d9.bodyId and d8.systemId==d9.systemId and co(d8.latitude,d9.latitude)and co(d8.altitude,d9.altitude)and(co(d8.longitude,d9.longitude)or co(d8.latitude,math.pi/2)or co(d8.latitude,-math.pi/2))end;local function dh(di,dc,dj,dk,dl)local db=di;if cT(di)and not dk and not dl and not dc and not dj then db,dc,dj,dk,dl=n(di,cZ)assert(db,'Argument 1 (position string) is malformed.')else assert(cQ(db),'Argument 1 (systemId) must be a number:'..type(db))assert(cQ(dc),'Argument 2 (bodyId) must be a number:'..type(dc))assert(cQ(dj),'Argument 3 (latitude) must be in degrees:'..type(dj))assert(cQ(dk),'Argument 4 (longitude) must be in degrees:'..type(dk))assert(cQ(dl),'Argument 5 (altitude) must be in meters:'..type(dl))end;db=x(db)dc=x(dc)dj=x(dj)dk=x(dk)dl=x(dl)if dc==0 then return setmetatable({latitude=dj,longitude=dk,altitude=dl,bodyId=dc,systemId=db},MapPosition)end;return setmetatable({latitude=cX*p(dj,-90,90),longitude=cX*(dk%360),altitude=dl,bodyId=dc,systemId=db},MapPosition)end;local dm={}dm.__index=dm;dm.__tostring=function(d2,d6)local dn=d6 and d6 ..'  'local dp={}local d7={}for cL in pairs(d2)do table.insert(d7,cL)end;table.sort(d7)for _,dq in ipairs(d7)do bdy=d2[dq]local dr=d5.__tostring(bdy,dn)if d6 then table.insert(dp,e('[%s]={\n%s\n%s}',dq,dr,d6))else table.insert(dp,e('  [%s]=%s',dq,dr))end end;if d6 then return e('\n%s%s%s',d6,table.concat(dp,',\n'..d6),d6)end;return e('{\n%s\n}',table.concat(dp,',\n'))end;local function ds(dt)local aM={}local pid;for _,bQ in pairs(dt)do local du=bQ.planetarySystemId;if type(du)~='number'then error('Invalid planetary system ID: '..tostring(du))elseif pid and du~=pid then error('Mistringmatch planetary system IDs: '..du..' and '..pid)end;local dv=bQ.bodyId;if type(dv)~='number'then error('Invalid body ID: '..tostring(dv))elseif aM[dv]then error('Duplicate body ID: '..tostring(dv))end;setmetatable(bQ.center,getmetatable(vec3.unit_x))aM[dv]=setmetatable(bQ,d5)pid=du end;return setmetatable(aM,dm)end;aQ={}local function dw(dt)return setmetatable({galaxyAtlas=dt or{}},aQ)end;aQ.__index=function(cS,i)if type(i)=='number'then local system=cS.galaxyAtlas[i]return ds(system)end;return rawget(aQ,i)end;aQ.__pairs=function(d2)return function(cS,cL)local dx,nv=next(cS,cL)return dx,nv and ds(nv)end,d2.galaxyAtlas,nil end;aQ.__tostring=function(d2)local dy={}for _,dz in pairs(d2 or{})do local dA=dz:getPlanetarySystemId()local dB=dm.__tostring(dz,'    ')table.insert(dy,e('  [%s]={%s\n  }',dA,dB))end;return e('{\n%s\n}\n',table.concat(dy,',\n'))end;aQ.BodyParameters=da;aQ.MapPosition=dh;aQ.PlanetarySystem=ds;function aQ.createBodyParameters(dC,dc,dD,dE,dF,dG,dH)assert(cQ(dC),'Argument 1 (planetarySystemId) must be a number:'..type(dC))assert(cQ(dc),'Argument 2 (bodyId) must be a number:'..type(dc))assert(cQ(dD),'Argument 3 (surfaceArea) must be a number:'..type(dD))assert(cR(dE),'Argument 4 (aPosition) must be an array or vec3:'..type(dE))assert(cR(dF),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dF))assert(cQ(dG),'Argument 6 (altitude) must be in meters:'..type(dG))assert(cQ(dH),'Argument 7 (gravityAtPosition) must be number:'..type(dH))local dd=w(dD/4/math.pi)local ai=dd+dG;local dI=vec3(dE)+ai*vec3(dF)local df=dH*ai*ai;return da(dC,dc,dd,dI,df)end;aQ.isMapPosition=cW;function aQ:getPlanetarySystem(di)if i==nil then i=0 end;if nv==nil then nv=0 end;local dC=di;if cW(di)then dC=di.systemId end;if type(dC)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dm then system=ds(system)end;return system end end end;function dm:sizeCalculator(b_)return 1.05*b_.radius end;function dm:castIntersections(dJ,dK,dL,dM,dN,dO)local dP={}local dQ=dN or self;for _,b_ in pairs(dQ)do table.insert(dP,b_)end;if not dO then table.sort(dP,function(dR,dS)return(dR.center-dJ):len()<(dS.center-dJ):len()end)end;local dT=dK:normalize()for _,b_ in ipairs(dP)do local dU=b_.center-dJ;local dd=self:sizeCalculator(b_)local dV=dU:dot(dT)local dW=dV^2-(dU:len2()-dd^2)if dW>=0 then local dX=w(dW)local bY=dV+dX;local bZ=dV-dX;if bZ>0 then return b_,bY,bZ elseif bY>0 then return b_,bY,nil end end end;return nil,nil,nil end;function dm:closestBody(dY)assert(type(dY)=='table','Invalid coordinates.')local dZ,b_;local d_=vec3(dY)for _,e0 in pairs(self)do local e1=(e0.center-d_):len2()if(not b_ or e1<dZ)and e0.name~="Space"then b_=e0;dZ=e1 end end;return b_ end;function dm:convertToBodyIdAndWorldCoordinates(di)local e2=di;if cT(di)then e2=dh(di)end;if e2.bodyId==0 then return 0,vec3(e2.latitude,e2.longitude,e2.altitude)end;local e0=self:getBodyParameters(e2)if e0 then return e2.bodyId,e0:convertToWorldCoordinates(e2)end end;function dm:getBodyParameters(di)local dc=di;if cW(di)then dc=di.bodyId end;assert(cQ(dc),'Argument 1 (bodyId) must be a number:'..type(dc))return self[dc]end;function dm:getPlanetarySystemId()local _,bQ=next(self)return bQ and bQ.planetarySystemId end;function d5:convertToMapPosition(de)assert(cR(de),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(de))local e3=vec3(de)if self.bodyId==0 then return setmetatable({latitude=e3.x,longitude=e3.y,altitude=e3.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local e4=e3-self.center;local ai=e4:len()local dl=ai-self.radius;local dj=0;local dk=0;if not co(ai,0)then local e5=m(e4.y,e4.x)dk=e5>=0 and e5 or 2*math.pi+e5;dj=math.pi/2-math.acos(e4.z/ai)end;return setmetatable({latitude=dj,longitude=dk,altitude=dl,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function d5:convertToWorldCoordinates(di)local e2=cT(di)and dh(di)or di;if e2.bodyId==0 then return vec3(e2.latitude,e2.longitude,e2.altitude)end;assert(cW(e2),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e2.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e2.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local e6=math.cos(e2.latitude)return self.center+(self.radius+e2.altitude)*vec3(e6*math.cos(e2.longitude),e6*math.sin(e2.longitude),math.sin(e2.latitude))end;function d5:getAltitude(de)return(vec3(de)-self.center):len()-self.radius end;function d5:getDistance(de)return(vec3(de)-self.center):len()end;function d5:getGravity(de)local e7=self.center-vec3(de)local e8=e7:len2()return self.GM/e8*e7/w(e8)end;return setmetatable(aQ,{__call=function(_,...)return dw(...)end})end;local function e9()local aS={}local ea=30000000/3600;local eb=ea*ea;local ec=100;local function ed(bQ)return 1/w(1-bQ*bQ/eb)end;function aS.computeAccelerationTime(ee,ef,eg)local eh=ea*math.asin(ee/ea)return(ea*math.asin(eg/ea)-eh)/ef end;function aS.computeDistanceAndTime(ee,eg,ei,ej,ek,el)ek=ek or 0;el=el or 0;local em=ee<=eg;local en=ej*(em and 1 or-1)/ei;local eo=-el/ei;local ep=en+eo;if em and ep<=0 or not em and ep>=0 then return-1,-1 end;local eq,er=0,0;if en~=0 and ek>0 then local eh=math.asin(ee/ea)local es=math.pi*(en/2+eo)local et=en*ek;local eu=ea*math.pi;local bQ=function(cS)local ev=(es*cS-et*math.sin(math.pi*cS/2/ek)+eu*eh)/eu;local ew=math.tan(ev)return ea*ew/w(ew*ew+1)end;local ex=em and function(cU)return cU>=eg end or function(cU)return cU<=eg end;er=2*ek;if ex(bQ(er))then local ey=0;while c(er-ey)>0.5 do local cS=(er+ey)/2;if ex(bQ(cS))then er=cS else ey=cS end end end;local ez=ee;local eA=er/ec;for eB=1,ec do local eC=bQ(eB*eA)eq=eq+(eC+ez)*eA/2;ez=eC end;if er<2*ek then return eq,er end;ee=ez end;local eh=ea*math.asin(ee/ea)local C=(ea*math.asin(eg/ea)-eh)/ep;local eD=eb*math.cos(eh/ea)/ep;local ai=eD-eb*math.cos((ep*C+eh)/ea)/ep;return ai+eq,C+er end;function aS.computeTravelTime(ee,ef,ai)if ai==0 then return 0 end;if ef>0 then local eh=ea*math.asin(ee/ea)local eD=eb*math.cos(eh/ea)/ef;return(ea*math.acos(ef*(eD-ai)/eb)-eh)/ef end;if ee==0 then return-1 end;assert(ee>0,'Acceleration and initial speed are both zero.')return ai/ee end;function aS.lorentz(bQ)return ed(bQ)end;return aS end;local function eE()local vec3=require('cpml.vec3')local cN=cN()local function cT(cU)return type(cU)=='string'end;local function cR(cS)return type(cS)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dl)assert(self.body)local ai=dl+self.body.radius;if not co(ai,0)then local orbit=w(self.body.GM/ai)return w(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(di,eF)assert(self.body)assert(cR(di)or cT(di))assert(cR(eF))local eG=(cT(di)or cN.isMapPosition(di))and self.body:convertToWorldCoordinates(di)or vec3(di)local bQ=vec3(eF)local eH=eG-self.body.center;local eI=bQ:len2()local eJ=eH:len()local eK=self.body.GM;local eL=((eI-eK/eJ)*eH-eH:dot(bQ)*bQ)/eK;local cp=eK/(2*eK/eJ-eI)local eM=eL:len()local dT=eL:normalize()local eN=cp*(1-eM)local eO=cp*(1+eM)local eP=eN*dT+self.body.center;local eQ=eM<=1 and-eO*dT+self.body.center or nil;local eR=w(cp*eK*(1-eM*eM))local eS=eQ and 2*math.pi*w(cp^3/eK)local eT=math.acos(eL:dot(eH)/(eM*eJ))if eH:dot(bQ)<0 then eT=-(eT-2*math.pi)end;local eU=math.acos((math.cos(eT)+eM)/(1+eM*math.cos(eT)))local eV=eU;if eV<0 then eV=eV+2*math.pi end;local eW=eV-eM*math.sin(eV)local eX=0;local eY=0;local eZ=0;if eS~=nil then eX=eW/(2*math.pi/eS)eY=eS-eX;eZ=eY+eS/2;if eT-math.pi>0 then eY=eX;eZ=eY+eS/2 end;if eZ>eS then eZ=eZ-eS end end;return{periapsis={position=eP,speed=eR/eN,circularOrbitSpeed=w(eK/eN),altitude=eN-self.body.radius},apoapsis=eQ and{position=eQ,speed=eR/eO,circularOrbitSpeed=w(eK/eO),altitude=eO-self.body.radius},currentVelocity=bQ,currentPosition=eG,eccentricity=eM,period=eS,eccentricAnomaly=eU,meanAnomaly=eW,timeToPeriapsis=eY,timeToApoapsis=eZ}end;local function e_(f0)local e0=cN.BodyParameters(f0.planetarySystemId,f0.bodyId,f0.radius,f0.center,f0.GM)return setmetatable({body=e0},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return e_(...)end})end;local function f1()local f2={}local f3={}local f4={XS=13,S=27,M=55,L=110,XL=221}local f5={}local f6;local f7;local f8;local f9;local fa;local function fb()local function fc(fd,fe,ff,fg,fh,fi,fj,fk)fe,fg,fi,fk=vec3(fe),vec3(fg),vec3(fi),vec3(fk)local fl,fm,fn=fd*fd,ff*ff,fh*fh;local eI=fg-fe;local fo=eI:normalize()local fp=eI:len()local fq=fi-fe;local fr=(fq-fq:project_on(fo)):normalize()local fs,ft=fq:dot(fo),fq:dot(fr)local fu=fs*fs+ft*ft;local fv=fo:cross(fr)local cf=(fl-fm+fp*fp)/(2*fp)local cg=(fl-fn+fu-2*fs*cf)/(2*ft)local bR=fl-cf^2-cg^2;local fw=w(bR)local fx=fe+fo*cf+fr*cg+fv*fw;local fy=fe+fo*cf+fr*cg-fv*fw;if c((fk-fx):len()-fj)<c((fk-fy):len()-fj)then return fx else return fy end end;local function fz()local function fA()local fB=core.getConstructWorldOrientationRight()local eI=core.getConstructWorldOrientationForward()local fq=core.getConstructWorldOrientationUp()local fC=library.systemResolution3(fB,eI,fq,{1,0,0})local fD=library.systemResolution3(fB,eI,fq,{0,1,0})local fE=library.systemResolution3(fB,eI,fq,{0,0,1})return function(fF)return library.systemResolution3(fC,fD,fE,fF)end end;local fG=fA()local fH=core.getConstructWorldPos()local eG=core.getElementPositionById(1)local fI={eG[1]-E,eG[2]-E,eG[3]-E}local fJ=fG(fI)local fK={fH[1]-fJ[1],fH[2]-fJ[2],fH[3]-fJ[3]}return fK end;local function fL(fM,eJ,fN)local fO=fM.pts;local fP=#fO;local fQ=fM.ref;if fP>3 then local fR,fS,fT,fU=fO[fP],fO[fP-1],fO[fP-2],fO[fP-3]fM.ref=fN;local eG=fc(fR[1],fR[2],fS[1],fS[2],fT[1],fT[2],fU[1],fU[2])local cf,cg,fw=eG.x,eG.y,eG.z;if cf==cf and cg==cg and fw==fw then cf=cf+fQ[1]cg=cg+fQ[2]fw=fw+fQ[3]local fV=vec3(cf,cg,fw)if not fM.lastPos then fM.center=fV elseif(fM.lastPos-fV):len()<2 then fM.center=fV;fM.skipCalc=true end;fM.lastPos=fV end;fM.pts={}else local fW={fN[1]-fQ[1],fN[2]-fQ[2],fN[3]-fQ[3]}fO[fP+1]={eJ,fW}end end;if radar_1 then f6=#radar_1.getEntries()local fX=radar_1.getData()local fY=fX:gmatch('{"constructId[^}]*}[^}]*}')if f6>0 then local fN=fz()local fZ,f_=0,0;fa,f9=0,0;for bQ in fY do local du,ai,g0=bQ:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g1=f4[g0]ai=x(ai)if radar_1.hasMatchingTransponder(du)==1 then table.insert(f3,du)end;local g2=radar_1.getConstructType(du)if CollisionSystem then if g1>27 or g2=="static"or g2=="space"then fa=fa+1;local bO=radar_1.getConstructName(du)local fM=bK[du]if fM==nil then g1=g1+F;bK[du]={pts={},ref=fN,name=bO,i=0,radius=g1,skipCalc=false}fM=bK[du]end;if not fM.skipCalc then fL(fM,ai,fN)f_=f_+1 end;if fM.center then table.insert(f5,fM)end end;fZ=fZ+1;if bL and fZ>700 or f_>70 or(not bL and fZ>300 or f_>30)then coroutine.yield()fZ,f_=0,0 end end end;f9=#f5;if f9>0 and bs>20 then local b_,g3,g4,g5;local g6=0;local g7=aR:getPlanetarySystem(0)g5=br:normalize()while g6<f9 do coroutine.yield()local g8={table.unpack(f5,g6,math.min(g6+75,f9))}b_,g3,g4=g7:castIntersections(bv,g5,nil,nil,g8,true)if b_ and g4 then bN={b_,g3,g4}break end;g6=g6+75 end;if not b_ then bN=nil end else bN=nil end;f5={}f7=fX:find('identifiedConstructs":%[%]')else f8=fX:find('worksInEnvironment":false')end end end;function f2.UpdateRadar()local g9=coroutine.status(UpdateRadarCoroutine)if g9=="suspended"then local cl,ga=coroutine.resume(UpdateRadarCoroutine)if ga then system.print("ERROR UPDATE RADAR: "..ga)end elseif g9=="dead"then UpdateRadarCoroutine=coroutine.create(fb)local cl,ga=coroutine.resume(UpdateRadarCoroutine)end end;function f2.GetRadarHud()return f7,f8,f6,f9,fa,f3 end;UpdateRadarCoroutine=coroutine.create(fb)return f2 end;local function gb()local gc=0;local gd=vec3({13771471,7435803,-128971})local ge=18000000;local gf=500000;local gg,gh=math.huge;local gi;local function gj(gk)gg=vec3(gk):dist(gd)if gg<ge then return true,c(gg-ge)end;gh=vec3(gk):dist(vec3(planet.center))if gh<gf then gi=true else gi=false end;if c(gh-gf)<c(gg-ge)then return gi,c(gh-gf)else return gi,c(gg-ge)end end;local function gl(bQ)if aF==1920 then return bQ else return y(aF*bQ/1920,0)end end;local function gm(bQ)if aG==1080 then return bQ else return y(aG*bQ/1080,0)end end;local function gn()return v()==0 and userControlScheme~="keyboard"and l()==0 end;local function go()local gp="TRAVEL"if not bA then gp="CRUISE"end;if Autopilot then gp="AUTOPILOT"end;return gp end;local gq=""local gr=""local gs=1;local gt=2;local gu=3;local gv=4;local gw=5;local gx=6;local gy=""local gz=0;local gA=d(1/apTickRate)*2*hudTickRate;local gB={}local gC={}local gD={}local gE={}local gF={}local gG={}local function gH(cf,gI,gJ,gK,gL,gM)local gN=fuelY;local gO=fuelY+5;if not BarFuelDisplay then gO=gO+5 end;if l()==1 and not RemoteHud then gN=gN-50;gO=gO-50 end;if gJ=="ATMO"then gy="atmofueltank"elseif gJ=="SPACE"then gy="spacefueltank"else gy="rocketfueltank"end;gz=_G[gy.."_size"]if#gK>0 then for i=1,#gK do local bO=string.sub(gK[i][gt],1,12)local gP=0;for gQ=1,gz do if gK[i][gt]==f(unit[gy.."_"..gQ].getData()).name then gP=gQ;break end end;local gR=o()if gL[i]==nil or gM[i]==nil or gR-gK[i][gx]>gA then local gS;local gT=0;if gP~=0 then gM[i]=f(unit[gy.."_"..gP].getData()).percentage;gL[i]=f(unit[gy.."_"..gP].getData()).timeLeft;if gL[i]=="n/a"then gL[i]=0 end else gT=k(gK[i][gs])-gK[i][gv]gM[i]=d(0.5+gT*100/gK[i][gu])gS=gK[i][gw]if gS<=gT then gL[i]=0 else gL[i]=d(0.5+gT/((gS-gT)/(gR-gK[i][gx])))end;gK[i][gw]=gT;gK[i][gx]=gR end end;if bO==gI then bO=e("%s %d",gJ,i)end;if gP==0 then bO=bO.." *"end;local gU;if gL[i]==0 then gU=""else gU=cC(gL[i])end;if gM[i]~=nil then local gV=d(gM[i]*2.55)local gW=e("rgb(%d,%d,%d)",255-gV,gV,0)local ci=""if gU~=""and gL[i]<120 or gM[i]<5 then ci=[[class="red"]]end;if BarFuelDisplay then gr=gr..e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cf,gO,gW,gM[i],cf,gO,cf+2,gO+10,gM[i],gU)gr=gr..ce(cf,gN,bO,ci.."txtstart pdim txtfuel")gN=gN-30;gO=gO-30 else gr=gr..ce(cf,gN,bO,ci.." pdim txtfuel")gr=gr..ce(cf,gO,e("%d%% %s",gM[i],gU),"pdim txtfuel","fill:"..gW)gN=gN+30;gO=gO+30 end end end end end;local function gX(gY,dl)if dl<200000 and not ap or dl and ap then local gZ=0;if c(bu)>1 then gZ=45*math.log(c(bu),10)if bu<0 then gZ=-gZ end end;gY[#gY+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bu),d(gZ))end;return gY end;local function g_(h0)local h1=-bt;h0=h0-h0:project_on(h1)local h2=vec3(0,0,1)h2=h2-h2:project_on(h1)local h3=h2:cross(h1)local gZ=h2:angle_between(h0)*constants.rad2deg;if h0:dot(h3)<0 then gZ=360-gZ end;return gZ end;local function h4(gY,centerX,centerY,h5,h6,bL)local h7=circleRad;local h8=20;local h9=d(h5)if bL then for i=-45,45,5 do local ha=i;gY[#gY+1]=e([[<g transform="rotate(%f,%d,%d)">]],ha,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gY[#gY+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h7+h8-len,centerX,centerY+h7+h8)end;gY[#gY+1]=ce(centerX,centerY+h7+h8-35,h6,"pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY+h7+h8-25,h9 .." deg","pdim txt txtmid")gY[#gY+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h5,centerX,centerY)gY[#gY+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h7+h8-20,centerX+5,centerY+h7+h8-20,centerX,centerY+h7+h8-15)gY[#gY+1]="</g>"end;local hb=h9;if bL then hb=g_(bo)end;local hc=20;local hd=d(hb)local he=0;local hf=centerY+h7+h8+20;local hg=centerX;if h6~="YAW"then hf=gm(130)hg=gl(960)end;local hh=[[<path class="txttick line" d="]]local hi=d(hd-(hc+10)-hd%5+0.5)for i=hi+60,hi,-5 do local cf=hg-(-i*5+hb*5)if i%10==0 then he=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;gY[#gY+1]=ce(cf+5,hf-12,z)elseif i%5==0 then he=5 end;if he==10 then hh=e([[%s M %f %f v %d]],hh,cf,hf-5,he)else hh=e([[%s M %f %f v %d]],hh,cf,hf-2.5,he)end end;gY[#gY+1]=hh..[["/>]]gY[#gY+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hg-5,hf+10,hg+5,hf+10,hg,hf+5)if bL then h6="HDG"end;gY[#gY+1]=ce(hg,hf+25,hd.."deg","pdim txt txtmid","")gY[#gY+1]=ce(hg,hf+35,h6,"pdim txt txtmid","")end;local function hj(gY,hk,h5,centerX,centerY,bL,hl,eC)local h7=circleRad;local hm=d(h7*3/5)if h7>0 then local hn=d(hk)local len=0;local hh=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h5,centerX,centerY)if not ap then hh=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gY[#gY+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h7-1,centerX,centerY)gY[#gY+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hn-30-hn%5+0.5),d(hn+30+hn%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cg=centerY+-i*5+hk*5;if len==30 then hh=e([[%s M %d %f h %d]],hh,centerX-hm-len,cg,len)if ap then gY[#gY+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h5,centerX,centerY,centerX-hm+10,cg,i)gY[#gY+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h5,centerX,centerY,centerX+hm-10,cg,i)if i==0 or i==180 or i==-180 then gY[#gY+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h5,centerX,centerY,centerX-hm+20,cg,hm*2-40)end else gY[#gY+1]=ce(centerX-hm+10,cg,i,"pdim txt txtmid")gY[#gY+1]=ce(centerX+hm-10,cg,i,"pdim txt txtmid")end;hh=e([[%s M %d %f h %d]],hh,centerX+hm,cg,len)else hh=e([[%s M %d %f h %d]],hh,centerX-hm-len,cg,len)hh=e([[%s M %d %f h %d]],hh,centerX+hm,cg,len)end end;gY[#gY+1]=hh..[["/>]]local ho="PITCH"if not bL then ho="REL PITCH"end;if hk>90 and not ap then hk=90-(hk-90)elseif hk<-90 and not ap then hk=-90-(hk+90)end;if h7>200 then if ap then if eC>P then gY[#gY+1]=ce(centerX,centerY-15,"Yaw","pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY+20,hl,"pdim txt txtmid")end;gY[#gY+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h5,centerX,centerY)else gY[#gY+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gY[#gY+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hm+25,centerY-5,centerX-hm+20,centerY,centerX-hm+25,centerY+5,centerX-hm+50,centerY+4,hn)gY[#gY+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hm-25,centerY-5,centerX+hm-20,centerY,centerX+hm-25,centerY+5,centerX+hm-30,centerY+4,hn)gY[#gY+1]="</g>"end;local hp=d(h7/3)gY[#gY+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hp,centerY,h7-hp)if not ap and bL then gY[#gY+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h5,centerX,centerY,centerX-hm+10,centerY,hm*2-20)end;gY[#gY+1]="</g>"if h7<200 then if ap and eC>P then gY[#gY+1]=ce(centerX,centerY-h7,ho,"pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY-h7+10,hn,"pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY-15,"Yaw","pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY+20,hl,"pdim txt txtmid")else gY[#gY+1]=ce(centerX,centerY-h7,ho,"pdim txt txtmid")gY[#gY+1]=ce(centerX,centerY-h7+15,hn,"pdim txt txtmid")end end end end;local function hq(gY,dl,bL)local hr=altMeterX;local hs=altMeterY;local ht=78;local hu=19;local hv=an;if an~=-1 then gY[#gY+1]=ce(hr+ht,hs+hu+20,e("AGL: %.1fm",an),"pdim altsm txtend")end;if bL and(dl<200000 and not ap or dl and ap)then table.insert(gY,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hr-1,hs-4,ht+2,hu+6,hr+1,hs-1,ht-4,hu))local fP=0;local hw=1;local hx=0;local hy=dl<0;local hz=dl<planet.surfaceMaxAltitude;local hA=9;if hy then hA=0 end;local dl=c(dl)while fP<6 do local hB=11;local hC=16;local hD=9;local hE=14;local ci="altsm"if fP>2 then hC=hC+3;hB=hB+2;hE=hE+2;hD=hD-6;ci="altbig"end;if hy then ci=ci.." red"elseif hz then ci=ci.." orange"end;local hF=dl/hw%10;local hG=d(hF)local hH=d((hG+1)%10)local hI=hx;if fP==0 then hI=hF-hG;if hy then hI=1-hI end end;if hy and(fP==0 or hx~=0)then local hJ=hH;hH=hG;hG=hJ end;local hK=hC*(hI-1)local hL=hK+hC;local cf=hr+hD+(6-fP)*hB;local cg=hs+hE;gY[#gY+1]=ce(cf,cg+hK,hH,ci)gY[#gY+1]=ce(cf,cg+hL,hG,ci)fP=fP+1;hw=hw*10;if hG==hA then hx=hI else hx=0 end end;table.insert(gY,[[</g></g>]])end end;local function hM(eF)local hN=-math.deg(m(eF.y,eF.z))+180;hN=hN-90;if hN<0 then hN=360+hN end;if hN>180 then hN=-180+hN-180 end;return-hN end;local function hO(eF)local hb=math.deg(m(eF.y,eF.x))-90;if hb<-180 then hb=360+hb end;return hb end;local function hP(gY,eF,eC,centerX,centerY)if eC>5 and not ap or eC>P then local h7=circleRad;local hQ=20;local hR=20;local hS=hM(eF)local hT=hO(eF)local hU=14;local hV=hU/2;local hW=-hT/hR*h7;local hX=hS/hQ*h7;local cf=centerX+hW;local cg=centerY+hX;local ai=w(hW^2+hX^2)local hY=[[<circle
                            cx="]]..cf..[["
                            cy="]]..cg..[["
                            r="]]..hV/hU..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cf..[["
                            cy="]]..cg..[["
                            r="]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cf-hU..[[,]]..cg..[[ h ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cf+hV..[[,]]..cg..[[ h ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cf..[[,]]..cg-hU..[[ v ]]..hV..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<h7 then gY[#gY+1]=hY else local gZ=m(hX,hW)local hZ=4;local h_=centerX+h7*math.cos(gZ)local i0=centerY+h7*math.sin(gZ)gY[#gY+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gZ*180/math.pi,h_,i0,h_-hZ,i0-hZ/2,hZ*2,hZ,h_+hZ,i0-hZ,hZ,hZ,-hZ,hZ)end;if not ap then local i1=vec3(eF)hS=hM(-i1)hT=hO(-i1)hW=-hT/hR*h7;hX=hS/hQ*h7;cf=centerX+hW;cg=centerY+hX;ai=w(hW^2+hX^2)if ai<h7 then local i2=[[<circle
                                    cx="]]..cf..[["
                                    cy="]]..cg..[["
                                    r="]]..hV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cf..[[,]]..cg-hU..[[ v ]]..hV..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cf..[[,]]..cg..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cf..[[,]]..cg..[[)" />
                                <path
                                    d="M ]]..cf-hV..[[,]]..cg..[[ h ]]..hU..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cf..[[,]]..cg..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cf..[[,]]..cg..[[)"/>]]gY[#gY+1]=i2 end end end end;local function i3(gY,gp,i4,i5)i4=d(i4+0.5)local gN=throtPosY+10;local gO=throtPosY+20;if l()==1 and not RemoteHud then gN=55;gO=65 end;local i6="CRUISE"local unit="km/h"local cl=i5;if gp=="TRAVEL"or gp=="AUTOPILOT"then i6="THROT"unit="%"cl=i4;local i7="dim"if i4<0 then i7="red"end;gY[#gY+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i7,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gY[#gY+1]=ce(throtPosX+10,gN,i6,"pbright txtstart")gY[#gY+1]=ce(throtPosX+10,gO,e("%.0f %s",cl,unit),"pbright txtstart")if ap and AtmoSpeedAssist and bA and L then i4=d(M*100+0.5)local i7="red"if i4<0 then i7="red"end;gY[#gY+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i7,1-c(i4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gY[#gY+1]=ce(throtPosX+10,gN+40,"LIMIT","pbright txtstart")gY[#gY+1]=ce(throtPosX+10,gO+40,i4 .."%","pbright txtstart")end;if ap and AtmoSpeedAssist or Reentry then gY[#gY+1]=ce(throtPosX+10,gN-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not ap and Autopilot then gY[#gY+1]=ce(throtPosX+10,gN-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i8(gY,i9)local ia=throtPosY-10;local ib=throtPosX+10;gY[#gY+1]=ce(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then ia=75 end;gY[#gY+1]=ce(ib,ia,d(i9).." km/h","pbright txtbig txtstart")end;local function ic(gY)gY[#gY+1]=ce(gl(1900),gm(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gY[#gY+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gY[#gY+1]=ce(gl(960),gm(550),"Warning: Invalid Control Scheme Detected","warnings")gY[#gY+1]=ce(gl(960),gm(600),"Keyboard Scheme must be selected","warnings")gY[#gY+1]=ce(gl(960),gm(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local id=gl(960)local ie=gm(860)local ig=gm(880)local ih=gm(900)local ii=gm(960)local ij=gm(200)local ik=gm(250)local il=gm(960)if l()==1 and not RemoteHud then ie=gm(135)ig=gm(155)ih=gm(175)ij=gm(115)ik=gm(95)end;if BrakeIsOn then gY[#gY+1]=ce(id,ie,"Brake Engaged","warnings")elseif K>0 then gY[#gY+1]=ce(id,ie,"Auto-Brake Engaged","warnings","opacity:"..K)end;if ap and b2 and an==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gY[#gY+1]=ce(id,ij+50,"** STALL WARNING **","warnings")c1("stall","SW",2)end end;if bJ then gY[#gY+1]=ce(id,ij+90,"Flight Assist in Progress","warnings")end;if aw then gY[#gY+1]=ce(id,il,"Gyro Enabled","warnings")end;if GearExtended then if R then gY[#gY+1]=ce(id,ig,"Gear Extended","warn")else gY[#gY+1]=ce(id,ig,"Landed (G: Takeoff)","warnings")end;local im=cr(a:getTargetGroundAltitude())gY[#gY+1]=ce(id,ih,"Hover Height: "..im,"warn")end;if a6 then gY[#gY+1]=ce(id,ii+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if c(ar-antigrav.getBaseAltitude())<501 then gY[#gY+1]=ce(id,ij+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gY[#gY+1]=ce(id,ij+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gY[#gY+1]=ce(id,ij+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gY[#gY+1]=ce(id,ij+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then gY[#gY+1]=ce(id,ij+20,"Follow Mode Engaged","warn")elseif Reentry then gY[#gY+1]=ce(id,ij+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local im=cr(HoldAltitude,2)if VertTakeOff then if by then im=cr(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gY[#gY+1]=ce(id,ij,"VTO to "..im,"warn")elseif AutoTakeoff and not IntoOrbit then if al then gY[#gY+1]=ce(id,ij,"Takeoff to "..AutopilotTargetName,"warn")else gY[#gY+1]=ce(id,ij,"Takeoff to "..im,"warn")end;if BrakeIsOn and not VertTakeOff then gY[#gY+1]=ce(id,ij+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gY[#gY+1]=ce(id,ij,"Altitude Hold: "..im,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if aq>0.1 then gY[#gY+1]=ce(id,ij+20,"Beginning ascent","warn")elseif aq<0.09 and aq>0.05 then gY[#gY+1]=ce(id,ij+20,"Aligning trajectory","warn")elseif aq<0.05 then gY[#gY+1]=ce(id,ij+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gY[#gY+1]=ce(id,ij,b9,"warn")end end;if IntruderAlertSystem and safeMass==-1 then gY[#gY+1]=ce(id,ij+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bw.."kg DETECTED","warnings")c1("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then gY[#gY+1]=ce(id,ij,"Brake-Landing","warnings")else gY[#gY+1]=ce(id,ij,"Coast-Landing","warnings")end end;if ProgradeIsOn then gY[#gY+1]=ce(id,ij,"Prograde Alignment","crit")end;if RetrogradeIsOn then gY[#gY+1]=ce(id,ij,"Retrograde Alignment","crit")end;if bM then local type;if string.find(bM,"COLLISION")then type="warnings"else type="crit"end;gY[#gY+1]=ce(id,ik+20,bM,type)elseif aq==0 then local bX,c0=bV(br:normalize())if c0~=nil then local im=cr(c0)local travelTime=aS.computeTravelTime(bs,0,c0)local io="Collision"if bX.noAtmosphericDensityAltitude>0 then io="Atmosphere"end;gY[#gY+1]=ce(id,ik+20,bX.name.." "..io.." "..cC(travelTime).." In "..im,"crit")end end;if VectorToTarget and not IntoOrbit then gY[#gY+1]=ce(id,ij+35,VectorStatus,"warn")end;gY[#gY+1]="</g>"return gY end;local function ip(eC)return d(y(eC*3.6,0)+0.5).." km/h"end;local function iq(gY)local ir=OrbitMapX;local is=OrbitMapY;local it=OrbitMapSize;local iu=4;local iv=15;local cf=0;local cg=0;local iw,ix,iy,iz;local function iA(type)local iB,C,eC,iC;if type=="Periapsis"then iB=orbit.periapsis.altitude;C=orbit.timeToPeriapsis;eC=orbit.periapsis.speed;iC=35 else iB=orbit.apoapsis.altitude;C=orbit.timeToApoapsis;eC=orbit.apoapsis.speed;iC=-35 end;gY[#gY+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cf+iC,cg-5,ir+it/2-iw+iz,cg-5)gY[#gY+1]=ce(cf,cg,type)cg=cg+iv;local im=cr(iB)gY[#gY+1]=ce(cf,cg,im)cg=cg+iv;gY[#gY+1]=ce(cf,cg,cC(C))cg=cg+iv;gY[#gY+1]=ce(cf,cg,ip(eC))end;if orbit~=nil and aq<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then is=is+iu;cf=ir+it+ir/2+iu;cg=is+it/2+5+iu;iw=it/4;iz=0;gY[#gY+1]=[[<g class="pbright txtorb txtmid">]]gY[#gY+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',it+ir*2,it+is,iu,iu)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iy=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iw*2)ix=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iy*(1-orbit.eccentricity)iz=iw-orbit.periapsis.altitude/iy-planet.radius/iy;local iD=""if orbit.periapsis.altitude<=0 then iD='redout'end;gY[#gY+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iD,ir+it/2+iz+iu,is+it/2+iu,iw,ix)gY[#gY+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ir+it/2+iu,is+it/2+iu,planet.radius/iy)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iA("Apoapsis")end;cg=is+it/2+5+iu;cf=ir-ir/2+10+iu;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iA("Periapsis")end;gY[#gY+1]=ce(ir+it/2+iu,planet.name,20+iu,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iE=orbit.timeToApoapsis/orbit.period*2*math.pi;local iF=iw*math.cos(iE)local iG=ix*math.sin(iE)gY[#gY+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ir+it/2+iF+iz+iu,is+it/2+iG+iu)end;gY[#gY+1]=[[</g>]]return gY else return gY end end;local function iH(gY)local cf=30;local cg=275;local iI={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iJ={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iK={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iL={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ap then c4(iI,iJ)table.insert(iI,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iI,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if an~=-1 then if antigrav then if by then table.insert(iI,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iI,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iI,"Alt-6: Begins Vertical Takeoff.")else table.insert(iI,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iI,"G: Begin BrakeLanding or Land")end else c4(iI,iK)end;if AltitudeHold then table.insert(iI,"Alt-Spacebar/Alt-C will raise/lower target height")end;c4(iI,iL)for i=1,#iI do cg=cg+12;gY[#gY+1]=ce(cf,cg,iI[i],"pdim txttick txtstart")end end;local function iM(iN,iO)local iP;local iQ=(iO-iN):normalize()local eH=(bv-iN):dot(iQ)/iQ:dot(iQ)if eH<=0.then return(bv-iN):len()elseif eH>=(iO-iN):len()then return(bv-iO):len()end;local iR=iN+eH*iQ;iP=(iR-bv):len()return iP end;local function iS()local iP;local iT=nil;local iU=nil;local iV=nil;for cL,iW in pairs(aM[0])do if iW.hasAtmosphere then local ai=iM(planet.center,iW.center)if iT==nil or ai<iT then iU=iW;iT=ai;iV=planet end;if ab and ab.hasAtmosphere and ab.name~=planet.name then local e1=iM(ab.center,iW.center)if e1<iT then iU=iW;iT=e1;iV=ab end end end end;local iX=gl(1770)local iY=gm(330)if iT then local iZ="txttick "local i_=500000;if iT<iU.radius+i_ or iT<iV.radius+i_ then if bH then iZ="txttick red "else iZ="txttick orange "end end;iP=cr(iT,2)bI=ce(iX,iY,"Pipe ("..iV.name.."--"..iU.name.."): "..iP,iZ.."pbright txtmid")end end;local j0={}function j0.HUDPrologue(gY)bH,gc=gj(bv)if not bH then G=PvPR;I=PvPG;H=PvPB else G=SafeR;I=SafeG;H=SafeB end;ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local j1=ax;local j2=ay;local j3=ax;local j4=ay;if gn()and not brightHud then j1=[[rgb(]]..d(G*0.4+0.5)..","..d(I*0.4+0.5)..","..d(H*0.3+0.5)..[[)]]j2=[[rgb(]]..d(G*0.3+0.5)..","..d(I*0.3+0.5)..","..d(H*0.2+0.5)..[[)]]end;gY[#gY+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],j1,j1,j3,j3,j2,j2,j4,j4,aF,aG)return gY end;function j0.DrawVerticalSpeed(gY,dl)gX(gY,dl)end;function j0.UpdateHud(gY)local hN=bB;local j5=bC;local h5=j5;local hk=hN;local i4=d(unit.getThrottle())local i9=bs*3.6;local i5=unit.getAxisCommandValue(0)local j6=gl(1770)local j7=gm(310)if AtmoSpeedAssist and bA then i5=J;i4=J*100 end;local gp=go()local h6="ROLL"if i4==nil then i4=0 end;if not bL then if bs>5 then hN=hM(bq)j5=hO(bq)else hN=0;j5=0 end;h6="YAW"end;if gc>50000 and not ap then local j8;j8=cr(gc)gY[#gY+1]=ce(j6,j7,"PvP Boundary: "..j8,"pbright txtbig txtmid")end;gY[#gY+1]=aj;gY[#gY+1]=aC;gY[#gY+1]=gq;if bI~=""then gY[#gY+1]=bI end;if gr~=""then gY[#gY+1]=gr end;gX(gY,ar)if l()==0 or RemoteHud then if not gn()or brightHud then if bL then h4(gY,centerX,centerY,h5,h6,bL)hj(gY,hk,h5,centerX,centerY,bL,d(hO(bq)),bs)else h4(gY,centerX,centerY,j5,h6,bL)hj(gY,hN,j5,centerX,centerY,bL,d(j5),bs)end;hq(gY,ar,bL)hP(gY,bq,bs,centerX,centerY)end end;i3(gY,gp,i4,i5)i8(gY,i9)ic(gY)iq(gY)if showHelp then iH(gY)end;return gY end;function j0.HUDEpilogue(gY)gY[#gY+1]="</svg>"return gY end;function j0.ExtraData(gY)local j9=gl(1240)local ja=gm(55)local jb=ja+10;local jc;local jd=0;local gp=go()if VertTakeOffEngine then gp=gp.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then gp=gp.."-COLLISION ON"end;if TurnBurn then gp="TB-"..gp end;if not stablized then gp=gp.."-DeCoupled"end;local je=vec3(core.getWorldAcceleration()):len()/9.80665;jc=core.g()gY[#gY+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j9=gl(1120)ja=gm(55)jb=ja+10 elseif ap then local jf=gl(770)gY[#gY+1]=ce(jf,ja,"ATMOSPHERE","pdim txt txtend")gY[#gY+1]=ce(jf,jb,e("%.2f",aq),"pdim txt txtend","")end;gY[#gY+1]=ce(j9,ja,"GRAVITY","pdim txt txtend")gY[#gY+1]=ce(j9,jb,e("%.2f",jc/9.80665),"pdim txt txtend")gY[#gY+1]=ce(j9,ja+20,"ACCEL","pdim txt txtend")gY[#gY+1]=ce(j9,jb+20,e("%.2f",je),"pdim txt txtend")gY[#gY+1]=ce(gl(960),gm(180),gp,"txtbig txtmid")end;function j0.DrawOdometer(gY,ac,TotalDistanceTravelled,ad)local jc;local jg=0;local jh=0;local jd=0;if ap then jd=LastMaxBrakeInAtmo else jd=LastMaxBrake end;maxThrust=a:maxForceForward()jc=core.g()if jc>0.1 then jh=au*jc;jg=maxThrust/jc end;gY[#gY+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gl(660),gl(700),gm(35),gl(960),gm(55),gl(1240),gm(35),gl(1280))if l()==0 or RemoteHud then gY[#gY+1]=ce(gl(700),gm(20),e("Trip: %.2f km",ac),"txtstart")gY[#gY+1]=ce(gl(700),gm(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gY[#gY+1]=ce(gl(830),gm(20),"Trip Time: "..cC(ad),"txtstart")gY[#gY+1]=ce(gl(830),gm(30),"Total Time: "..cC(TotalFlightTime),"txtstart")gY[#gY+1]=ce(gl(970),gm(20),e("Mass: %.2f Tons",au/1000),"txtstart")gY[#gY+1]=ce(gl(1240),gm(10),e("Max Brake: %.2f kN",jd/1000),"txtend")gY[#gY+1]=ce(gl(1240),gm(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if jc>0.1 then gY[#gY+1]=ce(gl(970),gm(30),e("Max Mass: %.2f Tons",jg/1000),"txtstart")gY[#gY+1]=ce(gl(1240),gm(20),e("Req Thrust: %.2f kN",jh/1000),"txtend")else gY[#gY+1]=ce(gl(970),gm(30),"Max Mass: n/a","txtstart")gY[#gY+1]=ce(gl(1240),gm(20),"Req Thrust: n/a","txtend")end end;gY[#gY+1]="</g>"return gY end;function j0.DrawWarnings(gY)return ic(gY)end;function j0.DisplayOrbitScreen(gY)return iq(gY)end;function j0.DisplayMessage(gY,im)if im~="empty"then local cg=310;for ji in string.gmatch(im,"([^\n]+)")do cg=cg+35;gY[#gY+1]=ce("50%",cg,ji,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function j0.DrawDeadZone(gY)gY[#gY+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function j0.UpdatePipe()if ap then bI=""return end;iS()end;function j0.DrawSettings(gY)if#bE>0 then local cf=gl(640)local cg=gm(200)gY[#gY+1]=[[<g class="pbright txtvspd txtstart">]]for cL,bQ in pairs(bE)do gY[#gY+1]=ce(cf,cg,bQ..": ".._G[bQ])cg=cg+20;if cL%12==0 then cf=cf+gl(350)cg=gm(200)end end;gY[#gY+1]=ce(gl(640),gm(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gY[#gY+1]="</g>"end;return gY end;local jj;local jk=gl(1770)local jl=gm(350)local jm=gm(15)local jn=gl(1370)local jo,jp;local jq=0;function j0.DrawRadarInfo()local function jr()if radarPanelID~=nil and jq==0 then r(radarPanelID)radarPanelID=nil;if jj~=nil then r(jj)jj=nil end else if jq==1 then r(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jj=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jq=0 end end;local f7,f8,f6,f9,fa,f3=aY.GetRadarHud()local z=f9 or 0;if f6>0 then if CollisionSystem then jo=z.."/"..fa.." Plotted : "..f6-fa.." Ignored"else jo="Radar Contacts: "..f6 end;gq=ce(jk,jl,jo,"pbright txtbig txtmid")if#f3>0 then gq=gq..ce(jn,jm,"Friendlies In Range","pbright txtbig txtmid")for cL,bQ in pairs(f3)do jm=jm+20;gq=gq..ce(jn,jm,radar_1.getConstructName(bQ),"pdim txtmid")end;f3={}end;if f7==nil and jj==nil then jq=1;jr()end;if f7~=nil and jj~=nil then jr()end;if radarPanelID==nil then jr()end else if f8 then gq=ce(jk,jl,"Radar: Jammed","pbright txtbig txtmid")else gq=ce(jk,jl,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jq=0;jr()end end end;function j0.DrawTanks()if fuelX~=0 and fuelY~=0 then gr=ce(fuelX,fuelY,"","txtstart pdim txtfuel")gH(fuelX,"Atmospheric ","ATMO",aH,gF,gG)gH(fuelX+120,"Space fuel t","SPACE",aI,gD,gE)gH(fuelX+240,"Rocket fuel ","ROCKET",aJ,gB,gC)end end;return j0 end;local function js()local function jt(position)local dg=sys:closestBody(position)if(position-dg.center):len()>dg.radius+dg.noAtmosphericDensityAltitude then dg=aM[0][0]end;return dg end;local function ju()local function jv(jw,jx)return jw.name<jx.name end;bG={}for cL,bQ in pairs(aM[0])do bG[#bG+1]={name=bQ.name,index=cL}end;table.sort(bG,jv)end;local function jy(jz)for cL,bQ in pairs(jz)do if bQ.name and bQ.name==CustomTarget.name then return cL end end;return-1 end;local function jA()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local jB=bG[AutopilotTargetIndex].index;local jC=aM[0][jB]if jC.center then AutopilotTargetName=jC.name;ab=aR[0][jB]if CustomTarget~=nil then if aq==0 then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end;if s(widgetTargetOrbitText,widgetTargetOrbit)~=1 then t(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jC;for _,bQ in pairs(aR[0])do if bQ.name==CustomTarget.planetname then ab=bQ;AutopilotTargetName=CustomTarget.name;break end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jD(h1)if not Autopilot and not VectorToTarget and not al and not IntoOrbit then if h1==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jA()else local jB=bG[AutopilotTargetIndex].index;local jC=aM[0][jB]if jC.name=="Space"or iphCondition=="Custom Only"and jC.center or iphCondition=="No Moons"and string.find(jC.name,"Moon")~=nil then if h1==nil then jD()else jD(1)end else jA()end end else a1="Disengage autopilot before changing Interplanetary Helper"c1("iph","AP")end end;local function jE()local fP=-1;fP=jy(aM[0])if fP>-1 then table.remove(aM[0],fP)end;fP=-1;fP=jy(SavedLocations)if fP~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fP)end;jD()ju()end;local function jF(bO,position,hJ,jG)if dbHud_1 or hJ then local dg=jt(position)local jc=dg.gravity;local jH=dg.atmosphericDensityAboveSurface;if jG then jH=aq;jc=unit.getClosestPlanetInfluence()end;local jI={position=position,name=bO,atmosphere=jH,planetname=dg.name,gravity=jc,safe=jG}if not hJ then SavedLocations[#SavedLocations+1]=jI else for cL,bQ in pairs(aM[0])do if bQ.name and bO==bQ.name then table.remove(aM[0],cL)end end end;table.insert(aM[0],jI)ju()jA()a1="Location saved as "..bO.."("..dg.name..")"else a1="Databank must be installed to save permanent locations"end end;local cM={}function cM.UpdateAtlasLocationsList()ju()end;function cM.UpdateAutopilotTarget()jA()end;function cM.adjustAutopilotTargetIndex(h1)jD(h1)end;function cM.findAtlasIndex(jz)jy(jz)end;function cM.UpdatePosition(jJ)local fP=jy(SavedLocations)if fP~=-1 then if jJ~=nil then SavedLocations[fP].name=jJ else local jK=SavedLocations[fP]jK.atmosphere=aq;jK.gravity=unit.getClosestPlanetInfluence()jK.position=bv;jK.safe=true end;a1=SavedLocations[fP].name.." position updated ("..SavedLocations[fP].planetname..")"else a1="Name Not Found"end end;function cM.AddNewLocation(bO,position,hJ,jG)jF(bO,position,hJ,jG)end;function cM.ClearCurrentPosition()jE()end;for cL,bQ in pairs(SavedLocations)do table.insert(aM[0],bQ)end;ju()cM.UpdateAutopilotTarget()return cM end;local function jL()local jM={}local function jN(eC)local jO=AutopilotEndSpeed;if not Autopilot then jO=0 end;if not ap then return aS.computeDistanceAndTime(eC,jO,au,0,0,LastMaxBrake-AutopilotPlanetGravity*au)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eC,jO,au,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*au)else return 0,0 end end end;local function jP(eC)local jO=AutopilotEndSpeed;if not Autopilot then jO=0 end;return aS.computeDistanceAndTime(eC,jO,au,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*au)end;local jQ=false;function jM.GetAutopilotBrakeDistanceAndTime(eC)return jN(eC)end;function jM.GetAutopilotTBBrakeDistanceAndTime(eC)return jP(eC)end;local function jR(jS,jT,jU)jT=jT:project_on_plane(jS)jU=jU:project_on_plane(jS)return m(jT:cross(jU):dot(jS),jT:dot(jU))end;local function jV()local function jW()local jX=-1;local jY=-1;if vBooster then jX=vBooster.distance()end;if hover then jY=hover.distance()end;if jX~=-1 and jY~=-1 then if jX<jY then return jX else return jY end elseif jX~=-1 then return jX elseif jY~=-1 then return jY else return-1 end end;local jZ=jW()local j_=-1;if telemeter_1 then j_=telemeter_1.getDistance()end;if jZ~=-1 and j_~=-1 then if jZ<j_ then return jZ else return j_ end elseif jZ~=-1 then return jZ else return j_ end end;local function k0(planet,dY,k1)local function k2(k3,de)local e3=vec3(de)if k3.bodyId==0 then return setmetatable({latitude=e3.x,longitude=e3.y,altitude=e3.z,bodyId=0,systemId=k3.planetarySystemId},MapPosition)end;local e4=e3-k3.center;local ai=e4:len()local dl=ai-k3.radius;local dj=0;local dk=0;if not co(ai,0)then local e5=m(e4.y,e4.x)dk=e5>=0 and e5 or 2*math.pi+e5;dj=math.pi/2-math.acos(e4.z/ai)end;return setmetatable({latitude=math.deg(dj),longitude=math.deg(dk),altitude=dl,bodyId=k3.bodyId,systemId=k3.planetarySystemId},MapPosition)end;local k4=k2(planet,dY)k4="::pos{"..k4.systemId..","..k4.bodyId..","..k4.latitude..","..k4.longitude..","..k4.altitude.."}"if k1 then return k4 else system.setWaypoint(k4)return true end end;local k5=false;function jM.showWayPoint(planet,dY,k1)return k0(planet,dY,k1)end;function jM.APTick()local function k6()if bN and not BrakeLanding then local b_=bN[1]local g3,g4=bN[2],bN[3]local k7=math.min(g3,g4 or g3)local k8=k7/bs;local k9=AutoTakeoff and(bs<42 or an~=-1)local ka=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if ka and not k9 and(a7*1.5>k7 or k8<1)then BrakeIsOn=true;ck(0)if AltitudeHold then cw()end;if LockPitch then ToggleLockPitch()end;a1="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cx()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if k8<11 then bM=b_.name.." COLLISION "..cC(k8).." / "..cr(k7,2)else bM=b_.name.." collision "..cC(k8)end;if k8<6 then c1("alarm","AL",2)end else bM=false end end;local function kb(bW,kc,kd)local function ke(bW,dK)bW=vec3(bW)dK=vec3(dK):normalize()local d0=bW*dK;return d0.x+d0.y+d0.z end;local kf=0.001;local kg=1;if not ap or not b2 or an~=-1 or bs<P then if kd==nil then kd=DampingMultiplier end;if kc==nil then kc=kf end;bW=vec3(bW):normalize()local kh=vec3()-bW;local ki=-ke(kh,core.getConstructWorldOrientationRight())*kg;local kj=-ke(kh,core.getConstructWorldOrientationUp())*kg;if aA==0 then aA=ki/2 end;if aB==0 then aB=kj/2 end;if c(ki)<0.1 then U=U-ki*2 else U=U-(ki+(ki-aA)*kd)end;if c(kj)<0.1 then T=T+kj*2 else T=T+kj+(kj-aB)*kd end;aA=ki;aB=kj;if c(ki)<kc and c(kj)<kc then return true end;return false elseif b2 and an==-1 then bW=br;if kd==nil then kd=DampingMultiplier end;if kc==nil then kc=kf end;bW=vec3(bW):normalize()local kh=bo-bW;local ki=-ke(kh,core.getConstructWorldOrientationRight())*kg;local kj=-ke(kh,core.getConstructWorldOrientationUp())*kg;if aA==0 then aA=ki/2 end;if aB==0 then aB=kj/2 end;if c(ki)<0.1 then U=U-ki*5 else U=U-(ki+(ki-aA)*kd)end;if c(kj)<0.1 then T=T+kj*5 else T=T+kj+(kj-aB)*kd end;aA=ki;aB=kj;if c(ki)<kc and c(kj)<kc then return true end;return false end end;ap=j()>0;aq=j()ar=core.getAltitude()an=jV()C=o()b3=C;bL=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k6()end;if antigrav then by=antigrav.getState()==1 end;local kk=1;local kl=1;local km=C-b3;local kn=-math.deg(jR(bn,br,bo))local ko=math.deg(jR(bp,br,bo))local h1=bt*-1;b2=ap and kn<-YawStallAngle or kn>YawStallAngle or ko<-PitchStallAngle or ko>PitchStallAngle;local kp=system.getMouseDeltaX()local kq=system.getMouseDeltaY()if InvertMouse and not a0 then kq=-kq end;U=0;Y=0;T=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if ar==0 then ar=(bv-planet.center):len()-planet.radius end;local jc=planet:getGravity(core.getConstructWorldPos()):len()*au;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if v()==0 then if l()==1 and a0 then if not aZ then af=af+kp;ag=ag+kq end else af=0;ag=0 end else af=af+kp;ag=ag+kq;ai=w(af*af+ag*ag)if not a0 and l()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then U=U-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then U=U-(af+DeadZone)*MouseXSensitivity else U=0 end;if ag>0 and ag>DeadZone then T=T-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then T=T-(ag+DeadZone)*MouseYSensitivity else T=0 end else af=0;ag=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(kq,-100,100)+0.5)*2*kk;U=(-utils.smoothstep(kp,-100,100)+0.5)*2*kl end end end end;local kr=bs>8334;if bs>SpaceSpeedLimit/3.6 and not ap and not Autopilot and not kr then a1="Space Speed Engine Shutoff reached"ck(0)end;if not kr and LastIsWarping then if not BrakeIsOn then cz()end;if Autopilot then cx()end end;LastIsWarping=kr;if ap and aq>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jQ then BrakeIsOn=true;jQ=true elseif not AtmoSpeedAssist and jQ then if bs<b7/3.6 then BrakeIsOn=false;jQ=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if ak then BrakeIsOn=false;local ks=false;if CustomTarget~=nil then ks=kb(CustomTarget.position-bv,0.1)else ks=kb(vec3(br),0.01)end;b0=true;if ks then cn(d(b7))if(c(bC)<2 or c(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;ak=false;am=true;Autopilot=false;cA()end elseif ap and AtmoSpeedAssist then ck(1)end elseif bs>P then kb(vec3(br),0.01)end end;if RetrogradeIsOn then if ap then RetrogradeIsOn=false elseif bs>P then kb(-vec3(br))end end;if not ProgradeIsOn and ak and not IntoOrbit then if aq==0 then Q=true;cA()ak=false;am=true else ak=false;cx()end end;if am and CustomTarget~=nil and(ar<HoldAltitude+250 and ar>HoldAltitude-250)and bs*3.6>b7-250 and c(bu)<25 and aq>=0.1 and(CustomTarget.position-bv):len()>2000+ar then cx()am=false end;if VertTakeOff then b0=true;local kt=HoldAltitude;if bu<-30 then a1="Unable to achieve lift. Safety Landing."ae=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then kt=antigrav.getBaseAltitude()end;if ar<kt-100 then b8=0;ae=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;ae=0 elseif bu<-30 then BrakeIsOn=true;ae=15 elseif ar>=kt then if by then if Autopilot or VectorToTarget then cu()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"c1("aggLk","AG")else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"c1("vtoc","VT")cu()end;ae=0 end else if aq>0.08 then b8=0;BrakeIsOn=false;ae=20 elseif aq<0.08 and aq>0 then BrakeIsOn=false;if bk then b8=0;ae=20 else ae=0;b8=36;cn(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=kt;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ku=p(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ku)local kv=p(vTpitchPID:get(),-1,1)T=kv end end;if IntoOrbit then local kh;local kw=false;local kx=cr(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ab end end;if not bf then bg=d(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=d(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kh=CustomTarget.position-bv end;local ky,kz=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local kA=bC;if not bc then local kB=false;local kC=false;ck(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kx;if be.VectorToTarget then kb(kh:normalize():project_on_plane(bt))kw=bo:dot(kh:project_on_plane(bn):normalize())>0.95 else kb(br)kw=kn<0.5;if bs<150 then kw=true end end;T=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kB=true else kB=false end;if kA<=bb+1 and kA>=bb-1 then kC=true else kC=false end;if kB and kC and kw then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then kb(kh:normalize():project_on_plane(bt))elseif bs>150 then kb(br)end;T=0;if be.VectorToTarget then local a7,_=aS.computeDistanceAndTime(bs,b7/3.6,au,0,0,LastMaxBrake)if bi and kh:len()>15000+a7+ar then b9="Orbiting to Target"if ar-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kh:len()<15000+a7+ar then a1="Orbit complete, proceeding with reentry"c1("orCom","OB")AutopilotTargetCoords=CustomTarget.position;Q=true;am=true;be.VectorToTarget,be.AutopilotAlign=false,false;cv()cA()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and ar>bg*0.9 and ar<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;ck(0)ba=0;if not be.VectorToTarget then a1="Orbit complete"c1("orCom","OB")cv()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kx;bd=true;cn(kz*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kD=bu;local kE=ar-bg;local kF=c(kE)if bu<10 and c(bB)<10 and kF<100 then kD=bu*2 end;if kD<10 and c(bB)<10 and kF<100 then kD=kD*2 end;if kD<5 and c(bB)<5 and kF<100 then kD=kD*4 end;VSpdPID:inject(kD)ba=p(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kE)ba=p(ba-p(OrbitAltPID:get(),-15,15),-90,90)end end else local kG=2.75;local kH=c(y(ky*kG))local kI=kH%50;if kI>0 then kH=kH-kI+50 end;BrakeIsOn=false;if ar<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..kx;ba=utils.map(bu,200,0,-15,80)elseif ar>=bg*0.8 and ar<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..kx;kH=kH*0.75;ba=utils.map(bu,100,-100,-15,65)elseif ar>=bg*1.15 and ar<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..kx;kH=kH*0.75;if bu<0 or bd then ba=utils.map(ar,bg*1.5,bg*1.01,-30,0)else ba=utils.map(ar,bg*0.99,bg*1.5,0,30)end elseif ar>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..kx;ba=-65;local kJ=utils.map(bu,-150,-400,1,0.55)kH=kH*kJ end;cn(d(kH))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kK=ba-bB;OrbitPitchPID:inject(kK)local kL=p(OrbitPitchPID:get(),-0.5,0.5)T=kL end end;if Autopilot and aq==0 and not ak then local function kM(jo,orbit)system.print(jo)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"ck(0)O=false;a1=jo;c1("apCom","AP")if orbit or ak then if orbit and AutopilotTargetOrbit~=nil and not ak then if not ar or ar==0 then return end;bg=ar;bf=true end;cv()end end;local kN,kO=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kP=(CustomTarget.position-ab.center):normalize()local kQ=kP:project_on_plane((ab.center-bv):normalize()):normalize()local kR=ab.center+kQ*(ab.radius+AutopilotTargetOrbit)local kS=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bv-kR):len()<(bv-kS):len()then kN=kR else kN=kS;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kN;aX.showWayPoint(ab,AutopilotTargetCoords)kO=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kO=true;TargetSet=true;AutopilotRealigned=true;kN=CustomTarget.position+(bv-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kP=(bv+br*100000-ab.center):normalize()local kQ=kP:project_on_plane((ab.center-bv):normalize()):normalize()if kQ:len()<1 then kP=(bv+bo*100000-ab.center):normalize()kQ=kP:project_on_plane((ab.center-bv):normalize()):normalize()end;kN=ab.center+kQ*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kN;TargetSet=true;kO=true;AutopilotRealigned=true;aX.showWayPoint(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kN)-bv):len()local bX,bY,bZ=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(b_)if b_.noAtmosphericDensityAltitude>0 then return b_.radius+b_.noAtmosphericDensityAltitude else return b_.radius+b_.surfaceMaxAltitude*1.5 end end)local c0=bY;if bZ~=nil and bY~=nil then c0=math.min(bZ,bY)end;if c0~=nil and c0<AutopilotDistance and bX.name==ab.name then AutopilotDistance=c0 end;local ks=true;local kT=(ab.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ab.radius;local im=cr(kT)s(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..im..'"}')local a7,a8;if not TurnBurn then a7,a8=jN(bs)else a7,a8=jP(bs)end;if bs>300 and AutopilotAccelerating then local kh=vec3(kN)-bv;local kU=p(math.deg(jR(bn,br:normalize(),kh:normalize()))*bs/500,-90,90)local kV=p(math.deg(jR(bp,br:normalize(),kh:normalize()))*bs/500,-90,90)if c(kU)<20 and c(kV)<20 then kU=kU*2;kV=kV*2 end;if c(kU)<2 and c(kV)<2 then kU=kU*2;kV=kV*2 end;local kn=-math.deg(jR(bn,bo,br:normalize()))local ko=-math.deg(jR(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kV-ko)local kW=p(apPitchPID:get(),-1,1)T=T+kW;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kU-kn)local kX=p(apYawPID:get(),-1,1)U=U+kX;kO=true;if c(kU)>2 or c(kV)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c1("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c1("apAcc","AP")end end end;if kT<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ab):escapeAndOrbitalSpeed(kT)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bX,c0=bV((AutopilotTargetCoords-bv):normalize())if ab.name~=planet.name then if bX~=nil then a1="Collision with "..bX.name.." in "..cr(c0).."\nClear LOS to continue."ah=5;k5=true else k5=false;a1=""end end end;if not k5 then if not AutopilotCruising and not AutopilotBraking and not kO then ks=kb((kN-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ks=kb(-vec3(br):normalize())end end;if AutopilotAccelerating then if not O then BrakeIsOn=false;ck(AutopilotInterplanetaryThrottle)J=y(AutopilotInterplanetaryThrottle,2)O=true end;local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J end;if bq:len()>=MaxGameVelocity or kY==0 and O then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c1("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;ck(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c1("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;ck(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then ck(1,true)end;local _,kz=aU(ab):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kh;if CustomTarget~=nil then kh=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kM("Autopilot complete, arrived at space location")BrakeIsOn=true;X=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=kz and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kM("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;aX.showWayPoint(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c1("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=kz then if CustomTarget~=nil then if br:normalize():dot(kh:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c1("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ab,CustomTarget.position)WaypointSet=true end else kM("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;aX.showWayPoint(ab,CustomTarget.position)WaypointSet=false end else kM("Autopilot completed, setting orbit",true)X=0 end end elseif AutopilotStatus=="Circularizing"then kM("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c1("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J end;if kY>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c1("apAcc","AP")end;AutopilotCruising=false end else if ks then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not ak then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif ks and not k5 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c1("apAcc","AP")end;if not O then ck(AutopilotInterplanetaryThrottle,true)J=y(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and aq>0)then a1="Autopilot complete, proceeding with reentry"c1("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;ck(0)O=false;ProgradeIsOn=true;ak=true;aX.showWayPoint(ab,CustomTarget.position)end;if Z then b0=true;local kV=0;local eG=bv+vec3(unit.getMasterPlayerRelativePosition())local kZ=eG-bv;local k_=vec3(kZ):project_on(bo):len()local l0=vec3(kZ):project_on(bp):len()local ai=w(k_*k_+l0*l0)kb(kZ:normalize())local l1=40;local l2=ai<l1;local l3=100;local l4=p((ai-l1)/2,10,l3)T=0;local ks=c(U)<0.1;if ks and bs<l4 and not l2 then BrakeIsOn=false;kV=-20 else BrakeIsOn=true;kV=0 end;local l5=0;if c(kV-bB)>l5 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kV-bB)local kW=pitchPID:get()T=kW end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l6=LastMaxBrakeInAtmo;if l6 then l6=l6*p(bs/100,0.1,1)*aq else l6=LastMaxBrake end;if aq<0.01 then l6=LastMaxBrake end;local l7=vec3(core.getWorldAirFrictionAcceleration())local l8=w(l7:len()-l7:project_on(h1):len())*au;if bs>100 then a7,a8=aS.computeDistanceAndTime(bs,100,au,0,0,l6+l8)local l9,la=aS.computeDistanceAndTime(100,0,au,0,0,l6/2)a7=a7+l9 else a7,a8=aS.computeDistanceAndTime(bs,0,au,0,0,l6/2)end;local lb=HoldAltitude-ar;local lc=500+bs;local ld=1;if AutoTakeoff then ld=p(bs/100,0.1,1)end;local kV=(utils.smoothstep(lb,-lc,lc)-0.5)*2*MaxPitch*ld;if not Reentry and not ak and not VectorToTarget and bo:dot(br:normalize())<0.99 then kV=(utils.smoothstep(lb,-lc*p(20-19*aq*10,1,20),lc*p(20-19*aq*10,1,20))-0.5)*2*MaxPitch*p(2-aq*10,1,2)*ld end;if not AltitudeHold then kV=0 end;if LockPitch~=nil then if bL and not IntoOrbit then kV=LockPitch else LockPitch=nil end end;b0=true;local le=T;if Reentry then local lf=d(b7)local lg,lh=aS.computeDistanceAndTime(bs,lf/3.6,au,0,0,LastMaxBrake-planet.gravity*9.8*au)local li=ar-(planet.noAtmosphericDensityAltitude+5000)if not bA and ar>planet.noAtmosphericDensityAltitude+5000 and bs<=lf/3.6 and bs>lf/3.6-10 and c(br:normalize():dot(bo))>0.9 then ck(0)elseif bA and bs>lf/3.6 and(lg>-1 and li<=lg or ar<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cn(lf,true)if not Q then kV=-80;if aq>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kV=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and ar>planet.noAtmosphericDensityAltitude+5000 then b0=true elseif ar<=planet.noAtmosphericDensityAltitude+5000 then cn(lf)if not bA and q:getTargetSpeed(axisCommandId.longitudinal)==b7 then Q=false;Reentry=false;b0=true end end end;if bs>P and not al and not VectorToTarget and not BrakeLanding and ForceAlignment then kb(vec3(br))end;if bJ or(VectorToTarget or al)and AutopilotTargetIndex>0 and aq>0.01 then local kh;if bJ then if type(bJ)=="table"then kh=bJ elseif bJ<3 and bJ>0 then kh=-bt:cross(br)*5000 elseif bJ>=3 then kh=bt:cross(br)*5000 elseif bJ<0 then kh=br*25000 end elseif CustomTarget~=nil then kh=CustomTarget.position-bv else kh=ab.center-bv end;local kU=math.deg(jR(bt:normalize(),br,kh))*2;local lj=math.rad(c(bC))if bs>minRollVelocity and aq>0.01 then local lk=p(90-kV*2,-90,90)b4=p(kU*2,-lk,lk)local ll=kU;kU=p(p(kU,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lj)+4*(bB-kV)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)kV=p(p(kV*math.cos(lj),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(p(c(ll)*math.sin(lj),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;kU=p(kU,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lm=kn-kU;if bJ and c(lm)<=0.0001 and(type(bJ)=="table"or type(bJ)~="table"and bJ<0 and c(bC)<1)then if bJ==-2 then cw()end;bJ=nil;c1("180Off","BR")return end;if not b2 and bs>minRollVelocity and aq>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lm)local kX=p(yawPID:get(),-1,1)U=U+kX elseif ap and an>-1 or bs<minRollVelocity then kb(kh)elseif b2 and aq>0.01 then if(kn<-YawStallAngle or kn>YawStallAngle)and aq>0.01 then kb(br)end;if(ko<-PitchStallAngle or ko>PitchStallAngle)and aq>0.01 then kV=p(bB-ko,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not al then local kt=planet:getAltitude(CustomTarget.position)local li=w(kh:len()^2-(ar-kt)^2)local ln=br:len()-c(bu)StrongBrakes=true;if not al and not Reentry and li<=a7+bs*km/2 and(br:project_on_plane(bt):normalize():dot(kh:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"ck(0)if AltitudeHold then cw()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(ln<0.1 or li<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<li)then if not by then c1("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bM=false end;LastDistanceToTarget=li end elseif VectorToTarget and aq==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(al or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local kh=CustomTarget.position-bv;local kt=planet:getAltitude(CustomTarget.position)local li=w(kh:len()^2-(ar-kt)^2)local l6=LastMaxBrakeInAtmo;if l6 then a7,a8=aS.computeDistanceAndTime(bs,0,au,0,0,l6/2)StrongBrakes=true;if li<=a7+bs*km/2 and br:project_on_plane(bt):normalize():dot(kh:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;ak=false;am=true;Autopilot=false;cA()end end;LastDistanceToTarget=li end end end;if aq==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(al or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cv()VectorToTarget=false;bc=true end end;if b2 and aq>0.01 and an==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then kb(br)kV=p(bB-ko,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;T=le;local j_=-1;if BrakeLanding then kV=0;local lo=false;local lp=30;if aT~=nil and aT>0 then local lq=p(aq,0.4,2)local l6=LastMaxBrakeInAtmo*p(bs/100,0.1,1)*lq;local lr=aT*lq+l6-jc;local ls=l6/2-jc;local lt=bs-w(c(ls/2)*20/(0.5*au))*utils.sign(ls)if lt<0 then lt=0 end;local lu;if bs>100 then local lv,_=aS.computeDistanceAndTime(bs,100,au,0,0,l6)local lw,_=aS.computeDistanceAndTime(100,0,au,0,0,w(l6))lu=lv+lw else lu=aS.computeDistanceAndTime(bs,0,au,0,0,w(l6))end;if lu<20 then BrakeIsOn=false else local lx=0;if lt>100 then local ly,_=aS.computeDistanceAndTime(lt,100,au,0,0,lr)local lz,_=aS.computeDistanceAndTime(100,0,au,0,0,aT*lq+w(l6)-jc)lx=ly+lz else lx,_=aS.computeDistanceAndTime(lt,0,au,0,0,aT*lq+w(l6)-jc)end;lx=(lx+15+bs*km)*1.1;local lA=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lA then local kt=planet:getAltitude(CustomTarget.position)local lB=ar-kt-100;local kh=CustomTarget.position-bv;local lC=w(kh:len()^2-(ar-kt)^2)if lC>100 then lA=false elseif lB<=lx or lx==-1 then BrakeIsOn=true;lo=true else BrakeIsOn=false;lo=true end end;if not lA and CalculateBrakeLandingSpeed then if lx>=lp then BrakeIsOn=true else BrakeIsOn=false end;lo=true end end end;if not bA then ck(0)end;q:setTargetGroundAltitude(500)q:activateGroundEngineAltitudeStabilization(500)stablized=true;j_=an;if j_>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if R then a.control.extendLandingGears()c1("grOut","LG",1)end;q:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-h1)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not lo then BrakeIsOn=true elseif not lo then BrakeIsOn=false end end;if AutoTakeoff or al then local bX,bZ,bY;if AutopilotTargetCoords~=nil then bX,bZ,bY=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(b_)return b_.radius+b_.noAtmosphericDensityAltitude end)end;if by then if ar>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;ck(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kV)<15 and ar/HoldAltitude>0.75 then AutoTakeoff=false;if not al then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif al and bs<P then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;ck(0)elseif al then ck(0)BrakeIsOn=true end elseif al and aq==0 and ab~=nil and(bX==nil or bX.name==ab.name)then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;if not bA then ck(0)end;AutopilotAccelerating=true end end;local lD=an>-1;local lE=bB;if(VectorToTarget or al or bJ)and not lD and bs>minRollVelocity and aq>0.01 then local lj=math.rad(c(bC))lE=bB*c(math.cos(lj))+ko*math.sin(lj)end;local lF=p(kV-lE,-PitchStallAngle*0.80,PitchStallAngle*0.80)if aq<0.01 and VectorToTarget then lF=p(kV-lE,-85,MaxPitch)elseif aq<0.01 then lF=p(kV-lE,-MaxPitch,MaxPitch)end;if c(bC)<5 or VectorToTarget or bJ or BrakeLanding or lD or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lF)local kW=pitchPID:get()T=T+kW end end;if antigrav~=nil and(antigrav and not ExternalAGG and ar<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;an=jV()return jM end;function script.onStart()local lG={}local lH={}local lI=false;local function lJ()local function lK(lL)local lM=dbHud_1.hasKey;for cL,bQ in pairs(lL)do if lM(bQ)then local d0=f(dbHud_1.getStringValue(bQ))if d0~=nil then _G[bQ]=d0;lI=true end end end end;if dbHud_1 then if not useTheseSettings then lK(c7())coroutine.yield()lK(b)else lK(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;lI=false end;coroutine.yield()if lI then a1="Loaded Saved Variables"aF=ResolutionX;aG=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ax=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]ay=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<C then LastMaxBrakeInAtmo=0 end;LastStartTime=C;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=au end;VectorStatus="Proceeding to Waypoint"end;local function lN()local function lO(lP,lQ)if lP>lQ then lQ=lP end;local lR,lS=0,0;if ContainerOptimization>0 then lR=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lS=FuelTankOptimization*0.05 end;lQ=lQ*(1-(lR+lS))return lQ end;local lT=core.getElementNameById;local lU=fuelX~=0 and fuelY~=0;for cL in pairs(as)do local type=core.getElementTypeById(as[cL])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(as[cL])),'^.*vertical.*$')then bx=true end end;if n(type,'^.*Space Engine$')then bl=true;if n(tostring(core.getElementTagsById(as[cL])),'^.*vertical.*$')then local lV=core.getElementRotationById(as[cL])if lV[4]<0 then if y(-lV[4],0.1)==0.5 then bj=true end else if y(lV[4],0.1)==0.5 then bk=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local lW=h(as[cL])if lW>10000 then E=128;F=110 elseif lW>1000 then E=64;F=55 elseif lW>150 then E=32;F=27 end end;aK=aK+h(as[cL])if lU and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lW=h(as[cL])local lX=k(as[cL])local lP=0;local gR=o()if type=="Atmospheric Fuel Tank"then local lQ=400;local lY=35.03;if lW>10000 then lQ=51200;lY=5480 elseif lW>1300 then lQ=6400;lY=988.67 elseif lW>150 then lQ=1600;lY=182.67 end;lP=lX-lY;if fuelTankHandlingAtmo>0 then lQ=lQ+lQ*fuelTankHandlingAtmo*0.2 end;lQ=lO(lP,lQ)aH[#aH+1]={as[cL],lT(as[cL]),lQ,lY,lP,gR}end;if type=="Rocket Fuel Tank"then local lQ=320;local lY=173.42;if lW>65000 then lQ=40000;lY=25740 elseif lW>6000 then lQ=5120;lY=4720 elseif lW>700 then lQ=640;lY=886.72 end;lP=lX-lY;if fuelTankHandlingRocket>0 then lQ=lQ+lQ*fuelTankHandlingRocket*0.1 end;lQ=lO(lP,lQ)aJ[#aJ+1]={as[cL],lT(as[cL]),lQ,lY,lP,gR}end;if type=="Space Fuel Tank"then local lQ=2400;local lY=182.67;if lW>10000 then lQ=76800;lY=5480 elseif lW>1300 then lQ=9600;lY=988.67 end;lP=lX-lY;if fuelTankHandlingSpace>0 then lQ=lQ+lQ*fuelTankHandlingSpace*0.2 end;lQ=lO(lP,lQ)aI[#aI+1]={as[cL],lT(as[cL]),lQ,lY,lP,gR}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function lZ()if gyro~=nil then aw=gyro.getState()==1 end;if not stablized then q:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then u(1)else u(0)end;if door and(ap or not ap and ar<10000)then for _,bQ in pairs(door)do bQ.toggle()end end;if switch then for _,bQ in pairs(switch)do bQ.toggle()end end;if forcefield and(ap or not ap==0 and ar<10000)then for _,bQ in pairs(forcefield)do bQ.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if an~=-1 or not ap and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if R then a.control.extendLandingGears()end else BrakeIsOn=false end;q:setTargetGroundAltitude(b1)if ap and an~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ap end;local function l_(m0,m1,m2,m3,cf,cg,m4,m5,m6,m7)local m8={enableName=m0,disableName=m1,width=m2,height=m3,x=cf,y=cg,toggleVar=m4,toggleFunction=m5,drawCondition=m6,hovered=false}if m7 then table.insert(lH,m8)else table.insert(lG,m8)end;return m8 end;local function m9(ma)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ma=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ma=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ma=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c7(ma)showHud=false else bE={}showHud=true end end;local function mb()bD=not bD;if bD then aE=lH;a1="Hold SHIFT to see Settings"bF=showHud else aE=lG;a1="Hold SHIFT to see Control Buttons"m9()showHud=bF end end;local function mc(bQ)_G[bQ]=not _G[bQ]if _G[bQ]then a1=bQ.." set to true"else a1=bQ.." set to false"end;if bQ=="showHud"then bF=_G[bQ]elseif bQ=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif bQ=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function md()local me=50;local mf=340;local cf=500;local cg=aG/2-400;local mg=0;for cL,bQ in pairs(c7("boolean"))do if type(_G[bQ])=="boolean"then l_(bQ,bQ,mf,me,cf,cg,function()return _G[bQ]end,function()mc(bQ)end,function()return true end,true)cg=cg+me+20;if mg==9 then cf=cf+mf+20;cg=aG/2-400;mg=0 else mg=mg+1 end end end;l_("Control View","Control View",mf,me,10,aG/2-500,function()return true end,mb,function()return true end,true)l_("View Handling Settings",'Hide Handling Settings',mf,me,10,aG/2-(500-me),function()return showHandlingVariables end,function()m9("handling")end,function()return true end,true)l_("View Hud Settings",'Hide Hud Settings',mf,me,10,aG/2-(500-me*2),function()return showHudVariables end,function()m9("hud")end,function()return true end,true)l_("View Physics Settings",'Hide Physics Settings',mf,me,10,aG/2-(500-me*3),function()return showPhysicsVariables end,function()m9("physics")end,function()return true end,true)end;local function mh()local function jF()local position=bv;local bO=planet.name..". "..#SavedLocations;if radar_1 then local du,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if du~=nil and du~=""then bO=bO.." "..radar_1.getConstructName(du)end end;return aW.AddNewLocation(bO,position,false,true)end;local function mi()TurnBurn=not TurnBurn end;local function mj(mk)if mk==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function ml()mj(1)end;local function mm()aW.UpdatePosition()end;local function jE()aW.ClearCurrentPosition()end;local function mn()local bO=AutopilotTargetName;if bO==nil then local im=cr((bv-CustomTarget.position):len())bO=CustomTarget.name.." "..im end;if bO==nil then bO="None"end;return"Engage Autopilot: "..bO end;local function mo()local bO=AutopilotTargetName;if bO==nil then bO=CustomTarget.name end;if bO==nil then bO="None"end;return"Disable Autopilot: "..bO end;local function mp()if safeMass>0 then a1="Safe Mass set to "..y(au,2).." kg"else a1="Intruder Detection reset\nSafe Mass set to "..y(au,2).." kg"ah=5;bw=0 end;safeMass=au end;local function mq()if l()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)c1("folOn","F")else c1("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()q:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local me=50;local mf=260;local mr=l_("Enable Brake Toggle","Disable Brake Toggle",mf,me,aF/2-mf/2,aG/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)l_("Align Prograde","Disable Prograde",mf,me,aF/2-mf/2-50-mr.width,aG/2-me+380,function()return ProgradeIsOn end,ml)l_("Align Retrograde","Disable Retrograde",mf,me,aF/2-mf/2+mr.width+50,aG/2-me+380,function()return RetrogradeIsOn end,mj,function()return aq==0 end)local ms=l_(mn,mo,600,60,aF/2-600/2,aG/2-60/2-400,function()return Autopilot end,cx)l_("Save Position","Save Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,jF,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)l_("Update Position","Update Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,mm,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)l_("Clear Position","Clear Position",200,ms.height,ms.x-200-30,ms.y,function()return true end,jE,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)me=60;mf=300;local cf=10;local cg=aG/2-500;l_("Show Help","Hide Help",mf,me,cf,cg,function()return showHelp end,function()showHelp=not showHelp end)cg=cg+me+20;l_("View Settings","View Settings",mf,me,cf,cg,function()return true end,mb)local cg=aG/2-300;l_("Enable Turn and Burn","Disable Turn and Burn",mf,me,cf,cg,function()return TurnBurn end,mi)l_("Horizontal Takeoff Mode","Vertical Takeoff Mode",mf,me,cf+mf+20,cg,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bx end)cg=cg+me+20;l_("Show Orbit Display","Hide Orbit Display",mf,me,cf,cg,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)l_("Engage Orbiting","Cancel Orbiting",mf,me,cf+mf+20,cg,function()return IntoOrbit end,cv,function()return aq==0 and bL end)cg=cg+me+20;l_("Glide Re-Entry","Cancel Glide Re-Entry",mf,me,cf,cg,function()return Reentry end,function()ak=true;ml()end,function()return planet.hasAtmosphere and not ap end)l_("Parachute Re-Entry","Cancel Parachute Re-Entry",mf,me,cf+mf+20,cg,function()return Reentry end,cA,function()return planet.hasAtmosphere and not ap end)cg=cg+me+20;l_("Engage Follow Mode","Disable Follow Mode",mf,me,cf,cg,function()return Z end,mq,function()return l()==1 end)l_("Enable Repair Arrows","Disable Repair Arrows",mf,me,cf+mf+20,cg,function()return aL end,function()aL=not aL;if aL then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return l()==1 end)cg=cg+me+20;if not ExternalAGG then l_("Enable AGG","Disable AGG",mf,me,cf,cg,function()return by end,cB,function()return antigrav~=nil end)end;l_("Reset Intruder Alert","Set Safe Mass",mf,me,cf+mf+20,cg,function()return safeMass>0 end,mp,function()return IntruderAlertSystem end)cg=cg+me+20;l_(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mf*2,me,cf,cg,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a1="IPH Mode: "..iphCondition end)cg=cg+me+20;l_(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mf*2,me,cf,cg,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a1="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()Logs=Logger()_logCompute=Logs.CreateLog("Computation","time")q:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lJ()coroutine.yield()lN()coroutine.yield()aX=jL()lZ()md()mh()aE=lG;coroutine.yield()aM=cM()aQ=cN()aR=aQ(cM())aS=e9()aU=eE()aY=f1()aV=gb()aW=js()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)c1("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(aq>0 or aq==0 and ar<10000)then for _,bQ in pairs(door)do bQ.toggle()end end;if switch then for _,bQ in pairs(switch)do bQ.toggle()end end;if forcefield and(aq>0 or aq==0 and ar<10000)then for _,bQ in pairs(forcefield)do bQ.toggle()end end;safeMass=au;cH()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;c1("stop","SU")for _,cU in pairs(Logs.getLogs())do system.print(cU)end end;function script.onTick(mt)local mu=nil;if mt=="contact"then if not contactTimer then contactTimer=0 end;if C>contactTimer+10 then a1="Radar Contact"c1("rdrCon","RC")contactTimer=C end;unit.stopTimer("contact")elseif mt=="tenthSecond"then local function mv()local mw=system.createData;local mx=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mx(panelInterplanetary,"value")interplanetaryHeaderText=mw('{"label": "Target Planet", "value": "N/A", "unit":""}')t(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mx(panelInterplanetary,"value")widgetDistanceText=mw('{"label": "distance", "value": "N/A", "unit":""}')t(widgetDistanceText,widgetDistance)widgetTravelTime=mx(panelInterplanetary,"value")widgetTravelTimeText=mw('{"label": "Travel Time", "value": "N/A", "unit":""}')t(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mx(panelInterplanetary,"value")widgetMaxMassText=mw('{"label": "Maximum Mass", "value": "N/A", "unit":""}')t(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mx(panelInterplanetary,"value")widgetTargetOrbitText=mw('{"label": "Target Altitude", "value": "N/A", "unit":""}')t(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mx(panelInterplanetary,"value")widgetCurBrakeDistanceText=mw('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mx(panelInterplanetary,"value")widgetCurBrakeTimeText=mw('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mx(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mw('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mx(panelInterplanetary,"value")widgetMaxBrakeTimeText=mw('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mx(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mw('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ap then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)t(widgetCurBrakeTimeText,widgetCurBrakeTime)t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function my()r(panelInterplanetary)panelInterplanetary=nil end;local function mz()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eC=bs;local kY=unit.getThrottle()/100;if AtmoSpeedAssist then kY=J end;local mA,mB=aS.computeDistanceAndTime(bs,MaxGameVelocity,au,a:maxForceForward()*kY,warmup,0)local a7,a8;if not TurnBurn then a7,a8=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mC;if not TurnBurn and eC>0 then _,mC=aX.GetAutopilotBrakeDistanceAndTime(eC)else _,mC=aX.GetAutopilotTBBrakeDistanceAndTime(eC)end;local mD=0;local mE=0;if AutopilotCruising or not Autopilot and eC>5 then mE=aS.computeTravelTime(eC,0,AutopilotDistance)elseif a7+mA<AutopilotDistance then mD=AutopilotDistance-(a7+mA)mE=aS.computeTravelTime(8333.0556,0,mD)else local mF=(AutopilotDistance-a7)/mA;mA=AutopilotDistance-a7;mB=mB*mF end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mE elseif AutopilotBraking then return mC elseif AutopilotCruising then return mE+mC else return mB+a8+mE end end;local function mG(jc,mH)if jc==nil then jc=core.g()end;jc=y(jc,5)if mH~=nil and mH or(mu==nil or mu~=jc)then local eC=bq:len()local mI=f(unit.getData()).maxBrake;if mI~=nil and mI>0 and ap then mI=mI/p(eC/100,0.1,1)mI=mI/aq;if aq>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mI)/2 else LastMaxBrakeInAtmo=mI end end end;if mI~=nil and mI>0 then LastMaxBrake=mI end;mu=jc end end;mG(nil,true)if aq>0 and not WasInAtmo then if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry)then ck(1)N=false end end;if bz~=nil then if q:getTargetSpeed(axisCommandId.longitudinal)~=bz then cn(bz,TRUE)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mv()end;if AutopilotTargetName~=nil then local mJ=CustomTarget~=nil;local mK=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()s(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mz()if mJ and not Autopilot then ai=(bv-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a7,a8=aX.GetAutopilotBrakeDistanceAndTime(bs)a9,aa=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=aX.GetAutopilotTBBrakeDistanceAndTime(bs)a9,aa=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local im=cr(ai)s(widgetDistanceText,'{"label": "distance", "value": "'..im..'"}')s(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cC(travelTime)..'", "unit":""}')im=cr(a7)s(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..im..'"}')s(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cC(a8)..'", "unit":""}')im=cr(a9)s(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..im..'"}')s(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cC(aa)..'", "unit":""}')s(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mK/1000)..'", "unit":" Tons"}')im=cr(AutopilotTargetOrbit)s(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..im..'"}')if aq>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if aq==0 and WasInAtmo then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else my()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()elseif mt=="oneSecond"then local function mL(gY)local mM=0;aC=""local mN=aK;local mO=0;local mP=0;local mQ=0;local gV=0;local gW=""local mR=core.getElementHitPointsById;for cL in pairs(as)do local lW=0;local mS=0;mS=h(as[cL])lW=mR(as[cL])mO=mO+lW;if lW<mS then if lW==0 then mQ=mQ+1 else mP=mP+1 end;if aL and#az==0 then position=vec3(core.getElementPositionById(as[cL]))local cf=position.x-E;local cg=position.y-E;local fw=position.z-E;table.insert(az,core.spawnArrowSticker(cf,cg,fw+1,"down"))table.insert(az,core.spawnArrowSticker(cf,cg,fw+1,"down"))core.rotateSticker(az[2],0,0,90)table.insert(az,core.spawnArrowSticker(cf+1,cg,fw,"north"))table.insert(az,core.spawnArrowSticker(cf+1,cg,fw,"north"))core.rotateSticker(az[4],90,90,0)table.insert(az,core.spawnArrowSticker(cf-1,cg,fw,"south"))table.insert(az,core.spawnArrowSticker(cf-1,cg,fw,"south"))core.rotateSticker(az[6],90,-90,0)table.insert(az,core.spawnArrowSticker(cf,cg-1,fw,"east"))table.insert(az,core.spawnArrowSticker(cf,cg-1,fw,"east"))core.rotateSticker(az[8],90,0,90)table.insert(az,core.spawnArrowSticker(cf,cg+1,fw,"west"))table.insert(az,core.spawnArrowSticker(cf,cg+1,fw,"west"))core.rotateSticker(az[10],-90,0,90)table.insert(az,as[cL])end elseif aL and#az>0 and az[11]==as[cL]then for gQ in pairs(az)do core.deleteSticker(az[gQ])end;az={}end end;mM=d(mO/mN*100)if mM<100 then gY[#gY+1]=ce(0,0,"","pbright txt")gV=d(mM*2.55)gW=e("rgb(%d,%d,%d)",255-gV,gV,0)if mM<100 then gY[#gY+1]=ce("50%",1035,"Elemental Integrity: "..mM.."%","txtbig txtmid","fill:"..gW)if mQ>0 then gY[#gY+1]=ce("50%",1055,"Disabled Modules: "..mQ.." Damaged Modules: "..mP,"txtbig txtmid","fill:"..gW)elseif mP>0 then gY[#gY+1]=ce("50%",1055,"Damaged Modules: "..mP,"txtbig txtmid","fill:"..gW)end end end end;local function mT()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then r(WeaponPanelID)WeaponPanelID=nil end end end;local function mU()local gR=o()local i9=bs;local mV=gR-at;if i9>1.38889 then i9=i9/1000;local mW=i9*(gR-at)TotalDistanceTravelled=TotalDistanceTravelled+mW;ac=ac+mW end;ad=ad+mV;TotalFlightTime=TotalFlightTime+mV;at=gR end;local function mX()if safeMass>0 then if au>safeMass+50 then bw=d(au-safeMass)safeMass=-1 elseif au<safeMass then safeMass=au end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mX()end;mU()aV.UpdatePipe()mT()local gY={}aV.ExtraData(gY)if ShowOdometer then gY=aV.DrawOdometer(gY,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then mL(gY)end;aj=table.concat(gY,"")collectgarbage("collect")elseif mt=="fiveSecond"then if not UseSatNav then return end;ao=dbHud_1.getStringValue("SPBAutopilotTargetName")if ao~=nil and ao~=""and ao~="SatNavNotChanged"then local d0=f(dbHud_1.getStringValue("SavedLocations"))if d0~=nil then _G["SavedLocations"]=d0;local fP=-1;local jI;for cL,bQ in pairs(SavedLocations)do if bQ.name and bQ.name=="SatNav Location"then fP=cL;break end end;if fP~=-1 then jI=SavedLocations[fP]fP=-1;for cL,bQ in pairs(aM[0])do if bQ.name and bQ.name=="SatNav Location"then fP=cL;break end end;if fP>-1 then aM[0][fP]=jI end;aW.UpdateAtlasLocationsList()a1=jI.name.." position updated"end end;for i=1,#bG do if bG[i].name==ao then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mt=="msgTick"then local gY={}aV.DisplayMessage(gY,"empty")a1="empty"unit.stopTimer("msgTick")ah=3 elseif mt=="animateTick"then a_=true;aZ=false;af=0;ag=0;unit.stopTimer("animateTick")elseif mt=="hudTick"then local function mY(gY)local mZ=d(p(ai/(aF/4)*255,0,255))gY[#gY+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(G+0.5)+mZ,d(I+0.5)-mZ,d(H+0.5)-mZ)end;local function m_()for _,bQ in pairs(aE)do if bQ.hovered then if not bQ.drawCondition or bQ.drawCondition()then bQ.toggleFunction()end;bQ.hovered=false end end end;local function n0()local function n1(n2,n3,cf,cg,m2,m3)if n2>cf and n2<cf+m2 and n3>cg and n3<cg+m3 then return true else return false end end;local cf=af+aF/2;local cg=ag+aG/2;for _,bQ in pairs(aE)do bQ.hovered=n1(cf,cg,bQ.x,bQ.y,bQ.width,bQ.height)end end;local function n4(gY)local function n5(gY,n6,hover,cf,cg,ev,n7,n8,n9,na,nb)if type(na)=="function"then na=na()end;if type(nb)=="function"then nb=nb()end;gY[#gY+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cf,cg,ev,n7)if n6 then gY[#gY+1]=e("%s'",n8)else gY[#gY+1]=n9 end;if hover then gY[#gY+1]=" style='stroke:white; stroke-width:2'"else gY[#gY+1]=" style='stroke:black; stroke-width:1'"end;gY[#gY+1]="></rect>"gY[#gY+1]=e("<text x='%f' y='%f' font-size='24' fill='",cf+ev/2,cg+n7/2+5)if n6 then gY[#gY+1]="black"else gY[#gY+1]="white"end;gY[#gY+1]="' text-anchor='middle' font-family='Montserrat'>"if n6 then gY[#gY+1]=e("%s</text>",na)else gY[#gY+1]=e("%s</text>",nb)end end;local nc="rgb(50,50,50)'"local nd="rgb(210,200,200)"local ne=n5;for _,bQ in pairs(aE)do local m1=bQ.disableName;local m0=bQ.enableName;if type(m1)=="function"then m1=m1()end;if type(m0)=="function"then m0=m0()end;if not bQ.drawCondition or bQ.drawCondition()then ne(gY,bQ.toggleVar(),bQ.hovered,bQ.x,bQ.y,bQ.width,bQ.height,nd,nc,m1,m0)end end end;local nf=y(ResolutionX/2,0)local ng=y(ResolutionY/2,0)local gY={}local nh=system.getTime()aV.HUDPrologue(gY)if showHud then local nh=system.getTime()aV.UpdateHud(gY)_logCompute.addValue(system.getTime()-nh)else if AlwaysVSpd then aV.DrawVerticalSpeed(gY,ar)end;aV.DisplayOrbitScreen(gY)aV.DrawWarnings(gY)end;if bD and bE~={}then aV.DrawSettings(gY)end;if radar_1 then aV.DrawRadarInfo()end;aV.HUDEpilogue(gY)gY[#gY+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aF,aG)if a1~="empty"then aV.DisplayMessage(gY,a1)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gY)end end;if v()==0 then if l()==1 and a0 then if not AltIsOn then n0()n4(gY)end;if not aZ and not a_ then local ni=table.concat(gY,"")gY={}gY[#gY+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aF,aG)gY[#gY+1]=ni;gY[#gY+1]="</body>"aZ=true;gY[#gY+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gY,"")system.setScreen(content)elseif a_ then local ni=table.concat(gY,"")gY={}gY[#gY+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aF,aG)gY[#gY+1]=ni;gY[#gY+1]="</body>"end;if not aZ then gY[#gY+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,af,ag)end else m_()end else if not a0 and l()==0 then m_()if ai>DeadZone then if DisplayDeadZone then mY(gY)end end elseif not AltIsOn or AltIsOn and a0 then n0()n4(gY)end;gY[#gY+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nf,ng,af,ag)end;gY[#gY+1]=[[</svg></body>]]content=table.concat(gY,"")elseif mt=="apTick"then aX.APTick()elseif mt=="radarTick"then aY.UpdateRadar()end end;function script.onFlush()local function nj(nk,l4)local nl=vec3()local nm=vec3()if nk==axisCommandId.longitudinal then nl=vec3(core.getConstructOrientationForward())nm=bo elseif nk==axisCommandId.vertical then nl=vec3(core.getConstructOrientationUp())nm=bn elseif nk==axisCommandId.lateral then nl=vec3(core.getConstructOrientationRight())nm=bp else return vec3()end;local nn=vec3(core.getWorldGravity())local no=nn:dot(nm)local np=vec3(core.getWorldAirFrictionAcceleration())local nq=np:dot(nm)local nr=bq:dot(nl)local ns=l4*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(ns-nr)local nt=targetSpeedPID2:get()local nu=(nt-nq-no)*nm;return nu end;local function nw(nk,l4)local nl=vec3()local nm=vec3()if nk==axisCommandId.longitudinal then nl=vec3(core.getConstructOrientationForward())nm=bo elseif nk==axisCommandId.vertical then nl=vec3(core.getConstructOrientationUp())nm=bn elseif nk==axisCommandId.lateral then nl=vec3(core.getConstructOrientationRight())nm=bp else return vec3()end;local nn=vec3(core.getWorldGravity())local no=nn:dot(nm)local np=vec3(core.getWorldAirFrictionAcceleration())local nq=np:dot(nm)local nr=bq:dot(nl)local ns=l4*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(ns-nr)local nt=targetSpeedPID:get()local nu=(nt-nq-no)*nm;return nu end;local function nx(ny,h0,jx)local nz=ny:cross(jx):normalize_inplace()local hN=math.acos(p(nz:dot(-h0),-1,1))*constants.rad2deg;if nz:cross(-h0):dot(jx)<0 then hN=-hN end;return hN end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=q:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and N then ck(0)N=false elseif not bA and not N then J=0;N=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local nA=p(S+T+system.getControlDeviceForwardInput(),-1,1)local nB=p(V+Y+system.getControlDeviceYawInput(),-1,1)local nC=p(W+U-system.getControlDeviceLeftRightInput(),-1,1)local nD=X;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())au=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local nE=bC/180*math.pi;local nF=math.cos(nE)local nG=math.sin(nE)bB=nx(bt,bo,bp*nF+bn*nG)local nH=br:normalize()local nI=c(bC)local nJ=utils.sign(bC)local nK=vec3(core.getWorldAngularVelocity())local nL=nA*pitchSpeedFactor*bp+nB*rollSpeedFactor*bo+nC*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local nM=c(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or ak or AltitudeHold or IntoOrbit)and nM>0 or aq>0.0 and nM<autoRollRollThreshold and autoRollPreference)and nB==0 and c(bB)<85 then local nN=b4;local nO=autoRollFactor;if aq==0 then nO=nO/4;b4=0;nN=0 end;if rollPID==nil then rollPID=pid.new(nO*0.01,0,nO*0.1)end;rollPID:inject(nN-bC)local nP=rollPID:get()nL=nL+nP*bo end end;if bt:len()>0.01 and aq>0.0 then local nQ=20.0;if turnAssist==true and nI>nQ and nA==0 and nC==0 then local nR=turnAssistFactor*0.1;local nS=turnAssistFactor*0.025;local nT=(nI-nQ)/(180-nQ)*180;local nU=0;if nT<90 then nU=nT/90 elseif nT<180 then nU=(180-nT)/90 end;nU=nU*nU;local nV=-nJ*nS*(1.0-nU)local nW=nR*nU;nL=nL+nW*bp+nV*bn end end;local nX=1;local nY=0;local nZ=1;if system.getMouseWheel()>0 then if AltIsOn then if aq>0 or Reentry then b7=p(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif av then local n_=J;J=y(p(J+speedChangeLarge/100,-1,1),2)if J>=0 and n_<0 then J=0;av=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if aq>0 or Reentry then b7=p(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif av then local n_=J;J=y(p(J-speedChangeLarge/100,-1,1),2)if J<=0 and n_>0 then J=0;av=false end end else av=true end;K=0;if ap and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local o0=throttlePID:get()M=p(o0,-1,1)if M<J and aq>0.005 then L=true;q:setThrottleCommand(axisCommandId.longitudinal,p(M,0.01,1))else L=false;q:setThrottleCommand(axisCommandId.longitudinal,J)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local o1=p(brakePID:get(),0,1)if aq>0 and bu<-80 or aq>0.005 then K=o1 end;if K>0 then if L and M==0.01 then q:setThrottleCommand(axisCommandId.longitudinal,0)end else M=p(M,0.01,1)end;local o2=''local o3=vec3()local o4=nj(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o4,nY)local o5='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o5=o5 ..ExtraLongitudeTags end;local o6=q:getAxisCommandType(axisCommandId.longitudinal)local o7=q:composeAxisAccelerationFromThrottle(o5,axisCommandId.longitudinal)local o8=nw(axisCommandId.lateral,LeftAmount*1000)o2=o2 ..' , '.."lateral airfoil , lateral ground "o3=o3+o8;if o3:len()>constants.epsilon then a:setEngineForceCommand(o2,o3,nY,'','','',nZ)end;a:setEngineForceCommand(o5,o7,nX)local o9='thrust analog vertical fueled 'local oa='thrust analog lateral fueled 'if ExtraLateralTags~="none"then oa=oa..ExtraLateralTags end;if ExtraVerticalTags~="none"then o9=o9 ..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o9,o4,nX)else a:setEngineForceCommand(o9,vec3(),nX)end;if LeftAmount~=0 then a:setEngineForceCommand(oa,o8,nX)else a:setEngineForceCommand(oa,vec3(),nX)end;if nD==0 then nD=K end;local ob=-nD*(brakeSpeedFactor*br+brakeFlatFactor*nH)a:setEngineForceCommand('brake',ob)else if AtmoSpeedAssist then q:setThrottleCommand(axisCommandId.longitudinal,J)end;local l4=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-l4/3.6)local o1=p(brakePID:get(),0,1)nD=p(nD+o1,0,1)end;local ob=-nD*(brakeSpeedFactor*br+brakeFlatFactor*nH)a:setEngineForceCommand('brake',ob)local o2=''local o3=vec3()local oc=false;local o5='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o5=o5 ..ExtraLongitudeTags end;local o6=q:getAxisCommandType(axisCommandId.longitudinal)if o6==axisCommandType.byThrottle then local o7=q:composeAxisAccelerationFromThrottle(o5,axisCommandId.longitudinal)a:setEngineForceCommand(o5,o7,nX)elseif o6==axisCommandType.byTargetSpeed then local o7=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)o2=o2 ..' , '..o5;o3=o3+o7;if q:getTargetSpeed(axisCommandId.longitudinal)==0 or q:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-q:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then oc=true end end;local oa='thrust analog lateral 'if ExtraLateralTags~="none"then oa=oa..ExtraLateralTags end;local od=q:getAxisCommandType(axisCommandId.lateral)if od==axisCommandType.byThrottle then local oe=q:composeAxisAccelerationFromThrottle(oa,axisCommandId.lateral)a:setEngineForceCommand(oa,oe,nX)elseif od==axisCommandType.byTargetSpeed then local o8=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)o2=o2 ..' , '..oa;o3=o3+o8 end;local o9='thrust analog vertical 'if ExtraVerticalTags~="none"then o9=o9 ..ExtraVerticalTags end;local of=q:getAxisCommandType(axisCommandId.vertical)if of==axisCommandType.byThrottle then local o4=q:composeAxisAccelerationFromThrottle(o9,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o9,o4,nX,'airfoil','ground','',nZ)else a:setEngineForceCommand(o9,vec3(),nX)a:setEngineForceCommand('airfoil vertical',o4,nX,'airfoil','','',nZ)a:setEngineForceCommand('ground vertical',o4,nX,'ground','','',nZ)end elseif of==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),nX)end;local og=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)o2=o2 ..' , '..o9;o3=o3+og end;if o3:len()>constants.epsilon then if X~=0 or oc or c(nH:dot(bo))<0.8 then o2=o2 ..', brake'end;a:setEngineForceCommand(o2,o3,nY,'','','',nZ)end end;local oh=torqueFactor*(nL-nK)local oi=vec3(core.getWorldAirFrictionAngularAcceleration())oh=oh-oi;a:setEngineTorqueCommand('torque',oh,nX,'airfoil','','',nZ)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local eC=bq:len()local oj=0.15;if not bA then local ok=q:getTargetSpeed(axisCommandId.longitudinal)if eC*3.6>ok*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eC*3.6<ok*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kY=unit.getThrottle()if AtmoSpeedAssist then kY=J*100 end;local l4=kY/100;if j==0 then l4=l4*MaxGameVelocity;if eC>=l4*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eC<l4*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lf=d(b7)l4=l4*lf/3.6;if eC>=l4*(1-oj)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eC<l4*(1-oj)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g9=coroutine.status(beginSetup)if g9=="suspended"then local cl,ga=coroutine.resume(beginSetup)if ga then system.print("ERROR STARTUP: "..ga)end elseif g9=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(ol)local function om(on)local B=1;local function oo(op,on)local oq={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local os=op;for _,bQ in ipairs(oq)do if on and os>bQ then op=bQ elseif op<bQ and not on then op=bQ;break end end;return op end;if on then B=-1 end;if not ExternalAGG and by then if a0 and on then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a0 then bg=oo(bg,on)else bg=bg+B*a2 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a0 and ap then HoldAltitude=oo(HoldAltitude,on)else HoldAltitude=HoldAltitude+B*a2 end end else q:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function ot(on)local B=1;if on then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=p(J+B*speedChangeLarge/100,-1,1)else q:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if on then B=1 else B=nil end;aW.adjustAutopilotTargetIndex(B)end end;local function ou(ov)if not ap then a1="Flight Assist in Atmo only"return end;local cS=type(ov)if bJ==nil then if cS=="table"then if Autopilot or VectorToTarget then cx()end;c1("180On","BR")elseif ov==1 then c1("bnkLft","BR")else c1("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cw()if cS~="table"then ov=ov+1 end end;bJ=ov else c1("180Off","BR")bJ=nil end end;if ol=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;ck(0)if vBooster or hover then if ap and an==-1 then c1("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if R then c1("grOut","LG",1)a.control.extendLandingGears()end;q:setTargetGroundAltitude(LandingGearGroundHeight)if ap then BrakeIsOn=true end end end;if R and not BrakeLanding and not(vBooster or hover)then c1("grOut","LG",1)a.control.extendLandingGears()end else if R then c1("grIn","LG",1)a.control.retractLandingGears()end;q:setTargetGroundAltitude(TargetHoverHeight)end elseif ol=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ol=="forward"then S=S-1 elseif ol=="backward"then if AltIsOn then ou(-br*5000)else S=S+1 end elseif ol=="left"then if AltIsOn then ou(1)else V=V-1 end elseif ol=="right"then if AltIsOn then ou(3)else V=V+1 end elseif ol=="yawright"then W=W-1 elseif ol=="yawleft"then W=W+1 elseif ol=="straferight"then q:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ol=="strafeleft"then q:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ol=="up"then ae=ae+1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ol=="down"then ae=ae-1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ol=="groundaltitudeup"then om()elseif ol=="groundaltitudedown"then om(true)elseif ol=="option1"then aW.adjustAutopilotTargetIndex()toggleView=false elseif ol=="option2"then aW.adjustAutopilotTargetIndex(1)toggleView=false elseif ol=="option3"then local function ow()aD=not aD;if not aD then c1("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else c1("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then r(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then r(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then r(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ow()toggleView=false elseif ol=="option4"then bJ=nil;cx()toggleView=false elseif ol=="option5"then function ToggleLockPitch()if LockPitch==nil then c1("lkPOn","LP")if not a0 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c1("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif ol=="option6"then cw()toggleView=false elseif ol=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a1="Collision System Enabled"else a1="Collision System Secured"end;toggleView=false elseif ol=="option8"then stablized=not stablized;if not stablized then a1="DeCoupled Mode - Ground Stabilization off"q:deactivateGroundEngineAltitudeStabilization()c1("gsOff","GS")else a1="Coupled Mode - Ground Stabilization on"q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c1("gsOn","GS")end;toggleView=false elseif ol=="option9"then if gyro~=nil then gyro.toggle()aw=gyro.getState()==1;if aw then c1("gyOn","GA")else c1("gyOff","GA")end end;toggleView=false elseif ol=="lshift"then if AltIsOn then a0=true end;if v()==1 then a0=true;PrevViewLock=v()u(1)elseif l()==1 and ShiftShowsRemoteButtons then a0=true;a_=false;aZ=false end elseif ol=="brake"then if BrakeToggleStatus then cz()elseif not BrakeIsOn then cz()else BrakeIsOn=true end elseif ol=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(1)end elseif ol=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif ol=="stopengines"then local function ox()if C-D<1.5 then c1("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bJ=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;ak=false;al=false;Q=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;aw=false;LockPitch=nil;IntoOrbit=false end end;ox()D=C;if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if J~=0 then q:resetCommand(axisCommandId.longitudinal)ck(0)else ck(100)end else if q:getTargetSpeed(axisCommandId.longitudinal)~=0 then q:resetCommand(axisCommandId.longitudinal)else if ap then cn(AtmoSpeedLimit)else cn(MaxGameVelocity*3.6)end end end elseif ol=="speedup"then ot()elseif ol=="speeddown"then ot(true)elseif ol=="antigravity"and not ExternalAGG then if antigrav~=nil then cB()end end end;function script.onActionStop(ol)local function oy()if not ExternalAGG and by then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if ol=="forward"then S=0 elseif ol=="backward"then S=0 elseif ol=="left"then if bJ then if bJ==2 then bJ=-2 else bJ=-1 end end;V=0 elseif ol=="right"then if bJ then if bJ==4 then bJ=-2 else bJ=-1 end end;V=0 elseif ol=="yawright"then W=0 elseif ol=="yawleft"then W=0 elseif ol=="straferight"then q:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ol=="strafeleft"then q:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ol=="up"then ae=0;q:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ol=="down"then ae=0;q:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ol=="groundaltitudeup"then oy()toggleView=false elseif ol=="groundaltitudedown"then oy()toggleView=false elseif ol=="lshift"then if v()==1 then af=0;ag=0;u(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a0=false elseif ol=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cz()else BrakeIsOn=false end end elseif ol=="lalt"then if l()==0 and freeLookToggle then if toggleView then if v()==1 then u(0)else u(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(0)end;AltIsOn=false end end;function script.onActionLoop(ol)local function oz(on)local B=1;if on then B=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=p(a5*1.05,a3,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+B*a4;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=p(a4*1.05,a2,50)else q:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function oA(on)local B=1;if on then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=p(J+B*speedChangeSmall/100,-1,1)else q:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if ol=="groundaltitudeup"then if not a0 then oz()end elseif ol=="groundaltitudedown"then if not a0 then oz(true)end elseif ol=="speedup"then oA()elseif ol=="speeddown"then oA(true)end end;function script.onInputText(ch)local function oB()for cL,bQ in pairs(c7())do dbHud_1.setStringValue(bQ,g(nil))end;for cL,bQ in pairs(b)do if bQ~="SavedLocations"then dbHud_1.setStringValue(bQ,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5 end;local function oC(oD,eG,hJ)local function oE(eG)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cZ='::pos{'..z..','..z..','..z..','..z..','..z..'}'local db,dc,dj,dk,dl=n(eG,cZ)if db=="0"and dc=="0"then return vec3(x(dj),x(dk),x(dl))end;dk=math.rad(dk)dj=math.rad(dj)local planet=aM[x(db)][x(dc)]local e6=math.cos(dj)local oF=vec3(e6*math.cos(dk),e6*math.sin(dk),math.sin(dj))return planet.center+(planet.radius+dl)*oF end;local position=oE(eG)return aW.AddNewLocation(oD,position,hJ)end;local i;local oG,oH=nil,nil;local oI="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(ch," ")oG=ch;if i~=nil then oG=string.sub(ch,0,i-1)oH=string.sub(ch,i+1)end;if oG=="/help"or oG=="/commands"then for ji in string.gmatch(oI,"([^\n]+)")do system.print(ji)end;return elseif oG=="/setname"then if oH==nil or oH==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(oH)else a1="Select a saved target to rename first"end elseif oG=="/addlocation"or string.find(ch,"::pos")~=nil then local hJ=false;local oD="0-Temp"if oH==nil or oH==""then oH=oG;hJ=true end;i=string.find(oH,"::")if not hJ then oD=string.sub(oH,1,i-2)end;local eG=string.sub(oH,i)oC(oD,eG,hJ)elseif oG=="/agg"then if oH==nil or oH==""then a1="Usage: /agg targetheight"return end;oH=x(oH)if oH<1000 then oH=1000 end;AntigravTargetAltitude=oH;a1="AGG Target Height set to "..oH elseif oG=="/G"then if oH==nil or oH==""then a1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oH=="dump"then for cL,bQ in pairs(c7())do if type(_G[bQ])=="boolean"then if _G[bQ]==true then system.print(bQ.." true")else system.print(bQ.." false")end elseif _G[bQ]==nil then system.print(bQ.." nil")else system.print(bQ.." ".._G[bQ])end end;return end;i=string.find(oH," ")local oJ=string.sub(oH,0,i-1)local oK=string.sub(oH,i+1)for cL,bQ in pairs(c7())do if bQ==oJ then a1="Variable "..oJ.." changed to "..oK;local oL=type(_G[bQ])if oL=="number"then oK=x(oK)elseif oL=="boolean"then if string.lower(oK)=="true"then oK=true else oK=false end end;_G[bQ]=oK;return end end;a1="No such global variable: "..oJ elseif oG=="/copydatabank"then if dbHud_2 then cH(true)else a1="Spare Databank required to copy databank"end elseif oG=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ab,AutopilotTargetCoords,true))a1="::pos waypoint shown in lua chat"else a1="No target selected in IPH"end end end;function script.onEnter(du)if radar_1 and not ap and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(du)if radar_1 and CollisionSystem then if#bK>650 then du=tostring(du)bK[du]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
