name: ArchHud - Archaegeo v0.709 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.709;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=false;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},PrivateLocations={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(L)a9=L end,get=function()return a9 end},ResolutionY={set=function(L)aa=L end,get=function()return aa end},circleRad={set=function(L)ab=L end,get=function()return ab end},SafeR={set=function(L)ac=L end,get=function()return ac end},SafeG={set=function(L)ad=L end,get=function()return ad end},SafeB={set=function(L)ae=L end,get=function()return ae end},PvPR={set=function(L)af=L end,get=function()return af end},PvPG={set=function(L)ag=L end,get=function()return ag end},PvPB={set=function(L)ah=L end,get=function()return ah end},centerX={set=function(L)ai=L end,get=function()return ai end},centerY={set=function(L)aj=L end,get=function()return aj end},throtPosX={set=function(L)ak=L end,get=function()return ak end},throtPosY={set=function(L)al=L end,get=function()return al end},vSpdMeterX={set=function(L)am=L end,get=function()return am end},vSpdMeterY={set=function(L)an=L end,get=function()return an end},altMeterX={set=function(L)ao=L end,get=function()return ao end},altMeterY={set=function(L)ap=L end,get=function()return ap end},fuelX={set=function(L)aq=L end,get=function()return aq end},fuelY={set=function(L)ar=L end,get=function()return ar end},shieldX={set=function(L)as=L end,get=function()return as end},shieldY={set=function(L)at=L end,get=function()return at end},DeadZone={set=function(L)au=L end,get=function()return au end},OrbitMapSize={set=function(L)av=L end,get=function()return av end},OrbitMapX={set=function(L)aw=L end,get=function()return aw end},OrbitMapY={set=function(L)ax=L end,get=function()return ax end},soundVolume={set=function(L)ay=L end,get=function()return ay end}}aA=5;aB=1;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(L)aA=L end,get=function()return aA end},speedChangeSmall={set=function(L)aB=L end,get=function()return aB end},MouseXSensitivity={set=function(L)aC=L end,get=function()return aC end},MouseYSensitivity={set=function(L)aD=L end,get=function()return aD end},autoRollFactor={set=function(L)aE=L end,get=function()return aE end},rollSpeedFactor={set=function(L)aF=L end,get=function()return aF end},autoRollRollThreshold={set=function(L)aG=L end,get=function()return aG end},minRollVelocity={set=function(L)aH=L end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(L)aI=L end,get=function()return aI end},torqueFactor={set=function(L)aJ=L end,get=function()return aJ end},pitchSpeedFactor={set=function(L)aK=L end,get=function()return aK end},yawSpeedFactor={set=function(L)aL=L end,get=function()return aL end},brakeSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeFlatFactor={set=function(L)aN=L end,get=function()return aN end},DampingMultiplier={set=function(L)aO=L end,get=function()return aO end},apTickRate={set=function(L)aP=L end,get=function()return aP end},hudTickRate={set=function(L)aQ=L end,get=function()return aQ end},ExtraLongitudeTags={set=function(L)aR=L end,get=function()return aR end},ExtraLateralTags={set=function(L)aS=L end,get=function()return aS end},ExtraVerticalTags={set=function(L)aT=L end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={VertTakeOff={set=function(L)b5=L end,get=function()return b5 end},VertTakeOffEngine={set=function(L)aW=L end,get=function()return aW end},SpaceTarget={set=function(L)bt=L end,get=function()return bt end},BrakeToggleStatus={set=function(L)aV=L end,get=function()return aV end},BrakeIsOn={set=function(L)aX=L end,get=function()return aX end},RetrogradeIsOn={set=function(L)aY=L end,get=function()return aY end},ProgradeIsOn={set=function(L)aZ=L end,get=function()return aZ end},Autopilot={set=function(L)a_=L end,get=function()return a_ end},TurnBurn={set=function(L)b0=L end,get=function()return b0 end},AltitudeHold={set=function(L)b1=L end,get=function()return b1 end},BrakeLanding={set=function(L)b2=L end,get=function()return b2 end},Reentry={set=function(L)b4=L end,get=function()return b4 end},AutoTakeoff={set=function(L)b3=L end,get=function()return b3 end},HoldAltitude={set=function(L)b6=L end,get=function()return b6 end},AutopilotAccelerating={set=function(L)b7=L end,get=function()return b7 end},AutopilotBraking={set=function(L)b9=L end,get=function()return b9 end},AutopilotCruising={set=function(L)ba=L end,get=function()return ba end},AutopilotRealigned={set=function(L)b8=L end,get=function()return b8 end},AutopilotEndSpeed={set=function(L)bb=L end,get=function()return bb end},AutopilotStatus={set=function(L)bc=L end,get=function()return bc end},AutopilotPlanetGravity={set=function(L)bd=L end,get=function()return bd end},PrevViewLock={set=function(L)be=L end,get=function()return be end},AutopilotTargetName={set=function(L)bf=L end,get=function()return bf end},AutopilotTargetCoords={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetIndex={set=function(L)bh=L end,get=function()return bh end},TotalDistanceTravelled={set=function(L)bj=L end,get=function()return bj end},TotalFlightTime={set=function(L)bk=L end,get=function()return bk end},SavedLocations={set=function(L)bl=L end,get=function()return bl end},VectorToTarget={set=function(L)bm=L end,get=function()return bm end},LocationIndex={set=function(L)bn=L end,get=function()return bn end},LastMaxBrake={set=function(L)bo=L end,get=function()return bo end},LockPitch={set=function(L)bp=L end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(L)bq=L end,get=function()return bq end},AntigravTargetAltitude={set=function(L)br=L end,get=function()return br end},LastStartTime={set=function(L)bs=L end,get=function()return bs end},iphCondition={set=function(L)bw=L end,get=function()return bw end},stablized={set=function(L)bx=L end,get=function()return bx end},UseExtra={set=function(L)by=L end,get=function()return by end},SelectedTab={set=function(L)bC=L end,get=function()return bC end},saveRoute={set=function(L)bA=L end,get=function()return bA end}}local function bD(a,b,c,bE,bF,bG)bH=bE()bI=ac;bJ=ae;bK=ad;bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=false;bS=false;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;b_=false;c0=false;c1="empty"c2=false;c3=0;c4=0;c5=nil;c6=0;c7=0;c8=0;c9=0;ca=0;cb=3;cc=0;cd=""ce=false;cf=false;cg=false;ch=-1;ci=bG()>0;cj=bG()ck=b.getAltitude()cl=bE()cm=b.getConstructMass()cn=false;co=nil;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]cr=""cs=a9;ct=aa;cu={}cv={}cw={}cx=false;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=nil;cH=false;cI=false;cJ=p;cK=false;cL=0;cM=V;cN=0;cO=nil;cP={VectorToTarget=false}cQ=0;cR=false;cS=false;cT=false;cU=vec3(b.getConstructWorldOrientationUp())cV=vec3(b.getConstructWorldOrientationForward())cW=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getVelocity())cY=vec3(b.getWorldVelocity())cZ=vec3(cY):len()c_=vec3(b.getWorldVertical())d0=-c_:dot(cY)d1=vec3(b.getConstructWorldPos())d2=false;d3=false;d4=nil;d5=true;d6=0;d7=0;d8={}d9=false;da=50000;db=nil;dc={}dd=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;de=false;df=nil;dg=false;dh=0;di=nil;dj=nil;dk={}dl=90;dm=x;dn=nil end;local function dp(d,b,c,a,dq,dr,ds,dt,du)local function dv(dw)return type(dw)=='number'end;local function dx(dw)return type(ds(dw))=='number'end;local function dy(dz)return type(dz)=='table'end;local function dA(a)return type(a)=='string'end;local function dB(dC)return dy(dC)and dv(dC.x and dC.y and dC.z)end;local function dD(dE)return dy(dE)and dv(dE.latitude and dE.longitude and dE.altitude and dE.id and dE.systemId)end;local dF=math.pi/180;local dG=180/math.pi;local dH=1e-10;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dK(dw)local dL=string.gsub(string.reverse(dq('%.4f',dw)),'^0*%.?','')return dL==''and'0'or string.reverse(dL)end;local function dM(dN)if dB(dN)then return dq('{x=%.3f,y=%.3f,z=%.3f}',dN.x,dN.y,dN.z)end;if dy(dN)and not getmetatable(dN)then local dO={}local dP=next(dN)if type(dP)=='nil'or dP==1 then dO=dN else for dQ,dC in pairs(dN)do local dR=dM(dC)if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end end;return dq('{%s}',table.concat(dO,','))end;if dA(dN)then return dq("'%s'",dN:gsub("'",[[\']]))end;return tostring(dN)end;local dS={}dS.__index=dS;dS.__tostring=function(dN,dT)local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)local dO={}for dV,dQ in ipairs(dU)do local dR=dM(dN[dQ])if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end;if dT then return dq('%s%s',dT,table.concat(dO,',\n'..dT))end;return dq('{%s}',table.concat(dO,','))end;dS.__eq=function(dW,dX)return dW.systemId==dX.systemId and dW.id==dX.id and du(dW.radius,dX.radius)and du(dW.center.x,dX.center.x)and du(dW.center.y,dX.center.y)and du(dW.center.z,dX.center.z)and du(dW.GM,dX.GM)end;local function dY(dZ,d_,e0,e1,e2)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e0),'Argument 3 (radius) must be a number:'..type(e0))assert(dy(e1),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e1))assert(dx(e2),'Argument 5 (GM) must be a number:'..type(e2))return setmetatable({systemId=ds(dZ),id=ds(d_),radius=ds(e0),center=vec3(e1),GM=ds(e2)},dS)end;local e3={}e3.__index=e3;e3.__tostring=function(e4)return dq('::pos{%d,%d,%s,%s,%s}',e4.systemId,e4.id,dK(e4.latitude*dG),dK(e4.longitude*dG),dK(e4.altitude))end;e3.__eq=function(dW,dX)return dW.id==dX.id and dW.systemId==dX.systemId and du(dW.latitude,dX.latitude)and du(dW.altitude,dX.altitude)and(du(dW.longitude,dX.longitude)or du(dW.latitude,math.pi/2)or du(dW.latitude,-math.pi/2))end;local function e5(e6,d_,e7,e8,e9)local dZ=e6;if dA(e6)and not e8 and not e9 and not d_ and not e7 then dZ,d_,e7,e8,e9=ea(e6,dJ)assert(dZ,'Argument 1 (position string) is malformed.')else assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e7),'Argument 3 (latitude) must be in degrees:'..type(e7))assert(dx(e8),'Argument 4 (longitude) must be in degrees:'..type(e8))assert(dx(e9),'Argument 5 (altitude) must be in meters:'..type(e9))end;dZ=ds(dZ)d_=ds(d_)e7=ds(e7)e8=ds(e8)e9=ds(e9)if d_==0 then return setmetatable({latitude=e7,longitude=e8,altitude=e9,id=d_,systemId=dZ},e3)end;return setmetatable({latitude=dF*dr(e7,-90,90),longitude=dF*(e8%360),altitude=e9,id=d_,systemId=dZ},e3)end;local eb={}eb.__index=eb;eb.__tostring=function(dN,dT)local ec=dT and dT..'  'local ed={}local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)for dV,ee in ipairs(dU)do ef=dN[ee]local eg=dS.__tostring(ef,ec)if dT then table.insert(ed,dq('[%s]={\n%s\n%s}',ee,eg,dT))else table.insert(ed,dq('  [%s]=%s',ee,eg))end end;if dT then return dq('\n%s%s%s',dT,table.concat(ed,',\n'..dT),dT)end;return dq('{\n%s\n}',table.concat(ed,',\n'))end;local function eh(ei)local e={}local pid;for dV,dC in pairs(ei)do local d_=dC.planetarySystemId;if type(d_)~='number'then error('Invalid planetary s ID: '..tostring(d_))elseif pid and d_~=pid then error('Mistringmatch planetary s IDs: '..d_..' and '..pid)end;local ej=dC.bodyId;if type(ej)~='number'then error('Invalid body ID: '..tostring(ej))elseif e[ej]then error('Duplicate body ID: '..tostring(ej))end;setmetatable(dC.center,getmetatable(vec3.unit_x))e[ej]=setmetatable(dC,dS)pid=d_ end;return setmetatable(e,eb)end;ek={}local function el(ei)return setmetatable({galaxyAtlas=ei or{}},ek)end;ek.__index=function(dz,L)if type(L)=='number'then local a=dz.galaxyAtlas[L]return eh(a)end;return rawget(ek,L)end;ek.__pairs=function(dN)return function(dz,dQ)local em,en=next(dz,dQ)return em,en and eh(en)end,dN.galaxyAtlas,nil end;ek.__tostring=function(dN)local eo={}for dV,ep in pairs(dN or{})do local eq=ep:getPlanetarySystemId()local er=eb.__tostring(ep,'    ')table.insert(eo,dq('  [%s]={%s\n  }',eq,er))end;return dq('{\n%s\n}\n',table.concat(eo,',\n'))end;ek.BodyParameters=dY;ek.MapPosition=e5;ek.PlanetarySystem=eh;function ek.createBodyParameters(dZ,d_,es,et,eu,ev,ew)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(es),'Argument 3 (surfaceArea) must be a number:'..type(es))assert(dy(et),'Argument 4 (aPosition) must be an array or vec3:'..type(et))assert(dy(eu),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eu))assert(dx(ev),'Argument 6 (altitude) must be in meters:'..type(ev))assert(dx(ew),'Argument 7 (gravityAtPosition) must be number:'..type(ew))local e0=dt(es/4/math.pi)local cc=e0+ev;local ex=vec3(et)+cc*vec3(eu)local e2=ew*cc*cc;return dY(dZ,d_,e0,ex,e2)end;ek.isMapPosition=dD;function ek:getPlanetarySystem(e6)if L==nil then L=0 end;if en==nil then en=0 end;local dZ=e6;if dD(e6)then dZ=e6.systemId end;if type(dZ)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(en)~=eb then a=eh(a)end;return a end end end;function eb:sizeCalculator(ey)return 1.05*ey.radius end;function eb:castIntersections(ez,eA,eB,eC,eD,eE)local eF={}if eD then for dV,ey in pairs(eD)do table.insert(eF,ey)end else eF=dk end;if not eE then table.sort(eF,function(eG,eH)local eI=eG.center;local eJ=eH.center;return(eI.x-ez.x)^2+(eI.y-ez.y)^2+(eI.z-ez.z)^2<(eJ.x-ez.x)^2+(eJ.y-ez.y)^2+(eJ.z-ez.z)^2 end)end;local eK=eA:normalize()for dV,ey in ipairs(eF)do local eL=ey.center-ez;local e0=self:sizeCalculator(ey)local eM=eL:dot(eK)local eN=eM^2-(eL:len2()-e0^2)if eN>=0 then local eO=dt(eN)local eP=eM+eO;local eQ=eM-eO;if eQ>0 then return ey,eP,eQ elseif eP>0 then return ey,eP,nil end end end;return nil,nil,nil end;function eb:closestBody(eR)assert(type(eR)=='table','Invalid coordinates.')local eS,ey;local eT=vec3(eR)for dV,eU in pairs(self)do local eV=(eU.center-eT):len2()if(not ey or eV<eS)and eU.name~="Space"then ey=eU;eS=eV end end;return ey end;function eb:convertToBodyIdAndWorldCoordinates(e6)local eW=e6;if dA(e6)then eW=e5(e6)end;if eW.id==0 then return 0,vec3(eW.latitude,eW.longitude,eW.altitude)end;local eU=self:getBodyParameters(eW)if eU then return eW.id,eU:convertToWorldCoordinates(eW)end end;function eb:getBodyParameters(e6)local d_=e6;if dD(e6)then d_=e6.id end;assert(dx(d_),'Argument 1 (id) must be a number:'..type(d_))return self[d_]end;function eb:getPlanetarySystemId()local dV,dC=next(self)return dC and dC.systemId end;function dS:convertToMapPosition(e1)assert(dy(e1),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e1))local eX=vec3(e1)if self.id==0 then return setmetatable({latitude=eX.x,longitude=eX.y,altitude=eX.z,id=0,systemId=self.systemId},e3)end;local eY=eX-self.center;local cc=eY:len()local e9=cc-self.radius;local e7=0;local e8=0;if not du(cc,0)then local eZ=e_(eY.y,eY.x)e8=eZ>=0 and eZ or 2*math.pi+eZ;e7=math.pi/2-math.acos(eY.z/cc)end;return setmetatable({latitude=e7,longitude=e8,altitude=e9,id=self.id,systemId=self.systemId},e3)end;function dS:convertToWorldCoordinates(e6)local eW=dA(e6)and e5(e6)or e6;if eW.id==0 then return vec3(eW.latitude,eW.longitude,eW.altitude)end;assert(dD(eW),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eW.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eW.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f0=math.cos(eW.latitude)return self.center+(self.radius+eW.altitude)*vec3(f0*math.cos(eW.longitude),f0*math.sin(eW.longitude),math.sin(eW.latitude))end;function dS:getAltitude(e1)return(vec3(e1)-self.center):len()-self.radius end;function dS:getDistance(e1)return(vec3(e1)-self.center):len()end;function dS:getGravity(e1)local f1=self.center-vec3(e1)local f2=f1:len2()return self.GM/f2*f1/dt(f2)end;return setmetatable(ek,{__call=function(dV,...)return el(...)end})end;local function f3(d,b,c,a,dt,f4)local cz={}local f5=30000000/3600;local f6=f5*f5;local f7=100;function cz.computeAccelerationTime(f8,f9,fa)local fb=f5*math.asin(f8/f5)return(f5*math.asin(fa/f5)-fb)/f9 end;function cz.computeDistanceAndTime(f8,fa,fc,fd,fe,ff)fe=fe or 0;ff=ff or 0;local fg=f8<=fa;local fh=fd*(fg and 1 or-1)/fc;local fi=-ff/fc;local fj=fh+fi;if fg and fj<=0 or not fg and fj>=0 then return-1,-1 end;local fk,fl=0,0;if fh~=0 and fe>0 then local fb=math.asin(f8/f5)local fm=math.pi*(fh/2+fi)local fn=fh*fe;local fo=f5*math.pi;local dC=function(dz)local fp=(fm*dz-fn*math.sin(math.pi*dz/2/fe)+fo*fb)/fo;local fq=math.tan(fp)return f5*fq/dt(fq*fq+1)end;local fr=fg and function(a)return a>=fa end or function(a)return a<=fa end;fl=2*fe;if fr(dC(fl))then local fs=0;while f4(fl-fs)>0.5 do local dz=(fl+fs)/2;if fr(dC(dz))then fl=dz else fs=dz end end end;local ft=f8;local fu=fl/f7;for fv=1,f7 do local fw=dC(fv*fu)fk=fk+(fw+ft)*fu/2;ft=fw end;if fl<2*fe then return fk,fl end;f8=ft end;local fb=f5*math.asin(f8/f5)local bH=(f5*math.asin(fa/f5)-fb)/fj;local fx=f6*math.cos(fb/f5)/fj;local cc=fx-f6*math.cos((fj*bH+fb)/f5)/fj;return cc+fk,bH+fl end;function cz.computeTravelTime(f8,f9,cc)if cc==0 then return 0 end;if f9>0 then local fb=f5*math.asin(f8/f5)local fx=f6*math.cos(fb/f5)/f9;return(f5*math.acos(f9*(fx-cc)/f6)-fb)/f9 end;if f8==0 then return-1 end;assert(f8>0,'Acceleration and initial speed are both zero.')return cc/f8 end;return cz end;local function fy(d,b,c,a,dq,dr,ds,dt,du)local vec3=require('cpml.vec3')local dp=dp(d,b,c,a,dq,dr,ds,dt,du)local function dA(a)return type(a)=='string'end;local function dy(dz)return type(dz)=='table'end;fz={}fz.__index=fz;function fz:escapeAndOrbitalSpeed(e9)assert(self.body)local cc=e9+self.body.radius;if not du(cc,0)then local fA=dt(self.body.GM/cc)return dt(2)*fA,fA end;return nil,nil end;function fz:orbitalParameters(e6,fB)assert(self.body)assert(dy(e6)or dA(e6))assert(dy(fB))local fC=(dA(e6)or dp.isMapPosition(e6))and self.body:convertToWorldCoordinates(e6)or vec3(e6)local dC=vec3(fB)local fD=fC-self.body.center;local fE=dC:len2()local fF=fD:len()local fG=self.body.GM;local fH=((fE-fG/fF)*fD-fD:dot(dC)*dC)/fG;local eI=fG/(2*fG/fF-fE)local fI=fH:len()local eK=fH:normalize()local fJ=eI*(1-fI)local fK=eI*(1+fI)local fL=fJ*eK+self.body.center;local fM=fI<=1 and-fK*eK+self.body.center or nil;local fN=dt(eI*fG*(1-fI*fI))local fO=fM and 2*math.pi*dt(eI^3/fG)local fP=math.acos(fH:dot(fD)/(fI*fF))if fD:dot(dC)<0 then fP=-(fP-2*math.pi)end;local fQ=math.acos((math.cos(fP)+fI)/(1+fI*math.cos(fP)))local fR=fQ;if fR<0 then fR=fR+2*math.pi end;local fS=fR-fI*math.sin(fR)local fT=0;local fU=0;local fV=0;if fO~=nil then fT=fS/(2*math.pi/fO)fU=fO-fT;fV=fU+fO/2;if fP-math.pi>0 then fU=fT;fV=fU+fO/2 end;if fV>fO then fV=fV-fO end end;return{periapsis={position=fL,speed=fN/fJ,circularOrbitSpeed=dt(fG/fJ),altitude=fJ-self.body.radius},apoapsis=fM and{position=fM,speed=fN/fK,circularOrbitSpeed=dt(fG/fK),altitude=fK-self.body.radius},currentVelocity=dC,currentPosition=fC,eccentricity=fI,period=fO,eccentricAnomaly=fQ,meanAnomaly=fS,timeToPeriapsis=fU,timeToApoapsis=fV,trueAnomaly=fP}end;local function fW(fX)local eU=dp.BodyParameters(fX.systemId,fX.id,fX.radius,fX.center,fX.GM)return setmetatable({body=eU},fz)end;return setmetatable(fz,{__call=function(dV,...)return fW(...)end})end;local function fY(d,b,c,a,dbHud_1,e,fZ,f_,bF,ds,dt,g0)local function g1(g2)local e4=g3:closestBody(g2)if(g2-e4.center):len()>e4.radius+e4.noAtmosphericDensityAltitude then e4=e[0][0]end;return e4 end;local function g4()local function g5(g6,g7)return g6.name<g7.name end;d8={}for dQ,dC in pairs(e[0])do d8[#d8+1]={name=dC.name,index=dQ}end;table.sort(d8,g5)end;local function g8(g9)for dQ,dC in pairs(g9)do if dC.name and dC.name==ga.name then return dQ end end;return-1 end;local function gb()dh=bh;if bh==0 then bf="None"c5=nil;ga=nil;return true end;local gc=d8[bh].index;local gd=e[0][gc]if gd.center then bf=gd.name;c5=cy[0][gc]if ga~=nil then if cj==0 then if fZ(ge,gf)~=1 then f_(ge,gf)end;if fZ(gg,gh)~=1 then f_(gg,gh)end;if fZ(gi,gj)~=1 then f_(gi,gj)end;if fZ(gk,gl)~=1 then f_(gk,gl)end;if fZ(gm,gn)~=1 then f_(gm,gn)end end;if fZ(go,gp)~=1 then f_(go,gp)end;if fZ(gq,gr)~=1 then f_(gq,gr)end;if fZ(gs,gt)~=1 then f_(gs,gt)end end;ga=nil else ga=gd;for dV,dC in pairs(cy[0])do if dC.name==ga.planetname then c5=dC;bf=ga.name;break end end;if fZ(go,gp)~=1 then f_(go,gp)end;if fZ(gq,gr)~=1 then f_(gq,gr)end end;if ga==nil then bg=vec3(c5.center)else bg=ga.position end;if c5.planetname~="Space"then if c5.hasAtmosphere then gu=bF(c5.radius*(T-1)+c5.noAtmosphericDensityAltitude)else gu=bF(c5.radius*(T-1)+c5.surfaceMaxAltitude)end else gu=S end;if ga~=nil and ga.planetname=="Space"then bb=0 else dV,bb=cB(c5):escapeAndOrbitalSpeed(gu)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gv(gw)if not a_ and not bm and not cf and not bv and not b4 and not cg then if gw==nil then bh=bh+1;if bh>#d8 then bh=0 end else bh=bh-1;if bh<0 then bh=#d8 end end;if bh==0 then gb()else local gc=d8[bh].index;local gd=e[0][gc]if gd~=nil and gd.name=="Space"or bw=="Custom Only"and gd.center or bw=="No Moons"and string.find(gd.name,"Moon")~=nil then if gw==nil then gv()else gv(1)end else gb()end end else c1="Disengage autopilot before changing Interplanetary Helper"g0("iph","AP")end end;local function gx()local gy=-1;gy=g8(e[0])if gy>-1 then table.remove(e[0],gy)end;gy=-1;gy=g8(bl)if gy~=-1 then c1=ga.name.." saved location cleared"table.remove(bl,gy)end;gv()g4()end;local function gz(gA,g2,gB,gC)if dbHud_1 or gB then local e4=g1(g2)local gD=e4.gravity;if gC then gD=c.getClosestPlanetInfluence()end;local gE={position=g2,name=gA,planetname=e4.name,gravity=gD,safe=gC}if not gB then bl[#bl+1]=gE else for dQ,dC in pairs(e[0])do if dC.name and gA==dC.name then table.remove(e[0],dQ)end end end;table.insert(e[0],gE)g4()gb()c1="Location saved as "..gA.."("..e4.name..")"else c1="Databank must be installed to save permanent locations"end end;local gF={}function gF.UpdateAtlasLocationsList()g4()end;function gF.UpdateAutopilotTarget()gb()end;function gF.adjustAutopilotTargetIndex(gw)gv(gw)end;function gF.findAtlasIndex(g9)g8(g9)end;function gF.UpdatePosition(gG)local gy=g8(bl)if gy~=-1 then if gG~=nil then bl[gy].name=gG;bh=bh-1;gv()else local gH=bl[gy]gH.gravity=c.getClosestPlanetInfluence()gH.position=d1;gH.safe=true end;c1=bl[gy].name.." position updated ("..bl[gy].planetname..")"else c1="Name Not Found"end end;function gF.AddNewLocation(gA,g2,gB,gC)gz(gA,g2,gB,gC)end;function gF.ClearCurrentPosition()gx()end;for dQ,dC in pairs(bl)do table.insert(e[0],dC)end;g4()if bh>#d8 then bh=0 end;gF.UpdateAutopilotTarget()return gF end;local function gI(b,a,c,library,radar_1,radar_2,f4,gJ,dt,gK,ds,gL,g0)local gM={}local gN={}local gO={XS=13,S=27,M=55,L=110,XL=221}local gP={}local gQ;local gR;local gS;local gT;local gU;local gV={}local gW="Atmo"local gX;local gY;local gZ=0;local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local fE=h4-h2;local hc=fE:normalize()local hd=fE:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local dE=h9-hk^2-hl^2;local hm=dt(dE)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if f4((h8-hn):len()-h7)<f4((h8-ho):len()-h7)then return hn else return ho end end;local function hp()local function hq()local hr=b.getConstructWorldOrientationRight()local fE=b.getConstructWorldOrientationForward()local he=b.getConstructWorldOrientationUp()local hs=library.systemResolution3(hr,fE,he,{1,0,0})local ht=library.systemResolution3(hr,fE,he,{0,1,0})local hu=library.systemResolution3(hr,fE,he,{0,0,1})return function(hv)return library.systemResolution3(hs,ht,hu,hv)end end;local hw=hq()local hx=b.getConstructWorldPos()local fC=b.getElementPositionById(1)local hy={fC[1],fC[2],fC[3]}local hz=hw(hy)local hA={hx[1]-hz[1],hx[2]-hz[2],hx[3]-hz[3]}return hA end;local function hB(hC,fF,hD)local hE=hC.pts;local gy=#hE;local hF=hC.ref;if gy>3 then local hG,hH,hI,hJ=hE[gy],hE[gy-1],hE[gy-2],hE[gy-3]hC.ref=hD;local fC=h0(hG[1],hG[2],hH[1],hH[2],hI[1],hI[2],hJ[1],hJ[2])local hk,hl,hm=fC.x,fC.y,fC.z;if hk==hk and hl==hl and hm==hm then hk=hk+hF[1]hl=hl+hF[2]hm=hm+hF[3]local hK=vec3(hk,hl,hm)if not hC.lastPos then hC.center=hK elseif(hC.lastPos-hK):len()<2 then hC.center=hK;hC.skipCalc=true end;hC.lastPos=hK end;hC.pts={}else local hL={hD[1]-hF[1],hD[2]-hF[2],hD[3]-hF[3]}hE[gy+1]={fF,hL}end end;if radar_1 or radar_2 then cF.assignRadar()end;if gV[1]then gQ=#gV[1].getConstructIds()local hM=gV[1].getData()local hN=hM:gmatch('{"constructId[^}]*}[^}]*}')if gQ>0 then local hD=hp()local hO,hP=0,0;gU,gT=0,0;for dC in hN do local d_,cc,hQ=dC:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hR=gO[hQ]cc=ds(cc)if gV[1].hasMatchingTransponder(d_)==1 then table.insert(gN,d_)end;local hS=gV[1].getConstructType(d_)if F then if hR>27 or hS=="static"or hS=="space"then gU=gU+1;local gA=gV[1].getConstructName(d_)local hC=dc[d_]if hC==nil then hR=hR+gL;dc[d_]={pts={},ref=hD,name=gA,i=0,radius=hR,skipCalc=false}hC=dc[d_]end;if not hC.skipCalc then hB(hC,cc,hD)hP=hP+1 end;if hC.center then table.insert(gP,hC)end end;hO=hO+1;if dd and hO>700 or hP>70 or(not dd and hO>300 or hP>30)then coroutine.yield()hO,hP=0,0 end end end;gT=#gP;if gT>0 and cZ>20 then local ey,hT,hU,hV;local hW=0;local hX=cy:getPlanetarySystem(0)hV=cY:normalize()while hW<gT do coroutine.yield()local hY={table.unpack(gP,hW,math.min(hW+75,gT))}ey,hT,hU=hX:castIntersections(d1,hV,nil,nil,hY,true)if ey and hU then df={ey,hT,hU}break end;hW=hW+75 end;if not ey then df=nil end else df=nil end;gP={}gR=hM:find('identifiedConstructs":%[%]')else gS=hM:find('worksInEnvironment":false')end end end;local function hZ()if gV[1]then gW="Atmo"if gV[1].getData():find('worksInAtmosphere":false')then gW="Space"end end end;function gM.pickType()hZ()end;function gM.assignRadar()if radar_1 and gV[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gV[1]=radar_2 end;if gV[1]==radar_2 then hZ()end elseif radar_2 and gV[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gV[1]=radar_1 end;if gV[1]==radar_1 then hZ()end end end;function gM.UpdateRadar()local h_=coroutine.status(gX)if h_=="suspended"then local dR,i0=coroutine.resume(gX)if i0 then a.print("ERROR UPDATE RADAR: "..i0)end elseif h_=="dead"then gX=coroutine.create(g_)local dR,i0=coroutine.resume(gX)end end;function gM.GetRadarHud(i1,i2,i3,i4)local i5=gN;local i6,i7;gN={}local dI=gT or 0;if gQ>0 then if F then i7=dI.."/"..gU.." Plotted : "..gQ-gU.." Ignored"else i7="Radar Contacts: "..gQ end;i6=gK(i3,i4,i7,"pbright txtbig txtmid")if#gN>0 then i6=i6 ..gK(i1,i2,"Friendlies In Range","pbright txtbig txtmid")for dQ,dC in pairs(gN)do i2=i2+20;i6=i6 ..gK(i1,i2,gV[1].getConstructName(dC),"pdim txtmid")end end;if gR==nil and gY==nil then gZ=1;cF.ToggleRadarPanel()end;if gR~=nil and gY~=nil then cF.ToggleRadarPanel()end;if i8==nil then cF.ToggleRadarPanel()end else if gS then i6=gK(i3,i4,gW.." Radar: Jammed","pbright txtbig txtmid")else i6=gK(i3,i4,"Radar: No "..gW.." Contacts","pbright txtbig txtmid")end;if i8~=nil then gZ=0;cF.ToggleRadarPanel()end end;return i6 end;function gM.GetClosestName(gA)if gV[1]then local d_,dV=gV[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d_~=nil and d_~=""then gA=gA.." "..gV[1].getConstructName(d_)end end;return gA end;function gM.ToggleRadarPanel()if i8~=nil and gZ==0 then gJ(i8)i8=nil;if gY~=nil then gJ(gY)gY=nil end else if gZ==1 then gJ(i8)i8=nil;_autoconf.displayCategoryPanel(gV,1,"Periscope","periscope")gY=_autoconf.panels[_autoconf.panels_size]end;if i8==nil then _autoconf.displayCategoryPanel(gV,1,"Radar","radar")i8=_autoconf.panels[_autoconf.panels_size]end;gZ=0 end end;function gM.ContactTick()if not i9 then i9=0 end;if bH>i9+10 then c1="Radar Contact"g0("rdrCon","RC")i9=bH end;c.stopTimer("contact")end;function gM.onEnter(d_)if radar_1 and not ci and not d9 then c.setTimer("contact",0.1)end end;function gM.onLeave(d_)if radar_1 and F then if#dc>650 then d_=tostring(d_)dc[d_]=nil end end end;gV[1]=nil;if radar_1 then gV[1]=radar_1;hZ()end;gX=coroutine.create(g_)return gM end;local function ia(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ib,warpdrive,f4,bF,dq,ic,bG,id,ie,e_,bE,dr,ig,f_,fZ,gJ,ih,dt,ii,gK,g0,ij,ik,il,im)local io=9.80665;local ip={}local iq={}local ir={}local is={}local it=nil;local iu=nil;local iv=nil;local iw=false;local ix="none"local iy=""local iz=55;local iA=0;local iB=0;local iC=vec3({13771471,7435803,-128971})local iD=18000000;local iE=500000;local iF,iG=math.huge;local iH;local function iI(iJ)iF=vec3(iJ):dist(iC)if iF<iD then return true,f4(iF-iD)end;iG=vec3(iJ):dist(vec3(iK.center))if iG<iE then iH=true else iH=false end;if f4(iG-iE)<f4(iF-iD)then return iH,f4(iG-iE)else return iH,f4(iF-iD)end end;local function iL(dC)if cs==1920 then return dC else return ii(cs*dC/1920,0)end end;local function iM(dC)if ct==1080 then return dC else return ii(ct*dC/1080,0)end end;local function iN()return ih()==0 and g~="keyboard"and ie()==0 end;local function iO()local iP="TRAVEL"if not d5 then iP="CRUISE"end;if a_ then iP="AUTOPILOT"end;return iP end;local i6=""local iQ=""local iR=""local iS=1;local iT=2;local iU=3;local iV=4;local iW=5;local iX=6;local iY=""local iZ=0;local i_=bF(1/aP)*2*aQ;local j0={}local j1={}local j2={}local j3={}local j4={}local j5={}local j6={}j6["atmofueltank"],j6["spacefueltank"],j6["rocketfueltank"]=0,0,0;local j7=0;local function j8(hk,j9,ja,jb,jc,jd)local je=j7;local jf=j7+5;if not C then jf=jf+5 end;if ie()==1 and not l then je=je-50;jf=jf-50 end;if ja=="ATMO"then iY="atmofueltank"elseif ja=="SPACE"then iY="spacefueltank"else iY="rocketfueltank"end;iZ=_G[iY.."_size"]if#jb>0 then for L=1,#jb do local gA=string.sub(jb[L][iT],1,12)local jg=0;for jh=1,iZ do if jb[L][iT]==ic(c[iY.."_"..jh].getData()).name then jg=jh;break end end;local ji=bE()if jc[L]==nil or jd[L]==nil or ji-jb[L][iX]>i_ then local jj;local jk=0;jk=id(jb[L][iS])-jb[L][iV]jj=jb[L][iW]if jj>jk then jb[L][iX]=ji;j6[iY]=j6[iY]+jj-jk end;jb[L][iW]=jk;if jg~=0 then jd[L]=ic(c[iY.."_"..jg].getData()).percentage;jc[L]=ic(c[iY.."_"..jg].getData()).timeLeft;if jc[L]=="n/a"then jc[L]=0 end else jd[L]=bF(0.5+jk*100/jb[L][iU])if jj<=jk then jc[L]=0 else jc[L]=bF(0.5+jk/((jj-jk)/(ji-jb[L][iX])))end end end;if gA==j9 then gA=dq("%s %d",ja,L)end;if jg==0 then gA=gA.." *"end;local jl;if jc[L]==0 then jl=""else jl=im(jc[L])end;if jd[L]~=nil then local jm=bF(jd[L]*2.55)local jn=dq("rgb(%d,%d,%d)",255-jm,jm,0)local jo=""if jl~=""and jc[L]<120 or jd[L]<5 then jo="red "end;local jp=dq("rgb(%d,%d,%d)",dr(bF((255-jm)/2.55),50,100),dr(bF(jm/2.55),0,50),50)local jq="rgb(196,0,255)"if ja=="ATMO"then jq="rgb(0,188,255)"elseif ja=="SPACE"then jq="rgb(239,255,0)"end;local jr=false;if js~=jq then jr=true end;js=jq;if C then if jr then je=je-5;jf=jf-5 end;iQ=iQ..dq([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jp,jq,hk,jf,jn,bF(jd[L]*1.7+0.5)-2,hk+1,jf+1,hk+5,jf+14,gA,jd[L],jl)je=je-22;jf=jf-22 else iQ=iQ..gK(hk,je,gA,jo.."pdim txtfuel")iQ=iQ..gK(hk,jf,dq("%d%% %s",jd[L],jl),"pdim txtfuel","fill:"..jn)je=je+30;jf=jf+30 end end end end;j7=je end;local function jt(ju,e9)if am==0 and an==0 then return end;if e9<200000 and not ci or e9 and ci then local jv=0;if f4(d0)>1 then jv=45*math.log(f4(d0),10)if d0<0 then jv=-jv end end;ju[#ju+1]=dq([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bF(d0),bF(jv))end;return ju end;local function jw(jx)local gw=-c_;jx=jx-jx:project_on(gw)local jy=vec3(0,0,1)jy=jy-jy:project_on(gw)local jz=jy:cross(gw)local jv=jy:angle_between(jx)*constants.rad2deg;if jx:dot(jz)<0 then jv=360-jv end;return jv end;local function jA(ju,ai,aj,jB,jC,dd)if ab==0 then return end;local jD=ab;local jE=20;local jF=bF(jB)if dd then for L=-45,45,5 do local jG=L;ju[#ju+1]=dq([[<g transform="rotate(%f,%d,%d)">]],jG,ai,aj)jH=5;if L%15==0 then jH=15 elseif L%10==0 then jH=10 end;ju[#ju+1]=dq([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jD+jE-jH,ai,aj+jD+jE)end;ju[#ju+1]=gK(ai,aj+jD+jE-35,jC,"pdim txt txtmid")ju[#ju+1]=gK(ai,aj+jD+jE-25,jF.." deg","pdim txt txtmid")ju[#ju+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jB,ai,aj)ju[#ju+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jD+jE-20,ai+5,aj+jD+jE-20,ai,aj+jD+jE-15)ju[#ju+1]="</g>"end;ju[#ju+1]=[[<g style="clip-path: url(#headingClip);">]]local jI=jF;if dd then jI=jw(cV)end;local jJ=20;local jK=bF(jI)local jL=0;local jM=aj+jD+jE+20;local jN=ai;if jC~="YAW"then jM=iM(130)jN=iL(960)end;local jO=[[<path class="txttick line" d="]]local jP=bF(jK-(jJ+10)-jK%5+0.5)for L=jP+70,jP,-5 do local hk=jN-(-L*5+jI*5)if L%10==0 then jL=10;local dI=L;if dI==360 then dI=0 elseif dI>360 then dI=dI-360 elseif dI<0 then dI=dI+360 end;ju[#ju+1]=gK(hk,jM+15,dI,"txtmid bright")elseif L%5==0 then jL=5 end;if jL==10 then jO=dq([[%s M %f %f v %d]],jO,hk,jM-5,jL)else jO=dq([[%s M %f %f v %d]],jO,hk,jM-2.5,jL)end end;ju[#ju+1]=jO..[["/>]]ju[#ju+1]=dq([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jN-5,jM-20,jN+5,jM-20,jN,jM-10)if I then if dd then jC="HDG"end;ju[#ju+1]=gK(iL(960),iM(100),jK.."Â°","dim txt txtmid size14","")ju[#ju+1]=gK(iL(960),iM(85),jC,"dim txt txtmid size20","")end;ju[#ju+1]=[[</g>]]end;local function jQ(ju,jR,jB,ai,aj,dd,jS,fw)if ab==0 then return end;local jD=ab;local jT=bF(jD*3/5)if jD>0 then local jU=bF(jR)local jH=0;local jO=dq([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jB,ai,aj)if not ci then jO=dq([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;ju[#ju+1]=dq([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jD-1,ai,aj)ju[#ju+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bF(jU-30-jU%5+0.5),bF(jU+30+jU%5+0.5),5 do if L%10==0 then jH=30 elseif L%5==0 then jH=20 end;local hl=aj+-L*5+jR*5;if jH==30 then jO=dq([[%s M %d %f h %d]],jO,ai-jT-jH,hl,jH)if ci then ju[#ju+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jB,ai,aj,ai-jT+10,hl+4,L)ju[#ju+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jB,ai,aj,ai+jT-10,hl+4,L)if L==0 or L==180 or L==-180 then ju[#ju+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jB,ai,aj,ai-jT+20,hl,jT*2-40)end else ju[#ju+1]=gK(ai-jT+10,hl,L,"pdim txt txtmid")ju[#ju+1]=gK(ai+jT-10,hl,L,"pdim txt txtmid")end;jO=dq([[%s M %d %f h %d]],jO,ai+jT,hl,jH)else jO=dq([[%s M %d %f h %d]],jO,ai-jT-jH,hl,jH)jO=dq([[%s M %d %f h %d]],jO,ai+jT,hl,jH)end end;ju[#ju+1]=jO..[["/>]]local jV="PITCH"if not dd then jV="REL PITCH"end;if jR>90 and not ci then jR=90-(jR-90)elseif jR<-90 and not ci then jR=-90-(jR+90)end;if jD>200 then if ci then if fw>iz then ju[#ju+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")ju[#ju+1]=gK(ai,aj+20,jS,"pdim txt txtmid")end;ju[#ju+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jB,ai,aj)else ju[#ju+1]=dq([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;ju[#ju+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-jT+25,aj-5,ai-jT+20,aj,ai-jT+25,aj+5,ai-jT+50,aj+4,jU)ju[#ju+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+jT-25,aj-5,ai+jT-20,aj,ai+jT-25,aj+5,ai+jT-30,aj+4,jU)ju[#ju+1]="</g>"end;local jW=bF(jD/3)ju[#ju+1]=dq([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-jW,aj,jD-jW)if not ci and dd then ju[#ju+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jB,ai,aj,ai-jT+10,aj,jT*2-20)end;ju[#ju+1]="</g>"if jD<200 then if ci and fw>iz then ju[#ju+1]=gK(ai,aj-jD,jV,"pdim txt txtmid")ju[#ju+1]=gK(ai,aj-jD+10,jU,"pdim txt txtmid")ju[#ju+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")ju[#ju+1]=gK(ai,aj+20,jS,"pdim txt txtmid")else ju[#ju+1]=gK(ai,aj-jD,jV,"pdim txt txtmid")ju[#ju+1]=gK(ai,aj-jD+15,jU,"pdim txt txtmid")end end end end;local function jX(ju,e9,dd)local jY=ao;local jZ=ap;if jY==0 and jZ==0 then return end;local j_=78;local k0=19;local k1=ch;if ch~=-1 then ju[#ju+1]=gK(jY+j_,jZ+k0+20,dq("AGL: %.1fm",ch),"pdim altsm txtend")end;if dd and(e9<200000 and not ci or e9 and ci)then table.insert(ju,dq([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jY-1,jZ-4,j_+2,k0+6,jY+1,jZ-1,j_-4,k0))local gy=0;local k2=1;local k3=0;local k4=e9<0;local k5=e9<iK.surfaceMaxAltitude;local k6=9;if k4 then k6=0 end;local e9=f4(e9)while gy<6 do local k7=11;local k8=16;local k9=9;local ka=14;local jo="altsm"if gy>2 then k8=k8+3;k7=k7+2;ka=ka+2;k9=k9-6;jo="altbig"end;if k4 then jo=jo.." red"elseif k5 then jo=jo.." orange"end;local kb=e9/k2%10;local kc=bF(kb)local kd=bF((kc+1)%10)local ke=k3;if gy==0 then ke=kb-kc;if k4 then ke=1-ke end end;if k4 and(gy==0 or k3~=0)then local gB=kd;kd=kc;kc=gB end;local kf=k8*(ke-1)local kg=kf+k8;local hk=jY+k9+(6-gy)*k7;local hl=jZ+ka;ju[#ju+1]=gK(hk,hl+kf,kd,jo)ju[#ju+1]=gK(hk,hl+kg,kc,jo)gy=gy+1;k2=k2*10;if kc==k6 then k3=ke else k3=0 end end;table.insert(ju,[[</g></g>]])end end;local function kh(fB)local ki=-math.deg(e_(fB.y,fB.z))+180;ki=ki-90;if ki<0 then ki=360+ki end;if ki>180 then ki=-180+ki-180 end;return-ki end;local function kj(fB)local jI=math.deg(e_(fB.y,fB.x))-90;if jI<-180 then jI=360+jI end;return jI end;local function kk(ju,fB,fw,ai,aj)if fw>5 and not ci or fw>iz then local jD=ab;local kl=20;local km=20;local kn=kh(fB)local ko=kj(fB)local kp=14;local kq=kp/2;local kr=-ko/km*jD;local ks=kn/kl*jD;local hk=ai+kr;local hl=aj+ks;local cc=dt(kr^2+ks^2)local kt=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kq/kp..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kq..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kp..[[,]]..hl..[[ h ]]..kq..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+kq..[[,]]..hl..[[ h ]]..kq..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kp..[[ v ]]..kq..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cc<jD then ju[#ju+1]=kt else local jv=e_(ks,kr)local ku=4;local kv=ai+jD*math.cos(jv)local kw=aj+jD*math.sin(jv)ju[#ju+1]=dq('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jv*180/math.pi,kv,kw,kv-ku,kw-ku/2,ku*2,ku,kv+ku,kw-ku,ku,ku,-ku,ku)end;if not ci then local kx=vec3(fB)kn=kh(-kx)ko=kj(-kx)kr=-ko/km*jD;ks=kn/kl*jD;hk=ai+kr;hl=aj+ks;cc=dt(kr^2+ks^2)if cc<jD then local ky=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kp..[[ v ]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-kq..[[,]]..hl..[[ h ]]..kp..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]ju[#ju+1]=ky end end end end;local function kz(ju,iP,kA,kB)if ak==0 and al==0 then return end;kA=bF(kA+0.5)local je=al+10;local jf=al+20;if ie()==1 and not l then je=55;jf=65 end;local kC="CRUISE"local c="km/h"local dR=kB;if iP=="TRAVEL"or iP=="AUTOPILOT"then kC="THROT"c="%"dR=kA;local kD="dim"if kA<0 then kD="red"end;ju[#ju+1]=dq([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kD,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-f4(kA),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;ju[#ju+1]=gK(ak+10,je,kC,"pbright txtstart")ju[#ju+1]=gK(ak+10,jf,dq("%.0f %s",dR,c),"pbright txtstart")if ci and u and d5 and bN then kA=bF(bO*100+0.5)local kD="red"if kA<0 then kD="red"end;ju[#ju+1]=dq([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kD,1-f4(kA),ak-10,al+50,ak-15,al+53,ak-15,al+47)ju[#ju+1]=gK(ak+10,je+40,"LIMIT","pbright txtstart")ju[#ju+1]=gK(ak+10,jf+40,kA.."%","pbright txtstart")end;if ci and u or b4 then ju[#ju+1]=gK(ak+10,je-40,"LIMIT: "..cM.." km/h","dim txtstart")elseif not ci and a_ then ju[#ju+1]=gK(ak+10,je-40,"LIMIT: "..bF(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kE(ju,kF)if ak==0 and al==0 then return end;local kG=al-10;local kH=ak+10;ju[#ju+1]=gK(0,0,"","pdim txt txtend")if ie()==1 and not l then kG=75 end;ju[#ju+1]=gK(kH,kG,bF(kF).." km/h","pbright txtbig txtstart")end;local function kI(ju)ju[#ju+1]=gK(iL(1900),iM(1070),dq("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")ju[#ju+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then ju[#ju+1]=gK(iL(960),iM(550),"Warning: Invalid Control Scheme Detected","warnings")ju[#ju+1]=gK(iL(960),iM(600),"Keyboard Scheme must be selected","warnings")ju[#ju+1]=gK(iL(960),iM(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kJ=iL(960)local kK=iM(860)local kL=iM(880)local kM=iM(900)local kN=iM(960)local kO=iM(200)local kP=iM(250)local kQ=iM(960)if ie()==1 and not l then kK=iM(135)kL=iM(155)kM=iM(175)kO=iM(115)kP=iM(95)end;local kR="#222222"local kS="white"local kT="dimmer"local kU="pbright"local kV="#110000"local kW=kR;local kX=kT;if aX then ju[#ju+1]=gK(kJ,kK,"Brake Engaged","warnings")kV="#440000"kW=kS;kX=kU elseif bM>0 then ju[#ju+1]=gK(kJ,kK,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local kY="#110000"local kZ=kR;local k_=kT;if ci and cK and ch==-1 then if not a_ and not bm and not b2 and not d3 and not b5 and not b3 then ju[#ju+1]=gK(kJ,kO+50,"** STALL WARNING **","warnings")kY="#ff0000"kZ=kS;k_=kU;g0("stall","SW",2)end end;if db then ju[#ju+1]=gK(kJ,kO+90,"Flight Assist in Progress","warnings")end;if co then ju[#ju+1]=gK(kJ,kQ,"Gyro Enabled","warnings")end;local l0="#111100"local l1=kR;local l2=kT;if bi then l0="#775500"l1=kS;l2=kU;if bS then ju[#ju+1]=gK(kJ,kL,"Gear Extended","warn")else ju[#ju+1]=gK(kJ,kL,"Landed (G: Takeoff)","warnings")end;local l3=il(d:getTargetGroundAltitude())ju[#ju+1]=gK(kJ,kM,"Hover Height: "..l3,"warn")end;local l4="#000011"local l5=kR;local l6=kT;if c2 then l4="#0000DD"l5=kS;l6=kU;ju[#ju+1]=gK(kJ,kN+20,"ROCKET BOOST ENABLED","warn")end;local l7="#001100"local l8=kR;local l9=kT;if antigrav and not q and d3 and br~=nil then l7="#00DD00"l8=kS;l9=kU;if f4(ck-antigrav.getBaseAltitude())<501 then ju[#ju+1]=gK(kJ,kO+15,dq("Target Altitude: %d Singularity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warn")else ju[#ju+1]=gK(kJ,kO+15,dq("Target Altitude: %d Singluarity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warnings")end elseif a_ and bf~="None"then ju[#ju+1]=gK(kJ,kO+20,"Autopilot "..bc,"warn")elseif bp~=nil then ju[#ju+1]=gK(kJ,kO+20,dq("LockedPitch: %d",bF(bp)),"warn")elseif b_ then ju[#ju+1]=gK(kJ,kO+20,"Follow Mode Engaged","warn")elseif b4 or cg then ju[#ju+1]=gK(kJ,kO+20,"Re-entry in Progress","warn")end;if b1 or b5 then local l3=il(b6,2)if b5 then if d3 then l3=il(antigrav.getBaseAltitude(),2).." AGG singularity height"end;ju[#ju+1]=gK(kJ,kO,"VTO to "..l3,"warn")elseif b3 and not bv then if cf then ju[#ju+1]=gK(kJ,kO,"Takeoff to "..bf,"warn")else ju[#ju+1]=gK(kJ,kO,"Takeoff to "..l3,"warn")end;if aX and not b5 then ju[#ju+1]=gK(kJ,kO+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else ju[#ju+1]=gK(kJ,kO,"Altitude Hold: "..l3,"warn")end end;if b5 and(antigrav~=nil and antigrav)then if cj>0.1 then ju[#ju+1]=gK(kJ,kO+20,"Beginning ascent","warn")elseif cj<0.09 and cj>0.05 then ju[#ju+1]=gK(kJ,kO+20,"Aligning trajectory","warn")elseif cj<0.05 then ju[#ju+1]=gK(kJ,kO+20,"Leaving atmosphere","warn")end end;if bv then if cO~=nil then ju[#ju+1]=gK(kJ,kO,cO,"warn")end end;if b2 then if la then ju[#ju+1]=gK(kJ,kO,"Brake-Landing","warnings")else ju[#ju+1]=gK(kJ,kO,"Coast-Landing","warnings")end end;if aZ then ju[#ju+1]=gK(kJ,kO,"Prograde Alignment","crit")end;if aY then ju[#ju+1]=gK(kJ,kO,"Retrograde Alignment","crit")end;local lb="#110000"local lc=kR;local ld=kT;if de then lb="#FF0000"lc=kS;ld=kU;local type;if string.find(de,"COLLISION")then type="warnings"else type="crit"end;ju[#ju+1]=gK(kJ,kP+20,de,type)elseif cj==0 then local le,lf=cE.checkLOS(cY:normalize())if lf~=nil then ld=kU;lb="#FF0000"lc=kS;local l3=il(lf)local lg=cz.computeTravelTime(cZ,0,lf)local lh="Collision"if le.noAtmosphericDensityAltitude>0 then lh="Atmosphere"end;ju[#ju+1]=gK(kJ,kP+20,le.name.." "..lh.." "..im(lg).." In "..l3,"crit")end end;if bm and not bv then ju[#ju+1]=gK(kJ,kO+35,li,"warn")end;local lj="#111100"local lk=kR;local ll=kT;if di and#di>1 then lj="#DDDD00"lk=kS;ll=kU end;local lm=iL;local ln=iM;local kT="topButton"local lo="topButtonActive"local lp=kT;if a_ or bm or cf or bv then lp=lo end;local lq=kT;if aZ then lq=lo end;local lr=kT;if b2 or bi then lr=lo end;local ls=kT;if b1 or bm then ls=lo end;local lt=kT;if aY then lt=lo end;local lu=kT;if bv or cR and a_ then lu=lo end;if x and I then local lv=ln(30)ju[#ju+1]=dq([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lp,lm(960),ln(54),ln(-53),lm(-120),lm(25),ln(50))ju[#ju+1]=gK(lm(910),lv,"AUTOPILOT")ju[#ju+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lq,lm(865),ln(51),lm(-25),ln(-50),lm(-110),lm(25),ln(46))ju[#ju+1]=gK(lm(800),lv,"PROGRADE")ju[#ju+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lr,lm(755),ln(47),lm(-25),ln(-46),lm(-98),lm(44),ln(44))ju[#ju+1]=gK(lm(700),lv,"LAND")ju[#ju+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],ls,lm(960),ln(54),ln(-53),lm(120),lm(-25),ln(50))ju[#ju+1]=gK(lm(1010),lv,"ALT HOLD")ju[#ju+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lt,lm(1055),ln(51),lm(25),ln(-50),lm(110),lm(-25),ln(46))ju[#ju+1]=gK(lm(1122),lv,"RETROGRADE")ju[#ju+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lu,lm(1165),ln(47),lm(25),ln(-46),lm(98),lm(-44),ln(44))ju[#ju+1]=gK(lm(1220),lv,"ORBIT")ju[#ju+1]=[[
                                    </g>
                                </g>]]ju[#ju+1]="</g>"end;return ju end;local function lw(fw)return bF(ii(fw*3.6,0)+0.5).." km/h"end;local function lx(gy)local gA=bf;if gy~=nil and type(gy)=="number"then if gy==0 then return"None"end;gA=d8[gy].name end;if gA==nil then gA=ga.name end;if gA==nil then gA="None"end;return gA end;local function ly(ju)local lz=cE.routeWP(true)if not lz or#lz==0 then return end;local hk=iL(750)local hl=iM(360)if a_ or bm then ju[#ju+1]=gK(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else ju[#ju+1]=gK(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dQ,L in pairs(lz)do hl=hl+20;ju[#ju+1]=gK(hk,hl,dQ..". "..lx(lz[dQ]),"pdim txtstart size20")end end;local function lA(ju)local hk=aw+10;local hl=ax+20;local lB={}local lC={"Alt-4: AutoTakeoff to Target"}local lD={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lE={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lF={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lB,"--------------DYNAMIC-----------------")if ci then if ch~=-1 then ij(lB,lC)if c5 and iK and c5.name==iK.name then table.insert(lB,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if d3 then table.insert(lB,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lB,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lB,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lB,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lB,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lB,"G: Takeoff to hover height, raise gear")else table.insert(lB,"G: Lowergear and Land")end else ij(lB,lD)table.insert(lB,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lB,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ij(lB,lE)if ib then table.insert(lB,"Alt-Shift-6: Vent shields")table.insert(lB,"Alt-Shift-7: Toggle shied off/on")end end;if ga~=nil then table.insert(lB,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lB,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lB,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lB,"Alt-Spacebar/C will raise/lower target height")table.insert(lB,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ci then table.insert(lB,"LALT+Mousewheel will lower/raise speed limit")end;ij(lB,lF)for L=1,#lB do hl=hl+12;ju[#ju+1]=gK(hk,hl,lB[L],"pdim txtbig txtstart")end end;local function lG(ju)local lH=aw;local lI=ax;local lJ=av;local lK=4;local lL=15;local hk=0;local hl=0;local lM,lN,lO,lP;local lQ;local function lR(type)local lS,bH,fw,lT,jo,lU;if type=="Periapsis"then lS=lQ.periapsis.altitude;bH=lQ.timeToPeriapsis;fw=lQ.periapsis.speed;jo="txtend"lT=12;lU=math.min(hk,lH+lJ-iK.radius/lO-lK*2)else lS=lQ.apoapsis.altitude;bH=lQ.timeToApoapsis;fw=lQ.apoapsis.speed;lT=-12;jo="txtstart"lU=hk end;if cZ<1 then bH=0 end;ju[#ju+1]=dq([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lU+lT,hl-5,hk,hl-5)ju[#ju+1]=dq([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lU-lT*4,hl+2,hk,hl+2)ju[#ju+1]=gK(lU,hl,type,jo)hk=lU-lT*2;hl=hl+lL;local l3=il(lS)ju[#ju+1]=gK(hk,hl,l3,jo)hl=hl+lL;ju[#ju+1]=gK(hk,hl,im(bH),jo)hl=hl+lL;ju[#ju+1]=gK(hk,hl,lw(fw),jo)end;local lV=lJ*1.5;if bC=="INFO"then lV=25*9 end;if bC~="HIDE"then ju[#ju+1]=[[<g class="pbright txtorb txtmid">]]ju[#ju+1]=dq('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lJ*2,lV,lH,lI)ju[#ju+1]=dq([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lJ*2,lV,lH,lI)end;local lW=lJ*1.5;local lX=lJ*2;local lY=lW/2;local lZ=lJ;local l_=lH+lZ;local m0=lI+lY;local m1=lH+lX;local m2=lI+lW;if bC=="ORBIT"then lI=lI+lK;lM=lJ/2;lP=0;lQ={}lQ.periapsis={}lQ.apoapsis={}if fA~=nil then if fA.periapsis~=nil then lQ.periapsis.altitude=fA.periapsis.altitude;lQ.periapsis.speed=fA.periapsis.speed end;if fA.apoapsis~=nil then lQ.apoapsis.altitude=fA.apoapsis.altitude;lQ.apoapsis.speed=fA.apoapsis.speed end;lQ.period=fA.period;lQ.eccentricity=fA.eccentricity;lQ.timeToApoapsis=fA.timeToApoapsis;lQ.timeToPeriapsis=fA.timeToPeriapsis;lQ.eccentricAnomaly=fA.eccentricAnomaly;lQ.trueAnomaly=fA.trueAnomaly end;if lQ.periapsis==nil then lQ.periapsis={}lQ.periapsis.altitude=-iK.radius;lQ.periapsis.speed=a0 end;if lQ.eccentricity==nil then lQ.eccentricity=1 end;if lQ.apoapsis==nil then lQ.apoapsis={}lQ.apoapsis.altitude=ck;lQ.apoapsis.speed=0 end;if cZ<1 then lQ.apoapsis.altitude=ck;lQ.apoapsis.speed=0 end;if lQ.apoapsis.altitude then lO=(lQ.apoapsis.altitude+lQ.periapsis.altitude+iK.radius*2)/(lM*2)lN=(iK.radius+lQ.apoapsis.altitude)/lO*(1-lQ.eccentricity)lP=lM-lQ.periapsis.altitude/lO-iK.radius/lO;local m3=math.pi;if lQ.period~=nil and lQ.period>0 and lQ.timeToApoapsis~=nil then m3=lQ.eccentricAnomaly;if lQ.timeToPeriapsis<lQ.timeToApoapsis then m3=2*math.pi-m3 end end;if cZ<1 or m3~=m3 then m3=math.pi end;local m4=-lM*math.cos(m3)+lH+lZ+lK;local m5=lN*math.sin(m3)+lI+lY+lK;local m6=""ju[#ju+1]='<g clip-path="url(#orbitRect)">'ju[#ju+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m6,lH+lJ+lK,lI+lJ*1.5/2+lK,lM,lN)if lN<1 then ju[#ju+1]=dq([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lH+lJ+lK-lP,lI+lJ*1.5/2+lK,m4,m5)end;ju[#ju+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lH+lJ+lK-lP,lI+lJ*1.5/2+lK,(iK.radius+iK.noAtmosphericDensityAltitude)/lO)ju[#ju+1]=dq('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lH+lJ+lK-lP,lI+lJ*1.5/2+lK,(iK.radius+iK.noAtmosphericDensityAltitude)/lO)ju[#ju+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lH+lJ+lK,lI+lJ*1.5/2+lK,lM,lN)ju[#ju+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lH+lJ+lK-lP,lI+lJ*1.5/2+lK,iK.radius/lO)ju[#ju+1]='</g>'local m7=math.floor(iK.radius/lO+0.5)hk=lH+lJ+lK*4+lM;hl=lI+lJ*1.5/2+5+lK;if lQ.apoapsis~=nil and lQ.apoapsis.speed<a0 then lR("Apoapsis")end;hl=lI+lJ*1.5/2+5+lK;hk=lH+lJ-lK*2-lM;if lQ.periapsis~=nil and lQ.periapsis.speed<a0 and lQ.periapsis.altitude>0 then lR("Periapsis")end;ju[#ju+1]=gK(lH+lJ+lK,lI+20+lK,iK.name,"txtorbbig")ju[#ju+1]=dq('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m4,m5)ju[#ju+1]=[[</g>]]return ju else ju[#ju+1]='<g clip-path="url(#orbitRect)">'local m8=""local m9=1.2*(ma-mb)/(lJ*2)local mc=1.4*(md-me)/(lJ*1.5)for dQ,dC in pairs(e[0])do if dC.center then local hk=lH+lJ+dC.center.x/m9;local hl=lI+lJ*1.5/2+dC.center.y/mc;m8=m8 ..'<circle cx="'..hk..'" cy="'..hl..'" r="'..dC.radius/m9*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dC.name,"Moon")and not string.match(dC.name,"Sanctuary")and not string.match(dC.name,"Space")then m8=m8 .."<text x='"..hk.."' y='"..hl+dC.radius/m9*30+20 .."' font-size='12' fill="..cp.." text-anchor='middle' font-family='Montserrat'>"..dC.name.."</text>"end end end;local fC=vec3(b.getConstructWorldPos())local hk=lH+lJ+fC.x/m9;local hl=lI+lJ*1.5/2+fC.y/mc;m8=m8 ..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'m8=m8 .."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"it=m9;iu=mc;local mf=fC+cY*1000000;local mg=lH+lJ+mf.x/m9;local jf=lI+lJ*1.5/2+mf.y/mc;m8=m8 ..'<line x1="'..hk..'" y1="'..hl..'" x2="'..mg..'" y2="'..jf..'" stroke="purple" stroke-width="1"/>'ju[#ju+1]=m8;ju[#ju+1]='</g>'end elseif bC=="INFO"then ju=cC.DrawOdometer(ju,c6,bj,c7)elseif bC=="HELP"then ju=lA(ju)elseif bC=="SCOPE"then ju[#ju+1]='<g clip-path="url(#orbitRect)">'local mh=dl;if cj>0 then table.sort(dk,function(eG,eH)local eI,eJ=eG.center,eH.center;return(eI.x-d1.x)^2+(eI.y-d1.y)^2+(eI.z-d1.z)^2<(eJ.x-d1.x)^2+(eJ.y-d1.y)^2+(eJ.z-d1.z)^2 end)end;local gS={}local mi={}local mj=120;local mk=nil;local ml=nil;for L,dC in ipairs(dk)do local gR=dC.center-d1;local mm=gR:len()local mn=gR:normalize()local mo=gR:cross(cV):normalize()local mp=math.acos(mo:dot(cW))if mp~=mp then mp=0 end;if mo:cross(cW):dot(cV)<0 then mp=-mp end;local mq=gR:project_on_plane(cV):len()local mr=math.sin(mp)*math.asin(mq/mm)*constants.rad2deg;local ms=math.cos(mp)*math.asin(mq/mm)*constants.rad2deg;if mn:dot(cV)<0 then ms=90*math.cos(mp)+90*math.cos(mp)-ms;mr=90*math.sin(mp)+90*math.sin(mp)-mr end;local hk=l_+mr/mh*lW;local hl=m0+ms/mh*lW;local mt=(hk-l_)*(hk-l_)+(hl-m0)*(hl-m0)local mu=math.asin((dC.radius+dC.surfaceMaxAltitude)/mm)*constants.rad2deg;if mu~=mu then mu=mh end;local hQ=mu/mh*lW;local mv=math.asin(dC.atmosphereRadius/mm)*constants.rad2deg;if mv~=mv then mv=mu end;local mw=mv/mh*lW;local cc=il(mm,1)local mx=dC.name;local my=false;if hl>lI then if hl>m2 then if hl-mw<=m2 then my=true end else my=true end else if hl+mw>=lI then my=true end end;local mz=false;local mA=hk;if dC.systemId==0 then mA=hk+mj else mA=hk-mj end;if mA+mj>lH then if mA+mj>m1 then if mA-mw-mj<=m1 then mz=true end else mz=true end else if mA+mw+mj>=lH then mz=true end end;local mB={}mB.x=hk;mB.y=hl;mB.planet=dC;mB.atmoSize=mw;if not mk or mt<mk then mk=mt;ml=mB end;if mz and my then local mC=math.max(mw,5)if mt<mC*mC then mx=mx.." - "..cc end;mB.size=hQ;mB.i=L;mB.displayString=mx;mB.distance=cc;mB.visible=true;mi[#mi+1]=mB else mB.visible=false end end;local mD=false;table.sort(mi,function(eI,eJ)return eI.y<eJ.y end)for dQ,fF in ipairs(mi)do local dC,hQ,L,mw,hk,hl,mx,cc=fF.planet,fF.size,fF.i,fF.atmoSize,fF.x,fF.y,fF.displayString,fF.distance;local lU,mE,mF,mG;local mH=15;local jo="pdim"if dC.systemId~=0 then mF=iL(string.len(mx)*5)mH=-(15+mF)mG=iM(10)jo="pdimfill"else mF=iL(string.len(mx)*9)mG=iM(15)end;if hQ*2>mF then lU=dr(hk,lH+mF/2,m1-mF/2)mE=dr(hl,lI+mG,m2-5)lU=dr(lU,hk-hQ+mF/2,hk+hQ-mF/2)mE=dr(mE,hl-hQ+mG,hl+hQ)else lU=hk+mH;mE=hl end;for mI,fF in pairs(gS)do local mJ=fF.textPositions;local mK=mJ.y-mE;if mI~=L and f4(mK)<mJ.height and mJ.x+mJ.width>lU and mJ.x<lU+mF then if hQ>mF then mE=dr(mE+mG,lI+15,m2-5)else mE=mJ.y+mJ.height+1 end end end;local mL=mx~=dC.name or lU<=l_ and lU+mF>=l_ and mE-mG<=m0 and mE>=m0;fF.hovered=mL;local mM=1;if mL then mM=2;if hQ*2<mF then mM=10 end;if mx==dC.name then mx=mx.." - "..cc end;jo="pbright"if dC.systemId~=0 then mF=iL(string.len(mx)*5)mH=-(15+mF)else mF=iL(string.len(mx)*7)end;if hQ*2>mF then lU=dr(hk,lH+mF/2,m1-mF/2)lU=dr(lU,hk-hQ+mF/2,hk+hQ-mF/2)else lU=hk+mH end end;gS[L]={}gS[L].textPositions={}gS[L].textPositions.y=mE;gS[L].textPositions.x=lU;gS[L].textPositions.width=mF;gS[L].textPositions.height=mG;gS[L].output=""if hQ*2>mF then jo=jo.." txtmid"else jo=jo.." txtstart"end;if mw-hQ>2 then gS[L].output=dq('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mw,cq,0.1*mM)end;gS[L].output=gS[L].output..dq('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hQ,cq,0.2*mM)if dC.systemId==0 then gS[L].output=gS[L].output..dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lU,mE,cp,jo,mx)if hQ*2<=mF then gS[L].output=gS[L].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lU+mF,mE+2,lU,mE+2,hk,hl)end else gS[L].output=gS[L].output..dq([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lU,mE,cq,jo,mx)if hQ*2<=mF then gS[L].output=gS[L].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lU,mE+2,lU+mF,mE+2,hk,hl)end end end;for dQ=#dk,1,-1 do if gS[dQ]then ju[#ju+1]=gS[dQ].output end end;if ml~=nil and dl<90 and not ml.hovered then local mN=ml.planet.atmosphereRadius/ml.atmoSize;local mO=dt(mk)*mN;local mP=il(mO,1)local mF=iL(math.max(string.len(mP)*7,string.len(ml.planet.name)*7))local mG=iM(12)local lU=dr(ml.x+(l_-ml.x)/2,lH+mF/2,m1-mF/2)local mE=dr(ml.y+(m0-ml.y)/2,lI+mG*2,m2-5)ju[#ju+1]=dq("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",ml.x,ml.y,l_,m0)ju[#ju+1]=dq([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lU,mE,"white",mP)if not ml.visible then ju[#ju+1]=dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lU,mE-mG,"white",ml.planet.name)end end;if cZ>1 then local gR=cY;local mn=gR:normalize()local mq=gR:project_on_plane(cV):len()local mo=gR:cross(cV):normalize()local mp=math.acos(mo:dot(cW))if mp~=mp then mp=0 end;if mo:cross(cW):dot(cV)<0 then mp=-mp end;local mr=math.sin(mp)*math.asin(mq/gR:len())*constants.rad2deg;local ms=math.cos(mp)*math.asin(mq/gR:len())*constants.rad2deg;if mn:dot(cV)<0 then ms=90*math.cos(mp)+90*math.cos(mp)-ms;mr=90*math.sin(mp)+90*math.sin(mp)-mr end;local hk=l_+mr/mh*lW;local hl=m0+ms/mh*lW;local kp=14;local kq=kp/2;local kt=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kq/kp..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kp..[[,]]..hl..[[ h ]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+kq..[[,]]..hl..[[ h ]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kp..[[ v ]]..kq..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]ju[#ju+1]=kt end;ju[#ju+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",l_,m0-10,l_,m0+10)ju[#ju+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",l_-10,m0,l_+10,m0)ju[#ju+1]='</g>'else return ju end end;local function mQ(mR,mS)local mT;local mU=(mS-mR):normalize()local fD=(d1-mR):dot(mU)/mU:dot(mU)if fD<=0. then return(d1-mR):len()elseif fD>=(mS-mR):len()then return(d1-mS):len()end;local mV=mR+fD*mU;mT=(mV-d1):len()return mT end;local function mW()local mT;local mX=nil;local mY=nil;local mZ=nil;for dQ,m_ in pairs(e[0])do if m_.hasAtmosphere then local cc=mQ(iK.center,m_.center)if mX==nil or cc<mX then mY=m_;mX=cc;mZ=iK end;if c5 and c5.hasAtmosphere and c5.name~=iK.name then local eV=mQ(c5.center,m_.center)if eV<mX then mY=m_;mX=eV;mZ=c5 end end end end;local n0=iL(1770)local n1=iM(330)if mX then local n2="txttick "local n3=500000;if mX<mY.radius+n3 or mX<mZ.radius+n3 then if d9 then n2="txttick red "else n2="txttick orange "end end;mT=il(mX,2)iy=gK(n0,n1,"Pipe ("..mZ.name.."--"..mY.name.."): "..mT,n2 .."pbright txtmid")end end;local function n4(hk,hl,n5,n6,kC)local n7={x=hk,y=hl,width=n5,height=n6,label=kC}is[kC]=n7;return n7 end;local function n8(n9,na,n5,n6,hk,hl,nb,nc,nd,ne,jo)local n7={enableName=n9,disableName=na,width=n5,height=n6,x=hk,y=hl,toggleVar=nb,toggleFunction=nc,drawCondition=nd,hovered=false,class=jo}if ne then table.insert(ir,n7)else table.insert(iq,n7)end;return n7 end;local function nf(ng)if not iw then nh=false;ni=false;nj=false;x=true;return elseif ng=="handling"then nh=not nh;ni=false;nj=false elseif ng=="hud"then ni=not ni;nh=false;nj=false elseif ng=="physics"then nj=not nj;nh=false;ni=false end;if nj or ni or nh then ix=ik(ng)x=false else ix="none"x=true end end;local function nk()iw=not iw;if iw then ip=ir;c1="Hold SHIFT to see Settings"dm=x else ip=iq;c1="Hold SHIFT to see Control Buttons"nf()x=dm end end;local function nl()local function nm(dC,dQ)dC.set(not dC.get())if dC.get()then c1=dQ.." set to true"else c1=dQ.." set to false"end;if dQ=="showHud"then dm=dC.get()elseif dQ=="BrakeToggleDefault"then aV=j end end;local nn=50;local no=340;local hk=500;local hl=ct/2-400;local np=0;for dQ,dC in pairs(ik("boolean"))do if type(dC.get())=="boolean"then n8(dQ,dQ,no,nn,hk,hl,function()return dC.get()end,function()nm(dC,dQ)end,function()return true end,true)hl=hl+nn+20;if np==9 then hk=hk+no+20;hl=ct/2-400;np=0 else np=np+1 end end end;n8("Control View","Control View",no,nn,10,ct/2-500,function()return true end,nk,function()return true end,true)n8("View Handling Settings",'Hide Handling Settings',no,nn,10,ct/2-(500-nn),function()return nh end,function()nf("handling")end,function()return true end,true)n8("View Hud Settings",'Hide Hud Settings',no,nn,10,ct/2-(500-nn*2),function()return ni end,function()nf("hud")end,function()return true end,true)n8("View Physics Settings",'Hide Physics Settings',no,nn,10,ct/2-(500-nn*3),function()return nj end,function()nf("physics")end,function()return true end,true)end;local function nq()local function gz()local g2=d1;local gA=iK.name..". "..#bl;if radar_1 then gA=cF.GetClosestName(gA)end;return cD.AddNewLocation(gA,g2,false,true)end;local function nr()b0=not b0 end;local function ns(nt)if nt==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;b_=false;b2=false;bp=nil;b4=false;b3=false end;local function nu()cD.UpdatePosition()end;local function gx()cD.ClearCurrentPosition()end;local function nv(gy)local lz=cE.routeWP(true)if lz and#lz>0 then return"Engage Route: "..lx(lz[1])end;return"Engage Autopilot: "..lx(gy)end;local function nw(gy)local lz=cE.routeWP(true)if lz and#lz>0 then return"Next Route Point: "..lx(lz[1])end;return"Disable Autopilot: "..lx(gy)end;local function nx()if ie()==1 then b_=not b_;if b_ then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;ny=bi;bi=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(Y)g0("folOn","F")else g0("folOff","F")aX=true;cJ=p;bi=ny;if bi then d.control.extendLandingGears()ig:setTargetGroundAltitude(Z)end end else c1="Follow Mode only works with Remote controller"b_=false end end;local nn=50;local no=260;local nz=iL(30)local nA=aw+av*2+2;local nB=ax+1;n8("+","+",nz,nz,nA,nB+nz+1,function()return false end,function()dl=dl/8 end,function()return bC=="SCOPE"end,nil,"ZoomButton")n8("-","-",nz,nz,nA,nB,function()return false end,function()dl=math.min(dl*8,90)end,function()return bC=="SCOPE"end,nil,"ZoomButton")n8("0","0",nz,nz,nA,nB+nz*2+2,function()return false end,function()dl=90 end,function()return bC=="SCOPE"and dl~=90 end,nil,"ZoomButton")local nC=n8("Enable Brake Toggle","Disable Brake Toggle",no,nn,cs/2-no/2,ct/2+350,function()return aV end,function()aV=not aV;if aV then c1="Brakes in Toggle Mode"else c1="Brakes in Default Mode"end end)n8("Align Prograde","Disable Prograde",no,nn,cs/2-no/2-50-nC.width,ct/2-nn+380,function()return aZ end,function()ns(1)end)n8("Align Retrograde","Disable Retrograde",no,nn,cs/2-no/2+nC.width+50,ct/2-nn+380,function()return aY end,ns,function()return cj==0 end)nD=n8(nv,nw,600,60,cs/2-600/2,ct/2-60/2-330,function()return a_ or bm or cf or bv end,function()end)local L;local function nE(nF)local lz=cE.routeWP(true)if lz and#lz>0 then return lz[1]end;local gy=dh+nF;if gy>#d8 then gy=gy-#d8-1 end;if gy<0 then gy=#d8+gy end;return gy end;nG={}for L=0,10 do local nH=n8(function(eJ)local gy=nE(eJ.apExtraIndex)if a_ or bm or cf or bv then return"Redirect: "..lx(gy)end;return nv(gy)end,function(eJ)local gy=nE(eJ.apExtraIndex)return nw(gy)end,600,60,cs/2-600/2,ct/2-60/2-330+60*L,function(eJ)local gy=nE(eJ.apExtraIndex)return gy==bh and(a_ or bm or cf or bv)end,function(eJ)local gy=nE(eJ.apExtraIndex)local nI=bh==gy;bh=gy;cD.UpdateAutopilotTarget()cE.ToggleAutopilot()if not nI and not(a_ or bm or cf or bv)then cE.ToggleAutopilot()end end,function()return dg and(#cE.routeWP(true)==0 or L==0)end)nH.apExtraIndex=L;nG[L]=nH end;n8("Save Position","Save Position",200,nD.height,nD.x+nD.width+30,nD.y,function()return false end,gz,function()return bh==0 or ga==nil end)n8("Update Position","Update Position",200,nD.height,nD.x+nD.width+30,nD.y,function()return false end,nu,function()return bh>0 and ga~=nil end)n8("Clear Position","Clear Position",200,nD.height,nD.x-200-30,nD.y,function()return true end,gx,function()return bh>0 and ga~=nil end)n8("Save Route","Save Route",200,nD.height,nD.x+nD.width+30,nD.y+nD.height+20,function()return false end,function()cE.routeWP(false,false,2)end,function()return#cE.routeWP(true)>0 end)n8("Load Route","Clear Route",200,nD.height,nD.x-200-30,nD.y+nD.height+20,function()return#cE.routeWP(true)>0 end,function()if#cE.routeWP(true)>0 then cE.routeWP(false,true)elseif a_ or bm then c1="Disable Autopilot before loading route"return else cE.routeWP(false,false,1)end end,function()return true end)nn=60;no=300;local hk=0;local hl=ct/2-150;n8("Enable Check Damage","Disable Check Damage",no,nn,hk,hl-nn-20,function()return s end,function()s=not s end)n8("View Settings","View Settings",no,nn,hk,hl,function()return true end,nk)hl=hl+nn+20;n8("Enable Turn and Burn","Disable Turn and Burn",no,nn,hk,hl,function()return b0 end,nr)hk=10;hl=ct/2-300;n8("Horizontal Takeoff Mode","Vertical Takeoff Mode",no,nn,hk+no+20,hl,function()return aW end,function()aW=not aW;if aW then c1="Vertical Takeoff Mode"else c1="Horizontal Takeoff Mode"end end,function()return d2 end)hl=hl+nn+20;n8("Engage Orbiting","Cancel Orbiting",no,nn,hk+no+20,hl,function()return bv end,cE.ToggleIntoOrbit,function()return cj==0 and dd end)hl=ct/2-150;n8("Glide Re-Entry","Cancel Glide Re-Entry",no,nn,hk+no+20,hl,function()return b4 end,function()ce=1;ns(1)end,function()return iK.hasAtmosphere and not ci end)hl=hl+nn+20;n8("Parachute Re-Entry","Cancel Parachute Re-Entry",no,nn,hk+no+20,hl,function()return b4 end,function()ce=2;ns(1)end,function()return iK.hasAtmosphere and not ci end)hl=hl+nn+20;n8("Engage Follow Mode","Disable Follow Mode",no,nn,hk,hl,function()return b_ end,nx,function()return ie()==1 end)n8("Enable Repair Arrows","Disable Repair Arrows",no,nn,hk+no+20,hl,function()return cx end,function()cx=not cx;if cx then c1="Repair Arrows Enabled"else c1="Repair Arrows Diabled"end end,function()return ie()==1 end)hl=hl+nn+20;if not q then n8("Enable AGG","Disable AGG",no,nn,hk,hl,function()return d3 end,cE.ToggleAntigrav,function()return antigrav~=nil end)end;n8(function()return dq("Switch IPH Mode - Current: %s",bw)end,function()return dq("IPH Mode: %s",bw)end,no*2,nn,hk,hl,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;c1="IPH Mode: "..bw end)hl=hl+nn+20;n8(function()return dq("Toggle Control Scheme - Current: %s",g)end,function()return dq("Control Scheme: %s",g)end,no*2,nn,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c1="New Control Scheme: "..g end)local nJ=iM(20)local nH=n4(0,0,iL(70),nJ,"HELP")nH=n4(nH.x+nH.width,nH.y,iL(80),nJ,"INFO")nH=n4(nH.x+nH.width,nH.y,iL(70),nJ,"ORBIT")nH=n4(nH.x+nH.width,nH.y,iL(70),nJ,"SCOPE")n4(nH.x+nH.width,nH.y,iL(70),nJ,"HIDE")end;local nK={}local nL=nil;function nK.HUDPrologue(ju)d9,da=iI(d1)if not d9 then bI=af;bK=ag;bJ=ah;if ib and G and ib.getState()==0 then ib.toggle()end else bI=ac;bK=ad;bJ=ae;if ib and G and ib.getState()==1 then ib.toggle()end end;cp=[[rgb(]]..bF(bI+0.6)..","..bF(bK+0.6)..","..bF(bJ+0.6)..[[)]]cq=[[rgb(]]..bF(bI*0.8+0.5)..","..bF(bK*0.8+0.5)..","..bF(bJ*0.8+0.5)..[[)]]local nM=cp;local nN=cq;local nO=[[rgb(]]..bF(bI*0.4+0.5)..","..bF(bK*0.4+0.5)..","..bF(bJ*0.4+0.5)..[[)]]local nP=cp;local nQ=cq;local nR=nO;if iN()and not m then nM=[[rgb(]]..bF(bI*0.5+0.5)..","..bF(bK*0.5+0.5)..","..bF(bJ*0.5+0.5)..[[)]]nN=[[rgb(]]..bF(bI*0.3+0.5)..","..bF(bK*0.3+0.5)..","..bF(bJ*0.2+0.5)..[[)]]nO=[[rgb(]]..bF(bI*0.2+0.5)..","..bF(bK*0.2+0.5)..","..bF(bJ*0.2+0.5)..[[)]]end;local lm=iL;local ln=iM;ju[#ju+1]=dq([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nM,nM,nM,nP,nP,nN,nN,nQ,nQ,nN,nM,nO,nQ,nM,nM,nO,nO,nR,nO,cs,ct,nN,nN,nN,nN,nN,nP,nN,nQ,nR,nQ,nQ,nR)if not nL then nL=dq([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lm(630),ln(0),lm(675),ln(45),lm(960),ln(55),lm(1245),ln(45),lm(1290),ln(0),lm(1000),ln(105),lm(1040),ln(59),lm(1250),ln(51),lm(1300),ln(0),lm(1920),ln(0),lm(1920),ln(20),lm(1400),ln(20),lm(1300),ln(105),lm(920),ln(105),lm(880),ln(59),lm(670),ln(51),lm(620),ln(0),lm(0),ln(0),lm(0),ln(20),lm(520),ln(20),lm(620),ln(105),lm(890),ln(59),lm(960),ln(62),lm(1030),ln(59),lm(985),ln(112),lm(1150),ln(112),lm(1100),ln(152),lm(820),ln(152),lm(780),ln(112),lm(935),ln(112),lm(890),ln(59),lm(960),ln(62),lm(1030),ln(59),lm(985),ln(112),lm(1150),ln(112),lm(1100),ln(152),lm(820),ln(152),lm(780),ln(112),lm(935),ln(112))end;if x and I then ju[#ju+1]=nL end;return ju end;function nK.DrawVerticalSpeed(ju,e9)jt(ju,e9)end;function nK.UpdateHud(ju)local ki=d6;local nS=d7;local jB=nS;local jR=ki;local kA=bF(c.getThrottle())local kF=cZ*3.6;local kB=c.getAxisCommandValue(0)local nT=iL(1770)local nU=iM(310)if u and d5 then kB=bL;kA=bL*100 end;local iP=iO()local jC="ROLL"if kA==nil then kA=0 end;if not dd then if cZ>5 then ki=kh(cX)nS=kj(cX)else ki=0;nS=0 end;jC="YAW"end;if da>50000 and not ci then local nV;nV=il(da)ju[#ju+1]=gK(nT,nU,"PvP Boundary: "..nV,"pbright txtbig txtmid")end;ju[#ju+1]=cd;ju[#ju+1]=cr;ju[#ju+1]=i6;if iy~=""then ju[#ju+1]=iy end;if iQ~=""then ju[#ju+1]=iQ end;if iR~=""then ju[#ju+1]=iR end;jt(ju,ck)if ie()==0 or l then if dd then jA(ju,ai,aj,jB,jC,dd)else jA(ju,ai,aj,nS,jC,dd)end;if not iN()or m then if dd then jA(ju,ai,aj,jB,jC,dd)jQ(ju,jR,jB,ai,aj,dd,bF(kj(cX)),cZ)else jA(ju,ai,aj,nS,jC,dd)jQ(ju,ki,nS,ai,aj,dd,bF(nS),cZ)end;jX(ju,ck,dd)kk(ju,cX,cZ,ai,aj)end end;kz(ju,iP,kA,kB)kE(ju,kF)kI(ju)lG(ju)if not iw and c0 then ly(ju)end;return ju end;function nK.HUDEpilogue(ju)ju[#ju+1]="</svg>"return ju end;function nK.ExtraData(ju)local nW=iL(1240)local nX=iM(55)local nY=nX+10;local gD;local lm=iL;local ln=iM;local nZ=0;local iP=iO()if aW then iP=iP.."-VERTICAL"end;if F and not b3 and not b2 and cZ>20 then iP=iP.."-COLLISION ON"end;if by~="Off"then iP="("..by..")-"..iP end;if b0 then iP="TB-"..iP end;if not bx then iP=iP.."-DeCoupled"end;local n_=ln(99)local o0=ln(80)local o1=ln(85)local o2=ln(31)local o3=0;local o4=0;local o5=cm>1000000 and ii(cm/1000000,2).."kT"or ii(cm/1000,2).."T"if ci then nZ=bq else nZ=bo end;local o6,o7=cz.computeDistanceAndTime(cZ,0,cm,0,0,nZ)if o6<0 then o6=0 end;nZ=ii(nZ/(cm*io),2).."g"local o8=d:maxForceForward()gD=b.g()if gD>0.1 then o4=cm*gD;o4=ii(o4/(cm*io),2).."g"o3=0.5*o8/gD;o3=o3>1000000 and ii(o3/1000000,2).."kT"or ii(o3/1000,2).."T"end;o8=ii(o8/(cm*io),2).."g"local o9=vec3(b.getWorldAcceleration()):len()/9.80665;gD=b.g()ju[#ju+1]=[[<g class="dim txt txtend size14">]]if ie()==1 and not l then nW=iL(1120)nX=iM(55)nY=nX+10 elseif ci and I then local oa=iL(770)ju[#ju+1]=gK(lm(895),n_,"ATMO","")ju[#ju+1]=dq([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lm(895),o1,lm(-80))ju[#ju+1]=gK(lm(815),o0,dq("%.1f%%",cj*100),"txtstart size20")end;if I then ju[#ju+1]=gK(lm(1025),n_,"GRAVITY","txtstart")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(1025),o1,lm(80))ju[#ju+1]=gK(lm(1105),o0,dq("%.2fg",gD/9.80665),"size20")ju[#ju+1]=gK(lm(1125),n_,"ACCEL","txtstart")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(1125),o1,lm(80))ju[#ju+1]=gK(lm(1205),o0,dq("%.2fg",o9),"size20")ju[#ju+1]=gK(lm(695),n_,"BRK TIME","")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(695),o1,lm(-80))ju[#ju+1]=gK(lm(615),o0,dq("%s",im(o7)),"txtstart size20")ju[#ju+1]=gK(lm(635),ln(45),"TRIP","")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(635),ln(31),lm(-90))if lg then ju[#ju+1]=gK(lm(532),ln(23),dq("%s",im(lg)),"txtstart size20")end;ju[#ju+1]=gK(lm(795),n_,"BRK DIST","")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(795),o1,lm(-80))ju[#ju+1]=gK(lm(715),o0,dq("%s",il(o6)),"txtstart size20")ju[#ju+1]=gK(lm(1285),ln(45),"MASS","txtstart")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(1285),ln(31),lm(90))ju[#ju+1]=gK(lm(1388),ln(23),dq("%s",o5),"size20")ju[#ju+1]=gK(lm(1220),n_,"THRUST","txtstart")ju[#ju+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lm(1220),o1,lm(80))ju[#ju+1]=gK(lm(1300),o0,dq("%s",o8),"size20")ju[#ju+1]=gK(iL(960),iM(175),iP,"pbright txtbig txtmid size20")end;ju[#ju+1]="</g>"end;local ob=1-(a6*0.05+a7*0.05)function nK.FuelUsed(oc)local od;if oc=="atmofueltank"then od=dq("Atmo Fuel Used: %.1f L",j6[oc]/(4*ob))elseif oc=="spacefueltank"then od=dq("Space Fuel Used: %.1f L",j6[oc]/(6*ob))else od=dq("Rocket Fuel Used: %.1f L",j6[oc]/(0.8*ob))end;return od end;function nK.DrawOdometer(ju,c6,bj,c7)if bC~="INFO"then return ju end;local gD;local o3=0;local o4=0;local nZ=0;local o5=cm>1000000 and ii(cm/1000000,2).." kTons"or ii(cm/1000,2).." Tons"if ci then nZ=bq else nZ=bo end;local o6,o7=cz.computeDistanceAndTime(cZ,0,cm,0,0,nZ)nZ=ii(nZ/(cm*io),2).." g"local o8=d:maxForceForward()gD=b.g()if gD>0.1 then o4=cm*gD;o4=ii(o4/(cm*io),2).." g"o3=0.5*o8/gD;o3=o3>1000000 and ii(o3/1000000,2).." kTons"or ii(o3/1000,2).." Tons"end;o8=ii(o8/(cm*io),2).." g"if ie()==0 or l then local oe=iL(aw+10)local of=iM(ax+20)local og=iL(aw+10+av/1.25)local n6=25;ju[#ju+1]="<g class='txtstart size14 bright'>"ju[#ju+1]=gK(oe,of,dq("BrkTime: %s",im(o7)))ju[#ju+1]=gK(og,of,dq("Trip: %.2f km",c6))ju[#ju+1]=gK(oe,of+n6,dq("Lifetime: %.2f kSU",bj/200000))ju[#ju+1]=gK(og,of+n6,dq("BrkDist: %s",il(o6)))ju[#ju+1]=gK(oe,of+n6*2,"Trip Time: "..im(c7))ju[#ju+1]=gK(og,of+n6*2,"Total Time: "..im(bk))ju[#ju+1]=gK(oe,of+n6*3,dq("Mass: %s",o5))ju[#ju+1]=gK(og,of+n6*3,dq("Max Brake: %s",nZ))ju[#ju+1]=gK(oe,of+n6*4,dq("Max Thrust: %s",o8))if gD>0.1 then ju[#ju+1]=gK(og,of+n6*4,dq("Max Thrust Mass: %s",o3))ju[#ju+1]=gK(oe,of+n6*5,dq("Req Thrust: %s",o4))else ju[#ju+1]=gK(og,of+n6*4,"Max Mass: n/a")ju[#ju+1]=gK(oe,of+n6*5,"Req Thrust: n/a")end;ju[#ju+1]=gK(og,of+n6*5,cC.FuelUsed("atmofueltank"))ju[#ju+1]=gK(oe,of+n6*6,cC.FuelUsed("spacefueltank"))ju[#ju+1]=gK(og,of+n6*6,cC.FuelUsed("rocketfueltank"))end;ju[#ju+1]="</g></g>"return ju end;function nK.DrawWarnings(ju)return kI(ju)end;function nK.DisplayOrbitScreen(ju)return lG(ju)end;function nK.DisplayMessage(ju,l3)if l3~="empty"then local hl=310;for oh in string.gmatch(l3,"([^\n]+)")do hl=hl+35;ju[#ju+1]=gK("50%",hl,oh,"msg")end end;if cb~=0 then c.setTimer("msgTick",cb)cb=0 end end;function nK.DrawDeadZone(ju)ju[#ju+1]=dq([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function nK.UpdatePipe()if ci then iy=""return end;mW()end;function nK.DrawSettings(ju)local hk=iL(640)local hl=iM(200)ju[#ju+1]=[[<g class="pbright txtvspd txtstart">]]local hO=0;for dQ,dC in pairs(ix)do hO=hO+1;ju[#ju+1]=gK(hk,hl,dQ..": "..dC.get())hl=hl+20;if hO%12==0 then hk=hk+iL(350)hl=iM(200)end end;ju[#ju+1]=gK(iL(640),iM(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")ju[#ju+1]="</g>"return ju end;local i3=iL(1770)local i4=iM(350)local i2=iM(15)local i1=iL(1370)local i7,oi;function nK.DrawRadarInfo()i6=cF.GetRadarHud(i1,i2,i3,i4)end;function nK.DrawTanks()if aq~=0 and ar~=0 then iQ=gK(aq,ar,"","txtstart pdim txtfuel")j7=ar;j8(aq,"Atmospheric ","ATMO",cu,j4,j5)j8(aq,"Space Fuel T","SPACE",cv,j2,j3)j8(aq,"Rocket Fuel ","ROCKET",cw,j0,j1)end end;function nK.DrawShield()local oj=ib.getState()==1 and"Shield Active"or"Shield Disabled"local ok=b.getPvPTimer()local ol=ib.getResistances()local om="A: "..10+ol[1]*100 .."% / E: "..10+ol[2]*100 .."% / K:"..10+ol[3]*100 .."% / T: "..10+ol[4]*100 .."%"local hk,hl=as-60,at+30;local on=bF(0.5+ib.getShieldHitpoints()*100/ib.getMaxShieldHitpoints())local jm=bF(on*2.55)local jn=dq("rgb(%d,%d,%d)",255-jm,jm,0)local jo=""iR=gK(hk,hl,"","txtmid pdim txtfuel")if on<10 and oj~="Shield Disabled"then jo="red "end;ok=ok>0 and"   PvPTime: "..im(ok)or""iR=iR..dq([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jn,on*2,hk,hl,hk+2,hl+10,on,ok)iR=iR..gK(hk,hl-5,oj,jo.."txtstart pbright txtbig")iR=iR..gK(hk,hl+30,om,jo.."txtstart pbright txtsmall")end;function nK.hudtick()if not iK then return end;local function oo(ju)local jq=bF(dr(cc/(cs/4)*255,0,255))ju[#ju+1]=dq("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bF(bI+0.5)+jq,bF(bK+0.5)-jq,bF(bJ+0.5)-jq)end;local function op()for dV,dC in pairs(ip)do if dC.hovered then if not dC.drawCondition or dC.drawCondition(dC)then dC.toggleFunction(dC)end;dC.hovered=false end end;for dV,dC in pairs(is)do if dC.hovered then bC=dC.label;dC.hovered=false end end end;local function oq()local function os(ot,ou,hk,hl,n5,n6)if ot>=hk and ot<=hk+n5 and ou>=hl and ou<=hl+n6 then return true else return false end end;local hk=c9+cs/2;local hl=ca+ct/2;for dV,dC in pairs(ip)do dC.hovered=os(hk,hl,dC.x,dC.y,dC.width,dC.height)end;for dV,dC in pairs(is)do dC.hovered=os(hk,hl,dC.x,dC.y,dC.width,dC.height)end;if dg then local mL=false;for dV,eJ in ipairs(nG)do if eJ.hovered then mL=true;break end end;if nD.hovered then mL=true end;dg=mL else dg=nD.hovered;if not dg then dh=bh end end end;local function ov(ju)if not bC or bC==""then bC="HELP"end;if x then for dQ,dC in pairs(is)do local jo="dim brightstroke"local ow=0.2;if bC==dQ then jo="pbright dimstroke"ow=0.6 end;local ox=""if dC.hovered then ow=0.8;ox=";stroke:white"end;ju[#ju+1]=dq([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dC.width,dC.height,dC.x,dC.y,jo,ow,ox)ju[#ju+1]=gK(dC.x+dC.width/2,dC.y+dC.height/2+5,dC.label,"txt txtmid pdim")end end end;local function oy(ju)local function oz(ju,oA,hover,hk,hl,fp,oB,oC,oD,oE,oF,nH)if type(oE)=="function"then oE=oE(nH)end;if type(oF)=="function"then oF=oF(nH)end;ju[#ju+1]=dq("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fp,oB)if oA then ju[#ju+1]=dq("%s'",oC)else ju[#ju+1]=oD end;if hover then ju[#ju+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else ju[#ju+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ii(ac*0.5,0),ii(ad*0.5,0),ii(ae*0.5,0))end;ju[#ju+1]=" rx='5'></rect>"ju[#ju+1]=dq("<text x='%f' y='%f' font-size='24' fill='",hk+fp/2,hl+oB/2+5)if oA then ju[#ju+1]="black"else ju[#ju+1]="white"end;ju[#ju+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oA then ju[#ju+1]=dq("%s</text>",oE)else ju[#ju+1]=dq("%s</text>",oF)end end;local oG=dq("rgb(%d,%d,%d)'",ii(ac*0.1,0),ii(ad*0.1,0),ii(ae*0.1,0))local oH=dq("rgb(%d,%d,%d)",ii(ac*0.8,0),ii(ad*0.8,0),ii(ae*0.8,0))local oI=oz;for dV,dC in pairs(ip)do local na=dC.disableName;local n9=dC.enableName;if type(na)=="function"then na=na(dC)end;if type(n9)=="function"then n9=n9(dC)end;if not dC.drawCondition or dC.drawCondition(dC)then oI(ju,dC.toggleVar(dC),dC.hovered,dC.x,dC.y,dC.width,dC.height,oH,oG,na,n9,dC)end end end;local oJ=ii(cs/2,0)local oK=ii(ct/2,0)local ju={}cC.HUDPrologue(ju)if x then cC.UpdateHud(ju)else if B then cC.DrawVerticalSpeed(ju,ck)end;cC.DrawWarnings(ju)end;if iw and ix~="none"then cC.DrawSettings(ju)end;if radar_1 then cC.DrawRadarInfo()end;cC.HUDEpilogue(ju)ju[#ju+1]=dq([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cs,ct)if c1~="empty"then cC.DisplayMessage(ju,c1)end;if ie()==0 and g=="virtual joystick"then if w then cC.DrawDeadZone(ju)end end;ov(ju)if ih()==0 then if ie()==1 and c0 then if not oL then oq()oy(ju)end;if not cH and not cI then local oM=table.concat(ju,"")ju={}ju[#ju+1]=dq("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cs,ct)ju[#ju+1]=oM;ju[#ju+1]="</body>"cH=true;ju[#ju+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oN=table.concat(ju,"")a.setScreen(oN)elseif cI then local oM=table.concat(ju,"")ju={}ju[#ju+1]=dq("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cs,ct)ju[#ju+1]=oM;ju[#ju+1]="</body>"end;if not cH then ju[#ju+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oJ,oK,c9,ca)end else op()end else if not c0 and ie()==0 then op()if cc>au then if w then oo(ju)end end elseif c0 and(not oL or not i)then oq()oy(ju)end;ju[#ju+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oJ,oK,c9,ca)end;ju[#ju+1]=[[</svg></body>]]oN=table.concat(ju,"")end;function nK.TenthTick()local function oO()local oP=a.createData;local oQ=a.createWidget;oR=a.createWidgetPanel("Interplanetary Helper")oS=oQ(oR,"value")oT=oP('{"label": "Target Planet", "value": "N/A", "unit":""}')f_(oT,oS)oU=oQ(oR,"value")oV=oP('{"label": "distance", "value": "N/A", "unit":""}')f_(oV,oU)gr=oQ(oR,"value")gq=oP('{"label": "Travel Time", "value": "N/A", "unit":""}')f_(gq,gr)gp=oQ(oR,"value")go=oP('{"label": "Maximum Mass", "value": "N/A", "unit":""}')f_(go,gp)gt=oQ(oR,"value")gs=oP('{"label": "Target Altitude", "value": "N/A", "unit":""}')f_(gs,gt)gl=oQ(oR,"value")gk=oP('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gj=oQ(oR,"value")gi=oP('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gh=oQ(oR,"value")gg=oP('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gf=oQ(oR,"value")ge=oP('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gn=oQ(oR,"value")gm=oP('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ci then f_(gk,gl)f_(gi,gj)f_(gg,gh)f_(ge,gf)f_(gm,gn)end end;local function oW()gJ(oR)oR=nil end;local function oX()if not a_ then if ga==nil or ga.planetname~=iK.name then oY=(c5.center-d1):len()else oY=(ga.position-d1):len()end end;local fw=cZ;local oZ=c.getThrottle()/100;if u then oZ=bL end;local o_,p0=cz.computeDistanceAndTime(cZ,a0,cm,d:maxForceForward()*oZ,a2,0)local c3,c4;if not b0 then c3,c4=cE.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cE.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dV,p1;if not b0 and fw>0 then dV,p1=cE.GetAutopilotBrakeDistanceAndTime(fw)else dV,p1=cE.GetAutopilotTBBrakeDistanceAndTime(fw)end;local p2=0;local p3=0;if ba or not a_ and fw>5 then p3=cz.computeTravelTime(fw,0,oY)elseif c3+o_<oY then p2=oY-(c3+o_)p3=cz.computeTravelTime(8333.0556,0,p2)else local p4=(oY-c3)/o_;o_=oY-c3;p0=p0*p4 end;if ga~=nil and ga.planetname==iK.name and not a_ then return p3 elseif b9 then return p1 elseif ba then return p3+p1 else return p0+c4+p3 end end;cC.DrawTanks()if ib then cC.DrawShield()end;if bf~="None"then if oR==nil then oO()end;if bf~=nil then local p5=ga~=nil;local p6=0.5*bq/c5:getGravity(c5.center+vec3(0,0,1)*c5.radius):len()p6=p6>1000000 and ii(p6/1000000,2).." kTons"or ii(p6/1000,2).." Tons"fZ(oT,'{"label": "Target", "value": "'..bf..'", "unit":""}')lg=oX()if p5 and not a_ then cc=(d1-ga.position):len()else cc=(bg-d1):len()end;if not b0 then c3,c4=cE.GetAutopilotBrakeDistanceAndTime(cZ)iA,iB=cE.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cE.GetAutopilotTBBrakeDistanceAndTime(cZ)iA,iB=cE.GetAutopilotTBBrakeDistanceAndTime(a0)end;local l3=il(cc)fZ(oV,'{"label": "distance", "value": "'..l3 ..'"}')fZ(gq,'{"label": "Travel Time", "value": "'..im(lg)..'", "unit":""}')l3=il(c3)fZ(gk,'{"label": "Cur Brake distance", "value": "'..l3 ..'"}')fZ(gi,'{"label": "Cur Brake Time", "value": "'..im(c4)..'", "unit":""}')l3=il(iA)fZ(gg,'{"label": "Max Brake distance", "value": "'..l3 ..'"}')fZ(ge,'{"label": "Max Brake Time", "value": "'..im(iB)..'", "unit":""}')fZ(go,'{"label": "Max Brake Mass", "value": "'..dq("%s",p6)..'", "unit":""}')l3=il(gu)fZ(gs,'{"label": "Target Orbit", "value": "'..l3 ..'"}')if cj>0 and not p7 then a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)a.removeDataFromWidget(gi,gj)a.removeDataFromWidget(gk,gl)a.removeDataFromWidget(gm,gn)p7=true;if not d5 and u and(b1 or b4 or cg)then cE.cmdThrottle(1)aX=false;bP=false end end;if cj==0 and p7 then if fZ(ge,gf)==1 then f_(ge,gf)end;if fZ(gg,gh)==1 then f_(gg,gh)end;if fZ(gi,gj)==1 then f_(gi,gj)end;if fZ(gk,gl)==1 then f_(gk,gl)end;if fZ(gm,gn)==1 then f_(gm,gn)end;p7=false end end else oW()end;if warpdrive~=nil then if ic(warpdrive.getData()).destination~="Unknown"and ic(warpdrive.getData()).distance>400000 then warpdrive.show()p8=true else warpdrive.hide()p8=false end end end;function nK.OneSecondTick(ju)local function p9()local ji=bE()local kF=cZ;local pa=ji-cl;if kF>1.38889 then kF=kF/1000;local pb=kF*(ji-cl)bj=bj+pb;c6=c6+pb end;c7=c7+pa;bk=bk+pa;cl=ji end;p9()cC.UpdatePipe()cC.ExtraData(ju)end;function nK.AnimateTick()cI=true;cH=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nK.MsgTick()local ju={}cC.DisplayMessage(ju,"empty")c1="empty"c.stopTimer("msgTick")cb=3 end;function nK.ButtonSetup()nl()nq()ip=iq end;return nK end;local function pc(d,b,c,a,e,vBooster,hover,pd,antigrav,warpdrive,dbHud_1,f4,bF,bG,ie,e_,bE,dr,ig,fZ,ih,dt,ii,g0,ij,du,il,im,pe,ic,dq,f_)local pf={}local function pg(fw)local ph=bb;if not a_ then ph=0 end;if not ci then return cz.computeDistanceAndTime(fw,ph,cm,0,0,bo-bd*cm)else if bq and bq>0 then return cz.computeDistanceAndTime(fw,ph,cm,0,0,bq-bd*cm)else return 0,0 end end end;local function pi(fw)local ph=bb;if not a_ then ph=0 end;return cz.computeDistanceAndTime(fw,ph,cm,d:maxForceForward(),a2,bo-bd*cm)end;local pj=false;local pk=0;local pl=0;local pm=0;local pn=bE()local po=0;local pp=0;local pq=0;local pr=0;local ps=false;local pt=false;local pu=false;local pv=nil;local pw=0;local px={}local iz=55;local py=nil;local pz=""function pf.GetAutopilotBrakeDistanceAndTime(fw)return pg(fw)end;function pf.GetAutopilotTBBrakeDistanceAndTime(fw)return pi(fw)end;local function pA(pB,pC,pD)pC=pC:project_on_plane(pB)pD=pD:project_on_plane(pB)return e_(pC:cross(pD):dot(pB),pC:dot(pD))end;local function pE()local function pF()local pG=-1;local pH=-1;if vBooster then pG=vBooster.getDistance()end;if hover then pH=hover.getDistance()end;if pG~=-1 and pH~=-1 then if pG<pH then return pG else return pH end elseif pG~=-1 then return pG elseif pH~=-1 then return pH else return-1 end end;local pI=pF()local pJ=-1;if pd then pJ=pd.getDistance()end;if pI~=-1 and pJ~=-1 then if pI<pJ then return pI else return pJ end elseif pI~=-1 then return pI else return pJ end end;local function pK(iK,eR,pL)local function pM(pN,e1)local eX=vec3(e1)if pN.id==0 then return setmetatable({latitude=eX.x,longitude=eX.y,altitude=eX.z,id=0,systemId=pN.systemId},e3)end;local eY=eX-pN.center;local cc=eY:len()local e9=cc-pN.radius;local e7=0;local e8=0;if not du(cc,0)then local eZ=e_(eY.y,eY.x)e8=eZ>=0 and eZ or 2*math.pi+eZ;e7=math.pi/2-math.acos(eY.z/cc)end;return setmetatable({latitude=math.deg(e7),longitude=math.deg(e8),altitude=e9,id=pN.id,systemId=pN.systemId},e3)end;local pO=pM(iK,eR)pO="::pos{"..pO.systemId..","..pO.id..","..pO.latitude..","..pO.longitude..","..pO.altitude.."}"if pL then return pO else a.setWaypoint(pO)return true end end;local pP=false;function pf.showWayPoint(iK,eR,pL)return pK(iK,eR,pL)end;function pf.APTick()local function pQ()if df and not b2 then local ey=df[1]local hT,hU=df[2],df[3]local pR=math.min(hT,hU or hT)local pS=pR/cZ;local pT=b3 and(cZ<42 or ch~=-1)local pU=b1 or bm or bp or a_;if pU and not pT and(c3*1.5>pR or pS<1)then aX=true;px={}cE.cmdThrottle(0)if b1 then cE.ToggleAltitudeHold()end;if bp then cE.ToggleLockPitch()end;c1="Autopilot Cancelled due to possible collision"if bm or a_ then cE.ToggleAutopilot()end;la=true;b2=true;cJ=true end;if pS<11 then de=ey.name.." COLLISION "..im(pS).." / "..il(pR,2)else de=ey.name.." collision "..im(pS)end;if pS<6 then g0("alarm","AL",2)end else de=false end end;local function pV(pW,pX,pY)local function pZ(pW,eA)pW=vec3(pW)eA=vec3(eA):normalize()local dL=pW*eA;return dL.x+dL.y+dL.z end;local p_=0.001;local q0=1;if not ci or not cK or ch~=-1 or cZ<iz then if pY==nil then pY=aO end;if pX==nil then pX=p_ end;pW=vec3(pW):normalize()local q1=vec3()-pW;local q2=-pZ(q1,b.getConstructWorldOrientationRight())*q0;local q3=-pZ(q1,b.getConstructWorldOrientationUp())*q0;if pl==0 then pl=q2/2 end;if pm==0 then pm=q3/2 end;if f4(q2)<0.1 then bV=bV-q2*2 else bV=bV-(q2+(q2-pl)*pY)end;if f4(q3)<0.1 then bU=bU+q3*2 else bU=bU+q3+(q3-pm)*pY end;pl=q2;pm=q3;if f4(q2)<pX and f4(q3)<pX then return true end;return false elseif cK and ch==-1 then pW=cY;if pY==nil then pY=aO end;if pX==nil then pX=p_ end;pW=vec3(pW):normalize()local q1=cV-pW;local q2=-pZ(q1,b.getConstructWorldOrientationRight())*q0;local q3=-pZ(q1,b.getConstructWorldOrientationUp())*q0;if pl==0 then pl=q2/2 end;if pm==0 then pm=q3/2 end;if f4(q2)<0.1 then bV=bV-q2*5 else bV=bV-(q2+(q2-pl)*pY)end;if f4(q3)<0.1 then bU=bU+q3*5 else bU=bU+q3+(q3-pm)*pY end;pl=q2;pm=q3;if f4(q2)<pX and f4(q3)<pX then return true end;return false end end;ci=bG()>0;cj=bG()ck=b.getAltitude()ch=pE()bH=bE()pn=bH;if F then pQ()end;if antigrav then d3=antigrav.getState()==1 end;local q4=a.getMouseWheel()if q4>0 then cE.changeSpd()elseif q4<0 then cE.changeSpd(true)else cn=true end;local q5=1;local q6=1;local q7=bH-pn;local q8=-math.deg(pA(cU,cY,cV))local q9=math.deg(pA(cW,cY,cV))local gw=c_*-1;cK=ci and q8<-M or q8>M or q9<-N or q9>N;local qa=a.getMouseDeltaX()local qb=a.getMouseDeltaY()if o and not c0 then qb=-qb end;bV=0;bZ=0;bU=0;g3=cy[0]iK=g3:closestBody(b.getConstructWorldPos())qc=cB(iK)fA=qc:orbitalParameters(b.getConstructWorldPos(),cY)if ck==0 then ck=(d1-iK.center):len()-iK.radius end;dd=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;local gD=iK:getGravity(b.getConstructWorldPos()):len()*cm;cL=0;cA=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ih()==0 then if ie()==1 and c0 then if not cH then c9=dr(c9+qa,-cs/2,cs/2)ca=dr(ca+qb,-ct/2,ct/2)end else c9=0;ca=0 end else c9=dr(c9+qa,-cs/2,cs/2)ca=dr(ca+qb,-ct/2,ct/2)cc=dt(c9*c9+ca*ca)if not c0 and ie()==0 then local kr,ks=1,1;if bC=="SCOPE"then kr,ks=dl/90,dl/90 end;if g=="virtual joystick"then if c9>0 and c9>au then bV=bV-(c9-au)*aC*kr elseif c9<0 and c9<au*-1 then bV=bV-(c9+au)*aC*kr else bV=0 end;if ca>0 and ca>au then bU=bU-(ca-au)*aD*ks elseif ca<0 and ca<au*-1 then bU=bU-(ca+au)*aD*ks else bU=0 end else c9=0;ca=0;if g=="mouse"then bU=(-utils.smoothstep(qb,-100,100)+0.5)*2*q5;bV=(-utils.smoothstep(qa,-100,100)+0.5)*2*q6 end end end end;local qd=cZ>8334;if cZ>W/3.6 and not ci and not a_ and not qd then c1="Space Speed Engine Shutoff reached"cE.cmdThrottle(0)end;if not qd and qe then if not aX then cE.BrakeToggle()end;if a_ then cE.ToggleAutopilot()end end;qe=qd;if ci and cj>0.09 then if cZ>cM/3.6 and not u and not pj then aX=true;pj=true elseif not u and pj then if cZ<cM/3.6 then aX=false;pj=false end end end;if aX then bY=1 else bY=0 end;if aZ then if ce then aX=false;local qf=false;if ga and ce==true then qf=pV(ga.position-d1,0.1)else qf=pV(vec3(cY),0.01)end;cJ=true;if qf then cE.cmdCruise(bF(cM))if(f4(d7)<2 or f4(d6)>85)and cZ>=cM/3.6-1 then aX=false;aZ=false;if ce~=2 then bR=true end;if ce==true then cg=true end;ce=false;a_=false;cE.BeginReentry()end elseif ci and u then cE.cmdThrottle(1)end elseif cZ>iz then pV(vec3(cY),0.01)end end;if aY then if ci then aY=false elseif cZ>iz then pV(-vec3(cY))end end;if not aZ and ce and not bv then if cj==0 then if ce~=2 then bR=true end;cE.BeginReentry()ce=false;cg=true else ce=false;cE.ToggleAutopilot()end end;if cg and ga and(ck<b6+250 and ck>b6-250)and cZ*3.6>cM-250 and f4(d0)<25 and cj>=0.1 and(ga.position-d1):len()>2000+ck then cE.ToggleAutopilot()cg=false end;if b5 then cJ=true;local qg=b6;if d0<-30 then c1="Unable to achieve lift. Safety Landing."c8=0;cJ=p;b5=false;b2=true elseif not q and d3 or b6<iK.spaceEngineMinAltitude then if d3 then qg=antigrav.getBaseAltitude()end;if ck<qg-100 then cN=0;c8=15;aX=false elseif d0>0 then aX=true;c8=0 elseif d0<-30 then aX=true;c8=15 elseif ck>=qg then if d3 then if a_ or bm then cE.ToggleVerticalTakeoff()else aX=true;b5=false end;c1="Takeoff complete. Singularity engaged"g0("aggLk","AG")else aX=false;c1="VTO complete. Engaging Horizontal Flight"g0("vtoc","VT")cE.ToggleVerticalTakeoff()end;c8=0 end else if cj>0.08 then cN=0;aX=false;c8=20 elseif cj<0.08 and cj>0 then aX=false;if cS then cN=0;c8=20 else c8=0;cN=36;cE.cmdCruise(3500)end else cJ=p;bv=true;cR=false;qh=false;ps=false;pq=nil;pr=nil;if pv==nil then pv=iK end;cQ=qg;pu=true;b5=false end end;if cN~=nil then if qi==nil then qi=pid.new(2*0.01,0,2*0.1)end;local qj=dr(cN-d6,-N*0.80,N*0.80)qi:inject(qj)local qk=dr(qi:get(),-1,1)bU=qk end end;if bv then local q1;local ql=false;local qm=il(cQ)if pv==nil then pv=iK;if bm then pv=c5 end end;if not pu then cQ=bF(pv.radius+pv.surfaceMaxAltitude+U)if pv.hasAtmosphere then cQ=bF(pv.radius+pv.noAtmosphericDensityAltitude+U)end;pu=true end;if cP.VectorToTarget and ga then q1=ga.position-d1 end;local qn,qo=cB(pv):escapeAndOrbitalSpeed((d1-pv.center):len()-pv.radius)local qp=d7;if not ps then local qq=false;local qr=false;cE.cmdThrottle(0)pr=0;cO="Aligning to orbital path - OrbitHeight: "..qm;if cP.VectorToTarget then pV(q1:normalize():project_on_plane(c_))ql=cV:dot(q1:project_on_plane(cU):normalize())>0.95 else pV(cY)ql=q8<0.5;if cZ<150 then ql=true end end;bU=0;pq=0;if d6<=pq+1 and d6>=pq-1 then qq=true else qq=false end;if qp<=pr+1 and qp>=pr-1 then qr=true else qr=false end;if qq and qr and ql then pq=nil;pr=nil;ps=true end else if cP.VectorToTarget then pV(q1:normalize():project_on_plane(c_))elseif cZ>150 then pV(cY)end;bU=0;if cP.VectorToTarget and ga then local c3,dV=cz.computeDistanceAndTime(cZ,cM/3.6,cm,0,0,bo)if cR and q1:len()>15000+c3+ck then cO="Orbiting to Target"if ck-100<=pv.noAtmosphericDensityAltitude or lg>fA.timeToPeriapsis and fA.periapsis.altitude<pv.noAtmosphericDensityAltitude then cR=false end elseif cR or q1:len()<15000+c3+ck then c1="Orbit complete, proceeding with reentry"g0("orCom","OB")bg=ga.position;bR=true;cg=true;cP.VectorToTarget,cP.AutopilotAlign=false,false;cE.ToggleIntoOrbit()cE.BeginReentry()return end end;if fA.periapsis~=nil and fA.apoapsis~=nil and fA.eccentricity<1 and ck>cQ*0.9 and ck<cQ*1.4 then if fA.apoapsis~=nil then if fA.periapsis.altitude>=cQ*0.99 and fA.apoapsis.altitude>=cQ*0.99 and fA.periapsis.altitude<fA.apoapsis.altitude and fA.periapsis.altitude*1.05>=fA.apoapsis.altitude or cR then if cR then aX=false;cE.cmdThrottle(0)pq=0;if not cP.VectorToTarget then c1="Orbit complete"g0("orCom","OB")cE.ToggleIntoOrbit()end else pw=pw+1;if pw>=2 then cR=true end end else cO="Adjusting Orbit - OrbitHeight: "..qm;pt=true;cE.cmdCruise(qo*3.6+1)local qs=cQ-ck;if qt==nil then qt=pid.new(0.1,0,1*0.1)end;qt:inject(qs-d0*dr(utils.smoothstep(2000-qs,-2000,2000)^6*10,1,10))pq=dr(qt:get(),-60,60)end end else local qu=2.75;local qv=f4(ii(qn*qu))local ob=qv%50;if ob>0 then qv=qv-ob+50 end;aX=false;if ck<cQ*0.8 then cO="Escaping planet gravity - OrbitHeight: "..qm;pq=utils.map(d0,200,0,-15,80)elseif ck>=cQ*0.8 and ck<cQ*1.15 then cO="Approaching orbital corridor - OrbitHeight: "..qm;qv=qv*0.75;pq=utils.map(d0,100,-100,-15,65)elseif ck>=cQ*1.15 and ck<cQ*1.5 then cO="Approaching orbital corridor - OrbitHeight: "..qm;qv=qv*0.75;if d0<0 or pt then pq=utils.map(ck,cQ*1.5,cQ*1.01,-30,0)else pq=utils.map(ck,cQ*0.99,cQ*1.5,0,30)end elseif ck>cQ*1.5 then cO="Reentering orbital corridor - OrbitHeight: "..qm;pq=-65;local qw=utils.map(d0,-150,-400,1,0.55)qv=qv*qw end;cE.cmdCruise(bF(qv))end end;if pq~=nil then if qx==nil then qx=pid.new(1*0.01,0,5*0.1)end;local qy=pq-d6;qx:inject(qy)local qz=dr(qx:get(),-0.5,0.5)bU=qz end end;if a_ and cj==0 and not ce then local function qA(i7,fA)a.print(i7)aX=false;b9=false;a_=false;qB=false;bc="Aligning"cE.cmdThrottle(0)bQ=false;c1=i7;g0("apCom","AP")if fA or ce then if fA and gu~=nil and not ce then if not ck or ck==0 then return end;cQ=ck;pu=true end;cE.ToggleIntoOrbit()end end;local qC,qD=bg,false;if ga and ga.planetname~="Space"then b8=true;if not qB then local qE=(ga.position-c5.center):normalize()local qF=qE:project_on_plane((c5.center-d1):normalize()):normalize()local qG=c5.center+qF*(c5.radius+gu)local qH=ga.position+(ga.position-c5.center):normalize()*(gu-c5:getAltitude(ga.position))if(d1-qG):len()<(d1-qH):len()then qC=qG else qC=qH;bb=0 end;bg=qC;cE.showWayPoint(c5,bg)qD=true;qB=true end;bd=0 elseif ga and ga.planetname=="Space"then if not qB then bd=0;qD=true;b8=true;qB=true;qC=ga.position+(d1-ga.position):normalize()*S;bg=qC end elseif ga==nil then bd=0;if not qB then local qE=(d1+cY*100000-c5.center):normalize()local qF=qE:project_on_plane((c5.center-d1):normalize()):normalize()if qF:len()<1 then qE=(d1+cV*100000-c5.center):normalize()qF=qE:project_on_plane((c5.center-d1):normalize()):normalize()end;qC=c5.center+qF*(c5.radius+gu)bg=qC;qB=true;qD=true;b8=true;cE.showWayPoint(c5,bg)end end;oY=(vec3(qC)-d1):len()local le,eP,eQ=cy:getPlanetarySystem(0):castIntersections(d1,cY:normalize(),function(ey)if ey.noAtmosphericDensityAltitude>0 then return ey.radius+ey.noAtmosphericDensityAltitude else return ey.radius+ey.surfaceMaxAltitude*1.5 end end)local lf=eP;if eQ~=nil and eP~=nil then lf=math.min(eQ,eP)end;if lf~=nil and lf<oY and le.name==c5.name then oY=lf end;local qf=true;local qI=(c5.center-(d1+vec3(cY):normalize()*oY)):len()-c5.radius;local l3=il(qI)fZ(gm,'{"label": "Projected Altitude", "value": "'..l3 ..'"}')local c3,c4;if not b0 then c3,c4=pg(cZ)else c3,c4=pi(cZ)end;if cZ>50 and b7 then local q1=vec3(qC)-d1;local qJ=dr(math.deg(pA(cU,cY:normalize(),q1:normalize()))*cZ/500,-90,90)local qK=dr(math.deg(pA(cW,cY:normalize(),q1:normalize()))*cZ/500,-90,90)if f4(qJ)<20 and f4(qK)<20 then qJ=qJ*2;qK=qK*2 end;if f4(qJ)<2 and f4(qK)<2 then qJ=qJ*2;qK=qK*2 end;local q8=-math.deg(pA(cU,cV,cY:normalize()))local q9=-math.deg(pA(cW,cV,cY:normalize()))if qL==nil then qL=pid.new(2*0.01,0,2*0.1)end;qL:inject(qK-q9)local qM=dr(qL:get(),-1,1)bU=bU+qM;if qN==nil then qN=pid.new(2*0.01,0,2*0.1)end;qN:inject(qJ-q8)local qO=dr(qN:get(),-1,1)bV=bV+qO;qD=true;if f4(qJ)>2 or f4(qK)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"g0("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end end elseif b7 and cZ<=50 then pV((qC-d1):normalize())end;if qI<gu*1.5 then if ga and ga.planetname=="Space"then bb=0 elseif ga==nil then dV,bb=cB(c5):escapeAndOrbitalSpeed(qI)end end;if a_ and not b7 and not ba and not b9 then local le,lf=cE.checkLOS((bg-d1):normalize())if c5.name~=iK.name then if le~=nil and c5.name~=le.name and lf<oY then c1="Collision with "..le.name.." in "..il(lf).."\nClear LOS to continue."cb=5;pP=true else pP=false;c1=""end end end;if not pP then if not ba and not b9 and not qD then qf=pV((qC-d1):normalize())elseif b0 and(b9 or ba)then qf=pV(-vec3(cY):normalize())end end;if b7 then if not bQ then aX=false;cE.cmdThrottle(a1)bL=ii(a1,2)bQ=true end;local oZ=c.getThrottle()if u then oZ=bL end;local qP=99999;local o9=-vec3(b.getWorldAcceleration()):dot(cY:normalize())local qQ=dr(cY:dot((qC-d1):normalize()),0,cZ)if qQ>0 or o9>0 then qP=cz.computeTravelTime(qQ,o9,oY-c3)end;if cX:len()>=a0 or oZ==0 and bQ or a2/4>qP then b7=false;if bc~="Cruising"then g0("apCru","AP")bc="Cruising"end;ba=true;cE.cmdThrottle(0)end;local qR=oY;if qR<=c3 or H and da<=c3+10000 and d9 then if H and da<=c3+10000 and d9 then if da<pk and da>2000 then cE.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pk=da else pk=da;return end end;b7=false;if bc~="Braking"then g0("apBrk","AP")bc="Braking"end;b9=true;cE.cmdThrottle(0)bQ=false end elseif b9 then if bc~="Orbiting to Target"then aX=true;bY=1 end;if b0 then cE.cmdThrottle(1,true)end;local dV,qo=cB(c5):escapeAndOrbitalSpeed((d1-iK.center):len()-iK.radius)local q1;if ga then q1=ga.position-d1 end;if ga and ga.planetname=="Space"and cZ<50 then if#px>0 then aX=false;cE.ToggleAutopilot()cE.ToggleAutopilot()return end;qA("Autopilot complete, arrived at space location")aX=true;bY=1 elseif ga and ga.planetname~="Space"and cZ<=qo and(fA.apoapsis==nil or fA.periapsis==nil or fA.apoapsis.altitude<=0 or fA.periapsis.altitude<=0)then qA("Autopilot complete, commencing reentry")bg=ga.position;ce=true;cE.showWayPoint(c5,bg)elseif(ga and ga.planetname~="Space"or ga==nil)and fA.periapsis~=nil and fA.periapsis.altitude>0 and fA.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then g0("apCir","AP")bc="Circularizing"end;if cZ<=qo then if ga then if cY:normalize():dot(q1:normalize())>0.4 then if bc~="Orbiting to Target"then g0("apOrb","OB")bc="Orbiting to Target"end;if not qS then aX=false;cE.showWayPoint(c5,ga.position)qS=true end else qA("Autopilot complete, proceeding with reentry")bg=ga.position;ce=true;cE.showWayPoint(c5,ga.position)qS=false end else qA("Autopilot completed, setting orbit",true)bY=0 end end elseif bc=="Circularizing"then qA("Autopilot complete, fixing Orbit",true)end elseif ba then local qR=oY;if qR<=c3 or H and da<=c3+10000 and d9 then if H and da<=c3+10000 and d9 then if da<pk and da>2000 then cE.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pk=da else pk=da;return end end;b7=false;if bc~="Braking"then g0("apBrk","AP")bc="Braking"end;b9=true end;local oZ=c.getThrottle()if u then oZ=bL end;if oZ>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end;ba=false end else if qf then if not b8 and ga==nil or not b8 and ga and ga.planetname~="Space"then if not ce then bg=vec3(c5.center)+(gu+c5.radius)*cW;qT=cU;qU=cW end;b8=true elseif qf and not pP then b7=true;if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end;if not bQ then cE.cmdThrottle(a1,true)bL=ii(a1,2)bQ=true;aX=false end end end end elseif a_ and(ga~=nil and ga.planetname~="Space"and cj>0)then c1="Autopilot complete, starting reentry"g0("apCom","AP")bg=ga.position;aX=false;b9=false;a_=false;qB=false;bc="Aligning"bY=0;cE.cmdThrottle(0)bQ=false;aZ=true;ce=true;cE.showWayPoint(c5,ga.position)end;if b_ then cJ=true;local qK=0;local fC=d1+vec3(c.getMasterPlayerRelativePosition())local qV=fC-d1;local qW=vec3(qV):project_on(cV):len()local qX=vec3(qV):project_on(cW):len()local cc=dt(qW*qW+qX*qX)pV(qV:normalize())local mm=40;local qY=cc<mm;local qZ=100;local q_=dr((cc-mm)/2,10,qZ)bU=0;local qf=f4(bV)<0.1;if qf and cZ<q_ and not qY then aX=false;qK=-20 else aX=true;qK=0 end;local r0=0;if f4(qK-d6)>r0 then if r1==nil then r1=pid.new(2*0.01,0,2*0.1)end;r1:inject(qK-d6)local qM=r1:get()bU=qM end end;if b1 or b2 or b4 or bm or bp~=nil then local r2=bq;if r2 then r2=r2*dr(cZ/100,0.1,1)*cj else r2=bo end;if cj<0.01 then r2=bo end;local r3=cV:project_on_plane(c_):normalize():dot(cY)local r4=vec3(b.getWorldAirFrictionAcceleration())local r5=r4:len()*cm;if r3>100 then c3,c4=cz.computeDistanceAndTime(r3,100,cm,0,0,r2)local r6,r7=cz.computeDistanceAndTime(100,0,cm,0,0,r2*0.55)c3=c3+r6 else c3,c4=cz.computeDistanceAndTime(r3,0,cm,0,0,r2*0.55)end;local qs=b6-ck-d0;local r8=200+cZ;if b4 or ce then r9=2000+cZ end;local ra=1;if b3 then ra=dr(cZ/100,0.1,1)end;local qK=(utils.smoothstep(qs,-r8,r8)-0.5)*2*P*ra;if not b4 and not ce and not bm and cV:dot(cY:normalize())<0.99 then qK=(utils.smoothstep(qs,-r8*dr(20-19*cj*10,1,20),r8*dr(20-19*cj*10,1,20))-0.5)*2*P*dr(2-cj*10,1,2)*ra end;if not b1 then qK=0 end;if bp~=nil then if dd and not bv then qK=bp else bp=nil end end;cJ=true;local rb=bU;if b4 then local rc=bF(cM)local rd,re=cz.computeDistanceAndTime(cZ,rc/3.6,cm,0,0,bo-iK.gravity*9.8*cm)rd=rd==-1 and 5000 or rd;local rf=ck-(iK.noAtmosphericDensityAltitude+rd)local rg=ck>iK.noAtmosphericDensityAltitude+rd*1.35;if rg then qK=Q;if cZ<=rc/3.6 and cZ>rc/3.6-10 and f4(cY:normalize():dot(cV))>0.9 and not d5 then bP=false;cE.cmdThrottle(1)end elseif(d5 or ig:getTargetSpeed(axisCommandId.longitudinal)~=rc)and not rg and not ci then cE.cmdCruise(rc,true)end;if d5 then if cZ>rc/3.6 and not rg then aX=true else aX=false end else aX=false end;if d0>0 then aX=true end;if not bR then qK=-80;if ck<iK.surfaceMaxAltitude+(iK.atmosphereThickness-iK.surfaceMaxAltitude)*0.25 then c1="PARACHUTE DEPLOYED at "..ii(ck,0)b4=false;b2=true;la=true;cE.cmdThrottle(0)qK=0;cJ=p end elseif iK.noAtmosphericDensityAltitude>0 and rg then cJ=true elseif not rg then if not ci and(d5 or ig:getTargetSpeed(axisCommandId.longitudinal)~=rc)then cE.cmdCruise(rc)end;if cZ<rc/3.6+1 then aX=false;bR=false;b4=false;cJ=true end end end;if cZ>iz and not cf and not bm and not b2 and v then pV(vec3(cY))end;if db or(bm or cf)and bh>0 and cj>0.01 then local q1;if db then if type(db)=="table"then q1=db elseif db<3 and db>0 then q1=-c_:cross(cY)*5000 elseif db>=3 then q1=c_:cross(cY)*5000 elseif db<0 then q1=cY*25000 end elseif ga~=nil then q1=ga.position-d1 else q1=c5.center-d1 end;local qJ=math.deg(pA(c_:normalize(),cY,q1))*2;local mp=math.rad(f4(d7))if cZ>aH and cj>0.01 then local rh=1000+cZ;local ri=(utils.smoothstep(qs-d0*10,-rh,rh)-0.5)*2*P;local rj=dr(90-ri,0,180)cL=dr(qJ*2,-rj,rj)local rk=qJ;qJ=dr(dr(qJ,-M*0.80,M*0.80)*math.cos(mp)+4*(d6-qK)*math.sin(math.rad(d7)),-M*0.80,M*0.80)local rl=1;if cL~=0 then rl=f4(mp/cL)end;rl=(90-dr(f4(cL-d7),0,90))/90;local rm=qK;if f4(d7)>90 then rm=-rm end;qK=rl*dr(dr(rm*math.cos(mp),-N*0.8,N*0.8)+f4(dr(f4(rk)*math.sin(mp),-N*0.80,N*0.80)),-N*0.80,N*0.80)else cL=0;qJ=dr(qJ,-M*0.80,M*0.80)end;local rn=q8-qJ;if db and f4(rn)<=0.0001 and(type(db)=="table"or type(db)~="table"and db<0 and f4(d7)<1)then if db==-2 then cE.ToggleAltitudeHold()end;db=nil;g0("180Off","BR")return end;if not cK and cZ>aH and cj>0.01 then if ro==nil then ro=pid.new(2*0.01,0,2*0.1)end;ro:inject(rn)local qO=dr(ro:get(),-1,1)bV=bV+qO elseif ci and ch>-1 or cZ<aH then pV(q1)elseif cK and cj>0.01 then if(q8<-M or q8>M)and cj>0.01 then pV(cY)end;if(q9<-N or q9>N)and cj>0.01 then qK=dr(d6-q9,d6-N*0.80,d6+N*0.80)end end;if ga~=nil and not cf then local qg=iK:getAltitude(ga.position)local rf=q1:project_on_plane(c_):len()la=true;if not cf and not b4 and rf<=c3 and(cY:project_on_plane(c_):normalize():dot(q1:project_on_plane(c_):normalize())>0.99 or li=="Finalizing Approach")then li="Finalizing Approach"if#px>0 then cE.ToggleAutopilot()cE.ToggleAutopilot()return end;cE.cmdThrottle(0)if b1 then cE.ToggleAltitudeHold()bm=true end;aX=true elseif not b3 then aX=false end;if li=="Finalizing Approach"and(r3<0.1 or rf<0.1 or rp~=nil and rp<rf)then if not d3 then g0("bklOn","BL")b2=true end;bm=false;li="Proceeding to Waypoint"de=false end;rp=rf end elseif bm and cj==0 and b6>iK.noAtmosphericDensityAltitude and not(cf or b4)then if ga~=nil and c5.name==iK.name then local q1=ga.position-d1;local qg=iK:getAltitude(ga.position)local rf=dt(q1:len()^2-(ck-qg)^2)local r2=bq;if r2 then c3,c4=cz.computeDistanceAndTime(cZ,0,cm,0,0,r2/2)la=true;if rf<=c3+cZ*q7/2 and cY:project_on_plane(c_):normalize():dot(q1:project_on_plane(c_):normalize())>0.99 then if iK.hasAtmosphere then aX=false;aZ=false;bR=true;ce=false;cg=true;a_=false;cE.BeginReentry()end end;rp=rf end end end;if cj==0 and(b1 and b6>iK.noAtmosphericDensityAltitude)and not(cf or bv or b4)then if not cR and not bv then cQ=b6;pu=true;if bm then cP.VectorToTarget=true end;cE.ToggleIntoOrbit()bm=false;ps=true end end;if cK and cj>0.01 and ch==-1 and cZ>aH and li~="Finalizing Approach"then pV(cY)qK=dr(d6-q9,d6-N*0.80,d6+N*0.80)end;bU=rb;local pJ=-1;if b2 then qK=0;local rq=false;local rr=30;if cA~=nil and cA>0 then local rs=dr(cj,0.4,2)local r2=bq*dr(cZ/100,0.1,1)*rs;local rt=cA*rs+r2-gD;local ru=r2/2-gD;local rv=cZ-dt(f4(ru/2)*20/(0.5*cm))*utils.sign(ru)if rv<0 then rv=0 end;local rw;if cZ>100 then local rx,dV=cz.computeDistanceAndTime(cZ,100,cm,0,0,r2)local ry,dV=cz.computeDistanceAndTime(100,0,cm,0,0,dt(r2))rw=rx+ry else rw=cz.computeDistanceAndTime(cZ,0,cm,0,0,dt(r2))end;if rw<20 then aX=false else local rz=0;if rv>100 then local rA,dV=cz.computeDistanceAndTime(rv,100,cm,0,0,rt)local rB,dV=cz.computeDistanceAndTime(100,0,cm,0,0,cA*rs+dt(r2)-gD)rz=rA+rB else rz,dV=cz.computeDistanceAndTime(rv,0,cm,0,0,cA*rs+dt(r2)-gD)end;rz=(rz+15+cZ*q7)*1.1;local rC=ga~=nil and iK:getAltitude(ga.position)>0 and ga.safe;if rC then local qg=iK:getAltitude(ga.position)local rD=ck-qg-100;local q1=ga.position-d1;local rE=dt(q1:len()^2-(ck-qg)^2)if rE>100 then rC=false elseif rD<=rz or rz==-1 then aX=true;rq=true else aX=false;rq=true end end;if not rC and t then if rz>=rr then aX=true else aX=false end;rq=true end end end;if not d5 then cE.cmdThrottle(0)end;ig:setTargetGroundAltitude(500)ig:activateGroundEngineAltitudeStabilization(500)bx=true;pJ=ch;if pJ>-1 then cJ=p;if cZ<1 or cY:normalize():dot(c_)<0 then b2=false;b1=false;bi=true;if bS then d.control.extendLandingGears()g0("grOut","LG",1)end;ig:setTargetGroundAltitude(Z)c8=0;aX=true else aX=true end elseif la and cY:normalize():dot(-gw)<0.999 then aX=true elseif d0<-O and not rq then aX=true elseif not rq then aX=false end end;if b3 or cf then local le,eQ,eP;if bg~=nil then le,eQ,eP=cy:getPlanetarySystem(0):castIntersections(d1,(bg-d1):normalize(),function(ey)return ey.radius+ey.noAtmosphericDensityAltitude end)end;if d3 then if ck>=b6-50 then b3=false;if not a_ and not bm then aX=true;cE.cmdThrottle(0)end else b6=antigrav.getBaseAltitude()end elseif f4(qK)<15 and ck/b6>0.75 then b3=false;if not cf then if d5 and not u then d.control.cancelCurrentControlMasterMode()end elseif cf and cZ<iz then a_=true;cf=false;b1=false;b3=false;cE.cmdThrottle(0)elseif cf then cE.cmdThrottle(0)aX=true end elseif cf and cj==0 and c5~=nil and(le==nil or le.name==c5.name)then a_=true;cf=false;b1=false;b3=false;if not d5 then cE.cmdThrottle(0)end;b7=true end end;local rF=ch>-1;local rG=d6;if(bm or cf or db)and not rF and cZ>aH and cj>0.01 then local mp=math.rad(f4(d7))rG=d6*f4(math.cos(mp))+q9*math.sin(mp)end;local rH=dr(qK-rG,-N*0.80,N*0.80)if cj<0.01 and bm then rH=dr(qK-rG,-85,P)elseif cj<0.01 then rH=dr(qK-rG,-P,P)end;if f4(d7)<5 or bm or db or b2 or rF or b1 then if r1==nil then r1=pid.new(5*0.01,0,5*0.1)end;r1:inject(rH)local qM=r1:get()bU=bU+qM end end;if antigrav~=nil and(antigrav and not q and ck<200000)then if br==nil or br<1000 then br=1000 end;if rI~=br then rI=br;antigrav.setBaseAltitude(rI)end end end;function pf.ToggleIntoOrbit()cR=false;pq=nil;pr=nil;pw=0;if cj==0 then if bv then g0("orOff","AP")bv=false;ps=false;pv=nil;cJ=p;if b1 then b1=false;b3=false end;cP.VectorToTarget=false;cP.AutopilotAlign=false;pu=false elseif dd then g0("orOn","AP")bv=true;cJ=true;if pv==nil then pv=iK end;if b1 then b1=false;b3=false end else c1="Unable to engage auto-orbit, not near a planet"end else bv=false;ps=false;pv=nil;cJ=p;if b1 then b1=false end;cP.VectorToTarget=false;cP.AutopilotAlign=false;pu=false end end;function pf.ToggleVerticalTakeoff()b1=false;if b5 then la=true;b4=false;b3=false;b2=true;cJ=true;c8=0;if ci and ch==-1 then b2=false;b1=true;c8=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cE.cmdCruise(bF(cM))end else cR=false;bi=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(Y)aX=true end;b5=not b5 end;function pf.checkLOS(pW)local le,eP,eQ=cy:getPlanetarySystem(0):castIntersections(d1,pW,function(ey)if ey.noAtmosphericDensityAltitude>0 then return ey.radius+ey.noAtmosphericDensityAltitude else return ey.radius+ey.surfaceMaxAltitude*1.5 end end)local lf=eP;if eQ~=nil and eP~=nil then lf=math.min(eQ,eP)end;if lf~=nil then return le,lf else return nil,nil end end;function pf.ToggleAutopilot()local function rJ(bt)de=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cE.ToggleAltitudeHold()end end;li="Proceeding to Waypoint"end;local rK=false;if bH-pp<1.5 and cj>0 then if not cT then c1="No space engines detected, Orbital Hop not supported"return end;if iK.hasAtmosphere then if cj>0 then b6=iK.noAtmosphericDensityAltitude+U;g0("orH","OH")end;pp=-1;if a_ or bm or bv then return end end else pp=bH end;qB=false;if(bh>0 or#px>0)and not a_ and not bm and not cf and not bv then if 0.5*d:maxForceForward()/b.g()<cm then c1="WARNING: Heavy Loads may affect autopilot performance."cb=5 end;if#px>0 and not cg then bh=px[1]cD.UpdateAutopilotTarget()table.remove(px,1)c1="Route Autopilot in Progress"local q1=ga.position-d1;local rf=q1:project_on_plane(c_):len()if rf>50000 and ga.planetname==iK.name then rK=true end end;cD.UpdateAutopilotTarget()cE.showWayPoint(c5,bg)if ga~=nil then bp=nil;bt=ga.planetname=="Space"if bt then g0("apSpc","AP")if cj~=0 then cf=true;cE.ToggleAltitudeHold()else a_=true end elseif iK.name==ga.planetname then la=true;if cj>0 then if not bm then g0("vtt","AP")rJ(bt)if rK then b6=iK.noAtmosphericDensityAltitude+U end end else g0("apOn","AP")if not(c5.name==iK.name and ck<gu*1.5)then cR=false;a_=true elseif not ci then if bv then cE.ToggleIntoOrbit()end;cQ=iK.noAtmosphericDensityAltitude+U;pu=true;cP.AutopilotAlign=true;cP.VectorToTarget=true;ps=false;if not bv then cE.ToggleIntoOrbit()end end end else g0("apP","AP")aY=false;aZ=false;if cj~=0 then cf=true;cE.ToggleAltitudeHold()else a_=true end end elseif cj==0 then if ga==nil and(c5.name==iK.name and dd)and not bv then qS=false;cR=false;ps=false;cE.ToggleIntoOrbit()else g0("apP","AP")a_=true;aY=false;aZ=false;b8=false;b_=false;b1=false;b2=false;b4=false;b3=false;bQ=false;bp=nil;qS=false end else g0("apP","AP")cf=true;cE.ToggleAltitudeHold()end else g0("apOff","AP")cE.ResetAutopilots(1)end end;function pf.routeWP(rL,rM,rN)if rN then if rN==1 then px={}px=ij(px,bA)if#px>0 then c1="Route Loaded"else c1="No Saved Route found on Databank"end;return px else bA={}bA=ij(bA,px)c1="Route Saved"pe()return end end;if rL then return px end;if rM then px={}c1="Current Route Cleared"else px[#px+1]=bh;c1="Added "..ga.name.." to route. "end;return px end;function pf.cmdThrottle(dR,rO)if ig:getAxisCommandType(0)~=axisCommandType.byThrottle and not rO then d.control.cancelCurrentControlMasterMode()end;ig:setThrottleCommand(axisCommandId.longitudinal,dR)bL=dr(ii(dR*100,0)/100,-1,1)d4=nil end;function pf.cmdCruise(dR,rO)if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rO then d.control.cancelCurrentControlMasterMode()end;ig:setTargetSpeedCommand(axisCommandId.longitudinal,dR)d4=dR end;function pf.ToggleLockPitch()if bp==nil then g0("lkPOn","LP")if not c0 then bp=d6 else bp=R end;b3=false;b1=false;b2=false else g0("lkPOff","LP")bp=nil end end;function pf.ToggleAltitudeHold()if bH-po<1.5 then if iK.hasAtmosphere then if cj>0 then b6=iK.spaceEngineMinAltitude-0.01*iK.noAtmosphericDensityAltitude;g0("11","EP")else if dd then b6=iK.noAtmosphericDensityAltitude+U;cQ=b6;pu=true;if not bv then cE.ToggleIntoOrbit()end;ps=true end end;po=-1;if b1 or bv or b5 then return end end else po=bH end;if dd and cj==0 then cQ=ck;pu=true;ps=true;cE.ToggleIntoOrbit()if bv then po=bH else po=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;b_=false;cJ=true;bp=nil;cR=false;if ch~=-1 and cZ<20 then g0("lfs","LS")b3=true;if po>-1 then b6=ck+X end;bi=false;d.control.retractLandingGears()aX=true;ig:setTargetGroundAltitude(Y)if aW and d2 then cE.ToggleVerticalTakeoff()end else g0("altOn","AH")b3=false;if po>-1 then if dd then b6=ck end end;if b5 then cE.ToggleVerticalTakeoff()end end;if cf then b6=100000 end else g0("altOff","AH")if bv then cE.ToggleIntoOrbit()end;if b5 then cE.ToggleVerticalTakeoff()end;cJ=p;b3=false;bm=false;po=0 end end;function pf.ResetAutopilots(pf)if pf then cf=false;a_=false;b8=false;bQ=false;b6=ck;qB=false end;bm=false;b3=false;b4=false;aZ=false;b2=false;rP=false;db=nil;if not d3 then b1=false;bp=nil end;if b5 then cE.ToggleVerticalTakeoff()end;if bv then cE.ToggleIntoOrbit()end;cJ=p;ce=false;cg=false;c8=0 end;function pf.BrakeToggle()aX=not aX;if b2 then b2=false;cJ=p end;if aX then g0("bkOn","B",1)cE.ResetAutopilots()else g0("bkOff","B",1)end end;function pf.BeginReentry()if b4 then c1="Re-Entry cancelled"g0("reOff","RE")b4=false;cJ=p;b1=false elseif not iK.hasAtmosphere then c1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"cb=5 elseif not bR then b4=true;if ig:getAxisCommandType(0)~=rQ.cruise then d.control.cancelCurrentControlMasterMode()end;cJ=true;aX=false;c1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cM;g0("par","RE")else b4=true;b1=true;cJ=true;aX=false;b6=iK.surfaceMaxAltitude+_;if b6>iK.spaceEngineMinAltitude then b6=iK.spaceEngineMinAltitude-0.01*iK.noAtmosphericDensityAltitude end;local rR=il(b6)c1="Beginning Re-entry.  Target speed: "..cM.." Target Altitude: "..rR;g0("glide","RE")cE.cmdCruise(bF(cM))end;b3=false end;function pf.ToggleAntigrav()if antigrav and not q then if d3 then g0("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=ck end;if br<1000 then br=1000 end;g0("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pf.changeSpd(rS)local rT=1;if rS then rT=-1 end;if not c0 then if u and not oL and cn then local rU=bL;bL=ii(dr(bL+rT*aA/100,-1,1),2)if bL>=0 and rU<0 then bL=0;cn=false end elseif oL then if cj>0 or b4 then cM=dr(cM+rT*aA,0,V)elseif a_ then a0=dr(a0+rT*aA/3.6*100,0,8333.00)end else ig:updateCommandFromActionStart(axisCommandId.longitudinal,rT*aA/10)end else if a_ or bm or cf or bv then dh=dh+1*rT*-1;if dh>#d8 then dh=1 end;if dh<1 then dh=#d8 end else if not rS then rT=1 else rT=nil end;cD.adjustAutopilotTargetIndex(rT)end end end;function pf.TenthTick()local function rV(gD,rW)if gD==nil then gD=b.g()end;gD=ii(gD,5)if rW~=nil and rW or(py==nil or py~=gD)then local fw=cX:len()local rX=ic(c.getData()).maxBrake;if rX~=nil and rX>0 and ci then rX=rX/dr(fw/100,0.1,1)rX=rX/cj;if cj>0.10 then if bq then bq=(bq+rX)/2 else bq=rX end end end;if rX~=nil and rX>0 then bo=rX end;py=gD end end;rV(nil,true)if d4~=nil then if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ig:getTargetSpeed(axisCommandId.longitudinal)~=d4 then cE.cmdCruise(d4)else d4=nil end end end;function pf.SatNavTick()if not r then return end;pz=dbHud_1.getStringValue("SPBAutopilotTargetName")if pz~=nil and pz~=""and pz~="SatNavNotChanged"then local dL=ic(dbHud_1.getStringValue("SavedLocations"))if dL~=nil then bl=dL;local gy=-1;local gE;for dQ,dC in pairs(bl)do if dC.name and dC.name=="SatNav Location"then gy=dQ;break end end;if gy~=-1 then gE=bl[gy]gy=-1;for dQ,dC in pairs(e[0])do if dC.name and dC.name=="SatNav Location"then gy=dQ;break end end;if gy>-1 then e[0][gy]=gE end;cD.UpdateAtlasLocationsList()c1=gE.name.." position updated"end end;for L=1,#d8 do if d8[L].name==pz then bh=L;a.print("Index = "..bh.." "..d8[L].name)cD.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;ch=pE()return pf end;local function rY(d,b,c,a,e,vBooster,hover,antigrav,ib,dbHud_2,gyro,ie,ig,ih,rZ,gJ,ii,ea,ds,dr,g0,ik,pe)local r_={}local s0=true;local s1=5;local s2=5;local s3=s1;local s4=s2;local s5=bH;function r_.startControl(s6)local function s7(rS)local rT=1;local function s8(s9,rS)local sa={iK.surfaceMaxAltitude+100,iK.spaceEngineMinAltitude-0.01*iK.noAtmosphericDensityAltitude,iK.noAtmosphericDensityAltitude+U,iK.radius*(T-1)+iK.noAtmosphericDensityAltitude}local sb=s9;for dV,dC in ipairs(sa)do if rS and sb>dC then s9=dC elseif s9<dC and not rS then s9=dC;break end end;return s9 end;if rS then rT=-1 end;if not q and d3 then if c0 and rS then br=1000 elseif br~=nil then br=br+rT*s2;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=rI+rT*100 end elseif b1 or b5 or bv then if bv then if c0 then cQ=s8(cQ,rS)else cQ=cQ+rT*s1 end;if cQ<iK.noAtmosphericDensityAltitude then cQ=iK.noAtmosphericDensityAltitude end else if c0 and ci then b6=s8(b6,rS)else b6=b6+rT*s1 end end else ig:updateTargetGroundAltitudeFromActionStart(rT*1.0)end end;local function sc(sd)if not ci then c1="Flight Assist in Atmo only"return end;local dz=type(sd)if db==nil then if dz=="table"then if a_ or bm then cE.ToggleAutopilot()end;g0("180On","BR")elseif sd==1 then g0("bnkLft","BR")else g0("bnkRht","BR")end;if not b1 and not a_ and not bm then cE.ToggleAltitudeHold()if dz~="table"then sd=sd+1 end end;db=sd else g0("180Off","BR")db=nil end end;if s6=="gear"then bi=not bi;if bi then bm=false;bp=nil;cE.cmdThrottle(0)if vBooster or hover then if ci and ch==-1 then g0("bklOn","BL")la=true;b4=false;b3=false;b5=false;b1=false;b2=true;cJ=true;bi=false else if bS then g0("grOut","LG",1)d.control.extendLandingGears()end;ig:setTargetGroundAltitude(Z)if ci then aX=true end end end;if bS and not b2 and not(vBooster or hover)then g0("grOut","LG",1)d.control.extendLandingGears()end else if bS then g0("grIn","LG",1)d.control.retractLandingGears()end;ig:setTargetGroundAltitude(Y)end elseif s6=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif s6=="forward"then bT=bT-1 elseif s6=="backward"then if oL then sc(-cY*5000)else bT=bT+1 end elseif s6=="left"then if oL then sc(1)else bW=bW-1 end elseif s6=="right"then if oL then sc(3)else bW=bW+1 end elseif s6=="yawright"then bX=bX-1 elseif s6=="yawleft"then bX=bX+1 elseif s6=="straferight"then ig:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif s6=="strafeleft"then ig:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif s6=="up"then c8=c8+1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif s6=="down"then c8=c8-1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif s6=="groundaltitudeup"then s7()elseif s6=="groundaltitudedown"then s7(true)elseif s6=="option1"then se=false;if oL and c0 then local sf=""for L=1,#di do sf=sf.."| Name: "..a.getPlayerName(di[L]).." Mass: "..ii(b.getBoardedPlayerMass(di[L])/1000,1).."t "end;a.print("Onboard: "..sf)return end;cD.adjustAutopilotTargetIndex()elseif s6=="option2"then se=false;if oL and c0 then for L=1,#di do b.forceDeboard(di[L])end;c1="Deboarded All Passengers"return end;cD.adjustAutopilotTargetIndex(1)elseif s6=="option3"then local function sg()s0=not s0;if not s0 then g0("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sh,atmofueltank_size,"Atmo Fuel","fuel_container")si=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sj,spacefueltank_size,"Space Fuel","fuel_container")sk=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sl,rocketfueltank_size,"Rocket Fuel","fuel_container")sm=_autoconf.panels[_autoconf.panels_size]end;sn=a.createWidgetPanel("Docking")so=a.createWidget(sn,"parenting")a.addDataToWidget(c.getDataId(),so)sp=a.createWidgetPanel("Core combat stress")sq=a.createWidget(sp,"core_stress")a.addDataToWidget(b.getDataId(),sq)if ib~=nil then ib.show()end else g0("hud","DH")c.hide()b.hide()if si~=nil then gJ(si)si=nil end;if sn~=nil then gJ(sn)sn=nil end;if sp~=nil then gJ(sp)sp=nil end;if sk~=nil then gJ(sk)sk=nil end;if sm~=nil then gJ(sm)sm=nil end;if ib~=nil then ib.hide()end end end;se=false;if oL and c0 then local sf=""for L=1,#dj do sf=sf.."| ID: "..dj[L].." Mass: "..ii(b.getDockedConstructMass(dj[L])/1000,1).."t "end;a.print("Docked Ships: "..sf)return end;if y then if x then x=false else x=true end end;sg()elseif s6=="option4"then se=false;if oL and c0 then for L=1,#dj do b.forceUndock(dj[L])end;c1="Undocked all ships"return end;db=nil;cE.ToggleAutopilot()elseif s6=="option5"then se=false;cE.ToggleLockPitch()elseif s6=="option6"then se=false;if oL and c0 then if ib then local sr=ib.getVentingCooldown()if sr>0 then c1="Cannot vent again for "..sr.." seconds"return end;if ib.getShieldHitpoints()<ib.getMaxShieldHitpoints()then ib.startVenting()c1="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c1="Shields already at max hitpoints"end;return else c1="No shield found"return end end;cE.ToggleAltitudeHold()elseif s6=="option7"then se=false;if oL and c0 then if ib then ib.toggle()return else c1="No shield found"return end end;F=not F;if F then c1="Collision System Enabled"else c1="Collision System Secured"end elseif s6=="option8"then se=false;if oL and c0 then if bh>0 and ga~=nil then cE.routeWP()else c1="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then c1="DeCoupled Mode - Ground Stabilization off"ig:deactivateGroundEngineAltitudeStabilization()g0("gsOff","GS")else c1="Coupled Mode - Ground Stabilization on"ig:activateGroundEngineAltitudeStabilization(ss)d:setEngineForceCommand('hover',vec3(),1)g0("gsOn","GS")end elseif s6=="option9"then se=false;if oL and c0 then ig:resetCommand(axisCommandId.longitudinal)ig:resetCommand(axisCommandId.lateral)ig:resetCommand(axisCommandId.vertical)cE.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()co=gyro.getState()==1;if co then g0("gyOn","GA")else g0("gyOff","GA")end else c1="No gyro found"end elseif s6=="lshift"then dg=false;if oL then c0=true end;if ih()==1 then c0=true;be=ih()rZ(1)elseif ie()==1 and z then c0=true;cI=false;cH=false end elseif s6=="brake"then if aV or oL then cE.BrakeToggle()elseif not aX then cE.BrakeToggle()else aX=true end elseif s6=="lalt"then se=true;oL=true;if ie()==0 and not i and g=="keyboard"then rZ(1)end elseif s6=="booster"then if n then d:toggleBoosters()elseif not c2 then if not st then d:toggleBoosters()st=true end;c2=true else if st then d:toggleBoosters()st=false end;c2=false end elseif s6=="stopengines"then local function su()if bH-s5<1.5 then g0("clear","CA")b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;db=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;b_=false;bQ=false;ce=false;cf=false;bR=false;cJ=p;bm=false;b0=false;co=false;bp=nil;bv=false end end;su()s5=bH;if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ig:resetCommand(axisCommandId.longitudinal)cE.cmdThrottle(0)else cE.cmdThrottle(100)end else if ig:getTargetSpeed(axisCommandId.longitudinal)~=0 then ig:resetCommand(axisCommandId.longitudinal)else if ci then cE.cmdCruise(V)else cE.cmdCruise(a0*3.6)end end end elseif s6=="speedup"then cE.changeSpd()elseif s6=="speeddown"then cE.changeSpd(true)elseif s6=="antigravity"and not q then if antigrav~=nil then cE.ToggleAntigrav()else c1="No antigrav found"end end end;function r_.stopControl(s6)local function sv()if not q and d3 then s4=s2 end;if b1 or b5 or bv then s3=s1 end end;if s6=="forward"then bT=0 elseif s6=="backward"then bT=0 elseif s6=="left"then if db then if db==2 then db=-2 else db=-1 end end;bW=0 elseif s6=="right"then if db then if db==4 then db=-2 else db=-1 end end;bW=0 elseif s6=="yawright"then bX=0 elseif s6=="yawleft"then bX=0 elseif s6=="straferight"then ig:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif s6=="strafeleft"then ig:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif s6=="up"then c8=0;ig:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then ig:activateGroundEngineAltitudeStabilization(ss)d:setEngineForceCommand('hover',vec3(),1)end elseif s6=="down"then c8=0;ig:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then ig:activateGroundEngineAltitudeStabilization(ss)d:setEngineForceCommand('hover',vec3(),1)end elseif s6=="groundaltitudeup"then sv()se=false elseif s6=="groundaltitudedown"then sv()se=false elseif s6=="lshift"then if ih()==1 then c9=0;ca=0;rZ(be)elseif ie()==1 and z then cI=false;cH=false end;c0=false elseif s6=="brake"then if not aV and not oL then if aX then cE.BrakeToggle()else aX=false end end elseif s6=="lalt"then if ie()==0 and i then if se then if ih()==1 then rZ(0)else rZ(1)end else se=true end elseif ie()==0 and not i and g=="keyboard"then rZ(0)end;oL=false end end;function r_.loopControl(s6)local function sw(rS)local rT=1;if rS then rT=-1 end;if not q and d3 then if br~=nil then br=br+rT*s4;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;s4=dr(s4*1.05,s2,50)aX=false else br=rI+rT*100;aX=false end elseif b1 or b5 or bv then if bv then cQ=cQ+rT*s3;if cQ<iK.noAtmosphericDensityAltitude then cQ=iK.noAtmosphericDensityAltitude end else b6=b6+rT*s3 end;s3=dr(s3*1.05,s1,50)else ig:updateTargetGroundAltitudeFromActionLoop(rT*1.0)end end;local function sx(rS)local rT=1;if rS then rT=-1 end;if not c0 then if u and not oL then bL=dr(bL+rT*aB/100,-1,1)else ig:updateCommandFromActionLoop(axisCommandId.longitudinal,rT*aB)end end end;if s6=="groundaltitudeup"then if not c0 then sw()end elseif s6=="groundaltitudedown"then if not c0 then sw(true)end elseif s6=="speedup"then sx()elseif s6=="speeddown"then sx(true)end end;function r_.inputTextControl(rR)local function sy(sz,fC,gB)local function sA(fC)local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local dZ,d_,e7,e8,e9=ea(fC,dJ)if dZ=="0"and d_=="0"then return vec3(ds(e7),ds(e8),ds(e9))end;e8=math.rad(e8)e7=math.rad(e7)local iK=e[ds(dZ)][ds(d_)]local f0=math.cos(e7)local sB=vec3(f0*math.cos(e8),f0*math.sin(e8),math.sin(e7))return iK.center+(iK.radius+e9)*sB end;local g2=sA(fC)return cD.AddNewLocation(sz,g2,gB)end;local L;local sC,sD=nil,nil;local sE="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"L=string.find(rR," ")sC=rR;if L~=nil then sC=string.sub(rR,0,L-1)sD=string.sub(rR,L+1)end;if sC=="/help"or sC=="/commands"then for oh in string.gmatch(sE,"([^\n]+)")do a.print(oh)end;return elseif sC=="/setname"then if sD==nil or sD==""then c1="Usage: ah-setname Newname"return end;if bh>0 and ga~=nil then cD.UpdatePosition(sD)else c1="Select a saved target to rename first"end elseif ib and sC=="/resist"then if not ib then c1="No shield found"return elseif sD==nil or ib.getResistancesCooldown()>0 then c1="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ=dI..', '..dI..', '..dI..', '..dI;local sF,sG,sH,sI=ea(sD,dJ)if sI==nil or sF+sG+sH+sI>0.6 then c1="Improperly formatted or total exceeds 0.6"return end;if ib.setResistances(sF,sG,sH,sI)==1 then c1="Shield Resistances set"else c1="Resistance setting failed."end elseif sC=="/addlocation"or string.find(rR,"::pos")~=nil then local gB=false;local sz="0-Temp"if sD==nil or sD==""then sD=sC;gB=true end;L=string.find(sD,"::")if not gB then sz=string.sub(sD,1,L-2)end;local fC=string.sub(sD,L)sy(sz,fC,gB)elseif sC=="/agg"then if sD==nil or sD==""then c1="Usage: /agg targetheight"return end;sD=ds(sD)if sD<1000 then sD=1000 end;br=sD;c1="AGG Target Height set to "..sD elseif sC=="/G"then if sD==nil or sD==""then c1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sD=="dump"then for dQ,dC in pairs(ik())do if type(dC.get())=="boolean"then if dC.get()==true then a.print(dQ.." true")else a.print(dQ.." false")end elseif dC.get()==nil then a.print(dQ.." nil")else a.print(dQ.." "..dC.get())end end;return end;L=string.find(sD," ")local sJ=string.sub(sD,0,L-1)local sK=string.sub(sD,L+1)for dQ,dC in pairs(ik())do if dQ==sJ then c1="Variable "..sJ.." changed to "..sK;local sL=type(dC.get())if sL=="number"then sK=ds(sK)if dQ=="AtmoSpeedLimit"then cM=sK end elseif sL=="boolean"then if string.lower(sK)=="true"then sK=true else sK=false end end;dC.set(sK)return end end;c1="No such global variable: "..sJ elseif sC=="/deletewp"then if bh>0 and ga~=nil then cD.ClearCurrentPosition()else c1="Select a custom wp to delete first in IPH"end elseif sC=="/copydatabank"then if dbHud_2 then pe(true)else c1="Spare Databank required to copy databank"end elseif sC=="/iphWP"then if bh>0 then a.print(cE.showWayPoint(c5,bg,true))a.print(json.encode(bg))a.logInfo("PRIVATELOCATIONS:"..json.encode(bl))c1="::pos waypoint shown in lua chat and written to logfile"else c1="No target selected in IPH"end end end;function r_.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;c1="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;return r_ end;local function sM(d,b,c,a,library,e,vBooster,hover,pd,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ib,gyro,warpdrive,sN)local sO={}local dq=string.format;local ic=json.decode;local sP=json.encode;local sQ=b.getElementMaxHitPointsById;local id=b.getElementMassById;local ie=d.control.isRemoteControlled;local ea=string.match;local gJ=a.destroyWidgetPanel;local fZ=a.updateData;local f_=a.addDataToWidget;local rZ=a.lockView;local ih=a.isViewLocked;local dt=math.sqrt;local ds=tonumber;local f4=math.abs;local bF=math.floor;local bG=c.getAtmosphereDensity;local e_=math.atan;local bE=a.getTime;local dr=utils.clamp;local ig=d.axisCommandManager;local sR=Z;local gL=13;local sS=b.getElementIdList()local sT={}local sU=0;local function du(eI,eJ)if eI==0 then return f4(eJ)<1e-09 end;if eJ==0 then return f4(eI)<1e-09 end;return f4(eI-eJ)<math.max(f4(eI),f4(eJ))*dH end;local function ii(dI,sV)local rT=10^(sV or 0)return bF(dI*rT+0.5)/rT end;local function ij(sW,sX)for dQ,dC in pairs(sX)do if type(dQ)=="string"then sW[dQ]=dC else sW[#sW+1]=sX[dQ]end end;return sW end;local function ik(sY)local sZ={}if not sY then ij(sZ,K)ij(sZ,a8)ij(sZ,az)ij(sZ,aU)return sZ elseif sY=="boolean"then return K elseif sY=="handling"then return a8 elseif sY=="hud"then return az elseif sY=="physics"then return aU end end;local function pe(s_)local function t0(t1)for dQ,dC in pairs(t1)do if not J or J and dQ~="SavedLocations"then dbHud_1.setStringValue(dQ,sP(dC.get()))if s_ and dbHud_2 then dbHud_2.setStringValue(dQ,sP(dC.get()))end end end end;if dbHud_1 then t0(bB)t0(ik())a.print("Saved Variables to Datacore")if s_ and dbHud_2 then c1="Databank copied.  Remove copy when ready."end end end;local function g0(t2,t3,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..t2 .."|"..t3 .."|"..ay)else a.logInfo("sound_notification|audiopacks/"..h.."/"..t2 .."|"..t3 .."|"..ay)end else a.logInfo("sound_q|audiopacks/"..h.."/"..t2 .."|"..t3 .."|"..ay)end end;local function gK(hk,hl,rR,jo,t4)if jo==nil then jo=""end;if t4==nil then t4=""end;return dq([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jo,hk,hl,t4,rR)end;local function il(cc,t5)local t6=cc>100000;if t5==nil then t5=1 end;if t6 then return ii(cc/1000/200,t5).."SU"elseif cc<1000 then return ii(cc,t5).."M"else return ii(cc/1000,t5).."KM"end end;local function im(t7)local t8=0;local t9=0;local ta=0;if t7<60 then t7=bF(t7)elseif t7<3600 then t8=bF(t7/60)t7=bF(t7%60)elseif t7<86400 then t9=bF(t7/3600)t8=bF(t7%3600/60)else ta=bF(t7/86400)t9=bF(t7%86400/3600)end;if ta>0 then return ta.."d "..t9 .."h "elseif t9>0 then return t9 .."h "..t8 .."m "elseif t8>0 then return t8 .."m "..t7 .."s"elseif t7>0 then return t7 .."s"else return"0s"end end;function sO.onStart()local tb=false;local function tc()local function td(te)local tf=dbHud_1.hasKey;for dQ,dC in pairs(te)do if tf(dQ)then local dL=ic(dbHud_1.getStringValue(dQ))if dL~=nil then dC.set(dL)tb=true end end end end;if dbHud_1 then if not f then td(ik())coroutine.yield()td(bB)else td(bB)c1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"cb=5;tb=false end;coroutine.yield()if tb then c1="Loaded Saved Variables"cs=a9;ct=aa;aV=j;g=string.lower(g)cJ=p;cM=V;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]elseif not f then c1="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if U<2000 then c1="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bz=VERSION_NUMBER else c1="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bH then bq=0 end;bs=bH;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"cb=7 end;if antigrav and not q then if br==nil then br=ck end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then bl=require("autoconf/custom/archhud/privatelocations")end;li="Proceeding to Waypoint"end;local function tg()local function th(ti,tj)if ti>tj then tj=ti end;local tk,tl=0,0;if a6>0 then tk=a6*0.05 end;if a7>0 then tl=a7*0.05 end;tj=tj*(1-(tk+tl))return tj end;local tm=b.getElementNameById;local tn=aq~=0 and ar~=0;for dQ in pairs(sS)do local type=b.getElementTypeById(sS[dQ])if ea(type,'^.*Atmospheric Engine$')then if ea(tostring(b.getElementTagsById(sS[dQ])),'^.*vertical.*$')and b.getElementForwardById(sS[dQ])[3]>0 then d2=true end end;if ea(type,'^.*Space Engine$')then cT=true;if ea(tostring(b.getElementTagsById(sS[dQ])),'^.*vertical.*$')then local to=b.getElementForwardById(sS[dQ])if to[3]<0 then tp=true else cS=true end end end;if type=="Landing Gear"then bS=true end;if type=="Dynamic Core Unit"then local tq=sQ(sS[dQ])if tq>10000 then gL=110 elseif tq>1000 then gL=55 elseif tq>150 then gL=27 end end;sU=sU+sQ(sS[dQ])if tn and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local tq=sQ(sS[dQ])local o5=id(sS[dQ])local ti=0;local ji=bE()if type=="Atmospheric Fuel Tank"then local tj=400;local tr=35.03;if tq>10000 then tj=51200;tr=5480 elseif tq>1300 then tj=6400;tr=988.67 elseif tq>150 then tj=1600;tr=182.67 end;ti=o5-tr;if a3>0 then tj=tj+tj*a3*0.2 end;tj=th(ti,tj)cu[#cu+1]={sS[dQ],tm(sS[dQ]),tj,tr,ti,ji}end;if type=="Rocket Fuel Tank"then local tj=320;local tr=173.42;if tq>65000 then tj=40000;tr=25740 elseif tq>6000 then tj=5120;tr=4720 elseif tq>700 then tj=640;tr=886.72 end;ti=o5-tr;if a5>0 then tj=tj+tj*a5*0.1 end;tj=th(ti,tj)cw[#cw+1]={sS[dQ],tm(sS[dQ]),tj,tr,ti,ji}end;if type=="Space Fuel Tank"then local tj=600;local tr=35.03;if tq>10000 then tj=76800;tr=5480 elseif tq>1300 then tj=9600;tr=988.67 elseif tq>150 then tj=2400;tr=182.67 end;ti=o5-tr;if a4>0 then tj=tj+tj*a4*0.2 end;tj=th(ti,tj)cv[#cv+1]={sS[dQ],tm(sS[dQ]),tj,tr,ti,ji}end end end;if not d2 then b5,aW=false,false end end;local function ts()if gyro~=nil then co=gyro.getState()==1 end;if not bx then ig:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then rZ(1)else rZ(0)end;if door and(ci or not ci and ck<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(ci or not ci==0 and ck<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;if antigrav then d3=antigrav.getState()==1;if d3 and not q then antigrav.show()end end;if ie()==1 and k then a.freeze(1)else a.freeze(0)end;if bS then bi=d.control.isAnyLandingGearExtended()==1;if bi then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if ch~=-1 or not ci and cX:len()<50 then aX=true;bi=true;if bS then d.control.extendLandingGears()end else aX=false end;ig:setTargetGroundAltitude(sR)if ci and ch~=-1 then cA=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;p7=ci end;local function tt()local tu={}local function tv()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tw={[1]=4480,[6]=4480,[7]=6270}for tx,ty in pairs(e)do e[tx][0]=tv()e[tx][0].systemId=tx;tu[tx]={}for tz,iK in pairs(e[tx])do iK.gravity=iK.gravity/9.8;iK.center=vec3(iK.center)iK.name=iK.name[1]iK.noAtmosphericDensityAltitude=iK.atmosphereThickness or iK.atmosphereRadius-iK.radius;iK.spaceEngineMinAltitude=tw[iK.id]or 0.68377*(iK.atmosphereThickness or iK.atmosphereRadius-iK.radius)iK.planetarySystemId=tx;iK.bodyId=iK.id;tu[tx][tz]=iK;if mb==nil or iK.center.x<mb then mb=iK.center.x end;if ma==nil or iK.center.x>ma then ma=iK.center.x end;if me==nil or iK.center.y<me then me=iK.center.y end;if md==nil or iK.center.y>md then md=iK.center.y end;if iK.center and iK.name~="Space"then dk[#dk+1]=iK end end end;ek=dp(d,b,c,a,dq,dr,ds,dt,du)cy=ek(tu)cz=f3(d,b,c,a,dt,f4)cB=fy(d,b,c,a,dq,dr,ds,dt,du)cD=fY(d,b,c,a,dbHud_1,e,fZ,f_,bF,ds,dt,g0)end;tA=false;tB=coroutine.create(function()ig:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})tc()coroutine.yield()tg()coroutine.yield()cE=pc(d,b,c,a,e,vBooster,hover,pd,antigrav,warpdrive,dbHud_1,f4,bF,bG,ie,e_,bE,dr,ig,fZ,ih,dt,ii,g0,ij,du,il,im,pe,ic,dq,f_)ts()coroutine.yield()tt()cF=gI(b,a,c,library,radar_1,radar_2,f4,gJ,dt,gK,ds,gL,g0)cC=ia(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ib,warpdrive,f4,bF,dq,ic,bG,id,ie,e_,bE,dr,ig,f_,fZ,gJ,ih,dt,ii,gK,g0,ij,ik,il,im)cC.ButtonSetup()cG=rY(d,b,c,a,e,vBooster,hover,antigrav,ib,dbHud_2,gyro,ie,ig,ih,rZ,gJ,ii,ea,ds,dr,g0,ik,pe)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)c.setTimer("radarTick",aP)c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)g0("start","SU")end)coroutine.resume(tB)end;function sO.onUpdate()if not tA then local h_=coroutine.status(tB)if h_=="suspended"then local dR,i0=coroutine.resume(tB)if i0 then a.print("ERROR STARTUP: "..i0)end elseif h_=="dead"then tA=true end end;if tA then d:update()if ci and u and d5 then if d5 and bP then cE.cmdThrottle(0)bP=false elseif not d5 and not bP then bL=0;bP=true end end;if dn then ig:setThrottleCommand(axisCommandId.longitudinal,dn)dn=nil end;if not cH and oN~=tC then a.setScreen(oN)end;tC=oN end end;function sO.onFlush()local function tD(tE,q_)local tF=vec3()local tG=vec3()if tE==axisCommandId.longitudinal then tF=vec3(b.getConstructOrientationForward())tG=cV elseif tE==axisCommandId.vertical then tF=vec3(b.getConstructOrientationUp())tG=cU elseif tE==axisCommandId.lateral then tF=vec3(b.getConstructOrientationRight())tG=cW else return vec3()end;local tH=vec3(b.getWorldGravity())local tI=tH:dot(tG)local tJ=vec3(b.getWorldAirFrictionAcceleration())local tK=tJ:dot(tG)local tL=cX:dot(tF)local tM=q_*constants.kph2m;if tN==nil then tN=pid.new(10,0,10.0)end;tN:inject(tM-tL)local tO=tN:get()local tP=(tO-tK-tI)*tG;return tP end;local function tQ(tE,q_)local tF=vec3()local tG=vec3()if tE==axisCommandId.longitudinal then tF=vec3(b.getConstructOrientationForward())tG=cV elseif tE==axisCommandId.vertical then tF=vec3(b.getConstructOrientationUp())tG=cU elseif tE==axisCommandId.lateral then tF=vec3(b.getConstructOrientationRight())tG=cW else return vec3()end;local tH=vec3(b.getWorldGravity())local tI=tH:dot(tG)local tJ=vec3(b.getWorldAirFrictionAcceleration())local tK=tJ:dot(tG)local tL=cX:dot(tF)local tM=q_*constants.kph2m;if tR==nil then tR=pid.new(10,0,10.0)end;tR:inject(tM-tL)local tO=tR:get()local tP=(tO-tK-tI)*tG;return tP end;local function tS(tT,jx,g7)local tU=tT:cross(g7):normalize_inplace()local ki=math.acos(dr(tU:dot(-jx),-1,1))*constants.rad2deg;if tU:cross(-jx):dot(g7)<0 then ki=-ki end;return ki end;if antigrav and not q then if not d3 and antigrav.getBaseAltitude()~=br then antigrav.setBaseAltitude(br)end end;d5=ig:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local tV=dr(bT+bU+a.getControlDeviceForwardInput(),-1,1)local tW=dr(bW+bZ+a.getControlDeviceYawInput(),-1,1)local tX=dr(bX+bV-a.getControlDeviceLeftRightInput(),-1,1)local tY=bY;c_=vec3(b.getWorldVertical())if c_==nil or c_:len()==0 then c_=(iK.center-d1):normalize()end;cU=vec3(b.getConstructWorldOrientationUp())cV=vec3(b.getConstructWorldOrientationForward())cW=vec3(b.getConstructWorldOrientationRight())cY=vec3(b.getWorldVelocity())cX=vec3(b.getVelocity())d1=vec3(b.getConstructWorldPos())cm=b.getConstructMass()cZ=vec3(cY):len()d0=-c_:dot(cY)d7=getRoll(c_,cV,cW)local tZ=d7/180*math.pi;local t_=math.cos(tZ)local u0=math.sin(tZ)d6=tS(c_,cV,cW*t_+cU*u0)local u1=cY:normalize()local u2=f4(d7)local u3=utils.sign(d7)local u4=vec3(b.getWorldAngularVelocity())local u5=tV*aK*cW+tW*aF*cV+tX*aL*cU;if cJ==true and c_:len()>0.01 then local u6=f4(cL-d7)if((aZ or b4 or b2 or ce or b1 or bv)and u6>0 or cj>0.0 and u6<aG and p)and tW==0 and f4(d6)<85 then local u7=cL;local u8=aE;if cj==0 then u8=u8/4;cL=0;u7=0 end;if u9==nil then u9=pid.new(u8*0.01,0,u8*0.1)end;u9:inject(u7-d7)local ua=u9:get()u5=u5+ua*cV end end;local ub=1;local uc=0;local ud=1;bM=0;if ci and u and d5 then if ue==nil then ue=pid.new(0.1,0,1)end;ue:inject(cM/3.6-cY:dot(cV))local uf=ue:get()bO=dr(uf,-1,1)if not dn then if bO<bL and cj>0.005 then bN=true;dn=dr(bO,0.01,1)else bN=false;dn=bL end end;if ug==nil then ug=pid.new(1*0.01,0,1*0.1)end;ug:inject(cY:len()-cM/3.6)local uh=dr(ug:get(),0,1)if cj>0 and d0<-80 or cj>0.005 then bM=uh end;if bM>0 then if bN and bO==0.01 and not dn then dn=0 end else bO=dr(bO,0.01,1)end;local ui=''local uj=vec3()local uk=tD(axisCommandId.vertical,c8*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uk,uc)local ul='thrust analog longitudinal 'if by=="All"or by=="Longitude"then ul=ul..aR end;local um=ig:getAxisCommandType(axisCommandId.longitudinal)local un=ig:composeAxisAccelerationFromThrottle(ul,axisCommandId.longitudinal)local uo=tQ(axisCommandId.lateral,bu*1000)ui=ui..' , '.."lateral airfoil , lateral ground "uj=uj+uo;if uj:len()>constants.epsilon then d:setEngineForceCommand(ui,uj,uc,'','','',ud)end;d:setEngineForceCommand(ul,un,ub)local up='thrust analog vertical fueled 'local uq='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then uq=uq..aS end;if by=="All"or by=="Vertical"then up=up..aT end;if c8~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(up,uk,ub)else d:setEngineForceCommand(up,vec3(),ub)end;if bu~=0 then d:setEngineForceCommand(uq,uo,ub)else d:setEngineForceCommand(uq,vec3(),ub)end;if tY==0 then tY=bM end;local ur=-tY*(aM*cY+aN*u1)d:setEngineForceCommand('brake',ur)else if u then if not dn then dn=bL end end;local q_=c.getAxisCommandValue(0)if not d5 then if ug==nil then ug=pid.new(1*0.01,0,1*0.1)end;ug:inject(cY:len()-q_/3.6)local uh=dr(ug:get(),0,1)tY=dr(tY+uh,0,1)end;local ur=-tY*(aM*cY+aN*u1)d:setEngineForceCommand('brake',ur)local ui=''local uj=vec3()local us=false;local ul='thrust analog longitudinal 'if by=="All"or by=="Longitude"then ul=ul..aR end;local um=ig:getAxisCommandType(axisCommandId.longitudinal)if um==axisCommandType.byThrottle then local un=ig:composeAxisAccelerationFromThrottle(ul,axisCommandId.longitudinal)d:setEngineForceCommand(ul,un,ub)elseif um==axisCommandType.byTargetSpeed then local un=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ui=ui..' , '..ul;uj=uj+un;if ig:getTargetSpeed(axisCommandId.longitudinal)==0 or ig:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ig:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then us=true end end;local uq='thrust analog lateral 'if by=="All"or by=="Lateral"then uq=uq..aS end;local ut=ig:getAxisCommandType(axisCommandId.lateral)if ut==axisCommandType.byThrottle then local uu=ig:composeAxisAccelerationFromThrottle(uq,axisCommandId.lateral)d:setEngineForceCommand(uq,uu,ub)elseif ut==axisCommandType.byTargetSpeed then local uo=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ui=ui..' , '..uq;uj=uj+uo end;local up='thrust analog vertical 'if by=="All"or by=="Vertical"then up=up..aT end;local uv=ig:getAxisCommandType(axisCommandId.vertical)if uv==axisCommandType.byThrottle then local uk=ig:composeAxisAccelerationFromThrottle(up,axisCommandId.vertical)if c8~=0 or b2 and aX then d:setEngineForceCommand(up,uk,ub,'airfoil','ground','',ud)else d:setEngineForceCommand(up,vec3(),ub)d:setEngineForceCommand('airfoil vertical',uk,ub,'airfoil','','',ud)d:setEngineForceCommand('ground vertical',uk,ub,'ground','','',ud)end elseif uv==axisCommandType.byTargetSpeed then if c8<0 then d:setEngineForceCommand('hover',vec3(),ub)end;local uw=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ui=ui..' , '..up;uj=uj+uw end;if uj:len()>constants.epsilon then if bY~=0 or us or f4(u1:dot(cV))<0.5 then ui=ui..', brake'end;d:setEngineForceCommand(ui,uj,uc,'','','',ud)end end;local ux=aJ*(u5-u4)local uy=vec3(b.getWorldAirFrictionAngularAcceleration())ux=ux-uy;d:setEngineTorqueCommand('torque',ux,ub,'airfoil','','',ud)d:setBoosterCommand('rocket_engine')if c2 and not n then local fw=cX:len()local uz=0.15;if not d5 then local uA=ig:getTargetSpeed(axisCommandId.longitudinal)if fw*3.6>uA*(1-uz)and st then st=false;d:toggleBoosters()elseif fw*3.6<uA*(1-uz)and not st then st=true;d:toggleBoosters()end else local oZ=c.getThrottle()if u then oZ=bL*100 end;local q_=oZ/100;if bG==0 then q_=q_*a0;if fw>=q_*(1-uz)and st then st=false;d:toggleBoosters()elseif fw<q_*(1-uz)and not st then st=true;d:toggleBoosters()end else local rc=bF(cM)q_=q_*rc/3.6;if fw>=q_*(1-uz)and st then st=false;d:toggleBoosters()elseif fw<q_*(1-uz)and not st then st=true;d:toggleBoosters()end end end end end;function sO.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(cj>0 or cj==0 and ck<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(cj>0 or cj==0 and ck<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;x=dm;pe()if nH then nH.activate()end;if A then cE.showWayPoint(iK,d1)end;local ob=1-(a6*0.05+a7*0.05)a.print(cC.FuelUsed("atmofueltank")..", "..cC.FuelUsed("spacefueltank")..", "..cC.FuelUsed("rocketfueltank"))g0("stop","SU")end;function sO.OneSecondTick()local function uB(ju)local uC=0;cr=""local uD=sU;local uE=0;local uF=0;local uG=0;local jm=0;local jn=""local uH=b.getElementHitPointsById;for dQ in pairs(sS)do local tq=0;local uI=0;uI=sQ(sS[dQ])tq=uH(sS[dQ])uE=uE+tq;if tq<uI then if tq==0 then uG=uG+1 else uF=uF+1 end;if cx and#sT==0 then g2=vec3(b.getElementPositionById(sS[dQ]))local hk=g2.x;local hl=g2.y;local hm=g2.z;table.insert(sT,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(sT,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(sT[2],0,0,90)table.insert(sT,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(sT,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(sT[4],90,90,0)table.insert(sT,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(sT,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(sT[6],90,-90,0)table.insert(sT,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(sT,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(sT[8],90,0,90)table.insert(sT,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(sT,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(sT[10],-90,0,90)table.insert(sT,sS[dQ])end elseif cx and#sT>0 and sT[11]==sS[dQ]then for jh in pairs(sT)do b.deleteSticker(sT[jh])end;sT={}end end;uC=bF(uE/uD*100)if uC<100 then ju[#ju+1]=gK(0,0,"","pbright txt")jm=bF(uC*2.55)jn=dq("rgb(%d,%d,%d)",255-jm,jm,0)if uC<100 then ju[#ju+1]=gK("50%",1035,"Elemental Integrity: "..uC.."%","txtbig txtmid","fill:"..jn)if uG>0 then ju[#ju+1]=gK("50%",1055,"Disabled Modules: "..uG.." Damaged Modules: "..uF,"txtbig txtmid","fill:"..jn)elseif uF>0 then ju[#ju+1]=gK("50%",1055,"Damaged Modules: "..uF,"txtbig txtmid","fill:"..jn)end end end end;local function uJ()if sN then if uK==nil and(i8~=nil or bi)then _autoconf.displayCategoryPanel(sN,weapon_size,"Weapons","weapon",true)uK=_autoconf.panels[_autoconf.panels_size]elseif uK~=nil and i8==nil and not bi then gJ(uK)uK=nil end end end;local function p9()local ji=bE()local kF=cZ;local pa=ji-cl;if kF>1.38889 then kF=kF/1000;local pb=kF*(ji-cl)bj=bj+pb;c6=c6+pb end;c7=c7+pa;bk=bk+pa;cl=ji end;p9()di=b.getPlayersOnBoard()dj=b.getDockedConstructs()uJ()local ju={}cC.OneSecondTick(ju)if s then uB(ju)end;cd=table.concat(ju,"")collectgarbage("collect")end;function sO.controlStart(s6)cG.startControl(s6)end;function sO.controlStop(s6)cG.stopControl(s6)end;function sO.controlLoop(s6)cG.loopControl(s6)end;function sO.controlInput(rR)cG.inputTextControl(rR)end;function sO.radarEnter(d_)cF.onEnter(d_)end;function sO.radarLeave(d_)cF.onLeave(d_)end;function sO.onTick(uL)if uL=="tenthSecond"then cE.TenthTick()cC.TenthTick()elseif uL=="oneSecond"then uM.OneSecondTick()elseif uL=="fiveSecond"then cE.SatNavTick()elseif uL=="msgTick"then cC.MsgTick()elseif uL=="animateTick"then cC.AnimateTick()elseif uL=="hudTick"then cC.hudtick()elseif uL=="apTick"then cE.APTick()elseif uL=="radarTick"then cF.UpdateRadar()elseif uL=="tagTick"then cG.tagTick()elseif uL=="contact"then cF.ContactTick()end end;return sO end;function script.onStart()uM.onStart()end;function script.onStop()uM.onStop()end;function script.onTick(uL)uM.onTick(uL)end;function script.onFlush()uM.onFlush()end;function script.onUpdate()uM.onUpdate()end;function script.onActionStart(s6)uM.controlStart(s6)end;function script.onActionStop(s6)uM.controlStop(s6)end;function script.onActionLoop(s6)uM.controlLoop(s6)end;function script.onInputText(rR)uM.controlInput(rR)end;function script.onEnter(d_)uM.radarEnter(d_)end;function script.onLeave(d_)uM.radarLeave(d_)end;bD(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uM=sM(d,b,c,a,library,e,vBooster,hover,pd,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ib,gyro,warpdrive,sN)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
