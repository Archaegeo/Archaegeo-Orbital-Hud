name: ArchHud - Archaegeo v0.706 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.706;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=true;m=false;n=false;o=false;p=false;q=false;r=false;s=true;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=35;K=35;L=30;M=30;N=-30;O=0;P=5000;Q=1.2;R=2000;S=1050;T=30000;U=1000;V=50;W=0;X=100000;Y=8333.00;Z=1.0;_=32;a0=0;a1=0;a2=0;a3=0;a4=0;a5=1920;a6=1080;a7=400;a8=130;a9=224;aa=255;ab=255;ac=0;ad=0;ae=960;af=540;ag=1300;ah=540;ai=1525;aj=325;ak=550;al=540;am=30;an=700;ao=1750;ap=250;aq=50;ar=250;as=0;at=25;au=100;av=5;aw=1;ax=0.003;ay=0.003;az=2;aA=1.5;aB=180;aC=150;aD=0.002;aE=2;aF=0.8;aG=1;aH=3;aI=1;aJ=40;aK=0.0166667;aL=0.0666667;aM="none"aN="none"aO="none"aP=j;aQ=false;aR=false;aS=false;aT=false;aU=false;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=1000;b1=false;b2=false;b3=false;b4=false;b5=0;b6="Aligning"b7=0;b8=1;b9="None"ba=nil;bb=0;bc=nil;bd=0.0;be=0;bf={}bg=false;bh=0;bi=0;bj=nil;bk=0;bl=1000;bm=0;bn=false;bo=0;bp=false;bq="All"br=true;bs="Off"bt=0.000;bu={}local bv={VertTakeOff={set=function(bw)a_=bw end,get=function()return a_ end},VertTakeOffEngine={set=function(bw)aQ=bw end,get=function()return aQ end},SpaceTarget={set=function(bw)bn=bw end,get=function()return bn end},BrakeToggleStatus={set=function(bw)aP=bw end,get=function()return aP end},BrakeIsOn={set=function(bw)aR=bw end,get=function()return aR end},RetrogradeIsOn={set=function(bw)aS=bw end,get=function()return aS end},ProgradeIsOn={set=function(bw)aT=bw end,get=function()return aT end},Autopilot={set=function(bw)aU=bw end,get=function()return aU end},TurnBurn={set=function(bw)aV=bw end,get=function()return aV end},AltitudeHold={set=function(bw)aW=bw end,get=function()return aW end},BrakeLanding={set=function(bw)aX=bw end,get=function()return aX end},Reentry={set=function(bw)aZ=bw end,get=function()return aZ end},AutoTakeoff={set=function(bw)aY=bw end,get=function()return aY end},HoldAltitude={set=function(bw)b0=bw end,get=function()return b0 end},AutopilotAccelerating={set=function(bw)b1=bw end,get=function()return b1 end},AutopilotBraking={set=function(bw)b3=bw end,get=function()return b3 end},AutopilotCruising={set=function(bw)b4=bw end,get=function()return b4 end},AutopilotRealigned={set=function(bw)b2=bw end,get=function()return b2 end},AutopilotEndSpeed={set=function(bw)b5=bw end,get=function()return b5 end},AutopilotStatus={set=function(bw)b6=bw end,get=function()return b6 end},AutopilotPlanetGravity={set=function(bw)b7=bw end,get=function()return b7 end},PrevViewLock={set=function(bw)b8=bw end,get=function()return b8 end},AutopilotTargetName={set=function(bw)b9=bw end,get=function()return b9 end},AutopilotTargetCoords={set=function(bw)ba=bw end,get=function()return ba end},AutopilotTargetIndex={set=function(bw)bb=bw end,get=function()return bb end},TotalDistanceTravelled={set=function(bw)bd=bw end,get=function()return bd end},TotalFlightTime={set=function(bw)be=bw end,get=function()return be end},SavedLocations={set=function(bw)bf=bw end,get=function()return bf end},VectorToTarget={set=function(bw)bg=bw end,get=function()return bg end},LocationIndex={set=function(bw)bh=bw end,get=function()return bh end},LastMaxBrake={set=function(bw)bi=bw end,get=function()return bi end},LockPitch={set=function(bw)bj=bw end,get=function()return bj end},LastMaxBrakeInAtmo={set=function(bw)bk=bw end,get=function()return bk end},AntigravTargetAltitude={set=function(bw)bl=bw end,get=function()return bl end},LastStartTime={set=function(bw)bm=bw end,get=function()return bm end},iphCondition={set=function(bw)bq=bw end,get=function()return bq end},stablized={set=function(bw)br=bw end,get=function()return br end},UseExtra={set=function(bw)bs=bw end,get=function()return bs end},SelectedTab={set=function(bw)bx=bw end,get=function()return bx end},saveRoute={set=function(bw)bu=bw end,get=function()return bu end}}local by=math.abs;local bz=math.floor;local bA=string.format;local bB=json.decode;local bC=json.encode;local bD=b.getElementMaxHitPointsById;local bE=c.getAtmosphereDensity;local bF=b.getElementMassById;local bG=d.control.isRemoteControlled;local bH=math.atan;local bI=string.match;local bJ=a.getTime;local vec3=vec3;local bK=utils.clamp;local bL=d.axisCommandManager;local bM=a.destroyWidgetPanel;local bN=a.updateData;local bO=a.addDataToWidget;local bP=a.lockView;local bQ=a.isViewLocked;local bR=math.sqrt;local bS=tonumber;local function bT(bU,bV)local bW=10^(bV or 0)return bz(bU*bW+0.5)/bW end;local bX=bJ()local bY=bJ()local bZ=13;local b_=a8;local c0=aa;local c1=a9;local c2=0;local c3=0;local c4=false;local c5=0;local c6=false;local c7=false;local c8=55;local c9=false;local ca=false;local cb=0;local cc=0;local cd=0;local ce=0;local cf=0;local cg=0;local ch=0;local ci=false;local cj=false;local ck="empty"local cl=false;local cm=0;local cn=0;local co=0;local cp=0;local cq=nil;local cr=0;local cs=0;local ct=0;local cu=0;local cv=0;local cw=3;local cx=0;local cy=""local cz=false;local cA=false;local cB=false;local cC=-1;local cD=""local cE=bE()>0;local cF=bE()local cG=b.getAltitude()local cH=b.getElementIdList()local cI=bJ()local cJ=b.getConstructMass()local cK=false;local cL=nil;local cM=[[rgb(]]..bz(b_+0.5)..","..bz(c1+0.5)..","..bz(c0+0.5)..[[)]]local cN=[[rgb(]]..bz(b_*0.9+0.5)..","..bz(c1*0.9+0.5)..","..bz(c0*0.9+0.5)..[[)]]local cO={}local cP=""local cQ=a5;local cR=a6;local cS={}local cT={}local cU={}local cV=0;local cW=false;local cX=nil;local cY=nil;local cZ=nil;local c_=nil;local d0=nil;local d1=nil;local d2=nil;local d3=nil;local d4=nil;local d5=nil;local d6=false;local d7=false;local d8=p;local d9=W;local da=false;local db=0;local dc=S;local dd=0;local de=nil;local df={VectorToTarget=false}local dg=0;local dh=false;local di=false;local dj=false;local dk=false;local dl=vec3(b.getConstructWorldOrientationUp())local dm=vec3(b.getConstructWorldOrientationForward())local dn=vec3(b.getConstructWorldOrientationRight())local dp=vec3(b.getVelocity())local dq=vec3(b.getWorldVelocity())local dr=vec3(dq):len()local ds=vec3(b.getWorldVertical())local dt=-ds:dot(dq)local du=vec3(b.getConstructWorldPos())local dv=false;local dw=false;local dx=nil;local dy=true;local dz=0;local dA=0;local dB={}local dC=false;local dD=50000;local dE=nil;local dF={}local dG=c.getClosestPlanetInfluence()>0 or cG>0 and cG<200000;local dH=false;local dI=nil;local dJ=false;local dK=0;local dL={}local dM=nil;local dN=nil;local dO={}local dP=90;local dQ=x;function dR(dS)a.print(bX..": "..dS)end;local function dT(dU,dV,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..dU.."|"..dV.."|"..au)else a.logInfo("sound_notification|audiopacks/"..h.."/"..dU.."|"..dV.."|"..au)end else a.logInfo("sound_q|audiopacks/"..h.."/"..dU.."|"..dV.."|"..au)end end;local function dW(dX,dY)for dZ,d_ in pairs(dY)do if type(dZ)=="string"then dX[dZ]=d_ else dX[#dX+1]=dY[dZ]end end;return dX end;local function e0(e1)local e2={}local e3={userControlScheme={set=function(bw)g=bw end,get=function()return g end},soundFolder={set=function(bw)h=bw end,get=function()return h end},freeLookToggle={set=function(bw)i=bw end,get=function()return i end},BrakeToggleDefault={set=function(bw)j=bw end,get=function()return j end},RemoteFreeze={set=function(bw)k=bw end,get=function()return k end},brightHud={set=function(bw)m=bw end,get=function()return m end},RemoteHud={set=function(bw)l=bw end,get=function()return l end},VanillaRockets={set=function(bw)n=bw end,get=function()return n end},InvertMouse={set=function(bw)o=bw end,get=function()return o end},autoRollPreference={set=function(bw)p=bw end,get=function()return p end},ExternalAGG={set=function(bw)q=bw end,get=function()return q end},UseSatNav={set=function(bw)r=bw end,get=function()return r end},ShouldCheckDamage={set=function(bw)s=bw end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(bw)t=bw end,get=function()return t end},AtmoSpeedAssist={set=function(bw)u=bw end,get=function()return u end},ForceAlignment={set=function(bw)v=bw end,get=function()return v end},DisplayDeadZone={set=function(bw)w=bw end,get=function()return w end},showHud={set=function(bw)x=bw end,get=function()return x end},hideHudOnToggleWidgets={set=function(bw)y=bw end,get=function()return y end},ShiftShowsRemoteButtons={set=function(bw)z=bw end,get=function()return z end},SetWaypointOnExit={set=function(bw)A=bw end,get=function()return A end},AlwaysVSpd={set=function(bw)B=bw end,get=function()return B end},BarFuelDisplay={set=function(bw)C=bw end,get=function()return C end},voices={set=function(bw)D=bw end,get=function()return D end},alerts={set=function(bw)E=bw end,get=function()return E end},CollisionSystem={set=function(bw)F=bw end,get=function()return F end},AutoShieldToggle={set=function(bw)G=bw end,get=function()return G end},PreventPvP={set=function(bw)H=bw end,get=function()return H end},DisplayOdometer={set=function(bw)I=bw end,get=function()return I end}}local e4={YawStallAngle={set=function(bw)J=bw end,get=function()return J end},PitchStallAngle={set=function(bw)K=bw end,get=function()return K end},brakeLandingRate={set=function(bw)L=bw end,get=function()return L end},MaxPitch={set=function(bw)M=bw end,get=function()return M end},ReEntryPitch={set=function(bw)N=bw end,get=function()return N end},LockPitchTarget={set=function(bw)O=bw end,get=function()return O end},AutopilotSpaceDistance={set=function(bw)P=bw end,get=function()return P end},TargetOrbitRadius={set=function(bw)Q=bw end,get=function()return Q end},LowOrbitHeight={set=function(bw)R=bw end,get=function()return R end},AtmoSpeedLimit={set=function(bw)S=bw end,get=function()return S end},SpaceSpeedLimit={set=function(bw)T=bw end,get=function()return T end},AutoTakeoffAltitude={set=function(bw)U=bw end,get=function()return U end},TargetHoverHeight={set=function(bw)V=bw end,get=function()return V end},LandingGearGroundHeight={set=function(bw)W=bw end,get=function()return W end},ReEntryHeight={set=function(bw)X=bw end,get=function()return X end},MaxGameVelocity={set=function(bw)Y=bw end,get=function()return Y end},AutopilotInterplanetaryThrottle={set=function(bw)Z=bw end,get=function()return Z end},warmup={set=function(bw)_=bw end,get=function()return _ end},fuelTankHandlingAtmo={set=function(bw)a0=bw end,get=function()return a0 end},fuelTankHandlingSpace={set=function(bw)a1=bw end,get=function()return a1 end},fuelTankHandlingRocket={set=function(bw)a2=bw end,get=function()return a2 end},ContainerOptimization={set=function(bw)a3=bw end,get=function()return a3 end},FuelTankOptimization={set=function(bw)a4=bw end,get=function()return a4 end}}local e5={ResolutionX={set=function(bw)a5=bw end,get=function()return a5 end},ResolutionY={set=function(bw)a6=bw end,get=function()return a6 end},circleRad={set=function(bw)a7=bw end,get=function()return a7 end},SafeR={set=function(bw)a8=bw end,get=function()return a8 end},SafeG={set=function(bw)a9=bw end,get=function()return a9 end},SafeB={set=function(bw)aa=bw end,get=function()return aa end},PvPR={set=function(bw)ab=bw end,get=function()return ab end},PvPG={set=function(bw)ac=bw end,get=function()return ac end},PvPB={set=function(bw)ad=bw end,get=function()return ad end},centerX={set=function(bw)ae=bw end,get=function()return ae end},centerY={set=function(bw)af=bw end,get=function()return af end},throtPosX={set=function(bw)ag=bw end,get=function()return ag end},throtPosY={set=function(bw)ah=bw end,get=function()return ah end},vSpdMeterX={set=function(bw)ai=bw end,get=function()return ai end},vSpdMeterY={set=function(bw)aj=bw end,get=function()return aj end},altMeterX={set=function(bw)ak=bw end,get=function()return ak end},altMeterY={set=function(bw)al=bw end,get=function()return al end},fuelX={set=function(bw)am=bw end,get=function()return am end},fuelY={set=function(bw)an=bw end,get=function()return an end},shieldX={set=function(bw)ao=bw end,get=function()return ao end},shieldY={set=function(bw)ap=bw end,get=function()return ap end},DeadZone={set=function(bw)aq=bw end,get=function()return aq end},OrbitMapSize={set=function(bw)ar=bw end,get=function()return ar end},OrbitMapX={set=function(bw)as=bw end,get=function()return as end},OrbitMapY={set=function(bw)at=bw end,get=function()return at end},soundVolume={set=function(bw)au=bw end,get=function()return au end}}local e6={speedChangeLarge={set=function(bw)av=bw end,get=function()return av end},speedChangeSmall={set=function(bw)aw=bw end,get=function()return aw end},MouseXSensitivity={set=function(bw)ax=bw end,get=function()return ax end},MouseYSensitivity={set=function(bw)ay=bw end,get=function()return ay end},autoRollFactor={set=function(bw)az=bw end,get=function()return az end},rollSpeedFactor={set=function(bw)aA=bw end,get=function()return aA end},autoRollRollThreshold={set=function(bw)aB=bw end,get=function()return aB end},minRollVelocity={set=function(bw)aC=bw end,get=function()return aC end},TrajectoryAlignmentStrength={set=function(bw)aD=bw end,get=function()return aD end},torqueFactor={set=function(bw)aE=bw end,get=function()return aE end},pitchSpeedFactor={set=function(bw)aF=bw end,get=function()return aF end},yawSpeedFactor={set=function(bw)aG=bw end,get=function()return aG end},brakeSpeedFactor={set=function(bw)aH=bw end,get=function()return aH end},brakeFlatFactor={set=function(bw)aI=bw end,get=function()return aI end},DampingMultiplier={set=function(bw)aJ=bw end,get=function()return aJ end},apTickRate={set=function(bw)aK=bw end,get=function()return aK end},hudTickRate={set=function(bw)aL=bw end,get=function()return aL end},ExtraLongitudeTags={set=function(bw)aM=bw end,get=function()return aM end},ExtraLateralTags={set=function(bw)aN=bw end,get=function()return aN end},ExtraVerticalTags={set=function(bw)aO=bw end,get=function()return aO end}}if not e1 then dW(e2,e3)dW(e2,e4)dW(e2,e5)dW(e2,e6)return e2 elseif e1=="boolean"then return e3 elseif e1=="handling"then return e4 elseif e1=="hud"then return e5 elseif e1=="physics"then return e6 end end;local function e7(e8,e9,ea,eb,ec)if eb==nil then eb=""end;if ec==nil then ec=""end;return bA([[<text class="%s" x=%s y=%s style="%s">%s</text>]],eb,e8,e9,ec,ea)end;local function ed(ee,ef)if ee==0 then return by(ef)<1e-09 end;if ef==0 then return by(ee)<1e-09 end;return by(ee-ef)<math.max(by(ee),by(ef))*eg end;local function eh(cx,ei)local ej=cx>100000;if ei==nil then ei=1 end;if ej then return bT(cx/1000/200,ei).."SU"elseif cx<1000 then return bT(cx,ei).."M"else return bT(cx/1000,ei).."KM"end end;local function ek(el)local em=0;local en=0;local eo=0;if el<60 then el=bz(el)elseif el<3600 then em=bz(el/60)el=bz(el%60)elseif el<86400 then en=bz(el/3600)em=bz(el%3600/60)else eo=bz(el/86400)en=bz(el%86400/3600)end;if eo>0 then return eo.."d "..en.."h "elseif en>0 then return en.."h "..em.."m "elseif em>0 then return em.."m "..el.."s"elseif el>0 then return el.."s"else return"0s"end end;local function ep(eq)local function er(es)for dZ,d_ in pairs(es)do dbHud_1.setStringValue(dZ,bC(d_.get()))if eq and dbHud_2 then dbHud_2.setStringValue(dZ,bC(d_.get()))end end end;if dbHud_1 then er(bv)er(e0())a.print("Saved Variables to Datacore")if eq and dbHud_2 then ck="Databank copied.  Remove copy when ready."end end end;local function et()local function eu(ev)return type(ev)=='number'end;local function ew(ev)return type(bS(ev))=='number'end;local function ex(ey)return type(ey)=='table'end;local function ez(a)return type(a)=='string'end;local function eA(d_)return ex(d_)and eu(d_.x and d_.y and d_.z)end;local function eB(eC)return ex(eC)and eu(eC.latitude and eC.longitude and eC.altitude and eC.id and eC.systemId)end;local eD=math.pi/180;local eE=180/math.pi;local eg=1e-10;local bU=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local eF='::pos{'..bU..','..bU..','..bU..','..bU..','..bU..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function eG(ev)local eH=string.gsub(string.reverse(bA('%.4f',ev)),'^0*%.?','')return eH==''and'0'or string.reverse(eH)end;local function eI(eJ)if eA(eJ)then return bA('{x=%.3f,y=%.3f,z=%.3f}',eJ.x,eJ.y,eJ.z)end;if ex(eJ)and not getmetatable(eJ)then local eK={}local eL=next(eJ)if type(eL)=='nil'or eL==1 then eK=eJ else for dZ,d_ in pairs(eJ)do local eM=eI(d_)if type(dZ)=='number'then table.insert(eK,bA('[%s]=%s',dZ,eM))else table.insert(eK,bA('%s=%s',dZ,eM))end end end;return bA('{%s}',table.concat(eK,','))end;if ez(eJ)then return bA("'%s'",eJ:gsub("'",[[\']]))end;return tostring(eJ)end;local eN={}eN.__index=eN;eN.__tostring=function(eJ,eO)local eP={}for dZ in pairs(eJ)do table.insert(eP,dZ)end;table.sort(eP)local eK={}for eQ,dZ in ipairs(eP)do local eM=eI(eJ[dZ])if type(dZ)=='number'then table.insert(eK,bA('[%s]=%s',dZ,eM))else table.insert(eK,bA('%s=%s',dZ,eM))end end;if eO then return bA('%s%s',eO,table.concat(eK,',\n'..eO))end;return bA('{%s}',table.concat(eK,','))end;eN.__eq=function(eR,eS)return eR.systemId==eS.systemId and eR.id==eS.id and ed(eR.radius,eS.radius)and ed(eR.center.x,eS.center.x)and ed(eR.center.y,eS.center.y)and ed(eR.center.z,eS.center.z)and ed(eR.GM,eS.GM)end;local function eT(eU,eV,eW,eX,eY)assert(ew(eU),'Argument 1 (systemId) must be a number:'..type(eU))assert(ew(eV),'Argument 2 (id) must be a number:'..type(eV))assert(ew(eW),'Argument 3 (radius) must be a number:'..type(eW))assert(ex(eX),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(eX))assert(ew(eY),'Argument 5 (GM) must be a number:'..type(eY))return setmetatable({systemId=bS(eU),id=bS(eV),radius=bS(eW),center=vec3(eX),GM=bS(eY)},eN)end;local eZ={}eZ.__index=eZ;eZ.__tostring=function(dR)return bA('::pos{%d,%d,%s,%s,%s}',dR.systemId,dR.id,eG(dR.latitude*eE),eG(dR.longitude*eE),eG(dR.altitude))end;eZ.__eq=function(eR,eS)return eR.id==eS.id and eR.systemId==eS.systemId and ed(eR.latitude,eS.latitude)and ed(eR.altitude,eS.altitude)and(ed(eR.longitude,eS.longitude)or ed(eR.latitude,math.pi/2)or ed(eR.latitude,-math.pi/2))end;local function e_(f0,eV,f1,f2,f3)local eU=f0;if ez(f0)and not f2 and not f3 and not eV and not f1 then eU,eV,f1,f2,f3=bI(f0,eF)assert(eU,'Argument 1 (position string) is malformed.')else assert(ew(eU),'Argument 1 (systemId) must be a number:'..type(eU))assert(ew(eV),'Argument 2 (id) must be a number:'..type(eV))assert(ew(f1),'Argument 3 (latitude) must be in degrees:'..type(f1))assert(ew(f2),'Argument 4 (longitude) must be in degrees:'..type(f2))assert(ew(f3),'Argument 5 (altitude) must be in meters:'..type(f3))end;eU=bS(eU)eV=bS(eV)f1=bS(f1)f2=bS(f2)f3=bS(f3)if eV==0 then return setmetatable({latitude=f1,longitude=f2,altitude=f3,id=eV,systemId=eU},eZ)end;return setmetatable({latitude=eD*bK(f1,-90,90),longitude=eD*(f2%360),altitude=f3,id=eV,systemId=eU},eZ)end;local f4={}f4.__index=f4;f4.__tostring=function(eJ,eO)local f5=eO and eO..'  'local f6={}local eP={}for dZ in pairs(eJ)do table.insert(eP,dZ)end;table.sort(eP)for eQ,f7 in ipairs(eP)do f8=eJ[f7]local f9=eN.__tostring(f8,f5)if eO then table.insert(f6,bA('[%s]={\n%s\n%s}',f7,f9,eO))else table.insert(f6,bA('  [%s]=%s',f7,f9))end end;if eO then return bA('\n%s%s%s',eO,table.concat(f6,',\n'..eO),eO)end;return bA('{\n%s\n}',table.concat(f6,',\n'))end;local function fa(fb)local e={}local pid;for eQ,d_ in pairs(fb)do local eV=d_.planetarySystemId;if type(eV)~='number'then error('Invalid planetary s ID: '..tostring(eV))elseif pid and eV~=pid then error('Mistringmatch planetary s IDs: '..eV..' and '..pid)end;local fc=d_.bodyId;if type(fc)~='number'then error('Invalid body ID: '..tostring(fc))elseif e[fc]then error('Duplicate body ID: '..tostring(fc))end;setmetatable(d_.center,getmetatable(vec3.unit_x))e[fc]=setmetatable(d_,eN)pid=eV end;return setmetatable(e,f4)end;cX={}local function fd(fb)return setmetatable({galaxyAtlas=fb or{}},cX)end;cX.__index=function(ey,bw)if type(bw)=='number'then local a=ey.galaxyAtlas[bw]return fa(a)end;return rawget(cX,bw)end;cX.__pairs=function(eJ)return function(ey,dZ)local fe,ff=next(ey,dZ)return fe,ff and fa(ff)end,eJ.galaxyAtlas,nil end;cX.__tostring=function(eJ)local fg={}for eQ,fh in pairs(eJ or{})do local fi=fh:getPlanetarySystemId()local fj=f4.__tostring(fh,'    ')table.insert(fg,bA('  [%s]={%s\n  }',fi,fj))end;return bA('{\n%s\n}\n',table.concat(fg,',\n'))end;cX.BodyParameters=eT;cX.MapPosition=e_;cX.PlanetarySystem=fa;function cX.createBodyParameters(eU,eV,fk,fl,fm,fn,fo)assert(ew(eU),'Argument 1 (systemId) must be a number:'..type(eU))assert(ew(eV),'Argument 2 (id) must be a number:'..type(eV))assert(ew(fk),'Argument 3 (surfaceArea) must be a number:'..type(fk))assert(ex(fl),'Argument 4 (aPosition) must be an array or vec3:'..type(fl))assert(ex(fm),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(fm))assert(ew(fn),'Argument 6 (altitude) must be in meters:'..type(fn))assert(ew(fo),'Argument 7 (gravityAtPosition) must be number:'..type(fo))local eW=bR(fk/4/math.pi)local cx=eW+fn;local fp=vec3(fl)+cx*vec3(fm)local eY=fo*cx*cx;return eT(eU,eV,eW,fp,eY)end;cX.isMapPosition=eB;function cX:getPlanetarySystem(f0)if bw==nil then bw=0 end;if ff==nil then ff=0 end;local eU=f0;if eB(f0)then eU=f0.systemId end;if type(eU)=='number'then local a=self.galaxyAtlas[bw]if a then if getmetatable(ff)~=f4 then a=fa(a)end;return a end end end;function f4:sizeCalculator(fq)return 1.05*fq.radius end;function f4:castIntersections(fr,fs,ft,fu,fv,fw)local fx={}if fv then for eQ,fq in pairs(fv)do table.insert(fx,fq)end else fx=dO end;if not fw then table.sort(fx,function(fy,fz)local ee=fy.center;local ef=fz.center;return(ee.x-fr.x)^2+(ee.y-fr.y)^2+(ee.z-fr.z)^2<(ef.x-fr.x)^2+(ef.y-fr.y)^2+(ef.z-fr.z)^2 end)end;local fA=fs:normalize()for eQ,fq in ipairs(fx)do local fB=fq.center-fr;local eW=self:sizeCalculator(fq)local fC=fB:dot(fA)local fD=fC^2-(fB:len2()-eW^2)if fD>=0 then local fE=bR(fD)local fF=fC+fE;local fG=fC-fE;if fG>0 then return fq,fF,fG elseif fF>0 then return fq,fF,nil end end end;return nil,nil,nil end;function f4:closestBody(fH)assert(type(fH)=='table','Invalid coordinates.')local fI,fq;local fJ=vec3(fH)for eQ,fK in pairs(self)do local fL=(fK.center-fJ):len2()if(not fq or fL<fI)and fK.name~="Space"then fq=fK;fI=fL end end;return fq end;function f4:convertToBodyIdAndWorldCoordinates(f0)local fM=f0;if ez(f0)then fM=e_(f0)end;if fM.id==0 then return 0,vec3(fM.latitude,fM.longitude,fM.altitude)end;local fK=self:getBodyParameters(fM)if fK then return fM.id,fK:convertToWorldCoordinates(fM)end end;function f4:getBodyParameters(f0)local eV=f0;if eB(f0)then eV=f0.id end;assert(ew(eV),'Argument 1 (id) must be a number:'..type(eV))return self[eV]end;function f4:getPlanetarySystemId()local eQ,d_=next(self)return d_ and d_.systemId end;function eN:convertToMapPosition(eX)assert(ex(eX),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(eX))local fN=vec3(eX)if self.id==0 then return setmetatable({latitude=fN.x,longitude=fN.y,altitude=fN.z,id=0,systemId=self.systemId},eZ)end;local fO=fN-self.center;local cx=fO:len()local f3=cx-self.radius;local f1=0;local f2=0;if not ed(cx,0)then local fP=bH(fO.y,fO.x)f2=fP>=0 and fP or 2*math.pi+fP;f1=math.pi/2-math.acos(fO.z/cx)end;return setmetatable({latitude=f1,longitude=f2,altitude=f3,id=self.id,systemId=self.systemId},eZ)end;function eN:convertToWorldCoordinates(f0)local fM=ez(f0)and e_(f0)or f0;if fM.id==0 then return vec3(fM.latitude,fM.longitude,fM.altitude)end;assert(eB(fM),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(fM.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(fM.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local fQ=math.cos(fM.latitude)return self.center+(self.radius+fM.altitude)*vec3(fQ*math.cos(fM.longitude),fQ*math.sin(fM.longitude),math.sin(fM.latitude))end;function eN:getAltitude(eX)return(vec3(eX)-self.center):len()-self.radius end;function eN:getDistance(eX)return(vec3(eX)-self.center):len()end;function eN:getGravity(eX)local fR=self.center-vec3(eX)local fS=fR:len2()return self.GM/fS*fR/bR(fS)end;return setmetatable(cX,{__call=function(eQ,...)return fd(...)end})end;local function fT()local cZ={}local fU=30000000/3600;local fV=fU*fU;local fW=100;function cZ.computeAccelerationTime(fX,fY,fZ)local f_=fU*math.asin(fX/fU)return(fU*math.asin(fZ/fU)-f_)/fY end;function cZ.computeDistanceAndTime(fX,fZ,g0,g1,g2,g3)g2=g2 or 0;g3=g3 or 0;local g4=fX<=fZ;local g5=g1*(g4 and 1 or-1)/g0;local g6=-g3/g0;local g7=g5+g6;if g4 and g7<=0 or not g4 and g7>=0 then return-1,-1 end;local g8,g9=0,0;if g5~=0 and g2>0 then local f_=math.asin(fX/fU)local ga=math.pi*(g5/2+g6)local gb=g5*g2;local gc=fU*math.pi;local d_=function(ey)local gd=(ga*ey-gb*math.sin(math.pi*ey/2/g2)+gc*f_)/gc;local ge=math.tan(gd)return fU*ge/bR(ge*ge+1)end;local gf=g4 and function(a)return a>=fZ end or function(a)return a<=fZ end;g9=2*g2;if gf(d_(g9))then local gg=0;while by(g9-gg)>0.5 do local ey=(g9+gg)/2;if gf(d_(ey))then g9=ey else gg=ey end end end;local gh=fX;local gi=g9/fW;for gj=1,fW do local gk=d_(gj*gi)g8=g8+(gk+gh)*gi/2;gh=gk end;if g9<2*g2 then return g8,g9 end;fX=gh end;local f_=fU*math.asin(fX/fU)local bX=(fU*math.asin(fZ/fU)-f_)/g7;local gl=fV*math.cos(f_/fU)/g7;local cx=gl-fV*math.cos((g7*bX+f_)/fU)/g7;return cx+g8,bX+g9 end;function cZ.computeTravelTime(fX,fY,cx)if cx==0 then return 0 end;if fY>0 then local f_=fU*math.asin(fX/fU)local gl=fV*math.cos(f_/fU)/fY;return(fU*math.acos(fY*(gl-cx)/fV)-f_)/fY end;if fX==0 then return-1 end;assert(fX>0,'Acceleration and initial speed are both zero.')return cx/fX end;return cZ end;local function gm()local vec3=require('cpml.vec3')local et=et()local function ez(a)return type(a)=='string'end;local function ex(ey)return type(ey)=='table'end;gn={}gn.__index=gn;function gn:escapeAndOrbitalSpeed(f3)assert(self.body)local cx=f3+self.body.radius;if not ed(cx,0)then local go=bR(self.body.GM/cx)return bR(2)*go,go end;return nil,nil end;function gn:orbitalParameters(f0,gp)assert(self.body)assert(ex(f0)or ez(f0))assert(ex(gp))local gq=(ez(f0)or et.isMapPosition(f0))and self.body:convertToWorldCoordinates(f0)or vec3(f0)local d_=vec3(gp)local gr=gq-self.body.center;local gs=d_:len2()local gt=gr:len()local gu=self.body.GM;local gv=((gs-gu/gt)*gr-gr:dot(d_)*d_)/gu;local ee=gu/(2*gu/gt-gs)local gw=gv:len()local fA=gv:normalize()local gx=ee*(1-gw)local gy=ee*(1+gw)local gz=gx*fA+self.body.center;local gA=gw<=1 and-gy*fA+self.body.center or nil;local gB=bR(ee*gu*(1-gw*gw))local gC=gA and 2*math.pi*bR(ee^3/gu)local gD=math.acos(gv:dot(gr)/(gw*gt))if gr:dot(d_)<0 then gD=-(gD-2*math.pi)end;local gE=math.acos((math.cos(gD)+gw)/(1+gw*math.cos(gD)))local gF=gE;if gF<0 then gF=gF+2*math.pi end;local gG=gF-gw*math.sin(gF)local gH=0;local gI=0;local gJ=0;if gC~=nil then gH=gG/(2*math.pi/gC)gI=gC-gH;gJ=gI+gC/2;if gD-math.pi>0 then gI=gH;gJ=gI+gC/2 end;if gJ>gC then gJ=gJ-gC end end;return{periapsis={position=gz,speed=gB/gx,circularOrbitSpeed=bR(gu/gx),altitude=gx-self.body.radius},apoapsis=gA and{position=gA,speed=gB/gy,circularOrbitSpeed=bR(gu/gy),altitude=gy-self.body.radius},currentVelocity=d_,currentPosition=gq,eccentricity=gw,period=gC,eccentricAnomaly=gE,meanAnomaly=gG,timeToPeriapsis=gI,timeToApoapsis=gJ,trueAnomaly=gD}end;local function gK(gL)local fK=et.BodyParameters(gL.systemId,gL.id,gL.radius,gL.center,gL.GM)return setmetatable({body=fK},gn)end;return setmetatable(gn,{__call=function(eQ,...)return gK(...)end})end;local function gM()local gN={}local gO={}local gP={XS=13,S=27,M=55,L=110,XL=221}local gQ={}local gR;local gS;local gT;local gU;local gV;local gW={}local gX="Atmo"local gY;local function gZ()local function g_(h0,h1,h2,h3,h4,h5,h6,h7)h1,h3,h5,h7=vec3(h1),vec3(h3),vec3(h5),vec3(h7)local h8,h9,ha=h0*h0,h2*h2,h4*h4;local gs=h3-h1;local hb=gs:normalize()local hc=gs:len()local hd=h5-h1;local he=(hd-hd:project_on(hb)):normalize()local hf,hg=hd:dot(hb),hd:dot(he)local hh=hf*hf+hg*hg;local hi=hb:cross(he)local e8=(h8-h9+hc*hc)/(2*hc)local e9=(h8-ha+hh-2*hf*e8)/(2*hg)local eC=h8-e8^2-e9^2;local hj=bR(eC)local hk=h1+hb*e8+he*e9+hi*hj;local hl=h1+hb*e8+he*e9-hi*hj;if by((h7-hk):len()-h6)<by((h7-hl):len()-h6)then return hk else return hl end end;local function hm()local function hn()local ho=b.getConstructWorldOrientationRight()local gs=b.getConstructWorldOrientationForward()local hd=b.getConstructWorldOrientationUp()local hp=library.systemResolution3(ho,gs,hd,{1,0,0})local hq=library.systemResolution3(ho,gs,hd,{0,1,0})local hr=library.systemResolution3(ho,gs,hd,{0,0,1})return function(hs)return library.systemResolution3(hp,hq,hr,hs)end end;local ht=hn()local hu=b.getConstructWorldPos()local gq=b.getElementPositionById(1)local hv={gq[1],gq[2],gq[3]}local hw=ht(hv)local hx={hu[1]-hw[1],hu[2]-hw[2],hu[3]-hw[3]}return hx end;local function hy(hz,gt,hA)local hB=hz.pts;local hC=#hB;local hD=hz.ref;if hC>3 then local hE,hF,hG,hH=hB[hC],hB[hC-1],hB[hC-2],hB[hC-3]hz.ref=hA;local gq=g_(hE[1],hE[2],hF[1],hF[2],hG[1],hG[2],hH[1],hH[2])local e8,e9,hj=gq.x,gq.y,gq.z;if e8==e8 and e9==e9 and hj==hj then e8=e8+hD[1]e9=e9+hD[2]hj=hj+hD[3]local hI=vec3(e8,e9,hj)if not hz.lastPos then hz.center=hI elseif(hz.lastPos-hI):len()<2 then hz.center=hI;hz.skipCalc=true end;hz.lastPos=hI end;hz.pts={}else local hJ={hA[1]-hD[1],hA[2]-hD[2],hA[3]-hD[3]}hB[hC+1]={gt,hJ}end end;if radar_1 or radar_2 then d4.assignRadar()end;if gW[1]then gR=#gW[1].getConstructIds()local hK=gW[1].getData()local hL=hK:gmatch('{"constructId[^}]*}[^}]*}')if gR>0 then local hA=hm()local hM,hN=0,0;gV,gU=0,0;for d_ in hL do local eV,cx,hO=d_:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hP=gP[hO]cx=bS(cx)if gW[1].hasMatchingTransponder(eV)==1 then table.insert(gO,eV)end;local hQ=gW[1].getConstructType(eV)if F then if hP>27 or hQ=="static"or hQ=="space"then gV=gV+1;local hR=gW[1].getConstructName(eV)local hz=dF[eV]if hz==nil then hP=hP+bZ;dF[eV]={pts={},ref=hA,name=hR,i=0,radius=hP,skipCalc=false}hz=dF[eV]end;if not hz.skipCalc then hy(hz,cx,hA)hN=hN+1 end;if hz.center then table.insert(gQ,hz)end end;hM=hM+1;if dG and hM>700 or hN>70 or(not dG and hM>300 or hN>30)then coroutine.yield()hM,hN=0,0 end end end;gU=#gQ;if gU>0 and dr>20 then local fq,hS,hT,hU;local hV=0;local hW=cY:getPlanetarySystem(0)hU=dq:normalize()while hV<gU do coroutine.yield()local hX={table.unpack(gQ,hV,math.min(hV+75,gU))}fq,hS,hT=hW:castIntersections(du,hU,nil,nil,hX,true)if fq and hT then dI={fq,hS,hT}break end;hV=hV+75 end;if not fq then dI=nil end else dI=nil end;gQ={}gS=hK:find('identifiedConstructs":%[%]')else gT=hK:find('worksInEnvironment":false')end end end;local function hY()if gW[1]then gX="Atmo"if gW[1].getData():find('worksInAtmosphere":false')then gX="Space"end end end;function gN.pickType()hY()end;function gN.assignRadar()if radar_1 and gW[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gW[1]=radar_2 end;if gW[1]==radar_2 then hY()end elseif radar_2 and gW[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gW[1]=radar_1 end;if gW[1]==radar_1 then hY()end end end;function gN.UpdateRadar()local hZ=coroutine.status(gY)if hZ=="suspended"then local eM,h_=coroutine.resume(gY)if h_ then a.print("ERROR UPDATE RADAR: "..h_)end elseif hZ=="dead"then gY=coroutine.create(gZ)local eM,h_=coroutine.resume(gY)end end;function gN.GetRadarHud(i0,i1,i2,i3)local i4=gO;local i5,dS;gO={}local bU=gU or 0;if gR>0 then if F then dS=bU.."/"..gV.." Plotted : "..gR-gV.." Ignored"else dS="Radar Contacts: "..gR end;i5=e7(i2,i3,dS,"pbright txtbig txtmid")if#gO>0 then i5=i5 ..e7(i0,i1,"Friendlies In Range","pbright txtbig txtmid")for dZ,d_ in pairs(gO)do i1=i1+20;i5=i5 ..e7(i0,i1,gW[1].getConstructName(d_),"pdim txtmid")end end;if gS==nil and i6==nil then i7=1;d4.ToggleRadarPanel()end;if gS~=nil and i6~=nil then d4.ToggleRadarPanel()end;if i8==nil then d4.ToggleRadarPanel()end else if gT then i5=e7(i2,i3,gX.." Radar: Jammed","pbright txtbig txtmid")else i5=e7(i2,i3,"Radar: No "..gX.." Contacts","pbright txtbig txtmid")end;if i8~=nil then i7=0;d4.ToggleRadarPanel()end end;return i5 end;function gN.GetClosestName(hR)if gW[1]then local eV,eQ=gW[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if eV~=nil and eV~=""then hR=hR.." "..gW[1].getConstructName(eV)end end;return hR end;function gN.ToggleRadarPanel()if i8~=nil and i7==0 then bM(i8)i8=nil;if i6~=nil then bM(i6)i6=nil end else if i7==1 then bM(i8)i8=nil;_autoconf.displayCategoryPanel(gW,1,"Periscope","periscope")i6=_autoconf.panels[_autoconf.panels_size]end;if i8==nil then _autoconf.displayCategoryPanel(gW,1,"Radar","radar")i8=_autoconf.panels[_autoconf.panels_size]end;i7=0 end end;gW[1]=nil;if radar_1 then gW[1]=radar_1;hY()end;gY=coroutine.create(gZ)return gN end;local function i9()local ia=9.80665;local ib={}local ic={}local id={}local dL={}local ie=nil;local ig=nil;local ih=nil;local ii=false;local ij="none"local ik=""local il=vec3({13771471,7435803,-128971})local im=18000000;local io=500000;local ip,iq=math.huge;local ir;local function is(it)ip=vec3(it):dist(il)if ip<im then return true,by(ip-im)end;iq=vec3(it):dist(vec3(iu.center))if iq<io then ir=true else ir=false end;if by(iq-io)<by(ip-im)then return ir,by(iq-io)else return ir,by(ip-im)end end;local function iv(d_)if cQ==1920 then return d_ else return bT(cQ*d_/1920,0)end end;local function iw(d_)if cR==1080 then return d_ else return bT(cR*d_/1080,0)end end;local function ix()return bQ()==0 and g~="keyboard"and bG()==0 end;local function iy()local iz="TRAVEL"if not dy then iz="CRUISE"end;if aU then iz="AUTOPILOT"end;return iz end;local i5=""local iA=""local iB=""local iC=1;local iD=2;local iE=3;local iF=4;local iG=5;local iH=6;local iI=""local iJ=0;local iK=bz(1/aK)*2*aL;local iL={}local iM={}local iN={}local iO={}local iP={}local iQ={}local function iR(e8,iS,iT,iU,iV,iW)local iX=iY;local iZ=iY+5;if not C then iZ=iZ+5 end;if bG()==1 and not l then iX=iX-50;iZ=iZ-50 end;if iT=="ATMO"then iI="atmofueltank"elseif iT=="SPACE"then iI="spacefueltank"else iI="rocketfueltank"end;iJ=_G[iI.."_size"]if#iU>0 then for bw=1,#iU do local hR=string.sub(iU[bw][iD],1,12)local i_=0;for j0=1,iJ do if iU[bw][iD]==bB(c[iI.."_"..j0].getData()).name then i_=j0;break end end;local j1=bJ()if iV[bw]==nil or iW[bw]==nil or j1-iU[bw][iH]>iK then local j2;local j3=0;if i_~=0 then iW[bw]=bB(c[iI.."_"..i_].getData()).percentage;iV[bw]=bB(c[iI.."_"..i_].getData()).timeLeft;if iV[bw]=="n/a"then iV[bw]=0 end else j3=bF(iU[bw][iC])-iU[bw][iF]iW[bw]=bz(0.5+j3*100/iU[bw][iE])j2=iU[bw][iG]if j2<=j3 then iV[bw]=0 else iV[bw]=bz(0.5+j3/((j2-j3)/(j1-iU[bw][iH])))end;iU[bw][iG]=j3;iU[bw][iH]=j1 end end;if hR==iS then hR=bA("%s %d",iT,bw)end;if i_==0 then hR=hR.." *"end;local j4;if iV[bw]==0 then j4=""else j4=ek(iV[bw])end;if iW[bw]~=nil then local j5=bz(iW[bw]*2.55)local j6=bA("rgb(%d,%d,%d)",255-j5,j5,0)local eb=""if j4~=""and iV[bw]<120 or iW[bw]<5 then eb="red "end;local j7=bA("rgb(%d,%d,%d)",bK(bz((255-j5)/2.55),50,100),bK(bz(j5/2.55),0,50),50)local j8="rgb(196,0,255)"if iT=="ATMO"then j8="rgb(0,188,255)"elseif iT=="SPACE"then j8="rgb(239,255,0)"end;local j9=false;if ja~=j8 then j9=true end;ja=j8;if C then if j9 then iX=iX-5;iZ=iZ-5 end;iA=iA..bA([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],j7,j8,e8,iZ,j6,bz(iW[bw]*1.7+0.5)-2,e8+1,iZ+1,e8+5,iZ+14,hR,iW[bw],j4)iX=iX-22;iZ=iZ-22 else iA=iA..e7(e8,iX,hR,eb.."pdim txtfuel")iA=iA..e7(e8,iZ,bA("%d%% %s",iW[bw],j4),"pdim txtfuel","fill:"..j6)iX=iX+30;iZ=iZ+30 end end end end;iY=iX end;local function jb(jc,f3)if ai==0 and aj==0 then return end;if f3<200000 and not cE or f3 and cE then local jd=0;if by(dt)>1 then jd=45*math.log(by(dt),10)if dt<0 then jd=-jd end end;jc[#jc+1]=bA([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ai,aj,bz(dt),bz(jd))end;return jc end;local function je(jf)local jg=-ds;jf=jf-jf:project_on(jg)local jh=vec3(0,0,1)jh=jh-jh:project_on(jg)local ji=jh:cross(jg)local jd=jh:angle_between(jf)*constants.rad2deg;if jf:dot(ji)<0 then jd=360-jd end;return jd end;local function jj(jc,ae,af,jk,jl,dG)if a7==0 then return end;local jm=a7;local jn=20;local jo=bz(jk)if dG then for bw=-45,45,5 do local jp=bw;jc[#jc+1]=bA([[<g transform="rotate(%f,%d,%d)">]],jp,ae,af)jq=5;if bw%15==0 then jq=15 elseif bw%10==0 then jq=10 end;jc[#jc+1]=bA([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ae,af+jm+jn-jq,ae,af+jm+jn)end;jc[#jc+1]=e7(ae,af+jm+jn-35,jl,"pdim txt txtmid")jc[#jc+1]=e7(ae,af+jm+jn-25,jo.." deg","pdim txt txtmid")jc[#jc+1]=bA([[<g transform="rotate(%f,%d,%d)">]],-jk,ae,af)jc[#jc+1]=bA([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ae-5,af+jm+jn-20,ae+5,af+jm+jn-20,ae,af+jm+jn-15)jc[#jc+1]="</g>"end;jc[#jc+1]=[[<g style="clip-path: url(#headingClip);">]]local jr=jo;if dG then jr=je(dm)end;local js=20;local jt=bz(jr)local ju=0;local jv=af+jm+jn+20;local jw=ae;if jl~="YAW"then jv=iw(130)jw=iv(960)end;local jx=[[<path class="txttick line" d="]]local jy=bz(jt-(js+10)-jt%5+0.5)for bw=jy+70,jy,-5 do local e8=jw-(-bw*5+jr*5)if bw%10==0 then ju=10;local bU=bw;if bU==360 then bU=0 elseif bU>360 then bU=bU-360 elseif bU<0 then bU=bU+360 end;jc[#jc+1]=e7(e8,jv+15,bU,"txtmid bright")elseif bw%5==0 then ju=5 end;if ju==10 then jx=bA([[%s M %f %f v %d]],jx,e8,jv-5,ju)else jx=bA([[%s M %f %f v %d]],jx,e8,jv-2.5,ju)end end;jc[#jc+1]=jx..[["/>]]jc[#jc+1]=bA([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jw-5,jv-20,jw+5,jv-20,jw,jv-10)if I then if dG then jl="HDG"end;jc[#jc+1]=e7(iv(960),iw(100),jt.."°","dim txt txtmid size14","")jc[#jc+1]=e7(iv(960),iw(85),jl,"dim txt txtmid size20","")end;jc[#jc+1]=[[</g>]]end;local function jz(jc,jA,jk,ae,af,dG,jB,gk)if a7==0 then return end;local jm=a7;local jC=bz(jm*3/5)if jm>0 then local jD=bz(jA)local jq=0;local jx=bA([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jk,ae,af)if not cE then jx=bA([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ae,af)end;jc[#jc+1]=bA([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jm-1,ae,af)jc[#jc+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for bw=bz(jD-30-jD%5+0.5),bz(jD+30+jD%5+0.5),5 do if bw%10==0 then jq=30 elseif bw%5==0 then jq=20 end;local e9=af+-bw*5+jA*5;if jq==30 then jx=bA([[%s M %d %f h %d]],jx,ae-jC-jq,e9,jq)if cE then jc[#jc+1]=bA([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jk,ae,af,ae-jC+10,e9+4,bw)jc[#jc+1]=bA([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jk,ae,af,ae+jC-10,e9+4,bw)if bw==0 or bw==180 or bw==-180 then jc[#jc+1]=bA([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jk,ae,af,ae-jC+20,e9,jC*2-40)end else jc[#jc+1]=e7(ae-jC+10,e9,bw,"pdim txt txtmid")jc[#jc+1]=e7(ae+jC-10,e9,bw,"pdim txt txtmid")end;jx=bA([[%s M %d %f h %d]],jx,ae+jC,e9,jq)else jx=bA([[%s M %d %f h %d]],jx,ae-jC-jq,e9,jq)jx=bA([[%s M %d %f h %d]],jx,ae+jC,e9,jq)end end;jc[#jc+1]=jx..[["/>]]local jE="PITCH"if not dG then jE="REL PITCH"end;if jA>90 and not cE then jA=90-(jA-90)elseif jA<-90 and not cE then jA=-90-(jA+90)end;if jm>200 then if cE then if gk>c8 then jc[#jc+1]=e7(ae,af-15,"Yaw","pdim txt txtmid")jc[#jc+1]=e7(ae,af+20,jB,"pdim txt txtmid")end;jc[#jc+1]=bA([[<g transform="rotate(%f,%d,%d)">]],-jk,ae,af)else jc[#jc+1]=bA([[<g transform="rotate(0,%d,%d)">]],ae,af)end;jc[#jc+1]=bA([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ae-jC+25,af-5,ae-jC+20,af,ae-jC+25,af+5,ae-jC+50,af+4,jD)jc[#jc+1]=bA([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ae+jC-25,af-5,ae+jC-20,af,ae+jC-25,af+5,ae+jC-30,af+4,jD)jc[#jc+1]="</g>"end;local jF=bz(jm/3)jc[#jc+1]=bA([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ae-jF,af,jm-jF)if not cE and dG then jc[#jc+1]=bA([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jk,ae,af,ae-jC+10,af,jC*2-20)end;jc[#jc+1]="</g>"if jm<200 then if cE and gk>c8 then jc[#jc+1]=e7(ae,af-jm,jE,"pdim txt txtmid")jc[#jc+1]=e7(ae,af-jm+10,jD,"pdim txt txtmid")jc[#jc+1]=e7(ae,af-15,"Yaw","pdim txt txtmid")jc[#jc+1]=e7(ae,af+20,jB,"pdim txt txtmid")else jc[#jc+1]=e7(ae,af-jm,jE,"pdim txt txtmid")jc[#jc+1]=e7(ae,af-jm+15,jD,"pdim txt txtmid")end end end end;local function jG(jc,f3,dG)local jH=ak;local jI=al;if jH==0 and jI==0 then return end;local jJ=78;local jK=19;local jL=cC;if cC~=-1 then jc[#jc+1]=e7(jH+jJ,jI+jK+20,bA("AGL: %.1fm",cC),"pdim altsm txtend")end;if dG and(f3<200000 and not cE or f3 and cE)then table.insert(jc,bA([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jH-1,jI-4,jJ+2,jK+6,jH+1,jI-1,jJ-4,jK))local hC=0;local jM=1;local jN=0;local jO=f3<0;local jP=f3<iu.surfaceMaxAltitude;local jQ=9;if jO then jQ=0 end;local f3=by(f3)while hC<6 do local jR=11;local jS=16;local jT=9;local jU=14;local eb="altsm"if hC>2 then jS=jS+3;jR=jR+2;jU=jU+2;jT=jT-6;eb="altbig"end;if jO then eb=eb.." red"elseif jP then eb=eb.." orange"end;local jV=f3/jM%10;local jW=bz(jV)local jX=bz((jW+1)%10)local jY=jN;if hC==0 then jY=jV-jW;if jO then jY=1-jY end end;if jO and(hC==0 or jN~=0)then local jZ=jX;jX=jW;jW=jZ end;local j_=jS*(jY-1)local k0=j_+jS;local e8=jH+jT+(6-hC)*jR;local e9=jI+jU;jc[#jc+1]=e7(e8,e9+j_,jX,eb)jc[#jc+1]=e7(e8,e9+k0,jW,eb)hC=hC+1;jM=jM*10;if jW==jQ then jN=jY else jN=0 end end;table.insert(jc,[[</g></g>]])end end;local function k1(gp)local k2=-math.deg(bH(gp.y,gp.z))+180;k2=k2-90;if k2<0 then k2=360+k2 end;if k2>180 then k2=-180+k2-180 end;return-k2 end;local function k3(gp)local jr=math.deg(bH(gp.y,gp.x))-90;if jr<-180 then jr=360+jr end;return jr end;local function k4(jc,gp,gk,ae,af)if gk>5 and not cE or gk>c8 then local jm=a7;local k5=20;local k6=20;local k7=k1(gp)local k8=k3(gp)local k9=14;local ka=k9/2;local kb=-k8/k6*jm;local kc=k7/k5*jm;local e8=ae+kb;local e9=af+kc;local cx=bR(kb^2+kc^2)local kd=[[<circle
                            cx="]]..e8 ..[["
                            cy="]]..e9 ..[["
                            r="]]..ka/k9 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..e8 ..[["
                            cy="]]..e9 ..[["
                            r="]]..ka..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..e8-k9 ..[[,]]..e9 ..[[ h ]]..ka..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..e8+ka..[[,]]..e9 ..[[ h ]]..ka..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..e8 ..[[,]]..e9-k9 ..[[ v ]]..ka..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cx<jm then jc[#jc+1]=kd else local jd=bH(kc,kb)local ke=4;local kf=ae+jm*math.cos(jd)local kg=af+jm*math.sin(jd)jc[#jc+1]=bA('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jd*180/math.pi,kf,kg,kf-ke,kg-ke/2,ke*2,ke,kf+ke,kg-ke,ke,ke,-ke,ke)end;if not cE then local kh=vec3(gp)k7=k1(-kh)k8=k3(-kh)kb=-k8/k6*jm;kc=k7/k5*jm;e8=ae+kb;e9=af+kc;cx=bR(kb^2+kc^2)if cx<jm then local ki=[[<circle
                                    cx="]]..e8 ..[["
                                    cy="]]..e9 ..[["
                                    r="]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..e8 ..[[,]]..e9-k9 ..[[ v ]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..e8 ..[[,]]..e9 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..e8 ..[[,]]..e9 ..[[)" />
                                <path
                                    d="M ]]..e8-ka..[[,]]..e9 ..[[ h ]]..k9 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..e8 ..[[,]]..e9 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..e8 ..[[,]]..e9 ..[[)"/>]]jc[#jc+1]=ki end end end end;local function kj(jc,iz,kk,kl)if ag==0 and ah==0 then return end;kk=bz(kk+0.5)local iX=ah+10;local iZ=ah+20;if bG()==1 and not l then iX=55;iZ=65 end;local km="CRUISE"local c="km/h"local eM=kl;if iz=="TRAVEL"or iz=="AUTOPILOT"then km="THROT"c="%"eM=kk;local kn="dim"if kk<0 then kn="red"end;jc[#jc+1]=bA([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kn,ag-7,ah-50,ag,ah-50,ag,ah+50,ag-7,ah+50,1-by(kk),ag-10,ah+50,ag-15,ah+53,ag-15,ah+47)end;jc[#jc+1]=e7(ag+10,iX,km,"pbright txtstart")jc[#jc+1]=e7(ag+10,iZ,bA("%.0f %s",eM,c),"pbright txtstart")if cE and u and dy and c4 then kk=bz(c5*100+0.5)local kn="red"if kk<0 then kn="red"end;jc[#jc+1]=bA([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kn,1-by(kk),ag-10,ah+50,ag-15,ah+53,ag-15,ah+47)jc[#jc+1]=e7(ag+10,iX+40,"LIMIT","pbright txtstart")jc[#jc+1]=e7(ag+10,iZ+40,kk.."%","pbright txtstart")end;if cE and u or aZ then jc[#jc+1]=e7(ag+10,iX-40,"LIMIT: "..dc.." km/h","dim txtstart")elseif not cE and aU then jc[#jc+1]=e7(ag+10,iX-40,"LIMIT: "..bz(Y*3.6+0.5).." km/h","dim txtstart")end end;local function ko(jc,kp)if ag==0 and ah==0 then return end;local kq=ah-10;local kr=ag+10;jc[#jc+1]=e7(0,0,"","pdim txt txtend")if bG()==1 and not l then kq=75 end;jc[#jc+1]=e7(kr,kq,bz(kp).." km/h","pbright txtbig txtstart")end;local function ks(jc)jc[#jc+1]=e7(iv(1900),iw(1070),bA("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jc[#jc+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jc[#jc+1]=e7(iv(960),iw(550),"Warning: Invalid Control Scheme Detected","warnings")jc[#jc+1]=e7(iv(960),iw(600),"Keyboard Scheme must be selected","warnings")jc[#jc+1]=e7(iv(960),iw(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kt=iv(960)local ku=iw(860)local kv=iw(880)local kw=iw(900)local kx=iw(960)local ky=iw(200)local kz=iw(250)local kA=iw(960)if bG()==1 and not l then ku=iw(135)kv=iw(155)kw=iw(175)ky=iw(115)kz=iw(95)end;local kB="#222222"local kC="white"local kD="dimmer"local kE="pbright"local kF="#110000"local kG=kB;local kH=kD;if aR then jc[#jc+1]=e7(kt,ku,"Brake Engaged","warnings")kF="#440000"kG=kC;kH=kE elseif c3>0 then jc[#jc+1]=e7(kt,ku,"Auto-Brake Engaged","warnings","opacity:"..c3)end;local kI="#110000"local kJ=kB;local kK=kD;if cE and da and cC==-1 then if not aU and not bg and not aX and not dw and not a_ and not aY then jc[#jc+1]=e7(kt,ky+50,"** STALL WARNING **","warnings")kI="#ff0000"kJ=kC;kK=kE;dT("stall","SW",2)end end;if dE then jc[#jc+1]=e7(kt,ky+90,"Flight Assist in Progress","warnings")end;if cL then jc[#jc+1]=e7(kt,kA,"Gyro Enabled","warnings")end;local kL="#111100"local kM=kB;local kN=kD;if bc then kL="#775500"kM=kC;kN=kE;if ca then jc[#jc+1]=e7(kt,kv,"Gear Extended","warn")else jc[#jc+1]=e7(kt,kv,"Landed (G: Takeoff)","warnings")end;local kO=eh(d:getTargetGroundAltitude())jc[#jc+1]=e7(kt,kw,"Hover Height: "..kO,"warn")end;local kP="#000011"local kQ=kB;local kR=kD;if cl then kP="#0000DD"kQ=kC;kR=kE;jc[#jc+1]=e7(kt,kx+20,"ROCKET BOOST ENABLED","warn")end;local kS="#001100"local kT=kB;local kU=kD;if antigrav and not q and dw and bl~=nil then kS="#00DD00"kT=kC;kU=kE;if by(cG-antigrav.getBaseAltitude())<501 then jc[#jc+1]=e7(kt,ky+15,bA("Target Altitude: %d Singularity Altitude: %d",bz(bl),bz(antigrav.getBaseAltitude())),"warn")else jc[#jc+1]=e7(kt,ky+15,bA("Target Altitude: %d Singluarity Altitude: %d",bz(bl),bz(antigrav.getBaseAltitude())),"warnings")end elseif aU and b9~="None"then jc[#jc+1]=e7(kt,ky+20,"Autopilot "..b6,"warn")elseif bj~=nil then jc[#jc+1]=e7(kt,ky+20,bA("LockedPitch: %d",bz(bj)),"warn")elseif ci then jc[#jc+1]=e7(kt,ky+20,"Follow Mode Engaged","warn")elseif aZ or cB then jc[#jc+1]=e7(kt,ky+20,"Re-entry in Progress","warn")end;if aW or a_ then local kO=eh(b0,2)if a_ then if dw then kO=eh(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jc[#jc+1]=e7(kt,ky,"VTO to "..kO,"warn")elseif aY and not bp then if cA then jc[#jc+1]=e7(kt,ky,"Takeoff to "..b9,"warn")else jc[#jc+1]=e7(kt,ky,"Takeoff to "..kO,"warn")end;if aR and not a_ then jc[#jc+1]=e7(kt,ky+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jc[#jc+1]=e7(kt,ky,"Altitude Hold: "..kO,"warn")end end;if a_ and(antigrav~=nil and antigrav)then if cF>0.1 then jc[#jc+1]=e7(kt,ky+20,"Beginning ascent","warn")elseif cF<0.09 and cF>0.05 then jc[#jc+1]=e7(kt,ky+20,"Aligning trajectory","warn")elseif cF<0.05 then jc[#jc+1]=e7(kt,ky+20,"Leaving atmosphere","warn")end end;if bp then if de~=nil then jc[#jc+1]=e7(kt,ky,de,"warn")end end;if aX then if kV then jc[#jc+1]=e7(kt,ky,"Brake-Landing","warnings")else jc[#jc+1]=e7(kt,ky,"Coast-Landing","warnings")end end;if aT then jc[#jc+1]=e7(kt,ky,"Prograde Alignment","crit")end;if aS then jc[#jc+1]=e7(kt,ky,"Retrograde Alignment","crit")end;local kW="#110000"local kX=kB;local kY=kD;if dH then kW="#FF0000"kX=kC;kY=kE;local type;if string.find(dH,"COLLISION")then type="warnings"else type="crit"end;jc[#jc+1]=e7(kt,kz+20,dH,type)elseif cF==0 then local kZ,k_=d3.checkLOS(dq:normalize())if k_~=nil then kY=kE;kW="#FF0000"kX=kC;local kO=eh(k_)local l0=cZ.computeTravelTime(dr,0,k_)local l1="Collision"if kZ.noAtmosphericDensityAltitude>0 then l1="Atmosphere"end;jc[#jc+1]=e7(kt,kz+20,kZ.name.." "..l1 .." "..ek(l0).." In "..kO,"crit")end end;if bg and not bp then jc[#jc+1]=e7(kt,ky+35,l2,"warn")end;local l3="#111100"local l4=kB;local l5=kD;if dM and#dM>1 then l3="#DDDD00"l4=kC;l5=kE end;local l6=iv;local l7=iw;local kD="topButton"local l8="topButtonActive"local l9=kD;if aU or bg or cA or bp then l9=l8 end;local la=kD;if aT then la=l8 end;local lb=kD;if aX or bc then lb=l8 end;local lc=kD;if aW or bg then lc=l8 end;local ld=kD;if aS then ld=l8 end;local le=kD;if bp or dh and aU then le=l8 end;if x and I then local lf=l7(30)jc[#jc+1]=bA([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],l9,l6(960),l7(54),l7(-53),l6(-120),l6(25),l7(50))jc[#jc+1]=e7(l6(910),lf,"AUTOPILOT")jc[#jc+1]=bA([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],la,l6(865),l7(51),l6(-25),l7(-50),l6(-110),l6(25),l7(46))jc[#jc+1]=e7(l6(800),lf,"PROGRADE")jc[#jc+1]=bA([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lb,l6(755),l7(47),l6(-25),l7(-46),l6(-98),l6(44),l7(44))jc[#jc+1]=e7(l6(700),lf,"LAND")jc[#jc+1]=bA([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lc,l6(960),l7(54),l7(-53),l6(120),l6(-25),l7(50))jc[#jc+1]=e7(l6(1010),lf,"ALT HOLD")jc[#jc+1]=bA([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ld,l6(1055),l7(51),l6(25),l7(-50),l6(110),l6(-25),l7(46))jc[#jc+1]=e7(l6(1122),lf,"RETROGRADE")jc[#jc+1]=bA([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],le,l6(1165),l7(47),l6(25),l7(-46),l6(98),l6(-44),l7(44))jc[#jc+1]=e7(l6(1220),lf,"ORBIT")jc[#jc+1]=[[
                                    </g>
                                </g>]]jc[#jc+1]="</g>"end;return jc end;local function lg(gk)return bz(bT(gk*3.6,0)+0.5).." km/h"end;local function lh(hC)local hR=b9;if hC~=nil and type(hC)=="number"then if hC==0 then return"None"end;hR=dB[hC].name end;if hR==nil then hR=li.name end;if hR==nil then hR="None"end;return hR end;local function lj(jc)local lk=d3.routeWP(true)if not lk or#lk==0 then return end;local e8=iv(750)local e9=iw(360)if aU or bg then jc[#jc+1]=e7(e8,e9,"REMAINING ROUTE","pdim txtstart size20")else jc[#jc+1]=e7(e8,e9,"LOADED ROUTE","pdim txtstart size20")end;for dZ,bw in pairs(lk)do e9=e9+20;jc[#jc+1]=e7(e8,e9,dZ..". "..lh(lk[dZ]),"pdim txtstart size20")end end;local function ll(jc)local e8=as+10;local e9=at+20;local lm={}local ln={"Alt-4: AutoTakeoff to Target"}local lo={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lp={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local lq={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(lm,"--------------DYNAMIC-----------------")if cE then if cC~=-1 then dW(lm,ln)if cq and iu and cq.name==iu.name then table.insert(lm,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aQ then if antigrav then if dw then table.insert(lm,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lm,"Turn on AGG to takeoff to AGG Height")end end;if aQ then table.insert(lm,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lm,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lm,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bc then table.insert(lm,"G: Takeoff to hover height, raise gear")else table.insert(lm,"G: Lowergear and Land")end else dW(lm,lo)table.insert(lm,"G: Begin BrakeLanding or Land")end;if a_ then table.insert(lm,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else dW(lm,lp)if lr then table.insert(lm,"Alt-Shift-5: Toggle shield off and on")table.insert(lm,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(lm,"Alt-9: Activate Gyroscope")end;if aN~="none"or aM~="none"or aO~="none"then table.insert(lm,"Alt-Shift-9: Cycles engines with Extra tags")end;if aW then table.insert(lm,"Alt-Spacebar/C will raise/lower target height")table.insert(lm,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not cE then table.insert(lm,"LALT+Mousewheel will lower/raise speed limit")end;dW(lm,lq)for bw=1,#lm do e9=e9+12;jc[#jc+1]=e7(e8,e9,lm[bw],"pdim txtbig txtstart")end end;local function ls(jc)local lt=as;local lu=at;local lv=ar;local lw=4;local lx=15;local e8=0;local e9=0;local ly,lz,lA,lB;local lC;local function lD(type)local lE,bX,gk,lF,eb,lG;if type=="Periapsis"then lE=lC.periapsis.altitude;bX=lC.timeToPeriapsis;gk=lC.periapsis.speed;eb="txtend"lF=12;lG=math.min(e8,lt+lv-iu.radius/lA-lw*2)else lE=lC.apoapsis.altitude;bX=lC.timeToApoapsis;gk=lC.apoapsis.speed;lF=-12;eb="txtstart"lG=e8 end;if dr<1 then bX=0 end;jc[#jc+1]=bA([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lG+lF,e9-5,e8,e9-5)jc[#jc+1]=bA([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lG-lF*4,e9+2,e8,e9+2)jc[#jc+1]=e7(lG,e9,type,eb)e8=lG-lF*2;e9=e9+lx;local kO=eh(lE)jc[#jc+1]=e7(e8,e9,kO,eb)e9=e9+lx;jc[#jc+1]=e7(e8,e9,ek(bX),eb)e9=e9+lx;jc[#jc+1]=e7(e8,e9,lg(gk),eb)end;local lH=lv*1.5;if bx=="INFO"then lH=25*7 end;if bx~="HIDE"then jc[#jc+1]=[[<g class="pbright txtorb txtmid">]]jc[#jc+1]=bA('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lv*2,lH,lt,lu)jc[#jc+1]=bA([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lv*2,lH,lt,lu)end;local lI=lv*1.5;local lJ=lv*2;local lK=lI/2;local lL=lv;local lM=lt+lL;local lN=lu+lK;local lO=lt+lJ;local lP=lu+lI;if bx=="ORBIT"then lu=lu+lw;ly=lv/2;lB=0;lC={}lC.periapsis={}lC.apoapsis={}if go~=nil then if go.periapsis~=nil then lC.periapsis.altitude=go.periapsis.altitude;lC.periapsis.speed=go.periapsis.speed end;if go.apoapsis~=nil then lC.apoapsis.altitude=go.apoapsis.altitude;lC.apoapsis.speed=go.apoapsis.speed end;lC.period=go.period;lC.eccentricity=go.eccentricity;lC.timeToApoapsis=go.timeToApoapsis;lC.timeToPeriapsis=go.timeToPeriapsis;lC.eccentricAnomaly=go.eccentricAnomaly;lC.trueAnomaly=go.trueAnomaly end;if lC.periapsis==nil then lC.periapsis={}lC.periapsis.altitude=-iu.radius;lC.periapsis.speed=Y end;if lC.eccentricity==nil then lC.eccentricity=1 end;if lC.apoapsis==nil then lC.apoapsis={}lC.apoapsis.altitude=cG;lC.apoapsis.speed=0 end;if dr<1 then lC.apoapsis.altitude=cG;lC.apoapsis.speed=0 end;if lC.apoapsis.altitude then lA=(lC.apoapsis.altitude+lC.periapsis.altitude+iu.radius*2)/(ly*2)lz=(iu.radius+lC.apoapsis.altitude)/lA*(1-lC.eccentricity)lB=ly-lC.periapsis.altitude/lA-iu.radius/lA;local lQ=math.pi;if lC.period~=nil and lC.period>0 and lC.timeToApoapsis~=nil then lQ=lC.eccentricAnomaly;if lC.timeToPeriapsis<lC.timeToApoapsis then lQ=2*math.pi-lQ end end;if dr<1 or lQ~=lQ then lQ=math.pi end;local lR=-ly*math.cos(lQ)+lt+lL+lw;local lS=lz*math.sin(lQ)+lu+lK+lw;local lT=""jc[#jc+1]='<g clip-path="url(#orbitRect)">'jc[#jc+1]=bA([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],lT,lt+lv+lw,lu+lv*1.5/2+lw,ly,lz)if lz<1 then jc[#jc+1]=bA([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lt+lv+lw-lB,lu+lv*1.5/2+lw,lR,lS)end;jc[#jc+1]=bA('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lt+lv+lw-lB,lu+lv*1.5/2+lw,(iu.radius+iu.noAtmosphericDensityAltitude)/lA)jc[#jc+1]=bA('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lt+lv+lw-lB,lu+lv*1.5/2+lw,(iu.radius+iu.noAtmosphericDensityAltitude)/lA)jc[#jc+1]=bA([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lt+lv+lw,lu+lv*1.5/2+lw,ly,lz)jc[#jc+1]=bA('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lt+lv+lw-lB,lu+lv*1.5/2+lw,iu.radius/lA)jc[#jc+1]='</g>'local lU=math.floor(iu.radius/lA+0.5)e8=lt+lv+lw*4+ly;e9=lu+lv*1.5/2+5+lw;if lC.apoapsis~=nil and lC.apoapsis.speed<Y then lD("Apoapsis")end;e9=lu+lv*1.5/2+5+lw;e8=lt+lv-lw*2-ly;if lC.periapsis~=nil and lC.periapsis.speed<Y and lC.periapsis.altitude>0 then lD("Periapsis")end;jc[#jc+1]=e7(lt+lv+lw,lu+20+lw,iu.name,"txtorbbig")jc[#jc+1]=bA('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',lR,lS)jc[#jc+1]=[[</g>]]return jc else jc[#jc+1]='<g clip-path="url(#orbitRect)">'local lV=""local lW=1.2*(lX-lY)/(lv*2)local lZ=1.4*(l_-m0)/(lv*1.5)for dZ,d_ in pairs(e[0])do if d_.center then local e8=lt+lv+d_.center.x/lW;local e9=lu+lv*1.5/2+d_.center.y/lZ;lV=lV..'<circle cx="'..e8 ..'" cy="'..e9 ..'" r="'..d_.radius/lW*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(d_.name,"Moon")and not string.match(d_.name,"Sanctuary")and not string.match(d_.name,"Space")then lV=lV.."<text x='"..e8 .."' y='"..e9+d_.radius/lW*30+20 .."' font-size='12' fill="..cM.." text-anchor='middle' font-family='Montserrat'>"..d_.name.."</text>"end end end;local gq=vec3(b.getConstructWorldPos())local e8=lt+lv+gq.x/lW;local e9=lu+lv*1.5/2+gq.y/lZ;lV=lV..'<circle cx="'..e8 ..'" cy="'..e9 ..'" r="2" stroke="white" stroke-width="1" fill="red"/>'lV=lV.."<text x='"..e8 .."' y='"..e9-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ie=lW;ig=lZ;local m1=gq+dq*1000000;local m2=lt+lv+m1.x/lW;local iZ=lu+lv*1.5/2+m1.y/lZ;lV=lV..'<line x1="'..e8 ..'" y1="'..e9 ..'" x2="'..m2 ..'" y2="'..iZ..'" stroke="purple" stroke-width="1"/>'jc[#jc+1]=lV;jc[#jc+1]='</g>'end elseif bx=="INFO"then jc=d1.DrawOdometer(jc,cr,bd,cs)elseif bx=="HELP"then jc=ll(jc)elseif bx=="SCOPE"then jc[#jc+1]='<g clip-path="url(#orbitRect)">'local m3=dP;if cF>0 then table.sort(dO,function(fy,fz)local ee,ef=fy.center,fz.center;return(ee.x-du.x)^2+(ee.y-du.y)^2+(ee.z-du.z)^2<(ef.x-du.x)^2+(ef.y-du.y)^2+(ef.z-du.z)^2 end)end;local gT={}local m4={}local m5=120;local m6=nil;local m7=nil;for bw,d_ in ipairs(dO)do local gS=d_.center-du;local m8=gS:len()local m9=gS:normalize()local ma=gS:cross(dm):normalize()local mb=math.acos(ma:dot(dn))if mb~=mb then mb=0 end;if ma:cross(dn):dot(dm)<0 then mb=-mb end;local mc=gS:project_on_plane(dm):len()local md=math.sin(mb)*math.asin(mc/m8)*constants.rad2deg;local me=math.cos(mb)*math.asin(mc/m8)*constants.rad2deg;if m9:dot(dm)<0 then me=90*math.cos(mb)+90*math.cos(mb)-me;md=90*math.sin(mb)+90*math.sin(mb)-md end;local e8=lM+md/m3*lI;local e9=lN+me/m3*lI;local mf=(e8-lM)*(e8-lM)+(e9-lN)*(e9-lN)local mg=math.asin((d_.radius+d_.surfaceMaxAltitude)/m8)*constants.rad2deg;if mg~=mg then mg=m3 end;local hO=mg/m3*lI;local mh=math.asin(d_.atmosphereRadius/m8)*constants.rad2deg;if mh~=mh then mh=mg end;local mi=mh/m3*lI;local cx=eh(m8,1)local mj=d_.name;local mk=false;if e9>lu then if e9>lP then if e9-mi<=lP then mk=true end else mk=true end else if e9+mi>=lu then mk=true end end;local ml=false;local mm=e8;if d_.systemId==0 then mm=e8+m5 else mm=e8-m5 end;if mm+m5>lt then if mm+m5>lO then if mm-mi-m5<=lO then ml=true end else ml=true end else if mm+mi+m5>=lt then ml=true end end;local mn={}mn.x=e8;mn.y=e9;mn.planet=d_;mn.atmoSize=mi;if not m6 or mf<m6 then m6=mf;m7=mn end;if ml and mk then local mo=math.max(mi,5)if mf<mo*mo then mj=mj.." - "..cx end;mn.size=hO;mn.i=bw;mn.displayString=mj;mn.distance=cx;mn.visible=true;m4[#m4+1]=mn else mn.visible=false end end;local mp=false;table.sort(m4,function(ee,ef)return ee.y<ef.y end)for dZ,gt in ipairs(m4)do local d_,hO,bw,mi,e8,e9,mj,cx=gt.planet,gt.size,gt.i,gt.atmoSize,gt.x,gt.y,gt.displayString,gt.distance;local lG,mq,mr,ms;local mt=15;local eb="pdim"if d_.systemId~=0 then mr=iv(string.len(mj)*5)mt=-(15+mr)ms=iw(10)eb="pdimfill"else mr=iv(string.len(mj)*9)ms=iw(15)end;if hO*2>mr then lG=bK(e8,lt+mr/2,lO-mr/2)mq=bK(e9,lu+ms,lP-5)lG=bK(lG,e8-hO+mr/2,e8+hO-mr/2)mq=bK(mq,e9-hO+ms,e9+hO)else lG=e8+mt;mq=e9 end;for mu,gt in pairs(gT)do local mv=gt.textPositions;local mw=mv.y-mq;if mu~=bw and by(mw)<mv.height and mv.x+mv.width>lG and mv.x<lG+mr then if hO>mr then mq=bK(mq+ms,lu+15,lP-5)else mq=mv.y+mv.height+1 end end end;local mx=mj~=d_.name or lG<=lM and lG+mr>=lM and mq-ms<=lN and mq>=lN;gt.hovered=mx;local my=1;if mx then my=2;if hO*2<mr then my=10 end;if mj==d_.name then mj=mj.." - "..cx end;eb="pbright"if d_.systemId~=0 then mr=iv(string.len(mj)*5)mt=-(15+mr)else mr=iv(string.len(mj)*7)end;if hO*2>mr then lG=bK(e8,lt+mr/2,lO-mr/2)lG=bK(lG,e8-hO+mr/2,e8+hO-mr/2)else lG=e8+mt end end;gT[bw]={}gT[bw].textPositions={}gT[bw].textPositions.y=mq;gT[bw].textPositions.x=lG;gT[bw].textPositions.width=mr;gT[bw].textPositions.height=ms;gT[bw].output=""if hO*2>mr then eb=eb.." txtmid"else eb=eb.." txtstart"end;if mi-hO>2 then gT[bw].output=bA('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',e8,e9,mi,cN,0.1*my)end;gT[bw].output=gT[bw].output..bA('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',e8,e9,hO,cN,0.2*my)if d_.systemId==0 then gT[bw].output=gT[bw].output..bA([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lG,mq,cM,eb,mj)if hO*2<=mr then gT[bw].output=gT[bw].output..bA("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lG+mr,mq+2,lG,mq+2,e8,e9)end else gT[bw].output=gT[bw].output..bA([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lG,mq,cN,eb,mj)if hO*2<=mr then gT[bw].output=gT[bw].output..bA("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lG,mq+2,lG+mr,mq+2,e8,e9)end end end;for dZ=#dO,1,-1 do if gT[dZ]then jc[#jc+1]=gT[dZ].output end end;if m7~=nil and dP<90 and not m7.hovered then local mz=m7.planet.atmosphereRadius/m7.atmoSize;local mA=bR(m6)*mz;local mB=eh(mA,1)local mr=iv(math.max(string.len(mB)*7,string.len(m7.planet.name)*7))local ms=iw(12)local lG=bK(m7.x+(lM-m7.x)/2,lt+mr/2,lO-mr/2)local mq=bK(m7.y+(lN-m7.y)/2,lu+ms*2,lP-5)jc[#jc+1]=bA("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",m7.x,m7.y,lM,lN)jc[#jc+1]=bA([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lG,mq,"white",mB)if not m7.visible then jc[#jc+1]=bA([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lG,mq-ms,"white",m7.planet.name)end end;if dr>1 then local gS=dq;local m9=gS:normalize()local mc=gS:project_on_plane(dm):len()local ma=gS:cross(dm):normalize()local mb=math.acos(ma:dot(dn))if mb~=mb then mb=0 end;if ma:cross(dn):dot(dm)<0 then mb=-mb end;local md=math.sin(mb)*math.asin(mc/gS:len())*constants.rad2deg;local me=math.cos(mb)*math.asin(mc/gS:len())*constants.rad2deg;if m9:dot(dm)<0 then me=90*math.cos(mb)+90*math.cos(mb)-me;md=90*math.sin(mb)+90*math.sin(mb)-md end;local e8=lM+md/m3*lI;local e9=lN+me/m3*lI;local k9=14;local ka=k9/2;local kd=[[<circle
                                    cx="]]..e8 ..[["
                                    cy="]]..e9 ..[["
                                    r="]]..ka/k9 ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..e8 ..[["
                                    cy="]]..e9 ..[["
                                    r="]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..e8-k9 ..[[,]]..e9 ..[[ h ]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..e8+ka..[[,]]..e9 ..[[ h ]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..e8 ..[[,]]..e9-k9 ..[[ v ]]..ka..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jc[#jc+1]=kd end;jc[#jc+1]=bA("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lM,lN-10,lM,lN+10)jc[#jc+1]=bA("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lM-10,lN,lM+10,lN)jc[#jc+1]='</g>'else return jc end end;local function mC(mD,mE)local mF;local mG=(mE-mD):normalize()local gr=(du-mD):dot(mG)/mG:dot(mG)if gr<=0. then return(du-mD):len()elseif gr>=(mE-mD):len()then return(du-mE):len()end;local mH=mD+gr*mG;mF=(mH-du):len()return mF end;local function mI()local mF;local mJ=nil;local mK=nil;local mL=nil;for dZ,mM in pairs(e[0])do if mM.hasAtmosphere then local cx=mC(iu.center,mM.center)if mJ==nil or cx<mJ then mK=mM;mJ=cx;mL=iu end;if cq and cq.hasAtmosphere and cq.name~=iu.name then local fL=mC(cq.center,mM.center)if fL<mJ then mK=mM;mJ=fL;mL=cq end end end end;local mN=iv(1770)local mO=iw(330)if mJ then local mP="txttick "local mQ=500000;if mJ<mK.radius+mQ or mJ<mL.radius+mQ then if dC then mP="txttick red "else mP="txttick orange "end end;mF=eh(mJ,2)ik=e7(mN,mO,"Pipe ("..mL.name.."--"..mK.name.."): "..mF,mP.."pbright txtmid")end end;local function mR(e8,e9,mS,mT,km)local mU={x=e8,y=e9,width=mS,height=mT,label=km}dL[km]=mU;return mU end;local function mV(mW,mX,mS,mT,e8,e9,mY,mZ,m_,n0,eb)local mU={enableName=mW,disableName=mX,width=mS,height=mT,x=e8,y=e9,toggleVar=mY,toggleFunction=mZ,drawCondition=m_,hovered=false,class=eb}if n0 then table.insert(id,mU)else table.insert(ic,mU)end;return mU end;local function n1(n2)if not ii then n3=false;n4=false;n5=false;x=true;return elseif n2=="handling"then n3=not n3;n4=false;n5=false elseif n2=="hud"then n4=not n4;n3=false;n5=false elseif n2=="physics"then n5=not n5;n3=false;n4=false end;if n5 or n4 or n3 then ij=e0(n2)x=false else ij="none"x=true end end;local function n6()ii=not ii;if ii then ib=id;ck="Hold SHIFT to see Settings"dQ=x else ib=ic;ck="Hold SHIFT to see Control Buttons"n1()x=dQ end end;local function n7()local function n8(d_,dZ)d_.set(not d_.get())if d_.get()then ck=dZ.." set to true"else ck=dZ.." set to false"end;if dZ=="showHud"then dQ=d_.get()elseif dZ=="BrakeToggleDefault"then aP=j end end;local n9=50;local na=340;local e8=500;local e9=cR/2-400;local nb=0;for dZ,d_ in pairs(e0("boolean"))do if type(d_.get())=="boolean"then mV(dZ,dZ,na,n9,e8,e9,function()return d_.get()end,function()n8(d_,dZ)end,function()return true end,true)e9=e9+n9+20;if nb==9 then e8=e8+na+20;e9=cR/2-400;nb=0 else nb=nb+1 end end end;mV("Control View","Control View",na,n9,10,cR/2-500,function()return true end,n6,function()return true end,true)mV("View Handling Settings",'Hide Handling Settings',na,n9,10,cR/2-(500-n9),function()return n3 end,function()n1("handling")end,function()return true end,true)mV("View Hud Settings",'Hide Hud Settings',na,n9,10,cR/2-(500-n9*2),function()return n4 end,function()n1("hud")end,function()return true end,true)mV("View Physics Settings",'Hide Physics Settings',na,n9,10,cR/2-(500-n9*3),function()return n5 end,function()n1("physics")end,function()return true end,true)end;local function nc()local function nd()local ne=du;local hR=iu.name..". "..#bf;if radar_1 then hR=d4.GetClosestName(hR)end;return d2.AddNewLocation(hR,ne,false,true)end;local function nf()aV=not aV end;local function ng(nh)if nh==1 then aT=not aT;aS=false else aS=not aS;aT=false end;aU=false;aW=false;ci=false;aX=false;bj=nil;aZ=false;aY=false end;local function ni()d2.UpdatePosition()end;local function nj()d2.ClearCurrentPosition()end;local function nk(hC)local lk=d3.routeWP(true)if lk and#lk>0 then return"Engage Route: "..lh(lk[1])end;return"Engage Autopilot: "..lh(hC)end;local function nl(hC)local lk=d3.routeWP(true)if lk and#lk>0 then return"Next Route Point: "..lh(lk[1])end;return"Disable Autopilot: "..lh(hC)end;local function nm()if bG()==1 then ci=not ci;if ci then aU=false;aS=false;aT=false;aW=false;aZ=false;aX=false;aY=false;nn=bc;bc=false;d.control.retractLandingGears()bL:setTargetGroundAltitude(V)dT("folOn","F")else dT("folOff","F")aR=true;d8=p;bc=nn;if bc then d.control.extendLandingGears()bL:setTargetGroundAltitude(W)end end else ck="Follow Mode only works with Remote controller"ci=false end end;local n9=50;local na=260;local no=iv(30)local np=as+ar*2+2;local nq=at+1;mV("+","+",no,no,np,nq+no+1,function()return false end,function()dP=dP/8 end,function()return bx=="SCOPE"end,nil,"ZoomButton")mV("-","-",no,no,np,nq,function()return false end,function()dP=math.min(dP*8,90)end,function()return bx=="SCOPE"end,nil,"ZoomButton")mV("0","0",no,no,np,nq+no*2+2,function()return false end,function()dP=90 end,function()return bx=="SCOPE"and dP~=90 end,nil,"ZoomButton")local nr=mV("Enable Brake Toggle","Disable Brake Toggle",na,n9,cQ/2-na/2,cR/2+350,function()return aP end,function()aP=not aP;if aP then ck="Brakes in Toggle Mode"else ck="Brakes in Default Mode"end end)mV("Align Prograde","Disable Prograde",na,n9,cQ/2-na/2-50-nr.width,cR/2-n9+380,function()return aT end,function()ng(1)end)mV("Align Retrograde","Disable Retrograde",na,n9,cQ/2-na/2+nr.width+50,cR/2-n9+380,function()return aS end,ng,function()return cF==0 end)ns=mV(nk,nl,600,60,cQ/2-600/2,cR/2-60/2-330,function()return aU or bg or cA or bp end,function()end)local bw;local function nt(nu)local lk=d3.routeWP(true)if lk and#lk>0 then return lk[1]end;local hC=dK+nu;if hC>#dB then hC=hC-#dB-1 end;if hC<0 then hC=#dB+hC end;return hC end;nv={}for bw=0,10 do local nw=mV(function(ef)local hC=nt(ef.apExtraIndex)if aU or bg or cA or bp then return"Redirect: "..lh(hC)end;return nk(hC)end,function(ef)local hC=nt(ef.apExtraIndex)return nl(hC)end,600,60,cQ/2-600/2,cR/2-60/2-330+60*bw,function(ef)local hC=nt(ef.apExtraIndex)return hC==bb and(aU or bg or cA or bp)end,function(ef)local hC=nt(ef.apExtraIndex)local nx=bb==hC;bb=hC;d2.UpdateAutopilotTarget()d3.ToggleAutopilot()if not nx and not(aU or bg or cA or bp)then d3.ToggleAutopilot()end end,function()return dJ and(#d3.routeWP(true)==0 or bw==0)end)nw.apExtraIndex=bw;nv[bw]=nw end;mV("Save Position","Save Position",200,ns.height,ns.x+ns.width+30,ns.y,function()return false end,nd,function()return bb==0 or li==nil end)mV("Update Position","Update Position",200,ns.height,ns.x+ns.width+30,ns.y,function()return false end,ni,function()return bb>0 and li~=nil end)mV("Clear Position","Clear Position",200,ns.height,ns.x-200-30,ns.y,function()return true end,nj,function()return bb>0 and li~=nil end)mV("Save Route","Save Route",200,ns.height,ns.x+ns.width+30,ns.y+ns.height+20,function()return false end,function()d3.routeWP(false,false,2)end,function()return#d3.routeWP(true)>0 end)mV("Load Route","Clear Route",200,ns.height,ns.x-200-30,ns.y+ns.height+20,function()return#d3.routeWP(true)>0 end,function()if#d3.routeWP(true)>0 then d3.routeWP(false,true)elseif aU or bg then ck="Disable Autopilot before loading route"return else d3.routeWP(false,false,1)end end,function()return true end)n9=60;na=300;local e8=0;local e9=cR/2-150;mV("View Settings","View Settings",na,n9,e8,e9,function()return true end,n6)e9=e9+n9+20;mV("Enable Turn and Burn","Disable Turn and Burn",na,n9,e8,e9,function()return aV end,nf)e8=10;e9=cR/2-300;mV("Horizontal Takeoff Mode","Vertical Takeoff Mode",na,n9,e8+na+20,e9,function()return aQ end,function()aQ=not aQ;if aQ then ck="Vertical Takeoff Mode"else ck="Horizontal Takeoff Mode"end end,function()return dv end)e9=e9+n9+20;mV("Engage Orbiting","Cancel Orbiting",na,n9,e8+na+20,e9,function()return bp end,d3.ToggleIntoOrbit,function()return cF==0 and dG end)e9=cR/2-150;mV("Glide Re-Entry","Cancel Glide Re-Entry",na,n9,e8+na+20,e9,function()return aZ end,function()cz=1;ng(1)end,function()return iu.hasAtmosphere and not cE end)e9=e9+n9+20;mV("Parachute Re-Entry","Cancel Parachute Re-Entry",na,n9,e8+na+20,e9,function()return aZ end,d3.BeginReentry,function()return iu.hasAtmosphere and not cE end)e9=e9+n9+20;mV("Engage Follow Mode","Disable Follow Mode",na,n9,e8,e9,function()return ci end,nm,function()return bG()==1 end)mV("Enable Repair Arrows","Disable Repair Arrows",na,n9,e8+na+20,e9,function()return cW end,function()cW=not cW;if cW then ck="Repair Arrows Enabled"else ck="Repair Arrows Diabled"end end,function()return bG()==1 end)e9=e9+n9+20;if not q then mV("Enable AGG","Disable AGG",na,n9,e8,e9,function()return dw end,d3.ToggleAntigrav,function()return antigrav~=nil end)end;mV(function()return bA("Switch IPH Mode - Current: %s",bq)end,function()return bA("IPH Mode: %s",bq)end,na*2,n9,e8,e9,function()return false end,function()if bq=="All"then bq="Custom Only"elseif bq=="Custom Only"then bq="No Moons"else bq="All"end;ck="IPH Mode: "..bq end)e9=e9+n9+20;mV(function()return bA("Toggle Control Scheme - Current: %s",g)end,function()return bA("Control Scheme: %s",g)end,na*2,n9,e8,e9,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;ck="New Control Scheme: "..g end)local ny=iw(20)local nw=mR(0,0,iv(70),ny,"HELP")nw=mR(nw.x+nw.width,nw.y,iv(80),ny,"INFO")nw=mR(nw.x+nw.width,nw.y,iv(70),ny,"ORBIT")nw=mR(nw.x+nw.width,nw.y,iv(70),ny,"SCOPE")mR(nw.x+nw.width,nw.y,iv(70),ny,"HIDE")end;local nz={}local nA=nil;function nz.HUDPrologue(jc)dC,dD=is(du)if not dC then b_=ab;c1=ac;c0=ad;if lr and G and lr.getState()==0 then lr.toggle()end else b_=a8;c1=a9;c0=aa;if lr and G and lr.getState()==1 then lr.toggle()end end;cM=[[rgb(]]..bz(b_+0.6)..","..bz(c1+0.6)..","..bz(c0+0.6)..[[)]]cN=[[rgb(]]..bz(b_*0.8+0.5)..","..bz(c1*0.8+0.5)..","..bz(c0*0.8+0.5)..[[)]]local nB=cM;local nC=cN;local nD=[[rgb(]]..bz(b_*0.4+0.5)..","..bz(c1*0.4+0.5)..","..bz(c0*0.4+0.5)..[[)]]local nE=cM;local nF=cN;local nG=nD;if ix()and not m then nB=[[rgb(]]..bz(b_*0.5+0.5)..","..bz(c1*0.5+0.5)..","..bz(c0*0.5+0.5)..[[)]]nC=[[rgb(]]..bz(b_*0.3+0.5)..","..bz(c1*0.3+0.5)..","..bz(c0*0.2+0.5)..[[)]]nD=[[rgb(]]..bz(b_*0.2+0.5)..","..bz(c1*0.2+0.5)..","..bz(c0*0.2+0.5)..[[)]]end;local l6=iv;local l7=iw;jc[#jc+1]=bA([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nB,nB,nB,nE,nE,nC,nC,nF,nF,nC,nB,nD,nF,nB,nB,nD,nD,nG,nD,cQ,cR,nC,nC,nC,nC,nC,nE,nC,nF,nG,nF,nF,nG)if not nA then nA=bA([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],l6(630),l7(0),l6(675),l7(45),l6(960),l7(55),l6(1245),l7(45),l6(1290),l7(0),l6(1000),l7(105),l6(1040),l7(59),l6(1250),l7(51),l6(1300),l7(0),l6(1920),l7(0),l6(1920),l7(20),l6(1400),l7(20),l6(1300),l7(105),l6(920),l7(105),l6(880),l7(59),l6(670),l7(51),l6(620),l7(0),l6(0),l7(0),l6(0),l7(20),l6(520),l7(20),l6(620),l7(105),l6(890),l7(59),l6(960),l7(62),l6(1030),l7(59),l6(985),l7(112),l6(1150),l7(112),l6(1100),l7(152),l6(820),l7(152),l6(780),l7(112),l6(935),l7(112),l6(890),l7(59),l6(960),l7(62),l6(1030),l7(59),l6(985),l7(112),l6(1150),l7(112),l6(1100),l7(152),l6(820),l7(152),l6(780),l7(112),l6(935),l7(112))end;if x and I then jc[#jc+1]=nA end;return jc end;function nz.DrawVerticalSpeed(jc,f3)jb(jc,f3)end;function nz.UpdateHud(jc)local k2=dz;local nH=dA;local jk=nH;local jA=k2;local kk=bz(c.getThrottle())local kp=dr*3.6;local kl=c.getAxisCommandValue(0)local nI=iv(1770)local nJ=iw(310)if u and dy then kl=c2;kk=c2*100 end;local iz=iy()local jl="ROLL"if kk==nil then kk=0 end;if not dG then if dr>5 then k2=k1(dp)nH=k3(dp)else k2=0;nH=0 end;jl="YAW"end;if dD>50000 and not cE then local nK;nK=eh(dD)jc[#jc+1]=e7(nI,nJ,"PvP Boundary: "..nK,"pbright txtbig txtmid")end;jc[#jc+1]=cy;jc[#jc+1]=cP;jc[#jc+1]=i5;if ik~=""then jc[#jc+1]=ik end;if iA~=""then jc[#jc+1]=iA end;if iB~=""then jc[#jc+1]=iB end;jb(jc,cG)if bG()==0 or l then if dG then jj(jc,ae,af,jk,jl,dG)else jj(jc,ae,af,nH,jl,dG)end;if not ix()or m then if dG then jj(jc,ae,af,jk,jl,dG)jz(jc,jA,jk,ae,af,dG,bz(k3(dp)),dr)else jj(jc,ae,af,nH,jl,dG)jz(jc,k2,nH,ae,af,dG,bz(nH),dr)end;jG(jc,cG,dG)k4(jc,dp,dr,ae,af)end end;kj(jc,iz,kk,kl)ko(jc,kp)ks(jc)ls(jc)if not ii and cj then lj(jc)end;return jc end;function nz.HUDEpilogue(jc)jc[#jc+1]="</svg>"return jc end;function nz.ExtraData(jc)local nL=iv(1240)local nM=iw(55)local nN=nM+10;local nO;local l6=iv;local l7=iw;local nP=0;local iz=iy()if aQ then iz=iz.."-VERTICAL"end;if F and not aY and not aX and dr>20 then iz=iz.."-COLLISION ON"end;if bs~="Off"then iz="("..bs..")-"..iz end;if aV then iz="TB-"..iz end;if not br then iz=iz.."-DeCoupled"end;local nQ=l7(99)local nR=l7(80)local nS=l7(85)local nT=l7(31)local nU=0;local nV=0;local nW=cJ>1000000 and bT(cJ/1000000,2).."kT"or bT(cJ/1000,2).."T"if cE then nP=bk else nP=bi end;local nX,nY=cZ.computeDistanceAndTime(dr,0,cJ,0,0,nP)if nX<0 then nX=0 end;nP=bT(nP/(cJ*ia),2).."g"local nZ=d:maxForceForward()nO=b.g()if nO>0.1 then nV=cJ*nO;nV=bT(nV/(cJ*ia),2).."g"nU=0.5*nZ/nO;nU=nU>1000000 and bT(nU/1000000,2).."kT"or bT(nU/1000,2).."T"end;nZ=bT(nZ/(cJ*ia),2).."g"local n_=vec3(b.getWorldAcceleration()):len()/9.80665;nO=b.g()jc[#jc+1]=[[<g class="dim txt txtend size14">]]if bG()==1 and not l then nL=iv(1120)nM=iw(55)nN=nM+10 elseif cE and I then local o0=iv(770)jc[#jc+1]=e7(l6(895),nQ,"ATMO","")jc[#jc+1]=bA([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],l6(895),nS,l6(-80))jc[#jc+1]=e7(l6(815),nR,bA("%.1f%%",cF*100),"txtstart size20")end;if I then jc[#jc+1]=e7(l6(1025),nQ,"GRAVITY","txtstart")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(1025),nS,l6(80))jc[#jc+1]=e7(l6(1105),nR,bA("%.2fg",nO/9.80665),"size20")jc[#jc+1]=e7(l6(1125),nQ,"ACCEL","txtstart")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(1125),nS,l6(80))jc[#jc+1]=e7(l6(1205),nR,bA("%.2fg",n_),"size20")jc[#jc+1]=e7(l6(695),nQ,"BRK TIME","")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(695),nS,l6(-80))jc[#jc+1]=e7(l6(615),nR,bA("%s",ek(nY)),"txtstart size20")jc[#jc+1]=e7(l6(635),l7(45),"TRIP","")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(635),l7(31),l6(-90))if l0 then jc[#jc+1]=e7(l6(532),l7(23),bA("%s",ek(l0)),"txtstart size20")end;jc[#jc+1]=e7(l6(795),nQ,"BRK DIST","")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(795),nS,l6(-80))jc[#jc+1]=e7(l6(715),nR,bA("%s",eh(nX)),"txtstart size20")jc[#jc+1]=e7(l6(1285),l7(45),"MASS","txtstart")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(1285),l7(31),l6(90))jc[#jc+1]=e7(l6(1388),l7(23),bA("%s",nW),"size20")jc[#jc+1]=e7(l6(1220),nQ,"THRUST","txtstart")jc[#jc+1]=bA([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],l6(1220),nS,l6(80))jc[#jc+1]=e7(l6(1300),nR,bA("%s",nZ),"size20")jc[#jc+1]=e7(iv(960),iw(175),iz,"pbright txtbig txtmid size20")end;jc[#jc+1]="</g>"end;function nz.DrawOdometer(jc,cr,bd,cs)if bx~="INFO"then return jc end;local nO;local nU=0;local nV=0;local nP=0;local nW=cJ>1000000 and bT(cJ/1000000,2).." kTons"or bT(cJ/1000,2).." Tons"if cE then nP=bk else nP=bi end;local nX,nY=cZ.computeDistanceAndTime(dr,0,cJ,0,0,nP)nP=bT(nP/(cJ*ia),2).." g"local nZ=d:maxForceForward()nO=b.g()if nO>0.1 then nV=cJ*nO;nV=bT(nV/(cJ*ia),2).." g"nU=0.5*nZ/nO;nU=nU>1000000 and bT(nU/1000000,2).." kTons"or bT(nU/1000,2).." Tons"end;nZ=bT(nZ/(cJ*ia),2).." g"if bG()==0 or l then local o1=iv(as+10)local o2=iw(at+20)local o3=iv(as+10+ar/1.25)local mT=25;jc[#jc+1]="<g class='txtstart size14 bright'>"jc[#jc+1]=e7(o1,o2,bA("BrkTime: %s",ek(nY)))jc[#jc+1]=e7(o3,o2,bA("Trip: %.2f km",cr))jc[#jc+1]=e7(o1,o2+mT,bA("Lifetime: %.2f kSU",bd/200000))jc[#jc+1]=e7(o3,o2+mT,bA("BrkDist: %s",eh(nX)))jc[#jc+1]=e7(o1,o2+mT*2,"Trip Time: "..ek(cs))jc[#jc+1]=e7(o3,o2+mT*2,"Total Time: "..ek(be))jc[#jc+1]=e7(o1,o2+mT*3,bA("Mass: %s",nW))jc[#jc+1]=e7(o3,o2+mT*3,bA("Max Brake: %s",nP))jc[#jc+1]=e7(o1,o2+mT*4,bA("Max Thrust: %s",nZ))if nO>0.1 then jc[#jc+1]=e7(o3,o2+mT*4,bA("Max Thrust Mass: %s",nU))jc[#jc+1]=e7(o1,o2+mT*5,bA("Req Thrust: %s",nV))else jc[#jc+1]=e7(o3,o2+mT*5,"Max Mass: n/a")jc[#jc+1]=e7(o1,o2+mT*6,"Req Thrust: n/a")end end;jc[#jc+1]="</g></g>"return jc end;function nz.DrawWarnings(jc)return ks(jc)end;function nz.DisplayOrbitScreen(jc)return ls(jc)end;function nz.DisplayMessage(jc,kO)if kO~="empty"then local e9=310;for o4 in string.gmatch(kO,"([^\n]+)")do e9=e9+35;jc[#jc+1]=e7("50%",e9,o4,"msg")end end;if cw~=0 then c.setTimer("msgTick",cw)cw=0 end end;function nz.DrawDeadZone(jc)jc[#jc+1]=bA([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aq)end;function nz.UpdatePipe()if cE then ik=""return end;mI()end;function nz.DrawSettings(jc)local e8=iv(640)local e9=iw(200)jc[#jc+1]=[[<g class="pbright txtvspd txtstart">]]local hM=0;for dZ,d_ in pairs(ij)do hM=hM+1;jc[#jc+1]=e7(e8,e9,dZ..": "..d_.get())e9=e9+20;if hM%12==0 then e8=e8+iv(350)e9=iw(200)end end;jc[#jc+1]=e7(iv(640),iw(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jc[#jc+1]="</g>"return jc end;local i6;local i2=iv(1770)local i3=iw(350)local i1=iw(15)local i0=iv(1370)local dS,o5;local i7=0;function nz.DrawRadarInfo()i5=d4.GetRadarHud(i0,i1,i2,i3)end;function nz.DrawTanks()if am~=0 and an~=0 then iA=e7(am,an,"","txtstart pdim txtfuel")iY=an;iR(am,"Atmospheric ","ATMO",cS,iP,iQ)iR(am,"Space Fuel T","SPACE",cT,iN,iO)iR(am,"Rocket Fuel ","ROCKET",cU,iL,iM)end end;function nz.DrawShield()local o6=lr.getState()==1 and"Shield Active"or"Shield Disabled"local o7=b.getPvPTimer()local o8=lr.getResistances()local o9="A: "..10+o8[1]*100 .."% / E: "..10+o8[2]*100 .."% / K:"..10+o8[3]*100 .."% / T: "..10+o8[4]*100 .."%"local e8,e9=ao-60,ap+30;local oa=bz(0.5+lr.getShieldHitpoints()*100/lr.getMaxShieldHitpoints())local j5=bz(oa*2.55)local j6=bA("rgb(%d,%d,%d)",255-j5,j5,0)local eb=""iB=e7(e8,e9,"","txtmid pdim txtfuel")if oa<10 and o6~="Shield Disabled"then eb="red "end;o7=o7>0 and"   PvPTime: "..ek(o7)or""iB=iB..bA([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],e8,e9,j6,oa*2,e8,e9,e8+2,e9+10,oa,o7)iB=iB..e7(e8,e9-5,o6,eb.."txtstart pbright txtbig")iB=iB..e7(e8,e9+30,o9,eb.."txtstart pbright txtsmall")end;function nz.hudtick()if not iu then return end;local function ob(jc)local j8=bz(bK(cx/(cQ/4)*255,0,255))jc[#jc+1]=bA("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",cu,cv,bz(b_+0.5)+j8,bz(c1+0.5)-j8,bz(c0+0.5)-j8)end;local function oc()for eQ,d_ in pairs(ib)do if d_.hovered then if not d_.drawCondition or d_.drawCondition(d_)then d_.toggleFunction(d_)end;d_.hovered=false end end;for eQ,d_ in pairs(dL)do if d_.hovered then bx=d_.label;d_.hovered=false end end end;local function od()local function oe(of,og,e8,e9,mS,mT)if of>=e8 and of<=e8+mS and og>=e9 and og<=e9+mT then return true else return false end end;local e8=cu+cQ/2;local e9=cv+cR/2;for eQ,d_ in pairs(ib)do d_.hovered=oe(e8,e9,d_.x,d_.y,d_.width,d_.height)end;for eQ,d_ in pairs(dL)do d_.hovered=oe(e8,e9,d_.x,d_.y,d_.width,d_.height)end;if dJ then local mx=false;for eQ,ef in ipairs(nv)do if ef.hovered then mx=true;break end end;if ns.hovered then mx=true end;dJ=mx else dJ=ns.hovered;if not dJ then dK=bb end end end;local function oh(jc)if not bx or bx==""then bx="HELP"end;if x then for dZ,d_ in pairs(dL)do local eb="dim brightstroke"local oi=0.2;if bx==dZ then eb="pbright dimstroke"oi=0.6 end;local oj=""if d_.hovered then oi=0.8;oj=";stroke:white"end;jc[#jc+1]=bA([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],d_.width,d_.height,d_.x,d_.y,eb,oi,oj)jc[#jc+1]=e7(d_.x+d_.width/2,d_.y+d_.height/2+5,d_.label,"txt txtmid pdim")end end end;local function ok(jc)local function ol(jc,om,hover,e8,e9,gd,on,oo,op,oq,os,nw)if type(oq)=="function"then oq=oq(nw)end;if type(os)=="function"then os=os(nw)end;jc[#jc+1]=bA("<rect x='%f' y='%f' width='%f' height='%f' fill='",e8,e9,gd,on)if om then jc[#jc+1]=bA("%s'",oo)else jc[#jc+1]=op end;if hover then jc[#jc+1]=bA(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",a8,a9,aa)else jc[#jc+1]=bA(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",bT(a8*0.5,0),bT(a9*0.5,0),bT(aa*0.5,0))end;jc[#jc+1]=" rx='5'></rect>"jc[#jc+1]=bA("<text x='%f' y='%f' font-size='24' fill='",e8+gd/2,e9+on/2+5)if om then jc[#jc+1]="black"else jc[#jc+1]="white"end;jc[#jc+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if om then jc[#jc+1]=bA("%s</text>",oq)else jc[#jc+1]=bA("%s</text>",os)end end;local ot=bA("rgb(%d,%d,%d)'",bT(a8*0.1,0),bT(a9*0.1,0),bT(aa*0.1,0))local ou=bA("rgb(%d,%d,%d)",bT(a8*0.8,0),bT(a9*0.8,0),bT(aa*0.8,0))local ov=ol;for eQ,d_ in pairs(ib)do local mX=d_.disableName;local mW=d_.enableName;if type(mX)=="function"then mX=mX(d_)end;if type(mW)=="function"then mW=mW(d_)end;if not d_.drawCondition or d_.drawCondition(d_)then ov(jc,d_.toggleVar(d_),d_.hovered,d_.x,d_.y,d_.width,d_.height,ou,ot,mX,mW,d_)end end end;local ow=bT(cQ/2,0)local ox=bT(cR/2,0)local jc={}d1.HUDPrologue(jc)if x then d1.UpdateHud(jc)else if B then d1.DrawVerticalSpeed(jc,cG)end;d1.DrawWarnings(jc)end;if ii and ij~="none"then d1.DrawSettings(jc)end;if radar_1 then d1.DrawRadarInfo()end;d1.HUDEpilogue(jc)jc[#jc+1]=bA([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cQ,cR)if ck~="empty"then d1.DisplayMessage(jc,ck)end;if bG()==0 and g=="virtual joystick"then if w then d1.DrawDeadZone(jc)end end;oh(jc)if bQ()==0 then if bG()==1 and cj then if not oy then od()ok(jc)end;if not d6 and not d7 then local oz=table.concat(jc,"")jc={}jc[#jc+1]=bA("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cQ,cR)jc[#jc+1]=oz;jc[#jc+1]="</body>"d6=true;jc[#jc+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oA=table.concat(jc,"")a.setScreen(oA)elseif d7 then local oz=table.concat(jc,"")jc={}jc[#jc+1]=bA("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cQ,cR)jc[#jc+1]=oz;jc[#jc+1]="</body>"end;if not d6 then jc[#jc+1]=bA([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ow,ox,cu,cv)end else oc()end else if not cj and bG()==0 then oc()if cx>aq then if w then ob(jc)end end elseif cj and(not oy or not i)then od()ok(jc)end;jc[#jc+1]=bA([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ow,ox,cu,cv)end;jc[#jc+1]=[[</svg></body>]]oA=table.concat(jc,"")end;function nz.TenthTick()d1.DrawTanks()if lr then d1.DrawShield()end end;function nz.OneSecond(jc)local function oB()local j1=bJ()local kp=dr;local oC=j1-cI;if kp>1.38889 then kp=kp/1000;local oD=kp*(j1-cI)bd=bd+oD;cr=cr+oD end;cs=cs+oC;be=be+oC;cI=j1 end;oB()d1.UpdatePipe()d1.ExtraData(jc)end;function nz.ButtonSetup()n7()nc()ib=ic end;return nz end;local function oE()local function oF(ne)local dR=oG:closestBody(ne)if(ne-dR.center):len()>dR.radius+dR.noAtmosphericDensityAltitude then dR=e[0][0]end;return dR end;local function oH()local function oI(oJ,oK)return oJ.name<oK.name end;dB={}for dZ,d_ in pairs(e[0])do dB[#dB+1]={name=d_.name,index=dZ}end;table.sort(dB,oI)end;local function oL(oM)for dZ,d_ in pairs(oM)do if d_.name and d_.name==li.name then return dZ end end;return-1 end;local function oN()dK=bb;if bb==0 then b9="None"cq=nil;li=nil;return true end;local oO=dB[bb].index;local oP=e[0][oO]if oP.center then b9=oP.name;cq=cY[0][oO]if li~=nil then if cF==0 then if bN(oQ,oR)~=1 then bO(oQ,oR)end;if bN(oS,oT)~=1 then bO(oS,oT)end;if bN(oU,oV)~=1 then bO(oU,oV)end;if bN(oW,oX)~=1 then bO(oW,oX)end;if bN(oY,oZ)~=1 then bO(oY,oZ)end end;if bN(o_,p0)~=1 then bO(o_,p0)end;if bN(p1,p2)~=1 then bO(p1,p2)end;if bN(p3,p4)~=1 then bO(p3,p4)end end;li=nil else li=oP;for eQ,d_ in pairs(cY[0])do if d_.name==li.planetname then cq=d_;b9=li.name;break end end;if bN(o_,p0)~=1 then bO(o_,p0)end;if bN(p1,p2)~=1 then bO(p1,p2)end end;if li==nil then ba=vec3(cq.center)else ba=li.position end;if cq.planetname~="Space"then if cq.hasAtmosphere then p5=bz(cq.radius*(Q-1)+cq.noAtmosphericDensityAltitude)else p5=bz(cq.radius*(Q-1)+cq.surfaceMaxAltitude)end else p5=P end;if li~=nil and li.planetname=="Space"then b5=0 else eQ,b5=d0(cq):escapeAndOrbitalSpeed(p5)end;b7=0;b1=false;b3=false;b4=false;aU=false;b2=false;b6="Aligning"return true end;local function p6(jg)if not aU and not bg and not cA and not bp and not aZ and not cB then if jg==nil then bb=bb+1;if bb>#dB then bb=0 end else bb=bb-1;if bb<0 then bb=#dB end end;if bb==0 then oN()else local oO=dB[bb].index;local oP=e[0][oO]if oP~=nil and oP.name=="Space"or bq=="Custom Only"and oP.center or bq=="No Moons"and string.find(oP.name,"Moon")~=nil then if jg==nil then p6()else p6(1)end else oN()end end else ck="Disengage autopilot before changing Interplanetary Helper"dT("iph","AP")end end;local function nj()local hC=-1;hC=oL(e[0])if hC>-1 then table.remove(e[0],hC)end;hC=-1;hC=oL(bf)if hC~=-1 then ck=li.name.." saved location cleared"table.remove(bf,hC)end;p6()oH()end;local function nd(hR,ne,jZ,p7)if dbHud_1 or jZ then local dR=oF(ne)local nO=dR.gravity;if p7 then nO=c.getClosestPlanetInfluence()end;local p8={position=ne,name=hR,planetname=dR.name,gravity=nO,safe=p7}if not jZ then bf[#bf+1]=p8 else for dZ,d_ in pairs(e[0])do if d_.name and hR==d_.name then table.remove(e[0],dZ)end end end;table.insert(e[0],p8)oH()oN()ck="Location saved as "..hR.."("..dR.name..")"else ck="Databank must be installed to save permanent locations"end end;local p9={}function p9.UpdateAtlasLocationsList()oH()end;function p9.UpdateAutopilotTarget()oN()end;function p9.adjustAutopilotTargetIndex(jg)p6(jg)end;function p9.findAtlasIndex(oM)oL(oM)end;function p9.UpdatePosition(pa)local hC=oL(bf)if hC~=-1 then if pa~=nil then bf[hC].name=pa;bb=bb-1;p6()else local pb=bf[hC]pb.gravity=c.getClosestPlanetInfluence()pb.position=du;pb.safe=true end;ck=bf[hC].name.." position updated ("..bf[hC].planetname..")"else ck="Name Not Found"end end;function p9.AddNewLocation(hR,ne,jZ,p7)nd(hR,ne,jZ,p7)end;function p9.ClearCurrentPosition()nj()end;for dZ,d_ in pairs(bf)do table.insert(e[0],d_)end;oH()if bb>#dB then bb=0 end;p9.UpdateAutopilotTarget()return p9 end;local function pc()local pd={}local function pe(gk)local pf=b5;if not aU then pf=0 end;if not cE then return cZ.computeDistanceAndTime(gk,pf,cJ,0,0,bi-b7*cJ)else if bk and bk>0 then return cZ.computeDistanceAndTime(gk,pf,cJ,0,0,bk-b7*cJ)else return 0,0 end end end;local function pg(gk)local pf=b5;if not aU then pf=0 end;return cZ.computeDistanceAndTime(gk,pf,cJ,d:maxForceForward(),_,bi-b7*cJ)end;local ph=false;local pi=0;local pj=0;local pk=0;local pl=bJ()local pm=0;local pn=0;local po=0;local pp=0;local pq=false;local pr=false;local ps=false;local pt=nil;local pu=0;local pv={}function pd.GetAutopilotBrakeDistanceAndTime(gk)return pe(gk)end;function pd.GetAutopilotTBBrakeDistanceAndTime(gk)return pg(gk)end;local function pw(px,py,pz)py=py:project_on_plane(px)pz=pz:project_on_plane(px)return bH(py:cross(pz):dot(px),py:dot(pz))end;local function pA()local function pB()local pC=-1;local pD=-1;if vBooster then pC=vBooster.getDistance()end;if hover then pD=hover.getDistance()end;if pC~=-1 and pD~=-1 then if pC<pD then return pC else return pD end elseif pC~=-1 then return pC elseif pD~=-1 then return pD else return-1 end end;local pE=pB()local pF=-1;if pG then pF=pG.getDistance()end;if pE~=-1 and pF~=-1 then if pE<pF then return pE else return pF end elseif pE~=-1 then return pE else return pF end end;local function pH(iu,fH,pI)local function pJ(pK,eX)local fN=vec3(eX)if pK.id==0 then return setmetatable({latitude=fN.x,longitude=fN.y,altitude=fN.z,id=0,systemId=pK.systemId},eZ)end;local fO=fN-pK.center;local cx=fO:len()local f3=cx-pK.radius;local f1=0;local f2=0;if not ed(cx,0)then local fP=bH(fO.y,fO.x)f2=fP>=0 and fP or 2*math.pi+fP;f1=math.pi/2-math.acos(fO.z/cx)end;return setmetatable({latitude=math.deg(f1),longitude=math.deg(f2),altitude=f3,id=pK.id,systemId=pK.systemId},eZ)end;local pL=pJ(iu,fH)pL="::pos{"..pL.systemId..","..pL.id..","..pL.latitude..","..pL.longitude..","..pL.altitude.."}"if pI then return pL else a.setWaypoint(pL)return true end end;local pM=false;function pd.changeSpd(pN)local bW=1;if pN then bW=-1 end;if not cj then if u and not oy and cK then local pO=c2;c2=bT(bK(c2+bW*av/100,-1,1),2)if c2>=0 and pO<0 then c2=0;cK=false end elseif oy then if cF>0 or aZ then dc=bK(dc+bW*av,0,S)elseif aU then Y=bK(Y+bW*av/3.6*100,0,8333.00)end else bL:updateCommandFromActionStart(axisCommandId.longitudinal,bW*av)end else if aU or bg or cA or bp then dK=dK+1*bW*-1;if dK>#dB then dK=1 end;if dK<1 then dK=#dB end else if not pN then bW=1 else bW=nil end;d2.adjustAutopilotTargetIndex(bW)end end end;function pd.showWayPoint(iu,fH,pI)return pH(iu,fH,pI)end;function pd.APTick()local function pP()if dI and not aX then local fq=dI[1]local hS,hT=dI[2],dI[3]local pQ=math.min(hS,hT or hS)local pR=pQ/dr;local pS=aY and(dr<42 or cC~=-1)local pT=aW or bg or bj or aU;if pT and not pS and(cm*1.5>pQ or pR<1)then aR=true;d3.cmdThrottle(0)if aW then d3.ToggleAltitudeHold()end;if bj then pU()end;ck="Autopilot Cancelled due to possible collision"if bg or aU then pv={}d3.ToggleAutopilot()end;kV=true;aX=true;d8=true end;if pR<11 then dH=fq.name.." COLLISION "..ek(pR).." / "..eh(pQ,2)else dH=fq.name.." collision "..ek(pR)end;if pR<6 then dT("alarm","AL",2)end else dH=false end end;local function pV(pW,pX,pY)local function pZ(pW,fs)pW=vec3(pW)fs=vec3(fs):normalize()local eH=pW*fs;return eH.x+eH.y+eH.z end;local p_=0.001;local q0=1;if not cE or not da or cC~=-1 or dr<c8 then if pY==nil then pY=aJ end;if pX==nil then pX=p_ end;pW=vec3(pW):normalize()local q1=vec3()-pW;local q2=-pZ(q1,b.getConstructWorldOrientationRight())*q0;local q3=-pZ(q1,b.getConstructWorldOrientationUp())*q0;if pj==0 then pj=q2/2 end;if pk==0 then pk=q3/2 end;if by(q2)<0.1 then cd=cd-q2*2 else cd=cd-(q2+(q2-pj)*pY)end;if by(q3)<0.1 then cc=cc+q3*2 else cc=cc+q3+(q3-pk)*pY end;pj=q2;pk=q3;if by(q2)<pX and by(q3)<pX then return true end;return false elseif da and cC==-1 then pW=dq;if pY==nil then pY=aJ end;if pX==nil then pX=p_ end;pW=vec3(pW):normalize()local q1=dm-pW;local q2=-pZ(q1,b.getConstructWorldOrientationRight())*q0;local q3=-pZ(q1,b.getConstructWorldOrientationUp())*q0;if pj==0 then pj=q2/2 end;if pk==0 then pk=q3/2 end;if by(q2)<0.1 then cd=cd-q2*5 else cd=cd-(q2+(q2-pj)*pY)end;if by(q3)<0.1 then cc=cc+q3*5 else cc=cc+q3+(q3-pk)*pY end;pj=q2;pk=q3;if by(q2)<pX and by(q3)<pX then return true end;return false end end;cE=bE()>0;cF=bE()cG=b.getAltitude()cC=pA()bX=bJ()pl=bX;if F then pP()end;if antigrav then dw=antigrav.getState()==1 end;local q4=1;local q5=1;local q6=bX-pl;local q7=-math.deg(pw(dl,dq,dm))local q8=math.deg(pw(dn,dq,dm))local jg=ds*-1;da=cE and q7<-J or q7>J or q8<-K or q8>K;local q9=a.getMouseDeltaX()local qa=a.getMouseDeltaY()if o and not cj then qa=-qa end;cd=0;ch=0;cc=0;oG=cY[0]iu=oG:closestBody(b.getConstructWorldPos())qb=d0(iu)go=qb:orbitalParameters(b.getConstructWorldPos(),dq)if cG==0 then cG=(du-iu.center):len()-iu.radius end;dG=c.getClosestPlanetInfluence()>0 or cG>0 and cG<200000;local nO=iu:getGravity(b.getConstructWorldPos()):len()*cJ;db=0;c_=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if bQ()==0 then if bG()==1 and cj then if not d6 then cu=bK(cu+q9,-cQ/2,cQ/2)cv=bK(cv+qa,-cR/2,cR/2)end else cu=0;cv=0 end else cu=bK(cu+q9,-cQ/2,cQ/2)cv=bK(cv+qa,-cR/2,cR/2)cx=bR(cu*cu+cv*cv)if not cj and bG()==0 then local kb,kc=1,1;if bx=="SCOPE"then kb,kc=dP/90,dP/90 end;if g=="virtual joystick"then if cu>0 and cu>aq then cd=cd-(cu-aq)*ax*kb elseif cu<0 and cu<aq*-1 then cd=cd-(cu+aq)*ax*kb else cd=0 end;if cv>0 and cv>aq then cc=cc-(cv-aq)*ay*kc elseif cv<0 and cv<aq*-1 then cc=cc-(cv+aq)*ay*kc else cc=0 end else cu=0;cv=0;if g=="mouse"then cc=(-utils.smoothstep(qa,-100,100)+0.5)*2*q4;cd=(-utils.smoothstep(q9,-100,100)+0.5)*2*q5 end end end end;local qc=dr>8334;if dr>T/3.6 and not cE and not aU and not qc then ck="Space Speed Engine Shutoff reached"d3.cmdThrottle(0)end;if not qc and qd then if not aR then d3.BrakeToggle()end;if aU then d3.ToggleAutopilot()end end;qd=qc;if cE and cF>0.09 then if dr>dc/3.6 and not u and not ph then aR=true;ph=true elseif not u and ph then if dr<dc/3.6 then aR=false;ph=false end end end;if aR then cg=1 else cg=0 end;if aT then if cz then aR=false;local qe=false;if li and cz~=1 then qe=pV(li.position-du,0.1)else qe=pV(vec3(dq),0.01)end;d8=true;if qe then d3.cmdCruise(bz(dc))if(by(dA)<2 or by(dz)>85)and dr>=dc/3.6-1 then aR=false;aT=false;c9=true;if cz~=1 then cB=true end;cz=false;aU=false;d3.BeginReentry()end elseif cE and u then d3.cmdThrottle(1)end elseif dr>c8 then pV(vec3(dq),0.01)end end;if aS then if cE then aS=false elseif dr>c8 then pV(-vec3(dq))end end;if not aT and cz and not bp then if cF==0 then c9=true;d3.BeginReentry()cz=false;cB=true else cz=false;d3.ToggleAutopilot()end end;if cB and li and(cG<b0+250 and cG>b0-250)and dr*3.6>dc-250 and by(dt)<25 and cF>=0.1 and(li.position-du):len()>2000+cG then d3.ToggleAutopilot()cB=false end;if a_ then d8=true;local qf=b0;if dt<-30 then ck="Unable to achieve lift. Safety Landing."ct=0;d8=p;a_=false;aX=true elseif not q and dw or b0<iu.spaceEngineMinAltitude then if dw then qf=antigrav.getBaseAltitude()end;if cG<qf-100 then dd=0;ct=15;aR=false elseif dt>0 then aR=true;ct=0 elseif dt<-30 then aR=true;ct=15 elseif cG>=qf then if dw then if aU or bg then d3.ToggleVerticalTakeoff()else aR=true;a_=false end;ck="Takeoff complete. Singularity engaged"dT("aggLk","AG")else aR=false;ck="VTO complete. Engaging Horizontal Flight"dT("vtoc","VT")d3.ToggleVerticalTakeoff()end;ct=0 end else if cF>0.08 then dd=0;aR=false;ct=20 elseif cF<0.08 and cF>0 then aR=false;if dj then dd=0;ct=20 else ct=0;dd=36;d3.cmdCruise(3500)end else d8=p;bp=true;dh=false;qg=false;pq=false;po=nil;pp=nil;if pt==nil then pt=iu end;dg=qf;ps=true;a_=false end end;if dd~=nil then if qh==nil then qh=pid.new(2*0.01,0,2*0.1)end;local qi=bK(dd-dz,-K*0.80,K*0.80)qh:inject(qi)local qj=bK(qh:get(),-1,1)cc=qj end end;if bp then local q1;local qk=false;local ql=eh(dg)if pt==nil then pt=iu;if bg then pt=cq end end;if not ps then dg=bz(pt.radius+pt.surfaceMaxAltitude+R)if pt.hasAtmosphere then dg=bz(pt.radius+pt.noAtmosphericDensityAltitude+R)end;ps=true end;if df.VectorToTarget and li then q1=li.position-du end;local qm,qn=d0(pt):escapeAndOrbitalSpeed((du-pt.center):len()-pt.radius)local qo=dA;if not pq then local qp=false;local qq=false;d3.cmdThrottle(0)pp=0;de="Aligning to orbital path - OrbitHeight: "..ql;if df.VectorToTarget then pV(q1:normalize():project_on_plane(ds))qk=dm:dot(q1:project_on_plane(dl):normalize())>0.95 else pV(dq)qk=q7<0.5;if dr<150 then qk=true end end;cc=0;po=0;if dz<=po+1 and dz>=po-1 then qp=true else qp=false end;if qo<=pp+1 and qo>=pp-1 then qq=true else qq=false end;if qp and qq and qk then po=nil;pp=nil;pq=true end else if df.VectorToTarget then pV(q1:normalize():project_on_plane(ds))elseif dr>150 then pV(dq)end;cc=0;if df.VectorToTarget and li then local cm,eQ=cZ.computeDistanceAndTime(dr,dc/3.6,cJ,0,0,bi)if dh and q1:len()>15000+cm+cG then de="Orbiting to Target"if cG-100<=pt.noAtmosphericDensityAltitude or l0>go.timeToPeriapsis and go.periapsis.altitude<pt.noAtmosphericDensityAltitude then dh=false end elseif dh or q1:len()<15000+cm+cG then ck="Orbit complete, proceeding with reentry"dT("orCom","OB")ba=li.position;c9=true;cB=true;df.VectorToTarget,df.AutopilotAlign=false,false;d3.ToggleIntoOrbit()d3.BeginReentry()return end end;if go.periapsis~=nil and go.apoapsis~=nil and go.eccentricity<1 and cG>dg*0.9 and cG<dg*1.4 then if go.apoapsis~=nil then if go.periapsis.altitude>=dg*0.99 and go.apoapsis.altitude>=dg*0.99 and go.periapsis.altitude<go.apoapsis.altitude and go.periapsis.altitude*1.05>=go.apoapsis.altitude or dh then if dh then aR=false;d3.cmdThrottle(0)po=0;if not df.VectorToTarget then ck="Orbit complete"dT("orCom","OB")d3.ToggleIntoOrbit()end else pu=pu+1;if pu>=2 then dh=true end end else de="Adjusting Orbit - OrbitHeight: "..ql;pr=true;d3.cmdCruise(qn*3.6+1)local qr=dg-cG;if qs==nil then qs=pid.new(0.1,0,1*0.1)end;qs:inject(qr-dt*bK(utils.smoothstep(2000-qr,-2000,2000)^6*10,1,10))po=bK(qs:get(),-60,60)end end else local qt=2.75;local qu=by(bT(qm*qt))local qv=qu%50;if qv>0 then qu=qu-qv+50 end;aR=false;if cG<dg*0.8 then de="Escaping planet gravity - OrbitHeight: "..ql;po=utils.map(dt,200,0,-15,80)elseif cG>=dg*0.8 and cG<dg*1.15 then de="Approaching orbital corridor - OrbitHeight: "..ql;qu=qu*0.75;po=utils.map(dt,100,-100,-15,65)elseif cG>=dg*1.15 and cG<dg*1.5 then de="Approaching orbital corridor - OrbitHeight: "..ql;qu=qu*0.75;if dt<0 or pr then po=utils.map(cG,dg*1.5,dg*1.01,-30,0)else po=utils.map(cG,dg*0.99,dg*1.5,0,30)end elseif cG>dg*1.5 then de="Reentering orbital corridor - OrbitHeight: "..ql;po=-65;local qw=utils.map(dt,-150,-400,1,0.55)qu=qu*qw end;d3.cmdCruise(bz(qu))end end;if po~=nil then if qx==nil then qx=pid.new(1*0.01,0,5*0.1)end;local qy=po-dz;qx:inject(qy)local qz=bK(qx:get(),-0.5,0.5)cc=qz end end;if aU and cF==0 and not cz then local function qA(dS,go)a.print(dS)aR=false;b3=false;aU=false;qB=false;b6="Aligning"d3.cmdThrottle(0)c7=false;ck=dS;dT("apCom","AP")if go or cz then if go and p5~=nil and not cz then if not cG or cG==0 then return end;dg=cG;ps=true end;d3.ToggleIntoOrbit()end end;local qC,qD=ba,false;if li and li.planetname~="Space"then b2=true;if not qB then local qE=(li.position-cq.center):normalize()local qF=qE:project_on_plane((cq.center-du):normalize()):normalize()local qG=cq.center+qF*(cq.radius+p5)local qH=li.position+(li.position-cq.center):normalize()*(p5-cq:getAltitude(li.position))if(du-qG):len()<(du-qH):len()then qC=qG else qC=qH;b5=0 end;ba=qC;d3.showWayPoint(cq,ba)qD=true;qB=true end;b7=0 elseif li and li.planetname=="Space"then if not qB then b7=0;qD=true;b2=true;qB=true;qC=li.position+(du-li.position):normalize()*P;ba=qC end elseif li==nil then b7=0;if not qB then local qE=(du+dq*100000-cq.center):normalize()local qF=qE:project_on_plane((cq.center-du):normalize()):normalize()if qF:len()<1 then qE=(du+dm*100000-cq.center):normalize()qF=qE:project_on_plane((cq.center-du):normalize()):normalize()end;qC=cq.center+qF*(cq.radius+p5)ba=qC;qB=true;qD=true;b2=true;d3.showWayPoint(cq,ba)end end;qI=(vec3(qC)-du):len()local kZ,fF,fG=cY:getPlanetarySystem(0):castIntersections(du,dq:normalize(),function(fq)if fq.noAtmosphericDensityAltitude>0 then return fq.radius+fq.noAtmosphericDensityAltitude else return fq.radius+fq.surfaceMaxAltitude*1.5 end end)local k_=fF;if fG~=nil and fF~=nil then k_=math.min(fG,fF)end;if k_~=nil and k_<qI and kZ.name==cq.name then qI=k_ end;local qe=true;local qJ=(cq.center-(du+vec3(dq):normalize()*qI)):len()-cq.radius;local kO=eh(qJ)bN(oY,'{"label": "Projected Altitude", "value": "'..kO..'"}')local cm,cn;if not aV then cm,cn=pe(dr)else cm,cn=pg(dr)end;if dr>50 and b1 then local q1=vec3(qC)-du;local qK=bK(math.deg(pw(dl,dq:normalize(),q1:normalize()))*dr/500,-90,90)local qL=bK(math.deg(pw(dn,dq:normalize(),q1:normalize()))*dr/500,-90,90)if by(qK)<20 and by(qL)<20 then qK=qK*2;qL=qL*2 end;if by(qK)<2 and by(qL)<2 then qK=qK*2;qL=qL*2 end;local q7=-math.deg(pw(dl,dm,dq:normalize()))local q8=-math.deg(pw(dn,dm,dq:normalize()))if qM==nil then qM=pid.new(2*0.01,0,2*0.1)end;qM:inject(qL-q8)local qN=bK(qM:get(),-1,1)cc=cc+qN;if qO==nil then qO=pid.new(2*0.01,0,2*0.1)end;qO:inject(qK-q7)local qP=bK(qO:get(),-1,1)cd=cd+qP;qD=true;if by(qK)>2 or by(qL)>2 then if b6~="Adjusting Trajectory"then b6="Adjusting Trajectory"dT("apAdj","AP")end else if b6~="Accelerating"then b6="Accelerating"dT("apAcc","AP")end end elseif b1 and dr<=50 then pV((qC-du):normalize())end;if qJ<p5*1.5 then if li and li.planetname=="Space"then b5=0 elseif li==nil then eQ,b5=d0(cq):escapeAndOrbitalSpeed(qJ)end end;if aU and not b1 and not b4 and not b3 then local kZ,k_=d3.checkLOS((ba-du):normalize())if cq.name~=iu.name then if kZ~=nil and cq.name~=kZ.name and k_<qI then ck="Collision with "..kZ.name.." in "..eh(k_).."\nClear LOS to continue."cw=5;pM=true else pM=false;ck=""end end end;if not pM then if not b4 and not b3 and not qD then qe=pV((qC-du):normalize())elseif aV and(b3 or b4)then qe=pV(-vec3(dq):normalize())end end;if b1 then if not c7 then aR=false;d3.cmdThrottle(Z)c2=bT(Z,2)c7=true end;local qQ=c.getThrottle()if u then qQ=c2 end;local qR=99999;local n_=-vec3(b.getWorldAcceleration()):dot(dq:normalize())local qS=bK(dq:dot((qC-du):normalize()),0,dr)if qS>0 or n_>0 then qR=cZ.computeTravelTime(qS,n_,qI-cm)end;if dp:len()>=Y or qQ==0 and c7 or _/4>qR then b1=false;if b6~="Cruising"then dT("apCru","AP")b6="Cruising"end;b4=true;d3.cmdThrottle(0)end;local qT=qI;if qT<=cm or H and dD<=cm+10000 and dC then if H and dD<=cm+10000 and dC then if dD<pi and dD>2000 then d3.ToggleAutopilot()ck="Autopilot cancelled to prevent crossing PvP Line"aR=true;pi=dD else pi=dD;return end end;b1=false;if b6~="Braking"then dT("apBrk","AP")b6="Braking"end;b3=true;d3.cmdThrottle(0)c7=false end elseif b3 then if b6~="Orbiting to Target"then aR=true;cg=1 end;if aV then d3.cmdThrottle(1,true)end;local eQ,qn=d0(cq):escapeAndOrbitalSpeed((du-iu.center):len()-iu.radius)local q1;if li then q1=li.position-du end;if li and li.planetname=="Space"and dr<50 then if#pv>0 then aR=false;d3.ToggleAutopilot()d3.ToggleAutopilot()return end;qA("Autopilot complete, arrived at space location")aR=true;cg=1 elseif li and li.planetname~="Space"and dr<=qn and(go.apoapsis==nil or go.periapsis==nil or go.apoapsis.altitude<=0 or go.periapsis.altitude<=0)then qA("Autopilot complete, commencing reentry")ba=li.position;cz=true;d3.showWayPoint(cq,ba)elseif(li and li.planetname~="Space"or li==nil)and go.periapsis~=nil and go.periapsis.altitude>0 and go.eccentricity<1 or b6=="Circularizing"then if b6~="Circularizing"then dT("apCir","AP")b6="Circularizing"end;if dr<=qn then if li then if dq:normalize():dot(q1:normalize())>0.4 then if b6~="Orbiting to Target"then dT("apOrb","OB")b6="Orbiting to Target"end;if not qU then aR=false;d3.showWayPoint(cq,li.position)qU=true end else qA("Autopilot complete, proceeding with reentry")ba=li.position;cz=true;d3.showWayPoint(cq,li.position)qU=false end else qA("Autopilot completed, setting orbit",true)cg=0 end end elseif b6=="Circularizing"then qA("Autopilot complete, fixing Orbit",true)end elseif b4 then local qT=qI;if qT<=cm or H and dD<=cm+10000 and dC then if H and dD<=cm+10000 and dC then if dD<pi and dD>2000 then d3.ToggleAutopilot()ck="Autopilot cancelled to prevent crossing PvP Line"aR=true;pi=dD else pi=dD;return end end;b1=false;if b6~="Braking"then dT("apBrk","AP")b6="Braking"end;b3=true end;local qQ=c.getThrottle()if u then qQ=c2 end;if qQ>0 then b1=true;if b6~="Accelerating"then b6="Accelerating"dT("apAcc","AP")end;b4=false end else if qe then if not b2 and li==nil or not b2 and li and li.planetname~="Space"then if not cz then ba=vec3(cq.center)+(p5+cq.radius)*dn;qV=dl;qW=dn end;b2=true elseif qe and not pM then b1=true;if b6~="Accelerating"then b6="Accelerating"dT("apAcc","AP")end;if not c7 then d3.cmdThrottle(Z,true)c2=bT(Z,2)c7=true;aR=false end end end end elseif aU and(li~=nil and li.planetname~="Space"and cF>0)then ck="Autopilot complete, starting reentry"dT("apCom","AP")ba=li.position;aR=false;b3=false;aU=false;qB=false;b6="Aligning"cg=0;d3.cmdThrottle(0)c7=false;aT=true;cz=true;d3.showWayPoint(cq,li.position)end;if ci then d8=true;local qL=0;local gq=du+vec3(c.getMasterPlayerRelativePosition())local qX=gq-du;local qY=vec3(qX):project_on(dm):len()local qZ=vec3(qX):project_on(dn):len()local cx=bR(qY*qY+qZ*qZ)pV(qX:normalize())local m8=40;local q_=cx<m8;local r0=100;local r1=bK((cx-m8)/2,10,r0)cc=0;local qe=by(cd)<0.1;if qe and dr<r1 and not q_ then aR=false;qL=-20 else aR=true;qL=0 end;local r2=0;if by(qL-dz)>r2 then if r3==nil then r3=pid.new(2*0.01,0,2*0.1)end;r3:inject(qL-dz)local qN=r3:get()cc=qN end end;if aW or aX or aZ or bg or bj~=nil then local r4=bk;if r4 then r4=r4*bK(dr/100,0.1,1)*cF else r4=bi end;if cF<0.01 then r4=bi end;local r5=dm:project_on_plane(ds):normalize():dot(dq)local r6=vec3(b.getWorldAirFrictionAcceleration())local r7=r6:len()*cJ;if r5>100 then cm,cn=cZ.computeDistanceAndTime(r5,100,cJ,0,0,r4)local r8,r9=cZ.computeDistanceAndTime(100,0,cJ,0,0,r4*0.55)cm=cm+r8 else cm,cn=cZ.computeDistanceAndTime(r5,0,cJ,0,0,r4*0.55)end;local qr=b0-cG-dt;local ra=200+dr;if aZ or cz then rb=2000+dr end;local rc=1;if aY then rc=bK(dr/100,0.1,1)end;local qL=(utils.smoothstep(qr,-ra,ra)-0.5)*2*M*rc;if not aZ and not cz and not bg and dm:dot(dq:normalize())<0.99 then qL=(utils.smoothstep(qr,-ra*bK(20-19*cF*10,1,20),ra*bK(20-19*cF*10,1,20))-0.5)*2*M*bK(2-cF*10,1,2)*rc end;if not aW then qL=0 end;if bj~=nil then if dG and not bp then qL=bj else bj=nil end end;d8=true;local rd=cc;if aZ then local re=bz(dc)local rf,rg=cZ.computeDistanceAndTime(dr,re/3.6,cJ,0,0,bi-iu.gravity*9.8*cJ)rf=rf==-1 and 5000 or rf;local rh=cG-(iu.noAtmosphericDensityAltitude+rf)local ri=cG>iu.noAtmosphericDensityAltitude+rf*1.35;if ri then qL=N;if dr<=re/3.6 and dr>re/3.6-10 and by(dq:normalize():dot(dm))>0.9 and not dy then c6=false;d3.cmdThrottle(1)end elseif dy and not ri and not cE then d3.cmdCruise(re,true)end;if dy then if dr>re/3.6 and not ri then aR=true else aR=false end else aR=false end;if dt>0 then aR=true end;if not c9 then qL=-80;if cF>0.02 then ck="PARACHUTE DEPLOYED"aZ=false;aX=true;qL=0;d8=p end elseif iu.noAtmosphericDensityAltitude>0 and ri then d8=true elseif not ri then if not cE and(dy or bL:getTargetSpeed(axisCommandId.longitudinal)~=re)then d3.cmdCruise(re)end;if dr<re/3.6+1 then aR=false;c9=false;aZ=false;d8=true end end end;if dr>c8 and not cA and not bg and not aX and v then pV(vec3(dq))end;if dE or(bg or cA)and bb>0 and cF>0.01 then local q1;if dE then if type(dE)=="table"then q1=dE elseif dE<3 and dE>0 then q1=-ds:cross(dq)*5000 elseif dE>=3 then q1=ds:cross(dq)*5000 elseif dE<0 then q1=dq*25000 end elseif li~=nil then q1=li.position-du else q1=cq.center-du end;local qK=math.deg(pw(ds:normalize(),dq,q1))*2;local mb=math.rad(by(dA))if dr>aC and cF>0.01 then local rj=1000+dr;local rk=(utils.smoothstep(qr-dt*10,-rj,rj)-0.5)*2*M;local rl=bK(90-rk,0,180)db=bK(qK*2,-rl,rl)local rm=qK;qK=bK(bK(qK,-J*0.80,J*0.80)*math.cos(mb)+4*(dz-qL)*math.sin(math.rad(dA)),-J*0.80,J*0.80)local rn=1;if db~=0 then rn=by(mb/db)end;rn=(90-bK(by(db-dA),0,90))/90;local ro=qL;if by(dA)>90 then ro=-ro end;qL=rn*bK(bK(ro*math.cos(mb),-K*0.8,K*0.8)+by(bK(by(rm)*math.sin(mb),-K*0.80,K*0.80)),-K*0.80,K*0.80)else db=0;qK=bK(qK,-J*0.80,J*0.80)end;local rp=q7-qK;if dE and by(rp)<=0.0001 and(type(dE)=="table"or type(dE)~="table"and dE<0 and by(dA)<1)then if dE==-2 then d3.ToggleAltitudeHold()end;dE=nil;dT("180Off","BR")return end;if not da and dr>aC and cF>0.01 then if rq==nil then rq=pid.new(2*0.01,0,2*0.1)end;rq:inject(rp)local qP=bK(rq:get(),-1,1)cd=cd+qP elseif cE and cC>-1 or dr<aC then pV(q1)elseif da and cF>0.01 then if(q7<-J or q7>J)and cF>0.01 then pV(dq)end;if(q8<-K or q8>K)and cF>0.01 then qL=bK(dz-q8,dz-K*0.80,dz+K*0.80)end end;if li~=nil and not cA then local qf=iu:getAltitude(li.position)local rh=q1:project_on_plane(ds):len()kV=true;if not cA and not aZ and rh<=cm and(dq:project_on_plane(ds):normalize():dot(q1:project_on_plane(ds):normalize())>0.99 or l2=="Finalizing Approach")then l2="Finalizing Approach"if#pv>0 then d3.ToggleAutopilot()d3.ToggleAutopilot()return end;d3.cmdThrottle(0)if aW then d3.ToggleAltitudeHold()bg=true end;aR=true elseif not aY then aR=false end;if l2=="Finalizing Approach"and(r5<0.1 or rh<0.1 or rr~=nil and rr<rh)then if not dw then dT("bklOn","BL")aX=true end;bg=false;l2="Proceeding to Waypoint"dH=false end;rr=rh end elseif bg and cF==0 and b0>iu.noAtmosphericDensityAltitude and not(cA or aZ)then if li~=nil and cq.name==iu.name then local q1=li.position-du;local qf=iu:getAltitude(li.position)local rh=bR(q1:len()^2-(cG-qf)^2)local r4=bk;if r4 then cm,cn=cZ.computeDistanceAndTime(dr,0,cJ,0,0,r4/2)kV=true;if rh<=cm+dr*q6/2 and dq:project_on_plane(ds):normalize():dot(q1:project_on_plane(ds):normalize())>0.99 then if iu.hasAtmosphere then aR=false;aT=false;c9=true;cz=false;cB=true;aU=false;d3.BeginReentry()end end;rr=rh end end end;if cF==0 and(aW and b0>iu.noAtmosphericDensityAltitude)and not(cA or bp or aZ)then if not dh and not bp then dg=b0;ps=true;if bg then df.VectorToTarget=true end;d3.ToggleIntoOrbit()bg=false;pq=true end end;if da and cF>0.01 and cC==-1 and dr>aC and l2~="Finalizing Approach"then pV(dq)qL=bK(dz-q8,dz-K*0.80,dz+K*0.80)end;cc=rd;local pF=-1;if aX then qL=0;local rs=false;local rt=30;if c_~=nil and c_>0 then local ru=bK(cF,0.4,2)local r4=bk*bK(dr/100,0.1,1)*ru;local rv=c_*ru+r4-nO;local rw=r4/2-nO;local rx=dr-bR(by(rw/2)*20/(0.5*cJ))*utils.sign(rw)if rx<0 then rx=0 end;local ry;if dr>100 then local rz,eQ=cZ.computeDistanceAndTime(dr,100,cJ,0,0,r4)local rA,eQ=cZ.computeDistanceAndTime(100,0,cJ,0,0,bR(r4))ry=rz+rA else ry=cZ.computeDistanceAndTime(dr,0,cJ,0,0,bR(r4))end;if ry<20 then aR=false else local rB=0;if rx>100 then local rC,eQ=cZ.computeDistanceAndTime(rx,100,cJ,0,0,rv)local rD,eQ=cZ.computeDistanceAndTime(100,0,cJ,0,0,c_*ru+bR(r4)-nO)rB=rC+rD else rB,eQ=cZ.computeDistanceAndTime(rx,0,cJ,0,0,c_*ru+bR(r4)-nO)end;rB=(rB+15+dr*q6)*1.1;local rE=li~=nil and iu:getAltitude(li.position)>0 and li.safe;if rE then local qf=iu:getAltitude(li.position)local rF=cG-qf-100;local q1=li.position-du;local rG=bR(q1:len()^2-(cG-qf)^2)if rG>100 then rE=false elseif rF<=rB or rB==-1 then aR=true;rs=true else aR=false;rs=true end end;if not rE and t then if rB>=rt then aR=true else aR=false end;rs=true end end end;if not dy then d3.cmdThrottle(0)end;bL:setTargetGroundAltitude(500)bL:activateGroundEngineAltitudeStabilization(500)br=true;pF=cC;if pF>-1 then d8=p;if dr<1 or dq:normalize():dot(ds)<0 then aX=false;aW=false;bc=true;if ca then d.control.extendLandingGears()dT("grOut","LG",1)end;bL:setTargetGroundAltitude(W)ct=0;aR=true else aR=true end elseif kV and dq:normalize():dot(-jg)<0.999 then aR=true elseif dt<-L and not rs then aR=true elseif not rs then aR=false end end;if aY or cA then local kZ,fG,fF;if ba~=nil then kZ,fG,fF=cY:getPlanetarySystem(0):castIntersections(du,(ba-du):normalize(),function(fq)return fq.radius+fq.noAtmosphericDensityAltitude end)end;if dw then if cG>=b0-50 then aY=false;if not aU and not bg then aR=true;d3.cmdThrottle(0)end else b0=antigrav.getBaseAltitude()end elseif by(qL)<15 and cG/b0>0.75 then aY=false;if not cA then if dy and not u then d.control.cancelCurrentControlMasterMode()end elseif cA and dr<c8 then aU=true;cA=false;aW=false;aY=false;d3.cmdThrottle(0)elseif cA then d3.cmdThrottle(0)aR=true end elseif cA and cF==0 and cq~=nil and(kZ==nil or kZ.name==cq.name)then aU=true;cA=false;aW=false;aY=false;if not dy then d3.cmdThrottle(0)end;b1=true end end;local rH=cC>-1;local rI=dz;if(bg or cA or dE)and not rH and dr>aC and cF>0.01 then local mb=math.rad(by(dA))rI=dz*by(math.cos(mb))+q8*math.sin(mb)end;local rJ=bK(qL-rI,-K*0.80,K*0.80)if cF<0.01 and bg then rJ=bK(qL-rI,-85,M)elseif cF<0.01 then rJ=bK(qL-rI,-M,M)end;if by(dA)<5 or bg or dE or aX or rH or aW then if r3==nil then r3=pid.new(5*0.01,0,5*0.1)end;r3:inject(rJ)local qN=r3:get()cc=cc+qN end end;if antigrav~=nil and(antigrav and not q and cG<200000)then if bl==nil or bl<1000 then bl=1000 end;if rK~=bl then rK=bl;antigrav.setBaseAltitude(rK)end end end;function pd.ToggleIntoOrbit()dh=false;po=nil;pp=nil;pu=0;if cF==0 then if bp then dT("orOff","AP")bp=false;pq=false;pt=nil;d8=p;if aW then aW=false;aY=false end;df.VectorToTarget=false;df.AutopilotAlign=false;ps=false elseif dG then dT("orOn","AP")bp=true;d8=true;if pt==nil then pt=iu end;if aW then aW=false;aY=false end else ck="Unable to engage auto-orbit, not near a planet"end else bp=false;pq=false;pt=nil;d8=p;if aW then aW=false end;df.VectorToTarget=false;df.AutopilotAlign=false;ps=false end end;function pd.ToggleVerticalTakeoff()aW=false;if a_ then kV=true;aZ=false;aY=false;aX=true;d8=true;ct=0;if cE and cC==-1 then aX=false;aW=true;ct=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)d3.cmdCruise(bz(dc))end else dh=false;bc=false;d.control.retractLandingGears()bL:setTargetGroundAltitude(V)aR=true end;a_=not a_ end;function pd.checkLOS(pW)local kZ,fF,fG=cY:getPlanetarySystem(0):castIntersections(du,pW,function(fq)if fq.noAtmosphericDensityAltitude>0 then return fq.radius+fq.noAtmosphericDensityAltitude else return fq.radius+fq.surfaceMaxAltitude*1.5 end end)local k_=fF;if fG~=nil and fF~=nil then k_=math.min(fG,fF)end;if k_~=nil then return kZ,k_ else return nil,nil end end;function pd.ToggleAutopilot()local function rL(bn)dH=false;bg=not bg;if bg then aV=false;if not aW and not bn then d3.ToggleAltitudeHold()end end;l2="Proceeding to Waypoint"end;local rM=false;if bX-pn<1.5 and cF>0 then if not dk then ck="No space engines detected, Orbital Hop not supported"return end;if iu.hasAtmosphere then if cF>0 then b0=iu.noAtmosphericDensityAltitude+R;dT("orH","OH")end;pn=-1;if aU or bg or bp then return end end else pn=bX end;qB=false;if(bb>0 or#pv>0)and not aU and not bg and not cA and not bp then if 0.5*d:maxForceForward()/b.g()<cJ then ck="WARNING: Heavy Loads may affect autopilot performance."cw=5 end;if#pv>0 and not cB then bb=pv[1]d2.UpdateAutopilotTarget()table.remove(pv,1)ck="Route Autopilot in Progress"local q1=li.position-du;local rh=q1:project_on_plane(ds):len()if rh>50000 and li.planetname==iu.name then rM=true end end;d2.UpdateAutopilotTarget()d3.showWayPoint(cq,ba)if li~=nil then bj=nil;bn=li.planetname=="Space"if bn then dT("apSpc","AP")if cF~=0 then cA=true;d3.ToggleAltitudeHold()else aU=true end elseif iu.name==li.planetname then kV=true;if cF>0 then if not bg then dT("vtt","AP")rL(bn)if rM then b0=iu.noAtmosphericDensityAltitude+R end end else dT("apOn","AP")if not(cq.name==iu.name and cG<p5*1.5)then dh=false;aU=true elseif not cE then if bp then d3.ToggleIntoOrbit()end;dg=iu.noAtmosphericDensityAltitude+R;ps=true;df.AutopilotAlign=true;df.VectorToTarget=true;pq=false;if not bp then d3.ToggleIntoOrbit()end end end else dT("apP","AP")aS=false;aT=false;if cF~=0 then cA=true;d3.ToggleAltitudeHold()else aU=true end end elseif cF==0 then if li==nil and(cq.name==iu.name and dG)and not bp then qU=false;dh=false;pq=false;d3.ToggleIntoOrbit()else dT("apP","AP")aU=true;aS=false;aT=false;b2=false;ci=false;aW=false;aX=false;aZ=false;aY=false;c7=false;bj=nil;qU=false end else dT("apP","AP")cA=true;d3.ToggleAltitudeHold()end else dT("apOff","AP")d3.ResetAutopilots(1)end end;function pd.routeWP(rN,rO,rP)if rP then if rP==1 then pv={}pv=dW(pv,bu)if#pv>0 then ck="Route Loaded"else ck="No Saved Route found on Databank"end;return pv else bu={}bu=dW(bu,pv)ck="Route Saved"ep()return end end;if rN then return pv end;if rO then pv={}ck="Current Route Cleared"else pv[#pv+1]=bb;ck="Added "..li.name.." to route. "end;return pv end;function pd.cmdThrottle(eM,rQ)if bL:getAxisCommandType(0)~=axisCommandType.byThrottle and not rQ then d.control.cancelCurrentControlMasterMode()end;bL:setThrottleCommand(axisCommandId.longitudinal,eM)c2=bK(bT(eM*100,0)/100,-1,1)dx=nil end;function pd.cmdCruise(eM,rQ)if bL:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rQ then d.control.cancelCurrentControlMasterMode()end;bL:setTargetSpeedCommand(axisCommandId.longitudinal,eM)dx=eM end;function pd.ToggleLockPitch()if bj==nil then dT("lkPOn","LP")if not cj then bj=dz else bj=O end;aY=false;aW=false;aX=false else dT("lkPOff","LP")bj=nil end end;function pd.ToggleAltitudeHold()if bX-pm<1.5 then if iu.hasAtmosphere then if cF>0 then b0=iu.spaceEngineMinAltitude-0.01*iu.noAtmosphericDensityAltitude;dT("11","EP")else if dG then b0=iu.noAtmosphericDensityAltitude+R;dg=b0;ps=true;if not bp then d3.ToggleIntoOrbit()end;pq=true end end;pm=-1;if aW or bp or a_ then return end end else pm=bX end;if dG and cF==0 then dg=cG;ps=true;pq=true;d3.ToggleIntoOrbit()if bp then pm=bX else pm=0 end;return end;aW=not aW;aX=false;aZ=false;if aW then aU=false;aT=false;aS=false;ci=false;d8=true;bj=nil;dh=false;if cC~=-1 and dr<20 then dT("lfs","LS")aY=true;if pm>-1 then b0=cG+U end;bc=false;d.control.retractLandingGears()aR=true;bL:setTargetGroundAltitude(V)if aQ and dv then d3.ToggleVerticalTakeoff()end else dT("altOn","AH")aY=false;if pm>-1 then if dG then b0=cG end end;if a_ then d3.ToggleVerticalTakeoff()end end;if cA then b0=100000 end else dT("altOff","AH")if bp then d3.ToggleIntoOrbit()end;if a_ then d3.ToggleVerticalTakeoff()end;d8=p;aY=false;bg=false;pm=0 end end;function pd.ResetAutopilots(pd)if pd then cA=false;aU=false;b2=false;c7=false;b0=cG;qB=false end;bg=false;aY=false;aZ=false;aT=false;aX=false;rR=false;dE=nil;if not dw then aW=false;bj=nil end;if a_ then d3.ToggleVerticalTakeoff()end;if bp then d3.ToggleIntoOrbit()end;d8=p;cz=false;cB=false;ct=0 end;function pd.BrakeToggle()aR=not aR;if aX then aX=false;d8=p end;if aR then dT("bkOn","B",1)d3.ResetAutopilots()else dT("bkOff","B",1)end end;function pd.BeginReentry()if aZ then ck="Re-Entry cancelled"dT("reOff","RE")aZ=false;d8=p;aW=false elseif not iu.hasAtmosphere then ck="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"cw=5 elseif not c9 then aZ=true;if bL:getAxisCommandType(0)~=rS.cruise then d.control.cancelCurrentControlMasterMode()end;d8=true;aR=false;ck="Beginning Parachute Re-Entry - Strap In.  Target speed: "..dc;dT("par","RE")else aZ=true;aW=true;d8=true;aR=false;b0=iu.surfaceMaxAltitude+X;if b0>iu.spaceEngineMinAltitude then b0=iu.spaceEngineMinAltitude-0.01*iu.noAtmosphericDensityAltitude end;local ea=eh(b0)ck="Beginning Re-entry.  Target speed: "..dc.." Target Altitude: "..ea;dT("glide","RE")d3.cmdCruise(bz(dc))end;aY=false end;function pd.ToggleAntigrav()if antigrav and not q then if dw then dT("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bl==nil then bl=cG end;if bl<1000 then bl=1000 end;dT("aggOn","AG")antigrav.activate()antigrav.show()end end end;cC=pA()return pd end;local function rT()local rU={}local rV=true;local rW=5;local rX=5;local rY=rW;local rZ=rX;function rU.startControl(r_)local function s0(pN)local bW=1;local function s1(s2,pN)local s3={iu.surfaceMaxAltitude+100,iu.spaceEngineMinAltitude-0.01*iu.noAtmosphericDensityAltitude,iu.noAtmosphericDensityAltitude+R,iu.radius*(Q-1)+iu.noAtmosphericDensityAltitude}local s4=s2;for eQ,d_ in ipairs(s3)do if pN and s4>d_ then s2=d_ elseif s2<d_ and not pN then s2=d_;break end end;return s2 end;if pN then bW=-1 end;if not q and dw then if cj and pN then bl=1000 elseif bl~=nil then bl=bl+bW*rX;if bl<1000 then bl=1000 end;if aW and bl<b0+10 and bl>b0-10 then b0=bl end else bl=rK+bW*100 end elseif aW or a_ or bp then if bp then if cj then dg=s1(dg,pN)else dg=dg+bW*rW end;if dg<iu.noAtmosphericDensityAltitude then dg=iu.noAtmosphericDensityAltitude end else if cj and cE then b0=s1(b0,pN)else b0=b0+bW*rW end end else bL:updateTargetGroundAltitudeFromActionStart(bW*1.0)end end;local function s5(s6)if not cE then ck="Flight Assist in Atmo only"return end;local ey=type(s6)if dE==nil then if ey=="table"then if aU or bg then d3.ToggleAutopilot()end;dT("180On","BR")elseif s6==1 then dT("bnkLft","BR")else dT("bnkRht","BR")end;if not aW and not aU and not bg then d3.ToggleAltitudeHold()if ey~="table"then s6=s6+1 end end;dE=s6 else dT("180Off","BR")dE=nil end end;if r_=="gear"then bc=not bc;if bc then bg=false;bj=nil;d3.cmdThrottle(0)if vBooster or hover then if cE and cC==-1 then dT("bklOn","BL")kV=true;aZ=false;aY=false;a_=false;aW=false;aX=true;d8=true;bc=false else if ca then dT("grOut","LG",1)d.control.extendLandingGears()end;bL:setTargetGroundAltitude(W)if cE then aR=true end end end;if ca and not aX and not(vBooster or hover)then dT("grOut","LG",1)d.control.extendLandingGears()end else if ca then dT("grIn","LG",1)d.control.retractLandingGears()end;bL:setTargetGroundAltitude(V)end elseif r_=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif r_=="forward"then cb=cb-1 elseif r_=="backward"then if oy then s5(-dq*5000)else cb=cb+1 end elseif r_=="left"then if oy then s5(1)else ce=ce-1 end elseif r_=="right"then if oy then s5(3)else ce=ce+1 end elseif r_=="yawright"then cf=cf-1 elseif r_=="yawleft"then cf=cf+1 elseif r_=="straferight"then bL:updateCommandFromActionStart(axisCommandId.lateral,1.0)bo=1 elseif r_=="strafeleft"then bL:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bo=-1 elseif r_=="up"then ct=ct+1;bL:deactivateGroundEngineAltitudeStabilization()bL:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif r_=="down"then ct=ct-1;bL:deactivateGroundEngineAltitudeStabilization()bL:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif r_=="groundaltitudeup"then s0()elseif r_=="groundaltitudedown"then s0(true)elseif r_=="option1"then s7=false;if oy and cj then local s8=""for bw=1,#dM do s8=s8 .."| Name: "..a.getPlayerName(dM[bw]).." Mass: "..bT(b.getBoardedPlayerMass(dM[bw])/1000,1).."t "end;a.print("Onboard: "..s8)return end;d2.adjustAutopilotTargetIndex()elseif r_=="option2"then s7=false;if oy and cj then for bw=1,#dM do b.forceDeboard(dM[bw])end;ck="Deboarded All Passengers"return end;d2.adjustAutopilotTargetIndex(1)elseif r_=="option3"then local function s9()rV=not rV;if not rV then dT("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sa,atmofueltank_size,"Atmo Fuel","fuel_container")sb=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sc,spacefueltank_size,"Space Fuel","fuel_container")sd=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(se,rocketfueltank_size,"Rocket Fuel","fuel_container")sf=_autoconf.panels[_autoconf.panels_size]end;sg=a.createWidgetPanel("Docking")sh=a.createWidget(sg,"parenting")a.addDataToWidget(c.getDataId(),sh)si=a.createWidgetPanel("Core combat stress")sj=a.createWidget(si,"core_stress")a.addDataToWidget(b.getDataId(),sj)if lr~=nil then lr.show()end else dT("hud","DH")c.hide()b.hide()if sb~=nil then bM(sb)sb=nil end;if sg~=nil then bM(sg)sg=nil end;if si~=nil then bM(si)si=nil end;if sd~=nil then bM(sd)sd=nil end;if sf~=nil then bM(sf)sf=nil end;if lr~=nil then lr.hide()end end end;s7=false;if oy and cj then local s8=""for bw=1,#dN do s8=s8 .."| ID: "..dN[bw].." Mass: "..bT(b.getDockedConstructMass(dN[bw])/1000,1).."t "end;a.print("Docked Ships: "..s8)return end;if y then if x then x=false else x=true end end;s9()elseif r_=="option4"then s7=false;if oy and cj then for bw=1,#dN do b.forceUndock(dN[bw])end;ck="Undocked all ships"return end;dE=nil;d3.ToggleAutopilot()elseif r_=="option5"then s7=false;d3.ToggleLockPitch()elseif r_=="option6"then s7=false;if oy and cj then if lr then local sk=lr.getVentingCooldown()if sk>0 then ck="Cannot vent again for "..sk.." seconds"return end;if lr.getShieldHitpoints()<lr.getMaxShieldHitpoints()then lr.startVenting()ck="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else ck="Shields already at max hitpoints"end;return else ck="No shield found"return end end;d3.ToggleAltitudeHold()elseif r_=="option7"then s7=false;if oy and cj then if lr then lr.toggle()return else ck="No shield found"return end end;F=not F;if F then ck="Collision System Enabled"else ck="Collision System Secured"end elseif r_=="option8"then s7=false;if oy and cj then if bb>0 and li~=nil then d3.routeWP()else ck="Select a saved wp on IPH to add to or remove from route"end;return end;br=not br;if not br then ck="DeCoupled Mode - Ground Stabilization off"bL:deactivateGroundEngineAltitudeStabilization()dT("gsOff","GS")else ck="Coupled Mode - Ground Stabilization on"bL:activateGroundEngineAltitudeStabilization(sl)d:setEngineForceCommand('hover',vec3(),1)dT("gsOn","GS")end elseif r_=="option9"then s7=false;if oy and cj then bL:resetCommand(axisCommandId.longitudinal)bL:resetCommand(axisCommandId.lateral)bL:resetCommand(axisCommandId.vertical)d3.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cL=gyro.getState()==1;if cL then dT("gyOn","GA")else dT("gyOff","GA")end else ck="No gyro found"end elseif r_=="lshift"then dJ=false;if oy then cj=true end;if bQ()==1 then cj=true;b8=bQ()bP(1)elseif bG()==1 and z then cj=true;d7=false;d6=false end elseif r_=="brake"then if aP or oy then d3.BrakeToggle()elseif not aR then d3.BrakeToggle()else aR=true end elseif r_=="lalt"then s7=true;oy=true;if bG()==0 and not i and g=="keyboard"then bP(1)end elseif r_=="booster"then if n then d:toggleBoosters()elseif not cl then if not sm then d:toggleBoosters()sm=true end;cl=true else if sm then d:toggleBoosters()sm=false end;cl=false end elseif r_=="stopengines"then local function sn()if bX-bY<1.5 then dT("clear","CA")b1=false;b3=false;b4=false;aU=false;b2=false;b6="Aligning"aS=false;aT=false;dE=nil;aW=false;aZ=false;aX=false;aR=false;aY=false;a_=false;ci=false;c7=false;cz=false;cA=false;c9=false;d8=p;bg=false;aV=false;cL=false;bj=nil;bp=false end end;sn()bY=bX;if bL:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if c2~=0 then bL:resetCommand(axisCommandId.longitudinal)d3.cmdThrottle(0)else d3.cmdThrottle(100)end else if bL:getTargetSpeed(axisCommandId.longitudinal)~=0 then bL:resetCommand(axisCommandId.longitudinal)else if cE then d3.cmdCruise(S)else d3.cmdCruise(Y*3.6)end end end elseif r_=="speedup"then d3.changeSpd()elseif r_=="speeddown"then d3.changeSpd(true)elseif r_=="antigravity"and not q then if antigrav~=nil then d3.ToggleAntigrav()else ck="No antigrav found"end end end;function rU.stopControl(r_)local function so()if not q and dw then rZ=rX end;if aW or a_ or bp then rY=rW end end;if r_=="forward"then cb=0 elseif r_=="backward"then cb=0 elseif r_=="left"then if dE then if dE==2 then dE=-2 else dE=-1 end end;ce=0 elseif r_=="right"then if dE then if dE==4 then dE=-2 else dE=-1 end end;ce=0 elseif r_=="yawright"then cf=0 elseif r_=="yawleft"then cf=0 elseif r_=="straferight"then bL:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bo=0 elseif r_=="strafeleft"then bL:updateCommandFromActionStop(axisCommandId.lateral,1.0)bo=0 elseif r_=="up"then ct=0;bL:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if br then bL:activateGroundEngineAltitudeStabilization(sl)d:setEngineForceCommand('hover',vec3(),1)end elseif r_=="down"then ct=0;bL:updateCommandFromActionStop(axisCommandId.vertical,1.0)if br then bL:activateGroundEngineAltitudeStabilization(sl)d:setEngineForceCommand('hover',vec3(),1)end elseif r_=="groundaltitudeup"then so()s7=false elseif r_=="groundaltitudedown"then so()s7=false elseif r_=="lshift"then if bQ()==1 then cu=0;cv=0;bP(b8)elseif bG()==1 and z then d7=false;d6=false end;cj=false elseif r_=="brake"then if not aP and not oy then if aR then d3.BrakeToggle()else aR=false end end elseif r_=="lalt"then if bG()==0 and i then if s7 then if bQ()==1 then bP(0)else bP(1)end else s7=true end elseif bG()==0 and not i and g=="keyboard"then bP(0)end;oy=false end end;function rU.loopControl(r_)local function sp(pN)local bW=1;if pN then bW=-1 end;if not q and dw then if bl~=nil then bl=bl+bW*rZ;if bl<1000 then bl=1000 end;if aW and bl<b0+10 and bl>b0-10 then b0=bl end;rZ=bK(rZ*1.05,rX,50)aR=false else bl=rK+bW*100;aR=false end elseif aW or a_ or bp then if bp then dg=dg+bW*rY;if dg<iu.noAtmosphericDensityAltitude then dg=iu.noAtmosphericDensityAltitude end else b0=b0+bW*rY end;rY=bK(rY*1.05,rW,50)else bL:updateTargetGroundAltitudeFromActionLoop(bW*1.0)end end;local function sq(pN)local bW=1;if pN then bW=-1 end;if not cj then if u and not oy then c2=bK(c2+bW*aw/100,-1,1)else bL:updateCommandFromActionLoop(axisCommandId.longitudinal,bW*aw)end end end;if r_=="groundaltitudeup"then if not cj then sp()end elseif r_=="groundaltitudedown"then if not cj then sp(true)end elseif r_=="speedup"then sq()elseif r_=="speeddown"then sq(true)end end;function rU.inputTextControl(ea)local function sr(ss,gq,jZ)local function st(gq)local bU=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local eF='::pos{'..bU..','..bU..','..bU..','..bU..','..bU..'}'local eU,eV,f1,f2,f3=bI(gq,eF)if eU=="0"and eV=="0"then return vec3(bS(f1),bS(f2),bS(f3))end;f2=math.rad(f2)f1=math.rad(f1)local iu=e[bS(eU)][bS(eV)]local fQ=math.cos(f1)local su=vec3(fQ*math.cos(f2),fQ*math.sin(f2),math.sin(f1))return iu.center+(iu.radius+f3)*su end;local ne=st(gq)return d2.AddNewLocation(ss,ne,jZ)end;local bw;local sv,sw=nil,nil;local sx="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"bw=string.find(ea," ")sv=ea;if bw~=nil then sv=string.sub(ea,0,bw-1)sw=string.sub(ea,bw+1)end;if sv=="/help"or sv=="/commands"then for o4 in string.gmatch(sx,"([^\n]+)")do a.print(o4)end;return elseif sv=="/setname"then if sw==nil or sw==""then ck="Usage: ah-setname Newname"return end;if bb>0 and li~=nil then d2.UpdatePosition(sw)else ck="Select a saved target to rename first"end elseif lr and sv=="/resist"then if not lr then ck="No shield found"return elseif sw==nil or lr.getResistancesCooldown()>0 then ck="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local bU=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local eF=bU..', '..bU..', '..bU..', '..bU;local sy,sz,sA,sB=bI(sw,eF)if sB==nil or sy+sz+sA+sB>0.6 then ck="Improperly formatted or total exceeds 0.6"return end;if lr.setResistances(sy,sz,sA,sB)==1 then ck="Shield Resistances set"else ck="Resistance setting failed."end elseif sv=="/addlocation"or string.find(ea,"::pos")~=nil then local jZ=false;local ss="0-Temp"if sw==nil or sw==""then sw=sv;jZ=true end;bw=string.find(sw,"::")if not jZ then ss=string.sub(sw,1,bw-2)end;local gq=string.sub(sw,bw)sr(ss,gq,jZ)elseif sv=="/agg"then if sw==nil or sw==""then ck="Usage: /agg targetheight"return end;sw=bS(sw)if sw<1000 then sw=1000 end;bl=sw;ck="AGG Target Height set to "..sw elseif sv=="/G"then if sw==nil or sw==""then ck="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sw=="dump"then for dZ,d_ in pairs(e0())do if type(d_.get())=="boolean"then if d_.get()==true then a.print(dZ.." true")else a.print(dZ.." false")end elseif d_.get()==nil then a.print(dZ.." nil")else a.print(dZ.." "..d_.get())end end;return end;bw=string.find(sw," ")local sC=string.sub(sw,0,bw-1)local sD=string.sub(sw,bw+1)for dZ,d_ in pairs(e0())do if dZ==sC then ck="Variable "..sC.." changed to "..sD;local sE=type(d_.get())if sE=="number"then sD=bS(sD)if dZ=="AtmoSpeedLimit"then dc=sD end elseif sE=="boolean"then if string.lower(sD)=="true"then sD=true else sD=false end end;d_.set(sD)return end end;ck="No such global variable: "..sC elseif sv=="/deletewp"then if bb>0 and li~=nil then d2.ClearCurrentPosition()else ck="Select a custom wp to delete first in IPH"end elseif sv=="/copydatabank"then if dbHud_2 then ep(true)else ck="Spare Databank required to copy databank"end elseif sv=="/iphWP"then if bb>0 then a.print(d3.showWayPoint(cq,ba,true))ck="::pos waypoint shown in lua chat"else ck="No target selected in IPH"end end end;return rU end;function script.onStart()local sF=false;local function sG()local function sH(sI)local sJ=dbHud_1.hasKey;for dZ,d_ in pairs(sI)do if sJ(dZ)then local eH=bB(dbHud_1.getStringValue(dZ))if eH~=nil then d_.set(eH)sF=true end end end end;if dbHud_1 then if not f then sH(e0())coroutine.yield()sH(bv)else sH(bv)ck="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"cw=5;sF=false end;coroutine.yield()if sF then ck="Loaded Saved Variables"cQ=a5;cR=a6;aP=j;g=string.lower(g)d8=p;dc=S;cM=[[rgb(]]..bz(b_+0.5)..","..bz(c1+0.5)..","..bz(c0+0.5)..[[)]]cN=[[rgb(]]..bz(b_*0.9+0.5)..","..bz(c1*0.9+0.5)..","..bz(c0*0.9+0.5)..[[)]]elseif not f then ck="No Saved Variables Found - Exit HUD to save settings"end;if bt<1.500 then if R<2000 then ck="Updating LowOrbitHeight to new minimum default of 2000."R=2000 end end;bt=VERSION_NUMBER else ck="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bm+180<bX then bk=0 end;bm=bX;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then ck="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"cw=7 end;if antigrav and not q then if bl==nil then bl=cG end;antigrav.setBaseAltitude(bl)end;l2="Proceeding to Waypoint"end;local function sK()local function sL(sM,sN)if sM>sN then sN=sM end;local sO,sP=0,0;if a3>0 then sO=a3*0.05 end;if a4>0 then sP=a4*0.05 end;sN=sN*(1-(sO+sP))return sN end;local sQ=b.getElementNameById;local sR=am~=0 and an~=0;for dZ in pairs(cH)do local type=b.getElementTypeById(cH[dZ])if bI(type,'^.*Atmospheric Engine$')then if bI(tostring(b.getElementTagsById(cH[dZ])),'^.*vertical.*$')and b.getElementForwardById(cH[dZ])[3]>0 then dv=true end end;if bI(type,'^.*Space Engine$')then dk=true;if bI(tostring(b.getElementTagsById(cH[dZ])),'^.*vertical.*$')then local sS=b.getElementForwardById(cH[dZ])if sS[3]<0 then di=true else dj=true end end end;if type=="Landing Gear"then ca=true end;if type=="Dynamic Core Unit"then local sT=bD(cH[dZ])if sT>10000 then bZ=110 elseif sT>1000 then bZ=55 elseif sT>150 then bZ=27 end end;cV=cV+bD(cH[dZ])if sR and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local sT=bD(cH[dZ])local nW=bF(cH[dZ])local sM=0;local j1=bJ()if type=="Atmospheric Fuel Tank"then local sN=400;local sU=35.03;if sT>10000 then sN=51200;sU=5480 elseif sT>1300 then sN=6400;sU=988.67 elseif sT>150 then sN=1600;sU=182.67 end;sM=nW-sU;if a0>0 then sN=sN+sN*a0*0.2 end;sN=sL(sM,sN)cS[#cS+1]={cH[dZ],sQ(cH[dZ]),sN,sU,sM,j1}end;if type=="Rocket Fuel Tank"then local sN=320;local sU=173.42;if sT>65000 then sN=40000;sU=25740 elseif sT>6000 then sN=5120;sU=4720 elseif sT>700 then sN=640;sU=886.72 end;sM=nW-sU;if a2>0 then sN=sN+sN*a2*0.1 end;sN=sL(sM,sN)cU[#cU+1]={cH[dZ],sQ(cH[dZ]),sN,sU,sM,j1}end;if type=="Space Fuel Tank"then local sN=600;local sU=35.03;if sT>10000 then sN=76800;sU=5480 elseif sT>1300 then sN=9600;sU=988.67 elseif sT>150 then sN=2400;sU=182.67 end;sM=nW-sU;if a1>0 then sN=sN+sN*a1*0.2 end;sN=sL(sM,sN)cT[#cT+1]={cH[dZ],sQ(cH[dZ]),sN,sU,sM,j1}end end end;if not dv then a_,aQ=false,false end end;local function sV()if gyro~=nil then cL=gyro.getState()==1 end;if not br then bL:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then bP(1)else bP(0)end;if door and(cE or not cE and cG<10000)then for eQ,d_ in pairs(door)do d_.toggle()end end;if switch then for eQ,d_ in pairs(switch)do d_.toggle()end end;if forcefield and(cE or not cE==0 and cG<10000)then for eQ,d_ in pairs(forcefield)do d_.toggle()end end;if antigrav then dw=antigrav.getState()==1;if dw and not q then antigrav.show()end end;if bG()==1 and k then a.freeze(1)else a.freeze(0)end;if ca then bc=d.control.isAnyLandingGearExtended()==1;if bc then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if cC~=-1 or not cE and dp:len()<50 then aR=true;bc=true;if ca then d.control.extendLandingGears()end else aR=false end;bL:setTargetGroundAltitude(d9)if cE and cC~=-1 then c_=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;sW=cE end;local function sX()local sY={}local function sZ()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local s_={[1]=4480,[6]=4480,[7]=6270}for t0,t1 in pairs(e)do e[t0][0]=sZ()e[t0][0].systemId=t0;sY[t0]={}for t2,iu in pairs(e[t0])do iu.gravity=iu.gravity/9.8;iu.center=vec3(iu.center)iu.name=iu.name[1]iu.noAtmosphericDensityAltitude=iu.atmosphereThickness or iu.atmosphereRadius-iu.radius;iu.spaceEngineMinAltitude=s_[iu.id]or 0.68377*(iu.atmosphereThickness or iu.atmosphereRadius-iu.radius)iu.planetarySystemId=t0;iu.bodyId=iu.id;sY[t0][t2]=iu;if lY==nil or iu.center.x<lY then lY=iu.center.x end;if lX==nil or iu.center.x>lX then lX=iu.center.x end;if m0==nil or iu.center.y<m0 then m0=iu.center.y end;if l_==nil or iu.center.y>l_ then l_=iu.center.y end;if iu.center and iu.name~="Space"then dO[#dO+1]=iu end end end;cX=et()cY=cX(sY)cZ=fT()d0=gm()d2=oE()end;t3=false;t4=coroutine.create(function()bL:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})sG()coroutine.yield()sK()coroutine.yield()d3=pc()sV()coroutine.yield()sX()d4=gM()d1=i9()d1.ButtonSetup()d5=rT()coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aK)c.setTimer("radarTick",aK)c.setTimer("hudTick",aL)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)dT("start","SU")end)coroutine.resume(t4)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(cF>0 or cF==0 and cG<10000)then for eQ,d_ in pairs(door)do d_.toggle()end end;if switch then for eQ,d_ in pairs(switch)do d_.toggle()end end;if forcefield and(cF>0 or cF==0 and cG<10000)then for eQ,d_ in pairs(forcefield)do d_.toggle()end end;x=dQ;ep()if nw then nw.activate()end;if A then d3.showWayPoint(iu,du)end;dT("stop","SU")end;function script.onTick(t5)local t6=nil;if t5=="contact"then if not t7 then t7=0 end;if bX>t7+10 then ck="Radar Contact"dT("rdrCon","RC")t7=bX end;c.stopTimer("contact")elseif t5=="tenthSecond"then local function t8()local t9=a.createData;local ta=a.createWidget;tb=a.createWidgetPanel("Interplanetary Helper")tc=ta(tb,"value")td=t9('{"label": "Target Planet", "value": "N/A", "u":""}')bO(td,tc)te=ta(tb,"value")tf=t9('{"label": "distance", "value": "N/A", "u":""}')bO(tf,te)p2=ta(tb,"value")p1=t9('{"label": "Travel Time", "value": "N/A", "u":""}')bO(p1,p2)p0=ta(tb,"value")o_=t9('{"label": "Maximum Mass", "value": "N/A", "u":""}')bO(o_,p0)p4=ta(tb,"value")p3=t9('{"label": "Target Altitude", "value": "N/A", "u":""}')bO(p3,p4)oX=ta(tb,"value")oW=t9('{"label": "Cur Brake distance", "value": "N/A", "u":""}')oV=ta(tb,"value")oU=t9('{"label": "Cur Brake Time", "value": "N/A", "u":""}')oT=ta(tb,"value")oS=t9('{"label": "Max Brake distance", "value": "N/A", "u":""}')oR=ta(tb,"value")oQ=t9('{"label": "Max Brake Time", "value": "N/A", "u":""}')oZ=ta(tb,"value")oY=t9('{"label": "Projected Altitude", "value": "N/A", "u":""}')if not cE then bO(oW,oX)bO(oU,oV)bO(oS,oT)bO(oQ,oR)bO(oY,oZ)end end;local function tg()bM(tb)tb=nil end;local function th()if not aU then if li==nil or li.planetname~=iu.name then qI=(cq.center-du):len()else qI=(li.position-du):len()end end;local gk=dr;local qQ=c.getThrottle()/100;if u then qQ=c2 end;local ti,tj=cZ.computeDistanceAndTime(dr,Y,cJ,d:maxForceForward()*qQ,_,0)local cm,cn;if not aV then cm,cn=d3.GetAutopilotBrakeDistanceAndTime(Y)else cm,cn=d3.GetAutopilotTBBrakeDistanceAndTime(Y)end;local eQ,tk;if not aV and gk>0 then eQ,tk=d3.GetAutopilotBrakeDistanceAndTime(gk)else eQ,tk=d3.GetAutopilotTBBrakeDistanceAndTime(gk)end;local tl=0;local tm=0;if b4 or not aU and gk>5 then tm=cZ.computeTravelTime(gk,0,qI)elseif cm+ti<qI then tl=qI-(cm+ti)tm=cZ.computeTravelTime(8333.0556,0,tl)else local tn=(qI-cm)/ti;ti=qI-cm;tj=tj*tn end;if li~=nil and li.planetname==iu.name and not aU then return tm elseif b3 then return tk elseif b4 then return tm+tk else return tj+cn+tm end end;local function to(nO,tp)if nO==nil then nO=b.g()end;nO=bT(nO,5)if tp~=nil and tp or(t6==nil or t6~=nO)then local gk=dp:len()local tq=bB(c.getData()).maxBrake;if tq~=nil and tq>0 and cE then tq=tq/bK(gk/100,0.1,1)tq=tq/cF;if cF>0.10 then if bk then bk=(bk+tq)/2 else bk=tq end end end;if tq~=nil and tq>0 then bi=tq end;t6=nO end end;to(nil,true)if dx~=nil then if bL:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or bL:getTargetSpeed(axisCommandId.longitudinal)~=dx then d3.cmdCruise(dx)else dx=nil end end;if b9~="None"then if tb==nil then t8()end;if b9~=nil then local tr=li~=nil;local ts=0.5*bk/cq:getGravity(cq.center+vec3(0,0,1)*cq.radius):len()ts=ts>1000000 and bT(ts/1000000,2).." kTons"or bT(ts/1000,2).." Tons"bN(td,'{"label": "Target", "value": "'..b9 ..'", "u":""}')l0=th()if tr and not aU then cx=(du-li.position):len()else cx=(ba-du):len()end;if not aV then cm,cn=d3.GetAutopilotBrakeDistanceAndTime(dr)co,cp=d3.GetAutopilotBrakeDistanceAndTime(Y)else cm,cn=d3.GetAutopilotTBBrakeDistanceAndTime(dr)co,cp=d3.GetAutopilotTBBrakeDistanceAndTime(Y)end;local kO=eh(cx)bN(tf,'{"label": "distance", "value": "'..kO..'"}')bN(p1,'{"label": "Travel Time", "value": "'..ek(l0)..'", "u":""}')kO=eh(cm)bN(oW,'{"label": "Cur Brake distance", "value": "'..kO..'"}')bN(oU,'{"label": "Cur Brake Time", "value": "'..ek(cn)..'", "u":""}')kO=eh(co)bN(oS,'{"label": "Max Brake distance", "value": "'..kO..'"}')bN(oQ,'{"label": "Max Brake Time", "value": "'..ek(cp)..'", "u":""}')bN(o_,'{"label": "Max Brake Mass", "value": "'..bA("%s",ts)..'", "u":""}')kO=eh(p5)bN(p3,'{"label": "Target Orbit", "value": "'..kO..'"}')if cF>0 and not sW then a.removeDataFromWidget(oQ,oR)a.removeDataFromWidget(oS,oT)a.removeDataFromWidget(oU,oV)a.removeDataFromWidget(oW,oX)a.removeDataFromWidget(oY,oZ)sW=true;if not dy and u and(aW or aZ or cB)then d3.cmdThrottle(1)aR=false;c6=false end end;if cF==0 and sW then if bN(oQ,oR)==1 then bO(oQ,oR)end;if bN(oS,oT)==1 then bO(oS,oT)end;if bN(oU,oV)==1 then bO(oU,oV)end;if bN(oW,oX)==1 then bO(oW,oX)end;if bN(oY,oZ)==1 then bO(oY,oZ)end;sW=false end end else tg()end;if warpdrive~=nil then if bB(warpdrive.getData()).destination~="Unknown"and bB(warpdrive.getData()).distance>400000 then warpdrive.show()tt=true else warpdrive.hide()tt=false end end;d1.TenthTick()elseif t5=="oneSecond"then local function tu(jc)local tv=0;cP=""local tw=cV;local tx=0;local ty=0;local tz=0;local j5=0;local j6=""local tA=b.getElementHitPointsById;for dZ in pairs(cH)do local sT=0;local tB=0;tB=bD(cH[dZ])sT=tA(cH[dZ])tx=tx+sT;if sT<tB then if sT==0 then tz=tz+1 else ty=ty+1 end;if cW and#cO==0 then ne=vec3(b.getElementPositionById(cH[dZ]))local e8=ne.x;local e9=ne.y;local hj=ne.z;table.insert(cO,b.spawnArrowSticker(e8,e9,hj+1,"down"))table.insert(cO,b.spawnArrowSticker(e8,e9,hj+1,"down"))b.rotateSticker(cO[2],0,0,90)table.insert(cO,b.spawnArrowSticker(e8+1,e9,hj,"north"))table.insert(cO,b.spawnArrowSticker(e8+1,e9,hj,"north"))b.rotateSticker(cO[4],90,90,0)table.insert(cO,b.spawnArrowSticker(e8-1,e9,hj,"south"))table.insert(cO,b.spawnArrowSticker(e8-1,e9,hj,"south"))b.rotateSticker(cO[6],90,-90,0)table.insert(cO,b.spawnArrowSticker(e8,e9-1,hj,"east"))table.insert(cO,b.spawnArrowSticker(e8,e9-1,hj,"east"))b.rotateSticker(cO[8],90,0,90)table.insert(cO,b.spawnArrowSticker(e8,e9+1,hj,"west"))table.insert(cO,b.spawnArrowSticker(e8,e9+1,hj,"west"))b.rotateSticker(cO[10],-90,0,90)table.insert(cO,cH[dZ])end elseif cW and#cO>0 and cO[11]==cH[dZ]then for j0 in pairs(cO)do b.deleteSticker(cO[j0])end;cO={}end end;tv=bz(tx/tw*100)if tv<100 then jc[#jc+1]=e7(0,0,"","pbright txt")j5=bz(tv*2.55)j6=bA("rgb(%d,%d,%d)",255-j5,j5,0)if tv<100 then jc[#jc+1]=e7("50%",1035,"Elemental Integrity: "..tv.."%","txtbig txtmid","fill:"..j6)if tz>0 then jc[#jc+1]=e7("50%",1055,"Disabled Modules: "..tz.." Damaged Modules: "..ty,"txtbig txtmid","fill:"..j6)elseif ty>0 then jc[#jc+1]=e7("50%",1055,"Damaged Modules: "..ty,"txtbig txtmid","fill:"..j6)end end end end;local function tC()if tD then if tE==nil and(i8~=nil or bc)then _autoconf.displayCategoryPanel(tD,weapon_size,"Weapons","weapon",true)tE=_autoconf.panels[_autoconf.panels_size]elseif tE~=nil and i8==nil and not bc then bM(tE)tE=nil end end end;dM=b.getPlayersOnBoard()dN=b.getDockedConstructs()tC()local jc={}d1.OneSecond(jc)if s then tu(jc)end;cy=table.concat(jc,"")collectgarbage("collect")elseif t5=="fiveSecond"then if not r then return end;cD=dbHud_1.getStringValue("SPBAutopilotTargetName")if cD~=nil and cD~=""and cD~="SatNavNotChanged"then local eH=bB(dbHud_1.getStringValue("SavedLocations"))if eH~=nil then bf=eH;local hC=-1;local p8;for dZ,d_ in pairs(bf)do if d_.name and d_.name=="SatNav Location"then hC=dZ;break end end;if hC~=-1 then p8=bf[hC]hC=-1;for dZ,d_ in pairs(e[0])do if d_.name and d_.name=="SatNav Location"then hC=dZ;break end end;if hC>-1 then e[0][hC]=p8 end;d2.UpdateAtlasLocationsList()ck=p8.name.." position updated"end end;for bw=1,#dB do if dB[bw].name==cD then bb=bw;a.print("Index = "..bb.." "..dB[bw].name)d2.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif t5=="msgTick"then local jc={}d1.DisplayMessage(jc,"empty")ck="empty"c.stopTimer("msgTick")cw=3 elseif t5=="animateTick"then d7=true;d6=false;cu=0;cv=0;c.stopTimer("animateTick")elseif t5=="hudTick"then d1.hudtick()elseif t5=="apTick"then d3.APTick()elseif t5=="radarTick"then d4.UpdateRadar()elseif t5=="tagTick"then if bs=="Off"then bs="All"elseif bs=="All"then bs="Longitude"elseif bs=="Longitude"then bs="Lateral"elseif bs=="Lateral"then bs="Vertical"else bs="Off"end;ck="Extra Engine Tags: "..bs;c.stopTimer("tagTick")end end;function script.onFlush()local function tF(tG,r1)local tH=vec3()local tI=vec3()if tG==axisCommandId.longitudinal then tH=vec3(b.getConstructOrientationForward())tI=dm elseif tG==axisCommandId.vertical then tH=vec3(b.getConstructOrientationUp())tI=dl elseif tG==axisCommandId.lateral then tH=vec3(b.getConstructOrientationRight())tI=dn else return vec3()end;local tJ=vec3(b.getWorldGravity())local tK=tJ:dot(tI)local tL=vec3(b.getWorldAirFrictionAcceleration())local tM=tL:dot(tI)local tN=dp:dot(tH)local tO=r1*constants.kph2m;if tP==nil then tP=pid.new(10,0,10.0)end;tP:inject(tO-tN)local tQ=tP:get()local tR=(tQ-tM-tK)*tI;return tR end;local function tS(tG,r1)local tH=vec3()local tI=vec3()if tG==axisCommandId.longitudinal then tH=vec3(b.getConstructOrientationForward())tI=dm elseif tG==axisCommandId.vertical then tH=vec3(b.getConstructOrientationUp())tI=dl elseif tG==axisCommandId.lateral then tH=vec3(b.getConstructOrientationRight())tI=dn else return vec3()end;local tJ=vec3(b.getWorldGravity())local tK=tJ:dot(tI)local tL=vec3(b.getWorldAirFrictionAcceleration())local tM=tL:dot(tI)local tN=dp:dot(tH)local tO=r1*constants.kph2m;if tT==nil then tT=pid.new(10,0,10.0)end;tT:inject(tO-tN)local tQ=tT:get()local tR=(tQ-tM-tK)*tI;return tR end;local function tU(tV,jf,oK)local tW=tV:cross(oK):normalize_inplace()local k2=math.acos(bK(tW:dot(-jf),-1,1))*constants.rad2deg;if tW:cross(-jf):dot(oK)<0 then k2=-k2 end;return k2 end;if antigrav and not q then if not dw and antigrav.getBaseAltitude()~=bl then antigrav.setBaseAltitude(bl)end end;dy=bL:getAxisCommandType(0)==axisCommandType.byThrottle;if dy and c6 then d3.cmdThrottle(0)c6=false elseif not dy and not c6 then c2=0;c6=true end;aF=math.max(aF,0.01)aG=math.max(aG,0.01)aA=math.max(aA,0.01)aE=math.max(aE,0.01)aH=math.max(aH,0.01)aI=math.max(aI,0.01)az=math.max(az,0.01)local tX=bK(cb+cc+a.getControlDeviceForwardInput(),-1,1)local tY=bK(ce+ch+a.getControlDeviceYawInput(),-1,1)local tZ=bK(cf+cd-a.getControlDeviceLeftRightInput(),-1,1)local t_=cg;ds=vec3(b.getWorldVertical())if ds==nil or ds:len()==0 then ds=(iu.center-du):normalize()end;dl=vec3(b.getConstructWorldOrientationUp())dm=vec3(b.getConstructWorldOrientationForward())dn=vec3(b.getConstructWorldOrientationRight())dq=vec3(b.getWorldVelocity())dp=vec3(b.getVelocity())du=vec3(b.getConstructWorldPos())cJ=b.getConstructMass()dr=vec3(dq):len()dt=-ds:dot(dq)dA=getRoll(ds,dm,dn)local u0=dA/180*math.pi;local u1=math.cos(u0)local u2=math.sin(u0)dz=tU(ds,dm,dn*u1+dl*u2)local u3=dq:normalize()local u4=by(dA)local u5=utils.sign(dA)local u6=vec3(b.getWorldAngularVelocity())local u7=tX*aF*dn+tY*aA*dm+tZ*aG*dl;if d8==true and ds:len()>0.01 then local u8=by(db-dA)if((aT or aZ or aX or cz or aW or bp)and u8>0 or cF>0.0 and u8<aB and p)and tY==0 and by(dz)<85 then local u9=db;local ua=az;if cF==0 then ua=ua/4;db=0;u9=0 end;if ub==nil then ub=pid.new(ua*0.01,0,ua*0.1)end;ub:inject(u9-dA)local uc=ub:get()u7=u7+uc*dm end end;local ud=1;local ue=0;local uf=1;local ug=a.getMouseWheel()if ug>0 then d3.changeSpd()elseif ug<0 then d3.changeSpd(true)else cK=true end;c3=0;if cE and u and dy then if uh==nil then uh=pid.new(0.5,0,1)end;uh:inject(dc/3.6-dq:dot(dm))local ui=uh:get()c5=bK(ui,-1,1)if c5<c2 and cF>0.005 then c4=true;bL:setThrottleCommand(axisCommandId.longitudinal,bK(c5,0.01,1))else c4=false;bL:setThrottleCommand(axisCommandId.longitudinal,c2)end;if uj==nil then uj=pid.new(1*0.01,0,1*0.1)end;uj:inject(dq:len()-dc/3.6)local uk=bK(uj:get(),0,1)if cF>0 and dt<-80 or cF>0.005 then c3=uk end;if c3>0 then if c4 and c5==0.01 then bL:setThrottleCommand(axisCommandId.longitudinal,0)end else c5=bK(c5,0.01,1)end;local ul=''local um=vec3()local un=tF(axisCommandId.vertical,ct*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",un,ue)local uo='thrust analog longitudinal 'if bs=="All"or bs=="Longitude"then uo=uo..aM end;local up=bL:getAxisCommandType(axisCommandId.longitudinal)local uq=bL:composeAxisAccelerationFromThrottle(uo,axisCommandId.longitudinal)local ur=tS(axisCommandId.lateral,bo*1000)ul=ul..' , '.."lateral airfoil , lateral ground "um=um+ur;if um:len()>constants.epsilon then d:setEngineForceCommand(ul,um,ue,'','','',uf)end;d:setEngineForceCommand(uo,uq,ud)local us='thrust analog vertical fueled 'local ut='thrust analog lateral fueled 'if bs=="All"or bs=="Lateral"then ut=ut..aN end;if bs=="All"or bs=="Vertical"then us=us..aO end;if ct~=0 or aX and aR or not bc and not br then d:setEngineForceCommand(us,un,ud)else d:setEngineForceCommand(us,vec3(),ud)end;if bo~=0 then d:setEngineForceCommand(ut,ur,ud)else d:setEngineForceCommand(ut,vec3(),ud)end;if t_==0 then t_=c3 end;local uu=-t_*(aH*dq+aI*u3)d:setEngineForceCommand('brake',uu)else if u then bL:setThrottleCommand(axisCommandId.longitudinal,c2)end;local r1=c.getAxisCommandValue(0)if not dy then if uj==nil then uj=pid.new(1*0.01,0,1*0.1)end;uj:inject(dq:len()-r1/3.6)local uk=bK(uj:get(),0,1)t_=bK(t_+uk,0,1)end;local uu=-t_*(aH*dq+aI*u3)d:setEngineForceCommand('brake',uu)local ul=''local um=vec3()local uv=false;local uo='thrust analog longitudinal 'if bs=="All"or bs=="Longitude"then uo=uo..aM end;local up=bL:getAxisCommandType(axisCommandId.longitudinal)if up==axisCommandType.byThrottle then local uq=bL:composeAxisAccelerationFromThrottle(uo,axisCommandId.longitudinal)d:setEngineForceCommand(uo,uq,ud)elseif up==axisCommandType.byTargetSpeed then local uq=bL:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ul=ul..' , '..uo;um=um+uq;if bL:getTargetSpeed(axisCommandId.longitudinal)==0 or bL:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-bL:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then uv=true end end;local ut='thrust analog lateral 'if bs=="All"or bs=="Lateral"then ut=ut..aN end;local uw=bL:getAxisCommandType(axisCommandId.lateral)if uw==axisCommandType.byThrottle then local ux=bL:composeAxisAccelerationFromThrottle(ut,axisCommandId.lateral)d:setEngineForceCommand(ut,ux,ud)elseif uw==axisCommandType.byTargetSpeed then local ur=bL:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ul=ul..' , '..ut;um=um+ur end;local us='thrust analog vertical 'if bs=="All"or bs=="Vertical"then us=us..aO end;local uy=bL:getAxisCommandType(axisCommandId.vertical)if uy==axisCommandType.byThrottle then local un=bL:composeAxisAccelerationFromThrottle(us,axisCommandId.vertical)if ct~=0 or aX and aR then d:setEngineForceCommand(us,un,ud,'airfoil','ground','',uf)else d:setEngineForceCommand(us,vec3(),ud)d:setEngineForceCommand('airfoil vertical',un,ud,'airfoil','','',uf)d:setEngineForceCommand('ground vertical',un,ud,'ground','','',uf)end elseif uy==axisCommandType.byTargetSpeed then if ct<0 then d:setEngineForceCommand('hover',vec3(),ud)end;local uz=bL:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ul=ul..' , '..us;um=um+uz end;if um:len()>constants.epsilon then if cg~=0 or uv or by(u3:dot(dm))<0.5 then ul=ul..', brake'end;d:setEngineForceCommand(ul,um,ue,'','','',uf)end end;local uA=aE*(u7-u6)local uB=vec3(b.getWorldAirFrictionAngularAcceleration())uA=uA-uB;d:setEngineTorqueCommand('torque',uA,ud,'airfoil','','',uf)d:setBoosterCommand('rocket_engine')if cl and not n then local gk=dp:len()local uC=0.15;if not dy then local uD=bL:getTargetSpeed(axisCommandId.longitudinal)if gk*3.6>uD*(1-uC)and sm then sm=false;d:toggleBoosters()elseif gk*3.6<uD*(1-uC)and not sm then sm=true;d:toggleBoosters()end else local qQ=c.getThrottle()if u then qQ=c2*100 end;local r1=qQ/100;if bE==0 then r1=r1*Y;if gk>=r1*(1-uC)and sm then sm=false;d:toggleBoosters()elseif gk<r1*(1-uC)and not sm then sm=true;d:toggleBoosters()end else local re=bz(dc)r1=r1*re/3.6;if gk>=r1*(1-uC)and sm then sm=false;d:toggleBoosters()elseif gk<r1*(1-uC)and not sm then sm=true;d:toggleBoosters()end end end end end;function script.onUpdate()if not t3 then local hZ=coroutine.status(t4)if hZ=="suspended"then local eM,h_=coroutine.resume(t4)if h_ then a.print("ERROR STARTUP: "..h_)end elseif hZ=="dead"then t3=true end end;if t3 then d:update()if not d6 and oA~=uE then a.setScreen(oA)end;uE=oA end end;function script.onActionStart(r_)d5.startControl(r_)end;function script.onActionStop(r_)d5.stopControl(r_)end;function script.onActionLoop(r_)d5.loopControl(r_)end;function script.onInputText(ea)d5.inputTextControl(ea)end;function script.onEnter(eV)if radar_1 and not cE and not dC then c.setTimer("contact",0.1)end end;function script.onLeave(eV)if radar_1 and F then if#dF>650 then eV=tostring(eV)dF[eV]=nil end end end;script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
