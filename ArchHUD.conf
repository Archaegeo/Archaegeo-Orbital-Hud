name: ArchHud - Archaegeo v1.7021 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=Navigator.new(system,core,unit)local b=require("atlas")require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")require("autoconf/custom/archhud/radarclass")script={}VERSION_NUMBER=1.7021;local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local function z(A,B)local C=10^(B or 0)return d(A*C+0.5)/C end;time=o()local D=o()local E=13;PrimaryR=SafeR;PrimaryB=SafeB;PrimaryG=SafeG;PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;apThrottleSet=false;minAutopilotSpeed=55;reentryMode=false;hasGear=false;local F=0;pitchInput2=0;yawInput2=0;local G=0;local H=0;brakeInput=0;rollInput2=0;followMode=false;holdingShift=false;msgText="empty"local I=5;local J=5;local K=I;local L=J;isBoosting=false;brakeDistance=0;brakeTime=0;local M=0;local N=0;autopilotTargetPlanet=nil;totalDistanceTrip=0;flightTime=0;upAmount=0;simulatedX=0;simulatedY=0;msgTimer=3;distance=0;lastOdometerOutput=""spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;local O=""inAtmo=j()>0;atmosDensity=j()coreAltitude=core.getAltitude()local P=core.getElementIdList()lastTravelTime=o()coreMass=core.getConstructMass()local Q=false;gyroIsOn=nil;rgb=[[rgb(]]..d(PrimaryR+0.5)..","..d(PrimaryG+0.5)..","..d(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..d(PrimaryR*0.9+0.5)..","..d(PrimaryG*0.9+0.5)..","..d(PrimaryB*0.9+0.5)..[[)]]local R={}damageMessage=""local S=true;resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;atmoTanks={}spaceTanks={}rocketTanks={}local T=0;repairArrows=false;local U=nil;galaxyReference=nil;Kinematic=nil;maxKinematicUp=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;local V=LandingGearGroundHeight;stalling=false;targetRoll=0;adjustedAtmoSpeedLimit=AtmoSpeedLimit;VtPitch=0;orbitMsg=nil;orbitalParams={VectorToTarget=false}OrbitTargetOrbit=0;OrbitAchieved=false;local W=false;SpaceEngineVertDn=false;SpaceEngines=false;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())coreVelocity=vec3(core.getVelocity())constructVelocity=vec3(core.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(core.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(core.getConstructWorldPos())UpVertAtmoEngine=false;antigravOn=false;setCruiseSpeed=nil;throttleMode=true;adjustedPitch=0;adjustedRoll=0;AtlasOrdered={}notPvPZone=false;pvpDist=50000;ReversalIsOn=nil;contacts={}nearPlanet=unit.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;apButtonsHovered=false;apScrollIndex=0;passengers=nil;ships=nil;planetAtlas={}scopeFOV=90;oldShowHud=showHud;function p(X)system.print(time..": "..X)end;local function Y(Z)local C=1;if Z then C=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and Q then local a0=PlayerThrottle;PlayerThrottle=z(q(PlayerThrottle+C*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and a0<0 then PlayerThrottle=0;Q=false end elseif AltIsOn then if atmosDensity>0 or Reentry then adjustedAtmoSpeedLimit=q(adjustedAtmoSpeedLimit+C*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+C*speedChangeLarge/3.6*100,0,8333.00)end else r:updateCommandFromActionStart(axisCommandId.longitudinal,C*speedChangeLarge)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*C*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not Z then C=1 else C=nil end;ATLAS.adjustAutopilotTargetIndex(C)end end end;function play(a1,a2,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..a1 .."|"..a2 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..a1 .."|"..a2 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..a1 .."|"..a2 .."|"..soundVolume)end end;function addTable(a3,a4)for i=1,#a4 do a3[#a3+1]=a4[i]end;return a3 end;function saveableVariables(a5)local a6={}if not a5 then addTable(a6,saveableVariablesBoolean)addTable(a6,savableVariablesHandling)addTable(a6,savableVariablesHud)addTable(a6,savableVariablesPhysics)return a6 elseif a5=="boolean"then return saveableVariablesBoolean elseif a5=="handling"then return savableVariablesHandling elseif a5=="hud"then return savableVariablesHud elseif a5=="physics"then return savableVariablesPhysics end end;local function a7(a8,a9,aa,ab,ac)if ab==nil then ab=""end;if ac==nil then ac=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ab,a8,a9,ac,aa)end;function float_eq(ad,ae)if ad==0 then return c(ae)<1e-09 end;if ae==0 then return c(ad)<1e-09 end;return c(ad-ae)<math.max(c(ad),c(ae))*epsilon end;function getDistanceDisplayString(distance,af)local ag=distance>100000;if af==nil then af=1 end;if ag then return z(distance/1000/200,af).."SU"elseif distance<1000 then return z(distance,af).."M"else return z(distance/1000,af).."KM"end end;function FormatTimeString(ah)local ai=0;local aj=0;local ak=0;if ah<60 then ah=d(ah)elseif ah<3600 then ai=d(ah/60)ah=d(ah%60)elseif ah<86400 then aj=d(ah/3600)ai=d(ah%3600/60)else ak=d(ah/86400)aj=d(ah%86400/3600)end;if ak>0 then return ak.."d "..aj.."h "elseif aj>0 then return aj.."h "..ai.."m "elseif ai>0 then return ai.."m "..ah.."s"elseif ah>0 then return ah.."s"else return"0s"end end;local function al(am)local function an(ao)for ap,aq in pairs(ao)do dbHud_1.setStringValue(aq,g(_G[aq]))if am and dbHud_2 then dbHud_2.setStringValue(aq,g(_G[aq]))end end end;if dbHud_1 then an(autoVariables)an(saveableVariables())system.print("Saved Variables to Datacore")if am and dbHud_2 then msgText="Databank copied.  Remove copy when ready."end end end;local function ar()local function as(at)return type(at)=='number'end;local function au(at)return type(y(at))=='number'end;local function av(aw)return type(aw)=='table'end;local function ax(ay)return type(ay)=='string'end;local function az(aq)return av(aq)and as(aq.x and aq.y and aq.z)end;local function aA(aB)return av(aB)and as(aB.latitude and aB.longitude and aB.altitude and aB.id and aB.systemId)end;local aC=math.pi/180;local aD=180/math.pi;local epsilon=1e-10;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aE='::pos{'..A..','..A..','..A..','..A..','..A..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function aF(at)local aG=string.gsub(string.reverse(e('%.4f',at)),'^0*%.?','')return aG==''and'0'or string.reverse(aG)end;local function aH(aI)if az(aI)then return e('{x=%.3f,y=%.3f,z=%.3f}',aI.x,aI.y,aI.z)end;if av(aI)and not getmetatable(aI)then local aJ={}local aK=next(aI)if type(aK)=='nil'or aK==1 then aJ=aI else for ap,aq in pairs(aI)do local aL=aH(aq)if type(ap)=='number'then table.insert(aJ,e('[%s]=%s',ap,aL))else table.insert(aJ,e('%s=%s',ap,aL))end end end;return e('{%s}',table.concat(aJ,','))end;if ax(aI)then return e("'%s'",aI:gsub("'",[[\']]))end;return tostring(aI)end;local aM={}aM.__index=aM;aM.__tostring=function(aI,aN)local aO={}for ap in pairs(aI)do table.insert(aO,ap)end;table.sort(aO)local aJ={}for _,ap in ipairs(aO)do local aL=aH(aI[ap])if type(ap)=='number'then table.insert(aJ,e('[%s]=%s',ap,aL))else table.insert(aJ,e('%s=%s',ap,aL))end end;if aN then return e('%s%s',aN,table.concat(aJ,',\n'..aN))end;return e('{%s}',table.concat(aJ,','))end;aM.__eq=function(aP,aQ)return aP.systemId==aQ.systemId and aP.id==aQ.id and float_eq(aP.radius,aQ.radius)and float_eq(aP.center.x,aQ.center.x)and float_eq(aP.center.y,aQ.center.y)and float_eq(aP.center.z,aQ.center.z)and float_eq(aP.GM,aQ.GM)end;local function aR(aS,aT,aU,aV,aW)assert(au(aS),'Argument 1 (systemId) must be a number:'..type(aS))assert(au(aT),'Argument 2 (id) must be a number:'..type(aT))assert(au(aU),'Argument 3 (radius) must be a number:'..type(aU))assert(av(aV),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(aV))assert(au(aW),'Argument 5 (GM) must be a number:'..type(aW))return setmetatable({systemId=y(aS),id=y(aT),radius=y(aU),center=vec3(aV),GM=y(aW)},aM)end;local aX={}aX.__index=aX;aX.__tostring=function(p)return e('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,aF(p.latitude*aD),aF(p.longitude*aD),aF(p.altitude))end;aX.__eq=function(aP,aQ)return aP.id==aQ.id and aP.systemId==aQ.systemId and float_eq(aP.latitude,aQ.latitude)and float_eq(aP.altitude,aQ.altitude)and(float_eq(aP.longitude,aQ.longitude)or float_eq(aP.latitude,math.pi/2)or float_eq(aP.latitude,-math.pi/2))end;local function aY(aZ,aT,a_,b0,b1)local aS=aZ;if ax(aZ)and not b0 and not b1 and not aT and not a_ then aS,aT,a_,b0,b1=n(aZ,aE)assert(aS,'Argument 1 (position string) is malformed.')else assert(au(aS),'Argument 1 (systemId) must be a number:'..type(aS))assert(au(aT),'Argument 2 (id) must be a number:'..type(aT))assert(au(a_),'Argument 3 (latitude) must be in degrees:'..type(a_))assert(au(b0),'Argument 4 (longitude) must be in degrees:'..type(b0))assert(au(b1),'Argument 5 (altitude) must be in meters:'..type(b1))end;aS=y(aS)aT=y(aT)a_=y(a_)b0=y(b0)b1=y(b1)if aT==0 then return setmetatable({latitude=a_,longitude=b0,altitude=b1,id=aT,systemId=aS},aX)end;return setmetatable({latitude=aC*q(a_,-90,90),longitude=aC*(b0%360),altitude=b1,id=aT,systemId=aS},aX)end;local b2={}b2.__index=b2;b2.__tostring=function(aI,aN)local b3=aN and aN..'  'local b4={}local aO={}for ap in pairs(aI)do table.insert(aO,ap)end;table.sort(aO)for _,b5 in ipairs(aO)do bdy=aI[b5]local b6=aM.__tostring(bdy,b3)if aN then table.insert(b4,e('[%s]={\n%s\n%s}',b5,b6,aN))else table.insert(b4,e('  [%s]=%s',b5,b6))end end;if aN then return e('\n%s%s%s',aN,table.concat(b4,',\n'..aN),aN)end;return e('{\n%s\n}',table.concat(b4,',\n'))end;local function b7(b8)local b={}local pid;for _,aq in pairs(b8)do local aT=aq.planetarySystemId;if type(aT)~='number'then error('Invalid planetary system ID: '..tostring(aT))elseif pid and aT~=pid then error('Mistringmatch planetary system IDs: '..aT..' and '..pid)end;local b9=aq.bodyId;if type(b9)~='number'then error('Invalid body ID: '..tostring(b9))elseif b[b9]then error('Duplicate body ID: '..tostring(b9))end;setmetatable(aq.center,getmetatable(vec3.unit_x))b[b9]=setmetatable(aq,aM)pid=aT end;return setmetatable(b,b2)end;U={}local function ba(b8)return setmetatable({galaxyAtlas=b8 or{}},U)end;U.__index=function(aw,i)if type(i)=='number'then local system=aw.galaxyAtlas[i]return b7(system)end;return rawget(U,i)end;U.__pairs=function(aI)return function(aw,ap)local bb,nv=next(aw,ap)return bb,nv and b7(nv)end,aI.galaxyAtlas,nil end;U.__tostring=function(aI)local bc={}for _,bd in pairs(aI or{})do local be=bd:getPlanetarySystemId()local bf=b2.__tostring(bd,'    ')table.insert(bc,e('  [%s]={%s\n  }',be,bf))end;return e('{\n%s\n}\n',table.concat(bc,',\n'))end;U.BodyParameters=aR;U.MapPosition=aY;U.PlanetarySystem=b7;function U.createBodyParameters(aS,aT,bg,bh,bi,bj,bk)assert(au(aS),'Argument 1 (systemId) must be a number:'..type(aS))assert(au(aT),'Argument 2 (id) must be a number:'..type(aT))assert(au(bg),'Argument 3 (surfaceArea) must be a number:'..type(bg))assert(av(bh),'Argument 4 (aPosition) must be an array or vec3:'..type(bh))assert(av(bi),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(bi))assert(au(bj),'Argument 6 (altitude) must be in meters:'..type(bj))assert(au(bk),'Argument 7 (gravityAtPosition) must be number:'..type(bk))local aU=x(bg/4/math.pi)local distance=aU+bj;local bl=vec3(bh)+distance*vec3(bi)local aW=bk*distance*distance;return aR(aS,aT,aU,bl,aW)end;U.isMapPosition=aA;function U:getPlanetarySystem(aZ)if i==nil then i=0 end;if nv==nil then nv=0 end;local aS=aZ;if aA(aZ)then aS=aZ.systemId end;if type(aS)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=b2 then system=b7(system)end;return system end end end;function b2:sizeCalculator(bm)return 1.05*bm.radius end;function b2:castIntersections(bn,bo,bp,bq,br,bs)local bt={}if br then for _,bm in pairs(br)do table.insert(bt,bm)end else bt=planetAtlas end;if not bs then table.sort(bt,function(bu,bv)local ad=bu.center;local ae=bv.center;return(ad.x-bn.x)^2+(ad.y-bn.y)^2+(ad.z-bn.z)^2<(ae.x-bn.x)^2+(ae.y-bn.y)^2+(ae.z-bn.z)^2 end)end;local bw=bo:normalize()for _,bm in ipairs(bt)do local bx=bm.center-bn;local aU=self:sizeCalculator(bm)local by=bx:dot(bw)local bz=by^2-(bx:len2()-aU^2)if bz>=0 then local bA=x(bz)local bB=by+bA;local bC=by-bA;if bC>0 then return bm,bB,bC elseif bB>0 then return bm,bB,nil end end end;return nil,nil,nil end;function b2:closestBody(bD)assert(type(bD)=='table','Invalid coordinates.')local bE,bm;local bF=vec3(bD)for _,bG in pairs(self)do local bH=(bG.center-bF):len2()if(not bm or bH<bE)and bG.name~="Space"then bm=bG;bE=bH end end;return bm end;function b2:convertToBodyIdAndWorldCoordinates(aZ)local bI=aZ;if ax(aZ)then bI=aY(aZ)end;if bI.id==0 then return 0,vec3(bI.latitude,bI.longitude,bI.altitude)end;local bG=self:getBodyParameters(bI)if bG then return bI.id,bG:convertToWorldCoordinates(bI)end end;function b2:getBodyParameters(aZ)local aT=aZ;if aA(aZ)then aT=aZ.id end;assert(au(aT),'Argument 1 (id) must be a number:'..type(aT))return self[aT]end;function b2:getPlanetarySystemId()local _,aq=next(self)return aq and aq.systemId end;function aM:convertToMapPosition(aV)assert(av(aV),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(aV))local bJ=vec3(aV)if self.id==0 then return setmetatable({latitude=bJ.x,longitude=bJ.y,altitude=bJ.z,id=0,systemId=self.systemId},aX)end;local bK=bJ-self.center;local distance=bK:len()local b1=distance-self.radius;local a_=0;local b0=0;if not float_eq(distance,0)then local bL=m(bK.y,bK.x)b0=bL>=0 and bL or 2*math.pi+bL;a_=math.pi/2-math.acos(bK.z/distance)end;return setmetatable({latitude=a_,longitude=b0,altitude=b1,id=self.id,systemId=self.systemId},aX)end;function aM:convertToWorldCoordinates(aZ)local bI=ax(aZ)and aY(aZ)or aZ;if bI.id==0 then return vec3(bI.latitude,bI.longitude,bI.altitude)end;assert(aA(bI),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(bI.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(bI.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local bM=math.cos(bI.latitude)return self.center+(self.radius+bI.altitude)*vec3(bM*math.cos(bI.longitude),bM*math.sin(bI.longitude),math.sin(bI.latitude))end;function aM:getAltitude(aV)return(vec3(aV)-self.center):len()-self.radius end;function aM:getDistance(aV)return(vec3(aV)-self.center):len()end;function aM:getGravity(aV)local bN=self.center-vec3(aV)local bO=bN:len2()return self.GM/bO*bN/x(bO)end;return setmetatable(U,{__call=function(_,...)return ba(...)end})end;local function bP()local Kinematic={}local bQ=30000000/3600;local bR=bQ*bQ;local bS=100;function Kinematic.computeAccelerationTime(bT,bU,bV)local bW=bQ*math.asin(bT/bQ)return(bQ*math.asin(bV/bQ)-bW)/bU end;function Kinematic.computeDistanceAndTime(bT,bV,bX,bY,bZ,b_)bZ=bZ or 0;b_=b_ or 0;local c0=bT<=bV;local c1=bY*(c0 and 1 or-1)/bX;local c2=-b_/bX;local c3=c1+c2;if c0 and c3<=0 or not c0 and c3>=0 then return-1,-1 end;local c4,c5=0,0;if c1~=0 and bZ>0 then local bW=math.asin(bT/bQ)local c6=math.pi*(c1/2+c2)local c7=c1*bZ;local c8=bQ*math.pi;local aq=function(aw)local c9=(c6*aw-c7*math.sin(math.pi*aw/2/bZ)+c8*bW)/c8;local ca=math.tan(c9)return bQ*ca/x(ca*ca+1)end;local cb=c0 and function(ay)return ay>=bV end or function(ay)return ay<=bV end;c5=2*bZ;if cb(aq(c5))then local cc=0;while c(c5-cc)>0.5 do local aw=(c5+cc)/2;if cb(aq(aw))then c5=aw else cc=aw end end end;local cd=bT;local ce=c5/bS;for cf=1,bS do local cg=aq(cf*ce)c4=c4+(cg+cd)*ce/2;cd=cg end;if c5<2*bZ then return c4,c5 end;bT=cd end;local bW=bQ*math.asin(bT/bQ)local time=(bQ*math.asin(bV/bQ)-bW)/c3;local ch=bR*math.cos(bW/bQ)/c3;local distance=ch-bR*math.cos((c3*time+bW)/bQ)/c3;return distance+c4,time+c5 end;function Kinematic.computeTravelTime(bT,bU,distance)if distance==0 then return 0 end;if bU>0 then local bW=bQ*math.asin(bT/bQ)local ch=bR*math.cos(bW/bQ)/bU;return(bQ*math.acos(bU*(ch-distance)/bR)-bW)/bU end;if bT==0 then return-1 end;assert(bT>0,'Acceleration and initial speed are both zero.')return distance/bT end;return Kinematic end;local function ci()local vec3=require('cpml.vec3')local ar=ar()local function ax(ay)return type(ay)=='string'end;local function av(aw)return type(aw)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(b1)assert(self.body)local distance=b1+self.body.radius;if not float_eq(distance,0)then local cj=x(self.body.GM/distance)return x(2)*cj,cj end;return nil,nil end;function Kepler:orbitalParameters(aZ,ck)assert(self.body)assert(av(aZ)or ax(aZ))assert(av(ck))local cl=(ax(aZ)or ar.isMapPosition(aZ))and self.body:convertToWorldCoordinates(aZ)or vec3(aZ)local aq=vec3(ck)local cm=cl-self.body.center;local cn=aq:len2()local co=cm:len()local cp=self.body.GM;local cq=((cn-cp/co)*cm-cm:dot(aq)*aq)/cp;local ad=cp/(2*cp/co-cn)local cr=cq:len()local bw=cq:normalize()local cs=ad*(1-cr)local ct=ad*(1+cr)local cu=cs*bw+self.body.center;local cv=cr<=1 and-ct*bw+self.body.center or nil;local cw=x(ad*cp*(1-cr*cr))local cx=cv and 2*math.pi*x(ad^3/cp)local cy=math.acos(cq:dot(cm)/(cr*co))if cm:dot(aq)<0 then cy=-(cy-2*math.pi)end;local cz=math.acos((math.cos(cy)+cr)/(1+cr*math.cos(cy)))local cA=cz;if cA<0 then cA=cA+2*math.pi end;local cB=cA-cr*math.sin(cA)local cC=0;local cD=0;local cE=0;if cx~=nil then cC=cB/(2*math.pi/cx)cD=cx-cC;cE=cD+cx/2;if cy-math.pi>0 then cD=cC;cE=cD+cx/2 end;if cE>cx then cE=cE-cx end end;return{periapsis={position=cu,speed=cw/cs,circularOrbitSpeed=x(cp/cs),altitude=cs-self.body.radius},apoapsis=cv and{position=cv,speed=cw/ct,circularOrbitSpeed=x(cp/ct),altitude=ct-self.body.radius},currentVelocity=aq,currentPosition=cl,eccentricity=cr,period=cx,eccentricAnomaly=cz,meanAnomaly=cB,timeToPeriapsis=cD,timeToApoapsis=cE,trueAnomaly=cy}end;local function cF(cG)local bG=ar.BodyParameters(cG.systemId,cG.id,cG.radius,cG.center,cG.GM)return setmetatable({body=bG},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return cF(...)end})end;local function cH()local function cI(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function cJ()local function cK(cL,cM)return cL.name<cM.name end;AtlasOrdered={}for ap,aq in pairs(b[0])do AtlasOrdered[#AtlasOrdered+1]={name=aq.name,index=ap}end;table.sort(AtlasOrdered,cK)end;local function cN(cO)for ap,aq in pairs(cO)do if aq.name and aq.name==CustomTarget.name then return ap end end;return-1 end;local function cP()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local cQ=AtlasOrdered[AutopilotTargetIndex].index;local cR=b[0][cQ]if cR.center then AutopilotTargetName=cR.name;autopilotTargetPlanet=galaxyReference[0][cQ]if CustomTarget~=nil then if atmosDensity==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=cR;for _,aq in pairs(galaxyReference[0])do if aq.name==CustomTarget.planetname then autopilotTargetPlanet=aq;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=d(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function cS(cT)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then if cT==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then cP()else local cQ=AtlasOrdered[AutopilotTargetIndex].index;local cR=b[0][cQ]if cR~=nil and cR.name=="Space"or iphCondition=="Custom Only"and cR.center or iphCondition=="No Moons"and string.find(cR.name,"Moon")~=nil then if cT==nil then cS()else cS(1)end else cP()end end else msgText="Disengage autopilot before changing Interplanetary Helper"play("iph","AP")end end;local function cU()local cV=-1;cV=cN(b[0])if cV>-1 then table.remove(b[0],cV)end;cV=-1;cV=cN(SavedLocations)if cV~=-1 then msgText=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cV)end;cS()cJ()end;local function cW(cX,position,cY,cZ)if dbHud_1 or cY then local p=cI(position)local c_=p.gravity;if cZ then c_=unit.getClosestPlanetInfluence()end;local d0={position=position,name=cX,planetname=p.name,gravity=c_,safe=cZ}if not cY then SavedLocations[#SavedLocations+1]=d0 else for ap,aq in pairs(b[0])do if aq.name and cX==aq.name then table.remove(b[0],ap)end end end;table.insert(b[0],d0)cJ()cP()msgText="Location saved as "..cX.."("..p.name..")"else msgText="Databank must be installed to save permanent locations"end end;local d1={}function d1.UpdateAtlasLocationsList()cJ()end;function d1.UpdateAutopilotTarget()cP()end;function d1.adjustAutopilotTargetIndex(cT)cS(cT)end;function d1.findAtlasIndex(cO)cN(cO)end;function d1.UpdatePosition(d2)local cV=cN(SavedLocations)if cV~=-1 then if d2~=nil then SavedLocations[cV].name=d2;AutopilotTargetIndex=AutopilotTargetIndex-1;cS()else local d3=SavedLocations[cV]d3.gravity=unit.getClosestPlanetInfluence()d3.position=worldPos;d3.safe=true end;msgText=SavedLocations[cV].name.." position updated ("..SavedLocations[cV].planetname..")"else msgText="Name Not Found"end end;function d1.AddNewLocation(cX,position,cY,cZ)cW(cX,position,cY,cZ)end;function d1.ClearCurrentPosition()cU()end;for ap,aq in pairs(SavedLocations)do table.insert(b[0],aq)end;cJ()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;d1.UpdateAutopilotTarget()return d1 end;function script.onStart()local d4=false;local function d5()local function d6(d7)local d8=dbHud_1.hasKey;for ap,aq in pairs(d7)do if d8(aq)then local aG=f(dbHud_1.getStringValue(aq))if aG~=nil then _G[aq]=aG;d4=true end end end end;if dbHud_1 then if not useTheseSettings then d6(saveableVariables())coroutine.yield()d6(autoVariables)else d6(autoVariables)msgText="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"msgTimer=5;d4=false end;coroutine.yield()if d4 then msgText="Loaded Saved Variables"resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;rgb=[[rgb(]]..d(PrimaryR+0.5)..","..d(PrimaryG+0.5)..","..d(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..d(PrimaryR*0.9+0.5)..","..d(PrimaryG*0.9+0.5)..","..d(PrimaryB*0.9+0.5)..[[)]]elseif not useTheseSettings then msgText="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then msgText="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else msgText="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then msgText="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function d9()local function da(db,dc)if db>dc then dc=db end;local dd,de=0,0;if ContainerOptimization>0 then dd=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then de=FuelTankOptimization*0.05 end;dc=dc*(1-(dd+de))return dc end;local df=core.getElementNameById;local dg=fuelX~=0 and fuelY~=0;for ap in pairs(P)do local type=core.getElementTypeById(P[ap])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(P[ap])),'^.*vertical.*$')and core.getElementForwardById(P[ap])[3]>0 then UpVertAtmoEngine=true end end;if n(type,'^.*Space Engine$')then SpaceEngines=true;if n(tostring(core.getElementTagsById(P[ap])),'^.*vertical.*$')then local dh=core.getElementForwardById(P[ap])if dh[3]<0 then W=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local di=h(P[ap])if di>10000 then E=110 elseif di>1000 then E=55 elseif di>150 then E=27 end end;T=T+h(P[ap])if dg and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local di=h(P[ap])local dj=k(P[ap])local db=0;local dk=o()if type=="Atmospheric Fuel Tank"then local dc=400;local dl=35.03;if di>10000 then dc=51200;dl=5480 elseif di>1300 then dc=6400;dl=988.67 elseif di>150 then dc=1600;dl=182.67 end;db=dj-dl;if fuelTankHandlingAtmo>0 then dc=dc+dc*fuelTankHandlingAtmo*0.2 end;dc=da(db,dc)atmoTanks[#atmoTanks+1]={P[ap],df(P[ap]),dc,dl,db,dk}end;if type=="Rocket Fuel Tank"then local dc=320;local dl=173.42;if di>65000 then dc=40000;dl=25740 elseif di>6000 then dc=5120;dl=4720 elseif di>700 then dc=640;dl=886.72 end;db=dj-dl;if fuelTankHandlingRocket>0 then dc=dc+dc*fuelTankHandlingRocket*0.1 end;dc=da(db,dc)rocketTanks[#rocketTanks+1]={P[ap],df(P[ap]),dc,dl,db,dk}end;if type=="Space Fuel Tank"then local dc=600;local dl=35.03;if di>10000 then dc=76800;dl=5480 elseif di>1300 then dc=9600;dl=988.67 elseif di>150 then dc=2400;dl=182.67 end;db=dj-dl;if fuelTankHandlingSpace>0 then dc=dc+dc*fuelTankHandlingSpace*0.2 end;dc=da(db,dc)spaceTanks[#spaceTanks+1]={P[ap],df(P[ap]),dc,dl,db,dk}end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function dm()if gyro~=nil then gyroIsOn=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,aq in pairs(door)do aq.toggle()end end;if switch then for _,aq in pairs(switch)do aq.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,aq in pairs(forcefield)do aq.toggle()end end;if antigrav then antigravOn=antigrav.getState()==1;if antigravOn and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if hasGear then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<50 then BrakeIsOn=true;GearExtended=true;if hasGear then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(V)if inAtmo and abvGndDet~=-1 then maxKinematicUp=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=inAtmo end;local function dn()local dp={}local function dq()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local dr={[1]=4480,[6]=4480,[7]=6270}for ds,dt in pairs(b)do b[ds][0]=dq()b[ds][0].systemId=ds;dp[ds]={}for du,planet in pairs(b[ds])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=dr[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=ds;planet.bodyId=planet.id;dp[ds][du]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then planetAtlas[#planetAtlas+1]=planet end end end;U=ar()galaxyReference=U(dp)Kinematic=bP()Kep=ci()ATLAS=cH()end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})d5()coroutine.yield()d9()coroutine.yield()AP=APClass(a,core,unit,system,b,vBooster,hover,telemeter_1,antigrav,c,d,j,l,m,o,q,r,t,w,x,z)dm()coroutine.yield()dn()RADAR=RadarClass(core,system,library,radar_1,radar_2,c,s,x,a7,y,E)HUD=HudClass(a,core,unit,system,b,radar_1,radar_2,antigrav,hover,shield_1,c,d,e,f,j,k,l,m,o,q,r,s,w,x,z,a7)HUD.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)play("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,aq in pairs(door)do aq.toggle()end end;if switch then for _,aq in pairs(switch)do aq.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,aq in pairs(forcefield)do aq.toggle()end end;showHud=oldShowHud;al()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;play("stop","SU")end;function script.onTick(dv)local dw=nil;if dv=="contact"then if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then msgText="Radar Contact"play("rdrCon","RC")contactTimer=time end;unit.stopTimer("contact")elseif dv=="tenthSecond"then local function dx()local dy=system.createData;local dz=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=dz(panelInterplanetary,"value")interplanetaryHeaderText=dy('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=dz(panelInterplanetary,"value")widgetDistanceText=dy('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=dz(panelInterplanetary,"value")widgetTravelTimeText=dy('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=dz(panelInterplanetary,"value")widgetMaxMassText=dy('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=dz(panelInterplanetary,"value")widgetTargetOrbitText=dy('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=dz(panelInterplanetary,"value")widgetCurBrakeDistanceText=dy('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=dz(panelInterplanetary,"value")widgetCurBrakeTimeText=dy('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=dz(panelInterplanetary,"value")widgetMaxBrakeDistanceText=dy('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=dz(panelInterplanetary,"value")widgetMaxBrakeTimeText=dy('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=dz(panelInterplanetary,"value")widgetTrajectoryAltitudeText=dy('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function dA()s(panelInterplanetary)panelInterplanetary=nil end;local function dB()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local cg=velMag;local dC=unit.getThrottle()/100;if AtmoSpeedAssist then dC=PlayerThrottle end;local dD,dE=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,a:maxForceForward()*dC,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,dF;if not TurnBurn and cg>0 then _,dF=AP.GetAutopilotBrakeDistanceAndTime(cg)else _,dF=AP.GetAutopilotTBBrakeDistanceAndTime(cg)end;local dG=0;local dH=0;if AutopilotCruising or not Autopilot and cg>5 then dH=Kinematic.computeTravelTime(cg,0,AutopilotDistance)elseif brakeDistance+dD<AutopilotDistance then dG=AutopilotDistance-(brakeDistance+dD)dH=Kinematic.computeTravelTime(8333.0556,0,dG)else local dI=(AutopilotDistance-brakeDistance)/dD;dD=AutopilotDistance-brakeDistance;dE=dE*dI end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return dH elseif AutopilotBraking then return dF elseif AutopilotCruising then return dH+dF else return dE+brakeTime+dH end end;local function dJ(c_,dK)if c_==nil then c_=core.g()end;c_=z(c_,5)if dK~=nil and dK or(dw==nil or dw~=c_)then local cg=coreVelocity:len()local dL=f(unit.getData()).maxBrake;if dL~=nil and dL>0 and inAtmo then dL=dL/q(cg/100,0.1,1)dL=dL/atmosDensity;if atmosDensity>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+dL)/2 else LastMaxBrakeInAtmo=dL end end end;if dL~=nil and dL>0 then LastMaxBrake=dL end;dw=c_ end end;dJ(nil,true)if setCruiseSpeed~=nil then if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or r:getTargetSpeed(axisCommandId.longitudinal)~=setCruiseSpeed then AP.cmdCruise(setCruiseSpeed)else setCruiseSpeed=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then dx()end;if AutopilotTargetName~=nil then local dM=CustomTarget~=nil;local dN=0.5*LastMaxBrakeInAtmo/autopilotTargetPlanet:getGravity(autopilotTargetPlanet.center+vec3(0,0,1)*autopilotTargetPlanet.radius):len()dN=dN>1000000 and z(dN/1000000,2).." kTons"or z(dN/1000,2).." Tons"t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=dB()if dM and not Autopilot then distance=(worldPos-CustomTarget.position):len()else distance=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)M,N=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)M,N=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local dO=getDistanceDisplayString(distance)t(widgetDistanceText,'{"label": "distance", "value": "'..dO..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..FormatTimeString(travelTime)..'", "unit":""}')dO=getDistanceDisplayString(brakeDistance)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..dO..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..FormatTimeString(brakeTime)..'", "unit":""}')dO=getDistanceDisplayString(M)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..dO..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..FormatTimeString(N)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..e("%s",dN)..'", "unit":""}')dO=getDistanceDisplayString(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..dO..'"}')if atmosDensity>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then AP.cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if atmosDensity==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else dA()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;HUD.TenthTick()elseif dv=="oneSecond"then local function dP(dQ)local dR=0;damageMessage=""local dS=T;local dT=0;local dU=0;local dV=0;local dW=0;local dX=""local dY=core.getElementHitPointsById;for ap in pairs(P)do local di=0;local dZ=0;dZ=h(P[ap])di=dY(P[ap])dT=dT+di;if di<dZ then if di==0 then dV=dV+1 else dU=dU+1 end;if repairArrows and#R==0 then position=vec3(core.getElementPositionById(P[ap]))local a8=position.x;local a9=position.y;local d_=position.z;table.insert(R,core.spawnArrowSticker(a8,a9,d_+1,"down"))table.insert(R,core.spawnArrowSticker(a8,a9,d_+1,"down"))core.rotateSticker(R[2],0,0,90)table.insert(R,core.spawnArrowSticker(a8+1,a9,d_,"north"))table.insert(R,core.spawnArrowSticker(a8+1,a9,d_,"north"))core.rotateSticker(R[4],90,90,0)table.insert(R,core.spawnArrowSticker(a8-1,a9,d_,"south"))table.insert(R,core.spawnArrowSticker(a8-1,a9,d_,"south"))core.rotateSticker(R[6],90,-90,0)table.insert(R,core.spawnArrowSticker(a8,a9-1,d_,"east"))table.insert(R,core.spawnArrowSticker(a8,a9-1,d_,"east"))core.rotateSticker(R[8],90,0,90)table.insert(R,core.spawnArrowSticker(a8,a9+1,d_,"west"))table.insert(R,core.spawnArrowSticker(a8,a9+1,d_,"west"))core.rotateSticker(R[10],-90,0,90)table.insert(R,P[ap])end elseif repairArrows and#R>0 and R[11]==P[ap]then for e0 in pairs(R)do core.deleteSticker(R[e0])end;R={}end end;dR=d(dT/dS*100)if dR<100 then dQ[#dQ+1]=a7(0,0,"","pbright txt")dW=d(dR*2.55)dX=e("rgb(%d,%d,%d)",255-dW,dW,0)if dR<100 then dQ[#dQ+1]=a7("50%",1035,"Elemental Integrity: "..dR.."%","txtbig txtmid","fill:"..dX)if dV>0 then dQ[#dQ+1]=a7("50%",1055,"Disabled Modules: "..dV.." Damaged Modules: "..dU,"txtbig txtmid","fill:"..dX)elseif dU>0 then dQ[#dQ+1]=a7("50%",1055,"Damaged Modules: "..dU,"txtbig txtmid","fill:"..dX)end end end end;local function e1()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function e2()local dk=o()local e3=velMag;local e4=dk-lastTravelTime;if e3>1.38889 then e3=e3/1000;local e5=e3*(dk-lastTravelTime)TotalDistanceTravelled=TotalDistanceTravelled+e5;totalDistanceTrip=totalDistanceTrip+e5 end;flightTime=flightTime+e4;TotalFlightTime=TotalFlightTime+e4;lastTravelTime=dk end;e2()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()e1()local dQ={}HUD.OneSecond(dQ)if ShouldCheckDamage then dP(dQ)end;lastOdometerOutput=table.concat(dQ,"")collectgarbage("collect")elseif dv=="fiveSecond"then if not UseSatNav then return end;O=dbHud_1.getStringValue("SPBAutopilotTargetName")if O~=nil and O~=""and O~="SatNavNotChanged"then local aG=f(dbHud_1.getStringValue("SavedLocations"))if aG~=nil then _G["SavedLocations"]=aG;local cV=-1;local d0;for ap,aq in pairs(SavedLocations)do if aq.name and aq.name=="SatNav Location"then cV=ap;break end end;if cV~=-1 then d0=SavedLocations[cV]cV=-1;for ap,aq in pairs(b[0])do if aq.name and aq.name=="SatNav Location"then cV=ap;break end end;if cV>-1 then b[0][cV]=d0 end;ATLAS.UpdateAtlasLocationsList()msgText=d0.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==O then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)ATLAS.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif dv=="msgTick"then local dQ={}HUD.DisplayMessage(dQ,"empty")msgText="empty"unit.stopTimer("msgTick")msgTimer=3 elseif dv=="animateTick"then Animated=true;Animating=false;simulatedX=0;simulatedY=0;unit.stopTimer("animateTick")elseif dv=="hudTick"then HUD.hudtick()elseif dv=="apTick"then AP.APTick()elseif dv=="radarTick"then RADAR.UpdateRadar()elseif dv=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;msgText="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function e6(e7,e8)local e9=vec3()local ea=vec3()if e7==axisCommandId.longitudinal then e9=vec3(core.getConstructOrientationForward())ea=constructForward elseif e7==axisCommandId.vertical then e9=vec3(core.getConstructOrientationUp())ea=constructUp elseif e7==axisCommandId.lateral then e9=vec3(core.getConstructOrientationRight())ea=constructRight else return vec3()end;local eb=vec3(core.getWorldGravity())local ec=eb:dot(ea)local ed=vec3(core.getWorldAirFrictionAcceleration())local ee=ed:dot(ea)local ef=coreVelocity:dot(e9)local eg=e8*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(eg-ef)local eh=targetSpeedPID2:get()local ei=(eh-ee-ec)*ea;return ei end;local function ej(e7,e8)local e9=vec3()local ea=vec3()if e7==axisCommandId.longitudinal then e9=vec3(core.getConstructOrientationForward())ea=constructForward elseif e7==axisCommandId.vertical then e9=vec3(core.getConstructOrientationUp())ea=constructUp elseif e7==axisCommandId.lateral then e9=vec3(core.getConstructOrientationRight())ea=constructRight else return vec3()end;local eb=vec3(core.getWorldGravity())local ec=eb:dot(ea)local ed=vec3(core.getWorldAirFrictionAcceleration())local ee=ed:dot(ea)local ef=coreVelocity:dot(e9)local eg=e8*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(eg-ef)local eh=targetSpeedPID:get()local ei=(eh-ee-ec)*ea;return ei end;local function ek(el,em,cM)local en=el:cross(cM):normalize_inplace()local eo=math.acos(q(en:dot(-em),-1,1))*constants.rad2deg;if en:cross(-em):dot(cM)<0 then eo=-eo end;return eo end;if antigrav and not ExternalAGG then if not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;throttleMode=r:getAxisCommandType(0)==axisCommandType.byThrottle;if throttleMode and WasInCruise then AP.cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local ep=q(F+pitchInput2+system.getControlDeviceForwardInput(),-1,1)local eq=q(G+rollInput2+system.getControlDeviceYawInput(),-1,1)local er=q(H+yawInput2-system.getControlDeviceLeftRightInput(),-1,1)local es=brakeInput;worldVertical=vec3(core.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end;constructUp=vec3(core.getConstructWorldOrientationUp())constructForward=vec3(core.getConstructWorldOrientationForward())constructRight=vec3(core.getConstructWorldOrientationRight())constructVelocity=vec3(core.getWorldVelocity())coreVelocity=vec3(core.getVelocity())worldPos=vec3(core.getConstructWorldPos())coreMass=core.getConstructMass()velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local et=adjustedRoll/180*math.pi;local eu=math.cos(et)local ev=math.sin(et)adjustedPitch=ek(worldVertical,constructForward,constructRight*eu+constructUp*ev)local ew=constructVelocity:normalize()local ex=c(adjustedRoll)local ey=utils.sign(adjustedRoll)local ez=vec3(core.getWorldAngularVelocity())local eA=ep*pitchSpeedFactor*constructRight+eq*rollSpeedFactor*constructForward+er*yawSpeedFactor*constructUp;if autoRoll==true and worldVertical:len()>0.01 then local eB=c(targetRoll-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and eB>0 or atmosDensity>0.0 and eB<autoRollRollThreshold and autoRollPreference)and eq==0 and c(adjustedPitch)<85 then local eC=targetRoll;local eD=autoRollFactor;if atmosDensity==0 then eD=eD/4;targetRoll=0;eC=0 end;if rollPID==nil then rollPID=pid.new(eD*0.01,0,eD*0.1)end;rollPID:inject(eC-adjustedRoll)local eE=rollPID:get()eA=eA+eE*constructForward end end;local eF=1;local eG=0;local eH=1;local eI=system.getMouseWheel()if eI>0 then Y()elseif eI<0 then Y(true)else Q=true end;brakeInput2=0;if inAtmo and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6-constructVelocity:dot(constructForward))local eJ=throttlePID:get()calculatedThrottle=q(eJ,-1,1)if calculatedThrottle<PlayerThrottle and atmosDensity>0.005 then ThrottleLimited=true;r:setThrottleCommand(axisCommandId.longitudinal,q(calculatedThrottle,0.01,1))else ThrottleLimited=false;r:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6)local eK=q(brakePID:get(),0,1)if atmosDensity>0 and vSpd<-80 or atmosDensity>0.005 then brakeInput2=eK end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else calculatedThrottle=q(calculatedThrottle,0.01,1)end;local eL=''local eM=vec3()local eN=e6(axisCommandId.vertical,upAmount*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",eN,eG)local eO='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then eO=eO..ExtraLongitudeTags end;local eP=r:getAxisCommandType(axisCommandId.longitudinal)local eQ=r:composeAxisAccelerationFromThrottle(eO,axisCommandId.longitudinal)local eR=ej(axisCommandId.lateral,LeftAmount*1000)eL=eL..' , '.."lateral airfoil , lateral ground "eM=eM+eR;if eM:len()>constants.epsilon then a:setEngineForceCommand(eL,eM,eG,'','','',eH)end;a:setEngineForceCommand(eO,eQ,eF)local eS='thrust analog vertical fueled 'local eT='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then eT=eT..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then eS=eS..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(eS,eN,eF)else a:setEngineForceCommand(eS,vec3(),eF)end;if LeftAmount~=0 then a:setEngineForceCommand(eT,eR,eF)else a:setEngineForceCommand(eT,vec3(),eF)end;if es==0 then es=brakeInput2 end;local eU=-es*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*ew)a:setEngineForceCommand('brake',eU)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;local e8=unit.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-e8/3.6)local eK=q(brakePID:get(),0,1)es=q(es+eK,0,1)end;local eU=-es*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*ew)a:setEngineForceCommand('brake',eU)local eL=''local eM=vec3()local eV=false;local eO='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then eO=eO..ExtraLongitudeTags end;local eP=r:getAxisCommandType(axisCommandId.longitudinal)if eP==axisCommandType.byThrottle then local eQ=r:composeAxisAccelerationFromThrottle(eO,axisCommandId.longitudinal)a:setEngineForceCommand(eO,eQ,eF)elseif eP==axisCommandType.byTargetSpeed then local eQ=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)eL=eL..' , '..eO;eM=eM+eQ;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then eV=true end end;local eT='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then eT=eT..ExtraLateralTags end;local eW=r:getAxisCommandType(axisCommandId.lateral)if eW==axisCommandType.byThrottle then local eX=r:composeAxisAccelerationFromThrottle(eT,axisCommandId.lateral)a:setEngineForceCommand(eT,eX,eF)elseif eW==axisCommandType.byTargetSpeed then local eR=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)eL=eL..' , '..eT;eM=eM+eR end;local eS='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then eS=eS..ExtraVerticalTags end;local eY=r:getAxisCommandType(axisCommandId.vertical)if eY==axisCommandType.byThrottle then local eN=r:composeAxisAccelerationFromThrottle(eS,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(eS,eN,eF,'airfoil','ground','',eH)else a:setEngineForceCommand(eS,vec3(),eF)a:setEngineForceCommand('airfoil vertical',eN,eF,'airfoil','','',eH)a:setEngineForceCommand('ground vertical',eN,eF,'ground','','',eH)end elseif eY==axisCommandType.byTargetSpeed then if upAmount<0 then a:setEngineForceCommand('hover',vec3(),eF)end;local eZ=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)eL=eL..' , '..eS;eM=eM+eZ end;if eM:len()>constants.epsilon then if brakeInput~=0 or eV or c(ew:dot(constructForward))<0.5 then eL=eL..', brake'end;a:setEngineForceCommand(eL,eM,eG,'','','',eH)end end;local e_=torqueFactor*(eA-ez)local f0=vec3(core.getWorldAirFrictionAngularAcceleration())e_=e_-f0;a:setEngineTorqueCommand('torque',e_,eF,'airfoil','','',eH)a:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local cg=coreVelocity:len()local f1=0.15;if not throttleMode then local f2=r:getTargetSpeed(axisCommandId.longitudinal)if cg*3.6>f2*(1-f1)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif cg*3.6<f2*(1-f1)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local dC=unit.getThrottle()if AtmoSpeedAssist then dC=PlayerThrottle*100 end;local e8=dC/100;if j==0 then e8=e8*MaxGameVelocity;if cg>=e8*(1-f1)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif cg<e8*(1-f1)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local f3=d(adjustedAtmoSpeedLimit)e8=e8*f3/3.6;if cg>=e8*(1-f1)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif cg<e8*(1-f1)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local f4=coroutine.status(beginSetup)if f4=="suspended"then local aL,f5=coroutine.resume(beginSetup)if f5 then system.print("ERROR STARTUP: "..f5)end elseif f4=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not Animating and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(f6)local function f7(Z)local C=1;local function f8(f9,Z)local fa={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local fb=f9;for _,aq in ipairs(fa)do if Z and fb>aq then f9=aq elseif f9<aq and not Z then f9=aq;break end end;return f9 end;if Z then C=-1 end;if not ExternalAGG and antigravOn then if holdingShift and Z then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*J;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+C*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=f8(OrbitTargetOrbit,Z)else OrbitTargetOrbit=OrbitTargetOrbit+C*I end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=f8(HoldAltitude,Z)else HoldAltitude=HoldAltitude+C*I end end else r:updateTargetGroundAltitudeFromActionStart(C*1.0)end end;local function fc(fd)if not inAtmo then msgText="Flight Assist in Atmo only"return end;local aw=type(fd)if ReversalIsOn==nil then if aw=="table"then if Autopilot or VectorToTarget then AP.ToggleAutopilot()end;play("180On","BR")elseif fd==1 then play("bnkLft","BR")else play("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then AP.ToggleAltitudeHold()if aw~="table"then fd=fd+1 end end;ReversalIsOn=fd else play("180Off","BR")ReversalIsOn=nil end end;if f6=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;AP.cmdThrottle(0)if vBooster or hover then if inAtmo and abvGndDet==-1 then play("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;autoRoll=true;GearExtended=false else if hasGear then play("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if inAtmo then BrakeIsOn=true end end end;if hasGear and not BrakeLanding and not(vBooster or hover)then play("grOut","LG",1)a.control.extendLandingGears()end else if hasGear then play("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif f6=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif f6=="forward"then F=F-1 elseif f6=="backward"then if AltIsOn then fc(-constructVelocity*5000)else F=F+1 end elseif f6=="left"then if AltIsOn then fc(1)else G=G-1 end elseif f6=="right"then if AltIsOn then fc(3)else G=G+1 end elseif f6=="yawright"then H=H-1 elseif f6=="yawleft"then H=H+1 elseif f6=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif f6=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif f6=="up"then upAmount=upAmount+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif f6=="down"then upAmount=upAmount-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif f6=="groundaltitudeup"then f7()elseif f6=="groundaltitudedown"then f7(true)elseif f6=="option1"then toggleView=false;if AltIsOn and holdingShift then local fe=""for i=1,#passengers do fe=fe.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..z(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..fe)return end;ATLAS.adjustAutopilotTargetIndex()elseif f6=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do core.forceDeboard(passengers[i])end;msgText="Deboarded All Passengers"return end;ATLAS.adjustAutopilotTargetIndex(1)elseif f6=="option3"then local function ff()S=not S;if not S then play("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else play("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then s(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then s(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and holdingShift then local fe=""for i=1,#ships do fe=fe.."| ID: "..ships[i].." Mass: "..z(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..fe)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ff()toggleView=false elseif f6=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do core.forceUndock(ships[i])end;msgText="Undocked all ships"return end;ReversalIsOn=nil;AP.ToggleAutopilot()elseif f6=="option5"then toggleView=false;AP.ToggleLockPitch()elseif f6=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then local fg=shield_1.getVentingCooldown()if fg>0 then msgText="Cannot vent again for "..fg.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()msgText="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else msgText="Shields already at max hitpoints"end;return else msgText="No shield found"return end end;AP.ToggleAltitudeHold()elseif f6=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield_1 then shield_1.toggle()return else msgText="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then msgText="Collision System Enabled"else msgText="Collision System Secured"end elseif f6=="option8"then stablized=not stablized;if not stablized then msgText="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()play("gsOff","GS")else msgText="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)play("gsOn","GS")end;toggleView=false elseif f6=="option9"then if AltIsOn and holdingShift then r:resetCommand(axisCommandId.longitudinal)r:resetCommand(axisCommandId.lateral)r:resetCommand(axisCommandId.vertical)AP.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.getState()==1;if gyroIsOn then play("gyOn","GA")else play("gyOff","GA")end end;toggleView=false elseif f6=="lshift"then apButtonsHovered=false;if AltIsOn then holdingShift=true end;if w()==1 then holdingShift=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then holdingShift=true;Animated=false;Animating=false end elseif f6=="brake"then if BrakeToggleStatus or AltIsOn then AP.BrakeToggle()elseif not BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=true end elseif f6=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif f6=="booster"then if VanillaRockets then a:toggleBoosters()elseif not isBoosting then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;isBoosting=false end elseif f6=="stopengines"then local function fh()if time-D<1.5 then play("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;apThrottleSet=false;spaceLand=false;spaceLaunch=false;reentryMode=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false end end;fh()D=time;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if PlayerThrottle~=0 then r:resetCommand(axisCommandId.longitudinal)AP.cmdThrottle(0)else AP.cmdThrottle(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if inAtmo then AP.cmdCruise(AtmoSpeedLimit)else AP.cmdCruise(MaxGameVelocity*3.6)end end end elseif f6=="speedup"then Y()elseif f6=="speeddown"then Y(true)elseif f6=="antigravity"and not ExternalAGG then if antigrav~=nil then AP.ToggleAntigrav()end end end;function script.onActionStop(f6)local function fi()if not ExternalAGG and antigravOn then L=J end;if AltitudeHold or VertTakeOff or IntoOrbit then K=I end end;if f6=="forward"then F=0 elseif f6=="backward"then F=0 elseif f6=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;G=0 elseif f6=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;G=0 elseif f6=="yawright"then H=0 elseif f6=="yawleft"then H=0 elseif f6=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif f6=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif f6=="up"then upAmount=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif f6=="down"then upAmount=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif f6=="groundaltitudeup"then fi()toggleView=false elseif f6=="groundaltitudedown"then fi()toggleView=false elseif f6=="lshift"then if w()==1 then simulatedX=0;simulatedY=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false elseif f6=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=false end end elseif f6=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(f6)local function fj(Z)local C=1;if Z then C=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+C*L;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;L=q(L*1.05,J,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+C*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+C*K;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+C*K end;K=q(K*1.05,I,50)else r:updateTargetGroundAltitudeFromActionLoop(C*1.0)end end;local function fk(Z)local C=1;if Z then C=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=q(PlayerThrottle+C*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,C*speedChangeSmall)end end end;if f6=="groundaltitudeup"then if not holdingShift then fj()end elseif f6=="groundaltitudedown"then if not holdingShift then fj(true)end elseif f6=="speedup"then fk()elseif f6=="speeddown"then fk(true)end end;function script.onInputText(aa)local function fl(fm,cl,cY)local function fn(cl)local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aE='::pos{'..A..','..A..','..A..','..A..','..A..'}'local aS,aT,a_,b0,b1=n(cl,aE)if aS=="0"and aT=="0"then return vec3(y(a_),y(b0),y(b1))end;b0=math.rad(b0)a_=math.rad(a_)local planet=b[y(aS)][y(aT)]local bM=math.cos(a_)local fo=vec3(bM*math.cos(b0),bM*math.sin(b0),math.sin(a_))return planet.center+(planet.radius+b1)*fo end;local position=fn(cl)return ATLAS.AddNewLocation(fm,position,cY)end;local i;local fp,fq=nil,nil;local fr="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(aa," ")fp=aa;if i~=nil then fp=string.sub(aa,0,i-1)fq=string.sub(aa,i+1)end;if fp=="/help"or fp=="/commands"then for fs in string.gmatch(fr,"([^\n]+)")do system.print(fs)end;return elseif fp=="/setname"then if fq==nil or fq==""then msgText="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(fq)else msgText="Select a saved target to rename first"end elseif shield_1 and fp=="/resist"then if fq==nil or shield_1.getResistancesCooldown()>0 then msgText="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local A=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local aE=A..', '..A..', '..A..', '..A;local ft,fu,fv,fw=n(fq,aE)if fw==nil or ft+fu+fv+fw>0.6 then msgText="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(ft,fu,fv,fw)==1 then msgText="Shield Resistances set"else msgText="Resistance setting failed."end elseif fp=="/addlocation"or string.find(aa,"::pos")~=nil then local cY=false;local fm="0-Temp"if fq==nil or fq==""then fq=fp;cY=true end;i=string.find(fq,"::")if not cY then fm=string.sub(fq,1,i-2)end;local cl=string.sub(fq,i)fl(fm,cl,cY)elseif fp=="/agg"then if fq==nil or fq==""then msgText="Usage: /agg targetheight"return end;fq=y(fq)if fq<1000 then fq=1000 end;AntigravTargetAltitude=fq;msgText="AGG Target Height set to "..fq elseif fp=="/G"then if fq==nil or fq==""then msgText="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if fq=="dump"then for ap,aq in pairs(saveableVariables())do if type(_G[aq])=="boolean"then if _G[aq]==true then system.print(aq.." true")else system.print(aq.." false")end elseif _G[aq]==nil then system.print(aq.." nil")else system.print(aq.." ".._G[aq])end end;return end;i=string.find(fq," ")local fx=string.sub(fq,0,i-1)local fy=string.sub(fq,i+1)for ap,aq in pairs(saveableVariables())do if aq==fx then msgText="Variable "..fx.." changed to "..fy;local fz=type(_G[aq])if fz=="number"then fy=y(fy)if aq=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=fy end elseif fz=="boolean"then if string.lower(fy)=="true"then fy=true else fy=false end end;_G[aq]=fy;return end end;msgText="No such global variable: "..fx elseif fp=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else msgText="Select a custom wp to delete first in IPH"end elseif fp=="/copydatabank"then if dbHud_2 then al(true)else msgText="Spare Databank required to copy databank"end elseif fp=="/iphWP"then if AutopilotTargetIndex>0 then system.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))msgText="::pos waypoint shown in lua chat"else msgText="No target selected in IPH"end end end;function script.onEnter(aT)if radar_1 and not inAtmo and not notPvPZone then unit.setTimer("contact",0.1)end end;function script.onLeave(aT)if radar_1 and CollisionSystem then if#contacts>650 then aT=tostring(aT)contacts[aT]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
