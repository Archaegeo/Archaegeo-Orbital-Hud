name: ArchHud - Archaegeo v0.736 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.736;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=13888.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(a,b,c,bH,bI,bJ)bK=bH()bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=0;bS=0;bT=0;bU=0;bV=false;bW=false;bX="empty"bY=3;bZ=false;b_=0;c0=0;c1=nil;c2=0;c3=0;c4=0;c5=false;c6=false;c7=false;c8=-1;c9=bJ()>0;ca=bJ()cb=b.getAltitude()cc=b.getConstructMass()cd=nil;ce=a9;cf=aa;cg={}ch={}ci={}cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=U;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=w;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;d8=0;d9=false;da=b.getMaxSpeed()if db then dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())end end;local function dd(d,b,c,a,de,df,dg,dh,di)local function dj(dk)return type(dk)=='number'end;local function dl(dk)return type(dg(dk))=='number'end;local function dm(dn)return type(dn)=='table'end;local function dp(a)return type(a)=='string'end;local function dq(dr)return dm(dr)and dj(dr.x and dr.y and dr.z)end;local function ds(dt)return dm(dt)and dj(dt.latitude and dt.longitude and dt.altitude and dt.id and dt.systemId)end;local du=math.pi/180;local dv=180/math.pi;local dw=1e-10;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local utils=utils;local vec3=vec3;local function dz(dk)local dA=string.gsub(string.reverse(de('%.4f',dk)),'^0*%.?','')return dA==''and'0'or string.reverse(dA)end;local function dB(dC)if dq(dC)then return de('{x=%.3f,y=%.3f,z=%.3f}',dC.x,dC.y,dC.z)end;if dm(dC)and not getmetatable(dC)then local dD={}local dE=next(dC)if type(dE)=='nil'or dE==1 then dD=dC else for dF,dr in pairs(dC)do local dG=dB(dr)if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end end;return de('{%s}',table.concat(dD,','))end;if dp(dC)then return de("'%s'",dC:gsub("'",[[\']]))end;return tostring(dC)end;local dH={}dH.__index=dH;dH.__tostring=function(dC,dI)local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)local dD={}for dK,dF in ipairs(dJ)do local dG=dB(dC[dF])if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end;if dI then return de('%s%s',dI,table.concat(dD,',\n'..dI))end;return de('{%s}',table.concat(dD,','))end;dH.__eq=function(dL,dM)return dL.systemId==dM.systemId and dL.id==dM.id and di(dL.radius,dM.radius)and di(dL.center.x,dM.center.x)and di(dL.center.y,dM.center.y)and di(dL.center.z,dM.center.z)and di(dL.GM,dM.GM)end;local function dN(dO,dP,dQ,dR,dS)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dQ),'Argument 3 (radius) must be a number:'..type(dQ))assert(dm(dR),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dR))assert(dl(dS),'Argument 5 (GM) must be a number:'..type(dS))return setmetatable({systemId=dg(dO),id=dg(dP),radius=dg(dQ),center=vec3(dR),GM=dg(dS)},dH)end;local dT={}dT.__index=dT;dT.__tostring=function(dU)return de('::pos{%d,%d,%s,%s,%s}',dU.systemId,dU.id,dz(dU.latitude*dv),dz(dU.longitude*dv),dz(dU.altitude))end;dT.__eq=function(dL,dM)return dL.id==dM.id and dL.systemId==dM.systemId and di(dL.latitude,dM.latitude)and di(dL.altitude,dM.altitude)and(di(dL.longitude,dM.longitude)or di(dL.latitude,math.pi/2)or di(dL.latitude,-math.pi/2))end;local function dV(dW,dP,dX,dY,dZ)local dO=dW;if dp(dW)and not dY and not dZ and not dP and not dX then dO,dP,dX,dY,dZ=d_(dW,dy)assert(dO,'Argument 1 (position string) is malformed.')else assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dX),'Argument 3 (latitude) must be in degrees:'..type(dX))assert(dl(dY),'Argument 4 (longitude) must be in degrees:'..type(dY))assert(dl(dZ),'Argument 5 (altitude) must be in meters:'..type(dZ))end;dO=dg(dO)dP=dg(dP)dX=dg(dX)dY=dg(dY)dZ=dg(dZ)if dP==0 then return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=dP,systemId=dO},dT)end;return setmetatable({latitude=du*df(dX,-90,90),longitude=du*(dY%360),altitude=dZ,id=dP,systemId=dO},dT)end;local e0={}e0.__index=e0;e0.__tostring=function(dC,dI)local e1=dI and dI..'  'local e2={}local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)for dK,e3 in ipairs(dJ)do e4=dC[e3]local e5=dH.__tostring(e4,e1)if dI then table.insert(e2,de('[%s]={\n%s\n%s}',e3,e5,dI))else table.insert(e2,de('  [%s]=%s',e3,e5))end end;if dI then return de('\n%s%s%s',dI,table.concat(e2,',\n'..dI),dI)end;return de('{\n%s\n}',table.concat(e2,',\n'))end;local function e6(e7)local e={}local pid;for dK,dr in pairs(e7)do local dP=dr.planetarySystemId;if type(dP)~='number'then error('Invalid planetary s ID: '..tostring(dP))elseif pid and dP~=pid then error('Mistringmatch planetary s IDs: '..dP..' and '..pid)end;local e8=dr.bodyId;if type(e8)~='number'then error('Invalid body ID: '..tostring(e8))elseif e[e8]then error('Duplicate body ID: '..tostring(e8))end;setmetatable(dr.center,getmetatable(vec3.unit_x))e[e8]=setmetatable(dr,dH)pid=dP end;return setmetatable(e,e0)end;e9={}local function ea(e7)return setmetatable({galaxyAtlas=e7 or{}},e9)end;e9.__index=function(dn,K)if type(K)=='number'then local a=dn.galaxyAtlas[K]return e6(a)end;return rawget(e9,K)end;e9.__pairs=function(dC)return function(dn,dF)local eb,ec=next(dn,dF)return eb,ec and e6(ec)end,dC.galaxyAtlas,nil end;e9.__tostring=function(dC)local ed={}for dK,ee in pairs(dC or{})do local ef=ee:getPlanetarySystemId()local eg=e0.__tostring(ee,'    ')table.insert(ed,de('  [%s]={%s\n  }',ef,eg))end;return de('{\n%s\n}\n',table.concat(ed,',\n'))end;e9.BodyParameters=dN;e9.MapPosition=dV;e9.PlanetarySystem=e6;function e9.createBodyParameters(dO,dP,eh,ei,ej,ek,el)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(eh),'Argument 3 (surfaceArea) must be a number:'..type(eh))assert(dm(ei),'Argument 4 (aPosition) must be an array or vec3:'..type(ei))assert(dm(ej),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ej))assert(dl(ek),'Argument 6 (altitude) must be in meters:'..type(ek))assert(dl(el),'Argument 7 (gravityAtPosition) must be number:'..type(el))local dQ=dh(eh/4/math.pi)local c4=dQ+ek;local em=vec3(ei)+c4*vec3(ej)local dS=el*c4*c4;return dN(dO,dP,dQ,em,dS)end;e9.isMapPosition=ds;function e9:getPlanetarySystem(dW)if K==nil then K=0 end;if ec==nil then ec=0 end;local dO=dW;if ds(dW)then dO=dW.systemId end;if type(dO)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ec)~=e0 then a=e6(a)end;return a end end end;function e0:sizeCalculator(en)return 1.05*en.radius end;function e0:castIntersections(eo,ep,eq,er,es,et)local eu={}if es then for dK,en in pairs(es)do table.insert(eu,en)end else eu=c_ end;if not et then table.sort(eu,function(ev,ew)local ex=ev.center;local ey=ew.center;return(ex.x-eo.x)^2+(ex.y-eo.y)^2+(ex.z-eo.z)^2<(ey.x-eo.x)^2+(ey.y-eo.y)^2+(ey.z-eo.z)^2 end)end;local ez=ep:normalize()for dK,en in ipairs(eu)do local eA=en.center-eo;local dQ=self:sizeCalculator(en)local eB=eA:dot(ez)local eC=eB^2-(eA:len2()-dQ^2)if eC>=0 then local eD=dh(eC)local eE=eB+eD;local eF=eB-eD;if eF>0 then return en,eE,eF elseif eE>0 then return en,eE,nil end end end;return nil,nil,nil end;function e0:closestBody(eG)assert(type(eG)=='table','Invalid coordinates.')local eH,en;local eI=vec3(eG)for dK,eJ in pairs(self)do local eK=(eJ.center-eI):len2()if(not en or eK<eH)and eJ.name~="Space"then en=eJ;eH=eK end end;return en end;function e0:convertToBodyIdAndWorldCoordinates(dW)local eL=dW;if dp(dW)then eL=dV(dW)end;if eL.id==0 then return 0,vec3(eL.latitude,eL.longitude,eL.altitude)end;local eJ=self:getBodyParameters(eL)if eJ then return eL.id,eJ:convertToWorldCoordinates(eL)end end;function e0:getBodyParameters(dW)local dP=dW;if ds(dW)then dP=dW.id end;assert(dl(dP),'Argument 1 (id) must be a number:'..type(dP))return self[dP]end;function e0:getPlanetarySystemId()local dK,dr=next(self)return dr and dr.systemId end;function dH:convertToMapPosition(dR)assert(dm(dR),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dR))local eM=vec3(dR)if self.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=self.systemId},dT)end;local eN=eM-self.center;local c4=eN:len()local dZ=c4-self.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=self.id,systemId=self.systemId},dT)end;function dH:convertToWorldCoordinates(dW)local eL=dp(dW)and dV(dW)or dW;if eL.id==0 then return vec3(eL.latitude,eL.longitude,eL.altitude)end;assert(ds(eL),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eL.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eL.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eQ=math.cos(eL.latitude)return self.center+(self.radius+eL.altitude)*vec3(eQ*math.cos(eL.longitude),eQ*math.sin(eL.longitude),math.sin(eL.latitude))end;function dH:getAltitude(dR)return(vec3(dR)-self.center):len()-self.radius end;function dH:getDistance(dR)return(vec3(dR)-self.center):len()end;function dH:getGravity(dR)local eR=self.center-vec3(dR)local eS=eR:len2()return self.GM/eS*eR/dh(eS)end;return setmetatable(e9,{__call=function(dK,...)return ea(...)end})end;local function eT(d,b,c,a,dh,eU)local ck={}local eV=100000000/3600;local eW=eV*eV;local eX=100;function ck.computeAccelerationTime(eY,eZ,e_)local f0=eV*math.asin(eY/eV)return(eV*math.asin(e_/eV)-f0)/eZ end;function ck.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/eV)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=eV*math.pi;local dr=function(dn)local fe=(fb*dn-fc*math.sin(math.pi*dn/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return eV*ff/dh(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(dr(fa))then local fh=0;while eU(fa-fh)>0.5 do local dn=(fa+fh)/2;if fg(dr(dn))then fa=dn else fh=dn end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=dr(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=eV*math.asin(eY/eV)local bK=(eV*math.asin(e_/eV)-f0)/f8;local fm=eW*math.cos(f0/eV)/f8;local c4=fm-eW*math.cos((f8*bK+f0)/eV)/f8;return c4+f9,bK+fa end;function ck.computeTravelTime(eY,eZ,c4)if c4==0 then return 0 end;if eZ>0 then local f0=eV*math.asin(eY/eV)local fm=eW*math.cos(f0/eV)/eZ;return(eV*math.acos(eZ*(fm-c4)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c4/eY end;return ck end;local function fn(d,b,c,a,de,df,dg,dh,di)local vec3=vec3;local dd=dd(d,b,c,a,de,df,dg,dh,di)local function dp(a)return type(a)=='string'end;local function dm(dn)return type(dn)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(dZ)assert(self.body)local c4=dZ+self.body.radius;if not di(c4,0)then local fp=dh(self.body.GM/c4)return dh(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dW,fq)assert(self.body)assert(dm(dW)or dp(dW))assert(dm(fq))local fr=(dp(dW)or dd.isMapPosition(dW))and self.body:convertToWorldCoordinates(dW)or vec3(dW)local dr=vec3(fq)local fs=fr-self.body.center;local ft=dr:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(dr)*dr)/fv;local ex=fv/(2*fv/fu-ft)local fx=fw:len()local ez=fw:normalize()local fy=ex*(1-fx)local fz=ex*(1+fx)local fA=fy*ez+self.body.center;local fB=fx<=1 and-fz*ez+self.body.center or nil;local fC=dh(ex*fv*(1-fx*fx))local fD=fB and 2*math.pi*dh(ex^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(dr)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=dh(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=dh(fv/fz),altitude=fz-self.body.radius},currentVelocity=dr,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eJ=dd.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eJ},fo)end;return setmetatable(fo,{__call=function(dK,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)local function fS(fT)local dU=fU:closestBody(fT)if(fT-dU.center):len()>dU.radius+dU.noAtmosphericDensityAltitude then dU=e[0][0]end;return dU end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cP={}for dF,dr in pairs(e[0])do cP[#cP+1]={name=dr.name,index=dF}end;table.sort(cP,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dF,dr in pairs(f_)do if dr.name and dr.name==g0 then return dF end end;return-1 end;local function g2()cX=bj;if bj==0 then bh="None"c1=nil;g1=nil;return true end;local g3=cP[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c1=cj[0][g3]if g1~=nil then if ca==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dK,dr in pairs(cj[0])do if dr.name==g1.planetname then c1=dr;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c1.center)else bi=g1.position end;if c1.planetname~="Space"then if c1.hasAtmosphere then gl=bI(c1.radius*(S-1)+c1.noAtmosphericDensityAltitude)else gl=bI(c1.radius*(S-1)+c1.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dK,bd=cl(c1):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c6 and not bx and not b6 and not c7 then if gn==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then g2()else local g3=cP[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bX="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bX=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d4=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d4 else gr=bn end;if dbHud_1 or gv or gq then local dU=fS(fT)local gy={position=fT,name=gu,planetname=dU.name,gravity=b.g(),safe=gw}if not gv then gr[#gr+1]=gy else for dF,dr in pairs(e[0])do if dr.name and gu==dr.name then table.remove(e[0],dF)end end end;table.insert(e[0],gy)fV()g2()bX="Location saved as "..gu.."("..dU.name..")"return gr else bX="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d4=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cb;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bX=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bX=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cD:cross(cH)*5000;bX=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bX=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.g()gF.position=cJ;gF.safe=true end;bX=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bX="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dF,dr in pairs(d5)do table.insert(e[0],dr)end;if gG then for dF,dr in pairs(gG)do gz[dF]=dr end end;fV()if bj>#cP then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP=0;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local gX;local gY=0;local gZ={}local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local ft=h4-h2;local hc=ft:normalize()local hd=ft:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local dt=h9-hk^2-hl^2;local hm=dh(dt)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if eU((h8-hn):len()-h7)<eU((h8-ho):len()-h7)then return hn else return ho end end;local function hp(hq,fu,hr)local hs=hq.pts;local gs=#hs;local ht=hq.ref;if gs>3 then local hu,hv,hw,hx=hs[gs],hs[gs-1],hs[gs-2],hs[gs-3]hq.ref=hr;local fr=h0(hu[1],hu[2],hv[1],hv[2],hw[1],hw[2],hx[1],hx[2])local hk,hl,hm=fr.x,fr.y,fr.z;if hk==hk and hl==hl and hm==hm then hk=hk+ht[1]hl=hl+ht[2]hm=hm+ht[3]local hy=vec3(hk,hl,hm)hq.center=hy;if hq.lastPos then if(hq.lastPos-hy):len()<2 then local hz=(hy-vec3(hr)):len()if eU(hz-fu)<10 then hq.skipCalc=true end end end;hq.lastPos=hy end;hq.pts={}else local hA={hr[1]-ht[1],hr[2]-ht[2],hr[3]-ht[3]}hs[gs+1]={fu,hA}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hB=gU[1].getData()local hC=hB:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hr={cJ["x"],cJ["y"],cJ["z"]}local hD,hE=0,0;local hF=cG*10;gT,gS=0,0;for dr in hC do local dP,c4,hG=dr:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gN[hG]c4=dg(c4)if gU[1].hasMatchingTransponder(dP)==1 then table.insert(gM,dP)end;if E then local hI=gU[1].getConstructType(dP)if F and gU[1].isConstructAbandoned(dP)==1 or c4<hF and(hH>27 or hI=="static"or hI=="space")then gT=gT+1;local gu=gU[1].getConstructName(dP)local hq=gZ[dP]if hq==nil then hH=hH+gK;gZ[dP]={pts={},ref=hr,name=gu,i=0,radius=hH,skipCalc=false}hq=gZ[dP]end;if not hq.skipCalc then hp(hq,c4,hr)if F and not hq.abandoned and gU[1].isConstructAbandoned(dP)==1 and hq.center then fQ("abRdr","RD")a.print("Abandoned Construct: "..gu.." ("..hI..") rough ::pos{0,0,"..hq.center.x..","..hq.center.y..","..hq.center.z.."}")bX="Abandoned Radar Contact ("..hI..") detected"hq.abandoned=true end;hE=hE+1 else table.insert(gO,hq)end end;hD=hD+1;if cT and hD>700 or hE>70 or(not cT and hD>300 or hE>30)then coroutine.yield()hD,hE=0,0 end end end;gS=#gO;if gS>0 and(cG>20 or b4)then local en,hJ,hK,hL;local hM=0;local hN=cj:getPlanetarySystem(0)hL=cF:normalize()while hM<gS do coroutine.yield()local hO={table.unpack(gO,hM,math.min(hM+75,gS))}en,hJ,hK=hN:castIntersections(cJ,hL,nil,nil,hO,true)if en and hK then cV={en,hJ,hK}break end;hM=hM+75 end;if not en then cV=nil end else cV=nil end;gO={}gQ=hB:find('identifiedConstructs":%[%]')else gR=hB:find('worksInEnvironment":false')end end end;local function hP()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hP()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hP()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hP()end end end;function gL.UpdateRadar()local hQ=coroutine.status(gW)if hQ=="suspended"then local dG,hR=coroutine.resume(gW)if hR then a.print("ERROR UPDATE RADAR: "..hR)end elseif hQ=="dead"then gW=coroutine.create(g_)local dG,hR=coroutine.resume(gW)end end;function gL.GetRadarHud(hS,hT,au,av)local hU=gM;local hV,hW;gM={}local dx=gS or 0;if gP>0 then if E then hW=dx.."/"..gT.." Plotted : "..gP-gT.." Ignored"else hW="Radar Contacts: "..gP end;hV=gJ(au,av,hW,"pbright txtbig txtmid")if#gM>0 then hV=hV..gJ(hS,hT,"Friendlies In Range","pbright txtbig txtmid")for dF,dr in pairs(gM)do hT=hT+20;hV=hV..gJ(hS,hT,gU[1].getConstructName(dr),"pdim txtmid")end end;if gQ==nil and gX==nil then gY=1;cp.ToggleRadarPanel()end;if gQ~=nil and gX~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gR then hV=gJ(au,av,gV.." Radar: Jammed","pbright txtbig txtmid")else hV=gJ(au,av,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gY=0;cp.ToggleRadarPanel()end end;return hV end;function gL.GetClosestName(gu)if gU[1]then local dP,dK=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dP~=nil and dP~=""then gu=gu.." "..gU[1].getConstructName(dP)end end;return gu end;function gL.ToggleRadarPanel()if d3~=nil and gY==0 then gI(d3)d3=nil;if gX~=nil then gI(gX)gX=nil end else if gY==1 then gI(d3)d3=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")gX=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gY=0 end end;function gL.ContactTick()if not hX then hX=0 end;if bK>hX+10 then bX="Radar Contact"fQ("rdrCon","RC")hX=bK end;c.stopTimer("contact")end;function gL.onEnter(dP)if radar_1 and not c9 and not cQ then c.setTimer("contact",0.1)end end;function gL.onLeave(dP)if radar_1 and E then if#gZ>650 then dP=tostring(dP)gZ[dP]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hP()end;gW=coroutine.create(g_)if hY then for dF,dr in pairs(hY)do gL[dF]=dr end end;return gL end;local function hZ(db,d_,bI)local h_={}local i0=db.getResistancesCooldown()local function i1()local i2=db.getState()if G then if not cQ and i2==0 then db.toggle()elseif cQ and i2==1 then db.toggle()end end end;local function i3()local i4=db.getStressRatioRaw()local i5=0.5999;if i4[1]==0.0 and i4[2]==0.0 and i4[3]==0.0 and i4[4]==0.0 then return end;local i6=db.setResistances(i5*i4[1],i5*i4[2],i5*i4[3],i5*i4[4])if i6==1 then bX="Shield Resistances updated"else bX="Value Exceeded. Failed to update Shield Resistances"end end;function h_.shieldTick()dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())i1()i0=db.getResistancesCooldown()if i0==0 and dc<a7 then i3()end end;function h_.setResist(i7)if not db then bX="No shield found"return elseif i7==nil or i0>0 then bX="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy=dx..', '..dx..', '..dx..', '..dx;local i8,i9,ia,ib=d_(i7,dy)if ib==nil or i8+i9+ia+ib>0.6 then bX="Improperly formatted or total exceeds 0.6"return end;if db.setResistances(i8,i9,ia,ib)==1 then bX="Shield Resistances set"else bX="Resistance setting failed."end end;function h_.ventShield()local ic=db.getVentingCooldown()if ic>0 then bX="Cannot vent again for "..ic.." seconds"return end;if db.getShieldHitpoints()<db.getMaxShieldHitpoints()then db.startVenting()bX="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bX="Shields already at max hitpoints"end end;if id then for dF,dr in pairs(id)do h_[dF]=dr end end;return h_ end;local function ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)local it=9.80665;local iu={}local iv={}local iw={}local ix={}local iy=nil;local iz=nil;local iA=nil;local iB=false;local iC="none"local iD=""local iE=55;local iF=0;local iG=0;local iH=nil;local iI=ac;local iJ=ad;local iK=ae;local iL=[[rgb(]]..bI(iI+0.5)..","..bI(iJ+0.5)..","..bI(iK+0.5)..[[)]]local iM=[[rgb(]]..bI(iI*0.9+0.5)..","..bI(iJ*0.9+0.5)..","..bI(iK*0.9+0.5)..[[)]]local iN=0;local iO=0;local iP=""local iQ=bH()local iR=false;local iS=false;local function iT(dr)if ce==1920 then return dr else return fR(ce*dr/1920,0)end end;local function iU(dr)if cf==1080 then return dr else return fR(cf*dr/1080,0)end end;local function iV()return il()==0 and g~="keyboard"and ij()==0 end;local function iW()local iX="TRAVEL"if not cM then iX="CRUISE"end;if b1 then iX="AUTOPILOT"end;return iX end;local hV=""local iY=""local iZ=""local i_=1;local j0=2;local j1=3;local j2=4;local j3=5;local j4=6;local j5=7;local j6=""local j7=0;local j8=120.0*aR;local j9={}local ja={}local jb={}local jc={}local jd={}local je={}local jf={}jf["atmofueltank"],jf["spacefueltank"],jf["rocketfueltank"]=0,0,0;local jg=0;local function jh(hk,ji,jj,jk,jl,jm)local jn=jg;local jo=jg+5;if not B then jo=jo+5 end;if ij()==1 and not l then jn=jn-50;jo=jo-50 end;if jj=="ATMO"then j6="atmofueltank"elseif jj=="SPACE"then j6="spacefueltank"else j6="rocketfueltank"end;j7=_G[j6 .."_size"]if#jk>0 then for K=1,#jk do local gu=jk[K][j0]local jp=jk[K][j5]for jq=1,j7 do if jk[K][j0]==ih(c[j6 .."_"..jq].getData()).name then jp=jq;break end end;local jr=bH()if jl[K]==nil or jm[K]==nil or jr-jk[K][j4]>j8 then local js;local jt=0;jt=ii(jk[K][i_])-jk[K][j2]js=jk[K][j3]if js>jt then jf[j6]=jf[j6]+js-jt end;if jp~=0 then local ju=ih(c[j6 .."_"..jp].getData())jm[K]=ju.percentage;jl[K]=ju.timeLeft;if jl[K]=="n/a"then jl[K]=0 end else jm[K]=bI(0.5+jt*100/jk[K][j1])if js<=jt then jl[K]=0 else jl[K]=bI(0.5+jt/((js-jt)/(jr-jk[K][j4])))end end;jk[K][j4]=jr;jk[K][j3]=jt end;if gu==ji then gu=de("%s %d",jj,K)end;if jp==0 then gu=gu.." *"end;local jv;if jl[K]==0 then jv=""else jv=iq(jl[K])end;if jm[K]~=nil then local jw=bI(jm[K]*2.55)local jx=de("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""if jv~=""and jl[K]<120 or jm[K]<5 then jy="red "end;local jz=de("rgb(%d,%d,%d)",df(bI((255-jw)/2.55),50,100),df(bI(jw/2.55),0,50),50)local jA="rgb(196,0,255)"if jj=="ATMO"then jA="rgb(0,188,255)"elseif jj=="SPACE"then jA="rgb(239,255,0)"end;local jB=false;if jC~=jA then jB=true end;jC=jA;if B then if jB then jn=jn-5;jo=jo-5 end;iY=iY..de([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jz,jA,hk,jo,jx,bI(jm[K]*1.7+0.5)-2,hk+1,jo+1,hk+5,jo+14,gu,jm[K],jv)jn=jn-22;jo=jo-22 else iY=iY..gJ(hk,jn,gu,jy.."pdim txtfuel")iY=iY..gJ(hk,jo,de("%d%% %s",jm[K],jv),"pdim txtfuel","fill:"..jx)jn=jn+30;jo=jo+30 end end end end;jg=jn end;local function jD(jE,dZ)if am==0 and an==0 then return end;if dZ<200000 and not c9 or dZ and c9 then local jF=0;if eU(cI)>1 then jF=45*math.log(eU(cI),10)if cI<0 then jF=-jF end end;jE[#jE+1]=de([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cI),bI(jF))end;return jE end;local function jG(jH)local gn=-cH;jH=jH-jH:project_on(gn)local jI=vec3(0,0,1)jI=jI-jI:project_on(gn)local jJ=jI:cross(gn)local jF=jI:angle_between(jH)*constants.rad2deg;if jH:dot(jJ)<0 then jF=360-jF end;return jF end;local function jK(jE,ai,aj,jL,jM,cT)if ab==0 then return end;local jN=ab;local jO=20;local jP=bI(jL)if cT then for K=-45,45,5 do local jQ=K;jE[#jE+1]=de([[<g transform="rotate(%f,%d,%d)">]],jQ,ai,aj)jR=5;if K%15==0 then jR=15 elseif K%10==0 then jR=10 end;jE[#jE+1]=de([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jN+jO-jR,ai,aj+jN+jO)end;jE[#jE+1]=gJ(ai,aj+jN+jO-35,jM,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+jN+jO-25,jP.." deg","pdim txt txtmid")jE[#jE+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jL,ai,aj)jE[#jE+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jN+jO-20,ai+5,aj+jN+jO-20,ai,aj+jN+jO-15)jE[#jE+1]="</g>"end;jE[#jE+1]=[[<g style="clip-path: url(#headingClip);">]]local jS=jP;if cT then jS=jG(cC)end;local jT=20;local jU=bI(jS)local jV=0;local jW=aj+jN+jO+20;local jX=ai;if jM~="YAW"then jW=iU(130)jX=iT(960)end;local jY=[[<path class="txttick line" d="]]local jZ=bI(jU-(jT+10)-jU%5+0.5)for K=jZ+70,jZ,-5 do local hk=jX-(-K*5+jS*5)if K%10==0 then jV=10;local dx=K;if dx==360 then dx=0 elseif dx>360 then dx=dx-360 elseif dx<0 then dx=dx+360 end;jE[#jE+1]=gJ(hk,jW+15,dx,"txtmid bright")elseif K%5==0 then jV=5 end;if jV==10 then jY=de([[%s M %f %f v %d]],jY,hk,jW-5,jV)else jY=de([[%s M %f %f v %d]],jY,hk,jW-2.5,jV)end end;jE[#jE+1]=jY..[["/>]]jE[#jE+1]=de([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jX-5,jW-20,jX+5,jW-20,jX,jW-10)if I then if cT then jM="HDG"end;jE[#jE+1]=gJ(iT(960),iU(100),jU.."°","dim txt txtmid size14","")jE[#jE+1]=gJ(iT(960),iU(85),jM,"dim txt txtmid size20","")end;jE[#jE+1]=[[</g>]]end;local function j_(jE,k0,jL,ai,aj,cT,k1,fl)if ab==0 then return end;local jN=ab;local k2=bI(jN*3/5)if jN>0 then local k3=bI(k0)local jR=0;local jY=de([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jL,ai,aj)if not c9 then jY=de([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jE[#jE+1]=de([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jN-1,ai,aj)jE[#jE+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(k3-30-k3%5+0.5),bI(k3+30+k3%5+0.5),5 do if K%10==0 then jR=30 elseif K%5==0 then jR=20 end;local hl=aj+-K*5+k0*5;if jR==30 then jY=de([[%s M %d %f h %d]],jY,ai-k2-jR,hl,jR)if c9 then jE[#jE+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ai,aj,ai-k2+10,hl+4,K)jE[#jE+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jL,ai,aj,ai+k2-10,hl+4,K)if K==0 or K==180 or K==-180 then jE[#jE+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ai,aj,ai-k2+20,hl,k2*2-40)end else jE[#jE+1]=gJ(ai-k2+10,hl,K,"pdim txt txtmid")jE[#jE+1]=gJ(ai+k2-10,hl,K,"pdim txt txtmid")end;jY=de([[%s M %d %f h %d]],jY,ai+k2,hl,jR)else jY=de([[%s M %d %f h %d]],jY,ai-k2-jR,hl,jR)jY=de([[%s M %d %f h %d]],jY,ai+k2,hl,jR)end end;jE[#jE+1]=jY..[["/>]]local k4="PITCH"if not cT then k4="REL PITCH"end;if k0>90 and not c9 then k0=90-(k0-90)elseif k0<-90 and not c9 then k0=-90-(k0+90)end;if jN>200 then if c9 then if fl>iE then jE[#jE+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+20,k1,"pdim txt txtmid")end;jE[#jE+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jL,ai,aj)else jE[#jE+1]=de([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jE[#jE+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k2+25,aj-5,ai-k2+20,aj,ai-k2+25,aj+5,ai-k2+50,aj+4,k3)jE[#jE+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k2-25,aj-5,ai+k2-20,aj,ai+k2-25,aj+5,ai+k2-30,aj+4,k3)jE[#jE+1]="</g>"end;local k5=bI(jN/3)jE[#jE+1]=de([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-k5,aj,jN-k5)if not c9 and cT then jE[#jE+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jL,ai,aj,ai-k2+10,aj,k2*2-20)end;jE[#jE+1]="</g>"if jN<200 then if c9 and fl>iE then jE[#jE+1]=gJ(ai,aj-jN,k4,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-jN+10,k3,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jE[#jE+1]=gJ(ai,aj+20,k1,"pdim txt txtmid")else jE[#jE+1]=gJ(ai,aj-jN,k4,"pdim txt txtmid")jE[#jE+1]=gJ(ai,aj-jN+15,k3,"pdim txt txtmid")end end end end;local function k6(jE,dZ,cT)local k7=ao;local k8=ap;if k7==0 and k8==0 then return end;local k9=78;local ka=19;local kb=c8;if c8~=-1 then jE[#jE+1]=gJ(k7+k9,k8+ka+20,de("AGL: %.1fm",c8),"pdim altsm txtend")end;if cT and(dZ<200000 and not c9 or dZ and c9)then table.insert(jE,de([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k7-1,k8-4,k9+2,ka+6,k7+1,k8-1,k9-4,ka))local gs=0;local kc=1;local kd=0;local ke=dZ<0;local kf=dZ<kg.surfaceMaxAltitude;local kh=9;if ke then kh=0 end;local dZ=eU(dZ)while gs<6 do local ki=11;local kj=16;local kk=9;local kl=14;local jy="altsm"if gs>2 then kj=kj+3;ki=ki+2;kl=kl+2;kk=kk-6;jy="altbig"end;if ke then jy=jy.." red"elseif kf then jy=jy.." orange"end;local km=dZ/kc%10;local kn=bI(km)local ko=bI((kn+1)%10)local kp=kd;if gs==0 then kp=km-kn;if ke then kp=1-kp end end;if ke and(gs==0 or kd~=0)then local gv=ko;ko=kn;kn=gv end;local kq=kj*(kp-1)local kr=kq+kj;local hk=k7+kk+(6-gs)*ki;local hl=k8+kl;jE[#jE+1]=gJ(hk,hl+kq,ko,jy)jE[#jE+1]=gJ(hk,hl+kr,kn,jy)gs=gs+1;kc=kc*10;if kn==kh then kd=kp else kd=0 end end;table.insert(jE,[[</g></g>]])end end;local function ks(fq)local kt=-math.deg(eP(fq.y,fq.z))+180;kt=kt-90;if kt<0 then kt=360+kt end;if kt>180 then kt=-180+kt-180 end;return-kt end;local function ku(fq)local jS=math.deg(eP(fq.y,fq.x))-90;if jS<-180 then jS=360+jS end;return jS end;local function kv(jE,fq,fl,ai,aj)if fl>5 and not c9 or fl>iE then local jN=ab;local kw=20;local kx=20;local ky=ks(fq)local kz=ku(fq)local kA=14;local kB=kA/2;local kC=-kz/kx*jN;local kD=ky/kw*jN;local hk=ai+kC;local hl=aj+kD;local c4=dh(kC^2+kD^2)local kE=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kB/kA..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kA..[[,]]..hl..[[ h ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+kB..[[,]]..hl..[[ h ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kA..[[ v ]]..kB..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c4<jN then jE[#jE+1]=kE else local jF=eP(kD,kC)local kF=4;local kG=ai+jN*math.cos(jF)local kH=aj+jN*math.sin(jF)jE[#jE+1]=de('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jF*180/math.pi,kG,kH,kG-kF,kH-kF/2,kF*2,kF,kG+kF,kH-kF,kF,kF,-kF,kF)end;if not c9 then local kI=vec3(fq)ky=ks(-kI)kz=ku(-kI)kC=-kz/kx*jN;kD=ky/kw*jN;hk=ai+kC;hl=aj+kD;c4=dh(kC^2+kD^2)if c4<jN then local kJ=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kA..[[ v ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-kB..[[,]]..hl..[[ h ]]..kA..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]jE[#jE+1]=kJ end end end end;local function kK(jE,iX,kL,kM)if ak==0 and al==0 then return end;kL=bI(kL+0.5)local jn=al+10;local jo=al+20;if ij()==1 and not l then jn=55;jo=65 end;local kN="CRUISE"local c="km/h"local dG=kM;if iX=="TRAVEL"or iX=="AUTOPILOT"then kN="THROT"c="%"dG=kL;local kO="dim"if kL<0 then kO="red"end;jE[#jE+1]=de([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kO,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eU(kL),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jE[#jE+1]=gJ(ak+10,jn,kN,"pbright txtstart")jE[#jE+1]=gJ(ak+10,jo,de("%.0f %s",dG,c),"pbright txtstart")if c9 and t and cM and bN then kL=bI(bO*100+0.5)local kO="red"if kL<0 then kO="red"end;jE[#jE+1]=de([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kO,1-eU(kL),ak-10,al+50,ak-15,al+53,ak-15,al+47)jE[#jE+1]=gJ(ak+10,jn+40,"LIMIT","pbright txtstart")jE[#jE+1]=gJ(ak+10,jo+40,kL.."%","pbright txtstart")end;if c9 and t or b6 then jE[#jE+1]=gJ(ak+10,jn-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c9 and b1 then jE[#jE+1]=gJ(ak+10,jn-40,"LIMIT: "..bI(_*3.6+0.5).." km/h","dim txtstart")end end;local function kP(jE,kQ)if ak==0 and al==0 then return end;local kR=al-10;local kS=ak+10;jE[#jE+1]=gJ(0,0,"","pdim txt txtend")if ij()==1 and not l then kR=75 end;jE[#jE+1]=gJ(kS,kR,bI(kQ).." km/h","pbright txtbig txtstart")end;local function kT(jE)jE[#jE+1]=gJ(iT(150),iU(1070),de("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jE[#jE+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jE[#jE+1]=gJ(iT(960),iU(550),"Warning: Invalid Control Scheme Detected","warnings")jE[#jE+1]=gJ(iT(960),iU(600),"Keyboard Scheme must be selected","warnings")jE[#jE+1]=gJ(iT(960),iU(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kU=iT(960)local kV=iU(860)local kW=iU(880)local kX=iU(900)local kY=iU(960)local kZ=iU(200)local k_=iU(250)local l0=iU(960)if ij()==1 and not l then kV=iU(135)kW=iU(155)kX=iU(175)kZ=iU(115)k_=iU(95)end;local l1="#222222"local l2="white"local l3="dimmer"local l4="pbright"local l5="#110000"local l6=l1;local l7=l3;if aZ then local l8=""if type(aZ)=="string"then l8="-"..aZ end;jE[#jE+1]=gJ(kU,kV,"Brake Engaged"..l8,"warnings")l5="#440000"l6=l2;l7=l4 elseif bM>0 then jE[#jE+1]=gJ(kU,kV,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local l9="#110000"local la=l1;local lb=l3;if c9 and cv and c8==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jE[#jE+1]=gJ(kU,kZ+50,"** STALL WARNING **","warnings")l9="#ff0000"la=l2;lb=l4;fQ("stall","SW",2)end end;if cS then jE[#jE+1]=gJ(kU,kZ+90,"Flight Assist in Progress","warnings")end;if cd then jE[#jE+1]=gJ(kU,l0,"Gyro Enabled","warnings")end;local lc="#111100"local ld=l1;local le=l3;if bk then lc="#775500"ld=l2;le=l4;if bQ then jE[#jE+1]=gJ(kU,kW,"Gear Extended","warn")else jE[#jE+1]=gJ(kU,kW,"Landed (G: Takeoff)","warnings")end end;if c8>-1 and(not cL or cb<100)then local lf=ip(d:getTargetGroundAltitude())jE[#jE+1]=gJ(kU,kX,"Hover Height: "..lf,"warn")end;local lg="#000011"local lh=l1;local li=l3;if bZ then lg="#0000DD"lh=l2;li=l4;jE[#jE+1]=gJ(kU,kY+20,"ROCKET BOOST ENABLED","warn")end;local lj="#001100"local lk=l1;local ll=l3;if antigrav and not q and cL and bt~=nil then lj="#00DD00"lk=l2;ll=l4;local lm="warnings"if eU(cb-antigrav.getBaseAltitude())<501 then lm="warn"end;jE[#jE+1]=gJ(kU,kZ+40,de("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),lm)end;if b1 and bh~="None"then jE[#jE+1]=gJ(kU,kZ,"Autopilot "..be,"warn")elseif br~=nil then jE[#jE+1]=gJ(kU,kZ+20,de("LockedPitch: %d",bI(br)),"warn")elseif bV then jE[#jE+1]=gJ(kU,kZ+20,"Follow Mode Engaged","warn")elseif b6 or c7 then jE[#jE+1]=gJ(kU,kZ+20,"Re-entry in Progress","warn")end;if b3 or b7 then local lf=ip(b8,2)if b7 then if cL then lf=ip(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jE[#jE+1]=gJ(kU,kZ,"VTO to "..lf,"warn")elseif b5 and not bx then if c6 then jE[#jE+1]=gJ(kU,kZ,"Takeoff to "..bh,"warn")else jE[#jE+1]=gJ(kU,kZ,"Takeoff to "..lf,"warn")end;if aZ and not b7 then jE[#jE+1]=gJ(kU,kZ+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jE[#jE+1]=gJ(kU,kZ,"Altitude Hold: "..de("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if ca>0.1 then jE[#jE+1]=gJ(kU,kZ+20,"Beginning ascent","warn")elseif ca<0.09 and ca>0.05 then jE[#jE+1]=gJ(kU,kZ+20,"Aligning trajectory","warn")elseif ca<0.05 then jE[#jE+1]=gJ(kU,kZ+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jE[#jE+1]=gJ(kU,kZ,cx,"warn")end end;if b4 then if ln then local lo="Brake Landing"if d7 then lo=lo.."-Aligning"end;if d6 then lo=lo.."-Drift Limited"end;jE[#jE+1]=gJ(kU,kZ,lo,"warnings")else jE[#jE+1]=gJ(kU,kZ,"Coast-Landing","warnings")end end;if b0 then jE[#jE+1]=gJ(kU,kZ,"Prograde Alignment","crit")end;if a_ then jE[#jE+1]=gJ(kU,kZ,"Retrograde Alignment","crit")end;local lp="#110000"local lq=l1;local lr=l3;if cU then lp="#FF0000"lq=l2;lr=l4;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jE[#jE+1]=gJ(kU,k_+20,cU,type)elseif ca==0 then local ls,lt=co.checkLOS(cF:normalize())if lt~=nil then lr=l4;lp="#FF0000"lq=l2;local lf=ip(lt)local lu=ck.computeTravelTime(cG,0,lt)local lv="Collision"if ls.noAtmosphericDensityAltitude>0 then lv="Atmosphere"end;jE[#jE+1]=gJ(kU,k_+20,ls.name.." "..lv.." "..iq(lu).." In "..lf,"crit")end end;if bo and not bx then jE[#jE+1]=gJ(kU,kZ+60,lw,"warn")end;local lx="#111100"local ly=l1;local lz=l3;if cY and#cY>1 then lx="#DDDD00"ly=l2;lz=l4 end;local lA=iT;local lB=iU;local l3="topButton"local lC="topButtonActive"local lD=l3;if b1 or bo or c6 or bx then lD=lC end;local lE=l3;if b0 then lE=lC end;local lF=l3;if b4 or bk then lF=lC end;local lG=l3;if b3 or bo then lG=lC end;local lH=l3;if a_ then lH=lC end;local lI=l3;if bx or cz and b1 then lI=lC end;if w and I then local lJ=lB(30)jE[#jE+1]=de([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lD,lA(960),lB(54),lB(-53),lA(-120),lA(25),lB(50))jE[#jE+1]=gJ(lA(910),lJ,"AUTOPILOT")jE[#jE+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,lA(865),lB(51),lA(-25),lB(-50),lA(-110),lA(25),lB(46))jE[#jE+1]=gJ(lA(800),lJ,"PROGRADE")jE[#jE+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lA(755),lB(47),lA(-25),lB(-46),lA(-98),lA(44),lB(44))jE[#jE+1]=gJ(lA(700),lJ,"LAND")jE[#jE+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lG,lA(960),lB(54),lB(-53),lA(120),lA(-25),lB(50))jE[#jE+1]=gJ(lA(1010),lJ,"ALT HOLD")jE[#jE+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,lA(1055),lB(51),lA(25),lB(-50),lA(110),lA(-25),lB(46))jE[#jE+1]=gJ(lA(1122),lJ,"RETROGRADE")jE[#jE+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lA(1165),lB(47),lA(25),lB(-46),lA(98),lA(-44),lB(44))jE[#jE+1]=gJ(lA(1220),lJ,"ORBIT")jE[#jE+1]=[[
                                    </g>
                                </g>]]jE[#jE+1]="</g>"end;return jE end;local function lK(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lL(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cP[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lM(jE)local lN=co.routeWP(true)if not lN or#lN==0 then return end;local hk=iT(750)local hl=iU(360)if b1 or bo then jE[#jE+1]=gJ(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else jE[#jE+1]=gJ(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dF,K in pairs(lN)do hl=hl+20;jE[#jE+1]=gJ(hk,hl,dF..". "..lN[dF],"pdim txtstart size20")end end;local function lO(jE)local hk=ay+10;local hl=az+20;local lP={}local lQ={"Alt-4: AutoTakeoff to Target"}local lR={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lS={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lT={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lP,"--------------DYNAMIC-----------------")if c9 then if c8~=-1 then im(lP,lQ)if c1 and kg and c1.name==kg.name then table.insert(lP,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lP,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lP,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lP,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lP,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lP,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lP,"G: Takeoff to hover height, raise gear")else table.insert(lP,"G: Lowergear and Land")end else im(lP,lR)table.insert(lP,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lP,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else im(lP,lS)if db then table.insert(lP,"Alt-Shift-6: Vent shields")if not G then table.insert(lP,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lP,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lP,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lP,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lP,"Alt-Spacebar/C will raise/lower target height")table.insert(lP,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c9 then table.insert(lP,"LALT+Mousewheel will lower/raise speed limit")end;im(lP,lT)for K=1,#lP do hl=hl+12;jE[#jE+1]=gJ(hk,hl,lP[K],"pdim txtbig txtstart")end end;local function lU(jE)local lV=ay;local lW=az;local lX=ax;local lY=4;local lZ=15;local hk=0;local hl=0;local l_,m0,m1,m2;local m3;local function m4(type)local gE,bK,fl,m5,jy,m6;if type=="Periapsis"then gE=m3.periapsis.altitude;bK=m3.timeToPeriapsis;fl=m3.periapsis.speed;jy="txtend"m5=12;m6=math.min(hk,lV+lX-kg.radius/m1-lY*2)else gE=m3.apoapsis.altitude;bK=m3.timeToApoapsis;fl=m3.apoapsis.speed;m5=-12;jy="txtstart"m6=hk end;if cG<1 then bK=0 end;jE[#jE+1]=de([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6+m5,hl-5,hk,hl-5)jE[#jE+1]=de([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m6-m5*4,hl+2,hk,hl+2)jE[#jE+1]=gJ(m6,hl,type,jy)hk=m6-m5*2;hl=hl+lZ;local lf=ip(gE)jE[#jE+1]=gJ(hk,hl,lf,jy)hl=hl+lZ;jE[#jE+1]=gJ(hk,hl,iq(bK),jy)hl=hl+lZ;jE[#jE+1]=gJ(hk,hl,lK(fl),jy)end;local m7=lX*1.5;if bF=="INFO"then m7=25*9 end;if bF~="HIDE"then jE[#jE+1]=[[<g class="pbright txtorb txtmid">]]jE[#jE+1]=de('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lX*2,m7,lV,lW)jE[#jE+1]=de([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lX*2,m7,lV,lW)end;local m8=lX*1.5;local m9=lX*2;local ma=m8/2;local mb=lX;local mc=lV+mb;local md=lW+ma;local me=lV+m9;local mf=lW+m8;if bF=="ORBIT"then lW=lW+lY;l_=lX/2;m2=0;m3={}m3.periapsis={}m3.apoapsis={}if fp~=nil then if fp.periapsis~=nil then m3.periapsis.altitude=fp.periapsis.altitude;m3.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then m3.apoapsis.altitude=fp.apoapsis.altitude;m3.apoapsis.speed=fp.apoapsis.speed end;m3.period=fp.period;m3.eccentricity=fp.eccentricity;m3.timeToApoapsis=fp.timeToApoapsis;m3.timeToPeriapsis=fp.timeToPeriapsis;m3.eccentricAnomaly=fp.eccentricAnomaly;m3.trueAnomaly=fp.trueAnomaly end;if m3.periapsis==nil then m3.periapsis={}m3.periapsis.altitude=-kg.radius;m3.periapsis.speed=_ end;if m3.eccentricity==nil then m3.eccentricity=1 end;if m3.apoapsis==nil then m3.apoapsis={}m3.apoapsis.altitude=cb;m3.apoapsis.speed=0 end;if cG<1 then m3.apoapsis.altitude=cb;m3.apoapsis.speed=0 end;if m3.apoapsis.altitude then m1=(m3.apoapsis.altitude+m3.periapsis.altitude+kg.radius*2)/(l_*2)m0=(kg.radius+m3.apoapsis.altitude)/m1*(1-m3.eccentricity)m2=l_-m3.periapsis.altitude/m1-kg.radius/m1;local mg=math.pi;if m3.period~=nil and m3.period>0 and m3.timeToApoapsis~=nil then mg=m3.eccentricAnomaly;if m3.timeToPeriapsis<m3.timeToApoapsis then mg=2*math.pi-mg end end;if cG<1 or mg~=mg then mg=math.pi end;local mh=-l_*math.cos(mg)+lV+mb+lY;local mi=m0*math.sin(mg)+lW+ma+lY;local mj=""jE[#jE+1]='<g clip-path="url(#orbitRect)">'jE[#jE+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mj,lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)if m0<1 then jE[#jE+1]=de([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lV+lX+lY-m2,lW+lX*1.5/2+lY,mh,mi)end;jE[#jE+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kg.radius+kg.noAtmosphericDensityAltitude)/m1)jE[#jE+1]=de('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lV+lX+lY-m2,lW+lX*1.5/2+lY,(kg.radius+kg.noAtmosphericDensityAltitude)/m1)jE[#jE+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lV+lX+lY,lW+lX*1.5/2+lY,l_,m0)jE[#jE+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lV+lX+lY-m2,lW+lX*1.5/2+lY,kg.radius/m1)jE[#jE+1]='</g>'local mk=math.floor(kg.radius/m1+0.5)hk=lV+lX+lY*4+l_;hl=lW+lX*1.5/2+5+lY;if m3.apoapsis~=nil and m3.apoapsis.speed<_ then m4("Apoapsis")end;hl=lW+lX*1.5/2+5+lY;hk=lV+lX-lY*2-l_;if m3.periapsis~=nil and m3.periapsis.speed<_ and m3.periapsis.altitude>0 then m4("Periapsis")end;jE[#jE+1]=gJ(lV+lX+lY,lW+20+lY,kg.name,"txtorbbig")jE[#jE+1]=de('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mh,mi)jE[#jE+1]=[[</g>]]return jE else jE[#jE+1]='<g clip-path="url(#orbitRect)">'local ml=""local mm=1.2*(mn-mo)/(lX*2)local mp=1.4*(mq-mr)/(lX*1.5)for dF,dr in pairs(e[0])do if dr.center then local hk=lV+lX+dr.center.x/mm;local hl=lW+lX*1.5/2+dr.center.y/mp;ml=ml..'<circle cx="'..hk..'" cy="'..hl..'" r="'..dr.radius/mm*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dr.name,"Moon")and not string.match(dr.name,"Sanctuary")and not string.match(dr.name,"Space")then ml=ml.."<text x='"..hk.."' y='"..hl+dr.radius/mm*30+20 .."' font-size='12' fill="..iL.." text-anchor='middle' font-family='Montserrat'>"..dr.name.."</text>"end end end;local fr=vec3(b.getConstructWorldPos())local hk=lV+lX+fr.x/mm;local hl=lW+lX*1.5/2+fr.y/mp;ml=ml..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'ml=ml.."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iy=mm;iz=mp;local ms=fr+cF*1000000;local mt=lV+lX+ms.x/mm;local jo=lW+lX*1.5/2+ms.y/mp;ml=ml..'<line x1="'..hk..'" y1="'..hl..'" x2="'..mt..'" y2="'..jo..'" stroke="purple" stroke-width="1"/>'jE[#jE+1]=ml;jE[#jE+1]='</g>'end elseif bF=="INFO"then jE=cm.DrawOdometer(jE,iN,bl,iO)elseif bF=="HELP"then jE=lO(jE)elseif bF=="SCOPE"then jE[#jE+1]='<g clip-path="url(#orbitRect)">'local mu=d0;if ca>0 then table.sort(c_,function(ev,ew)local ex,ey=ev.center,ew.center;return(ex.x-cJ.x)^2+(ex.y-cJ.y)^2+(ex.z-cJ.z)^2<(ey.x-cJ.x)^2+(ey.y-cJ.y)^2+(ey.z-cJ.z)^2 end)end;local gR={}local mv={}local mw=120;local mx=nil;local my=nil;for K,dr in ipairs(c_)do local gQ=dr.center-cJ;local mz=gQ:len()local mA=gQ:normalize()local mB=gQ:cross(cC):normalize()local mC=math.acos(mB:dot(cD))if mC~=mC then mC=0 end;if mB:cross(cD):dot(cC)<0 then mC=-mC end;local mD=gQ:project_on_plane(cC):len()local mE=math.sin(mC)*math.asin(mD/mz)*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/mz)*constants.rad2deg;if mA:dot(cC)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hk=mc+mE/mu*m8;local hl=md+mF/mu*m8;local mG=(hk-mc)*(hk-mc)+(hl-md)*(hl-md)local mH=math.asin((dr.radius+dr.surfaceMaxAltitude)/mz)*constants.rad2deg;if mH~=mH then mH=mu end;local hG=mH/mu*m8;local mI=math.asin(dr.atmosphereRadius/mz)*constants.rad2deg;if mI~=mI then mI=mH end;local mJ=mI/mu*m8;local c4=ip(mz,1)local mK=dr.name;local mL=false;if hl>lW then if hl>mf then if hl-mJ<=mf then mL=true end else mL=true end else if hl+mJ>=lW then mL=true end end;local mM=false;local mN=hk;if dr.systemId==0 then mN=hk+mw else mN=hk-mw end;if mN+mw>lV then if mN+mw>me then if mN-mJ-mw<=me then mM=true end else mM=true end else if mN+mJ+mw>=lV then mM=true end end;local mO={}mO.x=hk;mO.y=hl;mO.planet=dr;mO.atmoSize=mJ;if not mx or mG<mx then mx=mG;my=mO end;if mM and mL then local mP=math.max(mJ,5)if mG<mP*mP then mK=mK.." - "..c4 end;mO.size=hG;mO.i=K;mO.displayString=mK;mO.distance=c4;mO.visible=true;mv[#mv+1]=mO else mO.visible=false end end;local mQ=false;table.sort(mv,function(ex,ey)return ex.y<ey.y end)for dF,fu in ipairs(mv)do local dr,hG,K,mJ,hk,hl,mK,c4=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local m6,mR,mS,mT;local mU=15;local jy="pdim"if dr.systemId~=0 then mS=iT(string.len(mK)*5)mU=-(15+mS)mT=iU(10)jy="pdimfill"else mS=iT(string.len(mK)*9)mT=iU(15)end;if hG*2>mS then m6=df(hk,lV+mS/2,me-mS/2)mR=df(hl,lW+mT,mf-5)m6=df(m6,hk-hG+mS/2,hk+hG-mS/2)mR=df(mR,hl-hG+mT,hl+hG)else m6=hk+mU;mR=hl end;for mV,fu in pairs(gR)do local mW=fu.textPositions;local mX=mW.y-mR;if mV~=K and eU(mX)<mW.height and mW.x+mW.width>m6 and mW.x<m6+mS then if hG>mS then mR=df(mR+mT,lW+15,mf-5)else mR=mW.y+mW.height+1 end end end;local mY=mK~=dr.name or m6<=mc and m6+mS>=mc and mR-mT<=md and mR>=md;fu.hovered=mY;local mZ=1;if mY then mZ=2;if hG*2<mS then mZ=10 end;if mK==dr.name then mK=mK.." - "..c4 end;jy="pbright"if dr.systemId~=0 then mS=iT(string.len(mK)*5)mU=-(15+mS)else mS=iT(string.len(mK)*7)end;if hG*2>mS then m6=df(hk,lV+mS/2,me-mS/2)m6=df(m6,hk-hG+mS/2,hk+hG-mS/2)else m6=hk+mU end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=mR;gR[K].textPositions.x=m6;gR[K].textPositions.width=mS;gR[K].textPositions.height=mT;gR[K].output=""if hG*2>mS then jy=jy.." txtmid"else jy=jy.." txtstart"end;if mJ-hG>2 then gR[K].output=de('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mJ,iM,0.1*mZ)end;gR[K].output=gR[K].output..de('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hG,iM,0.2*mZ)if dr.systemId==0 then gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mR,iL,jy,mK)if hG*2<=mS then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6+mS,mR+2,m6,mR+2,hk,hl)end else gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m6,mR,iM,jy,mK)if hG*2<=mS then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m6,mR+2,m6+mS,mR+2,hk,hl)end end end;for dF=#c_,1,-1 do if gR[dF]then jE[#jE+1]=gR[dF].output end end;if my~=nil and d0<90 and not my.hovered then local m_=my.planet.atmosphereRadius/my.atmoSize;local n0=dh(mx)*m_;local n1=ip(n0,1)local mS=iT(math.max(string.len(n1)*7,string.len(my.planet.name)*7))local mT=iU(12)local m6=df(my.x+(mc-my.x)/2,lV+mS/2,me-mS/2)local mR=df(my.y+(md-my.y)/2,lW+mT*2,mf-5)jE[#jE+1]=de("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",my.x,my.y,mc,md)jE[#jE+1]=de([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mR,"white",n1)if not my.visible then jE[#jE+1]=de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m6,mR-mT,"white",my.planet.name)end end;if cG>1 then local gQ=cF;local mA=gQ:normalize()local mD=gQ:project_on_plane(cC):len()local mB=gQ:cross(cC):normalize()local mC=math.acos(mB:dot(cD))if mC~=mC then mC=0 end;if mB:cross(cD):dot(cC)<0 then mC=-mC end;local mE=math.sin(mC)*math.asin(mD/gQ:len())*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/gQ:len())*constants.rad2deg;if mA:dot(cC)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hk=mc+mE/mu*m8;local hl=md+mF/mu*m8;local kA=14;local kB=kA/2;local kE=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kB/kA..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kA..[[,]]..hl..[[ h ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+kB..[[,]]..hl..[[ h ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kA..[[ v ]]..kB..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jE[#jE+1]=kE end;jE[#jE+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc,md-10,mc,md+10)jE[#jE+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mc-10,md,mc+10,md)jE[#jE+1]='</g>'else return jE end end;local function n2(n3,n4)local n5;local n6=(n4-n3):normalize()local fs=(cJ-n3):dot(n6)/n6:dot(n6)if fs<=0. then return(cJ-n3):len()elseif fs>=(n4-n3):len()then return(cJ-n4):len()end;local n7=n3+fs*n6;n5=(n7-cJ):len()return n5 end;local function n8()local n5;local n9=nil;local na=nil;local nb=nil;for dF,nc in pairs(e[0])do if nc.hasAtmosphere then local c4=n2(kg.center,nc.center)if n9==nil or c4<n9 then na=nc;n9=c4;nb=kg end;if c1 and c1.hasAtmosphere and c1.name~=kg.name then local eK=n2(c1.center,nc.center)if eK<n9 then na=nc;n9=eK;nb=c1 end end end end;local nd=iT(1770)local ne=iU(330)if n9 then local nf="txttick "local ng=500000;if n9<na.radius+ng or n9<nb.radius+ng then if cQ then nf="txttick red "else nf="txttick orange "end end;n5=ip(n9,2)iD=gJ(nd,ne,"Pipe ("..nb.name.."--"..na.name.."): "..n5,nf.."pbright txtmid")end end;local function nh(hk,hl,ni,nj,kN)local nk={x=hk,y=hl,width=ni,height=nj,label=kN}ix[kN]=nk;return nk end;local function nl(nm,nn,ni,nj,hk,hl,no,np,nq,nr,jy)local nk={enableName=nm,disableName=nn,width=ni,height=nj,x=hk,y=hl,toggleVar=no,toggleFunction=np,drawCondition=nq,hovered=false,class=jy}if nr then table.insert(iw,nk)else table.insert(iv,nk)end;return nk end;local function ns(nt)if not iB then nu=false;nv=false;nw=false;w=true;return elseif nt=="handling"then nu=not nu;nv=false;nw=false elseif nt=="hud"then nv=not nv;nu=false;nw=false elseif nt=="physics"then nw=not nw;nu=false;nv=false end;if nw or nv or nu then iC=io(nt)w=false else iC="none"w=true end end;local function nx()iB=not iB;if iB then iu=iw;bX="Hold SHIFT to see Settings"d1=w else iu=iv;bX="Hold SHIFT to see Control Buttons"ns()w=d1 end end;local function ny()local function nz(dr,dF)dr.set(not dr.get())if dr.get()then bX=dF.." set to true"else bX=dF.." set to false"end;if dF=="showHud"then d1=dr.get()elseif dF=="BrakeToggleDefault"then aX=j end end;local nA=50;local nB=340;local hk=500;local hl=cf/2-400;local nC=0;for dF,dr in pairs(io("boolean"))do if type(dr.get())=="boolean"then nl(dF,dF,nB,nA,hk,hl,function()return dr.get()end,function()nz(dr,dF)end,function()return true end,true)hl=hl+nA+20;if nC==9 then hk=hk+nB+20;hl=cf/2-400;nC=0 else nC=nC+1 end end end;nl("Control View","Control View",nB,nA,10,cf/2-500,function()return true end,nx,function()return true end,true)nl("View Handling Settings",'Hide Handling Settings',nB,nA,10,cf/2-(500-nA),function()return nu end,function()ns("handling")end,function()return true end,true)nl("View Hud Settings",'Hide Hud Settings',nB,nA,10,cf/2-(500-nA*2),function()return nv end,function()ns("hud")end,function()return true end,true)nl("View Physics Settings",'Hide Physics Settings',nB,nA,10,cf/2-(500-nA*3),function()return nw end,function()ns("physics")end,function()return true end,true)end;local function nD()local function gt()local fT=cJ;local gu=kg.name..". "..#bn;if radar_1 then gu=cp.GetClosestName(gu)end;return cn.AddNewLocation(gu,fT,false,true)end;local function nE()b2=not b2 end;local function nF(nG)if nG==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bV=false;b4=false;br=nil;b6=false;b5=false end;local function nH(nI,nJ)cn.UpdatePosition(nil,nI,nJ)end;local function go()cn.ClearCurrentPosition()end;local function nK(gs)local lN=co.routeWP(true)if lN and#lN>0 then return"Engage Route: "..lN[1]end;return"Engage Autopilot: "..lL(gs)end;local function nL(gs)local lN=co.routeWP(true)if lN and#lN>0 then return"Next Route Point: "..lN[1]end;return"Disable Autopilot: "..lL(gs)end;local function nM()if ij()==1 then bV=not bV;if bV then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nN=bk;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cu=p;bk=nN;if bk then d.control.extendLandingGears()ik:setTargetGroundAltitude(Y)end end else bX="Follow Mode only works with Remote controller"bV=false end end;local nA=50;local nB=260;local nO=iT(30)local nP=ay+ax*2+2;local nQ=az+1;nl("+","+",nO,nO,nP,nQ+nO+1,function()return false end,function()d0=d0/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nl("-","-",nO,nO,nP,nQ,function()return false end,function()d0=math.min(d0*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nl("0","0",nO,nO,nP,nQ+nO*2+2,function()return false end,function()d0=90 end,function()return bF=="SCOPE"and d0~=90 end,nil,"ZoomButton")local nR=nl("Enable Brake Toggle","Disable Brake Toggle",nB,nA,ce/2-nB/2,cf/2+350,function()return aX end,function()aX=not aX;if aX then bX="Brakes in Toggle Mode"else bX="Brakes in Default Mode"end end)nl("Align Prograde","Disable Prograde",nB,nA,ce/2-nB/2-50-nR.width,cf/2-nA+380,function()return b0 end,function()nF(1)end)nl("Align Retrograde","Disable Retrograde",nB,nA,ce/2-nB/2+nR.width+50,cf/2-nA+380,function()return a_ end,nF,function()return ca==0 end)nS=nl(nK,nL,600,60,ce/2-600/2,cf/2-60/2-330,function()return b1 or bo or c6 or bx end,function()end)local K;local function nT(nU)local gs=cX+nU;if gs>#cP then gs=gs-#cP-1 end;if gs<0 then gs=#cP+gs end;return gs end;nV={}for K=0,10 do local nW=nl(function(ey)local gs=nT(ey.apExtraIndex)if b1 or bo or c6 or bx then return"Redirect: "..lL(gs)end;return nK(gs)end,function(ey)local gs=nT(ey.apExtraIndex)return nL(gs)end,600,60,ce/2-600/2,cf/2-60/2-330+60*K,function(ey)local gs=nT(ey.apExtraIndex)return gs==bj and(b1 or bo or c6 or bx)end,function(ey)local gs=nT(ey.apExtraIndex)local nX=bj==gs;bj=gs;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not nX and not(b1 or bo or c6 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or K==0)end)nW.apExtraIndex=K;nV[K]=nW end;nl("Save Position","Save Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,gt,function()return bj==0 or g1==nil end)nl("Update Position","Update Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,function()nH(nil)end,function()return bj>0 and g1~=nil end)nl("Save Heading","Clear Heading",200,nS.height,nS.x+nS.width+30,nS.y+nS.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nH(false)else nH(true)end end,function()return bj>0 and g1~=nil end)nl("Save AGG Alt","Clear AGG Alt",200,nS.height,nS.x+nS.width+30,nS.y+nS.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nH(nil,false)else nH(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nl("Clear Position","Clear Position",200,nS.height,nS.x-200-30,nS.y,function()return true end,go,function()return bj>0 and g1~=nil end)nl("Save Route","Save Route",200,nS.height,nS.x-200-30,nS.y+nS.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nl("Load Route","Clear Route",200,nS.height,nS.x-200-30,nS.y+nS.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bX="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nA=60;nB=300;local hk=0;local hl=cf/2-150;nl("Enable Check Damage","Disable Check Damage",nB,nA,hk,hl-nA-20,function()return s end,function()s=not s end)nl("View Settings","View Settings",nB,nA,hk,hl,function()return true end,nx)hl=hl+nA+20;nl("Enable Turn and Burn","Disable Turn and Burn",nB,nA,hk,hl,function()return b2 end,nE)hk=10;hl=cf/2-300;nl("Horizontal Takeoff Mode","Vertical Takeoff Mode",nB,nA,hk+nB+20,hl,function()return aY end,function()aY=not aY;if aY then bX="Vertical Takeoff Mode"else bX="Horizontal Takeoff Mode"end end,function()return cK end)hl=hl+nA+20;nl("Engage Orbiting","Cancel Orbiting",nB,nA,hk+nB+20,hl,function()return bx end,co.ToggleIntoOrbit,function()return ca==0 and cT end)hl=cf/2-150;nl("Glide Re-Entry","Cancel Glide Re-Entry",nB,nA,hk+nB+20,hl,function()return b6 end,function()c5=1;nF(1)end,function()return kg.hasAtmosphere and not c9 end)hl=hl+nA+20;nl("Parachute Re-Entry","Cancel Parachute Re-Entry",nB,nA,hk+nB+20,hl,function()return b6 end,function()c5=2;nF(1)end,function()return kg.hasAtmosphere and not c9 end)hl=hl+nA+20;nl("Engage Follow Mode","Disable Follow Mode",nB,nA,hk,hl,function()return bV end,nM,function()return ij()==1 end)nl("Enable Repair Arrows","Disable Repair Arrows",nB,nA,hk+nB+20,hl,function()return iR end,function()iR=not iR;if iR then bX="Repair Arrows Enabled"else bX="Repair Arrows Diabled"end end,function()return ij()==1 end)hl=hl+nA+20;if not q then nl("Enable AGG","Disable AGG",nB,nA,hk,hl,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nl(function()return de("Switch IPH Mode - Current: %s",by)end,function()return de("IPH Mode: %s",by)end,nB*2,nA,hk,hl,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bX="IPH Mode: "..by end)hl=hl+nA+20;nl(function()return de("Toggle Control Scheme - Current: %s",g)end,function()return de("Control Scheme: %s",g)end,nB*2,nA,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bX="New Control Scheme: "..g end)local nY=iU(20)local nW=nh(0,0,iT(70),nY,"HELP")nW=nh(nW.x+nW.width,nW.y,iT(80),nY,"INFO")nW=nh(nW.x+nW.width,nW.y,iT(70),nY,"ORBIT")nW=nh(nW.x+nW.width,nW.y,iT(70),nY,"SCOPE")nh(nW.x+nW.width,nW.y,iT(70),nY,"HIDE")end;local nZ={}local n_=nil;function nZ.HUDPrologue(jE)if not cQ then iI=af;iJ=ag;iK=ah else iI=ac;iJ=ad;iK=ae end;iL=[[rgb(]]..bI(iI+0.6)..","..bI(iJ+0.6)..","..bI(iK+0.6)..[[)]]iM=[[rgb(]]..bI(iI*0.8+0.5)..","..bI(iJ*0.8+0.5)..","..bI(iK*0.8+0.5)..[[)]]local o0=iL;local o1=iM;local o2=[[rgb(]]..bI(iI*0.4+0.5)..","..bI(iJ*0.4+0.5)..","..bI(iK*0.4+0.5)..[[)]]local o3=iL;local o4=iM;local o5=o2;if iV()and not m then o0=[[rgb(]]..bI(iI*0.5+0.5)..","..bI(iJ*0.5+0.5)..","..bI(iK*0.5+0.5)..[[)]]o1=[[rgb(]]..bI(iI*0.3+0.5)..","..bI(iJ*0.3+0.5)..","..bI(iK*0.2+0.5)..[[)]]o2=[[rgb(]]..bI(iI*0.2+0.5)..","..bI(iJ*0.2+0.5)..","..bI(iK*0.2+0.5)..[[)]]end;local lA=iT;local lB=iU;jE[#jE+1]=de([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o0,o0,o0,o3,o3,o1,o1,o4,o4,o1,o0,o2,o4,o0,o0,o2,o2,o5,o2,ce,cf,o1,o1,o1,o1,o1,o3,o1,o4,o5,o4,o4,o5)if not n_ then n_=de([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lA(630),lB(0),lA(675),lB(45),lA(960),lB(55),lA(1245),lB(45),lA(1290),lB(0),lA(1000),lB(105),lA(1040),lB(59),lA(1250),lB(51),lA(1300),lB(0),lA(1920),lB(0),lA(1920),lB(20),lA(1400),lB(20),lA(1300),lB(105),lA(920),lB(105),lA(880),lB(59),lA(670),lB(51),lA(620),lB(0),lA(0),lB(0),lA(0),lB(20),lA(520),lB(20),lA(620),lB(105),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112))end;if w and I then jE[#jE+1]=n_ end;return jE end;function nZ.DrawVerticalSpeed(jE,dZ)jD(jE,dZ)end;function nZ.UpdateHud(jE)local kt=cN;local o6=cO;local jL=o6;local k0=kt;local kL=bI(c.getThrottle())local kQ=cG*3.6;local kM=c.getAxisCommandValue(0)local o7=iT(1770)local o8=iU(310)if t and cM then kM=bL;kL=bL*100 end;local iX=iW()local jM="ROLL"if kL==nil then kL=0 end;if not cT then if cG>5 then kt=ks(cE)o6=ku(cE)else kt=0;o6=0 end;jM="YAW"end;if cR>50000 and not c9 then local o9;o9=ip(cR)jE[#jE+1]=gJ(o7,o8,"PvP Boundary: "..o9,"pbright txtbig txtmid")end;jE[#jE+1]=iP;jE[#jE+1]=hV;if iD~=""then jE[#jE+1]=iD end;if iY~=""then jE[#jE+1]=iY end;if iZ~=""then jE[#jE+1]=iZ end;jD(jE,cb)if ij()==0 or l then if not iV()or m then if cT then jK(jE,ai,aj,jL,jM,cT)j_(jE,k0,jL,ai,aj,cT,bI(ku(cE)),cG)else jK(jE,ai,aj,o6,jM,cT)j_(jE,kt,o6,ai,aj,cT,bI(o6),cG)end;k6(jE,cb,cT)kv(jE,cE,cG,ai,aj)end end;kK(jE,iX,kL,kM)kP(jE,kQ)kT(jE)lU(jE)if not iB and bW then lM(jE)end;return jE end;function nZ.HUDEpilogue(jE)jE[#jE+1]="</svg>"return jE end;function nZ.ExtraData(jE)local oa=iT(1240)local ob=iU(55)local oc=ob+10;local od;local lA=iT;local lB=iU;local oe=0;local iX=iW()if aY then iX=iX.."-VERTICAL"end;if E and not b5 and not b4 and cG>20 then iX=iX.."-COLLISION ON"end;if bA~="Off"then iX="("..bA..")-"..iX end;if b2 then iX="TB-"..iX end;if not bz then iX=iX.."-DeCoupled"end;local of=lB(99)local og=lB(80)local oh=lB(85)local oi=lB(31)local oj=0;local ok=0;local ol=cc>1000000 and fR(cc/1000000,2).."kT"or fR(cc/1000,2).."T"if c9 then oe=bs else oe=bq end;local om,on=ck.computeDistanceAndTime(cG,0,cc,0,0,oe)if om<0 then om=0 end;oe=fR(oe/(cc*it),2).."g"local oo=d:maxForceForward()od=b.g()if od>0.1 then ok=cc*od;ok=fR(ok/(cc*it),2).."g"oj=0.5*oo/od;oj=oj>1000000 and fR(oj/1000000,2).."kT"or fR(oj/1000,2).."T"end;oo=fR(oo/(cc*it),2).."g"local op=vec3(b.getWorldAcceleration()):len()/9.80665;od=b.g()jE[#jE+1]=[[<g class="dim txt txtend size14">]]if ij()==1 and not l then oa=iT(1120)ob=iU(55)oc=ob+10 elseif c9 and I then local oq=iT(770)jE[#jE+1]=gJ(lA(895),of,"ATMO","")jE[#jE+1]=de([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lA(895),oh,lA(-80))jE[#jE+1]=gJ(lA(815),og,de("%.1f%%",ca*100),"txtstart size20")end;if I then jE[#jE+1]=gJ(lA(1025),of,"GRAVITY","txtstart")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1025),oh,lA(80))jE[#jE+1]=gJ(lA(1105),og,de("%.2fg",od/9.80665),"size20")jE[#jE+1]=gJ(lA(1125),of,"ACCEL","txtstart")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1125),oh,lA(80))jE[#jE+1]=gJ(lA(1205),og,de("%.2fg",op),"size20")jE[#jE+1]=gJ(lA(695),of,"BRK TIME","")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(695),oh,lA(-80))jE[#jE+1]=gJ(lA(615),og,de("%s",iq(on)),"txtstart size20")jE[#jE+1]=gJ(lA(635),lB(45),"TRIP","")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(635),lB(31),lA(-90))if lu then jE[#jE+1]=gJ(lA(545),lB(26),de("%s",iq(lu)),"txtstart size20")end;jE[#jE+1]=gJ(lA(795),of,"BRK DIST","")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(795),oh,lA(-80))jE[#jE+1]=gJ(lA(715),og,de("%s",ip(om)),"txtstart size20")jE[#jE+1]=gJ(lA(1285),lB(45),"MASS","txtstart")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1285),lB(31),lA(90))jE[#jE+1]=gJ(lA(1375),lB(26),de("%s",ol),"size20")jE[#jE+1]=gJ(lA(1220),of,"THRUST","txtstart")jE[#jE+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1220),oh,lA(80))jE[#jE+1]=gJ(lA(1300),og,de("%s",oo),"size20")jE[#jE+1]=gJ(iT(960),iU(175),iX,"pbright txtbig txtmid size20")end;jE[#jE+1]="</g>"end;local os=1-(a5*0.05+a6*0.05)function nZ.FuelUsed(ot)local ou;if ot=="atmofueltank"then ou=de("Atmo Fuel Used: %.1f L",jf[ot]/(4*os))elseif ot=="spacefueltank"then ou=de("Space Fuel Used: %.1f L",jf[ot]/(6*os))else ou=de("Rocket Fuel Used: %.1f L",jf[ot]/(0.8*os))end;return ou end;function nZ.DrawOdometer(jE,iN,bl,iO)if bF~="INFO"then return jE end;local od;local oj=0;local ok=0;local oe=0;local ol=cc>1000000 and fR(cc/1000000,2).." kTons"or fR(cc/1000,2).." Tons"if c9 then oe=bs else oe=bq end;local om,on=ck.computeDistanceAndTime(cG,0,cc,0,0,oe)oe=fR(oe/(cc*it),2).." g"local oo=d:maxForceForward()od=b.g()if od>0.1 then ok=cc*od;ok=fR(ok/(cc*it),2).." g"oj=0.5*oo/od;oj=oj>1000000 and fR(oj/1000000,2).." kTons"or fR(oj/1000,2).." Tons"end;oo=fR(oo/(cc*it),2).." g"if ij()==0 or l then local ov=iT(ay+10)local ow=iU(az+20)local ox=iT(ay+10+ax/1.25)local nj=25;jE[#jE+1]="<g class='txtstart size14 bright'>"jE[#jE+1]=gJ(ov,ow,de("BrkTime: %s",iq(on)))jE[#jE+1]=gJ(ox,ow,de("Trip: %.2f km",iN))jE[#jE+1]=gJ(ov,ow+nj,de("Lifetime: %.2f kSU",bl/200000))jE[#jE+1]=gJ(ox,ow+nj,de("BrkDist: %s",ip(om)))jE[#jE+1]=gJ(ov,ow+nj*2,"Trip Time: "..iq(iO))jE[#jE+1]=gJ(ox,ow+nj*2,"Total Time: "..iq(bm))jE[#jE+1]=gJ(ov,ow+nj*3,de("Mass: %s",ol))jE[#jE+1]=gJ(ox,ow+nj*3,de("Max Brake: %s",oe))jE[#jE+1]=gJ(ov,ow+nj*4,de("Max Thrust: %s",oo))if od>0.1 then jE[#jE+1]=gJ(ox,ow+nj*4,de("Max Thrust Mass: %s",oj))jE[#jE+1]=gJ(ov,ow+nj*5,de("Req Thrust: %s",ok))else jE[#jE+1]=gJ(ox,ow+nj*4,"Max Mass: n/a")jE[#jE+1]=gJ(ov,ow+nj*5,"Req Thrust: n/a")end;jE[#jE+1]=gJ(ox,ow+nj*5,cm.FuelUsed("atmofueltank"))jE[#jE+1]=gJ(ov,ow+nj*6,cm.FuelUsed("spacefueltank"))jE[#jE+1]=gJ(ox,ow+nj*6,cm.FuelUsed("rocketfueltank"))jE[#jE+1]=gJ(ov,ow+nj*7,de("Set Max Speed: %s",bI(_*3.6+0.5)))jE[#jE+1]=gJ(ox,ow+nj*7,de("Actual Max Speed: %s",bI(da*3.6+0.5)))end;jE[#jE+1]="</g></g>"return jE end;function nZ.DrawWarnings(jE)return kT(jE)end;function nZ.DisplayOrbitScreen(jE)return lU(jE)end;function nZ.DisplayMessage(jE,lf)if lf~="empty"then local hl=310;for lo in string.gmatch(lf,"([^\n]+)")do hl=hl+35;jE[#jE+1]=gJ("50%",hl,lo,"msg")end end;if bY~=0 then c.setTimer("msgTick",bY)bY=0 end end;function nZ.DrawDeadZone(jE)jE[#jE+1]=de([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function nZ.UpdatePipe()if c9 then iD=""return end;n8()end;function nZ.DrawSettings(jE)local hk=iT(640)local hl=iU(200)jE[#jE+1]=[[<g class="pbright txtvspd txtstart">]]local hD=0;for dF,dr in pairs(iC)do hD=hD+1;jE[#jE+1]=gJ(hk,hl,dF..": "..dr.get())hl=hl+20;if hD%12==0 then hk=hk+iT(350)hl=iU(200)end end;jE[#jE+1]=gJ(iT(640),iU(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jE[#jE+1]="</g>"return jE end;local hT=iU(15)local hS=iT(1370)local hW,oy;function nZ.DrawRadarInfo()hV=cp.GetRadarHud(hS,hT,au,av)end;function nZ.DrawTanks()if aq~=0 and ar~=0 then iY=gJ(aq,ar,"","txtstart pdim txtfuel")jg=ar;jh(aq,"Atmospheric ","ATMO",cg,jd,je)jh(aq,"Space Fuel T","SPACE",ch,jb,jc)jh(aq,"Rocket Fuel ","ROCKET",ci,j9,ja)end end;function nZ.DrawShield()local i2=db.getState()==1 and"Shield Active"or"Shield Disabled"local oz=b.getPvPTimer()local oA=db.getResistances()local oB="A: "..10+oA[1]*100 .."% / E: "..10+oA[2]*100 .."% / K:"..10+oA[3]*100 .."% / T: "..10+oA[4]*100 .."%"local hk,hl=as-60,at+30;local jw=bI(dc*2.55)local jx=de("rgb(%d,%d,%d)",255-jw,jw,0)local jy=""iZ=gJ(hk,hl,"","txtmid pdim txtfuel")if dc<10 and i2~="Shield Disabled"then jy="red "end;oz=oz>0 and"   PvPTime: "..iq(oz)or""iZ=iZ..de([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jx,dc*2,hk,hl,hk+2,hl+10,dc,oz)iZ=iZ..gJ(hk,hl-5,i2,jy.."txtstart pbright txtbig")iZ=iZ..gJ(hk,hl+30,oB,jy.."txtstart pbright txtsmall")end;function nZ.hudtick()if not kg then return end;local function oC(jE)local jA=bI(df(d8/(ce/4)*255,0,255))jE[#jE+1]=de("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c2,c3,bI(iI+0.5)+jA,bI(iJ+0.5)-jA,bI(iK+0.5)-jA)end;local function oD()for dK,dr in pairs(iu)do if dr.hovered then if not dr.drawCondition or dr.drawCondition(dr)then dr.toggleFunction(dr)end;dr.hovered=false end end;for dK,dr in pairs(ix)do if dr.hovered then bF=dr.label;dr.hovered=false end end end;local function oE()local function oF(oG,oH,hk,hl,ni,nj)if oG>=hk and oG<=hk+ni and oH>=hl and oH<=hl+nj then return true else return false end end;local hk=c2+ce/2;local hl=c3+cf/2;for dK,dr in pairs(iu)do dr.hovered=oF(hk,hl,dr.x,dr.y,dr.width,dr.height)end;for dK,dr in pairs(ix)do dr.hovered=oF(hk,hl,dr.x,dr.y,dr.width,dr.height)end;if cW then local mY=false;for dK,ey in ipairs(nV)do if ey.hovered then mY=true;break end end;if nS.hovered then mY=true end;cW=mY else cW=nS.hovered;if not cW then cX=bj end end end;local function oI(jE)if not bF or bF==""then bF="HELP"end;if w then for dF,dr in pairs(ix)do local jy="dim brightstroke"local oJ=0.2;if bF==dF then jy="pbright dimstroke"oJ=0.6 end;local oK=""if dr.hovered then oJ=0.8;oK=";stroke:white"end;jE[#jE+1]=de([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dr.width,dr.height,dr.x,dr.y,jy,oJ,oK)jE[#jE+1]=gJ(dr.x+dr.width/2,dr.y+dr.height/2+5,dr.label,"txt txtmid pdim")end end end;local function oL(jE)local function oM(jE,oN,hover,hk,hl,fe,oO,oP,oQ,oR,oS,nW)if type(oR)=="function"then oR=oR(nW)end;if type(oS)=="function"then oS=oS(nW)end;jE[#jE+1]=de("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fe,oO)if oN then jE[#jE+1]=de("%s'",oP)else jE[#jE+1]=oQ end;if hover then jE[#jE+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jE[#jE+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jE[#jE+1]=" rx='5'></rect>"jE[#jE+1]=de("<text x='%f' y='%f' font-size='24' fill='",hk+fe/2,hl+oO/2+5)if oN then jE[#jE+1]="black"else jE[#jE+1]="white"end;jE[#jE+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oN then jE[#jE+1]=de("%s</text>",oR)else jE[#jE+1]=de("%s</text>",oS)end end;local oT=de("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local oU=de("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local oV=oM;for dK,dr in pairs(iu)do local nn=dr.disableName;local nm=dr.enableName;if type(nn)=="function"then nn=nn(dr)end;if type(nm)=="function"then nm=nm(dr)end;if not dr.drawCondition or dr.drawCondition(dr)then oV(jE,dr.toggleVar(dr),dr.hovered,dr.x,dr.y,dr.width,dr.height,oU,oT,nn,nm,dr)end end end;local oW=fR(ce/2,0)local oX=fR(cf/2,0)local jE={}if oY then jE[#jE+1]=oY end;cm.HUDPrologue(jE)if w then cm.UpdateHud(jE)else if A then cm.DrawVerticalSpeed(jE,cb)end;cm.DrawWarnings(jE)end;if iB and iC~="none"then cm.DrawSettings(jE)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jE)jE[#jE+1]=de([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ce,cf)if bX~="empty"then cm.DisplayMessage(jE,bX)end;if ij()==0 and g=="virtual joystick"then if v then cm.DrawDeadZone(jE)end end;oI(jE)if il()==0 then if ij()==1 and bW then if not oZ then oE()oL(jE)end;if not cs and not ct then local o_=table.concat(jE,"")jE={}jE[#jE+1]=de("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jE[#jE+1]=o_;jE[#jE+1]="</body>"cs=true;jE[#jE+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif ct then local o_=table.concat(jE,"")jE={}jE[#jE+1]=de("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jE[#jE+1]=o_;jE[#jE+1]="</body>"end;if not cs then jE[#jE+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oW,oX,c2,c3)end else oD()end else if not bW and ij()==0 then oD()if d8>aw then if v then oC(jE)end end elseif bW and(not oZ or not i)then oE()oL(jE)end;jE[#jE+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oW,oX,c2,c3)end;jE[#jE+1]=[[</svg></body>]]p0=table.concat(jE,"")end;function nZ.TenthTick()local function p1()local p2=a.createData;local p3=a.createWidget;p4=a.createWidgetPanel("Interplanetary Helper")p5=p3(p4,"value")p6=p2('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(p6,p5)p7=p3(p4,"value")p8=p2('{"label": "distance", "value": "N/A", "unit":""}')fP(p8,p7)gi=p3(p4,"value")gh=p2('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=p3(p4,"value")gf=p2('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=p3(p4,"value")gj=p2('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=p3(p4,"value")gb=p2('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=p3(p4,"value")g9=p2('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=p3(p4,"value")g7=p2('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=p3(p4,"value")g5=p2('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=p3(p4,"value")gd=p2('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c9 then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function p9()gI(p4)p4=nil end;cm.DrawTanks()if db then cm.DrawShield()end;if bh~="None"then if p4==nil then p1()end;if bh~=nil then local mz;local pa=g1~=nil;local pb=0.5*bs/c1:getGravity(c1.center+vec3(0,0,1)*c1.radius):len()pb=pb>1000000 and fR(pb/1000000,2).." kTons"or fR(pb/1000,2).." Tons"fO(p6,'{"label": "Target", "value": "'..bh..'", "unit":""}')if pa and not b1 then mz=(cJ-g1.position):len()else mz=(bi-cJ):len()end;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local lf=ip(mz)fO(p8,'{"label": "distance", "value": "'..lf..'"}')fO(gh,'{"label": "Travel Time", "value": "'..iq(lu)..'", "unit":""}')lf=ip(b_)fO(gb,'{"label": "Cur Brake distance", "value": "'..lf..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..iq(c0)..'", "unit":""}')lf=ip(iF)fO(g7,'{"label": "Max Brake distance", "value": "'..lf..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..iq(iG)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..de("%s",pb)..'", "unit":""}')lf=ip(gl)fO(gj,'{"label": "Target Orbit", "value": "'..lf..'"}')if c9 and not pc then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pc=true;if not cM and t and(b3 or b6 or c7)then co.cmdThrottle(1)aZ=false;bP=false end end;if not c9 and pc then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pc=false end end else p9()end;if warpdrive~=nil then local pd=ih(warpdrive.getData())if pd.destination~="Unknown"and pd.distance>400000 then if not iS then warpdrive.show()iS=true end elseif iS then warpdrive.hide()iS=false end end end;function nZ.OneSecondTick()local function pe()local jr=bH()local kQ=cG;local pf=jr-iQ;if kQ>1.38889 then kQ=kQ/1000;local pg=kQ*(jr-iQ)bl=bl+pg;iN=iN+pg end;iO=iO+pf;bm=bm+pf;iQ=jr end;local function ph(jE)local pi=0;local pj=is;local pk=0;local pl=0;local pm=0;local jw=0;local jx=""local pn=b.getElementHitPointsById;local po=b.getElementMaxHitPointsById;local pp={}for dF in pairs(ir)do local pq=0;local pr=0;pr=po(ir[dF])pq=pn(ir[dF])pk=pk+pq;if pq+1<pr then if pq==0 then pm=pm+1 else pl=pl+1 end;if iR and#pp==0 then fT=vec3(b.getElementPositionById(ir[dF]))local hk=fT.x;local hl=fT.y;local hm=fT.z;table.insert(pp,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(pp,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(pp[2],0,0,90)table.insert(pp,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(pp,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(pp[4],90,90,0)table.insert(pp,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(pp,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(pp[6],90,-90,0)table.insert(pp,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(pp,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(pp[8],90,0,90)table.insert(pp,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(pp,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(pp[10],-90,0,90)table.insert(pp,ir[dF])end elseif iR and#pp>0 and pp[11]==ir[dF]then for jq in pairs(pp)do b.deleteSticker(pp[jq])end;pp={}end end;pi=fR(pk/pj*100,2)if pm>0 or pl>0 then jE[#jE+1]=gJ(0,0,"","pbright txt")jw=bI(pi*2.55)jx=de("rgb(%d,%d,%d)",255-jw,jw,0)jE[#jE+1]=gJ("50%",1035,"Elemental Integrity: "..pi.."%","txtbig txtmid","fill:"..jx)if pm>0 then jE[#jE+1]=gJ("50%",1055,"Disabled Modules: "..pm.." Damaged Modules: "..pl,"txtbig txtmid","fill:"..jx)elseif pl>0 then jE[#jE+1]=gJ("50%",1055,"Damaged Modules: "..pl,"txtbig txtmid","fill:"..jx)end end end;local function ps()if ig then if iH==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ig,weapon_size,"Weapons","weapon",true)iH=_autoconf.panels[_autoconf.panels_size]elseif iH~=nil and d3==nil and not bk then gI(iH)iH=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jE={}pe()if s then ph(jE)end;ps()cm.UpdatePipe()cm.ExtraData(jE)iP=table.concat(jE,"")end;function nZ.AnimateTick()ct=true;cs=false;c2=0;c3=0;c.stopTimer("animateTick")end;function nZ.MsgTick()local jE={}cm.DisplayMessage(jE,"empty")bX="empty"c.stopTimer("msgTick")bY=3 end;function nZ.ButtonSetup()ny()nD()iu=iv end;if pt then for dF,dr in pairs(pt)do nZ[dF]=dr end end;return nZ end;local function pu(d,b,c,a,e,vBooster,hover,pv,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,pw,ih,de,fP)local px={}local py=false;local pz=0;local pA=0;local pB=0;local pC=bH()local pD=0;local pE=0;local pF=0;local pG=0;local pH=false;local pI=false;local pJ=false;local pK=nil;local pL=0;local iE=55;local pM=nil;local pN=false;local pO=false;local pP=false;local pQ=0;local pR=0;local pS=0;local pT=0;local pU=0;local pV={VectorToTarget=false}local pW=vec3(b.getConstructWorldOrientationUp())local pX=nil;local pY=0;local pZ=-1;local p_=-1;local q0=false;local q1=false;local q2=0;local q3=false;local q4=false;local q5=false;local q6=false;local q7=""local q8=false;local q9=false;local qa=""local qb=false;local qc=0;local qd=vec3({13771471,7435803,-128971})local qe=18000000;local qf=500000;local qg,qh=math.huge;local qi;local function qj(qk)qg=vec3(qk):dist(qd)if qg<qe then return true,eU(qg-qe)end;qh=vec3(qk):dist(vec3(kg.center))if qh<qf then qi=true else qi=false end;if eU(qh-qf)<eU(qg-qe)then return qi,eU(qh-qf)else return qi,eU(qg-qe)end end;local function ql(fl)local qm=bd;if not b1 then qm=0 end;local qn=bq;if c9 then if bs and bs>0 then qn=bs else return 0,0 end end;return ck.computeDistanceAndTime(fl,qm,cc,0,0,qn-bf*cc)end;local function qo(fl)local qm=bd;if not b1 then qm=0 end;return ck.computeDistanceAndTime(fl,qm,cc,d:maxForceForward(),a1,bq-bf*cc)end;local function qp(qq,qr,qs)qr=qr:project_on_plane(qq)qs=qs:project_on_plane(qq)return eP(qr:cross(qs):dot(qq),qr:dot(qs))end;local function qt()local function qu()local qv=-1;local qw=-1;if vBooster then qv=vBooster.getDistance()end;if hover then qw=hover.getDistance()end;if qv~=-1 and qw~=-1 then if qv<qw then return qv else return qw end elseif qv~=-1 then return qv elseif qw~=-1 then return qw else return-1 end end;local qx=qu()local qy=-1;if antigrav and antigrav.getState()==1 and not q and cG<iE then local qz=eU(cb-antigrav.getBaseAltitude())if qz<50 then return qz end end;if pv then qy=pv.getDistance()end;if qx~=-1 and qy~=-1 then if qx<qy then return qx else return qy end elseif qx~=-1 then return qx else return qy end end;local function qA(kg,eG,qB)local function qC(qD,dR)local eM=vec3(dR)if qD.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=qD.systemId},dT)end;local eN=eM-qD.center;local c4=eN:len()local dZ=c4-qD.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=math.deg(dX),longitude=math.deg(dY),altitude=dZ,id=qD.id,systemId=qD.systemId},dT)end;local qE=qC(kg,eG)qE="::pos{"..qE.systemId..","..qE.id..","..qE.latitude..","..qE.longitude..","..qE.altitude.."}"if qB then return qE else q5=qE;return true end end;local function qF(qG,qH,qI)local function qJ(qG,ep)qG=vec3(qG)ep=vec3(ep):normalize()local dA=qG*ep;return dA.x+dA.y+dA.z end;local qK=0.001;local qL=1;if not c9 or not cv or c8~=-1 or cG<iE then if qI==nil then qI=aQ end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=vec3()-qG;local qN=-qJ(qM,b.getConstructWorldOrientationRight())*qL;local qO=-qJ(qM,b.getConstructWorldOrientationUp())*qL;if pA==0 then pA=qN/2 end;if pB==0 then pB=qO/2 end;if eU(qN)<0.1 then pR=pR-qN*2 else pR=pR-(qN+(qN-pA)*qI)end;if eU(qO)<0.1 then pQ=pQ+qO*2 else pQ=pQ+qO+(qO-pB)*qI end;pA=qN;pB=qO;if eU(qN)<qH and eU(qO)<qH then return true end;return false elseif cv and c8==-1 then qG=cF;if qI==nil then qI=aQ end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=cC-qG;local qN=-qJ(qM,b.getConstructWorldOrientationRight())*qL;local qO=-qJ(qM,b.getConstructWorldOrientationUp())*qL;if pA==0 then pA=qN/2 end;if pB==0 then pB=qO/2 end;if eU(qN)<0.1 then pR=pR-qN*5 else pR=pR-(qN+(qN-pA)*qI)end;if eU(qO)<0.1 then pQ=pQ+qO*5 else pQ=pQ+qO+(qO-pB)*qI end;pA=qN;pB=qO;if eU(qN)<qH and eU(qO)<qH then return true end;return false end end;function px.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bV=false;pO=false;c5=false;c6=false;pP=false;cu=p;bo=false;b2=false;cd=false;br=nil;bx=false;d6=false;d7=nil end;function px.GetAutopilotBrakeDistanceAndTime(fl)return ql(fl)end;function px.GetAutopilotTBBrakeDistanceAndTime(fl)return qo(fl)end;function px.showWayPoint(kg,eG,qB)return qA(kg,eG,qB)end;function px.APTick()local qP=a.getMouseWheel()if qP>0 then co.changeSpd()elseif qP<0 then co.changeSpd(true)else pN=true end;q2=il()if q5 then a.setWaypoint(q5)q5=false end;if q8 then antigrav.setBaseAltitude(q8)q8=false end;if q6 then fO(q6,q7)q6=false;q7=""end;if p_~=-1 then co.cmdCruise(p_,q0)q0=false;p_=-1 end;if pX~=nil then if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ik:getTargetSpeed(axisCommandId.longitudinal)~=pX then ik:setTargetSpeedCommand(axisCommandId.longitudinal,pX)else pX=nil end end;if pZ~=-1 then co.cmdThrottle(pZ,q0)q0=false;pZ=-1 end;if q1 then cq.landingGear()q1=false end;if q9 then co.ToggleAutopilot()end end;function px.ToggleIntoOrbit()cz=false;pF=nil;pG=nil;pL=0;if not c9 then if bx then fQ("orOff","AP")bx=false;pH=false;pK=nil;cu=p;if b3 then b3=false;b5=false end;pV.VectorToTarget=false;pV.AutopilotAlign=false;pJ=false elseif cT then fQ("orOn","AP")bx=true;cu=true;if pK==nil then pK=kg end;if b3 then b3=false;b5=false end else bX="Unable to engage auto-orbit, not near a planet"end else bx=false;pH=false;pK=nil;cu=p;if b3 then b3=false end;pV.VectorToTarget=false;pV.AutopilotAlign=false;pJ=false end end;function px.ToggleVerticalTakeoff()b3=false;if b7 then ln=true;b6=false;b5=false;b4=true;cu=true;bU=0;if c9 and c8==-1 then b4=false;b3=true;bU=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)p_=bI(cw)end else cz=false;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function px.checkLOS(qG)local ls,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,qG,function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lt=eE;if eF~=nil and eE~=nil then lt=math.min(eF,eE)end;if lt~=nil then return ls,lt else return nil,nil end end;function px.ToggleAutopilot()local function qQ(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lw="Proceeding to Waypoint"end;local function qR(gu)if gu then for K,dF in pairs(cP)do if dF.name and dF.name==gu then return K end end else return 0 end end;local qS=false;if bK-pE<1.5 and c9 then if not cB then if c9 then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude;fQ("11","EP")pE=-1;if b1 or bo or bx then return end else bX="No space engines detected, Orbital Hop not supported"return end elseif kg.hasAtmosphere then if c9 then b8=kg.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pE=-1;if b1 or bo or bx then return end end else pE=bK end;qT=false;if(bj>0 or#bD>0)and not b1 and not bo and not c6 and not bx then if 0.5*d:maxForceForward()/b.g()<cc then bX="WARNING: Heavy Loads may affect autopilot performance."bY=5 end;if#bD>0 and not c7 then bj=qR(bD[1])cn.UpdateAutopilotTarget()bX="Route Autopilot in Progress"local qM=g1.position-cJ;local qU=qM:project_on_plane(cH):len()if qU>50000 and g1.planetname==kg.name then qS=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c1,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cL then co.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end elseif kg.name==g1.planetname then ln=true;if c9 then if not bo then fQ("vtt","AP")qQ(bv)if qS then b8=kg.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c1.name==kg.name and cb<gl*1.5)then cz=false;b1=true elseif not c9 then if bx then co.ToggleIntoOrbit()end;cy=kg.noAtmosphericDensityAltitude+T;pJ=true;pV.AutopilotAlign=true;pV.VectorToTarget=true;pH=false;if not bx then co.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end end elseif not c9 then if g1==nil and(c1.name==kg.name and cT)and not bx then qV=false;cz=false;pH=false;co.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bV=false;b3=false;b4=false;b6=false;b5=false;pO=false;br=nil;qV=false end else fQ("apP","AP")c6=true;co.ToggleAltitudeHold()end;q9=false else fQ("apOff","AP")co.ResetAutopilots(1)if q9==2 then q9=true end end end;function px.routeWP(qW,qX,qY)if qY then if qY==1 then bD={}bD=im(bD,bC)if#bD>0 then bX="Route Loaded"else bX="No Saved Route found on Databank"end;return bD else bC={}bC=im(bC,bD)bX="Route Saved"pw()return end end;if qW then return bD end;if qX then bD={}bX="Current Route Cleared"else bD[#bD+1]=g1.name;bX="Added "..g1.name.." to route. "end;return bD end;function px.cmdThrottle(dG,qZ)if ik:getAxisCommandType(0)~=axisCommandType.byThrottle and not qZ then d.control.cancelCurrentControlMasterMode()end;ik:setThrottleCommand(axisCommandId.longitudinal,dG)bL=df(fR(dG*100,0)/100,-1,1)pX=nil end;function px.cmdCruise(dG,qZ)if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not qZ then d.control.cancelCurrentControlMasterMode()end;ik:setTargetSpeedCommand(axisCommandId.longitudinal,dG)pX=dG end;function px.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bW then br=cN else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function px.ToggleAltitudeHold()if bK-pD<1.5 then if kg.hasAtmosphere then if c9 then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude;fQ("11","EP")else if cT then b8=kg.noAtmosphericDensityAltitude+T;cy=b8;pJ=true;if not bx then co.ToggleIntoOrbit()end;pH=true end end;pD=-1;if b3 or bx or b7 then return end end else pD=bK end;if cT and not c9 then cy=cb;pJ=true;pH=true;co.ToggleIntoOrbit()if bx then pD=bK else pD=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bV=false;cu=true;br=nil;cz=false;if c8~=-1 and cG<20 then if bk then cq.landingGear()end;fQ("lfs","LS")b5=true;if pD>-1 then b8=cb+W end;aZ="ATO Hold"ik:setTargetGroundAltitude(X)if aY and cK then co.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pD>-1 then if cT then b8=cb end end;if b7 then co.ToggleVerticalTakeoff()end end;if cL and not q then local q_=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cb then b8=g1.agg elseif b5 then b8=q_ end;if eU(cb-q_)<100 and cG<20 then b8=q_;aZ="AGG Hold"pZ=0 end end;if c6 then b8=200000 end else fQ("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pD=0 end end;function px.ResetAutopilots(px)if px then c6=false;b1=false;ba=false;pO=false;b8=cb;qT=false;d6=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;r0=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c5=false;c7=false;bU=0 end;function px.BrakeToggle(r1)if not aZ then if r1 then aZ=r1 else aZ=true end else aZ=false end;if b4 then b4=false;cu=p;d6=false end;if aZ then fQ("bkOn","B",1)co.ResetAutopilots()else fQ("bkOff","B",1)end end;function px.BeginReentry()if b6 then bX="Re-Entry cancelled"fQ("reOff","RE")b6=false;cu=p;b3=false elseif not kg.hasAtmosphere then bX="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bY=5 elseif not pP then b6=true;if ik:getAxisCommandType(0)~=r2.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bX="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fQ("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=kg.surfaceMaxAltitude+Z;if b8>kg.spaceEngineMinAltitude then b8=kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude end;local r3=ip(b8)bX="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..r3;fQ("glide","RE")p_=bI(cw)end;b5=false end;function px.ToggleAntigrav()if antigrav and not q then if cL then fQ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=cb end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function px.changeSpd(r4)local r5=1;if r4 then r5=-1 end;if not bW then if t and not oZ and pN then local r6=bL;bL=fR(df(bL+r5*aC/100,-1,1),2)if bL>=0 and r6<0 then bL=0;pN=false end elseif oZ then if c9 or b6 then cw=df(cw+r5*aC,0,U)elseif b1 then _=df(_+r5*aC/3.6*100,0,da-0.2)end else ik:updateCommandFromActionStart(axisCommandId.longitudinal,r5*aC/10)end else if b1 or bo or c6 or bx then cX=cX+1*r5*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not r4 then r5=1 else r5=nil end;cn.adjustAutopilotTargetIndex(r5)end end end;function px.TenthTick()local function r7()if not b1 then if g1==nil or g1.planetname~=kg.name then r8=(c1.center-cJ):len()else r8=(g1.position-cJ):len()end end;local fl=cG;local r9=c.getThrottle()/100;if t then r9=bL end;local ra,rb=ck.computeDistanceAndTime(cG,_,cc,d:maxForceForward()*r9,a1,0)local b_,c0;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local dK,rc;if not b2 and fl>0 then dK,rc=co.GetAutopilotBrakeDistanceAndTime(fl)else dK,rc=co.GetAutopilotTBBrakeDistanceAndTime(fl)end;local rd=0;local re=0;if bc or not b1 and fl>5 then re=ck.computeTravelTime(fl,0,r8)elseif b_+ra<r8 then rd=r8-(b_+ra)re=ck.computeTravelTime(8333.0556,0,rd)else local rf=(r8-b_)/ra;ra=r8-b_;rb=rb*rf end;if g1~=nil and g1.planetname==kg.name and not b1 then return re elseif bb then return rc elseif bc then return re+rc else return rb+c0+re end end;local function rg(od,rh)if od==nil then od=b.g()end;od=fR(od,5)if rh~=nil and rh or(pM==nil or pM~=od)then local fl=cE:len()local ri=ih(c.getData()).maxBrake;if ri~=nil and ri>0 and c9 then ri=ri/df(fl/100,0.1,1)ri=ri/ca;if ca>0.10 then if bs then bs=(bs+ri)/2 else bs=ri end end end;if ri~=nil and ri>0 then bq=ri end;pM=od end end;cQ,cR=qj(cJ)da=b.getMaxSpeed()if bh~="None"and(c1 or g1)then lu=r7()end;rg(nil,true)end;function px.SatNavTick()if not r then return end;qa=dbHud_1.getStringValue("SPBAutopilotTargetName")if qa~=nil and qa~=""and qa~="SatNavNotChanged"then local dA=ih(dbHud_1.getStringValue("SavedLocations"))if dA~=nil then bn=dA;local gs=-1;local gy;for dF,dr in pairs(bn)do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dF,dr in pairs(e[0])do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs>-1 then e[0][gs]=gy end;cn.UpdateAtlasLocationsList()bX=gy.name.." position updated"end end;for K=1,#cP do if cP[K].name==qa then bj=K;a.print("Index = "..bj.." "..cP[K].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function px.onFlush()local function rj(rk,rl)local rm=vec3()local rn=vec3()if rk==axisCommandId.longitudinal then rm=vec3(b.getConstructOrientationForward())rn=cC elseif rk==axisCommandId.vertical then rm=vec3(b.getConstructOrientationUp())rn=pW elseif rk==axisCommandId.lateral then rm=vec3(b.getConstructOrientationRight())rn=cD else return vec3()end;local ro=vec3(b.getWorldGravity())local rp=ro:dot(rn)local rq=vec3(b.getWorldAirFrictionAcceleration())local rr=rq:dot(rn)local rs=cE:dot(rm)local rt=rl*constants.kph2m;if ru==nil then ru=pid.new(10,0,10.0)end;ru:inject(rt-rs)local rv=ru:get()local rw=(rv-rr-rp)*rn;return rw end;local function rx(rk,rl)local rm=vec3()local rn=vec3()if rk==axisCommandId.longitudinal then rm=vec3(b.getConstructOrientationForward())rn=cC elseif rk==axisCommandId.vertical then rm=vec3(b.getConstructOrientationUp())rn=pW elseif rk==axisCommandId.lateral then rm=vec3(b.getConstructOrientationRight())rn=cD else return vec3()end;local ro=vec3(b.getWorldGravity())local rp=ro:dot(rn)local rq=vec3(b.getWorldAirFrictionAcceleration())local rr=rq:dot(rn)local rs=cE:dot(rm)local rt=rl*constants.kph2m;if ry==nil then ry=pid.new(10,0,10.0)end;ry:inject(rt-rs)local rv=ry:get()local rw=(rv-rr-rp)*rn;return rw end;local function rz(rA,jH,fY)local rB=rA:cross(fY):normalize_inplace()local kt=math.acos(df(rB:dot(-jH),-1,1))*constants.rad2deg;if rB:cross(-jH):dot(fY)<0 then kt=-kt end;return kt end;local function rC()if cV and not b4 then local en=cV[1]local hJ,hK=cV[2],cV[3]local rD=math.min(hJ,hK or hJ)local rE=rD/cG;local rF=b5 and(cG<42 or c8~=-1)local rG=b3 or bo or br or b1;if rG and not rF and(b_*1.5>rD or rE<1)then aZ="Collision"bD={}pZ=0;if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bX="Autopilot Cancelled due to possible collision"a.print(en.name.." COLLISION "..iq(rE).." / "..ip(rD,2))co.ResetAutopilots(1)ln=true;if c9 then b4=true end;cu=true end;if rE<11 then cU=en.name.." COLLISION "..iq(rE).." / "..ip(rD,2)else cU=en.name.." collision "..iq(rE)end;if rE<6 then fQ("alarm","AL",2)end else cU=false end end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then q8=bt end end;if d9 then d:setEngineForceCommand('hover',vec3(),1)d9=false end;cM=ik:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rH=df(bR+pQ+a.getControlDeviceForwardInput(),-1,1)local rI=df(bS+pS+a.getControlDeviceYawInput(),-1,1)local rJ=df(bT+pR-a.getControlDeviceLeftRightInput(),-1,1)local rK=aZ and 1 or 0;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(kg.center-cJ):normalize()end;pW=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cc=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local rL=cO/180*math.pi;local rM=math.cos(rL)local rN=math.sin(rL)cN=rz(cH,cC,cD*rM+pW*rN)local rO=cF:normalize()local rP=eU(cO)local rQ=utils.sign(cO)local rR=vec3(b.getWorldAngularVelocity())local rS=rH*aM*cD+rI*aH*cC+rJ*aN*pW;if cu==true and cH:len()>0.01 then local rT=eU(pT-cO)if((b0 or b6 or b4 or c5 or b3 or bx)and rT>0 or c9 and rT<aI and p)and rI==0 and eU(cN)<85 then local rU=pT;local rV=aG;if not c9 then rV=rV/4;pT=0;rU=0 end;if rW==nil then rW=pid.new(rV*0.01,0,rV*0.1)end;rW:inject(rU-cO)local rX=rW:get()rS=rS+rX*cC end end;local rY=1;local rZ=0;local r_=1;bM=0;ca=bJ()c9=false or cb<kg.noAtmosphericDensityAltitude and ca>0.00001;cb=b.getAltitude()c8=qt()bK=bH()pC=bK;if bk and c8>-1 and c8-3<Y then if ik.targetGroundAltitudeActivated then ik:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qb=not qb;if qb then cp.UpdateRadar()end;if E then rC()end end;if antigrav then cL=antigrav.getState()==1 end;local s0=1;local s1=1;local s2=bK-pC;local s3=-math.deg(qp(pW,cF,cC))local s4=math.deg(qp(cD,cF,cC))local gn=cH*-1;cv=c9 and s3<-L or s3>L or s4<-M or s4>M;local s5=a.getMouseDeltaX()local s6=a.getMouseDeltaY()if qc then local s7=bH()-qc;s5=s5*s7/0.016;s6=s6*s7/0.016 end;qc=bH()if o and not bW then s6=-s6 end;pR=0;pS=0;pQ=0;fU=cj[0]kg=fU:closestBody(b.getConstructWorldPos())s8=cl(kg)fp=s8:orbitalParameters(b.getConstructWorldPos(),cF)if cb==0 then cb=(cJ-kg.center):len()-kg.radius end;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;local od=kg:getGravity(b.getConstructWorldPos()):len()*cc;pT=0;local s9=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if q2==0 then if ij()==1 and bW then if not cs then c2=df(c2+s5/2,-ce/2,ce/2)c3=df(c3+s6/2,-cf/2,cf/2)end else c2=0;c3=0 end else c2=df(c2+s5/2,-ce/2,ce/2)c3=df(c3+s6/2,-cf/2,cf/2)d8=dh(c2*c2+c3*c3)if not bW and ij()==0 then local kC,kD=1,1;if bF=="SCOPE"then kC,kD=d0/90,d0/90 end;if g=="virtual joystick"then if d8>aw then pR=pR-df(eU(c2)-aw,0,ce/2)*utils.sign(c2)*aE*kC;pQ=pQ-df(eU(c3)-aw,0,cf/2)*utils.sign(c3)*aF*kD end else c2=0;c3=0;if g=="mouse"then pQ=(-utils.smoothstep(s6,-100,100)+0.5)*2*s0;pR=(-utils.smoothstep(s5,-100,100)+0.5)*2*s1 end end end end;local sa=cG>27777;if cG>V/3.6 and not c9 and not b1 and not sa then bX="Space Speed Engine Shutoff reached"pZ=0 end;if not sa and sb then if not aZ then co.BrakeToggle()end;if b1 then co.ResetAutopilots(1)end;pZ=0 end;sb=sa;if ca>0.09 then if cG>cw/3.6 and not t and not py then aZ="SpdLmt"py=true elseif not t and py then if cG<cw/3.6 then aZ=false;py=false end end end;if b0 then if c5 then aZ=false;local sc=false;if g1 and c5==true then sc=qF(g1.position-cJ,0.1)else sc=qF(vec3(cF),0.01)end;cu=true;if sc then p_=bI(cw)if(eU(cO)<2 or eU(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c5~=2 then pP=true end;if c5==true then c7=true end;c5=false;b1=false;co.BeginReentry()end elseif c9 and t then pZ=1 end elseif cG>iE then qF(vec3(cF),0.01)end end;if a_ then if c9 then a_=false elseif cG>iE then qF(-vec3(cF))end end;if not b0 and c5 and not bx then if not c9 then if c5~=2 then pP=true end;co.BeginReentry()c5=false;c7=true else c5=false;if not q9 then q9=true end end end;if c7 and g1 and(cb<b8+250 and cb>b8-250)and cG*3.6>cw-250 and eU(cI)<25 and ca>=0.1 and(g1.position-cJ):len()>2000+cb then if not q9 then q9=true end;c7=false end;if b7 then cu=true;local sd=b8;if cI<-30 then bX="Unable to achieve lift. Safety Landing."bU=0;cu=p;b7=false;b4=true elseif not q and cL or b8<kg.spaceEngineMinAltitude then if cL then sd=antigrav.getBaseAltitude()end;if cb<sd-100 then pU=0;bU=15;aZ=false elseif cI>0 then aZ="VTO Limit"bU=0 elseif cI<-30 then aZ="VTO Fall"bU=15 elseif cb>=sd then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bX="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bX="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")co.ToggleVerticalTakeoff()end;bU=0 end else if ca>0.08 then pU=0;aZ=false;bU=20 elseif ca<0.08 and c9 then aZ=false;if cA then pU=0;bU=20 else bU=0;pU=36;p_=3500 end else cu=p;bx=true;cz=false;se=false;pH=false;pF=nil;pG=nil;if pK==nil then pK=kg end;cy=sd;pJ=true;b7=false end end;if pU~=nil then if sf==nil then sf=pid.new(2*0.01,0,2*0.1)end;local sg=df(pU-cN,-M*0.80,M*0.80)sf:inject(sg)local sh=df(sf:get(),-1,1)pQ=sh end end;if bx then local function si()if fp.periapsis.altitude>=cy*0.99 and fp.apoapsis.altitude>=cy*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eU(cy-cb)<1000 then return true else return false end end;local qM;local sj=false;local sk=ip(cy)if pK==nil then pK=kg;if bo then pK=c1 end end;if not pJ then cy=bI(pK.radius+pK.surfaceMaxAltitude+T)if pK.hasAtmosphere then cy=bI(pK.radius+pK.noAtmosphericDensityAltitude+T)end;pJ=true end;if pV.VectorToTarget and g1 then qM=g1.position-cJ end;local sl,sm=cl(pK):escapeAndOrbitalSpeed((cJ-pK.center):len()-pK.radius)local sn=cO;if not pH then local so=false;local sp=false;pZ=0;pG=0;cx="Aligning to orbital path - OrbitHeight: "..sk;if pV.VectorToTarget then qF(qM:normalize():project_on_plane(cH))sj=cC:dot(qM:project_on_plane(pW):normalize())>0.95 else qF(cF)sj=s3<0.5;if cG<150 then sj=true end end;pQ=0;pF=0;if cN<=pF+2 and cN>=pF-2 then so=true else so=false end;if sn<=pG+2 and sn>=pG-2 then sp=true else sp=false end;if so and sp and sj then pF=nil;pG=nil;pH=true end else if pV.VectorToTarget then qF(qM:normalize():project_on_plane(cH))elseif cG>150 then qF(cF)end;pQ=0;if pV.VectorToTarget and g1 then local b_,dK=ck.computeDistanceAndTime(cG,cw/3.6,cc,0,0,bq)if cz and qM:len()>15000+b_+cb then cx="Orbiting to Target"if cb-100<=pK.noAtmosphericDensityAltitude or lu>fp.timeToPeriapsis and fp.periapsis.altitude<pK.noAtmosphericDensityAltitude or not si()and fp.eccentricity>0.1 then bX="Re-Aligning Orbit"cz=false end elseif cz or qM:len()<15000+b_+cb then bX="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;pP=true;c7=true;pV.VectorToTarget,pV.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cb>cy*0.9 and cb<cy*1.4 then if fp.apoapsis~=nil then if si()or cz then if cz then aZ=false;pZ=0;pF=0;if not pV.VectorToTarget then bX="Orbit complete"fQ("orCom","OB")co.ToggleIntoOrbit()end else pL=pL+1;if pL>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..sk;pI=true;p_=sm*3.6+1;local sq=cy-cb;if sr==nil then sr=pid.new(0.1,0,1*0.1)end;sr:inject(sq-cI*df(utils.smoothstep(2000-sq,-2000,2000)^6*10,1,10))pF=df(sr:get(),-60,60)end end else local ss=2.75;local st=eU(fR(sl*ss))local os=st%50;if os>0 then st=st-os+50 end;aZ=false;if cb<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..sk;pF=utils.map(cI,200,0,-15,80)elseif cb>=cy*0.8 and cb<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..sk;st=st*0.75;pF=utils.map(cI,100,-100,-15,65)elseif cb>=cy*1.15 and cb<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..sk;st=st*0.75;if cI<0 or pI then pF=utils.map(cb,cy*1.5,cy*1.01,-30,0)else pF=utils.map(cb,cy*0.99,cy*1.5,0,30)end elseif cb>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..sk;pF=-65;local su=utils.map(cI,-150,-400,1,0.55)st=st*su end;p_=bI(st)end end;if pF~=nil then if sv==nil then sv=pid.new(1*0.01,0,5*0.1)end;local sw=pF-cN;sv:inject(sw)local sx=df(sv:get(),-0.5,0.5)pQ=sx end end;if b1 and not c9 and not c5 then local function sy(hW,fp)a.print(hW)aZ=false;bb=false;b1=false;qT=false;be="Aligning"pZ=0;pO=false;bX=hW;fQ("apCom","AP")if fp or c5 then if fp and gl~=nil and not c5 then if not cb or cb==0 then return end;cy=cb;pJ=true end;co.ToggleIntoOrbit()end end;local sz,sA=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not qT then local sB=(g1.position-c1.center):normalize()local sC=sB:project_on_plane((c1.center-cJ):normalize()):normalize()local sD=c1.center+sC*(c1.radius+gl)local sE=g1.position+(g1.position-c1.center):normalize()*(gl-c1:getAltitude(g1.position))if(cJ-sD):len()<(cJ-sE):len()then sz=sD else sz=sE;bd=0 end;bi=sz;co.showWayPoint(c1,bi)sA=true;qT=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not qT then bf=0;sA=true;ba=true;qT=true;sz=g1.position+(cJ-g1.position):normalize()*R;bi=sz end elseif g1==nil then bf=0;if not qT then local sB=(cJ+cF*100000-c1.center):normalize()local sC=sB:project_on_plane((c1.center-cJ):normalize()):normalize()if sC:len()<1 then sB=(cJ+cC*100000-c1.center):normalize()sC=sB:project_on_plane((c1.center-cJ):normalize()):normalize()end;sz=c1.center+sC*(c1.radius+gl)bi=sz;qT=true;sA=true;ba=true;co.showWayPoint(c1,bi)end end;r8=(vec3(sz)-cJ):len()local ls,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lt=eE;if eF~=nil and eE~=nil then lt=math.min(eF,eE)end;if lt~=nil and lt<r8 and ls.name==c1.name then r8=lt end;local sc=true;local sF=(c1.center-(cJ+vec3(cF):normalize()*r8)):len()-c1.radius;local lf=ip(sF)q6=gd;q7='{"label": "Projected Altitude", "value": "'..lf..'"}'if cG>50 and b9 then local qM=vec3(sz)-cJ;local sG=df(math.deg(qp(pW,cF:normalize(),qM:normalize()))*cG/500,-90,90)local sH=df(math.deg(qp(cD,cF:normalize(),qM:normalize()))*cG/500,-90,90)if eU(sG)<20 and eU(sH)<20 then sG=sG*2;sH=sH*2 end;if eU(sG)<2 and eU(sH)<2 then sG=sG*2;sH=sH*2 end;local s3=-math.deg(qp(pW,cC,cF:normalize()))local s4=-math.deg(qp(cD,cC,cF:normalize()))if sI==nil then sI=pid.new(2*0.01,0,2*0.1)end;sI:inject(sH-s4)local sJ=df(sI:get(),-1,1)pQ=pQ+sJ;if sK==nil then sK=pid.new(2*0.01,0,2*0.1)end;sK:inject(sG-s3)local sL=df(sK:get(),-1,1)pR=pR+sL;sA=true;if eU(sG)>2 or eU(sH)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cG<=50 then qF((sz-cJ):normalize())end;if sF<gl*1.5 then bd=cw/3.6;if g1==nil then dK,bd=cl(c1):escapeAndOrbitalSpeed(sF)end end;local b_,c0;if not b2 then b_,c0=ql(cG)else b_,c0=qo(cG)end;if b1 and not b9 and not bc and not bb then local ls,lt=co.checkLOS((bi-cJ):normalize())if c1.name~=kg.name then if ls~=nil and c1.name~=ls.name and lt<r8 then bX="Collision with "..ls.name.." in "..ip(lt).."\nClear LOS to continue."bY=5;q3=true else q3=false;bX=""end end end;if not q3 then if not bc and not bb and not sA then sc=qF((sz-cJ):normalize())elseif b2 and(bb or bc)then sc=qF(-vec3(cF):normalize())end end;if b9 then if not pO then aZ=false;pZ=a0;bL=fR(a0,2)pO=true end;local r9=c.getThrottle()if t then r9=bL end;local sM=99999;local op=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local sN=df(cF:dot((sz-cJ):normalize()),0,cG)if sN>0 or op>0 then sM=ck.computeTravelTime(sN,op,r8-b_)end;if cE:len()>=_ or r9==0 and pO or a1/4>sM then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;pZ=0 end;local sO=r8;if sO<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pz and cR>2000 then co.ResetAutopilots(1)bX="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"pz=cR else pz=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;pZ=0;pO=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then pZ=1;q0=true end;local dK,sm=cl(c1):escapeAndOrbitalSpeed((cJ-kg.center):len()-kg.radius)local qM;if g1 then qM=g1.position-cJ end;if g1 and g1.planetname=="Space"and cG<50 then if#bD>0 then if not q9 then table.remove(bD,1)end;if#bD>0 then aZ=false;if not q9 then q9=2 end;return end end;sy("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cG<=sm and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sy("Autopilot complete, commencing reentry")bi=g1.position;c5=true;co.showWayPoint(c1,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cG<=sm then if g1 then if cF:normalize():dot(qM:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not qV then aZ=false;co.showWayPoint(c1,g1.position)qV=true end else sy("Autopilot complete, proceeding with reentry")bi=g1.position;c5=true;co.showWayPoint(c1,g1.position)qV=false end else sy("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sy("Autopilot complete, fixing Orbit",true)end elseif bc then local sO=r8;if sO<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pz and cR>2000 then if not q9 then q9=true end;bX="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"pz=cR else pz=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local r9=c.getThrottle()if t then r9=bL end;if r9>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if sc then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c5 then bi=vec3(c1.center)+(gl+c1.radius)*cD;sP=pW;sQ=cD end;ba=true elseif sc and not q3 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not pO then pZ=a0;q0=true;bL=fR(a0,2)pO=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and c9)then bX="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;qT=false;be="Aligning"pZ=0;pO=false;b0=true;c5=true;co.showWayPoint(c1,g1.position)end;if bV then cu=true;local sH=0;local fr=cJ+vec3(c.getMasterPlayerRelativePosition())local sR=fr-cJ;local sS=vec3(sR):project_on(cC):len()local sT=vec3(sR):project_on(cD):len()local c4=dh(sS*sS+sT*sT)qF(sR:normalize())local mz=40;local sU=c4<mz;local sV=100;local rl=df((c4-mz)/2,10,sV)pQ=0;local sc=eU(pR)<0.1;if sc and cG<rl and not sU then aZ=false;sH=-20 else aZ="Follow"sH=0 end;local sW=0;if eU(sH-cN)>sW then if sX==nil then sX=pid.new(2*0.01,0,2*0.1)end;sX:inject(sH-cN)local sJ=sX:get()pQ=sJ end end;if b3 or b4 or b6 or bo or br~=nil then local sY=bs;if sY then sY=sY*df(cG/100,0.1,1)*ca else sY=bq end;if not c9 then sY=bq end;pY=cC:project_on_plane(cH):normalize():dot(cF)if pY>100 then b_,c0=ck.computeDistanceAndTime(pY,100,cc,0,0,sY)local sZ,s_=ck.computeDistanceAndTime(100,0,cc,0,0,sY*0.55)b_=b_+sZ else b_,c0=ck.computeDistanceAndTime(pY,0,cc,0,0,sY*0.55)end;local sq=b8-cb-cI;local t0=200+cG;if b6 or c5 then t1=2000+cG end;local t2=1;if b5 then t2=df(cG/100,0.1,1)end;local sH=(utils.smoothstep(sq,-t0,t0)-0.5)*2*O*t2;if not b6 and not c5 and not bo and cC:dot(cF:normalize())<0.99 then sH=(utils.smoothstep(sq,-t0*df(20-19*ca*10,1,20),t0*df(20-19*ca*10,1,20))-0.5)*2*O*df(2-ca*10,1,2)*t2 end;if not b3 then sH=0 end;if br~=nil then if cT and not bx then sH=br else br=nil end end;cu=true;local t3=pQ;if b6 then local t4=bI(cw)local t5,t6=ck.computeDistanceAndTime(cG,t4/3.6,cc,0,0,bq-kg.gravity*9.8*cc)t5=t5==-1 and 5000 or t5;local qU=cb-(kg.noAtmosphericDensityAltitude+t5)local t7=cb>kg.noAtmosphericDensityAltitude+t5*1.35;if t7 then sH=P;if cG<=t4/3.6 and cG>t4/3.6-10 and eU(cF:normalize():dot(cC))>0.9 and not cM then bP=false;pZ=1 end elseif(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t4)and not t7 and not c9 then p_=t4;q0=true end;if cM then if cG>t4/3.6 and not t7 then aZ="Reentry Limit"if bL>0 then pZ=0 end else aZ=false end else aZ=false end;if cI>0 then aZ="Reentry vSpd"end;if not pP then sH=-80;if cb<kg.surfaceMaxAltitude+(kg.atmosphereThickness-kg.surfaceMaxAltitude)*0.25 then bX="PARACHUTE DEPLOYED at "..fR(cb,0)b6=false;b4=true;ln=true;pZ=0;sH=0;cu=p end elseif kg.noAtmosphericDensityAltitude>0 and t7 then cu=true elseif not t7 then if not c9 and(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t4)then p_=t4 end;if cG<t4/3.6+1 then aZ=false;pP=false;b6=false;cu=true;pZ=1 end end end;if cG>iE and not c6 and not bo and not b4 and u then qF(vec3(cF))end;if cS or(bo or c6)and bj>0 and c9 then local qM;if cS then if type(cS)=="table"then qM=cS elseif cS<3 and cS>0 then qM=-cH:cross(cF)*5000 elseif cS>=3 then qM=cH:cross(cF)*5000 elseif cS<0 then qM=cF*25000 end elseif g1~=nil then qM=g1.position-cJ else qM=c1.center-cJ end;local sG=math.deg(qp(cH:normalize(),cF,qM))*2;local mC=math.rad(eU(cO))if cG>aJ and c9 then local t8=1000+cG;local t9=(utils.smoothstep(sq-cI*10,-t8,t8)-0.5)*2*O;local ta=df(90-t9,0,180)pT=df(sG*2,-ta,ta)local tb=sG;sG=df(df(sG,-L*0.80,L*0.80)*math.cos(mC)+4*(cN-sH)*math.sin(math.rad(cO)),-L*0.80,L*0.80)local tc=1;if pT~=0 then tc=eU(mC/pT)end;tc=(90-df(eU(pT-cO),0,90))/90;local td=sH;if eU(cO)>90 then td=-td end;sH=tc*df(df(td*math.cos(mC),-M*0.8,M*0.8)+eU(df(eU(tb)*math.sin(mC),-M*0.80,M*0.80)),-M*0.80,M*0.80)else pT=0;sG=df(sG,-L*0.80,L*0.80)end;local te=s3-sG;if cS and eU(te)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eU(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fQ("180Off","BR")return end;if not cv and cG>aJ and c9 then if tf==nil then tf=pid.new(2*0.01,0,2*0.1)end;tf:inject(te)local sL=df(tf:get(),-1,1)pR=pR+sL elseif c9 and c8>-1 or cG<aJ then qF(qM)elseif cv and c9 then if(s3<-L or s3>L)and c9 then qF(cF)end;if(s4<-M or s4>M)and c9 then sH=df(cN-s4,cN-M*0.80,cN+M*0.80)end end;if g1~=nil and not c6 then local sd=kg:getAltitude(g1.position)local qU=qM:project_on_plane(cH):len()ln=true;if b8<kg.noAtmosphericDensityAltitude and not c6 and not b5 and not b6 and(qU<=b_ and qM:len()<kg.radius)and(cF:project_on_plane(cH):normalize():dot(qM:project_on_plane(cH):normalize())>0.99 or lw=="Finalizing Approach")then lw="Finalizing Approach"if#bD>0 then if not q9 then table.remove(bD,1)end;if#bD>0 then if not q9 then q9=2 end;return end end;pZ=0;if b3 then co.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lw=="Finalizing Approach"and(pY<0.1 or qU<0.1 or tg~=nil and tg<qU)then fQ("bklOn","BL")b4=true;d6=true;if g1.heading then d7=g1.heading else d7=nil end;bo=false;lw="Proceeding to Waypoint"cU=false end;tg=qU end elseif bo and not c9 and b8>kg.noAtmosphericDensityAltitude and not(c6 or b6)then if g1~=nil and c1.name==kg.name then local qM=g1.position-cJ;local sd=kg:getAltitude(g1.position)local qU=dh(qM:len()^2-(cb-sd)^2)local sY=bs;if sY then b_,c0=ck.computeDistanceAndTime(cG,0,cc,0,0,sY/2)ln=true;if qU<=b_+cG*s2/2 and cF:project_on_plane(cH):normalize():dot(qM:project_on_plane(cH):normalize())>0.99 then if kg.hasAtmosphere then aZ=false;b0=false;pP=true;c5=false;c7=true;b1=false;co.BeginReentry()end end;tg=qU end end end;if not c9 and(b3 and b8>kg.noAtmosphericDensityAltitude)and not(c6 or bx or b6)then if not cz and not bx then cy=b8;pJ=true;if bo then pV.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pH=true end end;if cv and c9 and c8==-1 and cG>aJ and lw~="Finalizing Approach"then qF(cF)sH=df(cN-s4,cN-M*0.80,cN+M*0.80)end;pQ=t3;local qy=-1;if b4 then if not q4 then if not cM then pZ=0 end;ik:setTargetGroundAltitude(500)ik:activateGroundEngineAltitudeStabilization(500)bz=true;q4=true end;sH=0;local th=false;local ti=math.abs(pY)if not q and cL then th=antigrav.getBaseAltitude()if th<kg.surfaceMaxAltitude and g1==nil or g1~=nil and kg:getAltitude(g1.position)>th then th=false end else th=false end;if d7 then if ti<0.05 then if cI>-N then aZ=false else aZ="BL Align BLR"end;if qF(d7,0.001)then d7=nil;cu=p else pQ=0;cu=true end else aZ="BL Align Hzn"end;if th and eU(cb-th)<250 then aZ="AGG Align"end else local tj=false;local tk=30;if ti<10 and s9~=nil and s9>0 then local tl=df(ca,0.4,2)local sY=bs*df(cG/100,0.1,1)*tl;local tm=s9*tl+sY-od;local tn=sY/2-od;local to=cG-dh(eU(tn/2)*20/(0.5*cc))*utils.sign(tn)if to<0 then to=0 end;local tp;if cG>100 then local tq,dK=ck.computeDistanceAndTime(cG,100,cc,0,0,sY)local tr,dK=ck.computeDistanceAndTime(100,0,cc,0,0,dh(sY))tp=tq+tr else tp=ck.computeDistanceAndTime(cG,0,cc,0,0,dh(sY))end;if tp<20 then aZ=false else local ts=0;if to>100 then local tt,dK=ck.computeDistanceAndTime(to,100,cc,0,0,tm)local tu,dK=ck.computeDistanceAndTime(100,0,cc,0,0,s9*tl+dh(sY)-od)ts=tt+tu else ts,dK=ck.computeDistanceAndTime(to,0,cc,0,0,s9*tl+dh(sY)-od)end;ts=(ts+15+cG*s2)*1.1;local tv=d6 and g1~=nil and kg:getAltitude(g1.position)>0 and g1.safe;local sd=nil;if th and th<cb then sd=th elseif tv then sd=kg:getAltitude(g1.position)+250 elseif cb>kg.surfaceMaxAltitude then sd=kg.surfaceMaxAltitude end;if cV then local tw=kg:getAltitude(cV[1].center)if sd then if tw>sd then sd=tw end else sd=tw end end;if sd~=nil then local tx=cb-sd;tj=true;if tx<=ts or ts==-1 or ti>0.05 and d6 then if ti>0.05 and d6 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qy=c8;if qy>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;if not th then q1=true;ik:setTargetGroundAltitude(Y)end;bU=0;aZ="BL Complete"cu=p;d6=false else aZ="BL Slowing"end elseif not tj then if ln and cF:normalize():dot(-gn)<0.999 then aZ="BL Strong"qF()elseif ti>10 or ti>0.05 and d6 then aZ="BL hSpd"elseif cI<-N then aZ="BL BLR"else aZ=false end end end else q4=false end;if b5 or c6 then local ls,eF,eE;if bi~=nil then ls,eF,eE=cj:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(en)return en.radius+en.noAtmosphericDensityAltitude end)end;if cL and not c6 then if cb>=b8-50 and cG>iE then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"pZ=0 end end elseif eU(sH)<15 and cb/b8>0.75 then b5=false;if not c6 then if cM and not t then d.control.cancelCurrentControlMasterMode()end elseif c6 and cG<iE then b1=true;c6=false;b3=false;b5=false;pZ=0 elseif c6 then pZ=0;aZ="ATO Space"end elseif c6 and not c9 and c1~=nil and(ls==nil or ls.name==c1.name)then b1=true;c6=false;b3=false;b5=false;if not cM then pZ=0 end;b9=true end end;local ty=c8>-1;local tz=cN;if(bo or c6 or cS)and not ty and cG>aJ and c9 then local mC=math.rad(eU(cO))tz=cN*eU(math.cos(mC))+s4*math.sin(mC)end;local tA=df(sH-tz,-M*0.80,M*0.80)if not c9 and bo then tA=df(sH-tz,-85,O)elseif not c9 then tA=df(sH-tz,-O,O)end;if eU(cO)<5 or bo or cS or b4 or ty or b3 then if sX==nil then sX=pid.new(5*0.01,0,5*0.1)end;sX:inject(tA)local sJ=sX:get()pQ=pQ+sJ end end;if antigrav~=nil and(antigrav and not q and cb<200000)then if bt==nil or bt<1000 then bt=1000 end;if tB~=bt then tB=bt;q8=tB end end;if(c9 or b6 or c7)and t and cM then if tC==nil then tC=pid.new(0.1,0,1)end;local tD=0;if aS>0 and not b6 and ca>0.005 and ca<0.1 and cI>-50 then tD=(0.1-ca)*cw*aS end;tC:inject(cw/3.6+tD-cF:dot(cC))local tE=tC:get()bO=df(tE,-1,1)if not d2 then if bO<bL and(ca>0.005 or b6 or c7)then bN=true;d2=df(bO,0.01,1)else bN=false;d2=bL end end;if tF==nil then tF=pid.new(1*0.01,0,1*0.1)end;tF:inject(cF:len()-cw/3.6-tD)local tG=df(tF:get(),0,1)if c9 and cI<-80 or(ca>0.005 or b6 or c7)then bM=tG end;if bM>0 then if bN and bO==0.01 and not d2 then d2=0 end else bO=df(bO,0.01,1)end;local tH=''local tI=vec3()local tJ=rj(axisCommandId.vertical,bU*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tJ,rZ)local tK='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tK=tK..aT end;local tL=ik:getAxisCommandType(axisCommandId.longitudinal)local tM=ik:composeAxisAccelerationFromThrottle(tK,axisCommandId.longitudinal)local tN=rx(axisCommandId.lateral,bw*1000)tH=tH..' , '.."lateral airfoil , lateral ground "tI=tI+tN;if tI:len()>constants.epsilon then d:setEngineForceCommand(tH,tI,rZ,'','','',r_)end;d:setEngineForceCommand(tK,tM,rY)local tO='thrust analog vertical fueled 'local tP='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tP=tP..aU end;if bA=="All"or bA=="Vertical"then tO=tO..aV end;if bU~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tO,tJ,rY)else d:setEngineForceCommand(tO,vec3(),rY)end;if bw~=0 then d:setEngineForceCommand(tP,tN,rY)else d:setEngineForceCommand(tP,vec3(),rY)end;if rK==0 then rK=bM end;local tQ=-rK*(aO*cF+aP*rO)d:setEngineForceCommand('brake',tQ)else if t then if not d2 then d2=bL end end;local rl=c.getAxisCommandValue(0)if not cM then if tF==nil then tF=pid.new(1*0.01,0,1*0.1)end;tF:inject(cF:len()-rl/3.6)local tG=df(tF:get(),0,1)rK=df(rK+tG,0,1)end;local tQ=-rK*(aO*cF+aP*rO)d:setEngineForceCommand('brake',tQ)local tH=''local tI=vec3()local tR=false;local tK='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tK=tK..aT end;local tL=ik:getAxisCommandType(axisCommandId.longitudinal)if tL==axisCommandType.byThrottle then local tM=ik:composeAxisAccelerationFromThrottle(tK,axisCommandId.longitudinal)d:setEngineForceCommand(tK,tM,rY)elseif tL==axisCommandType.byTargetSpeed then local tM=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tH=tH..' , '..tK;tI=tI+tM;if ik:getTargetSpeed(axisCommandId.longitudinal)==0 or ik:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ik:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tR=true end end;local tP='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tP=tP..aU end;local tS=ik:getAxisCommandType(axisCommandId.lateral)if tS==axisCommandType.byThrottle then local tT=ik:composeAxisAccelerationFromThrottle(tP,axisCommandId.lateral)d:setEngineForceCommand(tP,tT,rY)elseif tS==axisCommandType.byTargetSpeed then local tN=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tH=tH..' , '..tP;tI=tI+tN end;local tO='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tO=tO..aV end;local tU=ik:getAxisCommandType(axisCommandId.vertical)if tU==axisCommandType.byThrottle then local tJ=ik:composeAxisAccelerationFromThrottle(tO,axisCommandId.vertical)if bU~=0 or b4 and aZ then d:setEngineForceCommand(tO,tJ,rY,'airfoil','ground','',r_)else d:setEngineForceCommand(tO,vec3(),rY)d:setEngineForceCommand('airfoil vertical',tJ,rY,'airfoil','','',r_)d:setEngineForceCommand('ground vertical',tJ,rY,'ground','','',r_)end elseif tU==axisCommandType.byTargetSpeed then if bU<0 then d:setEngineForceCommand('hover',vec3(),rY)end;local tV=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tH=tH..' , '..tO;tI=tI+tV end;if tI:len()>constants.epsilon then if rK~=0 or tR or eU(rO:dot(cC))<0.5 then tH=tH..', brake'end;d:setEngineForceCommand(tH,tI,rZ,'','','',r_)end end;local tW=aL*(rS-rR)local tX=vec3(b.getWorldAirFrictionAngularAcceleration())tW=tW-tX;d:setEngineTorqueCommand('torque',tW,rY,'airfoil','','',r_)d:setBoosterCommand('rocket_engine')if bZ and not n then local fl=cE:len()local tY=0.15;if not cM then local tZ=ik:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>tZ*(1-tY)and t_ then t_=false;d:toggleBoosters()elseif fl*3.6<tZ*(1-tY)and not t_ then t_=true;d:toggleBoosters()end else local r9=c.getThrottle()if t then r9=bL*100 end;local rl=r9/100;if not c9 then rl=rl*_;if fl>=rl*(1-tY)and t_ then t_=false;d:toggleBoosters()elseif fl<rl*(1-tY)and not t_ then t_=true;d:toggleBoosters()end else local t4=bI(cw)rl=rl*t4/3.6;if fl>=rl*(1-tY)and t_ then t_=false;d:toggleBoosters()elseif fl<rl*(1-tY)and not t_ then t_=true;d:toggleBoosters()end end end end end;if u0 then for dF,dr in pairs(u0)do px[dF]=dr end end;c8=qt()return px end;local function u1(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u2,ij,ik,il,u3,gI,fR,d_,dg,df,fQ,io,pw)local u4={}local u5=true;local u6=5;local u7=5;local u8=u6;local u9=u7;local ua=bK;function u4.landingGear()bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c9 and c8==-1 then fQ("bklOn","BL")ln=true;b6=false;b5=false;b7=false;b3=false;if b4 then d6=not d6 end;b4=true;cu=true;bk=false else if bQ then fQ("grOut","LG",1)d.control.extendLandingGears()end;d6=false;ik:setTargetGroundAltitude(Y)if c9 then aZ="Landing"end end end;if bQ and not b4 and not(vBooster or hover)then fQ("grOut","LG",1)d.control.extendLandingGears()end else if bQ then fQ("grIn","LG",1)d.control.retractLandingGears()end;ik:activateGroundEngineAltitudeStabilization(ub)if bz then ik:setTargetGroundAltitude(X)end end end;function u4.startControl(uc)local function ud(r4)local r5=1;local function ue(uf,r4)local ug={kg.surfaceMaxAltitude+100,kg.spaceEngineMinAltitude-0.01*kg.noAtmosphericDensityAltitude,kg.noAtmosphericDensityAltitude+T,kg.radius*(S-1)+kg.noAtmosphericDensityAltitude}local uh=uf;for dK,dr in ipairs(ug)do if r4 and uh>dr then uf=dr elseif uf<dr and not r4 then uf=dr;break end end;return uf end;if r4 then r5=-1 end;if not q and cL then if bW and r4 then bt=1000 elseif bt~=nil then bt=bt+r5*u7;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tB+r5*100 end elseif b3 or b7 or bx then if bx then if bW then cy=ue(cy,r4)else cy=cy+r5*u6 end;if cy<kg.noAtmosphericDensityAltitude then cy=kg.noAtmosphericDensityAltitude end else if bW and c9 then b8=ue(b8,r4)else b8=b8+r5*u6 end end else if not r4 and c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:updateTargetGroundAltitudeFromActionStart(r5*1.0)end end;local function ui(uj)if not c9 then bX="Flight Assist in Atmo only"return end;local dn=type(uj)if cS==nil then if dn=="table"then if b1 or bo then co.ToggleAutopilot()end;fQ("180On","BR")elseif uj==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dn~="table"then uj=uj+1 end end;cS=uj else fQ("180Off","BR")cS=nil end end;if uc=="gear"then cq.landingGear()elseif uc=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uc=="forward"then if oZ and not c9 and not b1 then b0=not b0;a_=false else bR=bR-1 end elseif uc=="backward"then if oZ then if not c9 then if not b1 then a_=not a_;b0=false else b2=not b2 end else ui(-cF*5000)end else bR=bR+1 end elseif uc=="left"then if oZ then ui(1)else bS=bS-1 end elseif uc=="right"then if oZ then ui(3)else bS=bS+1 end elseif uc=="yawright"then bT=bT-1;d7=nil elseif uc=="yawleft"then bT=bT+1;d7=nil elseif uc=="straferight"then ik:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif uc=="strafeleft"then ik:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif uc=="up"then bU=bU+1;if c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif uc=="down"then bU=bU-1;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif uc=="groundaltitudeup"then ud()elseif uc=="groundaltitudedown"then ud(true)elseif uc=="option1"then uk=false;if oZ and bW then local ul=""for K=1,#cY do ul=ul.."| Name: "..a.getPlayerName(cY[K]).." Mass: "..fR(b.getBoardedPlayerMass(cY[K])/1000,1).."t "end;a.print("Onboard: "..ul)return end;cn.adjustAutopilotTargetIndex()elseif uc=="option2"then uk=false;if oZ and bW then for K=1,#cY do b.forceDeboard(cY[K])end;bX="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif uc=="option3"then local function um()u5=not u5;if not u5 then fQ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(un,atmofueltank_size,"Atmo Fuel","fuel_container")uo=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(up,spacefueltank_size,"Space Fuel","fuel_container")uq=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(ur,rocketfueltank_size,"Rocket Fuel","fuel_container")us=_autoconf.panels[_autoconf.panels_size]end;ut=a.createWidgetPanel("Docking")uu=a.createWidget(ut,"parenting")a.addDataToWidget(c.getDataId(),uu)uv=a.createWidgetPanel("Core combat stress")uw=a.createWidget(uv,"core_stress")a.addDataToWidget(b.getDataId(),uw)if db~=nil then db.show()end else fQ("hud","DH")c.hide()b.hide()if uo~=nil then gI(uo)uo=nil end;if ut~=nil then gI(ut)ut=nil end;if uv~=nil then gI(uv)uv=nil end;if uq~=nil then gI(uq)uq=nil end;if us~=nil then gI(us)us=nil end;if db~=nil then db.hide()end end end;uk=false;if oZ and bW then local ul=""for K=1,#cZ do ul=ul.."| ID: "..cZ[K].." Mass: "..fR(b.getDockedConstructMass(cZ[K])/1000,1).."t "end;a.print("Docked Ships: "..ul)return end;if x then if w then w=false else w=true end end;um()elseif uc=="option4"then uk=false;if oZ and bW then for K=1,#cZ do b.forceUndock(cZ[K])end;bX="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif uc=="option5"then uk=false;co.ToggleLockPitch()elseif uc=="option6"then uk=false;if oZ and bW then if db then cr.ventShield()else bX="No shield found"end;return end;co.ToggleAltitudeHold()elseif uc=="option7"then uk=false;if oZ and bW then if db then db.toggle()return else bX="No shield found"return end end;E=not E;if E then bX="Collision System Enabled"else bX="Collision System Secured"end elseif uc=="option8"then uk=false;if oZ and bW then if bj>0 and g1~=nil then co.routeWP()else bX="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bX="DeCoupled Mode - Ground Stabilization off"ik:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bX="Coupled Mode - Ground Stabilization on"ik:activateGroundEngineAltitudeStabilization(ub)d9=true;fQ("gsOn","GS")end elseif uc=="option9"then uk=false;if oZ and bW then ik:resetCommand(axisCommandId.longitudinal)ik:resetCommand(axisCommandId.lateral)ik:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cd=gyro.getState()==1;if cd then fQ("gyOn","GA")else fQ("gyOff","GA")end else bX="No gyro found"end elseif uc=="lshift"then cW=false;if oZ then bW=true end;if il()==1 then bW=true;bg=il()u3(1)elseif ij()==1 and y then bW=true;ct=false;cs=false end elseif uc=="brake"then if aX or oZ then co.BrakeToggle("Manual")elseif not aZ then co.BrakeToggle("Manual")else aZ="Manual"end elseif uc=="lalt"then uk=true;oZ=true;if ij()==0 and not i and g=="keyboard"then u3(1)end elseif uc=="booster"then if n then d:toggleBoosters()elseif not bZ then if not t_ then d:toggleBoosters()t_=true end;bZ=true else if t_ then d:toggleBoosters()t_=false end;bZ=false end elseif uc=="stopengines"then local function ux()if bK-ua<1.5 then fQ("clear","CA")co.clearAll()end end;ux()ua=bK;if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ik:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if ik:getTargetSpeed(axisCommandId.longitudinal)~=0 then ik:resetCommand(axisCommandId.longitudinal)else if c9 then co.cmdCruise(cw)else co.cmdCruise(_*3.6)end end end elseif uc=="speedup"then co.changeSpd()elseif uc=="speeddown"then co.changeSpd(true)elseif uc=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bX="No antigrav found"end end end;function u4.stopControl(uc)local function uy()if not q and cL then u9=u7 end;if b3 or b7 or bx then u8=u6 end end;if uc=="forward"then bR=0 elseif uc=="backward"then bR=0 elseif uc=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bS=0 elseif uc=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bS=0 elseif uc=="yawright"then bT=0 elseif uc=="yawleft"then bT=0 elseif uc=="straferight"then ik:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif uc=="strafeleft"then ik:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif uc=="up"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then ik:activateGroundEngineAltitudeStabilization(ub)d9=true end elseif uc=="down"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then ik:activateGroundEngineAltitudeStabilization(ub)d9=true end elseif uc=="groundaltitudeup"then uy()uk=false elseif uc=="groundaltitudedown"then uy()uk=false elseif uc=="lshift"then if il()==1 then c2=0;c3=0;u3(bg)elseif ij()==1 and y then ct=false;cs=false end;bW=false elseif uc=="brake"then if not aX and not oZ then if aZ then co.BrakeToggle()else aZ=false end end elseif uc=="lalt"then if ij()==0 and i then if uk then if il()==1 then u3(0)else u3(1)end else uk=true end elseif ij()==0 and not i and g=="keyboard"then u3(0)end;oZ=false end end;function u4.loopControl(uc)local function uz(r4)local r5=1;if r4 then r5=-1 end;if not q and cL then if bt~=nil then bt=bt+r5*u9;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;u9=df(u9*1.05,u7,50)else bt=tB+r5*100 end elseif b3 or b7 or bx then if bx then cy=cy+r5*u8;if cy<kg.noAtmosphericDensityAltitude then cy=kg.noAtmosphericDensityAltitude end else b8=b8+r5*u8 end;u8=df(u8*1.05,u6,50)else ik:updateTargetGroundAltitudeFromActionLoop(r5*1.0)end end;local function uA(r4)local r5=1;if r4 then r5=-1 end;if not bW then if t and not oZ then bL=df(bL+r5*aD/100,-1,1)else ik:updateCommandFromActionLoop(axisCommandId.longitudinal,r5*aD)end end end;if uc=="groundaltitudeup"then if not bW then uz()end elseif uc=="groundaltitudedown"then if not bW then uz(true)end elseif uc=="speedup"then uA()elseif uc=="speeddown"then uA(true)end end;function u4.inputTextControl(r3)local function uB(uC,fr,gv)local function uD(fr)local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local dO,dP,dX,dY,dZ=d_(fr,dy)if dO=="0"and dP=="0"then return vec3(dg(dX),dg(dY),dg(dZ))end;dY=math.rad(dY)dX=math.rad(dX)local kg=e[dg(dO)][dg(dP)]local eQ=math.cos(dX)local uE=vec3(eQ*math.cos(dY),eQ*math.sin(dY),math.sin(dX))return kg.center+(kg.radius+dZ)*uE end;local fT=uD(fr)return cn.AddNewLocation(uC,fT,gv)end;local K;local uF,i7=nil,nil;local uG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r3," ")uF=r3;if K~=nil then uF=string.sub(r3,0,K-1)i7=string.sub(r3,K+1)end;if uF=="/help"or uF=="/commands"then for lo in string.gmatch(uG,"([^\n]+)")do a.print(lo)end;return elseif uF=="/setname"then if i7==nil or i7==""then bX="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then cn.UpdatePosition(i7)else bX="Select a saved target to rename first"end elseif db and uF=="/resist"then cr.setResist(i7)elseif uF=="/addlocation"or string.find(r3,"::pos")~=nil then local gv=false;local uC="0-Temp"if i7==nil or i7==""or uF~="/addlocation"then i7=uF;gv=true end;K=string.find(i7,"::")if not gv then uC=string.sub(i7,1,K-2)end;local fr=string.sub(i7,K)uB(uC,fr,gv)elseif uF=="/agg"then if i7==nil or i7==""then bX="Usage: /agg targetheight"return end;i7=dg(i7)if i7<1000 then i7=1000 end;bt=i7;bX="AGG Target Height set to "..i7 elseif uF=="/G"then if i7==nil or i7==""then bX="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i7=="dump"then for dF,dr in pairs(io())do if type(dr.get())=="boolean"then if dr.get()==true then a.print(dF.." true")else a.print(dF.." false")end elseif dr.get()==nil then a.print(dF.." nil")else a.print(dF.." "..dr.get())end end;return end;K=string.find(i7," ")local uH=string.sub(i7,0,K-1)local uI=string.sub(i7,K+1)for dF,dr in pairs(io())do if dF==uH then local uJ=type(dr.get())if uJ=="number"then uI=dg(uI)if dF=="AtmoSpeedLimit"then cw=uI end end;bX="Variable "..uH.." changed to "..uI;if dF=="MaxGameVelocity"then uI=uI/3.6;if uI>da-0.2 then uI=da-0.2;bX="Variable "..uH.." changed to "..fR(uI*3.6,1)end end;if uJ=="boolean"then if string.lower(uI)=="true"then uI=true else uI=false end end;dr.set(uI)return end end;bX="No such global variable: "..uH elseif uF=="/deletewp"then if bj>0 and g1~=nil then cn.ClearCurrentPosition()else bX="Select a custom wp to delete first in IPH"end elseif uF=="/copydatabank"then if dbHud_2 then pw(true)else bX="Spare Databank required to copy databank"end elseif uF=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c1,bi,true))a.print(json.encode(bi))bX="::pos waypoint shown in lua chat in local and world format"else bX="No target selected in IPH"end elseif uF=="/createPrivate"then local uK="privatelocations = {\n"local uL=""if#d4>0 then for dF,dr in pairs(d4)do uK=uK.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uK=uK.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uK=uK.."safe = true},\n"else uK=uK.."safe = false},\n"end end end;uL=#d4 .."-Private "if i7=="all"then for dF,dr in pairs(bn)do uK=uK.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '*"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uK=uK.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uK=uK.." safe = true},\n"else uK=uK.."safe = false},\n"end end;uL=uL..#bn.."-Public "end;uK=uK.."}\n return privatelocations"if u2 then u2.setHTML(uK)end;bX=uL.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bY=7 end end;function u4.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bX="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uM then for dF,dr in pairs(uM)do u4[dF]=dr end end;return u4 end;local function uN(d,b,c,a,library,e,vBooster,hover,pv,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u2)local uO={}local de=string.format;local ih=json.decode;local uP=json.encode;local po=b.getElementMaxHitPointsById;local ii=b.getElementMassById;local ij=d.control.isRemoteControlled;local d_=string.match;local gI=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local u3=a.lockView;local il=a.isViewLocked;local dh=math.sqrt;local dg=tonumber;local eU=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eP=math.atan;local bH=a.getArkTime;local df=utils.clamp;local ik=d.axisCommandManager;local uQ=Y;local gK=13;local ir=b.getElementIdList()local is=0;local function di(ex,ey)if ex==0 then return eU(ey)<1e-09 end;if ey==0 then return eU(ex)<1e-09 end;return eU(ex-ey)<math.max(eU(ex),eU(ey))*dw end;local function fR(dx,uR)local r5=10^(uR or 0)return bI(dx*r5+0.5)/r5 end;local function im(uS,uT)for dF,dr in pairs(uT)do if type(dF)=="string"then uS[dF]=dr else uS[#uS+1]=uT[dF]end end;return uS end;local function io(uU)local uV={}if not uU then im(uV,J)im(uV,a8)im(uV,aB)im(uV,aW)return uV elseif uU=="boolean"then return J elseif uU=="handling"then return a8 elseif uU=="hud"then return aB elseif uU=="physics"then return aW end end;local function pw(uW)local function uX(uY)for dF,dr in pairs(uY)do dbHud_1.setStringValue(dF,uP(dr.get()))if uW and dbHud_2 then dbHud_2.setStringValue(dF,uP(dr.get()))end end end;if dbHud_1 then uX(bE)uX(io())a.print("Saved Variables to Datacore")if uW and dbHud_2 then bX="Databank copied.  Remove copy when ready."end end end;local function fQ(uZ,u_,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uZ..".mp3")end;local function gJ(hk,hl,r3,jy,v0)if jy==nil then jy=""end;if v0==nil then v0=""end;return de([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jy,hk,hl,v0,r3)end;local function ip(c4,v1)local v2=c4>100000;if v1==nil then v1=1 end;if v2 then return fR(c4/1000/200,v1).."SU"elseif c4<1000 then return fR(c4,v1).."M"else return fR(c4/1000,v1).."KM"end end;local function iq(v3)local v4=0;local v5=0;local v6=0;if v3<60 then v3=bI(v3)elseif v3<3600 then v4=bI(v3/60)v3=bI(v3%60)elseif v3<86400 then v5=bI(v3/3600)v4=bI(v3%3600/60)else v6=bI(v3/86400)v5=bI(v3%86400/3600)end;if v6>0 then return v6 .."d "..v5 .."h "elseif v5>0 then return v5 .."h "..v4 .."m "elseif v4>0 then return v4 .."m "..v3 .."s"elseif v3>0 then return v3 .."s"else return"0s"end end;function uO.onStart()local v7=false;local function v8()local function v9(va)local vb=dbHud_1.hasKey;for dF,dr in pairs(va)do if vb(dF)then local dA=ih(dbHud_1.getStringValue(dF))if dA~=nil then dr.set(dA)v7=true end end end end;if dbHud_1 then if not f then v9(io())coroutine.yield()v9(bE)else v9(bE)bX="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bY=5;v7=false end;coroutine.yield()if v7 then bX="Loaded Saved Variables"ce=a9;cf=aa;aX=j;g=string.lower(g)cu=p;cw=U elseif not f then bX="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if T<2000 then bX="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=im(d5,bn)end else bX="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bK then bs=0 end;bu=bK;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bX="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bY=7 end;if antigrav and not q then if bt==nil then bt=cb end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d4>0 then d5=im(d5,d4)end end;lw="Proceeding to Waypoint"end;local function vc()local function vd(ve,vf)if ve>vf then vf=ve end;local vg,vh=0,0;if a5>0 then vg=a5*0.05 end;if a6>0 then vh=a6*0.05 end;vf=vf*(1-(vg+vh))return vf end;local vi=b.getElementNameById;local vj=aq~=0 and ar~=0;local vk=_G["atmofueltank_size"]local vl=_G["spacefueltank_size"]local vm=_G["rocketfueltank_size"]for dF in pairs(ir)do local type=b.getElementTypeById(ir[dF])if d_(type,'^.*Atmospheric Engine$')then if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')and b.getElementForwardById(ir[dF])[3]>0 then cK=true end end;if d_(type,'^.*Space Engine$')then cB=true;if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')then local vn=b.getElementForwardById(ir[dF])if vn[3]<0 then vo=true else cA=true end end end;if type=="Landing Gear"then bQ=true end;if type=="Dynamic Core Unit"then local pq=po(ir[dF])if pq>10000 then gK=110 elseif pq>1000 then gK=55 elseif pq>150 then gK=27 end end;is=is+po(ir[dF])if vj and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pq=po(ir[dF])local ol=ii(ir[dF])local ve=0;local jr=bH()if type=="Atmospheric Fuel Tank"then local vf=400;local vp=35.03;if pq>10000 then vf=51200;vp=5480 elseif pq>1300 then vf=6400;vp=988.67 elseif pq>150 then vf=1600;vp=182.67 end;ve=ol-vp;if a2>0 then vf=vf+vf*a2*0.2 end;vf=vd(ve,vf)local gu=vi(ir[dF])local jp=0;for jq=1,vk do if gu==ih(c["atmofueltank_"..jq].getData()).name then jp=jq;break end end;local vq={ir[dF],string.sub(gu,1,12),vf,vp,ve,jr,jp}cg[#cg+1]=vq end;if type=="Rocket Fuel Tank"then local vf=320;local vp=173.42;if pq>65000 then vf=40000;vp=25740 elseif pq>6000 then vf=5120;vp=4720 elseif pq>700 then vf=640;vp=886.72 end;ve=ol-vp;if a4>0 then vf=vf+vf*a4*0.1 end;vf=vd(ve,vf)local gu=vi(ir[dF])local jp=0;for jq=1,vm do if gu==ih(c["rocketfueltank_"..jq].getData()).name then jp=jq;break end end;local vq={ir[dF],string.sub(gu,1,12),vf,vp,ve,jr,jp}ci[#ci+1]=vq end;if type=="Space Fuel Tank"then local vf=600;local vp=35.03;if pq>10000 then vf=76800;vp=5480 elseif pq>1300 then vf=9600;vp=988.67 elseif pq>150 then vf=2400;vp=182.67 end;ve=ol-vp;if a3>0 then vf=vf+vf*a3*0.2 end;vf=vd(ve,vf)local gu=vi(ir[dF])local jp=0;for jq=1,vl do if gu==ih(c["spacefueltank_"..jq].getData()).name then jp=jq;break end end;local vq={ir[dF],string.sub(gu,1,12),vf,vp,ve,jr,jp}ch[#ch+1]=vq end end end;if not cK then b7,aY=false,false end end;local function vr()if gyro~=nil then cd=gyro.getState()==1 end;if not bz then ik:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u3(1)else u3(0)end;if door and(c9 or not c9 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(c9 or not c9==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if ij()==1 and k then a.freeze(1)else a.freeze(0)end;if bQ then if c8~=-1 and not cL then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearExtended()==1 or c8~=-1 and c8-3<Y;if c8~=-1 or not c9 and cE:len()<50 then aZ="Startup"else aZ=false end;ik:setTargetGroundAltitude(uQ)pc=c9 end;local function vs()local vt={}local function vu()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vv={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vw={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vx,vy in pairs(e)do e[vx][0]=vu()e[vx][0].systemId=vx;vt[vx]={}for vz,kg in pairs(e[vx])do kg.gravity=kg.gravity/9.8;kg.center=vec3(kg.center)kg.name=kg.name[1]kg.noAtmosphericDensityAltitude=vw[kg.id]or kg.atmosphereThickness or kg.atmosphereRadius-kg.radius;kg.spaceEngineMinAltitude=vv[kg.id]or 0.68377*kg.atmosphereThickness;kg.planetarySystemId=vx;kg.bodyId=kg.id;vt[vx][vz]=kg;if mo==nil or kg.center.x<mo then mo=kg.center.x end;if mn==nil or kg.center.x>mn then mn=kg.center.x end;if mr==nil or kg.center.y<mr then mr=kg.center.y end;if mq==nil or kg.center.y>mq then mq=kg.center.y end;if kg.center and kg.name~="Space"then c_[#c_+1]=kg end end end;e9=dd(d,b,c,a,de,df,dg,dh,di)cj=e9(vt)ck=eT(d,b,c,a,dh,eU)cl=fn(d,b,c,a,de,df,dg,dh,di)cn=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)kg=cj[0]:closestBody(b.getConstructWorldPos())end;vA=false;vB=coroutine.create(function()ik:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v8()coroutine.yield()vc()coroutine.yield()co=pu(d,b,c,a,e,vBooster,hover,pv,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,pw,ih,de,fP)vr()coroutine.yield()vs()if radar_1 then cp=gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)end;if ie then cm=ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)end;if cm then cm.ButtonSetup()end;cq=u1(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u2,ij,ik,il,u3,gI,fR,d_,dg,df,fQ,io,pw)if db then cr=hZ(db,d_,bI)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u2 then u2.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if db then c.setTimer("shieldTick",0.0166667)end;if vC then vD.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vB)end;function uO.onUpdate()if not vA then local hQ=coroutine.status(vB)if hQ=="suspended"then local dG,hR=coroutine.resume(vB)if hR then a.print("ERROR STARTUP: "..hR)end elseif hQ=="dead"then vA=true end end;if vA then d:update()if c9 and t and cM then if cM and bP then co.cmdThrottle(0)bP=false elseif not cM and not bP then bL=0;bP=true end end;if d2 then ik:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p0~=vE then a.setScreen(p0)end;vE=p0;if vC then vD.ExtraOnUpdate()end end end;function uO.onFlush()if vA then co.onFlush()if vC then vD.ExtraOnFlush()end end end;function uO.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;w=d1;pw()if nW then nW.activate()end;if z then co.showWayPoint(kg,cJ)end;if cm then a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))end;if vC then vD.ExtraOnStop()end;fQ("stop","SU")end;function uO.controlStart(uc)if vA then cq.startControl(uc)end end;function uO.controlStop(uc)if vA then cq.stopControl(uc)end end;function uO.controlLoop(uc)if vA then cq.loopControl(uc)end end;function uO.controlInput(r3)if vA then cq.inputTextControl(r3)end end;function uO.radarEnter(dP)cp.onEnter(dP)end;function uO.radarLeave(dP)cp.onLeave(dP)end;function uO.onTick(vF)if vF=="tenthSecond"then co.TenthTick()if cm then cm.TenthTick()end elseif vF=="oneSecond"then if cm then cm.OneSecondTick()end elseif vF=="fiveSecond"then co.SatNavTick()elseif vF=="msgTick"then if cm then cm.MsgTick()end elseif vF=="animateTick"then if cm then cm.AnimateTick()end elseif vF=="hudTick"then if cm then cm.hudtick()end elseif vF=="apTick"then co.APTick()elseif vF=="shieldTick"then cr.shieldTick()elseif vF=="tagTick"then cq.tagTick()elseif vF=="contact"then cp.ContactTick()end end;if vC then for dF,dr in pairs(vC)do uO[dF]=dr end end;return uO end;function script.onStart()vD.onStart()end;function script.onStop()vD.onStop()end;function script.onTick(vF)vD.onTick(vF)end;function script.onFlush()vD.onFlush()end;function script.onUpdate()vD.onUpdate()end;function script.onActionStart(uc)vD.controlStart(uc)end;function script.onActionStop(uc)vD.controlStop(uc)end;function script.onActionLoop(uc)vD.controlLoop(uc)end;function script.onInputText(r3)vD.controlInput(r3)end;function script.onEnter(dP)vD.radarEnter(dP)end;function script.onLeave(dP)vD.radarLeave(dP)end;bG(a,b,c,a.getArkTime,math.floor,c.getAtmosphereDensity)vD=uN(d,b,c,a,library,e,vBooster,hover,pv,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u2)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
