name: ArchHud - Archaegeo v1.356 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.356;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local x=math.sqrt;local y=tonumber;local core=core;local function z(num,A)local B=10^(A or 0)return d(num*B+0.5)/B end;local C=p()local D=p()local E=16;local F=13;local G=SafeR;local H=SafeB;local I=SafeG;local J=0;local K=0;local L=false;local M=0;local N=false;local O=false;local P=55;local Q=false;local R=false;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=false;local a0=false;local a1="empty"local a2=5;local a3=5;local a4=a2;local a5=a3;local a6=false;local a7,a8=0;local a9,aa=0;local ab=nil;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=3;local ai=0;local aj=""local ak=0;local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=j()>0;local ar=j()local as=core.getAltitude()local at=core.getElementIdList()local au=p()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=false;local az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]local aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local aB={}local aC=0;local aD=0;local aE=""local aF=true;local aG={}local aH=ResolutionX;local aI=ResolutionY;local aJ={}local aK={}local aL={}local aM=0;local aN=false;local aO={}local aP={}local aQ=d(1/apTickRate)*2;local aR={}local aS={}local aT={}local aU={}local aV=false;local aW=0;local aX=nil;local aY=nil;local aZ=nil;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=false;local b9=false;local ba=autoRollPreference;local bb=LandingGearGroundHeight;local bc=false;local bd=p()local be=0;local bf=0;local bg=0;local bh=AtmoSpeedLimit;local bi=0;local bj=nil;local bk=0;local bl=0;local bm=false;local bn=false;local bo={VectorToTarget=false}local bp=false;local bq=0;local br=nil;local bs=false;local bt=false;local bu=false;local bv=false;local bw=0;local bx=vec3(core.getConstructWorldOrientationUp())local by=vec3(core.getConstructWorldOrientationForward())local bz=vec3(core.getConstructWorldOrientationRight())local bA=vec3(core.getWorldVelocity())local bB=vec3(bA):len()local bC=vec3(core.getWorldVertical())local bD=-bC:dot(bA)local bE=vec3(core.getConstructWorldPos())local bF=0;local bG=false;local bH=false;local bI=nil;local bJ=true;local bK=0;local bL=0;local bM=false;local bN={}local bO=showHud;local bP={}local bQ=false;local bR=""local bS=""local bT=nil;local bU={}local bV=unit.getClosestPlanetInfluence()>0;local bW=false;local bX=nil;timeCount=0;totalTime=0;local function bY(bZ,b_,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bZ.."|"..b_.."|"..soundVolume)end end;local function c0(c1,c2)for i=1,#c2 do c1[#c1+1]=c2[i]end;return c1 end;local function c3(c4)local c5={}local c6={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local c7={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c8={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c9={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c4 then c0(c5,c6)c0(c5,c7)c0(c5,c8)c0(c5,c9)return c5 elseif c4=="boolean"then return c6 elseif c4=="handling"then return c7 elseif c4=="hud"then return c8 elseif c4=="physics"then return c9 end end;local function ca(cb,cc,cd,ce,cf)if ce==nil then ce=""end;if cf==nil then cf=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],ce,cb,cc,cf,cd)end;local function cg(ch,ci)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not ci then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,ch)J=q(z(ch*100,0)/100,-1,1)end;local function cj(ch,ci)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ci then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,ch)bI=ch end;local function ck(cl,cm)if cl==0 then return c(cm)<1e-09 end;if cm==0 then return c(cl)<1e-09 end;return c(cl-cm)<math.max(c(cl),c(cm))*epsilon end;local function cn(ai,co)local cp=ai>100000;if co==nil then co=1 end;if cp then return z(ai/1000/200,co).."SU"elseif ai<1000 then return z(ai,co).."M"else return z(ai/1000,co).."KM"end end;local function cq()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;ba=true;ae=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;ae=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cj(d(bh))end else bs=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cr()bs=false;bk=nil;bl=nil;bw=0;if ar==0 then if IntoOrbit then bY("orOff","AP")IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false elseif bV then bY("orOn","AP")IntoOrbit=true;ba=true;if br==nil then br=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a1="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bm=false;br=nil;ba=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bo.VectorToTarget=false;bo.AutopilotAlign=false;bp=false end end;local function cs()if C-bf<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;bY("11","EP")else if bV then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bq=HoldAltitude;bp=true;if not IntoOrbit then cr()end;bm=true end end;bf=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bf=C end;if bV and ar==0 then bq=as;bp=true;bm=true;cr()if IntoOrbit then bf=C else bf=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Z=false;ba=true;LockPitch=nil;bs=false;if ao==-1 then bY("altOn","AH")AutoTakeoff=false;if bf>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=as end end;if VertTakeOff then cq()end else bY("lfs","LS")AutoTakeoff=true;if bf>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bG then cq()end end;if am then HoldAltitude=100000 end else bY("altOff","AH")if IntoOrbit then cr()end;if VertTakeOff then cq()end;ba=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bf=0 end end;local function ct()local function cu(SpaceTarget)bW=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cs()end end;VectorStatus="Proceeding to Waypoint"end;if C-bg<1.5 and ar>0 then if not bv then a1="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bY("orH","OH")end;bg=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bg=C end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then b6.UpdateAutopilotTarget()b7.showWayPoint(ab,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bY("apSpc","AP")if ar~=0 then am=true;cs()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bY("vtt","AP")cu(SpaceTarget)end else bY("apOn","AP")if not(ab.name==planet.name and bV)then bs=false;Autopilot=true elseif not aq then if IntoOrbit then cr()end;bq=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bp=true;bo.AutopilotAlign=true;bo.VectorToTarget=true;bm=false;if not IntoOrbit then cr()end end end else bY("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cs()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ab.name==planet.name and bV)and not IntoOrbit then WaypointSet=false;bs=false;bm=false;cr()else bY("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Z=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;O=false;LockPitch=nil;WaypointSet=false end else bY("apP","AP")am=true;cs()end else bY("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;O=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cr()end end end;local function cv(cw)local cx=-1;local cy;cx=b6.findAtlasIndex(SavedLocations)if cx~=-1 then local cz;if cw~=nil then cy={position=SavedLocations[cx].position,name=cw,atmosphere=SavedLocations[cx].atmosphere,planetname=SavedLocations[cx].planetname,gravity=SavedLocations[cx].gravity}else cy={position=bE,name=SavedLocations[cx].name,atmosphere=ar,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cx]=cy;cx=-1;cx=b6.findAtlasIndex(aX[0])if cx>-1 then aX[0][cx]=cy end;b6.UpdateAtlasLocationsList()a1=CustomTarget.name.." position updated"b6.UpdateAutopilotTarget()else a1="Name Not Found"end end;local function cA()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;ba=autoRollPreference end;if BrakeIsOn then bY("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bT=nil;if not bH then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cq()end;if IntoOrbit then cr()end;ba=autoRollPreference;al=false;an=false;ae=0 else bY("bkOff","B",1)end end;local function cB(cC,cD,cE)local function cF(cC,cG)cC=vec3(cC)cG=vec3(cG):normalize()local cH=cC*cG;return cH.x+cH.y+cH.z end;local cI=0.001;local cJ=1;if not aq or not bc or ao~=-1 or bB<P then if cE==nil then cE=DampingMultiplier end;if cD==nil then cD=cI end;cC=vec3(cC):normalize()local cK=vec3()-cC;local cL=-cF(cK,core.getConstructWorldOrientationRight())*cJ;local cM=-cF(cK,core.getConstructWorldOrientationUp())*cJ;if aC==0 then aC=cL/2 end;if aD==0 then aD=cM/2 end;if c(cL)<0.1 then U=U-cL*2 else U=U-(cL+(cL-aC)*cE)end;if c(cM)<0.1 then T=T+cM*2 else T=T+cM+(cM-aD)*cE end;aC=cL;aD=cM;if c(cL)<cD and c(cM)<cD then return true end;return false elseif bc and ao==-1 then cC=bA;if cE==nil then cE=DampingMultiplier end;if cD==nil then cD=cI end;cC=vec3(cC):normalize()local cK=by-cC;local cL=-cF(cK,core.getConstructWorldOrientationRight())*cJ;local cM=-cF(cK,core.getConstructWorldOrientationUp())*cJ;if aC==0 then aC=cL/2 end;if aD==0 then aD=cM/2 end;if c(cL)<0.1 then U=U-cL*5 else U=U-(cL+(cL-aC)*cE)end;if c(cM)<0.1 then T=T+cM*5 else T=T+cM+(cM-aD)*cE end;aC=cL;aD=cM;if c(cL)<cD and c(cM)<cD then return true end;return false end end;local function cN()if Reentry then a1="Re-Entry cancelled"bY("reOff","RE")Reentry=false;ba=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ah=5 elseif not Q then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;ba=true;BrakeIsOn=false;a1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bh;bY("par","RE")else Reentry=true;AltitudeHold=true;ba=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cd=cn(HoldAltitude)a1="Beginning Re-entry.  Target speed: "..bh.." Target Altitude: "..cd;bY("glide","RE")cj(d(bh))end;AutoTakeoff=false end;local function cO()if antigrav and not ExternalAGG then if bH then bY("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bY("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cP(cQ)local cR=0;local cS=0;local cT=0;if cQ<60 then cQ=d(cQ)elseif cQ<3600 then cR=d(cQ/60)cQ=d(cQ%60)elseif cQ<86400 then cS=d(cQ/3600)cR=d(cQ%3600/60)else cT=d(cQ/86400)cS=d(cQ%86400/3600)end;if cT>0 then return cT.."d "..cS.."h "elseif cS>0 then return cS.."h "..cR.."m "elseif cR>0 then return cR.."m "..cQ.."s"elseif cQ>0 then return cQ.."s"else return"0s"end end;local function cU(cV)local function cW(cX)for cY,cZ in pairs(cX)do dbHud_1.setStringValue(cZ,g(_G[cZ]))if cV and dbHud_2 then dbHud_2.setStringValue(cZ,g(_G[cZ]))end end end;if dbHud_1 then cW(b)cW(c3())system.print("Saved Variables to Datacore")if cV and dbHud_2 then a1="Databank copied.  Remove copy when ready."end end end;local function c_()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function d0()local function d1(d2)return type(d2)=='number'end;local function d3(d2)return type(y(d2))=='number'end;local function d4(d5)return type(d5)=='table'end;local function d6(d7)return type(d7)=='string'end;local function d8(cZ)return d4(cZ)and d1(cZ.x and cZ.y and cZ.z)end;local function d9(da)return d4(da)and d1(da.latitude and da.longitude and da.altitude and da.bodyId and da.systemId)end;local db=math.pi/180;local dc=180/math.pi;local epsilon=1e-10;local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dd='::pos{'..num..','..num..','..num..','..num..','..num..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function de(d2)local cH=string.gsub(string.reverse(e('%.4f',d2)),'^0*%.?','')return cH==''and'0'or string.reverse(cH)end;local function df(dg)if d8(dg)then return e('{x=%.3f,y=%.3f,z=%.3f}',dg.x,dg.y,dg.z)end;if d4(dg)and not getmetatable(dg)then local dh={}local di=next(dg)if type(di)=='nil'or di==1 then dh=dg else for cY,cZ in pairs(dg)do local ch=df(cZ)if type(cY)=='number'then table.insert(dh,e('[%s]=%s',cY,ch))else table.insert(dh,e('%s=%s',cY,ch))end end end;return e('{%s}',table.concat(dh,','))end;if d6(dg)then return e("'%s'",dg:gsub("'",[[\']]))end;return tostring(dg)end;local dj={}dj.__index=dj;dj.__tostring=function(dg,dk)local dl={}for cY in pairs(dg)do table.insert(dl,cY)end;table.sort(dl)local dh={}for _,cY in ipairs(dl)do local ch=df(dg[cY])if type(cY)=='number'then table.insert(dh,e('[%s]=%s',cY,ch))else table.insert(dh,e('%s=%s',cY,ch))end end;if dk then return e('%s%s',dk,table.concat(dh,',\n'..dk))end;return e('{%s}',table.concat(dh,','))end;dj.__eq=function(dm,dn)return dm.planetarySystemId==dn.planetarySystemId and dm.bodyId==dn.bodyId and ck(dm.radius,dn.radius)and ck(dm.center.x,dn.center.x)and ck(dm.center.y,dn.center.y)and ck(dm.center.z,dn.center.z)and ck(dm.GM,dn.GM)end;local function dp(dq,dr,ds,dt,du)assert(d3(dq),'Argument 1 (planetarySystemId) must be a number:'..type(dq))assert(d3(dr),'Argument 2 (bodyId) must be a number:'..type(dr))assert(d3(ds),'Argument 3 (radius) must be a number:'..type(ds))assert(d4(dt),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dt))assert(d3(du),'Argument 5 (GM) must be a number:'..type(du))return setmetatable({planetarySystemId=y(dq),bodyId=y(dr),radius=y(ds),center=vec3(dt),GM=y(du)},dj)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dv)return e('::pos{%d,%d,%s,%s,%s}',dv.systemId,dv.bodyId,de(dv.latitude*dc),de(dv.longitude*dc),de(dv.altitude))end;MapPosition.__eq=function(dm,dn)return dm.bodyId==dn.bodyId and dm.systemId==dn.systemId and ck(dm.latitude,dn.latitude)and ck(dm.altitude,dn.altitude)and(ck(dm.longitude,dn.longitude)or ck(dm.latitude,math.pi/2)or ck(dm.latitude,-math.pi/2))end;local function dw(dx,dr,dy,dz,dA)local dq=dx;if d6(dx)and not dz and not dA and not dr and not dy then dq,dr,dy,dz,dA=n(dx,dd)assert(dq,'Argument 1 (position string) is malformed.')else assert(d3(dq),'Argument 1 (systemId) must be a number:'..type(dq))assert(d3(dr),'Argument 2 (bodyId) must be a number:'..type(dr))assert(d3(dy),'Argument 3 (latitude) must be in degrees:'..type(dy))assert(d3(dz),'Argument 4 (longitude) must be in degrees:'..type(dz))assert(d3(dA),'Argument 5 (altitude) must be in meters:'..type(dA))end;dq=y(dq)dr=y(dr)dy=y(dy)dz=y(dz)dA=y(dA)if dr==0 then return setmetatable({latitude=dy,longitude=dz,altitude=dA,bodyId=dr,systemId=dq},MapPosition)end;return setmetatable({latitude=db*q(dy,-90,90),longitude=db*(dz%360),altitude=dA,bodyId=dr,systemId=dq},MapPosition)end;local dB={}dB.__index=dB;dB.__tostring=function(dg,dk)local dC=dk and dk..'  'local dD={}local dl={}for cY in pairs(dg)do table.insert(dl,cY)end;table.sort(dl)for _,dE in ipairs(dl)do bdy=dg[dE]local dF=dj.__tostring(bdy,dC)if dk then table.insert(dD,e('[%s]={\n%s\n%s}',dE,dF,dk))else table.insert(dD,e('  [%s]=%s',dE,dF))end end;if dk then return e('\n%s%s%s',dk,table.concat(dD,',\n'..dk),dk)end;return e('{\n%s\n}',table.concat(dD,',\n'))end;local function dG(dH)local aX={}local pid;for _,cZ in pairs(dH)do local dI=cZ.planetarySystemId;if type(dI)~='number'then error('Invalid planetary system ID: '..tostring(dI))elseif pid and dI~=pid then error('Mistringmatch planetary system IDs: '..dI..' and '..pid)end;local dJ=cZ.bodyId;if type(dJ)~='number'then error('Invalid body ID: '..tostring(dJ))elseif aX[dJ]then error('Duplicate body ID: '..tostring(dJ))end;setmetatable(cZ.center,getmetatable(vec3.unit_x))aX[dJ]=setmetatable(cZ,dj)pid=dI end;return setmetatable(aX,dB)end;b0={}local function dK(dH)return setmetatable({galaxyAtlas=dH or{}},b0)end;b0.__index=function(d5,i)if type(i)=='number'then local system=d5.galaxyAtlas[i]return dG(system)end;return rawget(b0,i)end;b0.__pairs=function(dg)return function(d5,cY)local dL,nv=next(d5,cY)return dL,nv and dG(nv)end,dg.galaxyAtlas,nil end;b0.__tostring=function(dg)local dM={}for _,dN in pairs(dg or{})do local dO=dN:getPlanetarySystemId()local dP=dB.__tostring(dN,'    ')table.insert(dM,e('  [%s]={%s\n  }',dO,dP))end;return e('{\n%s\n}\n',table.concat(dM,',\n'))end;b0.BodyParameters=dp;b0.MapPosition=dw;b0.PlanetarySystem=dG;function b0.createBodyParameters(dQ,dr,dR,dS,dT,dU,dV)assert(d3(dQ),'Argument 1 (planetarySystemId) must be a number:'..type(dQ))assert(d3(dr),'Argument 2 (bodyId) must be a number:'..type(dr))assert(d3(dR),'Argument 3 (surfaceArea) must be a number:'..type(dR))assert(d4(dS),'Argument 4 (aPosition) must be an array or vec3:'..type(dS))assert(d4(dT),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dT))assert(d3(dU),'Argument 6 (altitude) must be in meters:'..type(dU))assert(d3(dV),'Argument 7 (gravityAtPosition) must be number:'..type(dV))local ds=x(dR/4/math.pi)local ai=ds+dU;local dW=vec3(dS)+ai*vec3(dT)local du=dV*ai*ai;return dp(dQ,dr,ds,dW,du)end;b0.isMapPosition=d9;function b0:getPlanetarySystem(dx)if i==nil then i=0 end;if nv==nil then nv=0 end;local dQ=dx;if d9(dx)then dQ=dx.systemId end;if type(dQ)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dB then system=dG(system)end;return system end end end;function dB:sizeCalculator(dX)return 1.05*dX.radius end;function dB:castIntersections(dY,cG,dZ,d_,e0,e1)local e2={}local e3=e0 or self;for _,dX in pairs(e3)do table.insert(e2,dX)end;if not e1 then table.sort(e2,function(e4,e5)return(e4.center-dY):len()<(e5.center-dY):len()end)end;local e6=cG:normalize()for _,dX in ipairs(e2)do local e7=dX.center-dY;local ds=self:sizeCalculator(dX)local e8=e7:dot(e6)local e9=e8^2-(e7:len2()-ds^2)if e9>=0 then local ea=x(e9)local eb=e8+ea;local ec=e8-ea;if ec>0 then return dX,eb,ec elseif eb>0 then return dX,eb,nil end end end;return nil,nil,nil end;function dB:closestBody(ed)assert(type(ed)=='table','Invalid coordinates.')local ee,dX;local ef=vec3(ed)for _,eg in pairs(self)do local eh=(eg.center-ef):len2()if(not dX or eh<ee)and eg.name~="Space"then dX=eg;ee=eh end end;return dX end;function dB:convertToBodyIdAndWorldCoordinates(dx)local ei=dx;if d6(dx)then ei=dw(dx)end;if ei.bodyId==0 then return 0,vec3(ei.latitude,ei.longitude,ei.altitude)end;local eg=self:getBodyParameters(ei)if eg then return ei.bodyId,eg:convertToWorldCoordinates(ei)end end;function dB:getBodyParameters(dx)local dr=dx;if d9(dx)then dr=dx.bodyId end;assert(d3(dr),'Argument 1 (bodyId) must be a number:'..type(dr))return self[dr]end;function dB:getPlanetarySystemId()local _,cZ=next(self)return cZ and cZ.planetarySystemId end;function dj:convertToMapPosition(dt)assert(d4(dt),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dt))local ej=vec3(dt)if self.bodyId==0 then return setmetatable({latitude=ej.x,longitude=ej.y,altitude=ej.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ek=ej-self.center;local ai=ek:len()local dA=ai-self.radius;local dy=0;local dz=0;if not ck(ai,0)then local el=m(ek.y,ek.x)dz=el>=0 and el or 2*math.pi+el;dy=math.pi/2-math.acos(ek.z/ai)end;return setmetatable({latitude=dy,longitude=dz,altitude=dA,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dj:convertToWorldCoordinates(dx)local ei=d6(dx)and dw(dx)or dx;if ei.bodyId==0 then return vec3(ei.latitude,ei.longitude,ei.altitude)end;assert(d9(ei),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ei.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ei.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local em=math.cos(ei.latitude)return self.center+(self.radius+ei.altitude)*vec3(em*math.cos(ei.longitude),em*math.sin(ei.longitude),math.sin(ei.latitude))end;function dj:getAltitude(dt)return(vec3(dt)-self.center):len()-self.radius end;function dj:getDistance(dt)return(vec3(dt)-self.center):len()end;function dj:getGravity(dt)local en=self.center-vec3(dt)local eo=en:len2()return self.GM/eo*en/x(eo)end;return setmetatable(b0,{__call=function(_,...)return dK(...)end})end;local function ep()local b2={}local eq=30000000/3600;local er=eq*eq;local es=100;local function et(cZ)return 1/x(1-cZ*cZ/er)end;function b2.computeAccelerationTime(eu,ev,ew)local ex=eq*math.asin(eu/eq)return(eq*math.asin(ew/eq)-ex)/ev end;function b2.computeDistanceAndTime(eu,ew,ey,ez,eA,eB)eA=eA or 0;eB=eB or 0;local eC=eu<=ew;local eD=ez*(eC and 1 or-1)/ey;local eE=-eB/ey;local eF=eD+eE;if eC and eF<=0 or not eC and eF>=0 then return-1,-1 end;local eG,eH=0,0;if eD~=0 and eA>0 then local ex=math.asin(eu/eq)local eI=math.pi*(eD/2+eE)local eJ=eD*eA;local eK=eq*math.pi;local cZ=function(d5)local eL=(eI*d5-eJ*math.sin(math.pi*d5/2/eA)+eK*ex)/eK;local eM=math.tan(eL)return eq*eM/x(eM*eM+1)end;local eN=eC and function(d7)return d7>=ew end or function(d7)return d7<=ew end;eH=2*eA;if eN(cZ(eH))then local eO=0;while c(eH-eO)>0.5 do local d5=(eH+eO)/2;if eN(cZ(d5))then eH=d5 else eO=d5 end end end;local eP=eu;local eQ=eH/es;for eR=1,es do local eS=cZ(eR*eQ)eG=eG+(eS+eP)*eQ/2;eP=eS end;if eH<2*eA then return eG,eH end;eu=eP end;local ex=eq*math.asin(eu/eq)local C=(eq*math.asin(ew/eq)-ex)/eF;local eT=er*math.cos(ex/eq)/eF;local ai=eT-er*math.cos((eF*C+ex)/eq)/eF;return ai+eG,C+eH end;function b2.computeTravelTime(eu,ev,ai)if ai==0 then return 0 end;if ev>0 then local ex=eq*math.asin(eu/eq)local eT=er*math.cos(ex/eq)/ev;return(eq*math.acos(ev*(eT-ai)/er)-ex)/ev end;if eu==0 then return-1 end;assert(eu>0,'Acceleration and initial speed are both zero.')return ai/eu end;function b2.lorentz(cZ)return et(cZ)end;return b2 end;local function eU()local vec3=require('cpml.vec3')local d0=d0()local function d6(d7)return type(d7)=='string'end;local function d4(d5)return type(d5)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dA)assert(self.body)local ai=dA+self.body.radius;if not ck(ai,0)then local orbit=x(self.body.GM/ai)return x(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dx,eV)assert(self.body)assert(d4(dx)or d6(dx))assert(d4(eV))local eW=(d6(dx)or d0.isMapPosition(dx))and self.body:convertToWorldCoordinates(dx)or vec3(dx)local cZ=vec3(eV)local eX=eW-self.body.center;local eY=cZ:len2()local eZ=eX:len()local e_=self.body.GM;local f0=((eY-e_/eZ)*eX-eX:dot(cZ)*cZ)/e_;local cl=e_/(2*e_/eZ-eY)local f1=f0:len()local e6=f0:normalize()local f2=cl*(1-f1)local f3=cl*(1+f1)local f4=f2*e6+self.body.center;local f5=f1<=1 and-f3*e6+self.body.center or nil;local f6=x(cl*e_*(1-f1*f1))local f7=f5 and 2*math.pi*x(cl^3/e_)local f8=math.acos(f0:dot(eX)/(f1*eZ))if eX:dot(cZ)<0 then f8=-(f8-2*math.pi)end;local f9=math.acos((math.cos(f8)+f1)/(1+f1*math.cos(f8)))local fa=f9;if fa<0 then fa=fa+2*math.pi end;local fb=fa-f1*math.sin(fa)local fc=0;local fd=0;local fe=0;if f7~=nil then fc=fb/(2*math.pi/f7)fd=f7-fc;fe=fd+f7/2;if f8-math.pi>0 then fd=fc;fe=fd+f7/2 end;if fe>f7 then fe=fe-f7 end end;return{periapsis={position=f4,speed=f6/f2,circularOrbitSpeed=x(e_/f2),altitude=f2-self.body.radius},apoapsis=f5 and{position=f5,speed=f6/f3,circularOrbitSpeed=x(e_/f3),altitude=f3-self.body.radius},currentVelocity=cZ,currentPosition=eW,eccentricity=f1,period=f7,eccentricAnomaly=f9,meanAnomaly=fb,timeToPeriapsis=fd,timeToApoapsis=fe}end;local function ff(fg)local eg=d0.BodyParameters(fg.planetarySystemId,fg.bodyId,fg.radius,fg.center,fg.GM)return setmetatable({body=eg},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return ff(...)end})end;local function fh()local fi=0;local function fj(fk)local ds=500000;local fl,fm,fn=math.huge;local fo=false;local fp=vec3({13771471,7435803,-128971})local fq=18000000;fl=vec3(fk):dist(fp)if fl<fq then return true,c(fl-fq),"Safe Zone",0 end;fm=vec3(fk):dist(vec3(planet.center))if fm<ds then fo=true end;if c(fm-ds)<c(fl-fq)then return fo,c(fm-ds),planet.name,planet.bodyId else return fo,c(fl-fq),"Safe Zone",0 end end;local function fr(cZ)if aH==1920 then return cZ else return z(aH*cZ/1920,0)end end;local function fs(cZ)if aI==1080 then return cZ else return z(aI*cZ/1080,0)end end;local function ft()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fu()local fv="TRAVEL"if not bJ then fv="CRUISE"end;if Autopilot then fv="AUTOPILOT"end;return fv end;local function fw(fx,aV,cb,fy,fz,fA,fB,fC)local fD=1;local fE=2;local fF=3;local fG=4;local fH=5;local fI=6;local fJ=""local fK=0;local fL=fuelY;local fM=fuelY+5;if not BarFuelDisplay then fM=fM+5 end;if l()==1 and not RemoteHud then fL=fL-50;fM=fM-50 end;if fz=="ATMO"then fJ="atmofueltank"elseif fz=="SPACE"then fJ="spacefueltank"else fJ="rocketfueltank"end;fK=_G[fJ.."_size"]if#fA>0 then for i=1,#fA do local fN=string.sub(fA[i][fE],1,12)local fO=0;for fP=1,fK do if fA[i][fE]==f(unit[fJ.."_"..fP].getData()).name then fO=fP;break end end;if aV or fB[i]==nil or fC[i]==nil then local fQ=0;local fR=0;local fS=0;local fT=0;local fU=p()if fO~=0 then fC[i]=f(unit[fJ.."_"..fO].getData()).percentage;fB[i]=f(unit[fJ.."_"..fO].getData()).timeLeft;if fB[i]=="n/a"then fB[i]=0 end else fS=k(fA[i][fD])-fA[i][fG]fQ=fA[i][fF]fC[i]=d(0.5+fS*100/fQ)fR=fA[i][fH]fT=fA[i][fI]if fR<=fS then fB[i]=0 else fB[i]=d(0.5+fS/((fR-fS)/(fU-fT)))end;fA[i][fH]=fS;fA[i][fI]=fU end end;if fN==fy then fN=e("%s %d",fz,i)end;if fO==0 then fN=fN.." *"end;local fV;if fB[i]==0 then fV=""else fV=cP(fB[i])end;if fC[i]~=nil then local fW=d(fC[i]*2.55)local fX=e("rgb(%d,%d,%d)",255-fW,fW,0)local ce=""if fV~=""and fB[i]<120 or fC[i]<5 then if aV then ce=[[class="red"]]end end;if BarFuelDisplay then table.insert(fx,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cb,fM,fX,fC[i],cb,fM,cb+2,fM+10,fC[i],fV))fx[#fx+1]=ca(cb,fL,fN,ce.."txtstart pdim txtfuel")fL=fL-30;fM=fM-30 else fx[#fx+1]=ca(cb,fL,fN,ce.." pdim txtfuel")fx[#fx+1]=ca(cb,fM,e("%d%% %s",fC[i],fV),"pdim txtfuel","fill:"..fX)fL=fL+30;fM=fM+30 end end end end end;local function fY(fx,dA)if dA<200000 and not aq or dA and aq then local fZ=0;if c(bD)>1 then fZ=45*math.log(c(bD),10)if bD<0 then fZ=-fZ end end;fx[#fx+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bD),d(fZ))end;return fx end;local function f_(g0)local g1=-bC;g0=g0-g0:project_on(g1)local g2=vec3(0,0,1)g2=g2-g2:project_on(g1)local g3=g2:cross(g1)local fZ=g2:angle_between(g0)*constants.rad2deg;if g0:dot(g3)<0 then fZ=360-fZ end;return fZ end;local function g4(fx,centerX,centerY,g5,g6,bV)local g7=circleRad;local g8=20;local g9=d(g5)if bV then for i=-45,45,5 do local ga=i;fx[#fx+1]=e([[<g transform="rotate(%f,%d,%d)">]],ga,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fx[#fx+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+g7+g8-len,centerX,centerY+g7+g8)end;fx[#fx+1]=ca(centerX,centerY+g7+g8-35,g6,"pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY+g7+g8-25,g9 .." deg","pdim txt txtmid")fx[#fx+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g5,centerX,centerY)fx[#fx+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+g7+g8-20,centerX+5,centerY+g7+g8-20,centerX,centerY+g7+g8-15)fx[#fx+1]="</g>"end;local gb=g9;if bV then gb=f_(by)end;local gc=20;local gd=d(gb)local ge=0;local gf=centerY+g7+g8+20;local gg=centerX;if g6~="YAW"then gf=fs(130)gg=fr(960)end;local gh=[[<path class="txttick line" d="]]local gi=d(gd-(gc+10)-gd%5+0.5)for i=gi+60,gi,-5 do local cb=gg-(-i*5+gb*5)if i%10==0 then ge=10;local num=i;if num==360 then num=0 elseif num>360 then num=num-360 elseif num<0 then num=num+360 end;fx[#fx+1]=ca(cb+5,gf-12,num)elseif i%5==0 then ge=5 end;if ge==10 then gh=e([[%s M %f %f v %d]],gh,cb,gf-5,ge)else gh=e([[%s M %f %f v %d]],gh,cb,gf-2.5,ge)end end;fx[#fx+1]=gh..[["/>]]fx[#fx+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gg-5,gf+10,gg+5,gf+10,gg,gf+5)if bV then g6="HDG"end;fx[#fx+1]=ca(gg,gf+25,gd.."deg","pdim txt txtmid","")fx[#fx+1]=ca(gg,gf+35,g6,"pdim txt txtmid","")end;local function gj(fx,gk,g5,centerX,centerY,bV,gl,eS)local g7=circleRad;local gm=d(g7*3/5)if g7>0 then local gn=d(gk)local len=0;local gh=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*g5,centerX,centerY)if not aq then gh=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fx[#fx+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],g7-1,centerX,centerY)fx[#fx+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gn-30-gn%5+0.5),d(gn+30+gn%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cc=centerY+-i*5+gk*5;if len==30 then gh=e([[%s M %d %f h %d]],gh,centerX-gm-len,cc,len)if aq then fx[#fx+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g5,centerX,centerY,centerX-gm+10,cc,i)fx[#fx+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g5,centerX,centerY,centerX+gm-10,cc,i)if i==0 or i==180 or i==-180 then fx[#fx+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g5,centerX,centerY,centerX-gm+20,cc,gm*2-40)end else fx[#fx+1]=ca(centerX-gm+10,cc,i,"pdim txt txtmid")fx[#fx+1]=ca(centerX+gm-10,cc,i,"pdim txt txtmid")end;gh=e([[%s M %d %f h %d]],gh,centerX+gm,cc,len)else gh=e([[%s M %d %f h %d]],gh,centerX-gm-len,cc,len)gh=e([[%s M %d %f h %d]],gh,centerX+gm,cc,len)end end;fx[#fx+1]=gh..[["/>]]local go="PITCH"if not bV then go="REL PITCH"end;if gk>90 and not aq then gk=90-(gk-90)elseif gk<-90 and not aq then gk=-90-(gk+90)end;if g7>200 then if aq then if eS>P then fx[#fx+1]=ca(centerX,centerY-15,"Yaw","pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY+20,gl,"pdim txt txtmid")end;fx[#fx+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g5,centerX,centerY)else fx[#fx+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fx[#fx+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gm+25,centerY-5,centerX-gm+20,centerY,centerX-gm+25,centerY+5,centerX-gm+50,centerY+4,gn)fx[#fx+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gm-25,centerY-5,centerX+gm-20,centerY,centerX+gm-25,centerY+5,centerX+gm-30,centerY+4,gn)fx[#fx+1]="</g>"end;local gp=d(g7/3)fx[#fx+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gp,centerY,g7-gp)if not aq and bV then fx[#fx+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g5,centerX,centerY,centerX-gm+10,centerY,gm*2-20)end;fx[#fx+1]="</g>"if g7<200 then if aq and eS>P then fx[#fx+1]=ca(centerX,centerY-g7,go,"pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY-g7+10,gn,"pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY-15,"Yaw","pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY+20,gl,"pdim txt txtmid")else fx[#fx+1]=ca(centerX,centerY-g7,go,"pdim txt txtmid")fx[#fx+1]=ca(centerX,centerY-g7+15,gn,"pdim txt txtmid")end end end end;local function gq(fx,dA,bV)local gr=altMeterX;local gs=altMeterY;local gt=78;local gu=19;local gv=ao;if ao~=-1 then fx[#fx+1]=ca(gr+gt,gs+gu+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if bV and(dA<200000 and not aq or dA and aq)then table.insert(fx,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gr-1,gs-4,gt+2,gu+6,gr+1,gs-1,gt-4,gu))local cx=0;local gw=1;local gx=0;local gy=dA<0;local gz=dA<planet.surfaceMaxAltitude;local gA=9;if gy then gA=0 end;local dA=c(dA)while cx<6 do local gB=11;local gC=16;local gD=9;local gE=14;local ce="altsm"if cx>2 then gC=gC+3;gB=gB+2;gE=gE+2;gD=gD-6;ce="altbig"end;if gy then ce=ce.." red"elseif gz then ce=ce.." orange"end;local gF=dA/gw%10;local gG=d(gF)local gH=d((gG+1)%10)local gI=gx;if cx==0 then gI=gF-gG;if gy then gI=1-gI end end;if gy and(cx==0 or gx~=0)then local gJ=gH;gH=gG;gG=gJ end;local gK=gC*(gI-1)local gL=gK+gC;local cb=gr+gD+(6-cx)*gB;local cc=gs+gE;fx[#fx+1]=ca(cb,cc+gK,gH,ce)fx[#fx+1]=ca(cb,cc+gL,gG,ce)cx=cx+1;gw=gw*10;if gG==gA then gx=gI else gx=0 end end;table.insert(fx,[[</g></g>]])end end;local function gM(eV)eV=vec3(eV)local gN=-math.deg(m(eV.y,eV.z))+180;gN=gN-90;if gN<0 then gN=360+gN end;if gN>180 then gN=-180+gN-180 end;return-gN end;local function gO(eV)eV=vec3(eV)local gb=math.deg(m(eV.y,eV.x))-90;if gb<-180 then gb=360+gb end;return gb end;local function gP(fx,eV,eS,centerX,centerY)if eS>5 and not aq or eS>P then local g7=circleRad;local gQ=20;local gR=20;local gS=vec3(eV)local gT=gM(gS)local gU=gO(gS)local gV=14;local gW=gV/2;local gX=-gU/gR*g7;local gY=gT/gQ*g7;local cb=centerX+gX;local cc=centerY+gY;local ai=x(gX^2+gY^2)local gZ=[[<circle
                            cx="]]..cb..[["
                            cy="]]..cc..[["
                            r="]]..gW/gV..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cb..[["
                            cy="]]..cc..[["
                            r="]]..gW..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cb-gV..[[,]]..cc..[[ h ]]..gW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cb+gW..[[,]]..cc..[[ h ]]..gW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cb..[[,]]..cc-gV..[[ v ]]..gW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ai<g7 then fx[#fx+1]=gZ else local fZ=m(gY,gX)local g_=4;local h0=centerX+g7*math.cos(fZ)local h1=centerY+g7*math.sin(fZ)fx[#fx+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',fZ*180/math.pi,h0,h1,h0-g_,h1-g_/2,g_*2,g_,h0+g_,h1-g_,g_,g_,-g_,g_)end;if not aq then gT=gM(-gS)gU=gO(-gS)gX=-gU/gR*g7;gY=gT/gQ*g7;cb=centerX+gX;cc=centerY+gY;ai=x(gX^2+gY^2)if ai<g7 then local h2=[[<circle
                                    cx="]]..cb..[["
                                    cy="]]..cc..[["
                                    r="]]..gW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cb..[[,]]..cc-gV..[[ v ]]..gW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cb..[[,]]..cc..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cb..[[,]]..cc..[[)" />
                                <path
                                    d="M ]]..cb-gW..[[,]]..cc..[[ h ]]..gV..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cb..[[,]]..cc..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cb..[[,]]..cc..[[)"/>]]fx[#fx+1]=h2 end end end end;local function h3(fx,fv,h4,h5)h4=d(h4+0.5)local fL=throtPosY+10;local fM=throtPosY+20;if l()==1 and not RemoteHud then fL=55;fM=65 end;local h6="CRUISE"local unit="km/h"local ch=h5;if fv=="TRAVEL"or fv=="AUTOPILOT"then h6="THROT"unit="%"ch=h4;local h7="dim"if h4<0 then h7="red"end;fx[#fx+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],h7,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fx[#fx+1]=ca(throtPosX+10,fL,h6,"pbright txtstart")fx[#fx+1]=ca(throtPosX+10,fM,e("%.0f %s",ch,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bJ and L then h4=d(M*100+0.5)local h7="red"if h4<0 then h7="red"end;fx[#fx+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],h7,1-c(h4),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fx[#fx+1]=ca(throtPosX+10,fL+40,"LIMIT","pbright txtstart")fx[#fx+1]=ca(throtPosX+10,fM+40,h4 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then fx[#fx+1]=ca(throtPosX+10,fL-40,"LIMIT: "..bh.." km/h","dim txtstart")elseif not aq and Autopilot then fx[#fx+1]=ca(throtPosX+10,fL-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function h8(fx,h9)local ha=throtPosY-10;local hb=throtPosX+10;fx[#fx+1]=ca(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then ha=75 end;fx[#fx+1]=ca(hb,ha,d(h9).." km/h","pbright txtbig txtstart")end;local function hc(fx)fx[#fx+1]=ca(fr(1900),fs(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fx[#fx+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fx[#fx+1]=ca(fr(960),fs(550),"Warning: Invalid Control Scheme Detected","warnings")fx[#fx+1]=ca(fr(960),fs(600),"Keyboard Scheme must be selected","warnings")fx[#fx+1]=ca(fr(960),fs(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hd=fr(960)local he=fs(860)local hf=fs(880)local hg=fs(900)local hh=fs(960)local hi=fs(200)local hj=fs(250)local hk=fs(960)if l()==1 and not RemoteHud then he=fs(135)hf=fs(155)hg=fs(175)hi=fs(115)hj=fs(95)end;if BrakeIsOn then fx[#fx+1]=ca(hd,he,"Brake Engaged","warnings")elseif K>0 then fx[#fx+1]=ca(hd,he,"Auto-Brake Engaged","warnings","opacity:"..K)end;if aq and bc and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bH and not VertTakeOff and not AutoTakeoff then fx[#fx+1]=ca(hd,hi+50,"** STALL WARNING **","warnings")bY("stall","SW",2)end end;if bT then fx[#fx+1]=ca(hd,hi+90,"Flight Assist in Progress","warnings")end;if ax then fx[#fx+1]=ca(hd,hk,"Gyro Enabled","warnings")end;if GearExtended then if R then fx[#fx+1]=ca(hd,hf,"Gear Extended","warn")else fx[#fx+1]=ca(hd,hf,"Landed (G: Takeoff)","warnings")end;local hl=cn(a:getTargetGroundAltitude())fx[#fx+1]=ca(hd,hg,"Hover Height: "..hl,"warn")end;if a6 then fx[#fx+1]=ca(hd,hh+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bH and AntigravTargetAltitude~=nil then if c(as-antigrav.getBaseAltitude())<501 then fx[#fx+1]=ca(hd,hi+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fx[#fx+1]=ca(hd,hi+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fx[#fx+1]=ca(hd,hi+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fx[#fx+1]=ca(hd,hi+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Z then fx[#fx+1]=ca(hd,hi+20,"Follow Mode Engaged","warn")elseif Reentry then fx[#fx+1]=ca(hd,hi+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local hl=cn(HoldAltitude,2)if VertTakeOff then if bH then hl=cn(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fx[#fx+1]=ca(hd,hi,"VTO to "..hl,"warn")elseif AutoTakeoff and not IntoOrbit then if am then fx[#fx+1]=ca(hd,hi,"Takeoff to "..AutopilotTargetName,"warn")else fx[#fx+1]=ca(hd,hi,"Takeoff to "..hl,"warn")end;if BrakeIsOn and not VertTakeOff then fx[#fx+1]=ca(hd,hi+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fx[#fx+1]=ca(hd,hi,"Altitude Hold: "..hl,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then fx[#fx+1]=ca(hd,hi+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then fx[#fx+1]=ca(hd,hi+20,"Aligning trajectory","warn")elseif ar<0.05 then fx[#fx+1]=ca(hd,hi+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bj~=nil then fx[#fx+1]=ca(hd,hi,bj,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fx[#fx+1]=ca(hd,hi+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bF.."kg DETECTED","warnings")bY("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then fx[#fx+1]=ca(hd,hi,"Brake-Landing","warnings")else fx[#fx+1]=ca(hd,hi,"Coast-Landing","warnings")end end;if ProgradeIsOn then fx[#fx+1]=ca(hd,hi,"Prograde Alignment","crit")end;if RetrogradeIsOn then fx[#fx+1]=ca(hd,hi,"Retrograde Alignment","crit")end;if bW then local type;if string.find(bW,"COLLISION")then type="warnings"else type="crit"end;fx[#fx+1]=ca(hd,hj+20,bW,type)elseif ar==0 then local hm,eb,ec=b1:getPlanetarySystem(0):castIntersections(bE,bA:normalize(),function(dX)if dX.noAtmosphericDensityAltitude>0 then return dX.radius+dX.noAtmosphericDensityAltitude else return dX.radius+dX.surfaceMaxAltitude*1.5 end end)local hn=eb;if ec~=nil and eb~=nil then hn=math.min(ec,eb)end;if hn~=nil then local hl=cn(hn)local travelTime=b2.computeTravelTime(bB,0,hn)local ho="Collision"if hm.noAtmosphericDensityAltitude>0 then ho="Atmosphere"end;fx[#fx+1]=ca(hd,hj+20,hm.name.." "..ho.." "..cP(travelTime).." In "..hl,"crit")end end;if VectorToTarget and not IntoOrbit then fx[#fx+1]=ca(hd,hi+35,VectorStatus,"warn")end;fx[#fx+1]="</g>"return fx end;local function hp(eS)return d(z(eS*3.6,0)+0.5).." km/h"end;local function hq(fx)local hr=OrbitMapX;local hs=OrbitMapY;local ht=OrbitMapSize;local hu=4;local hv=15;local cb=0;local cc=0;local hw,hx,hy,hz;local function hA(type)local hB,C,eS,hC;if type=="Periapsis"then hB=orbit.periapsis.altitude;C=orbit.timeToPeriapsis;eS=orbit.periapsis.speed;hC=35 else hB=orbit.apoapsis.altitude;C=orbit.timeToApoapsis;eS=orbit.apoapsis.speed;hC=-35 end;fx[#fx+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cb+hC,cc-5,hr+ht/2-hw+hz,cc-5)fx[#fx+1]=ca(cb,cc,type)cc=cc+hv;local hl=cn(hB)fx[#fx+1]=ca(cb,cc,hl)cc=cc+hv;fx[#fx+1]=ca(cb,cc,cP(C))cc=cc+hv;fx[#fx+1]=ca(cb,cc,hp(eS))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hs=hs+hu;cb=hr+ht+hr/2+hu;cc=hs+ht/2+5+hu;hw=ht/4;hz=0;fx[#fx+1]=[[<g class="pbright txtorb txtmid">]]fx[#fx+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ht+hr*2,ht+hs,hu,hu)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hy=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hw*2)hx=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hy*(1-orbit.eccentricity)hz=hw-orbit.periapsis.altitude/hy-planet.radius/hy;local hD=""if orbit.periapsis.altitude<=0 then hD='redout'end;fx[#fx+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hD,hr+ht/2+hz+hu,hs+ht/2+hu,hw,hx)fx[#fx+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hr+ht/2+hu,hs+ht/2+hu,planet.radius/hy)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hA("Apoapsis")end;cc=hs+ht/2+5+hu;cb=hr-hr/2+10+hu;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hA("Periapsis")end;fx[#fx+1]=ca(hr+ht/2+hu,planet.name,20+hu,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hE=orbit.timeToApoapsis/orbit.period*2*math.pi;local hF=hw*math.cos(hE)local hG=hx*math.sin(hE)fx[#fx+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hr+ht/2+hF+hz+hu,hs+ht/2+hG+hu)end;fx[#fx+1]=[[</g>]]return fx else return fx end end;local hH;local function hI()if radarPanelID~=nil and ak==0 then s(radarPanelID)radarPanelID=nil;if hH~=nil then s(hH)hH=nil end else if ak==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")hH=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ak=0 end end;local function hJ(fx)local cb=30;local cc=275;local hK={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hL={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local hM={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local hN={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if aq then c0(hK,hL)table.insert(hK,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(hK,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bH then table.insert(hK,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hK,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hK,"Alt-6: Begins Vertical Takeoff.")else table.insert(hK,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hK,"G: Begin BrakeLanding or Land")end else c0(hK,hM)end;if AltitudeHold then table.insert(hK,"Alt-Spacebar/Alt-C will raise/lower target height")end;c0(hK,hN)for i=1,#hK do cc=cc+12;fx[#fx+1]=ca(cb,cc,hK[i],"pdim txttick txtstart")end end;local function hO(hP,hQ)local hR;local hS=(hQ-hP):normalize()local eX=(bE-hP):dot(hS)/hS:dot(hS)if eX<=0.then return(bE-hP):len()elseif eX>=(hQ-hP):len()then return(bE-hQ):len()end;local hT=hP+eX*hS;hR=(hT-bE):len()return hR end;local function hU()local hR;local hV=nil;local hW=nil;local hX=nil;for cY,hY in pairs(aX[0])do if hY.hasAtmosphere then local ai=hO(planet.center,hY.center)if hV==nil or ai<hV then hW=hY;hV=ai;hX=planet end;if ab and ab.hasAtmosphere and ab.name~=planet.name then local eh=hO(ab.center,hY.center)if eh<hV then hW=hY;hV=eh;hX=ab end end end end;local hZ=fr(1770)local h_=fs(330)if hV then local i0="txttick "local i1=500000;if hV<hW.radius+i1 or hV<hX.radius+i1 then if bQ then i0="txttick red "else i0="txttick orange "end end;hR=cn(hV,2)bS=ca(hZ,h_,"Pipe ("..hX.name.."--"..hW.name.."): "..hR,i0 .."pbright txtmid")end end;local i2={}function i2.HUDPrologue(fx)bQ,fi,_,_=fj(bE)if not bQ then G=PvPR;I=PvPG;H=PvPB else G=SafeR;I=SafeG;H=SafeB end;az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]local i3=az;local i4=aA;local i5=az;local i6=aA;if ft()and not brightHud then i3=[[rgb(]]..d(G*0.4+0.5)..","..d(I*0.4+0.5)..","..d(H*0.3+0.5)..[[)]]i4=[[rgb(]]..d(G*0.3+0.5)..","..d(I*0.3+0.5)..","..d(H*0.2+0.5)..[[)]]end;fx[#fx+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],i3,i3,i5,i5,i4,i4,i6,i6,aH,aI)return fx end;function i2.DrawVerticalSpeed(fx,dA)fY(fx,dA)end;function i2.UpdateHud(fx)local dA=as;local eV=core.getVelocity()local eS=vec3(eV):len()local gN=bK;local i7=bL;local g5=i7;local gk=bK;local h4=d(unit.getThrottle())local h9=eS*3.6;local h5=unit.getAxisCommandValue(0)local i8=fr(1770)local i9=fs(310)if AtmoSpeedAssist and bJ then h5=J;h4=J*100 end;local fv=fu()local g6="ROLL"if h4==nil then h4=0 end;if not bV then if eS>5 then gN=gM(eV)i7=gO(eV)else gN=0;i7=0 end;g6="YAW"end;if fi>50000 and not aq then local ia;if fi>200000 then ia=z(fi/200000,2).." su"else ia=z(fi/1000,1).." km"end;fx[#fx+1]=ca(i8,i9,"PvP Boundary: "..ia,"pbright txtbig txtmid")end;fx[#fx+1]=aj;fx[#fx+1]=aE;fx[#fx+1]=bR;if bS~=""then fx[#fx+1]=bS end;if aW%aQ==0 then aV=true end;if fuelX~=0 and fuelY~=0 then fw(fx,aV,fuelX,"Atmospheric ","ATMO",aJ,aT,aU)fw(fx,aV,fuelX+120,"Space fuel t","SPACE",aK,aR,aS)fw(fx,aV,fuelX+240,"Rocket fuel ","ROCKET",aL,aO,aP)end;if aV then aV=false;aW=0 end;aW=aW+1;fY(fx,dA)if l()==0 or RemoteHud then if not ft()or brightHud then if bV then g4(fx,centerX,centerY,g5,g6,bV)gj(fx,gk,g5,centerX,centerY,bV,d(gO(eV)),eS)else g4(fx,centerX,centerY,i7,g6,bV)gj(fx,gN,i7,centerX,centerY,bV,d(i7),eS)end;gq(fx,dA,bV)gP(fx,eV,eS,centerX,centerY)end end;h3(fx,fv,h4,h5)h8(fx,h9)hc(fx)hq(fx)if showHelp then hJ(fx)end;return fx end;function i2.HUDEpilogue(fx)fx[#fx+1]="</svg>"return fx end;function i2.ExtraData(fx)local ib=fr(1240)local ic=fs(55)local id=ic+10;local ie;local ig=0;local fv=fu()if VertTakeOffEngine then fv=fv.."-VERTICAL"end;if TurnBurn then fv="TB-"..fv end;if not stablized then fv=fv.."-DeCoupled"end;local ih=vec3(core.getWorldAcceleration()):len()/9.80665;ie=core.g()fx[#fx+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then ib=fr(1120)ic=fs(55)id=ic+10 elseif aq then local ii=fr(770)fx[#fx+1]=ca(ii,ic,"ATMOSPHERE","pdim txt txtend")fx[#fx+1]=ca(ii,id,e("%.2f",ar),"pdim txt txtend","")end;fx[#fx+1]=ca(ib,ic,"GRAVITY","pdim txt txtend")fx[#fx+1]=ca(ib,id,e("%.2f",ie/9.80665),"pdim txt txtend")fx[#fx+1]=ca(ib,ic+20,"ACCEL","pdim txt txtend")fx[#fx+1]=ca(ib,id+20,e("%.2f",ih),"pdim txt txtend")fx[#fx+1]=ca(fr(960),fs(180),fv,"txtbig txtmid")end;function i2.DrawOdometer(fx,ac,TotalDistanceTravelled,ad)local ie;local ij=0;local ik=0;local ig=0;if aq then ig=LastMaxBrakeInAtmo else ig=LastMaxBrake end;maxThrust=a:maxForceForward()ie=core.g()if ie>0.1 then ik=av*ie;ij=maxThrust/ie end;fx[#fx+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fr(660),fr(700),fs(35),fr(960),fs(55),fr(1240),fs(35),fr(1280))if l()==0 or RemoteHud then fx[#fx+1]=ca(fr(700),fs(20),e("Trip: %.2f km",ac),"txtstart")fx[#fx+1]=ca(fr(700),fs(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fx[#fx+1]=ca(fr(830),fs(20),"Trip Time: "..cP(ad),"txtstart")fx[#fx+1]=ca(fr(830),fs(30),"Total Time: "..cP(TotalFlightTime),"txtstart")fx[#fx+1]=ca(fr(970),fs(20),e("Mass: %.2f Tons",av/1000),"txtstart")fx[#fx+1]=ca(fr(1240),fs(10),e("Max Brake: %.2f kN",ig/1000),"txtend")fx[#fx+1]=ca(fr(1240),fs(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if ie>0.1 then fx[#fx+1]=ca(fr(970),fs(30),e("Max Mass: %.2f Tons",ij/1000),"txtstart")fx[#fx+1]=ca(fr(1240),fs(20),e("Req Thrust: %.2f kN",ik/1000),"txtend")else fx[#fx+1]=ca(fr(970),fs(30),"Max Mass: n/a","txtstart")fx[#fx+1]=ca(fr(1240),fs(20),"Req Thrust: n/a","txtend")end end;fx[#fx+1]="</g>"return fx end;function i2.DrawWarnings(fx)return hc(fx)end;function i2.DisplayOrbitScreen(fx)return hq(fx)end;function i2.DisplayMessage(fx,hl)if hl~="empty"then local cc=310;for il in string.gmatch(hl,"([^\n]+)")do cc=cc+35;fx[#fx+1]=ca("50%",cc,il,"msg")end end;if ah~=0 then unit.setTimer("msgTick",ah)ah=0 end end;function i2.DrawDeadZone(fx)fx[#fx+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function i2.UpdatePipe()if aq then bS=""return end;hU()end;function i2.UpdateRadarRoutine()local function im(io,ip,iq,ir,is,it,iu,iv)ip,ir,it,iv=vec3(ip),vec3(ir),vec3(it),vec3(iv)local iw,ix,iy=io*io,iq*iq,is*is;local eY=ir-ip;local iz=eY:normalize()local iA=eY:len()local iB=it-ip;local iC=(iB-iB:project_on(iz)):normalize()local iD,iE=iB:dot(iz),iB:dot(iC)local iF=iD*iD+iE*iE;local iG=iz:cross(iC)local cb=(iw-ix+iA*iA)/(2*iA)local cc=(iw-iy+iF-2*iD*cb)/(2*iE)local da=iw-cb^2-cc^2;local iH=x(da)local iI=ip+iz*cb+iC*cc+iG*iH;local iJ=ip+iz*cb+iC*cc-iG*iH;if c((iv-iI):len()-iu)<c((iv-iJ):len()-iu)then return iI else return iJ end end;local function iK()local function iL()local iM=core.getConstructWorldOrientationRight()local eY=core.getConstructWorldOrientationForward()local iB=core.getConstructWorldOrientationUp()local iN=library.systemResolution3(iM,eY,iB,{1,0,0})local iO=library.systemResolution3(iM,eY,iB,{0,1,0})local iP=library.systemResolution3(iM,eY,iB,{0,0,1})return function(iQ)return library.systemResolution3(iN,iO,iP,iQ)end end;local iR=iL()local iS=core.getConstructWorldPos()local eW=core.getElementPositionById(1)local iT={eW[1]-E,eW[2]-E,eW[3]-E}local iU=iR(iT)local iV={iS[1]-iU[1],iS[2]-iU[2],iS[3]-iU[3]}return iV end;local function iW(iX,eZ,iY)local iZ=iX.pts;local cx=#iZ;local i_=iX.ref;if cx>3 then local j0,j1,j2,j3=iZ[cx],iZ[cx-1],iZ[cx-2],iZ[cx-3]iX.ref=iY;local eW=im(j0[1],j0[2],j1[1],j1[2],j2[1],j2[2],j3[1],j3[2])local cb,cc,iH=eW.x,eW.y,eW.z;if cb==cb and cc==cc and iH==iH then cb=cb+i_[1]cc=cc+i_[2]iH=iH+i_[3]local j4=vec3(cb,cc,iH)if not iX.lastPos then iX.center=j4 elseif(iX.lastPos-j4):len()<2 then iX.center=j4;iX.skipCalc=true end;iX.lastPos=j4 end;iX.pts={}else local j5={iY[1]-i_[1],iY[2]-i_[2],iY[3]-i_[3]}iZ[cx+1]={eZ,j5}end end;if radar_1 then local j6=#radar_1.getEntries()local j7={}local j8=radar_1.getData()local j9=j8:gmatch('{"constructId[^}]*}[^}]*}')local ja=fr(1770)local jb=fs(350)local iY=iK()if j6>0 then local jc={}local jd,je,jf=0,0,0;for cZ in j9 do local dI,ai,jg=cZ:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local jh=13;ai=y(ai)if radar_1.hasMatchingTransponder(dI)==1 then table.insert(jc,dI)end;if CollisionSystem then if ai>0 and radar_1.getConstructType(dI)=="static"or radar_1.getConstructType(dI)=="space"then jf=jf+1;local fN=radar_1.getConstructName(dI)local iX=bU[dI]if iX==nil then bU[dI]={pts={},ref=iY,name=fN,i=0,radius=jh,skipCalc=false}local ji={XS=13,S=27,M=55,L=110,XL=221}jh=ji[jg]bU[dI].radius=jh+F;iX=bU[dI]end;if not iX.skipCalc then iW(iX,ai,iY)je=je+1 end;if iX.center then table.insert(j7,iX)end end;jd=jd+1;if bV and jd>700 or je>70 or(not bV and jd>300 or je>30)then coroutine.yield()jd,je=0,0 end end end;local jj=#j7;if jj>0 and bB>20 then local dX,jk,jl,jm;local jn=0;local jo=b1:getPlanetarySystem(0)jm=bA:normalize()while jn<jj do coroutine.yield()local jp={table.unpack(j7,jn,math.min(jn+75,jj))}dX,jk,jl=jo:castIntersections(bE,jm,nil,nil,jp)if dX and jl then bX={dX,jk,jl}break end;jn=jn+75 end;if not dX then bX=nil end else bX=nil end;local jq=j8:find('identifiedConstructs":%[%]')if jq==nil and hH==nil then ak=1;hI()end;if jq~=nil and hH~=nil then hI()end;if radarPanelID==nil then hI()end;local jr,js;if CollisionSystem then if bV then js="Buildings"else js="Stations"end;if jj>0 then jr=jj.."/"..jf.." "..js.." : "..j6-jf.." Ships"else jr="0/"..jf.." "..js.." : "..j6-jf.." Ships"end else jr="Radar Contacts: "..j6 end;bR=ca(ja,jb,jr,"pbright txtbig txtmid")if#jc>0 then local cc=fs(15)local cb=fr(1370)bR=bR..ca(cb,cc,"Friendlies In Range","pbright txtbig txtmid")for cY,cZ in pairs(jc)do cc=cc+20;bR=bR..ca(cb,cc,radar_1.getConstructName(cZ),"pdim txtmid")end end else local jt;jt=j8:find('worksInEnvironment":false')if jt then bR=ca(ja,jb,"Radar: Jammed","pbright txtbig txtmid")else bR=ca(ja,jb,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ak=0;hI()end end end end;function i2.UpdateRadar()local ju=coroutine.status(UpdateRadarCoroutine)if ju=="suspended"then local ch,jv=coroutine.resume(UpdateRadarCoroutine)if jv then system.print("ERROR UPDATE RADAR: "..jv)end elseif ju=="dead"then UpdateRadarCoroutine=coroutine.create(i2.UpdateRadarRoutine)local ch,jv=coroutine.resume(UpdateRadarCoroutine)end end;function i2.DrawSettings(fx)if#bN>0 then local cb=fr(640)local cc=fs(200)fx[#fx+1]=[[<g class="pbright txtvspd txtstart">]]for cY,cZ in pairs(bN)do fx[#fx+1]=ca(cb,cc,cZ..": ".._G[cZ])cc=cc+20;if cY%12==0 then cb=cb+fr(350)cc=fs(200)end end;fx[#fx+1]=ca(fr(640),fs(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fx[#fx+1]="</g>"end;return fx end;UpdateRadarCoroutine=coroutine.create(i2.UpdateRadarRoutine)return i2 end;local function jw()local function jx()local function jy(jz,jA)return jz.name<jA.name end;bP={}for cY,cZ in pairs(aX[0])do bP[#bP+1]={name=cZ.name,index=cY}end;table.sort(bP,jy)end;local c_={}function c_.UpdateAtlasLocationsList()jx()end;function c_.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ab=nil;CustomTarget=nil;return true end;local jB=bP[AutopilotTargetIndex].index;local jC=aX[0][jB]if jC.center then AutopilotTargetName=jC.name;ab=b1[0][jB]if CustomTarget~=nil then if ar==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jC;for _,cZ in pairs(b1[0])do if cZ.name==CustomTarget.planetname then ab=cZ;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ab.center)else AutopilotTargetCoords=CustomTarget.position end;if ab.planetname~="Space"then if ab.hasAtmosphere then AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(ab.radius*(TargetOrbitRadius-1)+ab.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b4(ab):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function c_.adjustAutopilotTargetIndex(g1)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if g1==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bP then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bP end end;if AutopilotTargetIndex==0 then b6.UpdateAutopilotTarget()else local jB=bP[AutopilotTargetIndex].index;local jC=aX[0][jB]if jC.name=="Space"or iphCondition=="Custom Only"and jC.center or iphCondition=="No Moons"and string.find(jC.name,"Moon")~=nil then if g1==nil then b6.adjustAutopilotTargetIndex()else b6.adjustAutopilotTargetIndex(1)end else b6.UpdateAutopilotTarget()end end else a1="Disengage autopilot before changing Interplanetary Helper"bY("iph","AP")end end;function c_.findAtlasIndex(jD)for cY,cZ in pairs(jD)do if cZ.name and cZ.name==CustomTarget.name then return cY end end;return-1 end;for cY,cZ in pairs(SavedLocations)do table.insert(aX[0],cZ)end;jx()c_.UpdateAutopilotTarget()return c_ end;local function jE()local jF={}local function jG(eS)local jH=AutopilotEndSpeed;if not Autopilot then jH=0 end;if not aq then return b2.computeDistanceAndTime(eS,jH,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b2.computeDistanceAndTime(eS,jH,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jI(eS)local jH=AutopilotEndSpeed;if not Autopilot then jH=0 end;return b2.computeDistanceAndTime(eS,jH,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;function jF.GetAutopilotBrakeDistanceAndTime(eS)return jG(eS)end;function jF.GetAutopilotTBBrakeDistanceAndTime(eS)return jI(eS)end;local function jJ(jK,jL,jM)jL=jL:project_on_plane(jK)jM=jM:project_on_plane(jK)return m(jL:cross(jM):dot(jK),jL:dot(jM))end;local function jN()local function jO()local jP=-1;local jQ=-1;if vBooster then jP=vBooster.distance()end;if hover then jQ=hover.distance()end;if jP~=-1 and jQ~=-1 then if jP<jQ then return jP else return jQ end elseif jP~=-1 then return jP elseif jQ~=-1 then return jQ else return-1 end end;local jR=jO()local jS=-1;if telemeter_1 then jS=telemeter_1.getDistance()end;if jR~=-1 and jS~=-1 then if jR<jS then return jR else return jS end elseif jR~=-1 then return jR else return jS end end;local function jT(planet,ed,jU)local function jV(jW,dt)local ej=vec3(dt)if jW.bodyId==0 then return setmetatable({latitude=ej.x,longitude=ej.y,altitude=ej.z,bodyId=0,systemId=jW.planetarySystemId},MapPosition)end;local ek=ej-jW.center;local ai=ek:len()local dA=ai-jW.radius;local dy=0;local dz=0;if not ck(ai,0)then local el=m(ek.y,ek.x)dz=el>=0 and el or 2*math.pi+el;dy=math.pi/2-math.acos(ek.z/ai)end;return setmetatable({latitude=math.deg(dy),longitude=math.deg(dz),altitude=dA,bodyId=jW.bodyId,systemId=jW.planetarySystemId},MapPosition)end;local jX=jV(planet,ed)jX="::pos{"..jX.systemId..","..jX.bodyId..","..jX.latitude..","..jX.longitude..","..jX.altitude.."}"if jU then return jX else system.setWaypoint(jX)return true end end;function jF.showWayPoint(planet,ed,jU)return jT(planet,ed,jU)end;function jF.APTick()local function jY()if bX and not BrakeLanding then local dX=bX[1]local jk,jl=bX[2],bX[3]local jZ=math.min(jk,jl or jk)local j_=jZ/bB;if(AltitudeHold or VectorToTarget or LockPitch)and not AutoTakeoff and(a7*1.5>jZ or j_<1)then BrakeIsOn=true;cg(0)if AltitudeHold then cs()end;if LockPitch then ToggleLockPitch()end;a1="Autopilot Cancelled due to possible collision"if VectorToTarget then ct()end;StrongBrakes=true;BrakeLanding=true;ba=true end;if j_<11 then bW=dX.name.." COLLISION "..cP(j_).." / "..cn(jZ,2)else bW=dX.name.." collision "..cP(j_)end;if j_<6 then bY("alarm","AL",2)end else bW=false end end;aq=j()>0;ar=j()as=core.getAltitude()ao=jN()C=p()bd=C;bV=unit.getClosestPlanetInfluence()>0;if CollisionSystem then jY()end;if antigrav then bH=antigrav.getState()==1 end;local k0=1;local k1=1;local k2=C-bd;local k3=-math.deg(jJ(bx,bA,by))local k4=math.deg(jJ(bz,bA,by))local g1=bC*-1;bc=aq and k3<-YawStallAngle or k3>YawStallAngle or k4<-PitchStallAngle or k4>PitchStallAngle;local k5=system.getMouseDeltaX()local k6=system.getMouseDeltaY()if InvertMouse and not a0 then k6=-k6 end;U=0;Y=0;T=0;sys=b1[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b4(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bA)if as==0 then as=(bE-planet.center):len()-planet.radius end;local ie=planet:getGravity(core.getConstructWorldPos()):len()*av;be=0;b3=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and a0 then if not b8 then af=af+k5;ag=ag+k6 end else af=0;ag=0 end else af=af+k5;ag=ag+k6;ai=x(af*af+ag*ag)if not a0 and l()==0 then if userControlScheme=="virtual joystick"then if af>0 and af>DeadZone then U=U-(af-DeadZone)*MouseXSensitivity elseif af<0 and af<DeadZone*-1 then U=U-(af+DeadZone)*MouseXSensitivity else U=0 end;if ag>0 and ag>DeadZone then T=T-(ag-DeadZone)*MouseYSensitivity elseif ag<0 and ag<DeadZone*-1 then T=T-(ag+DeadZone)*MouseYSensitivity else T=0 end else af=0;ag=0;if userControlScheme=="mouse"then T=(-utils.smoothstep(k6,-100,100)+0.5)*2*k0;U=(-utils.smoothstep(k5,-100,100)+0.5)*2*k1 end end end end;local k7=bB>8334;if bB>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not k7 then a1="Space Speed Engine Shutoff reached"cg(0)end;if not k7 and LastIsWarping then if not BrakeIsOn then cA()end;if Autopilot then ct()end end;LastIsWarping=k7;if aq and ar>0.09 then if bB>bh/3.6 and not AtmoSpeedAssist and not ay then BrakeIsOn=true;ay=true elseif not AtmoSpeedAssist and ay then if bB<bh/3.6 then BrakeIsOn=false;ay=false end end end;if BrakeIsOn then X=1 else X=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local k8=false;if CustomTarget~=nil then k8=cB(CustomTarget.position-bE,0.1)else k8=cB(vec3(bA),0.01)end;ba=true;if k8 then cj(d(bh))if(c(bL)<2 or c(bK)>85)and bB>=bh/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;cN()end elseif aq and AtmoSpeedAssist then cg(1)end elseif bB>P then cB(vec3(bA),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bB>P then cB(-vec3(bA))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then Q=true;cN()al=false;an=true else al=false;ct()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bB*3.6>bh-250 and c(bD)<25 and ar>=0.1 and(CustomTarget.position-bE):len()>2000+as then ct()an=false end;if VertTakeOff then ba=true;local k9=HoldAltitude;if bD<-30 then a1="Unable to achieve lift. Safety Landing."ae=0;ba=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bH or HoldAltitude<planet.spaceEngineMinAltitude then if bH then k9=antigrav.getBaseAltitude()end;if as<k9-100 then bi=0;ae=15;BrakeIsOn=false elseif bD>0 then BrakeIsOn=true;ae=0 elseif bD<-30 then BrakeIsOn=true;ae=15 elseif as>=k9 then if bH then if Autopilot or VectorToTarget then cq()else BrakeIsOn=true;VertTakeOff=false end;a1="Takeoff complete. Singularity engaged"bY("aggLk","AG")else BrakeIsOn=false;a1="VTO complete. Engaging Horizontal Flight"bY("vtoc","VT")cq()end;ae=0 end else if ar>0.08 then bi=0;BrakeIsOn=false;ae=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bu then bi=0;ae=20 else ae=0;bi=36;cj(3500)end else ba=autoRollPreference;IntoOrbit=true;bs=false;CancelIntoOrbit=false;bm=false;bk=nil;bl=nil;if br==nil then br=planet end;bq=k9;bp=true;VertTakeOff=false end end;if bi~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ka=q(bi-bK,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ka)local kb=q(vTpitchPID:get(),-1,1)T=kb end end;if IntoOrbit then local cK;local kc=false;local kd=cn(bq)if br==nil then br=planet;if VectorToTarget then br=ab end end;if not bp then bq=d(br.radius+br.surfaceMaxAltitude+LowOrbitHeight)if br.hasAtmosphere then bq=d(br.radius+br.noAtmosphericDensityAltitude+LowOrbitHeight)end;bp=true end;if bo.VectorToTarget then cK=CustomTarget.position-bE end;local ke,kf=b4(br):escapeAndOrbitalSpeed((bE-br.center):len()-br.radius)local kg=bL;if not bm then local kh=false;local ki=false;cg(0)bl=0;bj="Aligning to orbital path - OrbitHeight: "..kd;if bo.VectorToTarget then cB(cK:normalize():project_on_plane(bC))kc=by:dot(cK:project_on_plane(bx):normalize())>0.95 else cB(bA)kc=k3<0.5;if bB<150 then kc=true end end;T=0;bk=0;if bK<=bk+1 and bK>=bk-1 then kh=true else kh=false end;if kg<=bl+1 and kg>=bl-1 then ki=true else ki=false end;if kh and ki and kc then bk=nil;bl=nil;bm=true end else if bo.VectorToTarget then cB(cK:normalize():project_on_plane(bC))elseif bB>150 then cB(bA)end;T=0;if bo.VectorToTarget then local a7,_=b2.computeDistanceAndTime(bB,bh/3.6,av,0,0,LastMaxBrake)if bs and cK:len()>15000+a7+as then bj="Orbiting to Target"if as-100<=br.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<br.noAtmosphericDensityAltitude then bs=false end elseif bs or cK:len()<15000+a7+as then a1="Orbit complete, proceeding with reentry"bY("orCom","OB")AutopilotTargetCoords=CustomTarget.position;Q=true;an=true;bo.VectorToTarget,bo.AutopilotAlign=false,false;cr()cN()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bq*0.9 and as<bq*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bq*0.99 and orbit.apoapsis.altitude>=bq*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bs then if bs then BrakeIsOn=false;cg(0)bk=0;if not bo.VectorToTarget then a1="Orbit complete"bY("orCom","OB")cr()end else bw=bw+1;if bw>=2 then bs=true end end else bj="Adjusting Orbit - OrbitHeight: "..kd;bn=true;cj(kf*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kj=bD;local kk=as-bq;local kl=c(kk)if bD<10 and c(bK)<10 and kl<100 then kj=bD*2 end;if kj<10 and c(bK)<10 and kl<100 then kj=kj*2 end;if kj<5 and c(bK)<5 and kl<100 then kj=kj*4 end;VSpdPID:inject(kj)bk=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kk)bk=q(bk-q(OrbitAltPID:get(),-15,15),-90,90)end end else local km=2.75;local kn=c(o(ke*km))local ko=kn%50;if ko>0 then kn=kn-ko+50 end;BrakeIsOn=false;if as<bq*0.8 then bj="Escaping planet gravity - OrbitHeight: "..kd;bk=utils.map(bD,200,0,-15,80)elseif as>=bq*0.8 and as<bq*1.15 then bj="Approaching orbital corridor - OrbitHeight: "..kd;kn=kn*0.75;bk=utils.map(bD,100,-100,-15,65)elseif as>=bq*1.15 and as<bq*1.5 then bj="Approaching orbital corridor - OrbitHeight: "..kd;kn=kn*0.75;if bD<0 or bn then bk=utils.map(as,bq*1.5,bq*1.01,-30,0)else bk=utils.map(as,bq*0.99,bq*1.5,0,30)end elseif as>bq*1.5 then bj="Reentering orbital corridor - OrbitHeight: "..kd;bk=-65;local kp=utils.map(bD,-150,-400,1,0.55)kn=kn*kp end;cj(d(kn))end end;if bk~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kq=bk-bK;OrbitPitchPID:inject(kq)local kr=q(OrbitPitchPID:get(),-0.5,0.5)T=kr end end;if Autopilot and ar==0 and not al then local function ks(jr,orbit)system.print(jr)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cg(0)O=false;a1=jr;bY("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bq=as;bp=true end;cr()end end;local kt,ku=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kv=(CustomTarget.position-ab.center):normalize()local kw=kv:project_on_plane((ab.center-bE):normalize()):normalize()local kx=ab.center+kw*(ab.radius+AutopilotTargetOrbit)local ky=CustomTarget.position+(CustomTarget.position-ab.center):normalize()*(AutopilotTargetOrbit-ab:getAltitude(CustomTarget.position))if(bE-kx):len()<(bE-ky):len()then kt=kx else kt=ky;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kt;b7.showWayPoint(ab,AutopilotTargetCoords)ku=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;ku=true;TargetSet=true;AutopilotRealigned=true;kt=CustomTarget.position+(bE-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kv=(bE+bA*100000-ab.center):normalize()local kw=kv:project_on_plane((ab.center-bE):normalize()):normalize()if kw:len()<1 then kv=(bE+by*100000-ab.center):normalize()kw=kv:project_on_plane((ab.center-bE):normalize()):normalize()end;kt=ab.center+kw*(ab.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kt;TargetSet=true;ku=true;AutopilotRealigned=true;b7.showWayPoint(ab,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kt)-bE):len()local hm,eb,ec=b1:getPlanetarySystem(0):castIntersections(bE,bA:normalize(),function(dX)if dX.noAtmosphericDensityAltitude>0 then return dX.radius+dX.noAtmosphericDensityAltitude else return dX.radius+dX.surfaceMaxAltitude*1.5 end end)local hn=eb;if ec~=nil and eb~=nil then hn=math.min(ec,eb)end;if hn~=nil and hn<AutopilotDistance and hm.name==ab.name then AutopilotDistance=hn end;local k8=true;local kz=(ab.center-(bE+vec3(bA):normalize()*AutopilotDistance)):len()-ab.radius;local hl=cn(kz)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hl..'"}')local a7,a8;if not TurnBurn then a7,a8=jG(bB)else a7,a8=jI(bB)end;if bB>300 and AutopilotAccelerating then local cK=vec3(kt)-bE;local kA=q(math.deg(jJ(bx,bA:normalize(),cK:normalize()))*bB/500,-90,90)local kB=q(math.deg(jJ(bz,bA:normalize(),cK:normalize()))*bB/500,-90,90)if c(kA)<20 and c(kB)<20 then kA=kA*2;kB=kB*2 end;if c(kA)<2 and c(kB)<2 then kA=kA*2;kB=kB*2 end;local k3=-math.deg(jJ(bx,by,bA:normalize()))local k4=-math.deg(jJ(bz,by,bA:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kB-k4)local kC=q(apPitchPID:get(),-1,1)T=T+kC;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kA-k3)local kD=q(apYawPID:get(),-1,1)U=U+kD;ku=true;if c(kA)>2 or c(kB)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bY("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end end end;if kz<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b4(ab):escapeAndOrbitalSpeed(kz)end end;if not AutopilotCruising and not AutopilotBraking and not ku then k8=cB((kt-bE):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then k8=cB(-vec3(bA):normalize())end;if AutopilotAccelerating then if not O then BrakeIsOn=false;cg(AutopilotInterplanetaryThrottle)J=z(AutopilotInterplanetaryThrottle,2)O=true end;local kE=unit.getThrottle()if AtmoSpeedAssist then kE=J end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kE==0 and O then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bY("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cg(0)end;if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bY("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cg(0)O=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;X=1 end;if TurnBurn then cg(1,true)end;local _,kf=b4(ab):escapeAndOrbitalSpeed((bE-planet.center):len()-planet.radius)local cK;if CustomTarget~=nil then cK=CustomTarget.position-bE end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bB<50 then ks("Autopilot complete, arrived at space location")BrakeIsOn=true;X=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bB<=kf and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then ks("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b7.showWayPoint(ab,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bY("apCir","AP")AutopilotStatus="Circularizing"end;if bB<=kf then if CustomTarget~=nil then if bA:normalize():dot(cK:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bY("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;b7.showWayPoint(ab,CustomTarget.position)WaypointSet=true end else ks("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;b7.showWayPoint(ab,CustomTarget.position)WaypointSet=false end else ks("Autopilot completed, setting orbit",true)X=0 end end elseif AutopilotStatus=="Circularizing"then ks("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a7 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bY("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kE=unit.getThrottle()if AtmoSpeedAssist then kE=J end;if kE>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end;AutopilotCruising=false end else if k8 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ab.center)+(AutopilotTargetOrbit+ab.radius)*bz;AutopilotShipUp=bx;AutopilotShipRight=bz end;AutopilotRealigned=true elseif k8 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bY("apAcc","AP")end;if not O then cg(AutopilotInterplanetaryThrottle,true)J=z(AutopilotInterplanetaryThrottle,2)O=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a1="Autopilot complete, proceeding with reentry"bY("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"X=0;cg(0)O=false;ProgradeIsOn=true;al=true;b7.showWayPoint(ab,CustomTarget.position)end;if Z then ba=true;local kB=0;local eW=bE+vec3(unit.getMasterPlayerRelativePosition())local kF=eW-bE;local kG=vec3(kF):project_on(by):len()local kH=vec3(kF):project_on(bz):len()local ai=x(kG*kG+kH*kH)cB(kF:normalize())local kI=40;local kJ=ai<kI;local kK=100;local kL=q((ai-kI)/2,10,kK)T=0;local k8=c(U)<0.1;if k8 and bB<kL and not kJ then BrakeIsOn=false;kB=-20 else BrakeIsOn=true;kB=0 end;local kM=0;if c(kB-bK)>kM then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kB-bK)local kC=pitchPID:get()T=kC end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local kN=LastMaxBrakeInAtmo;if kN then kN=kN*q(bB/100,0.1,1)*ar else kN=LastMaxBrake end;if ar<0.01 then kN=LastMaxBrake end;local kO=vec3(core.getWorldAirFrictionAcceleration())local kP=x(kO:len()-kO:project_on(g1):len())*av;if bB>100 then a7,a8=b2.computeDistanceAndTime(bB,100,av,0,0,kN+kP)local kQ,kR=b2.computeDistanceAndTime(100,0,av,0,0,kN/2)a7=a7+kQ else a7,a8=b2.computeDistanceAndTime(bB,0,av,0,0,kN/2)end;local kS=HoldAltitude-as;local kT=500+bB;local kU=1;if AutoTakeoff then kU=q(bB/100,0.1,1)end;local kB=(utils.smoothstep(kS,-kT,kT)-0.5)*2*MaxPitch*kU;if not Reentry and not al and not VectorToTarget and by:dot(bA:normalize())<0.99 then kB=(utils.smoothstep(kS,-kT*q(20-19*ar*10,1,20),kT*q(20-19*ar*10,1,20))-0.5)*2*MaxPitch*q(2-ar*10,1,2)*kU end;if not AltitudeHold then kB=0 end;if LockPitch~=nil then if bV and not IntoOrbit then kB=LockPitch else LockPitch=nil end end;ba=true;local kV=T;if Reentry then local kW=d(bh)local kX,kY=b2.computeDistanceAndTime(bB,kW/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)local kZ=as-(planet.noAtmosphericDensityAltitude+5000)if not bJ and as>planet.noAtmosphericDensityAltitude+5000 and bB<=kW/3.6 and bB>kW/3.6-10 and c(bA:normalize():dot(by))>0.9 then cg(0)elseif bJ and bB>kW/3.6 and(kX>-1 and kZ<=kX or as<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cj(kW,true)if not Q then kB=-80;if ar>0.02 then a1="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kB=0;ba=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and as>planet.noAtmosphericDensityAltitude+5000 then ba=true elseif as<=planet.noAtmosphericDensityAltitude+5000 then cj(kW)if not bJ and r:getTargetSpeed(axisCommandId.longitudinal)==bh then Q=false;Reentry=false;ba=true end end end;if bB>P and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then cB(vec3(bA))end;if bT or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local cK;if bT then if type(bT)=="table"then cK=bT elseif bT<3 and bT>0 then cK=-bC:cross(bA)*5000 elseif bT>=3 then cK=bC:cross(bA)*5000 elseif bT<0 then cK=bA*25000 end elseif CustomTarget~=nil then cK=CustomTarget.position-bE else cK=ab.center-bE end;local kA=math.deg(jJ(bC:normalize(),bA,cK))*2;local k_=math.rad(c(bL))if bB>minRollVelocity and ar>0.01 then local l0=q(90-kB*2,-90,90)be=q(kA*2,-l0,l0)local l1=kA;kA=q(q(kA,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(k_)+4*(bK-kB)*math.sin(math.rad(bL)),-YawStallAngle*0.80,YawStallAngle*0.80)kB=q(q(kB*math.cos(k_),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(l1)*math.sin(k_),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else be=0;kA=q(kA,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l2=k3-kA;if bT and c(l2)<=0.0001 and(type(bT)=="table"or type(bT)~="table"and bT<0 and c(bL)<1)then if bT==-2 then cs()end;bT=nil;bY("180Off","BR")return end;if not bc and bB>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l2)local kD=q(yawPID:get(),-1,1)U=U+kD elseif aq and ao>-1 or bB<minRollVelocity then cB(cK)elseif bc and ar>0.01 then if(k3<-YawStallAngle or k3>YawStallAngle)and ar>0.01 then cB(bA)end;if(k4<-PitchStallAngle or k4>PitchStallAngle)and ar>0.01 then kB=q(bK-k4,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local k9=planet:getAltitude(CustomTarget.position)local kZ=x(cK:len()^2-(as-k9)^2)local l3=bA:len()-c(bD)StrongBrakes=true;if not am and not Reentry and kZ<=a7+bB*k2/2 and(bA:project_on_plane(bC):normalize():dot(cK:project_on_plane(bC):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cg(0)if AltitudeHold then cs()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l3<0.1 or kZ<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<kZ)then if not bH then bY("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bW=false end;LastDistanceToTarget=kZ end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ab.name==planet.name then local cK=CustomTarget.position-bE;local k9=planet:getAltitude(CustomTarget.position)local kZ=x(cK:len()^2-(as-k9)^2)local kN=LastMaxBrakeInAtmo;if kN then a7,a8=b2.computeDistanceAndTime(bB,0,av,0,0,kN/2)StrongBrakes=true;if kZ<=a7+bB*k2/2 and bA:project_on_plane(bC):normalize():dot(cK:project_on_plane(bC):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;Q=true;al=false;an=true;Autopilot=false;cN()end end;LastDistanceToTarget=kZ end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bs and not IntoOrbit then bq=HoldAltitude;bp=true;if VectorToTarget then bo.VectorToTarget=true end;cr()VectorToTarget=false;bm=true end end;if bc and ar>0.01 and ao==-1 and bB>minRollVelocity and VectorStatus~="Finalizing Approach"then cB(bA)kB=q(bK-k4,bK-PitchStallAngle*0.80,bK+PitchStallAngle*0.80)end;T=kV;local jS=-1;if BrakeLanding then kB=0;local l4=false;local l5=30;if b3~=nil and b3>0 then local l6=q(ar,0.4,2)local kN=LastMaxBrakeInAtmo*q(bB/100,0.1,1)*l6;local l7=b3*l6+kN-ie;local l8=kN/2-ie;local l9=bB-x(c(l8/2)*20/(0.5*av))*utils.sign(l8)if l9<0 then l9=0 end;local la;if bB>100 then local lb,_=b2.computeDistanceAndTime(bB,100,av,0,0,kN)local lc,_=b2.computeDistanceAndTime(100,0,av,0,0,x(kN))la=lb+lc else la=b2.computeDistanceAndTime(bB,0,av,0,0,x(kN))end;if la<20 then BrakeIsOn=false else local ld=0;if l9>100 then local le,_=b2.computeDistanceAndTime(l9,100,av,0,0,l7)local lf,_=b2.computeDistanceAndTime(100,0,av,0,0,b3*l6+x(kN)-ie)ld=le+lf else ld,_=b2.computeDistanceAndTime(l9,0,av,0,0,b3*l6+x(kN)-ie)end;ld=(ld+15+bB*k2)*1.1;local lg=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lg then local k9=planet:getAltitude(CustomTarget.position)local lh=as-k9-100;local cK=CustomTarget.position-bE;local li=x(cK:len()^2-(as-k9)^2)if li>100 then lg=false elseif lh<=ld or ld==-1 then BrakeIsOn=true;l4=true else BrakeIsOn=false;l4=true end end;if not lg and CalculateBrakeLandingSpeed then if ld>=l5 then BrakeIsOn=true else BrakeIsOn=false end;l4=true end end end;if not bJ then cg(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;jS=ao;if jS>-1 then ba=autoRollPreference;if bB<1 or bA:normalize():dot(bC)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if R then a.control.extendLandingGears()bY("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ae=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bA:normalize():dot(-g1)<0.999 then BrakeIsOn=true elseif bD<-brakeLandingRate and not l4 then BrakeIsOn=true elseif not l4 then BrakeIsOn=false end end;if AutoTakeoff or am then local hm,ec,eb;if AutopilotTargetCoords~=nil then hm,ec,eb=b1:getPlanetarySystem(0):castIntersections(bE,(AutopilotTargetCoords-bE):normalize(),function(dX)return dX.radius+dX.noAtmosphericDensityAltitude end)end;if bH then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cg(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kB)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bJ and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bB<P then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cg(0)elseif am then cg(0)BrakeIsOn=true end elseif am and ar==0 and ab~=nil and(hm==nil or hm.name==ab.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bJ then cg(0)end;AutopilotAccelerating=true end end;local lj=ao>-1;local lk=bK;if(VectorToTarget or am or bT)and not lj and bB>minRollVelocity and ar>0.01 then local k_=math.rad(c(bL))lk=bK*c(math.cos(k_))+k4*math.sin(k_)end;local ll=q(kB-lk,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then ll=q(kB-lk,-85,MaxPitch)elseif ar<0.01 then ll=q(kB-lk,-MaxPitch,MaxPitch)end;if c(bL)<5 or VectorToTarget or bT or BrakeLanding or lj or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(ll)local kC=pitchPID:get()T=T+kC end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jN()return jF end;function script.onStart()local lm={}local ln={}local lo=false;local function lp()local function lq(lr)local ls=dbHud_1.hasKey;for cY,cZ in pairs(lr)do if ls(cZ)then local cH=f(dbHud_1.getStringValue(cZ))if cH~=nil then _G[cZ]=cH;lo=true end end end end;if dbHud_1 then if not useTheseSettings then lq(c3())coroutine.yield()lq(b)else lq(b)a1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ah=5;lo=false end;coroutine.yield()if lo then a1="Loaded Saved Variables"aH=ResolutionX;aI=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)ba=autoRollPreference;bh=AtmoSpeedLimit;az=[[rgb(]]..d(G+0.5)..","..d(I+0.5)..","..d(H+0.5)..[[)]]aA=[[rgb(]]..d(G*0.9+0.5)..","..d(I*0.9+0.5)..","..d(H*0.9+0.5)..[[)]]elseif not useTheseSettings then a1="No Saved Variables Found - Exit HUD to save settings"end else a1="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<C then LastMaxBrakeInAtmo=0 end;LastStartTime=C;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ah=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=av end;VectorStatus="Proceeding to Waypoint"end;local function lt()local function lu(lv,lw)if lv>lw then lw=lv end;local lx,ly=0,0;if ContainerOptimization>0 then lx=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then ly=FuelTankOptimization*0.05 end;lw=lw*(1-(lx+ly))return lw end;local lz=core.getElementNameById;local lA=fuelX~=0 and fuelY~=0;for cY in pairs(at)do local type=core.getElementTypeById(at[cY])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(at[cY])),'^.*vertical.*$')then bG=true end end;if n(type,'^.*Space Engine$')then bv=true;if n(tostring(core.getElementTagsById(at[cY])),'^.*vertical.*$')then local lB=core.getElementRotationById(at[cY])if lB[4]<0 then if o(-lB[4],0.1)==0.5 then bt=true end else if o(lB[4],0.1)==0.5 then bu=true end end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local lC=h(at[cY])if lC>10000 then E=128;F=110 elseif lC>1000 then E=64;F=55 elseif lC>150 then E=32;F=27 end end;aM=aM+h(at[cY])if lA and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lC=h(at[cY])local lD=k(at[cY])local lv=0;local fU=p()if type=="Atmospheric Fuel Tank"then local lw=400;local lE=35.03;if lC>10000 then lw=51200;lE=5480 elseif lC>1300 then lw=6400;lE=988.67 elseif lC>150 then lw=1600;lE=182.67 end;lv=lD-lE;if fuelTankHandlingAtmo>0 then lw=lw+lw*fuelTankHandlingAtmo*0.2 end;lw=lu(lv,lw)aJ[#aJ+1]={at[cY],lz(at[cY]),lw,lE,lv,fU}end;if type=="Rocket Fuel Tank"then local lw=320;local lE=173.42;if lC>65000 then lw=40000;lE=25740 elseif lC>6000 then lw=5120;lE=4720 elseif lC>700 then lw=640;lE=886.72 end;lv=lD-lE;if fuelTankHandlingRocket>0 then lw=lw+lw*fuelTankHandlingRocket*0.1 end;lw=lu(lv,lw)aL[#aL+1]={at[cY],lz(at[cY]),lw,lE,lv,fU}end;if type=="Space Fuel Tank"then local lw=2400;local lE=182.67;if lC>10000 then lw=76800;lE=5480 elseif lC>1300 then lw=9600;lE=988.67 end;lv=lD-lE;if fuelTankHandlingSpace>0 then lw=lw+lw*fuelTankHandlingSpace*0.2 end;lw=lu(lv,lw)aK[#aK+1]={at[cY],lz(at[cY]),lw,lE,lv,fU}end end end;if not bG then VertTakeOff,VertTakeOffEngine=false,false end end;local function lF()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(aq or not aq and as<10000)then for _,cZ in pairs(door)do cZ.toggle()end end;if switch then for _,cZ in pairs(switch)do cZ.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cZ in pairs(forcefield)do cZ.toggle()end end;if antigrav then bH=antigrav.getState()==1;if bH and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if R then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if R then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(bb)if aq and ao~=-1 then b3=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function lG(lH,lI,lJ,lK,cb,cc,lL,lM,lN,lO)local lP={enableName=lH,disableName=lI,width=lJ,height=lK,x=cb,y=cc,toggleVar=lL,toggleFunction=lM,drawCondition=lN,hovered=false}if lO then table.insert(ln,lP)else table.insert(lm,lP)end;return lP end;local function lQ(lR)if not bM then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif lR=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif lR=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif lR=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bN=c3(lR)showHud=false else bN={}showHud=true end end;local function lS()bM=not bM;if bM then aG=ln;a1="Hold SHIFT to see Settings"bO=showHud else aG=lm;a1="Hold SHIFT to see Control Buttons"lQ()showHud=bO end end;local function lT(cZ)_G[cZ]=not _G[cZ]if _G[cZ]then a1=cZ.." set to true"else a1=cZ.." set to false"end;if cZ=="showHud"then bO=_G[cZ]elseif cZ=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cZ=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function lU()local lV=50;local lW=340;local cb=500;local cc=aI/2-400;local lX=0;for cY,cZ in pairs(c3("boolean"))do if type(_G[cZ])=="boolean"then lG(cZ,cZ,lW,lV,cb,cc,function()return _G[cZ]end,function()lT(cZ)end,function()return true end,true)cc=cc+lV+20;if lX==9 then cb=cb+lW+20;cc=aI/2-400;lX=0 else lX=lX+1 end end end;lG("Control View","Control View",lW,lV,10,aI/2-500,function()return true end,lS,function()return true end,true)lG("View Handling Settings",'Hide Handling Settings',lW,lV,10,aI/2-(500-lV),function()return showHandlingVariables end,function()lQ("handling")end,function()return true end,true)lG("View Hud Settings",'Hide Hud Settings',lW,lV,10,aI/2-(500-lV*2),function()return showHudVariables end,function()lQ("hud")end,function()return true end,true)lG("View Physics Settings",'Hide Physics Settings',lW,lV,10,aI/2-(500-lV*3),function()return showPhysicsVariables end,function()lQ("physics")end,function()return true end,true)end;local function lY()local function lZ()if dbHud_1 then local position=bE;local fN=planet.name..". "..#SavedLocations;if radar_1 then local dI,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dI~=nil and dI~=""then fN=fN.." "..radar_1.getConstructName(dI)end end;local cy={}cy={position=position,name=fN,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cy;table.insert(aX[0],cy)b6.UpdateAtlasLocationsList()a1="Location saved as "..fN else a1="Databank must be installed to save locations"end end;local function l_()TurnBurn=not TurnBurn end;local function m0(m1)if m1==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Z=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function m2()m0(1)end;local function m3()local cx=-1;cx=b6.findAtlasIndex(aX[0])if cx>-1 then table.remove(aX[0],cx)end;cx=-1;cx=b6.findAtlasIndex(SavedLocations)if cx~=-1 then a1=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cx)end;b6.adjustAutopilotTargetIndex()b6.UpdateAtlasLocationsList()end;local function m4()local fN=AutopilotTargetName;if fN==nil then local hl=cn((bE-CustomTarget.position):len())fN=CustomTarget.name.." "..hl end;if fN==nil then fN="None"end;return"Engage Autopilot: "..fN end;local function m5()local fN=AutopilotTargetName;if fN==nil then fN=CustomTarget.name end;if fN==nil then fN="None"end;return"Disable Autopilot: "..fN end;local function m6()if safeMass>0 then a1="Safe Mass set to "..z(av,2).." kg"else a1="Intruder Detection reset\nSafe Mass set to "..z(av,2).." kg"ah=5;bF=0 end;safeMass=av end;local function m7()if l()==1 then Z=not Z;if Z then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)bY("folOn","F")else bY("folOff","F")BrakeIsOn=true;ba=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a1="Follow Mode only works with Remote controller"Z=false end end;local lV=50;local lW=260;local m8=lG("Enable Brake Toggle","Disable Brake Toggle",lW,lV,aH/2-lW/2,aI/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a1="Brakes in Toggle Mode"else a1="Brakes in Default Mode"end end)lG("Align Prograde","Disable Prograde",lW,lV,aH/2-lW/2-50-m8.width,aI/2-lV+380,function()return ProgradeIsOn end,m2)lG("Align Retrograde","Disable Retrograde",lW,lV,aH/2-lW/2+m8.width+50,aI/2-lV+380,function()return RetrogradeIsOn end,m0,function()return ar==0 end)local m9=lG(m4,m5,600,60,aH/2-600/2,aI/2-60/2-400,function()return Autopilot end,ct)lG("Save Position","Save Position",200,m9.height,m9.x+m9.width+30,m9.y,function()return false end,lZ,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lG("Update Position","Update Position",200,m9.height,m9.x+m9.width+30,m9.y,function()return false end,cv,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lG("Clear Position","Clear Position",200,m9.height,m9.x-200-30,m9.y,function()return true end,m3,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lV=60;lW=300;local cb=10;local cc=aI/2-500;lG("Show Help","Hide Help",lW,lV,cb,cc,function()return showHelp end,function()showHelp=not showHelp end)cc=cc+lV+20;lG("View Settings","View Settings",lW,lV,cb,cc,function()return true end,lS)local cc=aI/2-300;lG("Enable Turn and Burn","Disable Turn and Burn",lW,lV,cb,cc,function()return TurnBurn end,l_)lG("Horizontal Takeoff Mode","Vertical Takeoff Mode",lW,lV,cb+lW+20,cc,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a1="Vertical Takeoff Mode"else a1="Horizontal Takeoff Mode"end end,function()return bG end)cc=cc+lV+20;lG("Show Orbit Display","Hide Orbit Display",lW,lV,cb,cc,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a1="Orbit Display Enabled"else a1="Orbit Display Disabled"end end)lG("Engage Orbiting","Cancel Orbiting",lW,lV,cb+lW+20,cc,function()return IntoOrbit end,cr,function()return ar==0 and bV end)cc=cc+lV+20;lG("Glide Re-Entry","Cancel Glide Re-Entry",lW,lV,cb,cc,function()return Reentry end,function()al=true;m2()end,function()return planet.hasAtmosphere and not aq end)lG("Parachute Re-Entry","Cancel Parachute Re-Entry",lW,lV,cb+lW+20,cc,function()return Reentry end,cN,function()return planet.hasAtmosphere and not aq end)cc=cc+lV+20;lG("Engage Follow Mode","Disable Follow Mode",lW,lV,cb,cc,function()return Z end,m7,function()return l()==1 end)lG("Enable Repair Arrows","Disable Repair Arrows",lW,lV,cb+lW+20,cc,function()return aN end,function()aN=not aN;if aN then a1="Repair Arrows Enabled"else a1="Repair Arrows Diabled"end end,function()return l()==1 end)cc=cc+lV+20;if not ExternalAGG then lG("Enable AGG","Disable AGG",lW,lV,cb,cc,function()return bH end,cO,function()return antigrav~=nil end)end;lG("Reset Intruder Alert","Set Safe Mass",lW,lV,cb+lW+20,cc,function()return safeMass>0 end,m6,function()return IntruderAlertSystem end)cc=cc+lV+20;lG(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,lW*2,lV,cb,cc,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a1="IPH Mode: "..iphCondition end)cc=cc+lV+20;lG(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,lW*2,lV,cb,cc,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a1="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lp()coroutine.yield()lt()coroutine.yield()b7=jE()lF()lU()lY()aG=lm;coroutine.yield()aX=c_()b0=d0()b1=b0(c_())b2=ep()b4=eU()b5=fh()b6=jw()b7=jE()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bY("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cZ in pairs(door)do cZ.toggle()end end;if switch then for _,cZ in pairs(switch)do cZ.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cZ in pairs(forcefield)do cZ.toggle()end end;safeMass=av;cU()if button then button.activate()end;if SetWaypointOnExit then b7.showWayPoint(planet,bE)end;bY("stop","SU")end;function script.onTick(ma)local mb=nil;if ma=="contact"then if not contactTimer then contactTimer=0 end;if C>contactTimer+10 then a1="Radar Contact"bY("rdrCon","RC")contactTimer=C end;unit.stopTimer("contact")elseif ma=="tenthSecond"then local function mc()local md=system.createData;local me=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=me(panelInterplanetary,"value")interplanetaryHeaderText=md('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=me(panelInterplanetary,"value")widgetDistanceText=md('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=me(panelInterplanetary,"value")widgetTravelTimeText=md('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=me(panelInterplanetary,"value")widgetMaxMassText=md('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=me(panelInterplanetary,"value")widgetTargetOrbitText=md('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=me(panelInterplanetary,"value")widgetCurBrakeDistanceText=md('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=me(panelInterplanetary,"value")widgetCurBrakeTimeText=md('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=me(panelInterplanetary,"value")widgetMaxBrakeDistanceText=md('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=me(panelInterplanetary,"value")widgetMaxBrakeTimeText=md('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=me(panelInterplanetary,"value")widgetTrajectoryAltitudeText=md('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mf()s(panelInterplanetary)panelInterplanetary=nil end;local function mg()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ab.center-bE):len()else AutopilotDistance=(CustomTarget.position-bE):len()end end;local eS=bB;local kE=unit.getThrottle()/100;if AtmoSpeedAssist then kE=J end;local mh,mi=b2.computeDistanceAndTime(bB,MaxGameVelocity,av,a:maxForceForward()*kE,warmup,0)local a7,a8;if not TurnBurn then a7,a8=b7.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b7.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mj;if not TurnBurn and eS>0 then _,mj=b7.GetAutopilotBrakeDistanceAndTime(eS)else _,mj=b7.GetAutopilotTBBrakeDistanceAndTime(eS)end;local mk=0;local ml=0;if AutopilotCruising or not Autopilot and eS>5 then ml=b2.computeTravelTime(eS,0,AutopilotDistance)elseif a7+mh<AutopilotDistance then mk=AutopilotDistance-(a7+mh)ml=b2.computeTravelTime(8333.0556,0,mk)else local mm=(AutopilotDistance-a7)/mh;mh=AutopilotDistance-a7;mi=mi*mm end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return ml elseif AutopilotBraking then return mj elseif AutopilotCruising then return ml+mj else return mi+a8+ml end end;local function mn(ie,mo)if ie==nil then ie=core.g()end;ie=z(ie,5)if mo~=nil and mo or(mb==nil or mb~=ie)then local eV=core.getVelocity()local eS=vec3(eV):len()local mp=f(unit.getData()).maxBrake;if mp~=nil and mp>0 and aq then mp=mp/q(eS/100,0.1,1)mp=mp/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mp)/2 else LastMaxBrakeInAtmo=mp end end end;if mp~=nil and mp>0 then LastMaxBrake=mp end;mb=ie end end;mn(nil,true)if ar>0 and not WasInAtmo then if not bJ and AtmoSpeedAssist and(AltitudeHold or Reentry)then cg(1)N=false end end;if bI~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bI then cj(bI,TRUE)else bI=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mc()end;if AutopilotTargetName~=nil then local mq=CustomTarget~=nil;local mr=LastMaxBrakeInAtmo/ab:getGravity(ab.center+vec3(0,0,1)*ab.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mg()if mq and not Autopilot then ai=(bE-CustomTarget.position):len()else ai=(AutopilotTargetCoords-bE):len()end;if not TurnBurn then a7,a8=b7.GetAutopilotBrakeDistanceAndTime(bB)a9,aa=b7.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a7,a8=b7.GetAutopilotTBBrakeDistanceAndTime(bB)a9,aa=b7.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hl=cn(ai)t(widgetDistanceText,'{"label": "distance", "value": "'..hl..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cP(travelTime)..'", "unit":""}')hl=cn(a7)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hl..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cP(a8)..'", "unit":""}')hl=cn(a9)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hl..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cP(aa)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mr/1000)..'", "unit":" Tons"}')hl=cn(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..hl..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ar==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mf()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif ma=="oneSecond"then local function ms(fx)local mt=0;aE=""local mu=aM;local mv=0;local mw=0;local mx=0;local fW=0;local fX=""local my=core.getElementHitPointsById;for cY in pairs(at)do local lC=0;local mz=0;mz=h(at[cY])lC=my(at[cY])mv=mv+lC;if lC<mz then if lC==0 then mx=mx+1 else mw=mw+1 end;if aN and#aB==0 then position=vec3(core.getElementPositionById(at[cY]))local cb=position.x-E;local cc=position.y-E;local iH=position.z-E;table.insert(aB,core.spawnArrowSticker(cb,cc,iH+1,"down"))table.insert(aB,core.spawnArrowSticker(cb,cc,iH+1,"down"))core.rotateSticker(aB[2],0,0,90)table.insert(aB,core.spawnArrowSticker(cb+1,cc,iH,"north"))table.insert(aB,core.spawnArrowSticker(cb+1,cc,iH,"north"))core.rotateSticker(aB[4],90,90,0)table.insert(aB,core.spawnArrowSticker(cb-1,cc,iH,"south"))table.insert(aB,core.spawnArrowSticker(cb-1,cc,iH,"south"))core.rotateSticker(aB[6],90,-90,0)table.insert(aB,core.spawnArrowSticker(cb,cc-1,iH,"east"))table.insert(aB,core.spawnArrowSticker(cb,cc-1,iH,"east"))core.rotateSticker(aB[8],90,0,90)table.insert(aB,core.spawnArrowSticker(cb,cc+1,iH,"west"))table.insert(aB,core.spawnArrowSticker(cb,cc+1,iH,"west"))core.rotateSticker(aB[10],-90,0,90)table.insert(aB,at[cY])end elseif aN and#aB>0 and aB[11]==at[cY]then for fP in pairs(aB)do core.deleteSticker(aB[fP])end;aB={}end end;mt=d(mv/mu*100)if mt<100 then fx[#fx+1]=ca(0,0,"","pbright txt")fW=d(mt*2.55)fX=e("rgb(%d,%d,%d)",255-fW,fW,0)if mt<100 then fx[#fx+1]=ca("50%",1035,"Elemental Integrity: "..mt.."%","txtbig txtmid","fill:"..fX)if mx>0 then fx[#fx+1]=ca("50%",1055,"Disabled Modules: "..mx.." Damaged Modules: "..mw,"txtbig txtmid","fill:"..fX)elseif mw>0 then fx[#fx+1]=ca("50%",1055,"Damaged Modules: "..mw,"txtbig txtmid","fill:"..fX)end end end end;local function mA()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mB()local fU=p()local h9=bB;local mC=fU-au;if h9>1.38889 then h9=h9/1000;local mD=h9*(fU-au)TotalDistanceTravelled=TotalDistanceTravelled+mD;ac=ac+mD end;ad=ad+mC;TotalFlightTime=TotalFlightTime+mC;au=fU end;local function mE()if safeMass>0 then if av>safeMass+50 then bF=d(av-safeMass)safeMass=-1 elseif av<safeMass then safeMass=av end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mE()end;mB()b5.UpdatePipe()mA()local fx={}b5.ExtraData(fx)if ShowOdometer then fx=b5.DrawOdometer(fx,ac,TotalDistanceTravelled,ad)end;if ShouldCheckDamage then ms(fx)end;aj=table.concat(fx,"")collectgarbage("collect")elseif ma=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cH=f(dbHud_1.getStringValue("SavedLocations"))if cH~=nil then _G["SavedLocations"]=cH;local cx=-1;local cy;for cY,cZ in pairs(SavedLocations)do if cZ.name and cZ.name=="SatNav Location"then cx=cY;break end end;if cx~=-1 then cy=SavedLocations[cx]cx=-1;for cY,cZ in pairs(aX[0])do if cZ.name and cZ.name=="SatNav Location"then cx=cY;break end end;if cx>-1 then aX[0][cx]=cy end;b6.UpdateAtlasLocationsList()a1=cy.name.." position updated"end end;for i=1,#bP do if bP[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bP[i].name)b6.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif ma=="msgTick"then local fx={}b5.DisplayMessage(fx,"empty")a1="empty"unit.stopTimer("msgTick")ah=3 elseif ma=="animateTick"then b9=true;b8=false;af=0;ag=0;unit.stopTimer("animateTick")elseif ma=="hudTick"then local function mF(fx)local mG=d(q(ai/(aH/4)*255,0,255))fx[#fx+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",af,ag,d(G+0.5)+mG,d(I+0.5)-mG,d(H+0.5)-mG)end;local function mH()for _,cZ in pairs(aG)do if cZ.hovered then if not cZ.drawCondition or cZ.drawCondition()then cZ.toggleFunction()end;cZ.hovered=false end end end;local function mI()local function mJ(mK,mL,cb,cc,lJ,lK)if mK>cb and mK<cb+lJ and mL>cc and mL<cc+lK then return true else return false end end;local cb=af+aH/2;local cc=ag+aI/2;for _,cZ in pairs(aG)do cZ.hovered=mJ(cb,cc,cZ.x,cZ.y,cZ.width,cZ.height)end end;local function mM(fx)local function mN(fx,mO,hover,cb,cc,eL,mP,mQ,mR,mS,mT)if type(mS)=="function"then mS=mS()end;if type(mT)=="function"then mT=mT()end;fx[#fx+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cb,cc,eL,mP)if mO then fx[#fx+1]=e("%s'",mQ)else fx[#fx+1]=mR end;if hover then fx[#fx+1]=" style='stroke:white; stroke-width:2'"else fx[#fx+1]=" style='stroke:black; stroke-width:1'"end;fx[#fx+1]="></rect>"fx[#fx+1]=e("<text x='%f' y='%f' font-size='24' fill='",cb+eL/2,cc+mP/2+5)if mO then fx[#fx+1]="black"else fx[#fx+1]="white"end;fx[#fx+1]="' text-anchor='middle' font-family='Montserrat'>"if mO then fx[#fx+1]=e("%s</text>",mS)else fx[#fx+1]=e("%s</text>",mT)end end;local mU="rgb(50,50,50)'"local mV="rgb(210,200,200)"local mW=mN;for _,cZ in pairs(aG)do local lI=cZ.disableName;local lH=cZ.enableName;if type(lI)=="function"then lI=lI()end;if type(lH)=="function"then lH=lH()end;if not cZ.drawCondition or cZ.drawCondition()then mW(fx,cZ.toggleVar(),cZ.hovered,cZ.x,cZ.y,cZ.width,cZ.height,mV,mU,lI,lH)end end end;local mX=z(ResolutionX/2,0)local mY=z(ResolutionY/2,0)local fx={}b5.HUDPrologue(fx)if showHud then b5.UpdateHud(fx)else if AlwaysVSpd then b5.DrawVerticalSpeed(fx,as)end;b5.DisplayOrbitScreen(fx)b5.DrawWarnings(fx)end;if bM and bN~={}then b5.DrawSettings(fx)end;b5.HUDEpilogue(fx)fx[#fx+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aH,aI)if a1~="empty"then b5.DisplayMessage(fx,a1)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b5.DrawDeadZone(fx)end end;if w()==0 then if l()==1 and a0 then if not AltIsOn then mI()mM(fx)end;if not b8 and not b9 then local mZ=table.concat(fx,"")fx={}fx[#fx+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fx[#fx+1]=mZ;fx[#fx+1]="</body>"b8=true;fx[#fx+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fx,"")system.setScreen(content)elseif b9 then local mZ=table.concat(fx,"")fx={}fx[#fx+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aH,aI)fx[#fx+1]=mZ;fx[#fx+1]="</body>"end;if not b8 then fx[#fx+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mX,mY,af,ag)end else mH()end else if not a0 and l()==0 then mH()if ai>DeadZone then if DisplayDeadZone then mF(fx)end end elseif not AltIsOn then mI()mM(fx)end;fx[#fx+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],mX,mY,af,ag)end;fx[#fx+1]=[[</svg></body>]]content=table.concat(fx,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif ma=="apTick"then b7.APTick()b5.UpdateRadar()end end;function script.onFlush()local function m_(n0,kL)local n1=vec3()local n2=vec3()if n0==axisCommandId.longitudinal then n1=vec3(core.getConstructOrientationForward())n2=by elseif n0==axisCommandId.vertical then n1=vec3(core.getConstructOrientationUp())n2=bx elseif n0==axisCommandId.lateral then n1=vec3(core.getConstructOrientationRight())n2=bz else return vec3()end;local n3=vec3(core.getWorldGravity())local n4=n3:dot(n2)local n5=vec3(core.getWorldAirFrictionAcceleration())local n6=n5:dot(n2)local n7=vec3(core.getVelocity())local n8=n7:dot(n1)local n9=kL*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(n9-n8)local na=targetSpeedPID2:get()local nb=(na-n6-n4)*n2;return nb end;local function nc(n0,kL)local n1=vec3()local n2=vec3()if n0==axisCommandId.longitudinal then n1=vec3(core.getConstructOrientationForward())n2=by elseif n0==axisCommandId.vertical then n1=vec3(core.getConstructOrientationUp())n2=bx elseif n0==axisCommandId.lateral then n1=vec3(core.getConstructOrientationRight())n2=bz else return vec3()end;local n3=vec3(core.getWorldGravity())local n4=n3:dot(n2)local n5=vec3(core.getWorldAirFrictionAcceleration())local n6=n5:dot(n2)local n7=vec3(core.getVelocity())local n8=n7:dot(n1)local n9=kL*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(n9-n8)local na=targetSpeedPID:get()local nb=(na-n6-n4)*n2;return nb end;local function nd(ne,g0,jA)local nf=ne:cross(jA):normalize_inplace()local gN=math.acos(q(nf:dot(-g0),-1,1))*constants.rad2deg;if nf:cross(-g0):dot(jA)<0 then gN=-gN end;return gN end;if antigrav and not ExternalAGG then if not bH and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bJ=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bJ and N then cg(0)N=false elseif not bJ and not N then J=0;N=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local ng=q(S+T+system.getControlDeviceForwardInput(),-1,1)local nh=q(V+Y+system.getControlDeviceYawInput(),-1,1)local ni=q(W+U-system.getControlDeviceLeftRightInput(),-1,1)local nj=X;bC=vec3(core.getWorldVertical())if bC==nil or bC:len()==0 then bC=(planet.center-bE):normalize()end;bx=vec3(core.getConstructWorldOrientationUp())by=vec3(core.getConstructWorldOrientationForward())bz=vec3(core.getConstructWorldOrientationRight())bA=vec3(core.getWorldVelocity())bE=vec3(core.getConstructWorldPos())av=core.getConstructMass()bB=vec3(bA):len()bD=-bC:dot(bA)bL=getRoll(bC,by,bz)local nk=bL/180*math.pi;local nl=math.cos(nk)local nm=math.sin(nk)bK=nd(bC,by,bz*nl+bx*nm)local nn=bA:normalize()local no=c(bL)local np=utils.sign(bL)local nq=vec3(core.getWorldAngularVelocity())local nr=ng*pitchSpeedFactor*bz+nh*rollSpeedFactor*by+ni*yawSpeedFactor*bx;if ba==true and bC:len()>0.01 then local ns=c(be-bL)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and ns>0 or ar>0.0 and ns<autoRollRollThreshold and autoRollPreference)and nh==0 and c(bK)<85 then local nt=be;local nu=autoRollFactor;if ar==0 then nu=nu/4;be=0;nt=0 end;if rollPID==nil then rollPID=pid.new(nu*0.01,0,nu*0.1)end;rollPID:inject(nt-bL)local nw=rollPID:get()nr=nr+nw*by end end;if bC:len()>0.01 and ar>0.0 then local nx=20.0;if turnAssist==true and no>nx and ng==0 and ni==0 then local ny=turnAssistFactor*0.1;local nz=turnAssistFactor*0.025;local nA=(no-nx)/(180-nx)*180;local nB=0;if nA<90 then nB=nA/90 elseif nA<180 then nB=(180-nA)/90 end;nB=nB*nB;local nC=-np*nz*(1.0-nB)local nD=ny*nB;nr=nr+nD*bz+nC*bx end end;local nE=1;local nF=0;local nG=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nH=J;J=z(q(J+speedChangeLarge/100,-1,1),2)if J>=0 and nH<0 then J=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then bh=q(bh-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nH=J;J=z(q(J-speedChangeLarge/100,-1,1),2)if J<=0 and nH>0 then J=0;aw=false end end else aw=true end;K=0;if aq and AtmoSpeedAssist and bJ then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bh/3.6-bA:dot(by))local nI=throttlePID:get()M=q(nI,-1,1)if M<J and ar>0.005 then L=true;r:setThrottleCommand(axisCommandId.longitudinal,q(M,0.01,1))else L=false;r:setThrottleCommand(axisCommandId.longitudinal,J)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-bh/3.6)local nJ=q(brakePID:get(),0,1)if ar>0 and bD<-80 or ar>0.005 then K=nJ end;if K>0 then if L and M==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else M=q(M,0.01,1)end;local nK=''local nL=vec3()local nM=m_(axisCommandId.vertical,ae*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nM,nF)local nN='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nN=nN..ExtraLongitudeTags end;local nO=r:getAxisCommandType(axisCommandId.longitudinal)local nP=r:composeAxisAccelerationFromThrottle(nN,axisCommandId.longitudinal)local nQ=nc(axisCommandId.lateral,LeftAmount*1000)nK=nK..' , '.."lateral airfoil , lateral ground "nL=nL+nQ;if nL:len()>constants.epsilon then a:setEngineForceCommand(nK,nL,nF,'','','',nG)end;a:setEngineForceCommand(nN,nP,nE)local nR='thrust analog vertical fueled 'local nS='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nS=nS..ExtraLateralTags end;if ExtraVerticalTags~="none"then nR=nR..ExtraVerticalTags end;if ae~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nR,nM,nE)else a:setEngineForceCommand(nR,vec3(),nE)end;if LeftAmount~=0 then a:setEngineForceCommand(nS,nQ,nE)else a:setEngineForceCommand(nS,vec3(),nE)end;if nj==0 then nj=K end;local nT=-nj*(brakeSpeedFactor*bA+brakeFlatFactor*nn)a:setEngineForceCommand('brake',nT)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,J)end;local kL=unit.getAxisCommandValue(0)if not bJ then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bA:len()-kL/3.6)local nJ=q(brakePID:get(),0,1)nj=q(nj+nJ,0,1)end;local nT=-nj*(brakeSpeedFactor*bA+brakeFlatFactor*nn)a:setEngineForceCommand('brake',nT)local nK=''local nL=vec3()local nU=false;local nN='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nN=nN..ExtraLongitudeTags end;local nO=r:getAxisCommandType(axisCommandId.longitudinal)if nO==axisCommandType.byThrottle then local nP=r:composeAxisAccelerationFromThrottle(nN,axisCommandId.longitudinal)a:setEngineForceCommand(nN,nP,nE)elseif nO==axisCommandType.byTargetSpeed then local nP=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nK=nK..' , '..nN;nL=nL+nP;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then nU=true end end;local nS='thrust analog lateral 'if ExtraLateralTags~="none"then nS=nS..ExtraLateralTags end;local nV=r:getAxisCommandType(axisCommandId.lateral)if nV==axisCommandType.byThrottle then local nW=r:composeAxisAccelerationFromThrottle(nS,axisCommandId.lateral)a:setEngineForceCommand(nS,nW,nE)elseif nV==axisCommandType.byTargetSpeed then local nQ=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nK=nK..' , '..nS;nL=nL+nQ end;local nR='thrust analog vertical 'if ExtraVerticalTags~="none"then nR=nR..ExtraVerticalTags end;local nX=r:getAxisCommandType(axisCommandId.vertical)if nX==axisCommandType.byThrottle then local nM=r:composeAxisAccelerationFromThrottle(nR,axisCommandId.vertical)if ae~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nR,nM,nE,'airfoil','ground','',nG)else a:setEngineForceCommand(nR,vec3(),nE)a:setEngineForceCommand('airfoil vertical',nM,nE,'airfoil','','',nG)a:setEngineForceCommand('ground vertical',nM,nE,'ground','','',nG)end elseif nX==axisCommandType.byTargetSpeed then if ae<0 then a:setEngineForceCommand('hover',vec3(),nE)end;local nY=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nK=nK..' , '..nR;nL=nL+nY end;if nL:len()>constants.epsilon then if X~=0 or nU or c(nn:dot(by))<0.8 then nK=nK..', brake'end;a:setEngineForceCommand(nK,nL,nF,'','','',nG)end end;local nZ=torqueFactor*(nr-nq)local n_=vec3(core.getWorldAirFrictionAngularAcceleration())nZ=nZ-n_;a:setEngineTorqueCommand('torque',nZ,nE,'airfoil','','',nG)a:setBoosterCommand('rocket_engine')if a6 and not VanillaRockets then local eS=vec3(core.getVelocity()):len()local o0=0.15;if not bJ then local o1=r:getTargetSpeed(axisCommandId.longitudinal)if eS*3.6>o1*(1-o0)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eS*3.6<o1*(1-o0)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kE=unit.getThrottle()if AtmoSpeedAssist then kE=J*100 end;local kL=kE/100;if j==0 then kL=kL*MaxGameVelocity;if eS>=kL*(1-o0)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eS<kL*(1-o0)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kW=d(bh)kL=kL*kW/3.6;if eS>=kL*(1-o0)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eS<kL*(1-o0)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local ju=coroutine.status(beginSetup)if ju=="suspended"then local ch,jv=coroutine.resume(beginSetup)if jv then system.print("ERROR STARTUP: "..jv)end elseif ju=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not b8 and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(o2)local B=1;local function o3(o4)local function o5(o6,o4)local o7={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local o8=o6;for _,cZ in ipairs(o7)do if o4 and o8>cZ then o6=cZ elseif o6<cZ and not o4 then o6=cZ;break end end;return o6 end;if o4 then B=-1 end;if not ExternalAGG and bH then if a0 and o4 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+B*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a0 then bq=o5(bq,o4)else bq=bq+B*a2 end;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else if a0 and aq then HoldAltitude=o5(HoldAltitude,o4)else HoldAltitude=HoldAltitude+B*a2 end end else r:updateTargetGroundAltitudeFromActionStart(B*1.0)end end;local function o9(o4)if o4 then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+B*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,B*speedChangeLarge)end else if o4 then B=1 else B=nil end;b6.adjustAutopilotTargetIndex(B)end end;local function oa(ob)if not aq then a1="Flight Assist in Atmo only"return end;local d5=type(ob)if bT==nil then if d5=="table"then if Autopilot or VectorToTarget then ct()end;bY("180On","BR")elseif ob==1 then bY("bnkLft","BR")else bY("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cs()if d5~="table"then ob=ob+1 end end;bT=ob else bY("180Off","BR")bT=nil end end;if o2=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cg(0)if vBooster or hover then if aq and ao==-1 then bY("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;ba=true;GearExtended=false else if R then bY("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if R and not BrakeLanding and not(vBooster or hover)then bY("grOut","LG",1)a.control.extendLandingGears()end else if R then bY("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif o2=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif o2=="forward"then S=S-1 elseif o2=="backward"then if AltIsOn then oa(-bA*5000)else S=S+1 end elseif o2=="left"then if AltIsOn then oa(1)else V=V-1 end elseif o2=="right"then if AltIsOn then oa(3)else V=V+1 end elseif o2=="yawright"then W=W-1 elseif o2=="yawleft"then W=W+1 elseif o2=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif o2=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif o2=="up"then ae=ae+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif o2=="down"then ae=ae-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif o2=="groundaltitudeup"then o3()elseif o2=="groundaltitudedown"then o3(true)elseif o2=="option1"then b6.adjustAutopilotTargetIndex()toggleView=false elseif o2=="option2"then b6.adjustAutopilotTargetIndex(1)toggleView=false elseif o2=="option3"then local function oc()aF=not aF;if not aF then bY("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else bY("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oc()toggleView=false elseif o2=="option4"then bT=nil;ct()toggleView=false elseif o2=="option5"then function ToggleLockPitch()if LockPitch==nil then bY("lkPOn","LP")if not a0 then LockPitch=bK else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bY("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif o2=="option6"then cs()toggleView=false elseif o2=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a1="Collision System Enabled"else a1="Collision System Secured"end;toggleView=false elseif o2=="option8"then stablized=not stablized;if not stablized then a1="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()bY("gsOff","GS")else a1="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bY("gsOn","GS")end;toggleView=false elseif o2=="option9"then if gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bY("gyOn","GA")else bY("gyOff","GA")end end;toggleView=false elseif o2=="lshift"then if AltIsOn then a0=true end;if w()==1 then a0=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then a0=true;b9=false;b8=false end elseif o2=="brake"then if BrakeToggleStatus then cA()elseif not BrakeIsOn then cA()else BrakeIsOn=true end elseif o2=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif o2=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a6 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a6=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a6=false end elseif o2=="stopengines"then local function od()if C-D<1.5 then bY("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bT=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Z=false;O=false;al=false;am=false;Q=false;ba=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;od()D=C;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if J~=0 then r:resetCommand(axisCommandId.longitudinal)cg(0)else cg(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if aq then cj(AtmoSpeedLimit)else cj(MaxGameVelocity*3.6)end end end elseif o2=="speedup"then o9()elseif o2=="speeddown"then o9(true)elseif o2=="antigravity"and not ExternalAGG then if antigrav~=nil then cO()end end end;function script.onActionStop(o2)local function oe()if not ExternalAGG and bH then a5=a3 end;if AltitudeHold or VertTakeOff or IntoOrbit then a4=a2 end end;if o2=="forward"then S=0 elseif o2=="backward"then S=0 elseif o2=="left"then if bT then if bT==2 then bT=-2 else bT=-1 end end;V=0 elseif o2=="right"then if bT then if bT==4 then bT=-2 else bT=-1 end end;V=0 elseif o2=="yawright"then W=0 elseif o2=="yawleft"then W=0 elseif o2=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif o2=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif o2=="up"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o2=="down"then ae=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif o2=="groundaltitudeup"then oe()toggleView=false elseif o2=="groundaltitudedown"then oe()toggleView=false elseif o2=="lshift"then if w()==1 then af=0;ag=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b9=false;b8=false end;a0=false elseif o2=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cA()else BrakeIsOn=false end end elseif o2=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(o2)local B=1;local function of(o4)if o4 then B=-1 end;if not ExternalAGG and bH then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+B*a5;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a5=a5*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+B*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bq=bq+B*a4;if bq<planet.noAtmosphericDensityAltitude then bq=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+B*a4 end;a4=a4*1.05 else r:updateTargetGroundAltitudeFromActionLoop(B*1.0)end end;local function og(o4)if o4 then B=-1 end;if not a0 then if AtmoSpeedAssist and not AltIsOn then J=q(J+B*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,B*speedChangeSmall)end end end;if o2=="groundaltitudeup"then if not a0 then of()end elseif o2=="groundaltitudedown"then if not a0 then of(true)end elseif o2=="speedup"then og()elseif o2=="speeddown"then og(true)end end;function script.onInputText(cd)local function oh()for cY,cZ in pairs(c3())do dbHud_1.setStringValue(cZ,g(nil))end;for cY,cZ in pairs(b)do if cZ~="SavedLocations"then dbHud_1.setStringValue(cZ,g(nil))end end;a1="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ah=5 end;local function oi(fN,eW)local oj=false;local dd='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dq,dr,dy,dz,dA=n(eW,dd)for _,cZ in pairs(b1[0])do if cZ.name==fN then dz=math.rad(dz)dy=math.rad(dy)local planet=aX[y(dq)][y(dr)]local em=math.cos(dy)local ok=vec3(em*math.cos(dz),em*math.sin(dz),math.sin(dy))return planet.center+(planet.radius+dA)*ok end end;return fN.." not found"end;local function ol(om,planet,eW,gJ)local function on(eW)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dd='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dq,dr,dy,dz,dA=n(eW,dd)if dq=="0"and dr=="0"then return vec3(y(dy),y(dz),y(dA))end;dz=math.rad(dz)dy=math.rad(dy)local planet=aX[y(dq)][y(dr)]local em=math.cos(dy)local ok=vec3(em*math.cos(dz),em*math.sin(dz),math.sin(dy))return planet.center+(planet.radius+dA)*ok end;if dbHud_1 or gJ then local cy={}local position=on(eW)if planet.name=="Space"then cy={position=position,name=om,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cy={position=position,name=om,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;if not gJ then SavedLocations[#SavedLocations+1]=cy else for cY,cZ in pairs(aX[0])do if cZ.name and om==cZ.name then table.remove(aX[0],cY)end end end;table.insert(aX[0],cy)b6.UpdateAtlasLocationsList()else a1="Databank must be installed to save permanent locations"end end;local i;local oo,op=nil,nil;local oq="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cd," ")oo=cd;if i~=nil then oo=string.sub(cd,0,i-1)op=string.sub(cd,i+1)end;if oo=="/help"or oo=="/commands"then for il in string.gmatch(oq,"([^\n]+)")do system.print(il)end;return elseif oo=="/setname"then if op==nil or op==""then a1="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cv(op)else a1="Select a saved target to rename first"end elseif oo=="/addlocation"or string.find(cd,"::pos")~=nil then local gJ=false;local om="0-Temp"if op==nil or op==""then op=oo;gJ=true end;i=string.find(op,"::")if not gJ then om=string.sub(op,1,i-2)end;local eW=string.sub(op,i)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dd='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dq,dr,dy,dz,dA=n(eW,dd)local planet=aX[y(dq)][y(dr)]if planet.name=="Space"then local j4=vec3(y(dy),y(dz),y(dA))local dv=sys:closestBody(j4)if(j4-dv.center):len()<dv.radius+dv.noAtmosphericDensityAltitude then planet=dv end end;ol(om,planet,eW,gJ)a1="Added "..om.." to saved locations,\nplanet "..planet.name.." at "..eW;ah=5 elseif oo=="/agg"then if op==nil or op==""then a1="Usage: /agg targetheight"return end;op=y(op)if op<1000 then op=1000 end;AntigravTargetAltitude=op;a1="AGG Target Height set to "..op elseif oo=="/G"then if op==nil or op==""then a1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if op=="dump"then for cY,cZ in pairs(c3())do if type(_G[cZ])=="boolean"then if _G[cZ]==true then system.print(cZ.." true")else system.print(cZ.." false")end elseif _G[cZ]==nil then system.print(cZ.." nil")else system.print(cZ.." ".._G[cZ])end end;return end;i=string.find(op," ")local os=string.sub(op,0,i-1)local ot=string.sub(op,i+1)for cY,cZ in pairs(c3())do if cZ==os then a1="Variable "..os.." changed to "..ot;local ou=type(_G[cZ])if ou=="number"then ot=y(ot)elseif ou=="boolean"then if string.lower(ot)=="true"then ot=true else ot=false end end;_G[cZ]=ot;return end end;a1="No such global variable: "..os elseif oo=="/copydatabank"then if dbHud_2 then cU(true)else a1="Spare Databank required to copy databank"end elseif oo=="/iphWP"then if AutopilotTargetIndex>0 then system.print(b7.showWayPoint(ab,AutopilotTargetCoords,true))a1="::pos waypoint shown in lua chat"else a1="No target selected in IPH"end end end;function script.onEnter(dI)if radar_1 and not aq and not bQ then unit.setTimer("contact",0.1)end end;function script.onLeave(dI)if radar_1 and CollisionSystem then if#bU>650 then dI=tostring(dI)bU[dI]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
