name: ArchHud - Archaegeo v0.712 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.712;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=true;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},SaveStartingLocation={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(L)a9=L end,get=function()return a9 end},ResolutionY={set=function(L)aa=L end,get=function()return aa end},circleRad={set=function(L)ab=L end,get=function()return ab end},SafeR={set=function(L)ac=L end,get=function()return ac end},SafeG={set=function(L)ad=L end,get=function()return ad end},SafeB={set=function(L)ae=L end,get=function()return ae end},PvPR={set=function(L)af=L end,get=function()return af end},PvPG={set=function(L)ag=L end,get=function()return ag end},PvPB={set=function(L)ah=L end,get=function()return ah end},centerX={set=function(L)ai=L end,get=function()return ai end},centerY={set=function(L)aj=L end,get=function()return aj end},throtPosX={set=function(L)ak=L end,get=function()return ak end},throtPosY={set=function(L)al=L end,get=function()return al end},vSpdMeterX={set=function(L)am=L end,get=function()return am end},vSpdMeterY={set=function(L)an=L end,get=function()return an end},altMeterX={set=function(L)ao=L end,get=function()return ao end},altMeterY={set=function(L)ap=L end,get=function()return ap end},fuelX={set=function(L)aq=L end,get=function()return aq end},fuelY={set=function(L)ar=L end,get=function()return ar end},shieldX={set=function(L)as=L end,get=function()return as end},shieldY={set=function(L)at=L end,get=function()return at end},DeadZone={set=function(L)au=L end,get=function()return au end},OrbitMapSize={set=function(L)av=L end,get=function()return av end},OrbitMapX={set=function(L)aw=L end,get=function()return aw end},OrbitMapY={set=function(L)ax=L end,get=function()return ax end},soundVolume={set=function(L)ay=L end,get=function()return ay end}}aA=5;aB=1;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(L)aA=L end,get=function()return aA end},speedChangeSmall={set=function(L)aB=L end,get=function()return aB end},MouseXSensitivity={set=function(L)aC=L end,get=function()return aC end},MouseYSensitivity={set=function(L)aD=L end,get=function()return aD end},autoRollFactor={set=function(L)aE=L end,get=function()return aE end},rollSpeedFactor={set=function(L)aF=L end,get=function()return aF end},autoRollRollThreshold={set=function(L)aG=L end,get=function()return aG end},minRollVelocity={set=function(L)aH=L end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(L)aI=L end,get=function()return aI end},torqueFactor={set=function(L)aJ=L end,get=function()return aJ end},pitchSpeedFactor={set=function(L)aK=L end,get=function()return aK end},yawSpeedFactor={set=function(L)aL=L end,get=function()return aL end},brakeSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeFlatFactor={set=function(L)aN=L end,get=function()return aN end},DampingMultiplier={set=function(L)aO=L end,get=function()return aO end},apTickRate={set=function(L)aP=L end,get=function()return aP end},hudTickRate={set=function(L)aQ=L end,get=function()return aQ end},ExtraLongitudeTags={set=function(L)aR=L end,get=function()return aR end},ExtraLateralTags={set=function(L)aS=L end,get=function()return aS end},ExtraVerticalTags={set=function(L)aT=L end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={VertTakeOff={set=function(L)b5=L end,get=function()return b5 end},VertTakeOffEngine={set=function(L)aW=L end,get=function()return aW end},SpaceTarget={set=function(L)bt=L end,get=function()return bt end},BrakeToggleStatus={set=function(L)aV=L end,get=function()return aV end},BrakeIsOn={set=function(L)aX=L end,get=function()return aX end},RetrogradeIsOn={set=function(L)aY=L end,get=function()return aY end},ProgradeIsOn={set=function(L)aZ=L end,get=function()return aZ end},Autopilot={set=function(L)a_=L end,get=function()return a_ end},TurnBurn={set=function(L)b0=L end,get=function()return b0 end},AltitudeHold={set=function(L)b1=L end,get=function()return b1 end},BrakeLanding={set=function(L)b2=L end,get=function()return b2 end},Reentry={set=function(L)b4=L end,get=function()return b4 end},AutoTakeoff={set=function(L)b3=L end,get=function()return b3 end},HoldAltitude={set=function(L)b6=L end,get=function()return b6 end},AutopilotAccelerating={set=function(L)b7=L end,get=function()return b7 end},AutopilotBraking={set=function(L)b9=L end,get=function()return b9 end},AutopilotCruising={set=function(L)ba=L end,get=function()return ba end},AutopilotRealigned={set=function(L)b8=L end,get=function()return b8 end},AutopilotEndSpeed={set=function(L)bb=L end,get=function()return bb end},AutopilotStatus={set=function(L)bc=L end,get=function()return bc end},AutopilotPlanetGravity={set=function(L)bd=L end,get=function()return bd end},PrevViewLock={set=function(L)be=L end,get=function()return be end},AutopilotTargetName={set=function(L)bf=L end,get=function()return bf end},AutopilotTargetCoords={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetIndex={set=function(L)bh=L end,get=function()return bh end},TotalDistanceTravelled={set=function(L)bj=L end,get=function()return bj end},TotalFlightTime={set=function(L)bk=L end,get=function()return bk end},SavedLocations={set=function(L)bl=L end,get=function()return bl end},VectorToTarget={set=function(L)bm=L end,get=function()return bm end},LocationIndex={set=function(L)bn=L end,get=function()return bn end},LastMaxBrake={set=function(L)bo=L end,get=function()return bo end},LockPitch={set=function(L)bp=L end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(L)bq=L end,get=function()return bq end},AntigravTargetAltitude={set=function(L)br=L end,get=function()return br end},LastStartTime={set=function(L)bs=L end,get=function()return bs end},iphCondition={set=function(L)bw=L end,get=function()return bw end},stablized={set=function(L)bx=L end,get=function()return bx end},UseExtra={set=function(L)by=L end,get=function()return by end},SelectedTab={set=function(L)bC=L end,get=function()return bC end},saveRoute={set=function(L)bA=L end,get=function()return bA end}}local function bD(a,b,c,bE,bF,bG)bH=bE()bI=ac;bJ=ae;bK=ad;bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=false;bS=false;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;b_=false;c0=false;c1="empty"c2=false;c3=0;c4=0;c5=nil;c6=0;c7=0;c8=0;c9=0;ca=0;cb=3;cc=0;cd=""ce=false;cf=false;cg=false;ch=-1;ci=bG()>0;cj=bG()ck=b.getAltitude()cl=bE()cm=b.getConstructMass()cn=false;co=nil;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]cr=a9;cs=aa;ct={}cu={}cv={}cw=false;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=false;cH=false;cI=p;cJ=false;cK=0;cL=V;cM=0;cN=nil;cO={VectorToTarget=false}cP=0;cQ=false;cR=false;cS=false;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getVelocity())cX=vec3(b.getWorldVelocity())cY=vec3(cX):len()cZ=vec3(b.getWorldVertical())c_=-cZ:dot(cX)d0=vec3(b.getConstructWorldPos())d1=false;d2=false;d3=nil;d4=true;d5=0;d6=0;d7={}d8=false;d9=50000;da=nil;db={}dc=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;dd=false;de=nil;df=false;dg=0;dh=nil;di=nil;dj={}dk=90;dl=x;dm=nil;dn=nil;dp={}dq={}dr=false;ds=nil end;local function dt(d,b,c,a,du,dv,dw,dx,dy)local function dz(dA)return type(dA)=='number'end;local function dB(dA)return type(dw(dA))=='number'end;local function dC(dD)return type(dD)=='table'end;local function dE(a)return type(a)=='string'end;local function dF(dG)return dC(dG)and dz(dG.x and dG.y and dG.z)end;local function dH(dI)return dC(dI)and dz(dI.latitude and dI.longitude and dI.altitude and dI.id and dI.systemId)end;local dJ=math.pi/180;local dK=180/math.pi;local dL=1e-10;local dM=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dN='::pos{'..dM..','..dM..','..dM..','..dM..','..dM..'}'local utils=utils;local vec3=vec3;local function dO(dA)local dP=string.gsub(string.reverse(du('%.4f',dA)),'^0*%.?','')return dP==''and'0'or string.reverse(dP)end;local function dQ(dR)if dF(dR)then return du('{x=%.3f,y=%.3f,z=%.3f}',dR.x,dR.y,dR.z)end;if dC(dR)and not getmetatable(dR)then local dS={}local dT=next(dR)if type(dT)=='nil'or dT==1 then dS=dR else for dU,dG in pairs(dR)do local dV=dQ(dG)if type(dU)=='number'then table.insert(dS,du('[%s]=%s',dU,dV))else table.insert(dS,du('%s=%s',dU,dV))end end end;return du('{%s}',table.concat(dS,','))end;if dE(dR)then return du("'%s'",dR:gsub("'",[[\']]))end;return tostring(dR)end;local dW={}dW.__index=dW;dW.__tostring=function(dR,dX)local dY={}for dU in pairs(dR)do table.insert(dY,dU)end;table.sort(dY)local dS={}for dZ,dU in ipairs(dY)do local dV=dQ(dR[dU])if type(dU)=='number'then table.insert(dS,du('[%s]=%s',dU,dV))else table.insert(dS,du('%s=%s',dU,dV))end end;if dX then return du('%s%s',dX,table.concat(dS,',\n'..dX))end;return du('{%s}',table.concat(dS,','))end;dW.__eq=function(d_,e0)return d_.systemId==e0.systemId and d_.id==e0.id and dy(d_.radius,e0.radius)and dy(d_.center.x,e0.center.x)and dy(d_.center.y,e0.center.y)and dy(d_.center.z,e0.center.z)and dy(d_.GM,e0.GM)end;local function e1(e2,e3,e4,e5,e6)assert(dB(e2),'Argument 1 (systemId) must be a number:'..type(e2))assert(dB(e3),'Argument 2 (id) must be a number:'..type(e3))assert(dB(e4),'Argument 3 (radius) must be a number:'..type(e4))assert(dC(e5),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e5))assert(dB(e6),'Argument 5 (GM) must be a number:'..type(e6))return setmetatable({systemId=dw(e2),id=dw(e3),radius=dw(e4),center=vec3(e5),GM=dw(e6)},dW)end;local e7={}e7.__index=e7;e7.__tostring=function(e8)return du('::pos{%d,%d,%s,%s,%s}',e8.systemId,e8.id,dO(e8.latitude*dK),dO(e8.longitude*dK),dO(e8.altitude))end;e7.__eq=function(d_,e0)return d_.id==e0.id and d_.systemId==e0.systemId and dy(d_.latitude,e0.latitude)and dy(d_.altitude,e0.altitude)and(dy(d_.longitude,e0.longitude)or dy(d_.latitude,math.pi/2)or dy(d_.latitude,-math.pi/2))end;local function e9(ea,e3,eb,ec,ed)local e2=ea;if dE(ea)and not ec and not ed and not e3 and not eb then e2,e3,eb,ec,ed=ee(ea,dN)assert(e2,'Argument 1 (position string) is malformed.')else assert(dB(e2),'Argument 1 (systemId) must be a number:'..type(e2))assert(dB(e3),'Argument 2 (id) must be a number:'..type(e3))assert(dB(eb),'Argument 3 (latitude) must be in degrees:'..type(eb))assert(dB(ec),'Argument 4 (longitude) must be in degrees:'..type(ec))assert(dB(ed),'Argument 5 (altitude) must be in meters:'..type(ed))end;e2=dw(e2)e3=dw(e3)eb=dw(eb)ec=dw(ec)ed=dw(ed)if e3==0 then return setmetatable({latitude=eb,longitude=ec,altitude=ed,id=e3,systemId=e2},e7)end;return setmetatable({latitude=dJ*dv(eb,-90,90),longitude=dJ*(ec%360),altitude=ed,id=e3,systemId=e2},e7)end;local ef={}ef.__index=ef;ef.__tostring=function(dR,dX)local eg=dX and dX..'  'local eh={}local dY={}for dU in pairs(dR)do table.insert(dY,dU)end;table.sort(dY)for dZ,ei in ipairs(dY)do ej=dR[ei]local ek=dW.__tostring(ej,eg)if dX then table.insert(eh,du('[%s]={\n%s\n%s}',ei,ek,dX))else table.insert(eh,du('  [%s]=%s',ei,ek))end end;if dX then return du('\n%s%s%s',dX,table.concat(eh,',\n'..dX),dX)end;return du('{\n%s\n}',table.concat(eh,',\n'))end;local function el(em)local e={}local pid;for dZ,dG in pairs(em)do local e3=dG.planetarySystemId;if type(e3)~='number'then error('Invalid planetary s ID: '..tostring(e3))elseif pid and e3~=pid then error('Mistringmatch planetary s IDs: '..e3 ..' and '..pid)end;local en=dG.bodyId;if type(en)~='number'then error('Invalid body ID: '..tostring(en))elseif e[en]then error('Duplicate body ID: '..tostring(en))end;setmetatable(dG.center,getmetatable(vec3.unit_x))e[en]=setmetatable(dG,dW)pid=e3 end;return setmetatable(e,ef)end;eo={}local function ep(em)return setmetatable({galaxyAtlas=em or{}},eo)end;eo.__index=function(dD,L)if type(L)=='number'then local a=dD.galaxyAtlas[L]return el(a)end;return rawget(eo,L)end;eo.__pairs=function(dR)return function(dD,dU)local eq,er=next(dD,dU)return eq,er and el(er)end,dR.galaxyAtlas,nil end;eo.__tostring=function(dR)local es={}for dZ,et in pairs(dR or{})do local eu=et:getPlanetarySystemId()local ev=ef.__tostring(et,'    ')table.insert(es,du('  [%s]={%s\n  }',eu,ev))end;return du('{\n%s\n}\n',table.concat(es,',\n'))end;eo.BodyParameters=e1;eo.MapPosition=e9;eo.PlanetarySystem=el;function eo.createBodyParameters(e2,e3,ew,ex,ey,ez,eA)assert(dB(e2),'Argument 1 (systemId) must be a number:'..type(e2))assert(dB(e3),'Argument 2 (id) must be a number:'..type(e3))assert(dB(ew),'Argument 3 (surfaceArea) must be a number:'..type(ew))assert(dC(ex),'Argument 4 (aPosition) must be an array or vec3:'..type(ex))assert(dC(ey),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ey))assert(dB(ez),'Argument 6 (altitude) must be in meters:'..type(ez))assert(dB(eA),'Argument 7 (gravityAtPosition) must be number:'..type(eA))local e4=dx(ew/4/math.pi)local cc=e4+ez;local eB=vec3(ex)+cc*vec3(ey)local e6=eA*cc*cc;return e1(e2,e3,e4,eB,e6)end;eo.isMapPosition=dH;function eo:getPlanetarySystem(ea)if L==nil then L=0 end;if er==nil then er=0 end;local e2=ea;if dH(ea)then e2=ea.systemId end;if type(e2)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(er)~=ef then a=el(a)end;return a end end end;function ef:sizeCalculator(eC)return 1.05*eC.radius end;function ef:castIntersections(eD,eE,eF,eG,eH,eI)local eJ={}if eH then for dZ,eC in pairs(eH)do table.insert(eJ,eC)end else eJ=dj end;if not eI then table.sort(eJ,function(eK,eL)local eM=eK.center;local eN=eL.center;return(eM.x-eD.x)^2+(eM.y-eD.y)^2+(eM.z-eD.z)^2<(eN.x-eD.x)^2+(eN.y-eD.y)^2+(eN.z-eD.z)^2 end)end;local eO=eE:normalize()for dZ,eC in ipairs(eJ)do local eP=eC.center-eD;local e4=self:sizeCalculator(eC)local eQ=eP:dot(eO)local eR=eQ^2-(eP:len2()-e4^2)if eR>=0 then local eS=dx(eR)local eT=eQ+eS;local eU=eQ-eS;if eU>0 then return eC,eT,eU elseif eT>0 then return eC,eT,nil end end end;return nil,nil,nil end;function ef:closestBody(eV)assert(type(eV)=='table','Invalid coordinates.')local eW,eC;local eX=vec3(eV)for dZ,eY in pairs(self)do local eZ=(eY.center-eX):len2()if(not eC or eZ<eW)and eY.name~="Space"then eC=eY;eW=eZ end end;return eC end;function ef:convertToBodyIdAndWorldCoordinates(ea)local e_=ea;if dE(ea)then e_=e9(ea)end;if e_.id==0 then return 0,vec3(e_.latitude,e_.longitude,e_.altitude)end;local eY=self:getBodyParameters(e_)if eY then return e_.id,eY:convertToWorldCoordinates(e_)end end;function ef:getBodyParameters(ea)local e3=ea;if dH(ea)then e3=ea.id end;assert(dB(e3),'Argument 1 (id) must be a number:'..type(e3))return self[e3]end;function ef:getPlanetarySystemId()local dZ,dG=next(self)return dG and dG.systemId end;function dW:convertToMapPosition(e5)assert(dC(e5),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e5))local f0=vec3(e5)if self.id==0 then return setmetatable({latitude=f0.x,longitude=f0.y,altitude=f0.z,id=0,systemId=self.systemId},e7)end;local f1=f0-self.center;local cc=f1:len()local ed=cc-self.radius;local eb=0;local ec=0;if not dy(cc,0)then local f2=f3(f1.y,f1.x)ec=f2>=0 and f2 or 2*math.pi+f2;eb=math.pi/2-math.acos(f1.z/cc)end;return setmetatable({latitude=eb,longitude=ec,altitude=ed,id=self.id,systemId=self.systemId},e7)end;function dW:convertToWorldCoordinates(ea)local e_=dE(ea)and e9(ea)or ea;if e_.id==0 then return vec3(e_.latitude,e_.longitude,e_.altitude)end;assert(dH(e_),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e_.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(e_.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f4=math.cos(e_.latitude)return self.center+(self.radius+e_.altitude)*vec3(f4*math.cos(e_.longitude),f4*math.sin(e_.longitude),math.sin(e_.latitude))end;function dW:getAltitude(e5)return(vec3(e5)-self.center):len()-self.radius end;function dW:getDistance(e5)return(vec3(e5)-self.center):len()end;function dW:getGravity(e5)local f5=self.center-vec3(e5)local f6=f5:len2()return self.GM/f6*f5/dx(f6)end;return setmetatable(eo,{__call=function(dZ,...)return ep(...)end})end;local function f7(d,b,c,a,dx,f8)local cy={}local f9=30000000/3600;local fa=f9*f9;local fb=100;function cy.computeAccelerationTime(fc,fd,fe)local ff=f9*math.asin(fc/f9)return(f9*math.asin(fe/f9)-ff)/fd end;function cy.computeDistanceAndTime(fc,fe,fg,fh,fi,fj)fi=fi or 0;fj=fj or 0;local fk=fc<=fe;local fl=fh*(fk and 1 or-1)/fg;local fm=-fj/fg;local fn=fl+fm;if fk and fn<=0 or not fk and fn>=0 then return-1,-1 end;local fo,fp=0,0;if fl~=0 and fi>0 then local ff=math.asin(fc/f9)local fq=math.pi*(fl/2+fm)local fr=fl*fi;local fs=f9*math.pi;local dG=function(dD)local ft=(fq*dD-fr*math.sin(math.pi*dD/2/fi)+fs*ff)/fs;local fu=math.tan(ft)return f9*fu/dx(fu*fu+1)end;local fv=fk and function(a)return a>=fe end or function(a)return a<=fe end;fp=2*fi;if fv(dG(fp))then local fw=0;while f8(fp-fw)>0.5 do local dD=(fp+fw)/2;if fv(dG(dD))then fp=dD else fw=dD end end end;local fx=fc;local fy=fp/fb;for fz=1,fb do local fA=dG(fz*fy)fo=fo+(fA+fx)*fy/2;fx=fA end;if fp<2*fi then return fo,fp end;fc=fx end;local ff=f9*math.asin(fc/f9)local bH=(f9*math.asin(fe/f9)-ff)/fn;local fB=fa*math.cos(ff/f9)/fn;local cc=fB-fa*math.cos((fn*bH+ff)/f9)/fn;return cc+fo,bH+fp end;function cy.computeTravelTime(fc,fd,cc)if cc==0 then return 0 end;if fd>0 then local ff=f9*math.asin(fc/f9)local fB=fa*math.cos(ff/f9)/fd;return(f9*math.acos(fd*(fB-cc)/fa)-ff)/fd end;if fc==0 then return-1 end;assert(fc>0,'Acceleration and initial speed are both zero.')return cc/fc end;return cy end;local function fC(d,b,c,a,du,dv,dw,dx,dy)local vec3=vec3;local dt=dt(d,b,c,a,du,dv,dw,dx,dy)local function dE(a)return type(a)=='string'end;local function dC(dD)return type(dD)=='table'end;fD={}fD.__index=fD;function fD:escapeAndOrbitalSpeed(ed)assert(self.body)local cc=ed+self.body.radius;if not dy(cc,0)then local fE=dx(self.body.GM/cc)return dx(2)*fE,fE end;return nil,nil end;function fD:orbitalParameters(ea,fF)assert(self.body)assert(dC(ea)or dE(ea))assert(dC(fF))local fG=(dE(ea)or dt.isMapPosition(ea))and self.body:convertToWorldCoordinates(ea)or vec3(ea)local dG=vec3(fF)local fH=fG-self.body.center;local fI=dG:len2()local fJ=fH:len()local fK=self.body.GM;local fL=((fI-fK/fJ)*fH-fH:dot(dG)*dG)/fK;local eM=fK/(2*fK/fJ-fI)local fM=fL:len()local eO=fL:normalize()local fN=eM*(1-fM)local fO=eM*(1+fM)local fP=fN*eO+self.body.center;local fQ=fM<=1 and-fO*eO+self.body.center or nil;local fR=dx(eM*fK*(1-fM*fM))local fS=fQ and 2*math.pi*dx(eM^3/fK)local fT=math.acos(fL:dot(fH)/(fM*fJ))if fH:dot(dG)<0 then fT=-(fT-2*math.pi)end;local fU=math.acos((math.cos(fT)+fM)/(1+fM*math.cos(fT)))local fV=fU;if fV<0 then fV=fV+2*math.pi end;local fW=fV-fM*math.sin(fV)local fX=0;local fY=0;local fZ=0;if fS~=nil then fX=fW/(2*math.pi/fS)fY=fS-fX;fZ=fY+fS/2;if fT-math.pi>0 then fY=fX;fZ=fY+fS/2 end;if fZ>fS then fZ=fZ-fS end end;return{periapsis={position=fP,speed=fR/fN,circularOrbitSpeed=dx(fK/fN),altitude=fN-self.body.radius},apoapsis=fQ and{position=fQ,speed=fR/fO,circularOrbitSpeed=dx(fK/fO),altitude=fO-self.body.radius},currentVelocity=dG,currentPosition=fG,eccentricity=fM,period=fS,eccentricAnomaly=fU,meanAnomaly=fW,timeToPeriapsis=fY,timeToApoapsis=fZ,trueAnomaly=fT}end;local function f_(g0)local eY=dt.BodyParameters(g0.systemId,g0.id,g0.radius,g0.center,g0.GM)return setmetatable({body=eY},fD)end;return setmetatable(fD,{__call=function(dZ,...)return f_(...)end})end;local function g1(d,b,c,a,dbHud_1,e,g2,g3,bF,dw,dx,g4)local function g5(g6)local e8=g7:closestBody(g6)if(g6-e8.center):len()>e8.radius+e8.noAtmosphericDensityAltitude then e8=e[0][0]end;return e8 end;local function g8()local function g9(ga,gb)return ga.name<gb.name end;d7={}for dU,dG in pairs(e[0])do d7[#d7+1]={name=dG.name,index=dU}end;table.sort(d7,g9)end;local function gc(gd,ge)if not ge then ge=gf.name end;for dU,dG in pairs(gd)do if dG.name and dG.name==ge then return dU end end;return-1 end;local function gg()dg=bh;if bh==0 then bf="None"c5=nil;gf=nil;return true end;local gh=d7[bh].index;local gi=e[0][gh]if gi.center then bf=gi.name;c5=cx[0][gh]if gf~=nil then if cj==0 then if g2(gj,gk)~=1 then g3(gj,gk)end;if g2(gl,gm)~=1 then g3(gl,gm)end;if g2(gn,go)~=1 then g3(gn,go)end;if g2(gp,gq)~=1 then g3(gp,gq)end;if g2(gr,gs)~=1 then g3(gr,gs)end end;if g2(gt,gu)~=1 then g3(gt,gu)end;if g2(gv,gw)~=1 then g3(gv,gw)end;if g2(gx,gy)~=1 then g3(gx,gy)end end;gf=nil else gf=gi;for dZ,dG in pairs(cx[0])do if dG.name==gf.planetname then c5=dG;bf=gf.name;break end end;if g2(gt,gu)~=1 then g3(gt,gu)end;if g2(gv,gw)~=1 then g3(gv,gw)end end;if gf==nil then bg=vec3(c5.center)else bg=gf.position end;if c5.planetname~="Space"then if c5.hasAtmosphere then gz=bF(c5.radius*(T-1)+c5.noAtmosphericDensityAltitude)else gz=bF(c5.radius*(T-1)+c5.surfaceMaxAltitude)end else gz=S end;if gf~=nil and gf.planetname=="Space"then bb=0 else dZ,bb=cA(c5):escapeAndOrbitalSpeed(gz)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gA(gB)if not a_ and not bm and not cf and not bv and not b4 and not cg then if gB==nil then bh=bh+1;if bh>#d7 then bh=0 end else bh=bh-1;if bh<0 then bh=#d7 end end;if bh==0 then gg()else local gh=d7[bh].index;local gi=e[0][gh]if gi and(gi~=nil and gi.name=="Space"or bw=="Custom Only"and gi.center or bw=="No Moons"and string.find(gi.name,"Moon")~=nil)then if gB==nil then gA()else gA(1)end else gg()end end else c1="Disengage autopilot before changing Interplanetary Helper"g4("iph","AP")end end;local function gC()local function gD(gE)local gF;if gE then gF=dp else gF=bl end;local gG=-1;gG=gc(e[0])if gG>-1 then table.remove(e[0],gG)end;gG=-1;gG=gc(gF)if gG~=-1 then c1=gf.name.." saved location cleared"table.remove(gF,gG)end;gA()g8()return gF end;if string.sub(bf,1,1)=="*"then dp=gD(true)else bl=gD(false)end end;local function gH(gI,g6,gJ,gK)local function gL(gE)if gE then gF=dp else gF=bl end;if dbHud_1 or gJ or gE then local e8=g5(g6)local gM=e8.gravity;if gK then gM=c.getClosestPlanetInfluence()end;local gN={position=g6,name=gI,planetname=e8.name,gravity=gM,safe=gK}if not gJ then gF[#gF+1]=gN else for dU,dG in pairs(e[0])do if dG.name and gI==dG.name then table.remove(e[0],dU)end end end;table.insert(e[0],gN)g8()gg()c1="Location saved as "..gI.."("..e8.name..")"return gF else c1="Databank must be installed to save permanent locations"end end;if string.sub(gI,1,1)=="*"then dp=gL(true)else bl=gL(false)end end;local gO={}function gO.UpdateAtlasLocationsList()g8()end;function gO.UpdateAutopilotTarget()gg()end;function gO.adjustAutopilotTargetIndex(gB)gA(gB)end;function gO.findAtlasIndex(gd,ge)return gc(gd,ge)end;function gO.UpdatePosition(gP,gQ)local function gR(gE)local gF;if gE then gF=dp else gF=bl end;local gG=gc(gF)if gG~=-1 then if gP~=nil then if gE then gP="*"..gP end;gF[gG].name=gP;bh=bh-1;gA()else local gS=gF[gG]if gQ then gS.heading=cV:cross(cZ)*5000;c1=gF[gG].name.." heading saved ("..gF[gG].planetname..")"return elseif gQ==false then gS.heading=nil;c1=gF[gG].name.." heading cleared ("..gF[gG].planetname..")"return end;gS.gravity=c.getClosestPlanetInfluence()gS.position=d0;gS.safe=true end;c1=gF[gG].name.." position updated ("..gF[gG].planetname..")"else c1="Name Not Found"end end;if string.sub(bf,1,1)=="*"then gR(true)else gR(false)end end;function gO.AddNewLocation(gI,g6,gJ,gK)gH(gI,g6,gJ,gK)end;function gO.ClearCurrentPosition()gC()end;for dU,dG in pairs(dq)do table.insert(e[0],dG)end;g8()if bh>#d7 then bh=0 end;gO.UpdateAutopilotTarget()return gO end;local function gT(b,a,c,library,radar_1,radar_2,f8,gU,dx,gV,dw,gW,g4)local gX={}local gY={}local gZ={XS=13,S=27,M=55,L=110,XL=221}local g_={}local h0;local h1;local h2;local h3;local h4;local h5={}local h6="Atmo"local h7;local h8;local h9=0;local function ha()local function hb(hc,hd,he,hf,hg,hh,hi,hj)hd,hf,hh,hj=vec3(hd),vec3(hf),vec3(hh),vec3(hj)local hk,hl,hm=hc*hc,he*he,hg*hg;local fI=hf-hd;local hn=fI:normalize()local ho=fI:len()local hp=hh-hd;local hq=(hp-hp:project_on(hn)):normalize()local hr,hs=hp:dot(hn),hp:dot(hq)local ht=hr*hr+hs*hs;local hu=hn:cross(hq)local hv=(hk-hl+ho*ho)/(2*ho)local hw=(hk-hm+ht-2*hr*hv)/(2*hs)local dI=hk-hv^2-hw^2;local hx=dx(dI)local hy=hd+hn*hv+hq*hw+hu*hx;local hz=hd+hn*hv+hq*hw-hu*hx;if f8((hj-hy):len()-hi)<f8((hj-hz):len()-hi)then return hy else return hz end end;local function hA()local function hB()local hC=b.getConstructWorldOrientationRight()local fI=b.getConstructWorldOrientationForward()local hp=b.getConstructWorldOrientationUp()local hD=library.systemResolution3(hC,fI,hp,{1,0,0})local hE=library.systemResolution3(hC,fI,hp,{0,1,0})local hF=library.systemResolution3(hC,fI,hp,{0,0,1})return function(hG)return library.systemResolution3(hD,hE,hF,hG)end end;local hH=hB()local hI=b.getConstructWorldPos()local fG=b.getElementPositionById(1)local hJ={fG[1],fG[2],fG[3]}local hK=hH(hJ)local hL={hI[1]-hK[1],hI[2]-hK[2],hI[3]-hK[3]}return hL end;local function hM(hN,fJ,hO)local hP=hN.pts;local gG=#hP;local hQ=hN.ref;if gG>3 then local hR,hS,hT,hU=hP[gG],hP[gG-1],hP[gG-2],hP[gG-3]hN.ref=hO;local fG=hb(hR[1],hR[2],hS[1],hS[2],hT[1],hT[2],hU[1],hU[2])local hv,hw,hx=fG.x,fG.y,fG.z;if hv==hv and hw==hw and hx==hx then hv=hv+hQ[1]hw=hw+hQ[2]hx=hx+hQ[3]local hV=vec3(hv,hw,hx)if not hN.lastPos then hN.center=hV elseif(hN.lastPos-hV):len()<2 then hN.center=hV;hN.skipCalc=true end;hN.lastPos=hV end;hN.pts={}else local hW={hO[1]-hQ[1],hO[2]-hQ[2],hO[3]-hQ[3]}hP[gG+1]={fJ,hW}end end;if radar_1 or radar_2 then cE.assignRadar()end;if h5[1]then h0=#h5[1].getConstructIds()local hX=h5[1].getData()local hY=hX:gmatch('{"constructId[^}]*}[^}]*}')if h0>0 then local hO=hA()local hZ,h_=0,0;h4,h3=0,0;for dG in hY do local e3,cc,i0=dG:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local i1=gZ[i0]cc=dw(cc)if h5[1].hasMatchingTransponder(e3)==1 then table.insert(gY,e3)end;local i2=h5[1].getConstructType(e3)if F then if i1>27 or i2=="static"or i2=="space"then h4=h4+1;local gI=h5[1].getConstructName(e3)local hN=db[e3]if hN==nil then i1=i1+gW;db[e3]={pts={},ref=hO,name=gI,i=0,radius=i1,skipCalc=false}hN=db[e3]end;if not hN.skipCalc then hM(hN,cc,hO)h_=h_+1 end;if hN.center then table.insert(g_,hN)end end;hZ=hZ+1;if dc and hZ>700 or h_>70 or(not dc and hZ>300 or h_>30)then coroutine.yield()hZ,h_=0,0 end end end;h3=#g_;if h3>0 and cY>20 then local eC,i3,i4,i5;local i6=0;local i7=cx:getPlanetarySystem(0)i5=cX:normalize()while i6<h3 do coroutine.yield()local i8={table.unpack(g_,i6,math.min(i6+75,h3))}eC,i3,i4=i7:castIntersections(d0,i5,nil,nil,i8,true)if eC and i4 then de={eC,i3,i4}break end;i6=i6+75 end;if not eC then de=nil end else de=nil end;g_={}h1=hX:find('identifiedConstructs":%[%]')else h2=hX:find('worksInEnvironment":false')end end end;local function i9()if h5[1]then h6="Atmo"if h5[1].getData():find('worksInAtmosphere":false')then h6="Space"end end end;function gX.pickType()i9()end;function gX.assignRadar()if radar_1 and h5[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then h5[1]=radar_2 end;if h5[1]==radar_2 then i9()end elseif radar_2 and h5[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then h5[1]=radar_1 end;if h5[1]==radar_1 then i9()end end end;function gX.UpdateRadar()local ia=coroutine.status(h7)if ia=="suspended"then local dV,ib=coroutine.resume(h7)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then h7=coroutine.create(ha)local dV,ib=coroutine.resume(h7)end end;function gX.GetRadarHud(ic,id,ie,ig)local ih=gY;local ii,ij;gY={}local dM=h3 or 0;if h0>0 then if F then ij=dM.."/"..h4 .." Plotted : "..h0-h4 .." Ignored"else ij="Radar Contacts: "..h0 end;ii=gV(ie,ig,ij,"pbright txtbig txtmid")if#gY>0 then ii=ii..gV(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dU,dG in pairs(gY)do id=id+20;ii=ii..gV(ic,id,h5[1].getConstructName(dG),"pdim txtmid")end end;if h1==nil and h8==nil then h9=1;cE.ToggleRadarPanel()end;if h1~=nil and h8~=nil then cE.ToggleRadarPanel()end;if dn==nil then cE.ToggleRadarPanel()end else if h2 then ii=gV(ie,ig,h6 .." Radar: Jammed","pbright txtbig txtmid")else ii=gV(ie,ig,"Radar: No "..h6 .." Contacts","pbright txtbig txtmid")end;if dn~=nil then h9=0;cE.ToggleRadarPanel()end end;return ii end;function gX.GetClosestName(gI)if h5[1]then local e3,dZ=h5[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if e3~=nil and e3~=""then gI=gI.." "..h5[1].getConstructName(e3)end end;return gI end;function gX.ToggleRadarPanel()if dn~=nil and h9==0 then gU(dn)dn=nil;if h8~=nil then gU(h8)h8=nil end else if h9==1 then gU(dn)dn=nil;_autoconf.displayCategoryPanel(h5,1,"Periscope","periscope")h8=_autoconf.panels[_autoconf.panels_size]end;if dn==nil then _autoconf.displayCategoryPanel(h5,1,"Radar","radar")dn=_autoconf.panels[_autoconf.panels_size]end;h9=0 end end;function gX.ContactTick()if not ik then ik=0 end;if bH>ik+10 then c1="Radar Contact"g4("rdrCon","RC")ik=bH end;c.stopTimer("contact")end;function gX.onEnter(e3)if radar_1 and not ci and not d8 then c.setTimer("contact",0.1)end end;function gX.onLeave(e3)if radar_1 and F then if#db>650 then e3=tostring(e3)db[e3]=nil end end end;h5[1]=nil;if radar_1 then h5[1]=radar_1;i9()end;h7=coroutine.create(ha)return gX end;local function il(d,b,c,a,e,radar_1,radar_2,antigrav,hover,im,warpdrive,io,f8,bF,du,ip,bG,iq,ir,f3,bE,dv,is,g3,g2,gU,it,dx,iu,gV,g4,iv,iw,ix,iy,iz,iA)local iB=9.80665;local iC={}local iD={}local iE={}local iF={}local iG=nil;local iH=nil;local iI=nil;local iJ=false;local iK="none"local iL=""local iM=55;local iN=0;local iO=0;local iP=""local iQ=nil;local iR=vec3({13771471,7435803,-128971})local iS=18000000;local iT=500000;local iU,iV=math.huge;local iW;local function iX(iY)iU=vec3(iY):dist(iR)if iU<iS then return true,f8(iU-iS)end;iV=vec3(iY):dist(vec3(iZ.center))if iV<iT then iW=true else iW=false end;if f8(iV-iT)<f8(iU-iS)then return iW,f8(iV-iT)else return iW,f8(iU-iS)end end;local function i_(dG)if cr==1920 then return dG else return iu(cr*dG/1920,0)end end;local function j0(dG)if cs==1080 then return dG else return iu(cs*dG/1080,0)end end;local function j1()return it()==0 and g~="keyboard"and ir()==0 end;local function j2()local j3="TRAVEL"if not d4 then j3="CRUISE"end;if a_ then j3="AUTOPILOT"end;return j3 end;local ii=""local j4=""local j5=""local j6=1;local j7=2;local j8=3;local j9=4;local ja=5;local jb=6;local jc=""local jd=0;local je=bF(1/aP)*2*aQ;local jf={}local jg={}local jh={}local ji={}local jj={}local jk={}local jl={}jl["atmofueltank"],jl["spacefueltank"],jl["rocketfueltank"]=0,0,0;local jm=0;local function jn(hv,jo,jp,jq,jr,js)local jt=jm;local ju=jm+5;if not C then ju=ju+5 end;if ir()==1 and not l then jt=jt-50;ju=ju-50 end;if jp=="ATMO"then jc="atmofueltank"elseif jp=="SPACE"then jc="spacefueltank"else jc="rocketfueltank"end;jd=_G[jc.."_size"]if#jq>0 then for L=1,#jq do local gI=string.sub(jq[L][j7],1,12)local jv=0;for jw=1,jd do if jq[L][j7]==ip(c[jc.."_"..jw].getData()).name then jv=jw;break end end;local jx=bE()if jr[L]==nil or js[L]==nil or jx-jq[L][jb]>je then local jy;local jz=0;jz=iq(jq[L][j6])-jq[L][j9]jy=jq[L][ja]if jy>jz then jq[L][jb]=jx;jl[jc]=jl[jc]+jy-jz end;jq[L][ja]=jz;if jv~=0 then js[L]=ip(c[jc.."_"..jv].getData()).percentage;jr[L]=ip(c[jc.."_"..jv].getData()).timeLeft;if jr[L]=="n/a"then jr[L]=0 end else js[L]=bF(0.5+jz*100/jq[L][j8])if jy<=jz then jr[L]=0 else jr[L]=bF(0.5+jz/((jy-jz)/(jx-jq[L][jb])))end end end;if gI==jo then gI=du("%s %d",jp,L)end;if jv==0 then gI=gI.." *"end;local jA;if jr[L]==0 then jA=""else jA=iy(jr[L])end;if js[L]~=nil then local jB=bF(js[L]*2.55)local jC=du("rgb(%d,%d,%d)",255-jB,jB,0)local jD=""if jA~=""and jr[L]<120 or js[L]<5 then jD="red "end;local jE=du("rgb(%d,%d,%d)",dv(bF((255-jB)/2.55),50,100),dv(bF(jB/2.55),0,50),50)local jF="rgb(196,0,255)"if jp=="ATMO"then jF="rgb(0,188,255)"elseif jp=="SPACE"then jF="rgb(239,255,0)"end;local jG=false;if jH~=jF then jG=true end;jH=jF;if C then if jG then jt=jt-5;ju=ju-5 end;j4=j4 ..du([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jE,jF,hv,ju,jC,bF(js[L]*1.7+0.5)-2,hv+1,ju+1,hv+5,ju+14,gI,js[L],jA)jt=jt-22;ju=ju-22 else j4=j4 ..gV(hv,jt,gI,jD.."pdim txtfuel")j4=j4 ..gV(hv,ju,du("%d%% %s",js[L],jA),"pdim txtfuel","fill:"..jC)jt=jt+30;ju=ju+30 end end end end;jm=jt end;local function jI(jJ,ed)if am==0 and an==0 then return end;if ed<200000 and not ci or ed and ci then local jK=0;if f8(c_)>1 then jK=45*math.log(f8(c_),10)if c_<0 then jK=-jK end end;jJ[#jJ+1]=du([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bF(c_),bF(jK))end;return jJ end;local function jL(jM)local gB=-cZ;jM=jM-jM:project_on(gB)local jN=vec3(0,0,1)jN=jN-jN:project_on(gB)local jO=jN:cross(gB)local jK=jN:angle_between(jM)*constants.rad2deg;if jM:dot(jO)<0 then jK=360-jK end;return jK end;local function jP(jJ,ai,aj,jQ,jR,dc)if ab==0 then return end;local jS=ab;local jT=20;local jU=bF(jQ)if dc then for L=-45,45,5 do local jV=L;jJ[#jJ+1]=du([[<g transform="rotate(%f,%d,%d)">]],jV,ai,aj)jW=5;if L%15==0 then jW=15 elseif L%10==0 then jW=10 end;jJ[#jJ+1]=du([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jS+jT-jW,ai,aj+jS+jT)end;jJ[#jJ+1]=gV(ai,aj+jS+jT-35,jR,"pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj+jS+jT-25,jU.." deg","pdim txt txtmid")jJ[#jJ+1]=du([[<g transform="rotate(%f,%d,%d)">]],-jQ,ai,aj)jJ[#jJ+1]=du([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jS+jT-20,ai+5,aj+jS+jT-20,ai,aj+jS+jT-15)jJ[#jJ+1]="</g>"end;jJ[#jJ+1]=[[<g style="clip-path: url(#headingClip);">]]local jX=jU;if dc then jX=jL(cU)end;local jY=20;local jZ=bF(jX)local j_=0;local k0=aj+jS+jT+20;local k1=ai;if jR~="YAW"then k0=j0(130)k1=i_(960)end;local k2=[[<path class="txttick line" d="]]local k3=bF(jZ-(jY+10)-jZ%5+0.5)for L=k3+70,k3,-5 do local hv=k1-(-L*5+jX*5)if L%10==0 then j_=10;local dM=L;if dM==360 then dM=0 elseif dM>360 then dM=dM-360 elseif dM<0 then dM=dM+360 end;jJ[#jJ+1]=gV(hv,k0+15,dM,"txtmid bright")elseif L%5==0 then j_=5 end;if j_==10 then k2=du([[%s M %f %f v %d]],k2,hv,k0-5,j_)else k2=du([[%s M %f %f v %d]],k2,hv,k0-2.5,j_)end end;jJ[#jJ+1]=k2 ..[["/>]]jJ[#jJ+1]=du([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k1-5,k0-20,k1+5,k0-20,k1,k0-10)if I then if dc then jR="HDG"end;jJ[#jJ+1]=gV(i_(960),j0(100),jZ.."°","dim txt txtmid size14","")jJ[#jJ+1]=gV(i_(960),j0(85),jR,"dim txt txtmid size20","")end;jJ[#jJ+1]=[[</g>]]end;local function k4(jJ,k5,jQ,ai,aj,dc,k6,fA)if ab==0 then return end;local jS=ab;local k7=bF(jS*3/5)if jS>0 then local k8=bF(k5)local jW=0;local k2=du([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jQ,ai,aj)if not ci then k2=du([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jJ[#jJ+1]=du([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jS-1,ai,aj)jJ[#jJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bF(k8-30-k8%5+0.5),bF(k8+30+k8%5+0.5),5 do if L%10==0 then jW=30 elseif L%5==0 then jW=20 end;local hw=aj+-L*5+k5*5;if jW==30 then k2=du([[%s M %d %f h %d]],k2,ai-k7-jW,hw,jW)if ci then jJ[#jJ+1]=du([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jQ,ai,aj,ai-k7+10,hw+4,L)jJ[#jJ+1]=du([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jQ,ai,aj,ai+k7-10,hw+4,L)if L==0 or L==180 or L==-180 then jJ[#jJ+1]=du([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jQ,ai,aj,ai-k7+20,hw,k7*2-40)end else jJ[#jJ+1]=gV(ai-k7+10,hw,L,"pdim txt txtmid")jJ[#jJ+1]=gV(ai+k7-10,hw,L,"pdim txt txtmid")end;k2=du([[%s M %d %f h %d]],k2,ai+k7,hw,jW)else k2=du([[%s M %d %f h %d]],k2,ai-k7-jW,hw,jW)k2=du([[%s M %d %f h %d]],k2,ai+k7,hw,jW)end end;jJ[#jJ+1]=k2 ..[["/>]]local k9="PITCH"if not dc then k9="REL PITCH"end;if k5>90 and not ci then k5=90-(k5-90)elseif k5<-90 and not ci then k5=-90-(k5+90)end;if jS>200 then if ci then if fA>iM then jJ[#jJ+1]=gV(ai,aj-15,"Yaw","pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj+20,k6,"pdim txt txtmid")end;jJ[#jJ+1]=du([[<g transform="rotate(%f,%d,%d)">]],-jQ,ai,aj)else jJ[#jJ+1]=du([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jJ[#jJ+1]=du([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k7+25,aj-5,ai-k7+20,aj,ai-k7+25,aj+5,ai-k7+50,aj+4,k8)jJ[#jJ+1]=du([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k7-25,aj-5,ai+k7-20,aj,ai+k7-25,aj+5,ai+k7-30,aj+4,k8)jJ[#jJ+1]="</g>"end;local ka=bF(jS/3)jJ[#jJ+1]=du([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-ka,aj,jS-ka)if not ci and dc then jJ[#jJ+1]=du([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jQ,ai,aj,ai-k7+10,aj,k7*2-20)end;jJ[#jJ+1]="</g>"if jS<200 then if ci and fA>iM then jJ[#jJ+1]=gV(ai,aj-jS,k9,"pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj-jS+10,k8,"pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj-15,"Yaw","pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj+20,k6,"pdim txt txtmid")else jJ[#jJ+1]=gV(ai,aj-jS,k9,"pdim txt txtmid")jJ[#jJ+1]=gV(ai,aj-jS+15,k8,"pdim txt txtmid")end end end end;local function kb(jJ,ed,dc)local kc=ao;local kd=ap;if kc==0 and kd==0 then return end;local ke=78;local kf=19;local kg=ch;if ch~=-1 then jJ[#jJ+1]=gV(kc+ke,kd+kf+20,du("AGL: %.1fm",ch),"pdim altsm txtend")end;if dc and(ed<200000 and not ci or ed and ci)then table.insert(jJ,du([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kc-1,kd-4,ke+2,kf+6,kc+1,kd-1,ke-4,kf))local gG=0;local kh=1;local ki=0;local kj=ed<0;local kk=ed<iZ.surfaceMaxAltitude;local kl=9;if kj then kl=0 end;local ed=f8(ed)while gG<6 do local km=11;local kn=16;local ko=9;local kp=14;local jD="altsm"if gG>2 then kn=kn+3;km=km+2;kp=kp+2;ko=ko-6;jD="altbig"end;if kj then jD=jD.." red"elseif kk then jD=jD.." orange"end;local kq=ed/kh%10;local kr=bF(kq)local ks=bF((kr+1)%10)local kt=ki;if gG==0 then kt=kq-kr;if kj then kt=1-kt end end;if kj and(gG==0 or ki~=0)then local gJ=ks;ks=kr;kr=gJ end;local ku=kn*(kt-1)local kv=ku+kn;local hv=kc+ko+(6-gG)*km;local hw=kd+kp;jJ[#jJ+1]=gV(hv,hw+ku,ks,jD)jJ[#jJ+1]=gV(hv,hw+kv,kr,jD)gG=gG+1;kh=kh*10;if kr==kl then ki=kt else ki=0 end end;table.insert(jJ,[[</g></g>]])end end;local function kw(fF)local kx=-math.deg(f3(fF.y,fF.z))+180;kx=kx-90;if kx<0 then kx=360+kx end;if kx>180 then kx=-180+kx-180 end;return-kx end;local function ky(fF)local jX=math.deg(f3(fF.y,fF.x))-90;if jX<-180 then jX=360+jX end;return jX end;local function kz(jJ,fF,fA,ai,aj)if fA>5 and not ci or fA>iM then local jS=ab;local kA=20;local kB=20;local kC=kw(fF)local kD=ky(fF)local kE=14;local kF=kE/2;local kG=-kD/kB*jS;local kH=kC/kA*jS;local hv=ai+kG;local hw=aj+kH;local cc=dx(kG^2+kH^2)local kI=[[<circle
                            cx="]]..hv..[["
                            cy="]]..hw..[["
                            r="]]..kF/kE..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hv..[["
                            cy="]]..hw..[["
                            r="]]..kF..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hv-kE..[[,]]..hw..[[ h ]]..kF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hv+kF..[[,]]..hw..[[ h ]]..kF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hv..[[,]]..hw-kE..[[ v ]]..kF..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cc<jS then jJ[#jJ+1]=kI else local jK=f3(kH,kG)local kJ=4;local kK=ai+jS*math.cos(jK)local kL=aj+jS*math.sin(jK)jJ[#jJ+1]=du('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jK*180/math.pi,kK,kL,kK-kJ,kL-kJ/2,kJ*2,kJ,kK+kJ,kL-kJ,kJ,kJ,-kJ,kJ)end;if not ci then local kM=vec3(fF)kC=kw(-kM)kD=ky(-kM)kG=-kD/kB*jS;kH=kC/kA*jS;hv=ai+kG;hw=aj+kH;cc=dx(kG^2+kH^2)if cc<jS then local kN=[[<circle
                                    cx="]]..hv..[["
                                    cy="]]..hw..[["
                                    r="]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hv..[[,]]..hw-kE..[[ v ]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hv..[[,]]..hw..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hv..[[,]]..hw..[[)" />
                                <path
                                    d="M ]]..hv-kF..[[,]]..hw..[[ h ]]..kE..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hv..[[,]]..hw..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hv..[[,]]..hw..[[)"/>]]jJ[#jJ+1]=kN end end end end;local function kO(jJ,j3,kP,kQ)if ak==0 and al==0 then return end;kP=bF(kP+0.5)local jt=al+10;local ju=al+20;if ir()==1 and not l then jt=55;ju=65 end;local kR="CRUISE"local c="km/h"local dV=kQ;if j3=="TRAVEL"or j3=="AUTOPILOT"then kR="THROT"c="%"dV=kP;local kS="dim"if kP<0 then kS="red"end;jJ[#jJ+1]=du([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kS,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-f8(kP),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jJ[#jJ+1]=gV(ak+10,jt,kR,"pbright txtstart")jJ[#jJ+1]=gV(ak+10,ju,du("%.0f %s",dV,c),"pbright txtstart")if ci and u and d4 and bN then kP=bF(bO*100+0.5)local kS="red"if kP<0 then kS="red"end;jJ[#jJ+1]=du([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kS,1-f8(kP),ak-10,al+50,ak-15,al+53,ak-15,al+47)jJ[#jJ+1]=gV(ak+10,jt+40,"LIMIT","pbright txtstart")jJ[#jJ+1]=gV(ak+10,ju+40,kP.."%","pbright txtstart")end;if ci and u or b4 then jJ[#jJ+1]=gV(ak+10,jt-40,"LIMIT: "..cL.." km/h","dim txtstart")elseif not ci and a_ then jJ[#jJ+1]=gV(ak+10,jt-40,"LIMIT: "..bF(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kT(jJ,kU)if ak==0 and al==0 then return end;local kV=al-10;local kW=ak+10;jJ[#jJ+1]=gV(0,0,"","pdim txt txtend")if ir()==1 and not l then kV=75 end;jJ[#jJ+1]=gV(kW,kV,bF(kU).." km/h","pbright txtbig txtstart")end;local function kX(jJ)jJ[#jJ+1]=gV(i_(1900),j0(1070),du("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jJ[#jJ+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jJ[#jJ+1]=gV(i_(960),j0(550),"Warning: Invalid Control Scheme Detected","warnings")jJ[#jJ+1]=gV(i_(960),j0(600),"Keyboard Scheme must be selected","warnings")jJ[#jJ+1]=gV(i_(960),j0(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kY=i_(960)local kZ=j0(860)local k_=j0(880)local l0=j0(900)local l1=j0(960)local l2=j0(200)local l3=j0(250)local l4=j0(960)if ir()==1 and not l then kZ=j0(135)k_=j0(155)l0=j0(175)l2=j0(115)l3=j0(95)end;local l5="#222222"local l6="white"local l7="dimmer"local l8="pbright"local l9="#110000"local la=l5;local lb=l7;if aX then jJ[#jJ+1]=gV(kY,kZ,"Brake Engaged","warnings")l9="#440000"la=l6;lb=l8 elseif bM>0 then jJ[#jJ+1]=gV(kY,kZ,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local lc="#110000"local ld=l5;local le=l7;if ci and cJ and ch==-1 then if not a_ and not bm and not b2 and not d2 and not b5 and not b3 then jJ[#jJ+1]=gV(kY,l2+50,"** STALL WARNING **","warnings")lc="#ff0000"ld=l6;le=l8;g4("stall","SW",2)end end;if da then jJ[#jJ+1]=gV(kY,l2+90,"Flight Assist in Progress","warnings")end;if co then jJ[#jJ+1]=gV(kY,l4,"Gyro Enabled","warnings")end;local lf="#111100"local lg=l5;local lh=l7;if bi then lf="#775500"lg=l6;lh=l8;if bS then jJ[#jJ+1]=gV(kY,k_,"Gear Extended","warn")else jJ[#jJ+1]=gV(kY,k_,"Landed (G: Takeoff)","warnings")end;local li=ix(d:getTargetGroundAltitude())jJ[#jJ+1]=gV(kY,l0,"Hover Height: "..li,"warn")end;local lj="#000011"local lk=l5;local ll=l7;if c2 then lj="#0000DD"lk=l6;ll=l8;jJ[#jJ+1]=gV(kY,l1+20,"ROCKET BOOST ENABLED","warn")end;local lm="#001100"local ln=l5;local lo=l7;if antigrav and not q and d2 and br~=nil then lm="#00DD00"ln=l6;lo=l8;if f8(ck-antigrav.getBaseAltitude())<501 then jJ[#jJ+1]=gV(kY,l2+15,du("Target Altitude: %d Singularity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warn")else jJ[#jJ+1]=gV(kY,l2+15,du("Target Altitude: %d Singluarity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warnings")end elseif a_ and bf~="None"then jJ[#jJ+1]=gV(kY,l2+20,"Autopilot "..bc,"warn")elseif bp~=nil then jJ[#jJ+1]=gV(kY,l2+20,du("LockedPitch: %d",bF(bp)),"warn")elseif b_ then jJ[#jJ+1]=gV(kY,l2+20,"Follow Mode Engaged","warn")elseif b4 or cg then jJ[#jJ+1]=gV(kY,l2+20,"Re-entry in Progress","warn")end;if b1 or b5 then local li=ix(b6,2)if b5 then if d2 then li=ix(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jJ[#jJ+1]=gV(kY,l2,"VTO to "..li,"warn")elseif b3 and not bv then if cf then jJ[#jJ+1]=gV(kY,l2,"Takeoff to "..bf,"warn")else jJ[#jJ+1]=gV(kY,l2,"Takeoff to "..li,"warn")end;if aX and not b5 then jJ[#jJ+1]=gV(kY,l2+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jJ[#jJ+1]=gV(kY,l2,"Altitude Hold: "..li,"warn")end end;if b5 and(antigrav~=nil and antigrav)then if cj>0.1 then jJ[#jJ+1]=gV(kY,l2+20,"Beginning ascent","warn")elseif cj<0.09 and cj>0.05 then jJ[#jJ+1]=gV(kY,l2+20,"Aligning trajectory","warn")elseif cj<0.05 then jJ[#jJ+1]=gV(kY,l2+20,"Leaving atmosphere","warn")end end;if bv then if cN~=nil then jJ[#jJ+1]=gV(kY,l2,cN,"warn")end end;if b2 then if lp then jJ[#jJ+1]=gV(kY,l2,"Brake-Landing","warnings")else jJ[#jJ+1]=gV(kY,l2,"Coast-Landing","warnings")end end;if aZ then jJ[#jJ+1]=gV(kY,l2,"Prograde Alignment","crit")end;if aY then jJ[#jJ+1]=gV(kY,l2,"Retrograde Alignment","crit")end;local lq="#110000"local lr=l5;local ls=l7;if dd then lq="#FF0000"lr=l6;ls=l8;local type;if string.find(dd,"COLLISION")then type="warnings"else type="crit"end;jJ[#jJ+1]=gV(kY,l3+20,dd,type)elseif cj==0 then local lt,lu=cD.checkLOS(cX:normalize())if lu~=nil then ls=l8;lq="#FF0000"lr=l6;local li=ix(lu)local lv=cy.computeTravelTime(cY,0,lu)local lw="Collision"if lt.noAtmosphericDensityAltitude>0 then lw="Atmosphere"end;jJ[#jJ+1]=gV(kY,l3+20,lt.name.." "..lw.." "..iy(lv).." In "..li,"crit")end end;if bm and not bv then jJ[#jJ+1]=gV(kY,l2+35,lx,"warn")end;local ly="#111100"local lz=l5;local lA=l7;if dh and#dh>1 then ly="#DDDD00"lz=l6;lA=l8 end;local lB=i_;local lC=j0;local l7="topButton"local lD="topButtonActive"local lE=l7;if a_ or bm or cf or bv then lE=lD end;local lF=l7;if aZ then lF=lD end;local lG=l7;if b2 or bi then lG=lD end;local lH=l7;if b1 or bm then lH=lD end;local lI=l7;if aY then lI=lD end;local lJ=l7;if bv or cQ and a_ then lJ=lD end;if x and I then local lK=lC(30)jJ[#jJ+1]=du([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lB(960),lC(54),lC(-53),lB(-120),lB(25),lC(50))jJ[#jJ+1]=gV(lB(910),lK,"AUTOPILOT")jJ[#jJ+1]=du([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lB(865),lC(51),lB(-25),lC(-50),lB(-110),lB(25),lC(46))jJ[#jJ+1]=gV(lB(800),lK,"PROGRADE")jJ[#jJ+1]=du([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lB(755),lC(47),lB(-25),lC(-46),lB(-98),lB(44),lC(44))jJ[#jJ+1]=gV(lB(700),lK,"LAND")jJ[#jJ+1]=du([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lH,lB(960),lC(54),lC(-53),lB(120),lB(-25),lC(50))jJ[#jJ+1]=gV(lB(1010),lK,"ALT HOLD")jJ[#jJ+1]=du([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lB(1055),lC(51),lB(25),lC(-50),lB(110),lB(-25),lC(46))jJ[#jJ+1]=gV(lB(1122),lK,"RETROGRADE")jJ[#jJ+1]=du([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lB(1165),lC(47),lB(25),lC(-46),lB(98),lB(-44),lC(44))jJ[#jJ+1]=gV(lB(1220),lK,"ORBIT")jJ[#jJ+1]=[[
                                    </g>
                                </g>]]jJ[#jJ+1]="</g>"end;return jJ end;local function lL(fA)return bF(iu(fA*3.6,0)+0.5).." km/h"end;local function lM(gG)local gI=bf;if gG~=nil and type(gG)=="number"then if gG==0 then return"None"end;gI=d7[gG].name end;if gI==nil then gI=gf.name end;if gI==nil then gI="None"end;return gI end;local function lN(jJ)local lO=cD.routeWP(true)if not lO or#lO==0 then return end;local hv=i_(750)local hw=j0(360)if a_ or bm then jJ[#jJ+1]=gV(hv,hw,"REMAINING ROUTE","pdim txtstart size20")else jJ[#jJ+1]=gV(hv,hw,"LOADED ROUTE","pdim txtstart size20")end;for dU,L in pairs(lO)do hw=hw+20;jJ[#jJ+1]=gV(hv,hw,dU..". "..lM(lO[dU]),"pdim txtstart size20")end end;local function lP(jJ)local hv=aw+10;local hw=ax+20;local lQ={}local lR={"Alt-4: AutoTakeoff to Target"}local lS={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lT={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lU={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lQ,"--------------DYNAMIC-----------------")if ci then if ch~=-1 then iv(lQ,lR)if c5 and iZ and c5.name==iZ.name then table.insert(lQ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if d2 then table.insert(lQ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lQ,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lQ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lQ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lQ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lQ,"G: Takeoff to hover height, raise gear")else table.insert(lQ,"G: Lowergear and Land")end else iv(lQ,lS)table.insert(lQ,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lQ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iv(lQ,lT)if im then table.insert(lQ,"Alt-Shift-6: Vent shields")table.insert(lQ,"Alt-Shift-7: Toggle shied off/on")end end;if gf~=nil then table.insert(lQ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lQ,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lQ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lQ,"Alt-Spacebar/C will raise/lower target height")table.insert(lQ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ci then table.insert(lQ,"LALT+Mousewheel will lower/raise speed limit")end;iv(lQ,lU)for L=1,#lQ do hw=hw+12;jJ[#jJ+1]=gV(hv,hw,lQ[L],"pdim txtbig txtstart")end end;local function lV(jJ)local lW=aw;local lX=ax;local lY=av;local lZ=4;local l_=15;local hv=0;local hw=0;local m0,m1,m2,m3;local m4;local function m5(type)local m6,bH,fA,m7,jD,m8;if type=="Periapsis"then m6=m4.periapsis.altitude;bH=m4.timeToPeriapsis;fA=m4.periapsis.speed;jD="txtend"m7=12;m8=math.min(hv,lW+lY-iZ.radius/m2-lZ*2)else m6=m4.apoapsis.altitude;bH=m4.timeToApoapsis;fA=m4.apoapsis.speed;m7=-12;jD="txtstart"m8=hv end;if cY<1 then bH=0 end;jJ[#jJ+1]=du([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8+m7,hw-5,hv,hw-5)jJ[#jJ+1]=du([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m8-m7*4,hw+2,hv,hw+2)jJ[#jJ+1]=gV(m8,hw,type,jD)hv=m8-m7*2;hw=hw+l_;local li=ix(m6)jJ[#jJ+1]=gV(hv,hw,li,jD)hw=hw+l_;jJ[#jJ+1]=gV(hv,hw,iy(bH),jD)hw=hw+l_;jJ[#jJ+1]=gV(hv,hw,lL(fA),jD)end;local m9=lY*1.5;if bC=="INFO"then m9=25*9 end;if bC~="HIDE"then jJ[#jJ+1]=[[<g class="pbright txtorb txtmid">]]jJ[#jJ+1]=du('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lY*2,m9,lW,lX)jJ[#jJ+1]=du([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lY*2,m9,lW,lX)end;local ma=lY*1.5;local mb=lY*2;local mc=ma/2;local md=lY;local me=lW+md;local mf=lX+mc;local mg=lW+mb;local mh=lX+ma;if bC=="ORBIT"then lX=lX+lZ;m0=lY/2;m3=0;m4={}m4.periapsis={}m4.apoapsis={}if fE~=nil then if fE.periapsis~=nil then m4.periapsis.altitude=fE.periapsis.altitude;m4.periapsis.speed=fE.periapsis.speed end;if fE.apoapsis~=nil then m4.apoapsis.altitude=fE.apoapsis.altitude;m4.apoapsis.speed=fE.apoapsis.speed end;m4.period=fE.period;m4.eccentricity=fE.eccentricity;m4.timeToApoapsis=fE.timeToApoapsis;m4.timeToPeriapsis=fE.timeToPeriapsis;m4.eccentricAnomaly=fE.eccentricAnomaly;m4.trueAnomaly=fE.trueAnomaly end;if m4.periapsis==nil then m4.periapsis={}m4.periapsis.altitude=-iZ.radius;m4.periapsis.speed=a0 end;if m4.eccentricity==nil then m4.eccentricity=1 end;if m4.apoapsis==nil then m4.apoapsis={}m4.apoapsis.altitude=ck;m4.apoapsis.speed=0 end;if cY<1 then m4.apoapsis.altitude=ck;m4.apoapsis.speed=0 end;if m4.apoapsis.altitude then m2=(m4.apoapsis.altitude+m4.periapsis.altitude+iZ.radius*2)/(m0*2)m1=(iZ.radius+m4.apoapsis.altitude)/m2*(1-m4.eccentricity)m3=m0-m4.periapsis.altitude/m2-iZ.radius/m2;local mi=math.pi;if m4.period~=nil and m4.period>0 and m4.timeToApoapsis~=nil then mi=m4.eccentricAnomaly;if m4.timeToPeriapsis<m4.timeToApoapsis then mi=2*math.pi-mi end end;if cY<1 or mi~=mi then mi=math.pi end;local mj=-m0*math.cos(mi)+lW+md+lZ;local mk=m1*math.sin(mi)+lX+mc+lZ;local ml=""jJ[#jJ+1]='<g clip-path="url(#orbitRect)">'jJ[#jJ+1]=du([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ml,lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)if m1<1 then jJ[#jJ+1]=du([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lW+lY+lZ-m3,lX+lY*1.5/2+lZ,mj,mk)end;jJ[#jJ+1]=du('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(iZ.radius+iZ.noAtmosphericDensityAltitude)/m2)jJ[#jJ+1]=du('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(iZ.radius+iZ.noAtmosphericDensityAltitude)/m2)jJ[#jJ+1]=du([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)jJ[#jJ+1]=du('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,iZ.radius/m2)jJ[#jJ+1]='</g>'local mm=math.floor(iZ.radius/m2+0.5)hv=lW+lY+lZ*4+m0;hw=lX+lY*1.5/2+5+lZ;if m4.apoapsis~=nil and m4.apoapsis.speed<a0 then m5("Apoapsis")end;hw=lX+lY*1.5/2+5+lZ;hv=lW+lY-lZ*2-m0;if m4.periapsis~=nil and m4.periapsis.speed<a0 and m4.periapsis.altitude>0 then m5("Periapsis")end;jJ[#jJ+1]=gV(lW+lY+lZ,lX+20+lZ,iZ.name,"txtorbbig")jJ[#jJ+1]=du('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mj,mk)jJ[#jJ+1]=[[</g>]]return jJ else jJ[#jJ+1]='<g clip-path="url(#orbitRect)">'local mn=""local mo=1.2*(mp-mq)/(lY*2)local mr=1.4*(ms-mt)/(lY*1.5)for dU,dG in pairs(e[0])do if dG.center then local hv=lW+lY+dG.center.x/mo;local hw=lX+lY*1.5/2+dG.center.y/mr;mn=mn..'<circle cx="'..hv..'" cy="'..hw..'" r="'..dG.radius/mo*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dG.name,"Moon")and not string.match(dG.name,"Sanctuary")and not string.match(dG.name,"Space")then mn=mn.."<text x='"..hv.."' y='"..hw+dG.radius/mo*30+20 .."' font-size='12' fill="..cp.." text-anchor='middle' font-family='Montserrat'>"..dG.name.."</text>"end end end;local fG=vec3(b.getConstructWorldPos())local hv=lW+lY+fG.x/mo;local hw=lX+lY*1.5/2+fG.y/mr;mn=mn..'<circle cx="'..hv..'" cy="'..hw..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mn=mn.."<text x='"..hv.."' y='"..hw-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iG=mo;iH=mr;local mu=fG+cX*1000000;local mv=lW+lY+mu.x/mo;local ju=lX+lY*1.5/2+mu.y/mr;mn=mn..'<line x1="'..hv..'" y1="'..hw..'" x2="'..mv..'" y2="'..ju..'" stroke="purple" stroke-width="1"/>'jJ[#jJ+1]=mn;jJ[#jJ+1]='</g>'end elseif bC=="INFO"then jJ=cB.DrawOdometer(jJ,c6,bj,c7)elseif bC=="HELP"then jJ=lP(jJ)elseif bC=="SCOPE"then jJ[#jJ+1]='<g clip-path="url(#orbitRect)">'local mw=dk;if cj>0 then table.sort(dj,function(eK,eL)local eM,eN=eK.center,eL.center;return(eM.x-d0.x)^2+(eM.y-d0.y)^2+(eM.z-d0.z)^2<(eN.x-d0.x)^2+(eN.y-d0.y)^2+(eN.z-d0.z)^2 end)end;local h2={}local mx={}local my=120;local mz=nil;local mA=nil;for L,dG in ipairs(dj)do local h1=dG.center-d0;local mB=h1:len()local mC=h1:normalize()local mD=h1:cross(cU):normalize()local mE=math.acos(mD:dot(cV))if mE~=mE then mE=0 end;if mD:cross(cV):dot(cU)<0 then mE=-mE end;local mF=h1:project_on_plane(cU):len()local mG=math.sin(mE)*math.asin(mF/mB)*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/mB)*constants.rad2deg;if mC:dot(cU)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hv=me+mG/mw*ma;local hw=mf+mH/mw*ma;local mI=(hv-me)*(hv-me)+(hw-mf)*(hw-mf)local mJ=math.asin((dG.radius+dG.surfaceMaxAltitude)/mB)*constants.rad2deg;if mJ~=mJ then mJ=mw end;local i0=mJ/mw*ma;local mK=math.asin(dG.atmosphereRadius/mB)*constants.rad2deg;if mK~=mK then mK=mJ end;local mL=mK/mw*ma;local cc=ix(mB,1)local mM=dG.name;local mN=false;if hw>lX then if hw>mh then if hw-mL<=mh then mN=true end else mN=true end else if hw+mL>=lX then mN=true end end;local mO=false;local mP=hv;if dG.systemId==0 then mP=hv+my else mP=hv-my end;if mP+my>lW then if mP+my>mg then if mP-mL-my<=mg then mO=true end else mO=true end else if mP+mL+my>=lW then mO=true end end;local mQ={}mQ.x=hv;mQ.y=hw;mQ.planet=dG;mQ.atmoSize=mL;if not mz or mI<mz then mz=mI;mA=mQ end;if mO and mN then local mR=math.max(mL,5)if mI<mR*mR then mM=mM.." - "..cc end;mQ.size=i0;mQ.i=L;mQ.displayString=mM;mQ.distance=cc;mQ.visible=true;mx[#mx+1]=mQ else mQ.visible=false end end;local mS=false;table.sort(mx,function(eM,eN)return eM.y<eN.y end)for dU,fJ in ipairs(mx)do local dG,i0,L,mL,hv,hw,mM,cc=fJ.planet,fJ.size,fJ.i,fJ.atmoSize,fJ.x,fJ.y,fJ.displayString,fJ.distance;local m8,mT,mU,mV;local mW=15;local jD="pdim"if dG.systemId~=0 then mU=i_(string.len(mM)*5)mW=-(15+mU)mV=j0(10)jD="pdimfill"else mU=i_(string.len(mM)*9)mV=j0(15)end;if i0*2>mU then m8=dv(hv,lW+mU/2,mg-mU/2)mT=dv(hw,lX+mV,mh-5)m8=dv(m8,hv-i0+mU/2,hv+i0-mU/2)mT=dv(mT,hw-i0+mV,hw+i0)else m8=hv+mW;mT=hw end;for mX,fJ in pairs(h2)do local mY=fJ.textPositions;local mZ=mY.y-mT;if mX~=L and f8(mZ)<mY.height and mY.x+mY.width>m8 and mY.x<m8+mU then if i0>mU then mT=dv(mT+mV,lX+15,mh-5)else mT=mY.y+mY.height+1 end end end;local m_=mM~=dG.name or m8<=me and m8+mU>=me and mT-mV<=mf and mT>=mf;fJ.hovered=m_;local n0=1;if m_ then n0=2;if i0*2<mU then n0=10 end;if mM==dG.name then mM=mM.." - "..cc end;jD="pbright"if dG.systemId~=0 then mU=i_(string.len(mM)*5)mW=-(15+mU)else mU=i_(string.len(mM)*7)end;if i0*2>mU then m8=dv(hv,lW+mU/2,mg-mU/2)m8=dv(m8,hv-i0+mU/2,hv+i0-mU/2)else m8=hv+mW end end;h2[L]={}h2[L].textPositions={}h2[L].textPositions.y=mT;h2[L].textPositions.x=m8;h2[L].textPositions.width=mU;h2[L].textPositions.height=mV;h2[L].output=""if i0*2>mU then jD=jD.." txtmid"else jD=jD.." txtstart"end;if mL-i0>2 then h2[L].output=du('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hv,hw,mL,cq,0.1*n0)end;h2[L].output=h2[L].output..du('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hv,hw,i0,cq,0.2*n0)if dG.systemId==0 then h2[L].output=h2[L].output..du([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mT,cp,jD,mM)if i0*2<=mU then h2[L].output=h2[L].output..du("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8+mU,mT+2,m8,mT+2,hv,hw)end else h2[L].output=h2[L].output..du([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m8,mT,cq,jD,mM)if i0*2<=mU then h2[L].output=h2[L].output..du("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m8,mT+2,m8+mU,mT+2,hv,hw)end end end;for dU=#dj,1,-1 do if h2[dU]then jJ[#jJ+1]=h2[dU].output end end;if mA~=nil and dk<90 and not mA.hovered then local n1=mA.planet.atmosphereRadius/mA.atmoSize;local n2=dx(mz)*n1;local n3=ix(n2,1)local mU=i_(math.max(string.len(n3)*7,string.len(mA.planet.name)*7))local mV=j0(12)local m8=dv(mA.x+(me-mA.x)/2,lW+mU/2,mg-mU/2)local mT=dv(mA.y+(mf-mA.y)/2,lX+mV*2,mh-5)jJ[#jJ+1]=du("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mA.x,mA.y,me,mf)jJ[#jJ+1]=du([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mT,"white",n3)if not mA.visible then jJ[#jJ+1]=du([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m8,mT-mV,"white",mA.planet.name)end end;if cY>1 then local h1=cX;local mC=h1:normalize()local mF=h1:project_on_plane(cU):len()local mD=h1:cross(cU):normalize()local mE=math.acos(mD:dot(cV))if mE~=mE then mE=0 end;if mD:cross(cV):dot(cU)<0 then mE=-mE end;local mG=math.sin(mE)*math.asin(mF/h1:len())*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/h1:len())*constants.rad2deg;if mC:dot(cU)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hv=me+mG/mw*ma;local hw=mf+mH/mw*ma;local kE=14;local kF=kE/2;local kI=[[<circle
                                    cx="]]..hv..[["
                                    cy="]]..hw..[["
                                    r="]]..kF/kE..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hv..[["
                                    cy="]]..hw..[["
                                    r="]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hv-kE..[[,]]..hw..[[ h ]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hv+kF..[[,]]..hw..[[ h ]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hv..[[,]]..hw-kE..[[ v ]]..kF..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jJ[#jJ+1]=kI end;jJ[#jJ+1]=du("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me,mf-10,me,mf+10)jJ[#jJ+1]=du("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",me-10,mf,me+10,mf)jJ[#jJ+1]='</g>'else return jJ end end;local function n4(n5,n6)local n7;local n8=(n6-n5):normalize()local fH=(d0-n5):dot(n8)/n8:dot(n8)if fH<=0. then return(d0-n5):len()elseif fH>=(n6-n5):len()then return(d0-n6):len()end;local n9=n5+fH*n8;n7=(n9-d0):len()return n7 end;local function na()local n7;local nb=nil;local nc=nil;local nd=nil;for dU,ne in pairs(e[0])do if ne.hasAtmosphere then local cc=n4(iZ.center,ne.center)if nb==nil or cc<nb then nc=ne;nb=cc;nd=iZ end;if c5 and c5.hasAtmosphere and c5.name~=iZ.name then local eZ=n4(c5.center,ne.center)if eZ<nb then nc=ne;nb=eZ;nd=c5 end end end end;local nf=i_(1770)local ng=j0(330)if nb then local nh="txttick "local ni=500000;if nb<nc.radius+ni or nb<nd.radius+ni then if d8 then nh="txttick red "else nh="txttick orange "end end;n7=ix(nb,2)iL=gV(nf,ng,"Pipe ("..nd.name.."--"..nc.name.."): "..n7,nh.."pbright txtmid")end end;local function nj(hv,hw,nk,nl,kR)local nm={x=hv,y=hw,width=nk,height=nl,label=kR}iF[kR]=nm;return nm end;local function nn(no,np,nk,nl,hv,hw,nq,nr,ns,nt,jD)local nm={enableName=no,disableName=np,width=nk,height=nl,x=hv,y=hw,toggleVar=nq,toggleFunction=nr,drawCondition=ns,hovered=false,class=jD}if nt then table.insert(iE,nm)else table.insert(iD,nm)end;return nm end;local function nu(nv)if not iJ then nw=false;nx=false;ny=false;x=true;return elseif nv=="handling"then nw=not nw;nx=false;ny=false elseif nv=="hud"then nx=not nx;nw=false;ny=false elseif nv=="physics"then ny=not ny;nw=false;nx=false end;if ny or nx or nw then iK=iw(nv)x=false else iK="none"x=true end end;local function nz()iJ=not iJ;if iJ then iC=iE;c1="Hold SHIFT to see Settings"dl=x else iC=iD;c1="Hold SHIFT to see Control Buttons"nu()x=dl end end;local function nA()local function nB(dG,dU)dG.set(not dG.get())if dG.get()then c1=dU.." set to true"else c1=dU.." set to false"end;if dU=="showHud"then dl=dG.get()elseif dU=="BrakeToggleDefault"then aV=j end end;local nC=50;local nD=340;local hv=500;local hw=cs/2-400;local nE=0;for dU,dG in pairs(iw("boolean"))do if type(dG.get())=="boolean"then nn(dU,dU,nD,nC,hv,hw,function()return dG.get()end,function()nB(dG,dU)end,function()return true end,true)hw=hw+nC+20;if nE==9 then hv=hv+nD+20;hw=cs/2-400;nE=0 else nE=nE+1 end end end;nn("Control View","Control View",nD,nC,10,cs/2-500,function()return true end,nz,function()return true end,true)nn("View Handling Settings",'Hide Handling Settings',nD,nC,10,cs/2-(500-nC),function()return nw end,function()nu("handling")end,function()return true end,true)nn("View Hud Settings",'Hide Hud Settings',nD,nC,10,cs/2-(500-nC*2),function()return nx end,function()nu("hud")end,function()return true end,true)nn("View Physics Settings",'Hide Physics Settings',nD,nC,10,cs/2-(500-nC*3),function()return ny end,function()nu("physics")end,function()return true end,true)end;local function nF()local function gH()local g6=d0;local gI=iZ.name..". "..#bl;if radar_1 then gI=cE.GetClosestName(gI)end;return cC.AddNewLocation(gI,g6,false,true)end;local function nG()b0=not b0 end;local function nH(nI)if nI==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;b_=false;b2=false;bp=nil;b4=false;b3=false end;local function nJ(nK)cC.UpdatePosition(nil,nK)end;local function gC()cC.ClearCurrentPosition()end;local function nL(gG)local lO=cD.routeWP(true)if lO and#lO>0 then return"Engage Route: "..lM(lO[1])end;return"Engage Autopilot: "..lM(gG)end;local function nM(gG)local lO=cD.routeWP(true)if lO and#lO>0 then return"Next Route Point: "..lM(lO[1])end;return"Disable Autopilot: "..lM(gG)end;local function nN()if ir()==1 then b_=not b_;if b_ then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;nO=bi;bi=false;d.control.retractLandingGears()is:setTargetGroundAltitude(Y)g4("folOn","F")else g4("folOff","F")aX=true;cI=p;bi=nO;if bi then d.control.extendLandingGears()is:setTargetGroundAltitude(Z)end end else c1="Follow Mode only works with Remote controller"b_=false end end;local nC=50;local nD=260;local nP=i_(30)local nQ=aw+av*2+2;local nR=ax+1;nn("+","+",nP,nP,nQ,nR+nP+1,function()return false end,function()dk=dk/8 end,function()return bC=="SCOPE"end,nil,"ZoomButton")nn("-","-",nP,nP,nQ,nR,function()return false end,function()dk=math.min(dk*8,90)end,function()return bC=="SCOPE"end,nil,"ZoomButton")nn("0","0",nP,nP,nQ,nR+nP*2+2,function()return false end,function()dk=90 end,function()return bC=="SCOPE"and dk~=90 end,nil,"ZoomButton")local nS=nn("Enable Brake Toggle","Disable Brake Toggle",nD,nC,cr/2-nD/2,cs/2+350,function()return aV end,function()aV=not aV;if aV then c1="Brakes in Toggle Mode"else c1="Brakes in Default Mode"end end)nn("Align Prograde","Disable Prograde",nD,nC,cr/2-nD/2-50-nS.width,cs/2-nC+380,function()return aZ end,function()nH(1)end)nn("Align Retrograde","Disable Retrograde",nD,nC,cr/2-nD/2+nS.width+50,cs/2-nC+380,function()return aY end,nH,function()return cj==0 end)nT=nn(nL,nM,600,60,cr/2-600/2,cs/2-60/2-330,function()return a_ or bm or cf or bv end,function()end)local L;local function nU(nV)local lO=cD.routeWP(true)if lO and#lO>0 then return lO[1]end;local gG=dg+nV;if gG>#d7 then gG=gG-#d7-1 end;if gG<0 then gG=#d7+gG end;return gG end;nW={}for L=0,10 do local nX=nn(function(eN)local gG=nU(eN.apExtraIndex)if a_ or bm or cf or bv then return"Redirect: "..lM(gG)end;return nL(gG)end,function(eN)local gG=nU(eN.apExtraIndex)return nM(gG)end,600,60,cr/2-600/2,cs/2-60/2-330+60*L,function(eN)local gG=nU(eN.apExtraIndex)return gG==bh and(a_ or bm or cf or bv)end,function(eN)local gG=nU(eN.apExtraIndex)local nY=bh==gG;bh=gG;cC.UpdateAutopilotTarget()cD.ToggleAutopilot()if not nY and not(a_ or bm or cf or bv)then cD.ToggleAutopilot()end end,function()return df and(#cD.routeWP(true)==0 or L==0)end)nX.apExtraIndex=L;nW[L]=nX end;nn("Save Position","Save Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,gH,function()return bh==0 or gf==nil end)nn("Update Position","Update Position",200,nT.height,nT.x+nT.width+30,nT.y,function()return false end,function()nJ(nil)end,function()return bh>0 and gf~=nil end)nn("Save Heading","Clear Heading",200,nT.height,nT.x+nT.width+30,nT.y+nT.height+20,function()return gf.heading~=nil end,function()if gf.heading~=nil then nJ(false)else nJ(true)end end,function()return bh>0 and gf~=nil end)nn("Clear Position","Clear Position",200,nT.height,nT.x-200-30,nT.y,function()return true end,gC,function()return bh>0 and gf~=nil end)nn("Save Route","Save Route",200,nT.height,nT.x-200-30,nT.y+nT.height*2+40,function()return false end,function()cD.routeWP(false,false,2)end,function()return#cD.routeWP(true)>0 end)nn("Load Route","Clear Route",200,nT.height,nT.x-200-30,nT.y+nT.height+20,function()return#cD.routeWP(true)>0 end,function()if#cD.routeWP(true)>0 then cD.routeWP(false,true)elseif a_ or bm then c1="Disable Autopilot before loading route"return else cD.routeWP(false,false,1)end end,function()return true end)nC=60;nD=300;local hv=0;local hw=cs/2-150;nn("Enable Check Damage","Disable Check Damage",nD,nC,hv,hw-nC-20,function()return s end,function()s=not s end)nn("View Settings","View Settings",nD,nC,hv,hw,function()return true end,nz)hw=hw+nC+20;nn("Enable Turn and Burn","Disable Turn and Burn",nD,nC,hv,hw,function()return b0 end,nG)hv=10;hw=cs/2-300;nn("Horizontal Takeoff Mode","Vertical Takeoff Mode",nD,nC,hv+nD+20,hw,function()return aW end,function()aW=not aW;if aW then c1="Vertical Takeoff Mode"else c1="Horizontal Takeoff Mode"end end,function()return d1 end)hw=hw+nC+20;nn("Engage Orbiting","Cancel Orbiting",nD,nC,hv+nD+20,hw,function()return bv end,cD.ToggleIntoOrbit,function()return cj==0 and dc end)hw=cs/2-150;nn("Glide Re-Entry","Cancel Glide Re-Entry",nD,nC,hv+nD+20,hw,function()return b4 end,function()ce=1;nH(1)end,function()return iZ.hasAtmosphere and not ci end)hw=hw+nC+20;nn("Parachute Re-Entry","Cancel Parachute Re-Entry",nD,nC,hv+nD+20,hw,function()return b4 end,function()ce=2;nH(1)end,function()return iZ.hasAtmosphere and not ci end)hw=hw+nC+20;nn("Engage Follow Mode","Disable Follow Mode",nD,nC,hv,hw,function()return b_ end,nN,function()return ir()==1 end)nn("Enable Repair Arrows","Disable Repair Arrows",nD,nC,hv+nD+20,hw,function()return cw end,function()cw=not cw;if cw then c1="Repair Arrows Enabled"else c1="Repair Arrows Diabled"end end,function()return ir()==1 end)hw=hw+nC+20;if not q then nn("Enable AGG","Disable AGG",nD,nC,hv,hw,function()return d2 end,cD.ToggleAntigrav,function()return antigrav~=nil end)end;nn(function()return du("Switch IPH Mode - Current: %s",bw)end,function()return du("IPH Mode: %s",bw)end,nD*2,nC,hv,hw,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;c1="IPH Mode: "..bw end)hw=hw+nC+20;nn(function()return du("Toggle Control Scheme - Current: %s",g)end,function()return du("Control Scheme: %s",g)end,nD*2,nC,hv,hw,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c1="New Control Scheme: "..g end)local nZ=j0(20)local nX=nj(0,0,i_(70),nZ,"HELP")nX=nj(nX.x+nX.width,nX.y,i_(80),nZ,"INFO")nX=nj(nX.x+nX.width,nX.y,i_(70),nZ,"ORBIT")nX=nj(nX.x+nX.width,nX.y,i_(70),nZ,"SCOPE")nj(nX.x+nX.width,nX.y,i_(70),nZ,"HIDE")end;local n_={}local o0=nil;function n_.HUDPrologue(jJ)d8,d9=iX(d0)if not d8 then bI=af;bK=ag;bJ=ah;if im and G and im.getState()==0 then im.toggle()end else bI=ac;bK=ad;bJ=ae;if im and G and im.getState()==1 then im.toggle()end end;cp=[[rgb(]]..bF(bI+0.6)..","..bF(bK+0.6)..","..bF(bJ+0.6)..[[)]]cq=[[rgb(]]..bF(bI*0.8+0.5)..","..bF(bK*0.8+0.5)..","..bF(bJ*0.8+0.5)..[[)]]local o1=cp;local o2=cq;local o3=[[rgb(]]..bF(bI*0.4+0.5)..","..bF(bK*0.4+0.5)..","..bF(bJ*0.4+0.5)..[[)]]local o4=cp;local o5=cq;local o6=o3;if j1()and not m then o1=[[rgb(]]..bF(bI*0.5+0.5)..","..bF(bK*0.5+0.5)..","..bF(bJ*0.5+0.5)..[[)]]o2=[[rgb(]]..bF(bI*0.3+0.5)..","..bF(bK*0.3+0.5)..","..bF(bJ*0.2+0.5)..[[)]]o3=[[rgb(]]..bF(bI*0.2+0.5)..","..bF(bK*0.2+0.5)..","..bF(bJ*0.2+0.5)..[[)]]end;local lB=i_;local lC=j0;jJ[#jJ+1]=du([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o1,o1,o1,o4,o4,o2,o2,o5,o5,o2,o1,o3,o5,o1,o1,o3,o3,o6,o3,cr,cs,o2,o2,o2,o2,o2,o4,o2,o5,o6,o5,o5,o6)if not o0 then o0=du([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lB(630),lC(0),lB(675),lC(45),lB(960),lC(55),lB(1245),lC(45),lB(1290),lC(0),lB(1000),lC(105),lB(1040),lC(59),lB(1250),lC(51),lB(1300),lC(0),lB(1920),lC(0),lB(1920),lC(20),lB(1400),lC(20),lB(1300),lC(105),lB(920),lC(105),lB(880),lC(59),lB(670),lC(51),lB(620),lC(0),lB(0),lC(0),lB(0),lC(20),lB(520),lC(20),lB(620),lC(105),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112),lB(890),lC(59),lB(960),lC(62),lB(1030),lC(59),lB(985),lC(112),lB(1150),lC(112),lB(1100),lC(152),lB(820),lC(152),lB(780),lC(112),lB(935),lC(112))end;if x and I then jJ[#jJ+1]=o0 end;return jJ end;function n_.DrawVerticalSpeed(jJ,ed)jI(jJ,ed)end;function n_.UpdateHud(jJ)local kx=d5;local o7=d6;local jQ=o7;local k5=kx;local kP=bF(c.getThrottle())local kU=cY*3.6;local kQ=c.getAxisCommandValue(0)local o8=i_(1770)local o9=j0(310)if u and d4 then kQ=bL;kP=bL*100 end;local j3=j2()local jR="ROLL"if kP==nil then kP=0 end;if not dc then if cY>5 then kx=kw(cW)o7=ky(cW)else kx=0;o7=0 end;jR="YAW"end;if d9>50000 and not ci then local oa;oa=ix(d9)jJ[#jJ+1]=gV(o8,o9,"PvP Boundary: "..oa,"pbright txtbig txtmid")end;jJ[#jJ+1]=cd;jJ[#jJ+1]=iP;jJ[#jJ+1]=ii;if iL~=""then jJ[#jJ+1]=iL end;if j4~=""then jJ[#jJ+1]=j4 end;if j5~=""then jJ[#jJ+1]=j5 end;jI(jJ,ck)if ir()==0 or l then if dc then jP(jJ,ai,aj,jQ,jR,dc)else jP(jJ,ai,aj,o7,jR,dc)end;if not j1()or m then if dc then jP(jJ,ai,aj,jQ,jR,dc)k4(jJ,k5,jQ,ai,aj,dc,bF(ky(cW)),cY)else jP(jJ,ai,aj,o7,jR,dc)k4(jJ,kx,o7,ai,aj,dc,bF(o7),cY)end;kb(jJ,ck,dc)kz(jJ,cW,cY,ai,aj)end end;kO(jJ,j3,kP,kQ)kT(jJ,kU)kX(jJ)lV(jJ)if not iJ and c0 then lN(jJ)end;return jJ end;function n_.HUDEpilogue(jJ)jJ[#jJ+1]="</svg>"return jJ end;function n_.ExtraData(jJ)local ob=i_(1240)local oc=j0(55)local od=oc+10;local gM;local lB=i_;local lC=j0;local oe=0;local j3=j2()if aW then j3=j3 .."-VERTICAL"end;if F and not b3 and not b2 and cY>20 then j3=j3 .."-COLLISION ON"end;if by~="Off"then j3="("..by..")-"..j3 end;if b0 then j3="TB-"..j3 end;if not bx then j3=j3 .."-DeCoupled"end;local of=lC(99)local og=lC(80)local oh=lC(85)local oi=lC(31)local oj=0;local ok=0;local ol=cm>1000000 and iu(cm/1000000,2).."kT"or iu(cm/1000,2).."T"if ci then oe=bq else oe=bo end;local om,on=cy.computeDistanceAndTime(cY,0,cm,0,0,oe)if om<0 then om=0 end;oe=iu(oe/(cm*iB),2).."g"local oo=d:maxForceForward()gM=b.g()if gM>0.1 then ok=cm*gM;ok=iu(ok/(cm*iB),2).."g"oj=0.5*oo/gM;oj=oj>1000000 and iu(oj/1000000,2).."kT"or iu(oj/1000,2).."T"end;oo=iu(oo/(cm*iB),2).."g"local op=vec3(b.getWorldAcceleration()):len()/9.80665;gM=b.g()jJ[#jJ+1]=[[<g class="dim txt txtend size14">]]if ir()==1 and not l then ob=i_(1120)oc=j0(55)od=oc+10 elseif ci and I then local oq=i_(770)jJ[#jJ+1]=gV(lB(895),of,"ATMO","")jJ[#jJ+1]=du([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lB(895),oh,lB(-80))jJ[#jJ+1]=gV(lB(815),og,du("%.1f%%",cj*100),"txtstart size20")end;if I then jJ[#jJ+1]=gV(lB(1025),of,"GRAVITY","txtstart")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1025),oh,lB(80))jJ[#jJ+1]=gV(lB(1105),og,du("%.2fg",gM/9.80665),"size20")jJ[#jJ+1]=gV(lB(1125),of,"ACCEL","txtstart")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1125),oh,lB(80))jJ[#jJ+1]=gV(lB(1205),og,du("%.2fg",op),"size20")jJ[#jJ+1]=gV(lB(695),of,"BRK TIME","")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(695),oh,lB(-80))jJ[#jJ+1]=gV(lB(615),og,du("%s",iy(on)),"txtstart size20")jJ[#jJ+1]=gV(lB(635),lC(45),"TRIP","")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(635),lC(31),lB(-90))if lv then jJ[#jJ+1]=gV(lB(545),lC(26),du("%s",iy(lv)),"txtstart size20")end;jJ[#jJ+1]=gV(lB(795),of,"BRK DIST","")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(795),oh,lB(-80))jJ[#jJ+1]=gV(lB(715),og,du("%s",ix(om)),"txtstart size20")jJ[#jJ+1]=gV(lB(1285),lC(45),"MASS","txtstart")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1285),lC(31),lB(90))jJ[#jJ+1]=gV(lB(1375),lC(26),du("%s",ol),"size20")jJ[#jJ+1]=gV(lB(1220),of,"THRUST","txtstart")jJ[#jJ+1]=du([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lB(1220),oh,lB(80))jJ[#jJ+1]=gV(lB(1300),og,du("%s",oo),"size20")jJ[#jJ+1]=gV(i_(960),j0(175),j3,"pbright txtbig txtmid size20")end;jJ[#jJ+1]="</g>"end;local os=1-(a6*0.05+a7*0.05)function n_.FuelUsed(ot)local ou;if ot=="atmofueltank"then ou=du("Atmo Fuel Used: %.1f L",jl[ot]/(4*os))elseif ot=="spacefueltank"then ou=du("Space Fuel Used: %.1f L",jl[ot]/(6*os))else ou=du("Rocket Fuel Used: %.1f L",jl[ot]/(0.8*os))end;return ou end;function n_.DrawOdometer(jJ,c6,bj,c7)if bC~="INFO"then return jJ end;local gM;local oj=0;local ok=0;local oe=0;local ol=cm>1000000 and iu(cm/1000000,2).." kTons"or iu(cm/1000,2).." Tons"if ci then oe=bq else oe=bo end;local om,on=cy.computeDistanceAndTime(cY,0,cm,0,0,oe)oe=iu(oe/(cm*iB),2).." g"local oo=d:maxForceForward()gM=b.g()if gM>0.1 then ok=cm*gM;ok=iu(ok/(cm*iB),2).." g"oj=0.5*oo/gM;oj=oj>1000000 and iu(oj/1000000,2).." kTons"or iu(oj/1000,2).." Tons"end;oo=iu(oo/(cm*iB),2).." g"if ir()==0 or l then local ov=i_(aw+10)local ow=j0(ax+20)local ox=i_(aw+10+av/1.25)local nl=25;jJ[#jJ+1]="<g class='txtstart size14 bright'>"jJ[#jJ+1]=gV(ov,ow,du("BrkTime: %s",iy(on)))jJ[#jJ+1]=gV(ox,ow,du("Trip: %.2f km",c6))jJ[#jJ+1]=gV(ov,ow+nl,du("Lifetime: %.2f kSU",bj/200000))jJ[#jJ+1]=gV(ox,ow+nl,du("BrkDist: %s",ix(om)))jJ[#jJ+1]=gV(ov,ow+nl*2,"Trip Time: "..iy(c7))jJ[#jJ+1]=gV(ox,ow+nl*2,"Total Time: "..iy(bk))jJ[#jJ+1]=gV(ov,ow+nl*3,du("Mass: %s",ol))jJ[#jJ+1]=gV(ox,ow+nl*3,du("Max Brake: %s",oe))jJ[#jJ+1]=gV(ov,ow+nl*4,du("Max Thrust: %s",oo))if gM>0.1 then jJ[#jJ+1]=gV(ox,ow+nl*4,du("Max Thrust Mass: %s",oj))jJ[#jJ+1]=gV(ov,ow+nl*5,du("Req Thrust: %s",ok))else jJ[#jJ+1]=gV(ox,ow+nl*4,"Max Mass: n/a")jJ[#jJ+1]=gV(ov,ow+nl*5,"Req Thrust: n/a")end;jJ[#jJ+1]=gV(ox,ow+nl*5,cB.FuelUsed("atmofueltank"))jJ[#jJ+1]=gV(ov,ow+nl*6,cB.FuelUsed("spacefueltank"))jJ[#jJ+1]=gV(ox,ow+nl*6,cB.FuelUsed("rocketfueltank"))if cY>833 then local oy=cm/math.sqrt(1-(cY/8333.33)^2)local ol=oy>1000000 and iu(oy/1000000,2).." kTons"or iu(oy/1000,2).." Tons"jJ[#jJ+1]=gV(ox,ow+nl*7,du("Rel. Mass: %s",ol))end end;jJ[#jJ+1]="</g></g>"return jJ end;function n_.DrawWarnings(jJ)return kX(jJ)end;function n_.DisplayOrbitScreen(jJ)return lV(jJ)end;function n_.DisplayMessage(jJ,li)if li~="empty"then local hw=310;for oz in string.gmatch(li,"([^\n]+)")do hw=hw+35;jJ[#jJ+1]=gV("50%",hw,oz,"msg")end end;if cb~=0 then c.setTimer("msgTick",cb)cb=0 end end;function n_.DrawDeadZone(jJ)jJ[#jJ+1]=du([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function n_.UpdatePipe()if ci then iL=""return end;na()end;function n_.DrawSettings(jJ)local hv=i_(640)local hw=j0(200)jJ[#jJ+1]=[[<g class="pbright txtvspd txtstart">]]local hZ=0;for dU,dG in pairs(iK)do hZ=hZ+1;jJ[#jJ+1]=gV(hv,hw,dU..": "..dG.get())hw=hw+20;if hZ%12==0 then hv=hv+i_(350)hw=j0(200)end end;jJ[#jJ+1]=gV(i_(640),j0(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jJ[#jJ+1]="</g>"return jJ end;local ie=i_(1770)local ig=j0(350)local id=j0(15)local ic=i_(1370)local ij,oA;function n_.DrawRadarInfo()ii=cE.GetRadarHud(ic,id,ie,ig)end;function n_.DrawTanks()if aq~=0 and ar~=0 then j4=gV(aq,ar,"","txtstart pdim txtfuel")jm=ar;jn(aq,"Atmospheric ","ATMO",ct,jj,jk)jn(aq,"Space Fuel T","SPACE",cu,jh,ji)jn(aq,"Rocket Fuel ","ROCKET",cv,jf,jg)end end;function n_.DrawShield()local oB=im.getState()==1 and"Shield Active"or"Shield Disabled"local oC=b.getPvPTimer()local oD=im.getResistances()local oE="A: "..10+oD[1]*100 .."% / E: "..10+oD[2]*100 .."% / K:"..10+oD[3]*100 .."% / T: "..10+oD[4]*100 .."%"local hv,hw=as-60,at+30;local oF=bF(0.5+im.getShieldHitpoints()*100/im.getMaxShieldHitpoints())local jB=bF(oF*2.55)local jC=du("rgb(%d,%d,%d)",255-jB,jB,0)local jD=""j5=gV(hv,hw,"","txtmid pdim txtfuel")if oF<10 and oB~="Shield Disabled"then jD="red "end;oC=oC>0 and"   PvPTime: "..iy(oC)or""j5=j5 ..du([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hv,hw,jC,oF*2,hv,hw,hv+2,hw+10,oF,oC)j5=j5 ..gV(hv,hw-5,oB,jD.."txtstart pbright txtbig")j5=j5 ..gV(hv,hw+30,oE,jD.."txtstart pbright txtsmall")end;function n_.hudtick()if not iZ then return end;local function oG(jJ)local jF=bF(dv(cc/(cr/4)*255,0,255))jJ[#jJ+1]=du("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bF(bI+0.5)+jF,bF(bK+0.5)-jF,bF(bJ+0.5)-jF)end;local function oH()for dZ,dG in pairs(iC)do if dG.hovered then if not dG.drawCondition or dG.drawCondition(dG)then dG.toggleFunction(dG)end;dG.hovered=false end end;for dZ,dG in pairs(iF)do if dG.hovered then bC=dG.label;dG.hovered=false end end end;local function oI()local function oJ(oK,oL,hv,hw,nk,nl)if oK>=hv and oK<=hv+nk and oL>=hw and oL<=hw+nl then return true else return false end end;local hv=c9+cr/2;local hw=ca+cs/2;for dZ,dG in pairs(iC)do dG.hovered=oJ(hv,hw,dG.x,dG.y,dG.width,dG.height)end;for dZ,dG in pairs(iF)do dG.hovered=oJ(hv,hw,dG.x,dG.y,dG.width,dG.height)end;if df then local m_=false;for dZ,eN in ipairs(nW)do if eN.hovered then m_=true;break end end;if nT.hovered then m_=true end;df=m_ else df=nT.hovered;if not df then dg=bh end end end;local function oM(jJ)if not bC or bC==""then bC="HELP"end;if x then for dU,dG in pairs(iF)do local jD="dim brightstroke"local oN=0.2;if bC==dU then jD="pbright dimstroke"oN=0.6 end;local oO=""if dG.hovered then oN=0.8;oO=";stroke:white"end;jJ[#jJ+1]=du([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dG.width,dG.height,dG.x,dG.y,jD,oN,oO)jJ[#jJ+1]=gV(dG.x+dG.width/2,dG.y+dG.height/2+5,dG.label,"txt txtmid pdim")end end end;local function oP(jJ)local function oQ(jJ,oR,hover,hv,hw,ft,oS,oT,oU,oV,oW,nX)if type(oV)=="function"then oV=oV(nX)end;if type(oW)=="function"then oW=oW(nX)end;jJ[#jJ+1]=du("<rect x='%f' y='%f' width='%f' height='%f' fill='",hv,hw,ft,oS)if oR then jJ[#jJ+1]=du("%s'",oT)else jJ[#jJ+1]=oU end;if hover then jJ[#jJ+1]=du(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jJ[#jJ+1]=du(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",iu(ac*0.5,0),iu(ad*0.5,0),iu(ae*0.5,0))end;jJ[#jJ+1]=" rx='5'></rect>"jJ[#jJ+1]=du("<text x='%f' y='%f' font-size='24' fill='",hv+ft/2,hw+oS/2+5)if oR then jJ[#jJ+1]="black"else jJ[#jJ+1]="white"end;jJ[#jJ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oR then jJ[#jJ+1]=du("%s</text>",oV)else jJ[#jJ+1]=du("%s</text>",oW)end end;local oX=du("rgb(%d,%d,%d)'",iu(ac*0.1,0),iu(ad*0.1,0),iu(ae*0.1,0))local oY=du("rgb(%d,%d,%d)",iu(ac*0.8,0),iu(ad*0.8,0),iu(ae*0.8,0))local oZ=oQ;for dZ,dG in pairs(iC)do local np=dG.disableName;local no=dG.enableName;if type(np)=="function"then np=np(dG)end;if type(no)=="function"then no=no(dG)end;if not dG.drawCondition or dG.drawCondition(dG)then oZ(jJ,dG.toggleVar(dG),dG.hovered,dG.x,dG.y,dG.width,dG.height,oY,oX,np,no,dG)end end end;local o_=iu(cr/2,0)local p0=iu(cs/2,0)local jJ={}cB.HUDPrologue(jJ)if x then cB.UpdateHud(jJ)else if B then cB.DrawVerticalSpeed(jJ,ck)end;cB.DrawWarnings(jJ)end;if iJ and iK~="none"then cB.DrawSettings(jJ)end;if radar_1 then cB.DrawRadarInfo()end;cB.HUDEpilogue(jJ)jJ[#jJ+1]=du([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cr,cs)if c1~="empty"then cB.DisplayMessage(jJ,c1)end;if ir()==0 and g=="virtual joystick"then if w then cB.DrawDeadZone(jJ)end end;oM(jJ)if it()==0 then if ir()==1 and c0 then if not p1 then oI()oP(jJ)end;if not cG and not cH then local p2=table.concat(jJ,"")jJ={}jJ[#jJ+1]=du("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jJ[#jJ+1]=p2;jJ[#jJ+1]="</body>"cG=true;jJ[#jJ+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local p3=table.concat(jJ,"")a.setScreen(p3)elseif cH then local p2=table.concat(jJ,"")jJ={}jJ[#jJ+1]=du("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jJ[#jJ+1]=p2;jJ[#jJ+1]="</body>"end;if not cG then jJ[#jJ+1]=du([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c9,ca)end else oH()end else if not c0 and ir()==0 then oH()if cc>au then if w then oG(jJ)end end elseif c0 and(not p1 or not i)then oI()oP(jJ)end;jJ[#jJ+1]=du([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],o_,p0,c9,ca)end;jJ[#jJ+1]=[[</svg></body>]]p3=table.concat(jJ,"")end;function n_.TenthTick()local function p4()local p5=a.createData;local p6=a.createWidget;p7=a.createWidgetPanel("Interplanetary Helper")p8=p6(p7,"value")p9=p5('{"label": "Target Planet", "value": "N/A", "unit":""}')g3(p9,p8)pa=p6(p7,"value")pb=p5('{"label": "distance", "value": "N/A", "unit":""}')g3(pb,pa)gw=p6(p7,"value")gv=p5('{"label": "Travel Time", "value": "N/A", "unit":""}')g3(gv,gw)gu=p6(p7,"value")gt=p5('{"label": "Maximum Mass", "value": "N/A", "unit":""}')g3(gt,gu)gy=p6(p7,"value")gx=p5('{"label": "Target Altitude", "value": "N/A", "unit":""}')g3(gx,gy)gq=p6(p7,"value")gp=p5('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')go=p6(p7,"value")gn=p5('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gm=p6(p7,"value")gl=p5('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gk=p6(p7,"value")gj=p5('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gs=p6(p7,"value")gr=p5('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ci then g3(gp,gq)g3(gn,go)g3(gl,gm)g3(gj,gk)g3(gr,gs)end end;local function pc()gU(p7)p7=nil end;local function pd()if not a_ then if gf==nil or gf.planetname~=iZ.name then pe=(c5.center-d0):len()else pe=(gf.position-d0):len()end end;local fA=cY;local pf=c.getThrottle()/100;if u then pf=bL end;local pg,ph=cy.computeDistanceAndTime(cY,a0,cm,d:maxForceForward()*pf,a2,0)local c3,c4;if not b0 then c3,c4=cD.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cD.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dZ,pi;if not b0 and fA>0 then dZ,pi=cD.GetAutopilotBrakeDistanceAndTime(fA)else dZ,pi=cD.GetAutopilotTBBrakeDistanceAndTime(fA)end;local pj=0;local pk=0;if ba or not a_ and fA>5 then pk=cy.computeTravelTime(fA,0,pe)elseif c3+pg<pe then pj=pe-(c3+pg)pk=cy.computeTravelTime(8333.0556,0,pj)else local pl=(pe-c3)/pg;pg=pe-c3;ph=ph*pl end;if gf~=nil and gf.planetname==iZ.name and not a_ then return pk elseif b9 then return pi elseif ba then return pk+pi else return ph+c4+pk end end;cB.DrawTanks()if im then cB.DrawShield()end;if bf~="None"then if p7==nil then p4()end;if bf~=nil then local pm=gf~=nil;local pn=0.5*bq/c5:getGravity(c5.center+vec3(0,0,1)*c5.radius):len()pn=pn>1000000 and iu(pn/1000000,2).." kTons"or iu(pn/1000,2).." Tons"g2(p9,'{"label": "Target", "value": "'..bf..'", "unit":""}')lv=pd()if pm and not a_ then cc=(d0-gf.position):len()else cc=(bg-d0):len()end;if not b0 then c3,c4=cD.GetAutopilotBrakeDistanceAndTime(cY)iN,iO=cD.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cD.GetAutopilotTBBrakeDistanceAndTime(cY)iN,iO=cD.GetAutopilotTBBrakeDistanceAndTime(a0)end;local li=ix(cc)g2(pb,'{"label": "distance", "value": "'..li..'"}')g2(gv,'{"label": "Travel Time", "value": "'..iy(lv)..'", "unit":""}')li=ix(c3)g2(gp,'{"label": "Cur Brake distance", "value": "'..li..'"}')g2(gn,'{"label": "Cur Brake Time", "value": "'..iy(c4)..'", "unit":""}')li=ix(iN)g2(gl,'{"label": "Max Brake distance", "value": "'..li..'"}')g2(gj,'{"label": "Max Brake Time", "value": "'..iy(iO)..'", "unit":""}')g2(gt,'{"label": "Max Brake Mass", "value": "'..du("%s",pn)..'", "unit":""}')li=ix(gz)g2(gx,'{"label": "Target Orbit", "value": "'..li..'"}')if cj>0 and not po then a.removeDataFromWidget(gj,gk)a.removeDataFromWidget(gl,gm)a.removeDataFromWidget(gn,go)a.removeDataFromWidget(gp,gq)a.removeDataFromWidget(gr,gs)po=true;if not d4 and u and(b1 or b4 or cg)then cD.cmdThrottle(1)aX=false;bP=false end end;if cj==0 and po then if g2(gj,gk)==1 then g3(gj,gk)end;if g2(gl,gm)==1 then g3(gl,gm)end;if g2(gn,go)==1 then g3(gn,go)end;if g2(gp,gq)==1 then g3(gp,gq)end;if g2(gr,gs)==1 then g3(gr,gs)end;po=false end end else pc()end;if warpdrive~=nil then if ip(warpdrive.getData()).destination~="Unknown"and ip(warpdrive.getData()).distance>400000 then warpdrive.show()pp=true else warpdrive.hide()pp=false end end end;function n_.OneSecondTick()local function pq()local jx=bE()local kU=cY;local pr=jx-cl;if kU>1.38889 then kU=kU/1000;local ps=kU*(jx-cl)bj=bj+ps;c6=c6+ps end;c7=c7+pr;bk=bk+pr;cl=jx end;local function pt(jJ)local pu=0;iP=""local pv=iA;local pw=0;local px=0;local py=0;local jB=0;local jC=""local pz=b.getElementHitPointsById;local pA=b.getElementMaxHitPointsById;local pB={}for dU in pairs(iz)do local pC=0;local pD=0;pD=pA(iz[dU])pC=pz(iz[dU])pw=pw+pC;if pC<pD then if pC==0 then py=py+1 else px=px+1 end;if cw and#pB==0 then g6=vec3(b.getElementPositionById(iz[dU]))local hv=g6.x;local hw=g6.y;local hx=g6.z;table.insert(pB,b.spawnArrowSticker(hv,hw,hx+1,"down"))table.insert(pB,b.spawnArrowSticker(hv,hw,hx+1,"down"))b.rotateSticker(pB[2],0,0,90)table.insert(pB,b.spawnArrowSticker(hv+1,hw,hx,"north"))table.insert(pB,b.spawnArrowSticker(hv+1,hw,hx,"north"))b.rotateSticker(pB[4],90,90,0)table.insert(pB,b.spawnArrowSticker(hv-1,hw,hx,"south"))table.insert(pB,b.spawnArrowSticker(hv-1,hw,hx,"south"))b.rotateSticker(pB[6],90,-90,0)table.insert(pB,b.spawnArrowSticker(hv,hw-1,hx,"east"))table.insert(pB,b.spawnArrowSticker(hv,hw-1,hx,"east"))b.rotateSticker(pB[8],90,0,90)table.insert(pB,b.spawnArrowSticker(hv,hw+1,hx,"west"))table.insert(pB,b.spawnArrowSticker(hv,hw+1,hx,"west"))b.rotateSticker(pB[10],-90,0,90)table.insert(pB,iz[dU])end elseif cw and#pB>0 and pB[11]==iz[dU]then for jw in pairs(pB)do b.deleteSticker(pB[jw])end;pB={}end end;pu=bF(pw/pv*100)if pu<100 then jJ[#jJ+1]=gV(0,0,"","pbright txt")jB=bF(pu*2.55)jC=du("rgb(%d,%d,%d)",255-jB,jB,0)if pu<100 then jJ[#jJ+1]=gV("50%",1035,"Elemental Integrity: "..pu.."%","txtbig txtmid","fill:"..jC)if py>0 then jJ[#jJ+1]=gV("50%",1055,"Disabled Modules: "..py.." Damaged Modules: "..px,"txtbig txtmid","fill:"..jC)elseif px>0 then jJ[#jJ+1]=gV("50%",1055,"Damaged Modules: "..px,"txtbig txtmid","fill:"..jC)end end end end;local function pE()if io then if iQ==nil and(dn~=nil or bi)then _autoconf.displayCategoryPanel(io,weapon_size,"Weapons","weapon",true)iQ=_autoconf.panels[_autoconf.panels_size]elseif iQ~=nil and dn==nil and not bi then gU(iQ)iQ=nil end end end;dh=b.getPlayersOnBoard()di=b.getDockedConstructs()local jJ={}pq()if s then pt(jJ)end;pE()cB.UpdatePipe()cB.ExtraData(jJ)cd=table.concat(jJ,"")collectgarbage("collect")end;function n_.AnimateTick()cH=true;cG=false;c9=0;ca=0;c.stopTimer("animateTick")end;function n_.MsgTick()local jJ={}cB.DisplayMessage(jJ,"empty")c1="empty"c.stopTimer("msgTick")cb=3 end;function n_.ButtonSetup()nA()nF()iC=iD end;return n_ end;local function pF(d,b,c,a,e,vBooster,hover,pG,antigrav,warpdrive,dbHud_1,f8,bF,bG,ir,f3,bE,dv,is,g2,it,dx,iu,g4,iv,dy,ix,iy,pH,ip,du,g3)local pI={}local function pJ(fA)local pK=bb;if not a_ then pK=0 end;if not ci then return cy.computeDistanceAndTime(fA,pK,cm,0,0,bo-bd*cm)else if bq and bq>0 then return cy.computeDistanceAndTime(fA,pK,cm,0,0,bq-bd*cm)else return 0,0 end end end;local function pL(fA)local pK=bb;if not a_ then pK=0 end;return cy.computeDistanceAndTime(fA,pK,cm,d:maxForceForward(),a2,bo-bd*cm)end;local pM=false;local pN=0;local pO=0;local pP=0;local pQ=bE()local pR=0;local pS=0;local pT=0;local pU=0;local pV=false;local pW=false;local pX=false;local pY=nil;local pZ=0;local p_={}local iM=55;local q0=nil;local q1=""function pI.GetAutopilotBrakeDistanceAndTime(fA)return pJ(fA)end;function pI.GetAutopilotTBBrakeDistanceAndTime(fA)return pL(fA)end;local function q2(q3,q4,q5)q4=q4:project_on_plane(q3)q5=q5:project_on_plane(q3)return f3(q4:cross(q5):dot(q3),q4:dot(q5))end;local function q6()local function q7()local q8=-1;local q9=-1;if vBooster then q8=vBooster.getDistance()end;if hover then q9=hover.getDistance()end;if q8~=-1 and q9~=-1 then if q8<q9 then return q8 else return q9 end elseif q8~=-1 then return q8 elseif q9~=-1 then return q9 else return-1 end end;local qa=q7()local qb=-1;if pG then qb=pG.getDistance()end;if qa~=-1 and qb~=-1 then if qa<qb then return qa else return qb end elseif qa~=-1 then return qa else return qb end end;local function qc(iZ,eV,qd)local function qe(qf,e5)local f0=vec3(e5)if qf.id==0 then return setmetatable({latitude=f0.x,longitude=f0.y,altitude=f0.z,id=0,systemId=qf.systemId},e7)end;local f1=f0-qf.center;local cc=f1:len()local ed=cc-qf.radius;local eb=0;local ec=0;if not dy(cc,0)then local f2=f3(f1.y,f1.x)ec=f2>=0 and f2 or 2*math.pi+f2;eb=math.pi/2-math.acos(f1.z/cc)end;return setmetatable({latitude=math.deg(eb),longitude=math.deg(ec),altitude=ed,id=qf.id,systemId=qf.systemId},e7)end;local qg=qe(iZ,eV)qg="::pos{"..qg.systemId..","..qg.id..","..qg.latitude..","..qg.longitude..","..qg.altitude.."}"if qd then return qg else a.setWaypoint(qg)return true end end;local qh=false;function pI.showWayPoint(iZ,eV,qd)return qc(iZ,eV,qd)end;function pI.APTick()local function qi()if de and not b2 then local eC=de[1]local i3,i4=de[2],de[3]local qj=math.min(i3,i4 or i3)local qk=qj/cY;local ql=b3 and(cY<42 or ch~=-1)local qm=b1 or bm or bp or a_;if qm and not ql and(c3*1.5>qj or qk<1)then aX=true;p_={}cD.cmdThrottle(0)if b1 then cD.ToggleAltitudeHold()end;if bp then cD.ToggleLockPitch()end;c1="Autopilot Cancelled due to possible collision"if bm or a_ then cD.ToggleAutopilot()end;lp=true;b2=true;cI=true end;if qk<11 then dd=eC.name.." COLLISION "..iy(qk).." / "..ix(qj,2)else dd=eC.name.." collision "..iy(qk)end;if qk<6 then g4("alarm","AL",2)end else dd=false end end;local function qn(qo,qp,qq)local function qr(qo,eE)qo=vec3(qo)eE=vec3(eE):normalize()local dP=qo*eE;return dP.x+dP.y+dP.z end;local qs=0.001;local qt=1;if not ci or not cJ or ch~=-1 or cY<iM then if qq==nil then qq=aO end;if qp==nil then qp=qs end;qo=vec3(qo):normalize()local qu=vec3()-qo;local qv=-qr(qu,b.getConstructWorldOrientationRight())*qt;local qw=-qr(qu,b.getConstructWorldOrientationUp())*qt;if pO==0 then pO=qv/2 end;if pP==0 then pP=qw/2 end;if f8(qv)<0.1 then bV=bV-qv*2 else bV=bV-(qv+(qv-pO)*qq)end;if f8(qw)<0.1 then bU=bU+qw*2 else bU=bU+qw+(qw-pP)*qq end;pO=qv;pP=qw;if f8(qv)<qp and f8(qw)<qp then return true end;return false elseif cJ and ch==-1 then qo=cX;if qq==nil then qq=aO end;if qp==nil then qp=qs end;qo=vec3(qo):normalize()local qu=cU-qo;local qv=-qr(qu,b.getConstructWorldOrientationRight())*qt;local qw=-qr(qu,b.getConstructWorldOrientationUp())*qt;if pO==0 then pO=qv/2 end;if pP==0 then pP=qw/2 end;if f8(qv)<0.1 then bV=bV-qv*5 else bV=bV-(qv+(qv-pO)*qq)end;if f8(qw)<0.1 then bU=bU+qw*5 else bU=bU+qw+(qw-pP)*qq end;pO=qv;pP=qw;if f8(qv)<qp and f8(qw)<qp then return true end;return false end end;ci=bG()>0;cj=bG()ck=b.getAltitude()ch=q6()bH=bE()pQ=bH;if F then qi()end;if antigrav then d2=antigrav.getState()==1 end;local qx=a.getMouseWheel()if qx>0 then cD.changeSpd()elseif qx<0 then cD.changeSpd(true)else cn=true end;local qy=1;local qz=1;local qA=bH-pQ;local qB=-math.deg(q2(cT,cX,cU))local qC=math.deg(q2(cV,cX,cU))local gB=cZ*-1;cJ=ci and qB<-M or qB>M or qC<-N or qC>N;local qD=a.getMouseDeltaX()local qE=a.getMouseDeltaY()if o and not c0 then qE=-qE end;bV=0;bZ=0;bU=0;g7=cx[0]iZ=g7:closestBody(b.getConstructWorldPos())qF=cA(iZ)fE=qF:orbitalParameters(b.getConstructWorldPos(),cX)if ck==0 then ck=(d0-iZ.center):len()-iZ.radius end;dc=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;local gM=iZ:getGravity(b.getConstructWorldPos()):len()*cm;cK=0;cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if it()==0 then if ir()==1 and c0 then if not cG then c9=dv(c9+qD,-cr/2,cr/2)ca=dv(ca+qE,-cs/2,cs/2)end else c9=0;ca=0 end else c9=dv(c9+qD,-cr/2,cr/2)ca=dv(ca+qE,-cs/2,cs/2)cc=dx(c9*c9+ca*ca)if not c0 and ir()==0 then local kG,kH=1,1;if bC=="SCOPE"then kG,kH=dk/90,dk/90 end;if g=="virtual joystick"then if c9>0 and c9>au then bV=bV-(c9-au)*aC*kG elseif c9<0 and c9<au*-1 then bV=bV-(c9+au)*aC*kG else bV=0 end;if ca>0 and ca>au then bU=bU-(ca-au)*aD*kH elseif ca<0 and ca<au*-1 then bU=bU-(ca+au)*aD*kH else bU=0 end else c9=0;ca=0;if g=="mouse"then bU=(-utils.smoothstep(qE,-100,100)+0.5)*2*qy;bV=(-utils.smoothstep(qD,-100,100)+0.5)*2*qz end end end end;local qG=cY>8334;if cY>W/3.6 and not ci and not a_ and not qG then c1="Space Speed Engine Shutoff reached"cD.cmdThrottle(0)end;if not qG and qH then if not aX then cD.BrakeToggle()end;if a_ then cD.ToggleAutopilot()end end;qH=qG;if ci and cj>0.09 then if cY>cL/3.6 and not u and not pM then aX=true;pM=true elseif not u and pM then if cY<cL/3.6 then aX=false;pM=false end end end;if aX then bY=1 else bY=0 end;if aZ then if ce then aX=false;local qI=false;if gf and ce==true then qI=qn(gf.position-d0,0.1)else qI=qn(vec3(cX),0.01)end;cI=true;if qI then cD.cmdCruise(bF(cL))if(f8(d6)<2 or f8(d5)>85)and cY>=cL/3.6-1 then aX=false;aZ=false;if ce~=2 then bR=true end;if ce==true then cg=true end;ce=false;a_=false;cD.BeginReentry()end elseif ci and u then cD.cmdThrottle(1)end elseif cY>iM then qn(vec3(cX),0.01)end end;if aY then if ci then aY=false elseif cY>iM then qn(-vec3(cX))end end;if not aZ and ce and not bv then if cj==0 then if ce~=2 then bR=true end;cD.BeginReentry()ce=false;cg=true else ce=false;cD.ToggleAutopilot()end end;if cg and gf and(ck<b6+250 and ck>b6-250)and cY*3.6>cL-250 and f8(c_)<25 and cj>=0.1 and(gf.position-d0):len()>2000+ck then cD.ToggleAutopilot()cg=false end;if b5 then cI=true;local qJ=b6;if c_<-30 then c1="Unable to achieve lift. Safety Landing."c8=0;cI=p;b5=false;b2=true elseif not q and d2 or b6<iZ.spaceEngineMinAltitude then if d2 then qJ=antigrav.getBaseAltitude()end;if ck<qJ-100 then cM=0;c8=15;aX=false elseif c_>0 then aX=true;c8=0 elseif c_<-30 then aX=true;c8=15 elseif ck>=qJ then if d2 then if a_ or bm then cD.ToggleVerticalTakeoff()else aX=true;b5=false end;c1="Takeoff complete. Singularity engaged"g4("aggLk","AG")else aX=false;c1="VTO complete. Engaging Horizontal Flight"g4("vtoc","VT")cD.ToggleVerticalTakeoff()end;c8=0 end else if cj>0.08 then cM=0;aX=false;c8=20 elseif cj<0.08 and cj>0 then aX=false;if cR then cM=0;c8=20 else c8=0;cM=36;cD.cmdCruise(3500)end else cI=p;bv=true;cQ=false;qK=false;pV=false;pT=nil;pU=nil;if pY==nil then pY=iZ end;cP=qJ;pX=true;b5=false end end;if cM~=nil then if qL==nil then qL=pid.new(2*0.01,0,2*0.1)end;local qM=dv(cM-d5,-N*0.80,N*0.80)qL:inject(qM)local qN=dv(qL:get(),-1,1)bU=qN end end;if bv then local qu;local qO=false;local qP=ix(cP)if pY==nil then pY=iZ;if bm then pY=c5 end end;if not pX then cP=bF(pY.radius+pY.surfaceMaxAltitude+U)if pY.hasAtmosphere then cP=bF(pY.radius+pY.noAtmosphericDensityAltitude+U)end;pX=true end;if cO.VectorToTarget and gf then qu=gf.position-d0 end;local qQ,qR=cA(pY):escapeAndOrbitalSpeed((d0-pY.center):len()-pY.radius)local qS=d6;if not pV then local qT=false;local qU=false;cD.cmdThrottle(0)pU=0;cN="Aligning to orbital path - OrbitHeight: "..qP;if cO.VectorToTarget then qn(qu:normalize():project_on_plane(cZ))qO=cU:dot(qu:project_on_plane(cT):normalize())>0.95 else qn(cX)qO=qB<0.5;if cY<150 then qO=true end end;bU=0;pT=0;if d5<=pT+2 and d5>=pT-2 then qT=true else qT=false end;if qS<=pU+2 and qS>=pU-2 then qU=true else qU=false end;if qT and qU and qO then pT=nil;pU=nil;pV=true end else if cO.VectorToTarget then qn(qu:normalize():project_on_plane(cZ))elseif cY>150 then qn(cX)end;bU=0;if cO.VectorToTarget and gf then local c3,dZ=cy.computeDistanceAndTime(cY,cL/3.6,cm,0,0,bo)if cQ and qu:len()>15000+c3+ck then cN="Orbiting to Target"if ck-100<=pY.noAtmosphericDensityAltitude or lv>fE.timeToPeriapsis and fE.periapsis.altitude<pY.noAtmosphericDensityAltitude then cQ=false end elseif cQ or qu:len()<15000+c3+ck then c1="Orbit complete, proceeding with reentry"g4("orCom","OB")bg=gf.position;bR=true;cg=true;cO.VectorToTarget,cO.AutopilotAlign=false,false;cD.ToggleIntoOrbit()cD.BeginReentry()return end end;if fE.periapsis~=nil and fE.apoapsis~=nil and fE.eccentricity<1 and ck>cP*0.9 and ck<cP*1.4 then if fE.apoapsis~=nil then if fE.periapsis.altitude>=cP*0.99 and fE.apoapsis.altitude>=cP*0.99 and fE.periapsis.altitude<fE.apoapsis.altitude and fE.periapsis.altitude*1.05>=fE.apoapsis.altitude or cQ then if cQ then aX=false;cD.cmdThrottle(0)pT=0;if not cO.VectorToTarget then c1="Orbit complete"g4("orCom","OB")cD.ToggleIntoOrbit()end else pZ=pZ+1;if pZ>=2 then cQ=true end end else cN="Adjusting Orbit - OrbitHeight: "..qP;pW=true;cD.cmdCruise(qR*3.6+1)local qV=cP-ck;if qW==nil then qW=pid.new(0.1,0,1*0.1)end;qW:inject(qV-c_*dv(utils.smoothstep(2000-qV,-2000,2000)^6*10,1,10))pT=dv(qW:get(),-60,60)end end else local qX=2.75;local qY=f8(iu(qQ*qX))local os=qY%50;if os>0 then qY=qY-os+50 end;aX=false;if ck<cP*0.8 then cN="Escaping planet gravity - OrbitHeight: "..qP;pT=utils.map(c_,200,0,-15,80)elseif ck>=cP*0.8 and ck<cP*1.15 then cN="Approaching orbital corridor - OrbitHeight: "..qP;qY=qY*0.75;pT=utils.map(c_,100,-100,-15,65)elseif ck>=cP*1.15 and ck<cP*1.5 then cN="Approaching orbital corridor - OrbitHeight: "..qP;qY=qY*0.75;if c_<0 or pW then pT=utils.map(ck,cP*1.5,cP*1.01,-30,0)else pT=utils.map(ck,cP*0.99,cP*1.5,0,30)end elseif ck>cP*1.5 then cN="Reentering orbital corridor - OrbitHeight: "..qP;pT=-65;local qZ=utils.map(c_,-150,-400,1,0.55)qY=qY*qZ end;cD.cmdCruise(bF(qY))end end;if pT~=nil then if q_==nil then q_=pid.new(1*0.01,0,5*0.1)end;local r0=pT-d5;q_:inject(r0)local r1=dv(q_:get(),-0.5,0.5)bU=r1 end end;if a_ and cj==0 and not ce then local function r2(ij,fE)a.print(ij)aX=false;b9=false;a_=false;r3=false;bc="Aligning"cD.cmdThrottle(0)bQ=false;c1=ij;g4("apCom","AP")if fE or ce then if fE and gz~=nil and not ce then if not ck or ck==0 then return end;cP=ck;pX=true end;cD.ToggleIntoOrbit()end end;local r4,r5=bg,false;if gf and gf.planetname~="Space"then b8=true;if not r3 then local r6=(gf.position-c5.center):normalize()local r7=r6:project_on_plane((c5.center-d0):normalize()):normalize()local r8=c5.center+r7*(c5.radius+gz)local r9=gf.position+(gf.position-c5.center):normalize()*(gz-c5:getAltitude(gf.position))if(d0-r8):len()<(d0-r9):len()then r4=r8 else r4=r9;bb=0 end;bg=r4;cD.showWayPoint(c5,bg)r5=true;r3=true end;bd=0 elseif gf and gf.planetname=="Space"then if not r3 then bd=0;r5=true;b8=true;r3=true;r4=gf.position+(d0-gf.position):normalize()*S;bg=r4 end elseif gf==nil then bd=0;if not r3 then local r6=(d0+cX*100000-c5.center):normalize()local r7=r6:project_on_plane((c5.center-d0):normalize()):normalize()if r7:len()<1 then r6=(d0+cU*100000-c5.center):normalize()r7=r6:project_on_plane((c5.center-d0):normalize()):normalize()end;r4=c5.center+r7*(c5.radius+gz)bg=r4;r3=true;r5=true;b8=true;cD.showWayPoint(c5,bg)end end;pe=(vec3(r4)-d0):len()local lt,eT,eU=cx:getPlanetarySystem(0):castIntersections(d0,cX:normalize(),function(eC)if eC.noAtmosphericDensityAltitude>0 then return eC.radius+eC.noAtmosphericDensityAltitude else return eC.radius+eC.surfaceMaxAltitude*1.5 end end)local lu=eT;if eU~=nil and eT~=nil then lu=math.min(eU,eT)end;if lu~=nil and lu<pe and lt.name==c5.name then pe=lu end;local qI=true;local ra=(c5.center-(d0+vec3(cX):normalize()*pe)):len()-c5.radius;local li=ix(ra)g2(gr,'{"label": "Projected Altitude", "value": "'..li..'"}')local c3,c4;if not b0 then c3,c4=pJ(cY)else c3,c4=pL(cY)end;if cY>50 and b7 then local qu=vec3(r4)-d0;local rb=dv(math.deg(q2(cT,cX:normalize(),qu:normalize()))*cY/500,-90,90)local rc=dv(math.deg(q2(cV,cX:normalize(),qu:normalize()))*cY/500,-90,90)if f8(rb)<20 and f8(rc)<20 then rb=rb*2;rc=rc*2 end;if f8(rb)<2 and f8(rc)<2 then rb=rb*2;rc=rc*2 end;local qB=-math.deg(q2(cT,cU,cX:normalize()))local qC=-math.deg(q2(cV,cU,cX:normalize()))if rd==nil then rd=pid.new(2*0.01,0,2*0.1)end;rd:inject(rc-qC)local re=dv(rd:get(),-1,1)bU=bU+re;if rf==nil then rf=pid.new(2*0.01,0,2*0.1)end;rf:inject(rb-qB)local rg=dv(rf:get(),-1,1)bV=bV+rg;r5=true;if f8(rb)>2 or f8(rc)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"g4("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"g4("apAcc","AP")end end elseif b7 and cY<=50 then qn((r4-d0):normalize())end;if ra<gz*1.5 then if gf and gf.planetname=="Space"then bb=0 elseif gf==nil then dZ,bb=cA(c5):escapeAndOrbitalSpeed(ra)end end;if a_ and not b7 and not ba and not b9 then local lt,lu=cD.checkLOS((bg-d0):normalize())if c5.name~=iZ.name then if lt~=nil and c5.name~=lt.name and lu<pe then c1="Collision with "..lt.name.." in "..ix(lu).."\nClear LOS to continue."cb=5;qh=true else qh=false;c1=""end end end;if not qh then if not ba and not b9 and not r5 then qI=qn((r4-d0):normalize())elseif b0 and(b9 or ba)then qI=qn(-vec3(cX):normalize())end end;if b7 then if not bQ then aX=false;cD.cmdThrottle(a1)bL=iu(a1,2)bQ=true end;local pf=c.getThrottle()if u then pf=bL end;local rh=99999;local op=-vec3(b.getWorldAcceleration()):dot(cX:normalize())local ri=dv(cX:dot((r4-d0):normalize()),0,cY)if ri>0 or op>0 then rh=cy.computeTravelTime(ri,op,pe-c3)end;if cW:len()>=a0 or pf==0 and bQ or a2/4>rh then b7=false;if bc~="Cruising"then g4("apCru","AP")bc="Cruising"end;ba=true;cD.cmdThrottle(0)end;local rj=pe;if rj<=c3 or H and d9<=c3+10000 and d8 then if H and d9<=c3+10000 and d8 then if d9<pN and d9>2000 then cD.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pN=d9 else pN=d9;return end end;b7=false;if bc~="Braking"then g4("apBrk","AP")bc="Braking"end;b9=true;cD.cmdThrottle(0)bQ=false end elseif b9 then if bc~="Orbiting to Target"then aX=true;bY=1 end;if b0 then cD.cmdThrottle(1,true)end;local dZ,qR=cA(c5):escapeAndOrbitalSpeed((d0-iZ.center):len()-iZ.radius)local qu;if gf then qu=gf.position-d0 end;if gf and gf.planetname=="Space"and cY<50 then if#p_>0 then aX=false;cD.ToggleAutopilot()cD.ToggleAutopilot()return end;r2("Autopilot complete, arrived at space location")aX=true;bY=1 elseif gf and gf.planetname~="Space"and cY<=qR and(fE.apoapsis==nil or fE.periapsis==nil or fE.apoapsis.altitude<=0 or fE.periapsis.altitude<=0)then r2("Autopilot complete, commencing reentry")bg=gf.position;ce=true;cD.showWayPoint(c5,bg)elseif(gf and gf.planetname~="Space"or gf==nil)and fE.periapsis~=nil and fE.periapsis.altitude>0 and fE.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then g4("apCir","AP")bc="Circularizing"end;if cY<=qR then if gf then if cX:normalize():dot(qu:normalize())>0.4 then if bc~="Orbiting to Target"then g4("apOrb","OB")bc="Orbiting to Target"end;if not rk then aX=false;cD.showWayPoint(c5,gf.position)rk=true end else r2("Autopilot complete, proceeding with reentry")bg=gf.position;ce=true;cD.showWayPoint(c5,gf.position)rk=false end else r2("Autopilot completed, setting orbit",true)bY=0 end end elseif bc=="Circularizing"then r2("Autopilot complete, fixing Orbit",true)end elseif ba then local rj=pe;if rj<=c3 or H and d9<=c3+10000 and d8 then if H and d9<=c3+10000 and d8 then if d9<pN and d9>2000 then cD.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pN=d9 else pN=d9;return end end;b7=false;if bc~="Braking"then g4("apBrk","AP")bc="Braking"end;b9=true end;local pf=c.getThrottle()if u then pf=bL end;if pf>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"g4("apAcc","AP")end;ba=false end else if qI then if not b8 and gf==nil or not b8 and gf and gf.planetname~="Space"then if not ce then bg=vec3(c5.center)+(gz+c5.radius)*cV;rl=cT;rm=cV end;b8=true elseif qI and not qh then b7=true;if bc~="Accelerating"then bc="Accelerating"g4("apAcc","AP")end;if not bQ then cD.cmdThrottle(a1,true)bL=iu(a1,2)bQ=true;aX=false end end end end elseif a_ and(gf~=nil and gf.planetname~="Space"and cj>0)then c1="Autopilot complete, starting reentry"g4("apCom","AP")bg=gf.position;aX=false;b9=false;a_=false;r3=false;bc="Aligning"bY=0;cD.cmdThrottle(0)bQ=false;aZ=true;ce=true;cD.showWayPoint(c5,gf.position)end;if b_ then cI=true;local rc=0;local fG=d0+vec3(c.getMasterPlayerRelativePosition())local rn=fG-d0;local ro=vec3(rn):project_on(cU):len()local rp=vec3(rn):project_on(cV):len()local cc=dx(ro*ro+rp*rp)qn(rn:normalize())local mB=40;local rq=cc<mB;local rr=100;local rs=dv((cc-mB)/2,10,rr)bU=0;local qI=f8(bV)<0.1;if qI and cY<rs and not rq then aX=false;rc=-20 else aX=true;rc=0 end;local rt=0;if f8(rc-d5)>rt then if ru==nil then ru=pid.new(2*0.01,0,2*0.1)end;ru:inject(rc-d5)local re=ru:get()bU=re end end;if b1 or b2 or b4 or bm or bp~=nil then local rv=bq;if rv then rv=rv*dv(cY/100,0.1,1)*cj else rv=bo end;if cj<0.01 then rv=bo end;local rw=cU:project_on_plane(cZ):normalize():dot(cX)local rx=vec3(b.getWorldAirFrictionAcceleration())local ry=rx:len()*cm;if rw>100 then c3,c4=cy.computeDistanceAndTime(rw,100,cm,0,0,rv)local rz,rA=cy.computeDistanceAndTime(100,0,cm,0,0,rv*0.55)c3=c3+rz else c3,c4=cy.computeDistanceAndTime(rw,0,cm,0,0,rv*0.55)end;local qV=b6-ck-c_;local rB=200+cY;if b4 or ce then rC=2000+cY end;local rD=1;if b3 then rD=dv(cY/100,0.1,1)end;local rc=(utils.smoothstep(qV,-rB,rB)-0.5)*2*P*rD;if not b4 and not ce and not bm and cU:dot(cX:normalize())<0.99 then rc=(utils.smoothstep(qV,-rB*dv(20-19*cj*10,1,20),rB*dv(20-19*cj*10,1,20))-0.5)*2*P*dv(2-cj*10,1,2)*rD end;if not b1 then rc=0 end;if bp~=nil then if dc and not bv then rc=bp else bp=nil end end;cI=true;local rE=bU;if b4 then local rF=bF(cL)local rG,rH=cy.computeDistanceAndTime(cY,rF/3.6,cm,0,0,bo-iZ.gravity*9.8*cm)rG=rG==-1 and 5000 or rG;local rI=ck-(iZ.noAtmosphericDensityAltitude+rG)local rJ=ck>iZ.noAtmosphericDensityAltitude+rG*1.35;if rJ then rc=Q;if cY<=rF/3.6 and cY>rF/3.6-10 and f8(cX:normalize():dot(cU))>0.9 and not d4 then bP=false;cD.cmdThrottle(1)end elseif(d4 or is:getTargetSpeed(axisCommandId.longitudinal)~=rF)and not rJ and not ci then cD.cmdCruise(rF,true)end;if d4 then if cY>rF/3.6 and not rJ then aX=true else aX=false end else aX=false end;if c_>0 then aX=true end;if not bR then rc=-80;if ck<iZ.surfaceMaxAltitude+(iZ.atmosphereThickness-iZ.surfaceMaxAltitude)*0.25 then c1="PARACHUTE DEPLOYED at "..iu(ck,0)b4=false;b2=true;lp=true;cD.cmdThrottle(0)rc=0;cI=p end elseif iZ.noAtmosphericDensityAltitude>0 and rJ then cI=true elseif not rJ then if not ci and(d4 or is:getTargetSpeed(axisCommandId.longitudinal)~=rF)then cD.cmdCruise(rF)end;if cY<rF/3.6+1 then aX=false;bR=false;b4=false;cI=true end end end;if cY>iM and not cf and not bm and not b2 and v then qn(vec3(cX))end;if da or(bm or cf)and bh>0 and cj>0.01 then local qu;if da then if type(da)=="table"then qu=da elseif da<3 and da>0 then qu=-cZ:cross(cX)*5000 elseif da>=3 then qu=cZ:cross(cX)*5000 elseif da<0 then qu=cX*25000 end elseif gf~=nil then qu=gf.position-d0 else qu=c5.center-d0 end;local rb=math.deg(q2(cZ:normalize(),cX,qu))*2;local mE=math.rad(f8(d6))if cY>aH and cj>0.01 then local rK=1000+cY;local rL=(utils.smoothstep(qV-c_*10,-rK,rK)-0.5)*2*P;local rM=dv(90-rL,0,180)cK=dv(rb*2,-rM,rM)local rN=rb;rb=dv(dv(rb,-M*0.80,M*0.80)*math.cos(mE)+4*(d5-rc)*math.sin(math.rad(d6)),-M*0.80,M*0.80)local rO=1;if cK~=0 then rO=f8(mE/cK)end;rO=(90-dv(f8(cK-d6),0,90))/90;local rP=rc;if f8(d6)>90 then rP=-rP end;rc=rO*dv(dv(rP*math.cos(mE),-N*0.8,N*0.8)+f8(dv(f8(rN)*math.sin(mE),-N*0.80,N*0.80)),-N*0.80,N*0.80)else cK=0;rb=dv(rb,-M*0.80,M*0.80)end;local rQ=qB-rb;if da and f8(rQ)<=0.0001 and(type(da)=="table"or type(da)~="table"and da<0 and f8(d6)<1)then if da==-2 then cD.ToggleAltitudeHold()end;da=nil;g4("180Off","BR")return end;if not cJ and cY>aH and cj>0.01 then if rR==nil then rR=pid.new(2*0.01,0,2*0.1)end;rR:inject(rQ)local rg=dv(rR:get(),-1,1)bV=bV+rg elseif ci and ch>-1 or cY<aH then qn(qu)elseif cJ and cj>0.01 then if(qB<-M or qB>M)and cj>0.01 then qn(cX)end;if(qC<-N or qC>N)and cj>0.01 then rc=dv(d5-qC,d5-N*0.80,d5+N*0.80)end end;if gf~=nil and not cf then local qJ=iZ:getAltitude(gf.position)local rI=qu:project_on_plane(cZ):len()lp=true;if not cf and not b4 and rI<=c3 and(cX:project_on_plane(cZ):normalize():dot(qu:project_on_plane(cZ):normalize())>0.99 or lx=="Finalizing Approach")then lx="Finalizing Approach"if#p_>0 then cD.ToggleAutopilot()cD.ToggleAutopilot()return end;cD.cmdThrottle(0)if b1 then cD.ToggleAltitudeHold()bm=true end;aX=true elseif not b3 then aX=false end;if lx=="Finalizing Approach"and(rw<0.1 or rI<0.1 or rS~=nil and rS<rI)then if not d2 then g4("bklOn","BL")b2=true;dr=true;if gf.heading then ds=gf.heading else ds=nil end end;bm=false;if bf=="STARTINGPOINT"then cC.ClearCurrentPosition()end;lx="Proceeding to Waypoint"dd=false end;rS=rI end elseif bm and cj==0 and b6>iZ.noAtmosphericDensityAltitude and not(cf or b4)then if gf~=nil and c5.name==iZ.name then local qu=gf.position-d0;local qJ=iZ:getAltitude(gf.position)local rI=dx(qu:len()^2-(ck-qJ)^2)local rv=bq;if rv then c3,c4=cy.computeDistanceAndTime(cY,0,cm,0,0,rv/2)lp=true;if rI<=c3+cY*qA/2 and cX:project_on_plane(cZ):normalize():dot(qu:project_on_plane(cZ):normalize())>0.99 then if iZ.hasAtmosphere then aX=false;aZ=false;bR=true;ce=false;cg=true;a_=false;cD.BeginReentry()end end;rS=rI end end end;if cj==0 and(b1 and b6>iZ.noAtmosphericDensityAltitude)and not(cf or bv or b4)then if not cQ and not bv then cP=b6;pX=true;if bm then cO.VectorToTarget=true end;cD.ToggleIntoOrbit()bm=false;pV=true end end;if cJ and cj>0.01 and ch==-1 and cY>aH and lx~="Finalizing Approach"then qn(cX)rc=dv(d5-qC,d5-N*0.80,d5+N*0.80)end;bU=rE;local qb=-1;if b2 then rc=0;if ds then if rw<0.05 and rw>-0.05 then if c_>-O then aX=false else aX=true end;if qn(ds,0.0001)then ds=nil;cI=p else bU=0;cI=true end else aX=true end else local rT=false;local rU=30;if cz~=nil and cz>0 then local rV=dv(cj,0.4,2)local rv=bq*dv(cY/100,0.1,1)*rV;local rW=cz*rV+rv-gM;local rX=rv/2-gM;local rY=cY-dx(f8(rX/2)*20/(0.5*cm))*utils.sign(rX)if rY<0 then rY=0 end;local rZ;if cY>100 then local r_,dZ=cy.computeDistanceAndTime(cY,100,cm,0,0,rv)local s0,dZ=cy.computeDistanceAndTime(100,0,cm,0,0,dx(rv))rZ=r_+s0 else rZ=cy.computeDistanceAndTime(cY,0,cm,0,0,dx(rv))end;if rZ<20 then aX=false else local s1=0;if rY>100 then local s2,dZ=cy.computeDistanceAndTime(rY,100,cm,0,0,rW)local s3,dZ=cy.computeDistanceAndTime(100,0,cm,0,0,cz*rV+dx(rv)-gM)s1=s2+s3 else s1,dZ=cy.computeDistanceAndTime(rY,0,cm,0,0,cz*rV+dx(rv)-gM)end;s1=(s1+15+cY*qA)*1.1;local s4=gf~=nil and iZ:getAltitude(gf.position)>0 and gf.safe;if s4 then local qJ=iZ:getAltitude(gf.position)local s5=ck-qJ-100;local qu=gf.position-d0;local s6=dx(qu:len()^2-(ck-qJ)^2)if s6>100 then s4=false elseif s5<=s1 or s1==-1 then aX=true;rT=true else aX=false;rT=true end end;if not s4 and t then if s1>=rU then aX=true else aX=false end;rT=true end end end;if not d4 then cD.cmdThrottle(0)end;is:setTargetGroundAltitude(500)is:activateGroundEngineAltitudeStabilization(500)bx=true;qb=ch;if qb>-1 then if(cY<1 or cX:normalize():dot(cZ)<0)and not ds then b2=false;b1=false;bi=true;if bS then d.control.extendLandingGears()g4("grOut","LG",1)end;is:setTargetGroundAltitude(Z)c8=0;aX=true;cI=p;dr=false else aX=true end elseif lp and cX:normalize():dot(-gB)<0.999 then aX=true;qn()elseif c_<-O and not rT or(rw>0.05 or rw<-0.05)and dr then aX=true elseif not rT then aX=false end end end;if b3 or cf then local lt,eU,eT;if bg~=nil then lt,eU,eT=cx:getPlanetarySystem(0):castIntersections(d0,(bg-d0):normalize(),function(eC)return eC.radius+eC.noAtmosphericDensityAltitude end)end;if d2 then if ck>=b6-50 then b3=false;if not a_ and not bm then aX=true;cD.cmdThrottle(0)end else b6=antigrav.getBaseAltitude()end elseif f8(rc)<15 and ck/b6>0.75 then b3=false;if not cf then if d4 and not u then d.control.cancelCurrentControlMasterMode()end elseif cf and cY<iM then a_=true;cf=false;b1=false;b3=false;cD.cmdThrottle(0)elseif cf then cD.cmdThrottle(0)aX=true end elseif cf and cj==0 and c5~=nil and(lt==nil or lt.name==c5.name)then a_=true;cf=false;b1=false;b3=false;if not d4 then cD.cmdThrottle(0)end;b7=true end end;local s7=ch>-1;local s8=d5;if(bm or cf or da)and not s7 and cY>aH and cj>0.01 then local mE=math.rad(f8(d6))s8=d5*f8(math.cos(mE))+qC*math.sin(mE)end;local s9=dv(rc-s8,-N*0.80,N*0.80)if cj<0.01 and bm then s9=dv(rc-s8,-85,P)elseif cj<0.01 then s9=dv(rc-s8,-P,P)end;if f8(d6)<5 or bm or da or b2 or s7 or b1 then if ru==nil then ru=pid.new(5*0.01,0,5*0.1)end;ru:inject(s9)local re=ru:get()bU=bU+re end end;if antigrav~=nil and(antigrav and not q and ck<200000)then if br==nil or br<1000 then br=1000 end;if sa~=br then sa=br;antigrav.setBaseAltitude(sa)end end end;function pI.ToggleIntoOrbit()cQ=false;pT=nil;pU=nil;pZ=0;if cj==0 then if bv then g4("orOff","AP")bv=false;pV=false;pY=nil;cI=p;if b1 then b1=false;b3=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pX=false elseif dc then g4("orOn","AP")bv=true;cI=true;if pY==nil then pY=iZ end;if b1 then b1=false;b3=false end else c1="Unable to engage auto-orbit, not near a planet"end else bv=false;pV=false;pY=nil;cI=p;if b1 then b1=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pX=false end end;function pI.ToggleVerticalTakeoff()b1=false;if b5 then lp=true;b4=false;b3=false;b2=true;cI=true;c8=0;if ci and ch==-1 then b2=false;b1=true;c8=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cD.cmdCruise(bF(cL))end else cQ=false;bi=false;d.control.retractLandingGears()is:setTargetGroundAltitude(Y)aX=true end;b5=not b5 end;function pI.checkLOS(qo)local lt,eT,eU=cx:getPlanetarySystem(0):castIntersections(d0,qo,function(eC)if eC.noAtmosphericDensityAltitude>0 then return eC.radius+eC.noAtmosphericDensityAltitude else return eC.radius+eC.surfaceMaxAltitude*1.5 end end)local lu=eT;if eU~=nil and eT~=nil then lu=math.min(eU,eT)end;if lu~=nil then return lt,lu else return nil,nil end end;function pI.ToggleAutopilot()local function sb(bt)dd=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cD.ToggleAltitudeHold()end end;lx="Proceeding to Waypoint"end;local sc=false;if bH-pS<1.5 and cj>0 then if not cS then c1="No space engines detected, Orbital Hop not supported"return end;if iZ.hasAtmosphere then if cj>0 then b6=iZ.noAtmosphericDensityAltitude+U;g4("orH","OH")end;pS=-1;if a_ or bm or bv then return end end else pS=bH end;r3=false;if(bh>0 or#p_>0)and not a_ and not bm and not cf and not bv then if 0.5*d:maxForceForward()/b.g()<cm then c1="WARNING: Heavy Loads may affect autopilot performance."cb=5 end;if#p_>0 and not cg then bh=p_[1]cC.UpdateAutopilotTarget()table.remove(p_,1)c1="Route Autopilot in Progress"local qu=gf.position-d0;local rI=qu:project_on_plane(cZ):len()if rI>50000 and gf.planetname==iZ.name then sc=true end end;cC.UpdateAutopilotTarget()cD.showWayPoint(c5,bg)if J and#p_==0 and bf~="STARTINGPOINT"and cC.findAtlasIndex(bl,"STARTINGPOINT")==-1 and ch>-1 then cC.AddNewLocation("STARTINGPOINT",d0,false,false)end;if gf~=nil then bp=nil;bt=gf.planetname=="Space"if bt then g4("apSpc","AP")if cj~=0 then cf=true;cD.ToggleAltitudeHold()else a_=true end elseif iZ.name==gf.planetname then lp=true;if cj>0 then if not bm then g4("vtt","AP")sb(bt)if sc then b6=iZ.noAtmosphericDensityAltitude+U end end else g4("apOn","AP")if not(c5.name==iZ.name and ck<gz*1.5)then cQ=false;a_=true elseif not ci then if bv then cD.ToggleIntoOrbit()end;cP=iZ.noAtmosphericDensityAltitude+U;pX=true;cO.AutopilotAlign=true;cO.VectorToTarget=true;pV=false;if not bv then cD.ToggleIntoOrbit()end end end else g4("apP","AP")aY=false;aZ=false;if cj~=0 then cf=true;cD.ToggleAltitudeHold()else a_=true end end elseif cj==0 then if gf==nil and(c5.name==iZ.name and dc)and not bv then rk=false;cQ=false;pV=false;cD.ToggleIntoOrbit()else g4("apP","AP")a_=true;aY=false;aZ=false;b8=false;b_=false;b1=false;b2=false;b4=false;b3=false;bQ=false;bp=nil;rk=false end else g4("apP","AP")cf=true;cD.ToggleAltitudeHold()end else g4("apOff","AP")cD.ResetAutopilots(1)end end;function pI.routeWP(sd,se,sf)if sf then if sf==1 then p_={}p_=iv(p_,bA)if#p_>0 then c1="Route Loaded"else c1="No Saved Route found on Databank"end;return p_ else bA={}bA=iv(bA,p_)c1="Route Saved"pH()return end end;if sd then return p_ end;if se then p_={}c1="Current Route Cleared"else p_[#p_+1]=bh;c1="Added "..gf.name.." to route. "end;return p_ end;function pI.cmdThrottle(dV,sg)if is:getAxisCommandType(0)~=axisCommandType.byThrottle and not sg then d.control.cancelCurrentControlMasterMode()end;is:setThrottleCommand(axisCommandId.longitudinal,dV)bL=dv(iu(dV*100,0)/100,-1,1)d3=nil end;function pI.cmdCruise(dV,sg)if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not sg then d.control.cancelCurrentControlMasterMode()end;is:setTargetSpeedCommand(axisCommandId.longitudinal,dV)d3=dV end;function pI.ToggleLockPitch()if bp==nil then g4("lkPOn","LP")if not c0 then bp=d5 else bp=R end;b3=false;b1=false;b2=false else g4("lkPOff","LP")bp=nil end end;function pI.ToggleAltitudeHold()if bH-pR<1.5 then if iZ.hasAtmosphere then if cj>0 then b6=iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude;g4("11","EP")else if dc then b6=iZ.noAtmosphericDensityAltitude+U;cP=b6;pX=true;if not bv then cD.ToggleIntoOrbit()end;pV=true end end;pR=-1;if b1 or bv or b5 then return end end else pR=bH end;if dc and cj==0 then cP=ck;pX=true;pV=true;cD.ToggleIntoOrbit()if bv then pR=bH else pR=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;b_=false;cI=true;bp=nil;cQ=false;if ch~=-1 and cY<20 then g4("lfs","LS")b3=true;if pR>-1 then b6=ck+X end;bi=false;d.control.retractLandingGears()aX=true;is:setTargetGroundAltitude(Y)if aW and d1 then cD.ToggleVerticalTakeoff()end else g4("altOn","AH")b3=false;if pR>-1 then if dc then b6=ck end end;if b5 then cD.ToggleVerticalTakeoff()end end;if cf then b6=100000 end else g4("altOff","AH")if bv then cD.ToggleIntoOrbit()end;if b5 then cD.ToggleVerticalTakeoff()end;cI=p;b3=false;bm=false;pR=0 end end;function pI.ResetAutopilots(pI)if pI then cf=false;a_=false;b8=false;bQ=false;b6=ck;r3=false;dr=false end;bm=false;b3=false;b4=false;aZ=false;b2=false;ds=nil;sh=false;da=nil;dr=false;if not d2 then b1=false;bp=nil end;if b5 then cD.ToggleVerticalTakeoff()end;if bv then cD.ToggleIntoOrbit()end;cI=p;ce=false;cg=false;c8=0 end;function pI.BrakeToggle()aX=not aX;if b2 then b2=false;cI=p end;if aX then g4("bkOn","B",1)cD.ResetAutopilots()else g4("bkOff","B",1)end end;function pI.BeginReentry()if b4 then c1="Re-Entry cancelled"g4("reOff","RE")b4=false;cI=p;b1=false elseif not iZ.hasAtmosphere then c1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"cb=5 elseif not bR then b4=true;if is:getAxisCommandType(0)~=si.cruise then d.control.cancelCurrentControlMasterMode()end;cI=true;aX=false;c1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cL;g4("par","RE")else b4=true;b1=true;cI=true;aX=false;b6=iZ.surfaceMaxAltitude+_;if b6>iZ.spaceEngineMinAltitude then b6=iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude end;local sj=ix(b6)c1="Beginning Re-entry.  Target speed: "..cL.." Target Altitude: "..sj;g4("glide","RE")cD.cmdCruise(bF(cL))end;b3=false end;function pI.ToggleAntigrav()if antigrav and not q then if d2 then g4("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=ck end;if br<1000 then br=1000 end;g4("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pI.changeSpd(sk)local sl=1;if sk then sl=-1 end;if not c0 then if u and not p1 and cn then local sm=bL;bL=iu(dv(bL+sl*aA/100,-1,1),2)if bL>=0 and sm<0 then bL=0;cn=false end elseif p1 then if cj>0 or b4 then cL=dv(cL+sl*aA,0,V)elseif a_ then a0=dv(a0+sl*aA/3.6*100,0,8333.00)end else is:updateCommandFromActionStart(axisCommandId.longitudinal,sl*aA/10)end else if a_ or bm or cf or bv then dg=dg+1*sl*-1;if dg>#d7 then dg=1 end;if dg<1 then dg=#d7 end else if not sk then sl=1 else sl=nil end;cC.adjustAutopilotTargetIndex(sl)end end end;function pI.TenthTick()local function sn(gM,so)if gM==nil then gM=b.g()end;gM=iu(gM,5)if so~=nil and so or(q0==nil or q0~=gM)then local fA=cW:len()local sp=ip(c.getData()).maxBrake;if sp~=nil and sp>0 and ci then sp=sp/dv(fA/100,0.1,1)sp=sp/cj;if cj>0.10 then if bq then bq=(bq+sp)/2 else bq=sp end end end;if sp~=nil and sp>0 then bo=sp end;q0=gM end end;sn(nil,true)if d3~=nil then if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or is:getTargetSpeed(axisCommandId.longitudinal)~=d3 then cD.cmdCruise(d3)else d3=nil end end end;function pI.SatNavTick()if not r then return end;q1=dbHud_1.getStringValue("SPBAutopilotTargetName")if q1~=nil and q1~=""and q1~="SatNavNotChanged"then local dP=ip(dbHud_1.getStringValue("SavedLocations"))if dP~=nil then bl=dP;local gG=-1;local gN;for dU,dG in pairs(bl)do if dG.name and dG.name=="SatNav Location"then gG=dU;break end end;if gG~=-1 then gN=bl[gG]gG=-1;for dU,dG in pairs(e[0])do if dG.name and dG.name=="SatNav Location"then gG=dU;break end end;if gG>-1 then e[0][gG]=gN end;cC.UpdateAtlasLocationsList()c1=gN.name.." position updated"end end;for L=1,#d7 do if d7[L].name==q1 then bh=L;a.print("Index = "..bh.." "..d7[L].name)cC.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;ch=q6()return pI end;local function sq(d,b,c,a,e,vBooster,hover,antigrav,im,dbHud_2,gyro,screenHud_1,ir,is,it,sr,gU,iu,ee,dw,dv,g4,iw,pH)local ss={}local st=true;local su=5;local sv=5;local sw=su;local sx=sv;local sy=bH;function ss.startControl(sz)local function sA(sk)local sl=1;local function sB(sC,sk)local sD={iZ.surfaceMaxAltitude+100,iZ.spaceEngineMinAltitude-0.01*iZ.noAtmosphericDensityAltitude,iZ.noAtmosphericDensityAltitude+U,iZ.radius*(T-1)+iZ.noAtmosphericDensityAltitude}local sE=sC;for dZ,dG in ipairs(sD)do if sk and sE>dG then sC=dG elseif sC<dG and not sk then sC=dG;break end end;return sC end;if sk then sl=-1 end;if not q and d2 then if c0 and sk then br=1000 elseif br~=nil then br=br+sl*sv;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=sa+sl*100 end elseif b1 or b5 or bv then if bv then if c0 then cP=sB(cP,sk)else cP=cP+sl*su end;if cP<iZ.noAtmosphericDensityAltitude then cP=iZ.noAtmosphericDensityAltitude end else if c0 and ci then b6=sB(b6,sk)else b6=b6+sl*su end end else is:updateTargetGroundAltitudeFromActionStart(sl*1.0)end end;local function sF(sG)if not ci then c1="Flight Assist in Atmo only"return end;local dD=type(sG)if da==nil then if dD=="table"then if a_ or bm then cD.ToggleAutopilot()end;g4("180On","BR")elseif sG==1 then g4("bnkLft","BR")else g4("bnkRht","BR")end;if not b1 and not a_ and not bm then cD.ToggleAltitudeHold()if dD~="table"then sG=sG+1 end end;da=sG else g4("180Off","BR")da=nil end end;if sz=="gear"then bi=not bi;if bi then bm=false;bp=nil;cD.cmdThrottle(0)if vBooster or hover then if ci and ch==-1 then g4("bklOn","BL")lp=true;b4=false;b3=false;b5=false;b1=false;b2=true;dr=false;cI=true;bi=false else if bS then g4("grOut","LG",1)d.control.extendLandingGears()end;is:setTargetGroundAltitude(Z)if ci then aX=true end end end;if bS and not b2 and not(vBooster or hover)then g4("grOut","LG",1)d.control.extendLandingGears()end else if bS then g4("grIn","LG",1)d.control.retractLandingGears()end;is:setTargetGroundAltitude(Y)end elseif sz=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif sz=="forward"then bT=bT-1 elseif sz=="backward"then if p1 then sF(-cX*5000)else bT=bT+1 end elseif sz=="left"then if p1 then sF(1)else bW=bW-1 end elseif sz=="right"then if p1 then sF(3)else bW=bW+1 end elseif sz=="yawright"then bX=bX-1;ds=nil elseif sz=="yawleft"then bX=bX+1;ds=nil elseif sz=="straferight"then is:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif sz=="strafeleft"then is:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif sz=="up"then c8=c8+1;is:deactivateGroundEngineAltitudeStabilization()is:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif sz=="down"then c8=c8-1;is:deactivateGroundEngineAltitudeStabilization()is:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif sz=="groundaltitudeup"then sA()elseif sz=="groundaltitudedown"then sA(true)elseif sz=="option1"then sH=false;if p1 and c0 then local sI=""for L=1,#dh do sI=sI.."| Name: "..a.getPlayerName(dh[L]).." Mass: "..iu(b.getBoardedPlayerMass(dh[L])/1000,1).."t "end;a.print("Onboard: "..sI)return end;cC.adjustAutopilotTargetIndex()elseif sz=="option2"then sH=false;if p1 and c0 then for L=1,#dh do b.forceDeboard(dh[L])end;c1="Deboarded All Passengers"return end;cC.adjustAutopilotTargetIndex(1)elseif sz=="option3"then local function sJ()st=not st;if not st then g4("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sK,atmofueltank_size,"Atmo Fuel","fuel_container")sL=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sM,spacefueltank_size,"Space Fuel","fuel_container")sN=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sO,rocketfueltank_size,"Rocket Fuel","fuel_container")sP=_autoconf.panels[_autoconf.panels_size]end;sQ=a.createWidgetPanel("Docking")sR=a.createWidget(sQ,"parenting")a.addDataToWidget(c.getDataId(),sR)sS=a.createWidgetPanel("Core combat stress")sT=a.createWidget(sS,"core_stress")a.addDataToWidget(b.getDataId(),sT)if im~=nil then im.show()end else g4("hud","DH")c.hide()b.hide()if sL~=nil then gU(sL)sL=nil end;if sQ~=nil then gU(sQ)sQ=nil end;if sS~=nil then gU(sS)sS=nil end;if sN~=nil then gU(sN)sN=nil end;if sP~=nil then gU(sP)sP=nil end;if im~=nil then im.hide()end end end;sH=false;if p1 and c0 then local sI=""for L=1,#di do sI=sI.."| ID: "..di[L].." Mass: "..iu(b.getDockedConstructMass(di[L])/1000,1).."t "end;a.print("Docked Ships: "..sI)return end;if y then if x then x=false else x=true end end;sJ()elseif sz=="option4"then sH=false;if p1 and c0 then for L=1,#di do b.forceUndock(di[L])end;c1="Undocked all ships"return end;da=nil;cD.ToggleAutopilot()elseif sz=="option5"then sH=false;cD.ToggleLockPitch()elseif sz=="option6"then sH=false;if p1 and c0 then if im then local sU=im.getVentingCooldown()if sU>0 then c1="Cannot vent again for "..sU.." seconds"return end;if im.getShieldHitpoints()<im.getMaxShieldHitpoints()then im.startVenting()c1="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c1="Shields already at max hitpoints"end;return else c1="No shield found"return end end;cD.ToggleAltitudeHold()elseif sz=="option7"then sH=false;if p1 and c0 then if im then im.toggle()return else c1="No shield found"return end end;F=not F;if F then c1="Collision System Enabled"else c1="Collision System Secured"end elseif sz=="option8"then sH=false;if p1 and c0 then if bh>0 and gf~=nil then cD.routeWP()else c1="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then c1="DeCoupled Mode - Ground Stabilization off"is:deactivateGroundEngineAltitudeStabilization()g4("gsOff","GS")else c1="Coupled Mode - Ground Stabilization on"is:activateGroundEngineAltitudeStabilization(sV)d:setEngineForceCommand('hover',vec3(),1)g4("gsOn","GS")end elseif sz=="option9"then sH=false;if p1 and c0 then is:resetCommand(axisCommandId.longitudinal)is:resetCommand(axisCommandId.lateral)is:resetCommand(axisCommandId.vertical)cD.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()co=gyro.getState()==1;if co then g4("gyOn","GA")else g4("gyOff","GA")end else c1="No gyro found"end elseif sz=="lshift"then df=false;if p1 then c0=true end;if it()==1 then c0=true;be=it()sr(1)elseif ir()==1 and z then c0=true;cH=false;cG=false end elseif sz=="brake"then if aV or p1 then cD.BrakeToggle()elseif not aX then cD.BrakeToggle()else aX=true end elseif sz=="lalt"then sH=true;p1=true;if ir()==0 and not i and g=="keyboard"then sr(1)end elseif sz=="booster"then if n then d:toggleBoosters()elseif not c2 then if not sW then d:toggleBoosters()sW=true end;c2=true else if sW then d:toggleBoosters()sW=false end;c2=false end elseif sz=="stopengines"then local function sX()if bH-sy<1.5 then g4("clear","CA")b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;da=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;b_=false;bQ=false;ce=false;cf=false;bR=false;cI=p;bm=false;b0=false;co=false;bp=nil;bv=false;dr=false;ds=nil end end;sX()sy=bH;if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then is:resetCommand(axisCommandId.longitudinal)cD.cmdThrottle(0)else cD.cmdThrottle(100)end else if is:getTargetSpeed(axisCommandId.longitudinal)~=0 then is:resetCommand(axisCommandId.longitudinal)else if ci then cD.cmdCruise(V)else cD.cmdCruise(a0*3.6)end end end elseif sz=="speedup"then cD.changeSpd()elseif sz=="speeddown"then cD.changeSpd(true)elseif sz=="antigravity"and not q then if antigrav~=nil then cD.ToggleAntigrav()else c1="No antigrav found"end end end;function ss.stopControl(sz)local function sY()if not q and d2 then sx=sv end;if b1 or b5 or bv then sw=su end end;if sz=="forward"then bT=0 elseif sz=="backward"then bT=0 elseif sz=="left"then if da then if da==2 then da=-2 else da=-1 end end;bW=0 elseif sz=="right"then if da then if da==4 then da=-2 else da=-1 end end;bW=0 elseif sz=="yawright"then bX=0 elseif sz=="yawleft"then bX=0 elseif sz=="straferight"then is:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif sz=="strafeleft"then is:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif sz=="up"then c8=0;is:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then is:activateGroundEngineAltitudeStabilization(sV)d:setEngineForceCommand('hover',vec3(),1)end elseif sz=="down"then c8=0;is:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then is:activateGroundEngineAltitudeStabilization(sV)d:setEngineForceCommand('hover',vec3(),1)end elseif sz=="groundaltitudeup"then sY()sH=false elseif sz=="groundaltitudedown"then sY()sH=false elseif sz=="lshift"then if it()==1 then c9=0;ca=0;sr(be)elseif ir()==1 and z then cH=false;cG=false end;c0=false elseif sz=="brake"then if not aV and not p1 then if aX then cD.BrakeToggle()else aX=false end end elseif sz=="lalt"then if ir()==0 and i then if sH then if it()==1 then sr(0)else sr(1)end else sH=true end elseif ir()==0 and not i and g=="keyboard"then sr(0)end;p1=false end end;function ss.loopControl(sz)local function sZ(sk)local sl=1;if sk then sl=-1 end;if not q and d2 then if br~=nil then br=br+sl*sx;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;sx=dv(sx*1.05,sv,50)else br=sa+sl*100 end elseif b1 or b5 or bv then if bv then cP=cP+sl*sw;if cP<iZ.noAtmosphericDensityAltitude then cP=iZ.noAtmosphericDensityAltitude end else b6=b6+sl*sw end;sw=dv(sw*1.05,su,50)else is:updateTargetGroundAltitudeFromActionLoop(sl*1.0)end end;local function s_(sk)local sl=1;if sk then sl=-1 end;if not c0 then if u and not p1 then bL=dv(bL+sl*aB/100,-1,1)else is:updateCommandFromActionLoop(axisCommandId.longitudinal,sl*aB)end end end;if sz=="groundaltitudeup"then if not c0 then sZ()end elseif sz=="groundaltitudedown"then if not c0 then sZ(true)end elseif sz=="speedup"then s_()elseif sz=="speeddown"then s_(true)end end;function ss.inputTextControl(sj)local function t0(t1,fG,gJ)local function t2(fG)local dM=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dN='::pos{'..dM..','..dM..','..dM..','..dM..','..dM..'}'local e2,e3,eb,ec,ed=ee(fG,dN)if e2=="0"and e3=="0"then return vec3(dw(eb),dw(ec),dw(ed))end;ec=math.rad(ec)eb=math.rad(eb)local iZ=e[dw(e2)][dw(e3)]local f4=math.cos(eb)local t3=vec3(f4*math.cos(ec),f4*math.sin(ec),math.sin(eb))return iZ.center+(iZ.radius+ed)*t3 end;local g6=t2(fG)return cC.AddNewLocation(t1,g6,gJ)end;local L;local t4,t5=nil,nil;local t6="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate - dumps all custom waypoints to logfile and a screen if present for cut and paste to privatelocations.lua"L=string.find(sj," ")t4=sj;if L~=nil then t4=string.sub(sj,0,L-1)t5=string.sub(sj,L+1)end;if t4=="/help"or t4=="/commands"then for oz in string.gmatch(t6,"([^\n]+)")do a.print(oz)end;return elseif t4=="/setname"then if t5==nil or t5==""then c1="Usage: ah-setname Newname"return end;if bh>0 and gf~=nil then cC.UpdatePosition(t5)else c1="Select a saved target to rename first"end elseif im and t4=="/resist"then if not im then c1="No shield found"return elseif t5==nil or im.getResistancesCooldown()>0 then c1="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dM=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dN=dM..', '..dM..', '..dM..', '..dM;local t7,t8,t9,ta=ee(t5,dN)if ta==nil or t7+t8+t9+ta>0.6 then c1="Improperly formatted or total exceeds 0.6"return end;if im.setResistances(t7,t8,t9,ta)==1 then c1="Shield Resistances set"else c1="Resistance setting failed."end elseif t4=="/addlocation"or string.find(sj,"::pos")~=nil then local gJ=false;local t1="0-Temp"if t5==nil or t5==""then t5=t4;gJ=true end;L=string.find(t5,"::")if not gJ then t1=string.sub(t5,1,L-2)end;local fG=string.sub(t5,L)t0(t1,fG,gJ)elseif t4=="/agg"then if t5==nil or t5==""then c1="Usage: /agg targetheight"return end;t5=dw(t5)if t5<1000 then t5=1000 end;br=t5;c1="AGG Target Height set to "..t5 elseif t4=="/G"then if t5==nil or t5==""then c1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if t5=="dump"then for dU,dG in pairs(iw())do if type(dG.get())=="boolean"then if dG.get()==true then a.print(dU.." true")else a.print(dU.." false")end elseif dG.get()==nil then a.print(dU.." nil")else a.print(dU.." "..dG.get())end end;return end;L=string.find(t5," ")local tb=string.sub(t5,0,L-1)local tc=string.sub(t5,L+1)for dU,dG in pairs(iw())do if dU==tb then c1="Variable "..tb.." changed to "..tc;local td=type(dG.get())if td=="number"then tc=dw(tc)if dU=="AtmoSpeedLimit"then cL=tc end elseif td=="boolean"then if string.lower(tc)=="true"then tc=true else tc=false end end;dG.set(tc)return end end;c1="No such global variable: "..tb elseif t4=="/deletewp"then if bh>0 and gf~=nil then cC.ClearCurrentPosition()else c1="Select a custom wp to delete first in IPH"end elseif t4=="/copydatabank"then if dbHud_2 then pH(true)else c1="Spare Databank required to copy databank"end elseif t4=="/iphWP"then if bh>0 then a.print(cD.showWayPoint(c5,bg,true))a.print(json.encode(bg))c1="::pos waypoint shown in lua chat in local and world format"else c1="No target selected in IPH"end elseif t4=="/createPrivate"then if#dp>0 then local te="privatelocations = {\n"for dU,dG in pairs(dp)do te=te.."{position = {x = "..dG.position.x..", y = "..dG.position.y..", z = "..dG.position.z.."},\n ".."name = '"..dG.name.."',\n planetname = '"..dG.planetname.."',\n gravity = "..dG.gravity..",\n save = "if dG.safe then te=te.."true},\n"else te=te.."false},\n"end end;te=te.."}\n return privatelocations"a.logInfo("PRIVATELOCATIONS:"..te)if screenHud_1 then screenHud_1.setHTML(te)end;c1="privatelocations.lua created in logfile and on attached screen if present"else c1="No private locations to save"end end end;function ss.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;c1="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;return ss end;local function tf(d,b,c,a,library,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,im,gyro,warpdrive,io,screenHud_1)local tg={}local du=string.format;local ip=json.decode;local th=json.encode;local pA=b.getElementMaxHitPointsById;local iq=b.getElementMassById;local ir=d.control.isRemoteControlled;local ee=string.match;local gU=a.destroyWidgetPanel;local g2=a.updateData;local g3=a.addDataToWidget;local sr=a.lockView;local it=a.isViewLocked;local dx=math.sqrt;local dw=tonumber;local f8=math.abs;local bF=math.floor;local bG=c.getAtmosphereDensity;local f3=math.atan;local bE=a.getTime;local dv=utils.clamp;local is=d.axisCommandManager;local ti=Z;local gW=13;local iz=b.getElementIdList()local iA=0;local function dy(eM,eN)if eM==0 then return f8(eN)<1e-09 end;if eN==0 then return f8(eM)<1e-09 end;return f8(eM-eN)<math.max(f8(eM),f8(eN))*dL end;local function iu(dM,tj)local sl=10^(tj or 0)return bF(dM*sl+0.5)/sl end;local function iv(tk,tl)for dU,dG in pairs(tl)do if type(dU)=="string"then tk[dU]=dG else tk[#tk+1]=tl[dU]end end;return tk end;local function iw(tm)local tn={}if not tm then iv(tn,K)iv(tn,a8)iv(tn,az)iv(tn,aU)return tn elseif tm=="boolean"then return K elseif tm=="handling"then return a8 elseif tm=="hud"then return az elseif tm=="physics"then return aU end end;local function pH(to)local function tp(tq)for dU,dG in pairs(tq)do dbHud_1.setStringValue(dU,th(dG.get()))if to and dbHud_2 then dbHud_2.setStringValue(dU,th(dG.get()))end end end;if dbHud_1 then tp(bB)tp(iw())a.print("Saved Variables to Datacore")if to and dbHud_2 then c1="Databank copied.  Remove copy when ready."end end end;local function g4(tr,ts,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..tr.."|"..ts.."|"..ay)else a.logInfo("sound_notification|audiopacks/"..h.."/"..tr.."|"..ts.."|"..ay)end else a.logInfo("sound_q|audiopacks/"..h.."/"..tr.."|"..ts.."|"..ay)end end;local function gV(hv,hw,sj,jD,tt)if jD==nil then jD=""end;if tt==nil then tt=""end;return du([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jD,hv,hw,tt,sj)end;local function ix(cc,tu)local tv=cc>100000;if tu==nil then tu=1 end;if tv then return iu(cc/1000/200,tu).."SU"elseif cc<1000 then return iu(cc,tu).."M"else return iu(cc/1000,tu).."KM"end end;local function iy(tw)local tx=0;local ty=0;local tz=0;if tw<60 then tw=bF(tw)elseif tw<3600 then tx=bF(tw/60)tw=bF(tw%60)elseif tw<86400 then ty=bF(tw/3600)tx=bF(tw%3600/60)else tz=bF(tw/86400)ty=bF(tw%86400/3600)end;if tz>0 then return tz.."d "..ty.."h "elseif ty>0 then return ty.."h "..tx.."m "elseif tx>0 then return tx.."m "..tw.."s"elseif tw>0 then return tw.."s"else return"0s"end end;function tg.onStart()local tA=false;local function tB()local function tC(tD)local tE=dbHud_1.hasKey;for dU,dG in pairs(tD)do if tE(dU)then local dP=ip(dbHud_1.getStringValue(dU))if dP~=nil then dG.set(dP)tA=true end end end end;if dbHud_1 then if not f then tC(iw())coroutine.yield()tC(bB)else tC(bB)c1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"cb=5;tA=false end;coroutine.yield()if tA then c1="Loaded Saved Variables"cr=a9;cs=aa;aV=j;g=string.lower(g)cI=p;cL=V;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]elseif not f then c1="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if U<2000 then c1="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bz=VERSION_NUMBER;if#bl>0 then dq=iv(dq,bl)end else c1="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bH then bq=0 end;bs=bH;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"cb=7 end;if antigrav and not q then if br==nil then br=ck end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then dp=require("autoconf/custom/archhud/privatelocations")if#dp>0 then dq=iv(dq,dp)end end;lx="Proceeding to Waypoint"end;local function tF()local function tG(tH,tI)if tH>tI then tI=tH end;local tJ,tK=0,0;if a6>0 then tJ=a6*0.05 end;if a7>0 then tK=a7*0.05 end;tI=tI*(1-(tJ+tK))return tI end;local tL=b.getElementNameById;local tM=aq~=0 and ar~=0;for dU in pairs(iz)do local type=b.getElementTypeById(iz[dU])if ee(type,'^.*Atmospheric Engine$')then if ee(tostring(b.getElementTagsById(iz[dU])),'^.*vertical.*$')and b.getElementForwardById(iz[dU])[3]>0 then d1=true end end;if ee(type,'^.*Space Engine$')then cS=true;if ee(tostring(b.getElementTagsById(iz[dU])),'^.*vertical.*$')then local tN=b.getElementForwardById(iz[dU])if tN[3]<0 then tO=true else cR=true end end end;if type=="Landing Gear"then bS=true end;if type=="Dynamic Core Unit"then local pC=pA(iz[dU])if pC>10000 then gW=110 elseif pC>1000 then gW=55 elseif pC>150 then gW=27 end end;iA=iA+pA(iz[dU])if tM and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pC=pA(iz[dU])local ol=iq(iz[dU])local tH=0;local jx=bE()if type=="Atmospheric Fuel Tank"then local tI=400;local tP=35.03;if pC>10000 then tI=51200;tP=5480 elseif pC>1300 then tI=6400;tP=988.67 elseif pC>150 then tI=1600;tP=182.67 end;tH=ol-tP;if a3>0 then tI=tI+tI*a3*0.2 end;tI=tG(tH,tI)ct[#ct+1]={iz[dU],tL(iz[dU]),tI,tP,tH,jx}end;if type=="Rocket Fuel Tank"then local tI=320;local tP=173.42;if pC>65000 then tI=40000;tP=25740 elseif pC>6000 then tI=5120;tP=4720 elseif pC>700 then tI=640;tP=886.72 end;tH=ol-tP;if a5>0 then tI=tI+tI*a5*0.1 end;tI=tG(tH,tI)cv[#cv+1]={iz[dU],tL(iz[dU]),tI,tP,tH,jx}end;if type=="Space Fuel Tank"then local tI=600;local tP=35.03;if pC>10000 then tI=76800;tP=5480 elseif pC>1300 then tI=9600;tP=988.67 elseif pC>150 then tI=2400;tP=182.67 end;tH=ol-tP;if a4>0 then tI=tI+tI*a4*0.2 end;tI=tG(tH,tI)cu[#cu+1]={iz[dU],tL(iz[dU]),tI,tP,tH,jx}end end end;if not d1 then b5,aW=false,false end end;local function tQ()if gyro~=nil then co=gyro.getState()==1 end;if not bx then is:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then sr(1)else sr(0)end;if door and(ci or not ci and ck<10000)then for dZ,dG in pairs(door)do dG.toggle()end end;if switch then for dZ,dG in pairs(switch)do dG.toggle()end end;if forcefield and(ci or not ci==0 and ck<10000)then for dZ,dG in pairs(forcefield)do dG.toggle()end end;if antigrav then d2=antigrav.getState()==1;if d2 and not q then antigrav.show()end end;if ir()==1 and k then a.freeze(1)else a.freeze(0)end;if bS then bi=d.control.isAnyLandingGearExtended()==1;if bi then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if ch~=-1 or not ci and cW:len()<50 then aX=true;bi=true;if bS then d.control.extendLandingGears()end else aX=false end;is:setTargetGroundAltitude(ti)if ci and ch~=-1 then cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;po=ci end;local function tR()local tS={}local function tT()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tU={[1]=4480,[6]=4480,[7]=6270}for tV,tW in pairs(e)do e[tV][0]=tT()e[tV][0].systemId=tV;tS[tV]={}for tX,iZ in pairs(e[tV])do iZ.gravity=iZ.gravity/9.8;iZ.center=vec3(iZ.center)iZ.name=iZ.name[1]iZ.noAtmosphericDensityAltitude=iZ.atmosphereThickness or iZ.atmosphereRadius-iZ.radius;iZ.spaceEngineMinAltitude=tU[iZ.id]or 0.68377*(iZ.atmosphereThickness or iZ.atmosphereRadius-iZ.radius)iZ.planetarySystemId=tV;iZ.bodyId=iZ.id;tS[tV][tX]=iZ;if mq==nil or iZ.center.x<mq then mq=iZ.center.x end;if mp==nil or iZ.center.x>mp then mp=iZ.center.x end;if mt==nil or iZ.center.y<mt then mt=iZ.center.y end;if ms==nil or iZ.center.y>ms then ms=iZ.center.y end;if iZ.center and iZ.name~="Space"then dj[#dj+1]=iZ end end end;eo=dt(d,b,c,a,du,dv,dw,dx,dy)cx=eo(tS)cy=f7(d,b,c,a,dx,f8)cA=fC(d,b,c,a,du,dv,dw,dx,dy)cC=g1(d,b,c,a,dbHud_1,e,g2,g3,bF,dw,dx,g4)end;tY=false;tZ=coroutine.create(function()is:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})tB()coroutine.yield()tF()coroutine.yield()cD=pF(d,b,c,a,e,vBooster,hover,pG,antigrav,warpdrive,dbHud_1,f8,bF,bG,ir,f3,bE,dv,is,g2,it,dx,iu,g4,iv,dy,ix,iy,pH,ip,du,g3)tQ()coroutine.yield()tR()cE=gT(b,a,c,library,radar_1,radar_2,f8,gU,dx,gV,dw,gW,g4)cB=il(d,b,c,a,e,radar_1,radar_2,antigrav,hover,im,warpdrive,io,f8,bF,du,ip,bG,iq,ir,f3,bE,dv,is,g3,g2,gU,it,dx,iu,gV,g4,iv,iw,ix,iy,iz,iA)cB.ButtonSetup()cF=sq(d,b,c,a,e,vBooster,hover,antigrav,im,dbHud_2,gyro,screenHud_1,ir,is,it,sr,gU,iu,ee,dw,dv,g4,iw,pH)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)c.setTimer("radarTick",aP)c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)g4("start","SU")end)coroutine.resume(tZ)end;function tg.onUpdate()if not tY then local ia=coroutine.status(tZ)if ia=="suspended"then local dV,ib=coroutine.resume(tZ)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then tY=true end end;if tY then d:update()if ci and u and d4 then if d4 and bP then cD.cmdThrottle(0)bP=false elseif not d4 and not bP then bL=0;bP=true end end;if dm then is:setThrottleCommand(axisCommandId.longitudinal,dm)dm=nil end;if not cG and p3~=t_ then a.setScreen(p3)end;t_=p3 end end;function tg.onFlush()local function u0(u1,rs)local u2=vec3()local u3=vec3()if u1==axisCommandId.longitudinal then u2=vec3(b.getConstructOrientationForward())u3=cU elseif u1==axisCommandId.vertical then u2=vec3(b.getConstructOrientationUp())u3=cT elseif u1==axisCommandId.lateral then u2=vec3(b.getConstructOrientationRight())u3=cV else return vec3()end;local u4=vec3(b.getWorldGravity())local u5=u4:dot(u3)local u6=vec3(b.getWorldAirFrictionAcceleration())local u7=u6:dot(u3)local u8=cW:dot(u2)local u9=rs*constants.kph2m;if ua==nil then ua=pid.new(10,0,10.0)end;ua:inject(u9-u8)local ub=ua:get()local uc=(ub-u7-u5)*u3;return uc end;local function ud(u1,rs)local u2=vec3()local u3=vec3()if u1==axisCommandId.longitudinal then u2=vec3(b.getConstructOrientationForward())u3=cU elseif u1==axisCommandId.vertical then u2=vec3(b.getConstructOrientationUp())u3=cT elseif u1==axisCommandId.lateral then u2=vec3(b.getConstructOrientationRight())u3=cV else return vec3()end;local u4=vec3(b.getWorldGravity())local u5=u4:dot(u3)local u6=vec3(b.getWorldAirFrictionAcceleration())local u7=u6:dot(u3)local u8=cW:dot(u2)local u9=rs*constants.kph2m;if ue==nil then ue=pid.new(10,0,10.0)end;ue:inject(u9-u8)local ub=ue:get()local uc=(ub-u7-u5)*u3;return uc end;local function uf(ug,jM,gb)local uh=ug:cross(gb):normalize_inplace()local kx=math.acos(dv(uh:dot(-jM),-1,1))*constants.rad2deg;if uh:cross(-jM):dot(gb)<0 then kx=-kx end;return kx end;if antigrav and not q then if not d2 and antigrav.getBaseAltitude()~=br then antigrav.setBaseAltitude(br)end end;d4=is:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local ui=dv(bT+bU+a.getControlDeviceForwardInput(),-1,1)local uj=dv(bW+bZ+a.getControlDeviceYawInput(),-1,1)local uk=dv(bX+bV-a.getControlDeviceLeftRightInput(),-1,1)local ul=bY;cZ=vec3(b.getWorldVertical())if cZ==nil or cZ:len()==0 then cZ=(iZ.center-d0):normalize()end;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getWorldVelocity())cW=vec3(b.getVelocity())d0=vec3(b.getConstructWorldPos())cm=b.getConstructMass()cY=vec3(cX):len()c_=-cZ:dot(cX)d6=getRoll(cZ,cU,cV)local um=d6/180*math.pi;local un=math.cos(um)local uo=math.sin(um)d5=uf(cZ,cU,cV*un+cT*uo)local up=cX:normalize()local uq=f8(d6)local ur=utils.sign(d6)local us=vec3(b.getWorldAngularVelocity())local ut=ui*aK*cV+uj*aF*cU+uk*aL*cT;if cI==true and cZ:len()>0.01 then local uu=f8(cK-d6)if((aZ or b4 or b2 or ce or b1 or bv)and uu>0 or cj>0.0 and uu<aG and p)and uj==0 and f8(d5)<85 then local uv=cK;local uw=aE;if cj==0 then uw=uw/4;cK=0;uv=0 end;if ux==nil then ux=pid.new(uw*0.01,0,uw*0.1)end;ux:inject(uv-d6)local uy=ux:get()ut=ut+uy*cU end end;local uz=1;local uA=0;local uB=1;bM=0;if ci and u and d4 then if uC==nil then uC=pid.new(0.1,0,1)end;uC:inject(cL/3.6-cX:dot(cU))local uD=uC:get()bO=dv(uD,-1,1)if not dm then if bO<bL and cj>0.005 then bN=true;dm=dv(bO,0.01,1)else bN=false;dm=bL end end;if uE==nil then uE=pid.new(1*0.01,0,1*0.1)end;uE:inject(cX:len()-cL/3.6)local uF=dv(uE:get(),0,1)if cj>0 and c_<-80 or cj>0.005 then bM=uF end;if bM>0 then if bN and bO==0.01 and not dm then dm=0 end else bO=dv(bO,0.01,1)end;local uG=''local uH=vec3()local uI=u0(axisCommandId.vertical,c8*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uI,uA)local uJ='thrust analog longitudinal 'if by=="All"or by=="Longitude"then uJ=uJ..aR end;local uK=is:getAxisCommandType(axisCommandId.longitudinal)local uL=is:composeAxisAccelerationFromThrottle(uJ,axisCommandId.longitudinal)local uM=ud(axisCommandId.lateral,bu*1000)uG=uG..' , '.."lateral airfoil , lateral ground "uH=uH+uM;if uH:len()>constants.epsilon then d:setEngineForceCommand(uG,uH,uA,'','','',uB)end;d:setEngineForceCommand(uJ,uL,uz)local uN='thrust analog vertical fueled 'local uO='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then uO=uO..aS end;if by=="All"or by=="Vertical"then uN=uN..aT end;if c8~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(uN,uI,uz)else d:setEngineForceCommand(uN,vec3(),uz)end;if bu~=0 then d:setEngineForceCommand(uO,uM,uz)else d:setEngineForceCommand(uO,vec3(),uz)end;if ul==0 then ul=bM end;local uP=-ul*(aM*cX+aN*up)d:setEngineForceCommand('brake',uP)else if u then if not dm then dm=bL end end;local rs=c.getAxisCommandValue(0)if not d4 then if uE==nil then uE=pid.new(1*0.01,0,1*0.1)end;uE:inject(cX:len()-rs/3.6)local uF=dv(uE:get(),0,1)ul=dv(ul+uF,0,1)end;local uP=-ul*(aM*cX+aN*up)d:setEngineForceCommand('brake',uP)local uG=''local uH=vec3()local uQ=false;local uJ='thrust analog longitudinal 'if by=="All"or by=="Longitude"then uJ=uJ..aR end;local uK=is:getAxisCommandType(axisCommandId.longitudinal)if uK==axisCommandType.byThrottle then local uL=is:composeAxisAccelerationFromThrottle(uJ,axisCommandId.longitudinal)d:setEngineForceCommand(uJ,uL,uz)elseif uK==axisCommandType.byTargetSpeed then local uL=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)uG=uG..' , '..uJ;uH=uH+uL;if is:getTargetSpeed(axisCommandId.longitudinal)==0 or is:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-is:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then uQ=true end end;local uO='thrust analog lateral 'if by=="All"or by=="Lateral"then uO=uO..aS end;local uR=is:getAxisCommandType(axisCommandId.lateral)if uR==axisCommandType.byThrottle then local uS=is:composeAxisAccelerationFromThrottle(uO,axisCommandId.lateral)d:setEngineForceCommand(uO,uS,uz)elseif uR==axisCommandType.byTargetSpeed then local uM=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)uG=uG..' , '..uO;uH=uH+uM end;local uN='thrust analog vertical 'if by=="All"or by=="Vertical"then uN=uN..aT end;local uT=is:getAxisCommandType(axisCommandId.vertical)if uT==axisCommandType.byThrottle then local uI=is:composeAxisAccelerationFromThrottle(uN,axisCommandId.vertical)if c8~=0 or b2 and aX then d:setEngineForceCommand(uN,uI,uz,'airfoil','ground','',uB)else d:setEngineForceCommand(uN,vec3(),uz)d:setEngineForceCommand('airfoil vertical',uI,uz,'airfoil','','',uB)d:setEngineForceCommand('ground vertical',uI,uz,'ground','','',uB)end elseif uT==axisCommandType.byTargetSpeed then if c8<0 then d:setEngineForceCommand('hover',vec3(),uz)end;local uU=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)uG=uG..' , '..uN;uH=uH+uU end;if uH:len()>constants.epsilon then if bY~=0 or uQ or f8(up:dot(cU))<0.5 then uG=uG..', brake'end;d:setEngineForceCommand(uG,uH,uA,'','','',uB)end end;local uV=aJ*(ut-us)local uW=vec3(b.getWorldAirFrictionAngularAcceleration())uV=uV-uW;d:setEngineTorqueCommand('torque',uV,uz,'airfoil','','',uB)d:setBoosterCommand('rocket_engine')if c2 and not n then local fA=cW:len()local uX=0.15;if not d4 then local uY=is:getTargetSpeed(axisCommandId.longitudinal)if fA*3.6>uY*(1-uX)and sW then sW=false;d:toggleBoosters()elseif fA*3.6<uY*(1-uX)and not sW then sW=true;d:toggleBoosters()end else local pf=c.getThrottle()if u then pf=bL*100 end;local rs=pf/100;if bG==0 then rs=rs*a0;if fA>=rs*(1-uX)and sW then sW=false;d:toggleBoosters()elseif fA<rs*(1-uX)and not sW then sW=true;d:toggleBoosters()end else local rF=bF(cL)rs=rs*rF/3.6;if fA>=rs*(1-uX)and sW then sW=false;d:toggleBoosters()elseif fA<rs*(1-uX)and not sW then sW=true;d:toggleBoosters()end end end end end;function tg.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(cj>0 or cj==0 and ck<10000)then for dZ,dG in pairs(door)do dG.toggle()end end;if switch then for dZ,dG in pairs(switch)do dG.toggle()end end;if forcefield and(cj>0 or cj==0 and ck<10000)then for dZ,dG in pairs(forcefield)do dG.toggle()end end;x=dl;pH()if nX then nX.activate()end;if A then cD.showWayPoint(iZ,d0)end;local os=1-(a6*0.05+a7*0.05)a.print(cB.FuelUsed("atmofueltank")..", "..cB.FuelUsed("spacefueltank")..", "..cB.FuelUsed("rocketfueltank"))g4("stop","SU")end;function tg.controlStart(sz)cF.startControl(sz)end;function tg.controlStop(sz)cF.stopControl(sz)end;function tg.controlLoop(sz)cF.loopControl(sz)end;function tg.controlInput(sj)cF.inputTextControl(sj)end;function tg.radarEnter(e3)cE.onEnter(e3)end;function tg.radarLeave(e3)cE.onLeave(e3)end;function tg.onTick(uZ)if uZ=="tenthSecond"then cD.TenthTick()cB.TenthTick()elseif uZ=="oneSecond"then cB.OneSecondTick()elseif uZ=="fiveSecond"then cD.SatNavTick()elseif uZ=="msgTick"then cB.MsgTick()elseif uZ=="animateTick"then cB.AnimateTick()elseif uZ=="hudTick"then cB.hudtick()elseif uZ=="apTick"then cD.APTick()elseif uZ=="radarTick"then cE.UpdateRadar()elseif uZ=="tagTick"then cF.tagTick()elseif uZ=="contact"then cE.ContactTick()end end;return tg end;function script.onStart()u_.onStart()end;function script.onStop()u_.onStop()end;function script.onTick(uZ)u_.onTick(uZ)end;function script.onFlush()u_.onFlush()end;function script.onUpdate()u_.onUpdate()end;function script.onActionStart(sz)u_.controlStart(sz)end;function script.onActionStop(sz)u_.controlStop(sz)end;function script.onActionLoop(sz)u_.controlLoop(sz)end;function script.onInputText(sj)u_.controlInput(sj)end;function script.onEnter(e3)u_.radarEnter(e3)end;function script.onLeave(e3)u_.radarLeave(e3)end;bD(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)u_=tf(d,b,c,a,library,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,im,gyro,warpdrive,io,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
