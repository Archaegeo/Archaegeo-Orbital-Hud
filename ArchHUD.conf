name: ArchHud - Archaegeo v1.704 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        local mabs = math.abs --export: test
        local mfloor = math.floor --export: test2
        require("autoconf/custom/archhud/globals")local a=Navigator.new(system,core,unit)local b=require("atlas")require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")require("autoconf/custom/archhud/radarclass")require("autoconf/custom/archhud/controlclass")script={}VERSION_NUMBER=1.704;local c=string.format;local d=json.decode;local e=json.encode;local f=core.getElementMaxHitPointsById;local g=unit.getAtmosphereDensity;local h=core.getElementMassById;local i=a.control.isRemoteControlled;local j=math.atan;local k=string.match;local l=system.getTime;local m=utils.clamp;local n=a.axisCommandManager;local o=system.destroyWidgetPanel;local p=system.updateData;local q=system.addDataToWidget;local r=system.lockView;local s=system.isViewLocked;local t=math.sqrt;local u=tonumber;local function v(w,x)local y=10^(x or 0)return z(w*y+0.5)/y end;A=l()B=l()local C=13;D=E;F=G;H=I;J=0;K=0;L=false;M=0;N=false;O=false;P=55;Q=false;R=false;S=0;T=0;U=0;V=0;W=0;X=0;Y=0;Z=false;_=false;a0="empty"a1=false;a2=0;a3=0;local a4=0;local a5=0;a6=nil;a7=0;a8=0;a9=0;aa=0;ab=0;ac=3;ad=0;ae=""af=false;ag=false;ah=false;ai=-1;local aj=""ak=g()>0;al=g()am=core.getAltitude()local an=core.getElementIdList()ao=l()ap=core.getConstructMass()local aq=false;ar=nil;as=[[rgb(]]..z(D+0.5)..","..z(H+0.5)..","..z(F+0.5)..[[)]]at=[[rgb(]]..z(D*0.9+0.5)..","..z(H*0.9+0.5)..","..z(F*0.9+0.5)..[[)]]local au={}av=""aw=ax;ay=az;aA={}aB={}aC={}local aD=0;aE=false;local aF=nil;aG=nil;aH=nil;aI=nil;aJ=nil;aK=nil;aL=nil;aM=nil;aN=nil;aO=nil;aP=false;aQ=false;aR=aS;local aT=aU;aV=false;aW=0;aX=aY;aZ=0;a_=nil;b0={VectorToTarget=false}b1=0;b2=false;local b3=false;b4=false;b5=false;b6=vec3(core.getConstructWorldOrientationUp())b7=vec3(core.getConstructWorldOrientationForward())b8=vec3(core.getConstructWorldOrientationRight())b9=vec3(core.getVelocity())ba=vec3(core.getWorldVelocity())bb=vec3(ba):len()bc=vec3(core.getWorldVertical())bd=-bc:dot(ba)be=vec3(core.getConstructWorldPos())bf=false;bg=false;bh=nil;bi=true;bj=0;bk=0;bl={}bm=false;bn=50000;bo=nil;bp={}bq=unit.getClosestPlanetInfluence()>0 or am>0 and am<200000;br=false;bs=nil;bt=false;bu=0;bv=nil;bw=nil;bx={}by=90;bz=bA;function bB(bC)system.print(A..": "..bC)end;local function bD(bE)local y=1;if bE then y=-1 end;if not _ then if bF and not bG and aq then local bH=J;J=v(m(J+y*bI/100,-1,1),2)if J>=0 and bH<0 then J=0;aq=false end elseif bG then if al>0 or bJ then aX=m(aX+y*bI,0,aY)elseif bK then bL=m(bL+y*bI/3.6*100,0,8333.00)end else n:updateCommandFromActionStart(axisCommandId.longitudinal,y*bI)end else if bK or bM or ag or bN then bu=bu+1*y*-1;if bu>#bl then bu=1 end;if bu<1 then bu=#bl end else if not bE then y=1 else y=nil end;aL.adjustAutopilotTargetIndex(y)end end end;function bO(bP,bQ,type)if type==nil and not bR or type~=nil and not bS or bT=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..bT.."/"..bP.."|"..bQ.."|"..bU)else system.logInfo("sound_notification|audiopacks/"..bT.."/"..bP.."|"..bQ.."|"..bU)end else system.logInfo("sound_q|audiopacks/"..bT.."/"..bP.."|"..bQ.."|"..bU)end end;function bV(bW,bX)for bY=1,#bX do bW[#bW+1]=bX[bY]end;return bW end;function bZ(b_)local c0={}if not b_ then bV(c0,c1)bV(c0,c2)bV(c0,c3)bV(c0,c4)return c0 elseif b_=="boolean"then return c1 elseif b_=="handling"then return c2 elseif b_=="hud"then return c3 elseif b_=="physics"then return c4 end end;local function c5(c6,c7,c8,c9,ca)if c9==nil then c9=""end;if ca==nil then ca=""end;return c([[<text class="%s" x=%s y=%s style="%s">%s</text>]],c9,c6,c7,ca,c8)end;function cb(cc,cd)if cc==0 then return ce(cd)<1e-09 end;if cd==0 then return ce(cc)<1e-09 end;return ce(cc-cd)<math.max(ce(cc),ce(cd))*cf end;function cg(ad,ch)local ci=ad>100000;if ch==nil then ch=1 end;if ci then return v(ad/1000/200,ch).."SU"elseif ad<1000 then return v(ad,ch).."M"else return v(ad/1000,ch).."KM"end end;function cj(ck)local cl=0;local cm=0;local cn=0;if ck<60 then ck=z(ck)elseif ck<3600 then cl=z(ck/60)ck=z(ck%60)elseif ck<86400 then cm=z(ck/3600)cl=z(ck%3600/60)else cn=z(ck/86400)cm=z(ck%86400/3600)end;if cn>0 then return cn.."d "..cm.."h "elseif cm>0 then return cm.."h "..cl.."m "elseif cl>0 then return cl.."m "..ck.."s"elseif ck>0 then return ck.."s"else return"0s"end end;function co(cp)local function cq(cr)for cs,ct in pairs(cr)do dbHud_1.setStringValue(ct,e(_G[ct]))if cp and dbHud_2 then dbHud_2.setStringValue(ct,e(_G[ct]))end end end;if dbHud_1 then cq(cu)cq(bZ())system.print("Saved Variables to Datacore")if cp and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end;local function cv()local function cw(cx)return type(cx)=='number'end;local function cy(cx)return type(u(cx))=='number'end;local function cz(cA)return type(cA)=='table'end;local function cB(cC)return type(cC)=='string'end;local function cD(ct)return cz(ct)and cw(ct.x and ct.y and ct.z)end;local function cE(cF)return cz(cF)and cw(cF.latitude and cF.longitude and cF.altitude and cF.id and cF.systemId)end;local cG=math.pi/180;local cH=180/math.pi;local cf=1e-10;local w=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cI='::pos{'..w..','..w..','..w..','..w..','..w..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cJ(cx)local cK=string.gsub(string.reverse(c('%.4f',cx)),'^0*%.?','')return cK==''and'0'or string.reverse(cK)end;local function cL(cM)if cD(cM)then return c('{x=%.3f,y=%.3f,z=%.3f}',cM.x,cM.y,cM.z)end;if cz(cM)and not getmetatable(cM)then local cN={}local cO=next(cM)if type(cO)=='nil'or cO==1 then cN=cM else for cs,ct in pairs(cM)do local cP=cL(ct)if type(cs)=='number'then table.insert(cN,c('[%s]=%s',cs,cP))else table.insert(cN,c('%s=%s',cs,cP))end end end;return c('{%s}',table.concat(cN,','))end;if cB(cM)then return c("'%s'",cM:gsub("'",[[\']]))end;return tostring(cM)end;local cQ={}cQ.__index=cQ;cQ.__tostring=function(cM,cR)local cS={}for cs in pairs(cM)do table.insert(cS,cs)end;table.sort(cS)local cN={}for cT,cs in ipairs(cS)do local cP=cL(cM[cs])if type(cs)=='number'then table.insert(cN,c('[%s]=%s',cs,cP))else table.insert(cN,c('%s=%s',cs,cP))end end;if cR then return c('%s%s',cR,table.concat(cN,',\n'..cR))end;return c('{%s}',table.concat(cN,','))end;cQ.__eq=function(cU,cV)return cU.systemId==cV.systemId and cU.id==cV.id and cb(cU.radius,cV.radius)and cb(cU.center.x,cV.center.x)and cb(cU.center.y,cV.center.y)and cb(cU.center.z,cV.center.z)and cb(cU.GM,cV.GM)end;local function cW(cX,cY,cZ,c_,d0)assert(cy(cX),'Argument 1 (systemId) must be a number:'..type(cX))assert(cy(cY),'Argument 2 (id) must be a number:'..type(cY))assert(cy(cZ),'Argument 3 (radius) must be a number:'..type(cZ))assert(cz(c_),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(c_))assert(cy(d0),'Argument 5 (GM) must be a number:'..type(d0))return setmetatable({systemId=u(cX),id=u(cY),radius=u(cZ),center=vec3(c_),GM=u(d0)},cQ)end;local d1={}d1.__index=d1;d1.__tostring=function(bB)return c('::pos{%d,%d,%s,%s,%s}',bB.systemId,bB.id,cJ(bB.latitude*cH),cJ(bB.longitude*cH),cJ(bB.altitude))end;d1.__eq=function(cU,cV)return cU.id==cV.id and cU.systemId==cV.systemId and cb(cU.latitude,cV.latitude)and cb(cU.altitude,cV.altitude)and(cb(cU.longitude,cV.longitude)or cb(cU.latitude,math.pi/2)or cb(cU.latitude,-math.pi/2))end;local function d2(d3,cY,d4,d5,d6)local cX=d3;if cB(d3)and not d5 and not d6 and not cY and not d4 then cX,cY,d4,d5,d6=k(d3,cI)assert(cX,'Argument 1 (position string) is malformed.')else assert(cy(cX),'Argument 1 (systemId) must be a number:'..type(cX))assert(cy(cY),'Argument 2 (id) must be a number:'..type(cY))assert(cy(d4),'Argument 3 (latitude) must be in degrees:'..type(d4))assert(cy(d5),'Argument 4 (longitude) must be in degrees:'..type(d5))assert(cy(d6),'Argument 5 (altitude) must be in meters:'..type(d6))end;cX=u(cX)cY=u(cY)d4=u(d4)d5=u(d5)d6=u(d6)if cY==0 then return setmetatable({latitude=d4,longitude=d5,altitude=d6,id=cY,systemId=cX},d1)end;return setmetatable({latitude=cG*m(d4,-90,90),longitude=cG*(d5%360),altitude=d6,id=cY,systemId=cX},d1)end;local d7={}d7.__index=d7;d7.__tostring=function(cM,cR)local d8=cR and cR..'  'local d9={}local cS={}for cs in pairs(cM)do table.insert(cS,cs)end;table.sort(cS)for cT,da in ipairs(cS)do db=cM[da]local dc=cQ.__tostring(db,d8)if cR then table.insert(d9,c('[%s]={\n%s\n%s}',da,dc,cR))else table.insert(d9,c('  [%s]=%s',da,dc))end end;if cR then return c('\n%s%s%s',cR,table.concat(d9,',\n'..cR),cR)end;return c('{\n%s\n}',table.concat(d9,',\n'))end;local function dd(de)local b={}local pid;for cT,ct in pairs(de)do local cY=ct.planetarySystemId;if type(cY)~='number'then error('Invalid planetary system ID: '..tostring(cY))elseif pid and cY~=pid then error('Mistringmatch planetary system IDs: '..cY..' and '..pid)end;local df=ct.bodyId;if type(df)~='number'then error('Invalid body ID: '..tostring(df))elseif b[df]then error('Duplicate body ID: '..tostring(df))end;setmetatable(ct.center,getmetatable(vec3.unit_x))b[df]=setmetatable(ct,cQ)pid=cY end;return setmetatable(b,d7)end;aF={}local function dg(de)return setmetatable({galaxyAtlas=de or{}},aF)end;aF.__index=function(cA,bY)if type(bY)=='number'then local system=cA.galaxyAtlas[bY]return dd(system)end;return rawget(aF,bY)end;aF.__pairs=function(cM)return function(cA,cs)local dh,di=next(cA,cs)return dh,di and dd(di)end,cM.galaxyAtlas,nil end;aF.__tostring=function(cM)local dj={}for cT,dk in pairs(cM or{})do local dl=dk:getPlanetarySystemId()local dm=d7.__tostring(dk,'    ')table.insert(dj,c('  [%s]={%s\n  }',dl,dm))end;return c('{\n%s\n}\n',table.concat(dj,',\n'))end;aF.BodyParameters=cW;aF.MapPosition=d2;aF.PlanetarySystem=dd;function aF.createBodyParameters(cX,cY,dn,dp,dq,dr,ds)assert(cy(cX),'Argument 1 (systemId) must be a number:'..type(cX))assert(cy(cY),'Argument 2 (id) must be a number:'..type(cY))assert(cy(dn),'Argument 3 (surfaceArea) must be a number:'..type(dn))assert(cz(dp),'Argument 4 (aPosition) must be an array or vec3:'..type(dp))assert(cz(dq),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dq))assert(cy(dr),'Argument 6 (altitude) must be in meters:'..type(dr))assert(cy(ds),'Argument 7 (gravityAtPosition) must be number:'..type(ds))local cZ=t(dn/4/math.pi)local ad=cZ+dr;local dt=vec3(dp)+ad*vec3(dq)local d0=ds*ad*ad;return cW(cX,cY,cZ,dt,d0)end;aF.isMapPosition=cE;function aF:getPlanetarySystem(d3)if bY==nil then bY=0 end;if di==nil then di=0 end;local cX=d3;if cE(d3)then cX=d3.systemId end;if type(cX)=='number'then local system=self.galaxyAtlas[bY]if system then if getmetatable(di)~=d7 then system=dd(system)end;return system end end end;function d7:sizeCalculator(du)return 1.05*du.radius end;function d7:castIntersections(dv,dw,dx,dy,dz,dA)local dB={}if dz then for cT,du in pairs(dz)do table.insert(dB,du)end else dB=bx end;if not dA then table.sort(dB,function(dC,dD)local cc=dC.center;local cd=dD.center;return(cc.x-dv.x)^2+(cc.y-dv.y)^2+(cc.z-dv.z)^2<(cd.x-dv.x)^2+(cd.y-dv.y)^2+(cd.z-dv.z)^2 end)end;local dE=dw:normalize()for cT,du in ipairs(dB)do local dF=du.center-dv;local cZ=self:sizeCalculator(du)local dG=dF:dot(dE)local dH=dG^2-(dF:len2()-cZ^2)if dH>=0 then local dI=t(dH)local dJ=dG+dI;local dK=dG-dI;if dK>0 then return du,dJ,dK elseif dJ>0 then return du,dJ,nil end end end;return nil,nil,nil end;function d7:closestBody(dL)assert(type(dL)=='table','Invalid coordinates.')local dM,du;local dN=vec3(dL)for cT,dO in pairs(self)do local dP=(dO.center-dN):len2()if(not du or dP<dM)and dO.name~="Space"then du=dO;dM=dP end end;return du end;function d7:convertToBodyIdAndWorldCoordinates(d3)local dQ=d3;if cB(d3)then dQ=d2(d3)end;if dQ.id==0 then return 0,vec3(dQ.latitude,dQ.longitude,dQ.altitude)end;local dO=self:getBodyParameters(dQ)if dO then return dQ.id,dO:convertToWorldCoordinates(dQ)end end;function d7:getBodyParameters(d3)local cY=d3;if cE(d3)then cY=d3.id end;assert(cy(cY),'Argument 1 (id) must be a number:'..type(cY))return self[cY]end;function d7:getPlanetarySystemId()local cT,ct=next(self)return ct and ct.systemId end;function cQ:convertToMapPosition(c_)assert(cz(c_),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(c_))local dR=vec3(c_)if self.id==0 then return setmetatable({latitude=dR.x,longitude=dR.y,altitude=dR.z,id=0,systemId=self.systemId},d1)end;local dS=dR-self.center;local ad=dS:len()local d6=ad-self.radius;local d4=0;local d5=0;if not cb(ad,0)then local dT=j(dS.y,dS.x)d5=dT>=0 and dT or 2*math.pi+dT;d4=math.pi/2-math.acos(dS.z/ad)end;return setmetatable({latitude=d4,longitude=d5,altitude=d6,id=self.id,systemId=self.systemId},d1)end;function cQ:convertToWorldCoordinates(d3)local dQ=cB(d3)and d2(d3)or d3;if dQ.id==0 then return vec3(dQ.latitude,dQ.longitude,dQ.altitude)end;assert(cE(dQ),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dQ.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dQ.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dU=math.cos(dQ.latitude)return self.center+(self.radius+dQ.altitude)*vec3(dU*math.cos(dQ.longitude),dU*math.sin(dQ.longitude),math.sin(dQ.latitude))end;function cQ:getAltitude(c_)return(vec3(c_)-self.center):len()-self.radius end;function cQ:getDistance(c_)return(vec3(c_)-self.center):len()end;function cQ:getGravity(c_)local dV=self.center-vec3(c_)local dW=dV:len2()return self.GM/dW*dV/t(dW)end;return setmetatable(aF,{__call=function(cT,...)return dg(...)end})end;local function dX()local aH={}local dY=30000000/3600;local dZ=dY*dY;local d_=100;function aH.computeAccelerationTime(e0,e1,e2)local e3=dY*math.asin(e0/dY)return(dY*math.asin(e2/dY)-e3)/e1 end;function aH.computeDistanceAndTime(e0,e2,e4,e5,e6,e7)e6=e6 or 0;e7=e7 or 0;local e8=e0<=e2;local e9=e5*(e8 and 1 or-1)/e4;local ea=-e7/e4;local eb=e9+ea;if e8 and eb<=0 or not e8 and eb>=0 then return-1,-1 end;local ec,ed=0,0;if e9~=0 and e6>0 then local e3=math.asin(e0/dY)local ee=math.pi*(e9/2+ea)local ef=e9*e6;local eg=dY*math.pi;local ct=function(cA)local eh=(ee*cA-ef*math.sin(math.pi*cA/2/e6)+eg*e3)/eg;local ei=math.tan(eh)return dY*ei/t(ei*ei+1)end;local ej=e8 and function(cC)return cC>=e2 end or function(cC)return cC<=e2 end;ed=2*e6;if ej(ct(ed))then local ek=0;while ce(ed-ek)>0.5 do local cA=(ed+ek)/2;if ej(ct(cA))then ed=cA else ek=cA end end end;local el=e0;local em=ed/d_;for en=1,d_ do local eo=ct(en*em)ec=ec+(eo+el)*em/2;el=eo end;if ed<2*e6 then return ec,ed end;e0=el end;local e3=dY*math.asin(e0/dY)local A=(dY*math.asin(e2/dY)-e3)/eb;local ep=dZ*math.cos(e3/dY)/eb;local ad=ep-dZ*math.cos((eb*A+e3)/dY)/eb;return ad+ec,A+ed end;function aH.computeTravelTime(e0,e1,ad)if ad==0 then return 0 end;if e1>0 then local e3=dY*math.asin(e0/dY)local ep=dZ*math.cos(e3/dY)/e1;return(dY*math.acos(e1*(ep-ad)/dZ)-e3)/e1 end;if e0==0 then return-1 end;assert(e0>0,'Acceleration and initial speed are both zero.')return ad/e0 end;return aH end;local function eq()local vec3=require('cpml.vec3')local cv=cv()local function cB(cC)return type(cC)=='string'end;local function cz(cA)return type(cA)=='table'end;er={}er.__index=er;function er:escapeAndOrbitalSpeed(d6)assert(self.body)local ad=d6+self.body.radius;if not cb(ad,0)then local es=t(self.body.GM/ad)return t(2)*es,es end;return nil,nil end;function er:orbitalParameters(d3,et)assert(self.body)assert(cz(d3)or cB(d3))assert(cz(et))local eu=(cB(d3)or cv.isMapPosition(d3))and self.body:convertToWorldCoordinates(d3)or vec3(d3)local ct=vec3(et)local ev=eu-self.body.center;local ew=ct:len2()local ex=ev:len()local ey=self.body.GM;local ez=((ew-ey/ex)*ev-ev:dot(ct)*ct)/ey;local cc=ey/(2*ey/ex-ew)local eA=ez:len()local dE=ez:normalize()local eB=cc*(1-eA)local eC=cc*(1+eA)local eD=eB*dE+self.body.center;local eE=eA<=1 and-eC*dE+self.body.center or nil;local eF=t(cc*ey*(1-eA*eA))local eG=eE and 2*math.pi*t(cc^3/ey)local eH=math.acos(ez:dot(ev)/(eA*ex))if ev:dot(ct)<0 then eH=-(eH-2*math.pi)end;local eI=math.acos((math.cos(eH)+eA)/(1+eA*math.cos(eH)))local eJ=eI;if eJ<0 then eJ=eJ+2*math.pi end;local eK=eJ-eA*math.sin(eJ)local eL=0;local eM=0;local eN=0;if eG~=nil then eL=eK/(2*math.pi/eG)eM=eG-eL;eN=eM+eG/2;if eH-math.pi>0 then eM=eL;eN=eM+eG/2 end;if eN>eG then eN=eN-eG end end;return{periapsis={position=eD,speed=eF/eB,circularOrbitSpeed=t(ey/eB),altitude=eB-self.body.radius},apoapsis=eE and{position=eE,speed=eF/eC,circularOrbitSpeed=t(ey/eC),altitude=eC-self.body.radius},currentVelocity=ct,currentPosition=eu,eccentricity=eA,period=eG,eccentricAnomaly=eI,meanAnomaly=eK,timeToPeriapsis=eM,timeToApoapsis=eN,trueAnomaly=eH}end;local function eO(eP)local dO=cv.BodyParameters(eP.systemId,eP.id,eP.radius,eP.center,eP.GM)return setmetatable({body=dO},er)end;return setmetatable(er,{__call=function(cT,...)return eO(...)end})end;local function eQ()local function eR(eS)local bB=eT:closestBody(eS)if(eS-bB.center):len()>bB.radius+bB.noAtmosphericDensityAltitude then bB=b[0][0]end;return bB end;local function eU()local function eV(eW,eX)return eW.name<eX.name end;bl={}for cs,ct in pairs(b[0])do bl[#bl+1]={name=ct.name,index=cs}end;table.sort(bl,eV)end;local function eY(eZ)for cs,ct in pairs(eZ)do if ct.name and ct.name==e_.name then return cs end end;return-1 end;local function f0()bu=f1;if f1==0 then f2="None"a6=nil;e_=nil;return true end;local f3=bl[f1].index;local f4=b[0][f3]if f4.center then f2=f4.name;a6=aG[0][f3]if e_~=nil then if al==0 then if p(f5,f6)~=1 then q(f5,f6)end;if p(f7,f8)~=1 then q(f7,f8)end;if p(f9,fa)~=1 then q(f9,fa)end;if p(fb,fc)~=1 then q(fb,fc)end;if p(fd,fe)~=1 then q(fd,fe)end end;if p(ff,fg)~=1 then q(ff,fg)end;if p(fh,fi)~=1 then q(fh,fi)end;if p(fj,fk)~=1 then q(fj,fk)end end;e_=nil else e_=f4;for cT,ct in pairs(aG[0])do if ct.name==e_.planetname then a6=ct;f2=e_.name;break end end;if p(ff,fg)~=1 then q(ff,fg)end;if p(fh,fi)~=1 then q(fh,fi)end end;if e_==nil then fl=vec3(a6.center)else fl=e_.position end;if a6.planetname~="Space"then if a6.hasAtmosphere then fm=z(a6.radius*(fn-1)+a6.noAtmosphericDensityAltitude)else fm=z(a6.radius*(fn-1)+a6.surfaceMaxAltitude)end else fm=fo end;if e_~=nil and e_.planetname=="Space"then fp=0 else cT,fp=aJ(a6):escapeAndOrbitalSpeed(fm)end;fq=0;fr=false;fs=false;ft=false;bK=false;fu=false;fv="Aligning"return true end;local function fw(fx)if not bK and not bM and not ag and not bN and not bJ and not ah then if fx==nil then f1=f1+1;if f1>#bl then f1=0 end else f1=f1-1;if f1<0 then f1=#bl end end;if f1==0 then f0()else local f3=bl[f1].index;local f4=b[0][f3]if f4~=nil and f4.name=="Space"or fy=="Custom Only"and f4.center or fy=="No Moons"and string.find(f4.name,"Moon")~=nil then if fx==nil then fw()else fw(1)end else f0()end end else a0="Disengage autopilot before changing Interplanetary Helper"bO("iph","AP")end end;local function fz()local fA=-1;fA=eY(b[0])if fA>-1 then table.remove(b[0],fA)end;fA=-1;fA=eY(fB)if fA~=-1 then a0=e_.name.." saved location cleared"table.remove(fB,fA)end;fw()eU()end;local function fC(fD,eS,fE,fF)if dbHud_1 or fE then local bB=eR(eS)local fG=bB.gravity;if fF then fG=unit.getClosestPlanetInfluence()end;local fH={position=eS,name=fD,planetname=bB.name,gravity=fG,safe=fF}if not fE then fB[#fB+1]=fH else for cs,ct in pairs(b[0])do if ct.name and fD==ct.name then table.remove(b[0],cs)end end end;table.insert(b[0],fH)eU()f0()a0="Location saved as "..fD.."("..bB.name..")"else a0="Databank must be installed to save permanent locations"end end;local fI={}function fI.UpdateAtlasLocationsList()eU()end;function fI.UpdateAutopilotTarget()f0()end;function fI.adjustAutopilotTargetIndex(fx)fw(fx)end;function fI.findAtlasIndex(eZ)eY(eZ)end;function fI.UpdatePosition(fJ)local fA=eY(fB)if fA~=-1 then if fJ~=nil then fB[fA].name=fJ;f1=f1-1;fw()else local fK=fB[fA]fK.gravity=unit.getClosestPlanetInfluence()fK.position=be;fK.safe=true end;a0=fB[fA].name.." position updated ("..fB[fA].planetname..")"else a0="Name Not Found"end end;function fI.AddNewLocation(fD,eS,fE,fF)fC(fD,eS,fE,fF)end;function fI.ClearCurrentPosition()fz()end;for cs,ct in pairs(fB)do table.insert(b[0],ct)end;eU()if f1>#bl then f1=0 end;fI.UpdateAutopilotTarget()return fI end;function script.onStart()local fL=false;local function fM()local function fN(fO)local fP=dbHud_1.hasKey;for cs,ct in pairs(fO)do if fP(ct)then local cK=d(dbHud_1.getStringValue(ct))if cK~=nil then _G[ct]=cK;fL=true end end end end;if dbHud_1 then if not fQ then fN(bZ())coroutine.yield()fN(cu)else fN(cu)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ac=5;fL=false end;coroutine.yield()if fL then a0="Loaded Saved Variables"aw=ax;ay=az;fR=fS;fT=string.lower(fT)aR=aS;aX=aY;as=[[rgb(]]..z(D+0.5)..","..z(H+0.5)..","..z(F+0.5)..[[)]]at=[[rgb(]]..z(D*0.9+0.5)..","..z(H*0.9+0.5)..","..z(F*0.9+0.5)..[[)]]elseif not fQ then a0="No Saved Variables Found - Exit HUD to save settings"end;if fU<1.500 then if fV<2000 then a0="Updating LowOrbitHeight to new minimum default of 2000."fV=2000 end end;fU=VERSION_NUMBER else a0="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if fW+180<A then fX=0 end;fW=A;fT=string.lower(fT)if string.find("keyboard virtual joystick mouse",fT)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ac=7 end;if antigrav and not fY then if fZ==nil then fZ=am end;antigrav.setBaseAltitude(fZ)end;f_="Proceeding to Waypoint"end;local function g0()local function g1(g2,g3)if g2>g3 then g3=g2 end;local g4,g5=0,0;if g6>0 then g4=g6*0.05 end;if g7>0 then g5=g7*0.05 end;g3=g3*(1-(g4+g5))return g3 end;local g8=core.getElementNameById;local g9=ga~=0 and gb~=0;for cs in pairs(an)do local type=core.getElementTypeById(an[cs])if k(type,'^.*Atmospheric Engine$')then if k(tostring(core.getElementTagsById(an[cs])),'^.*vertical.*$')and core.getElementForwardById(an[cs])[3]>0 then bf=true end end;if k(type,'^.*Space Engine$')then b5=true;if k(tostring(core.getElementTagsById(an[cs])),'^.*vertical.*$')then local gc=core.getElementForwardById(an[cs])if gc[3]<0 then b3=true else b4=true end end end;if type=="Landing Gear"then R=true end;if type=="Dynamic Core Unit"then local gd=f(an[cs])if gd>10000 then C=110 elseif gd>1000 then C=55 elseif gd>150 then C=27 end end;aD=aD+f(an[cs])if g9 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local gd=f(an[cs])local ge=h(an[cs])local g2=0;local gf=l()if type=="Atmospheric Fuel Tank"then local g3=400;local gg=35.03;if gd>10000 then g3=51200;gg=5480 elseif gd>1300 then g3=6400;gg=988.67 elseif gd>150 then g3=1600;gg=182.67 end;g2=ge-gg;if gh>0 then g3=g3+g3*gh*0.2 end;g3=g1(g2,g3)aA[#aA+1]={an[cs],g8(an[cs]),g3,gg,g2,gf}end;if type=="Rocket Fuel Tank"then local g3=320;local gg=173.42;if gd>65000 then g3=40000;gg=25740 elseif gd>6000 then g3=5120;gg=4720 elseif gd>700 then g3=640;gg=886.72 end;g2=ge-gg;if gi>0 then g3=g3+g3*gi*0.1 end;g3=g1(g2,g3)aC[#aC+1]={an[cs],g8(an[cs]),g3,gg,g2,gf}end;if type=="Space Fuel Tank"then local g3=600;local gg=35.03;if gd>10000 then g3=76800;gg=5480 elseif gd>1300 then g3=9600;gg=988.67 elseif gd>150 then g3=2400;gg=182.67 end;g2=ge-gg;if gj>0 then g3=g3+g3*gj*0.2 end;g3=g1(g2,g3)aB[#aB+1]={an[cs],g8(an[cs]),g3,gg,g2,gf}end end end;if not bf then gk,gl=false,false end end;local function gm()if gyro~=nil then ar=gyro.getState()==1 end;if not gn then n:deactivateGroundEngineAltitudeStabilization()end;if fT~="keyboard"then r(1)else r(0)end;if door and(ak or not ak and am<10000)then for cT,ct in pairs(door)do ct.toggle()end end;if switch then for cT,ct in pairs(switch)do ct.toggle()end end;if forcefield and(ak or not ak==0 and am<10000)then for cT,ct in pairs(forcefield)do ct.toggle()end end;if antigrav then bg=antigrav.getState()==1;if bg and not fY then antigrav.show()end end;if i()==1 and go then system.freeze(1)else system.freeze(0)end;if R then gp=a.control.isAnyLandingGearExtended()==1;if gp then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ai~=-1 or not ak and b9:len()<50 then gq=true;gp=true;if R then a.control.extendLandingGears()end else gq=false end;n:setTargetGroundAltitude(aT)if ak and ai~=-1 then aI=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;gr=ak end;local function gs()local gt={}local function gu()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local gv={[1]=4480,[6]=4480,[7]=6270}for gw,gx in pairs(b)do b[gw][0]=gu()b[gw][0].systemId=gw;gt[gw]={}for gy,gz in pairs(b[gw])do gz.gravity=gz.gravity/9.8;gz.center=vec3(gz.center)gz.name=gz.name[1]gz.noAtmosphericDensityAltitude=gz.atmosphereThickness or gz.atmosphereRadius-gz.radius;gz.spaceEngineMinAltitude=gv[gz.id]or 0.68377*(gz.atmosphereThickness or gz.atmosphereRadius-gz.radius)gz.planetarySystemId=gw;gz.bodyId=gz.id;gt[gw][gy]=gz;if gA==nil or gz.center.x<gA then gA=gz.center.x end;if gB==nil or gz.center.x>gB then gB=gz.center.x end;if gC==nil or gz.center.y<gC then gC=gz.center.y end;if gD==nil or gz.center.y>gD then gD=gz.center.y end;if gz.center and gz.name~="Space"then bx[#bx+1]=gz end end end;aF=cv()aG=aF(gt)aH=dX()aJ=eq()aL=eQ()end;gE=false;gF=coroutine.create(function()n:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})fM()coroutine.yield()g0()coroutine.yield()aM=gG(a,core,unit,system,b,vBooster,hover,gH,antigrav,ce,z,g,i,j,l,m,n,p,s,t,v)gm()coroutine.yield()gs()aN=gI(core,system,library,radar_1,radar_2,ce,o,t,c5,u,C)aK=gJ(a,core,unit,system,b,radar_1,radar_2,antigrav,hover,gK,ce,z,c,d,g,h,i,j,l,m,n,o,s,t,v,c5)aK.ButtonSetup()aO=gL(a,core,unit,system,b,vBooster,hover,antigrav,gK,dbHud_2,i,n,s,r,o,v,k,u,m)coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",gM)unit.setTimer("radarTick",gM)unit.setTimer("hudTick",gN)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bO("start","SU")end)coroutine.resume(gF)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not fY then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(al>0 or al==0 and am<10000)then for cT,ct in pairs(door)do ct.toggle()end end;if switch then for cT,ct in pairs(switch)do ct.toggle()end end;if forcefield and(al>0 or al==0 and am<10000)then for cT,ct in pairs(forcefield)do ct.toggle()end end;bA=bz;co()if gO then gO.activate()end;if gP then aM.showWayPoint(gz,be)end;bO("stop","SU")end;function script.onTick(gQ)local gR=nil;if gQ=="contact"then if not gS then gS=0 end;if A>gS+10 then a0="Radar Contact"bO("rdrCon","RC")gS=A end;unit.stopTimer("contact")elseif gQ=="tenthSecond"then local function gT()local gU=system.createData;local gV=system.createWidget;gW=system.createWidgetPanel("Interplanetary Helper")gX=gV(gW,"value")gY=gU('{"label": "Target Planet", "value": "N/A", "unit":""}')q(gY,gX)gZ=gV(gW,"value")g_=gU('{"label": "distance", "value": "N/A", "unit":""}')q(g_,gZ)fi=gV(gW,"value")fh=gU('{"label": "Travel Time", "value": "N/A", "unit":""}')q(fh,fi)fg=gV(gW,"value")ff=gU('{"label": "Maximum Mass", "value": "N/A", "unit":""}')q(ff,fg)fk=gV(gW,"value")fj=gU('{"label": "Target Altitude", "value": "N/A", "unit":""}')q(fj,fk)fc=gV(gW,"value")fb=gU('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')fa=gV(gW,"value")f9=gU('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')f8=gV(gW,"value")f7=gU('{"label": "Max Brake distance", "value": "N/A", "unit":""}')f6=gV(gW,"value")f5=gU('{"label": "Max Brake Time", "value": "N/A", "unit":""}')fe=gV(gW,"value")fd=gU('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ak then q(fb,fc)q(f9,fa)q(f7,f8)q(f5,f6)q(fd,fe)end end;local function h0()o(gW)gW=nil end;local function h1()if not bK then if e_==nil or e_.planetname~=gz.name then h2=(a6.center-be):len()else h2=(e_.position-be):len()end end;local eo=bb;local h3=unit.getThrottle()/100;if bF then h3=J end;local h4,h5=aH.computeDistanceAndTime(bb,bL,ap,a:maxForceForward()*h3,h6,0)local a2,a3;if not h7 then a2,a3=aM.GetAutopilotBrakeDistanceAndTime(bL)else a2,a3=aM.GetAutopilotTBBrakeDistanceAndTime(bL)end;local cT,h8;if not h7 and eo>0 then cT,h8=aM.GetAutopilotBrakeDistanceAndTime(eo)else cT,h8=aM.GetAutopilotTBBrakeDistanceAndTime(eo)end;local h9=0;local ha=0;if ft or not bK and eo>5 then ha=aH.computeTravelTime(eo,0,h2)elseif a2+h4<h2 then h9=h2-(a2+h4)ha=aH.computeTravelTime(8333.0556,0,h9)else local hb=(h2-a2)/h4;h4=h2-a2;h5=h5*hb end;if e_~=nil and e_.planetname==gz.name and not bK then return ha elseif fs then return h8 elseif ft then return ha+h8 else return h5+a3+ha end end;local function hc(fG,hd)if fG==nil then fG=core.g()end;fG=v(fG,5)if hd~=nil and hd or(gR==nil or gR~=fG)then local eo=b9:len()local he=d(unit.getData()).maxBrake;if he~=nil and he>0 and ak then he=he/m(eo/100,0.1,1)he=he/al;if al>0.10 then if fX then fX=(fX+he)/2 else fX=he end end end;if he~=nil and he>0 then hf=he end;gR=fG end end;hc(nil,true)if bh~=nil then if n:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or n:getTargetSpeed(axisCommandId.longitudinal)~=bh then aM.cmdCruise(bh)else bh=nil end end;if f2~="None"then if gW==nil then gT()end;if f2~=nil then local hg=e_~=nil;local hh=0.5*fX/a6:getGravity(a6.center+vec3(0,0,1)*a6.radius):len()hh=hh>1000000 and v(hh/1000000,2).." kTons"or v(hh/1000,2).." Tons"p(gY,'{"label": "Target", "value": "'..f2 ..'", "unit":""}')hi=h1()if hg and not bK then ad=(be-e_.position):len()else ad=(fl-be):len()end;if not h7 then a2,a3=aM.GetAutopilotBrakeDistanceAndTime(bb)a4,a5=aM.GetAutopilotBrakeDistanceAndTime(bL)else a2,a3=aM.GetAutopilotTBBrakeDistanceAndTime(bb)a4,a5=aM.GetAutopilotTBBrakeDistanceAndTime(bL)end;local hj=cg(ad)p(g_,'{"label": "distance", "value": "'..hj..'"}')p(fh,'{"label": "Travel Time", "value": "'..cj(hi)..'", "unit":""}')hj=cg(a2)p(fb,'{"label": "Cur Brake distance", "value": "'..hj..'"}')p(f9,'{"label": "Cur Brake Time", "value": "'..cj(a3)..'", "unit":""}')hj=cg(a4)p(f7,'{"label": "Max Brake distance", "value": "'..hj..'"}')p(f5,'{"label": "Max Brake Time", "value": "'..cj(a5)..'", "unit":""}')p(ff,'{"label": "Max Brake Mass", "value": "'..c("%s",hh)..'", "unit":""}')hj=cg(fm)p(fj,'{"label": "Target Orbit", "value": "'..hj..'"}')if al>0 and not gr then system.removeDataFromWidget(f5,f6)system.removeDataFromWidget(f7,f8)system.removeDataFromWidget(f9,fa)system.removeDataFromWidget(fb,fc)system.removeDataFromWidget(fd,fe)gr=true;if not bi and bF and(hk or bJ or ah)then aM.cmdThrottle(1)gq=false;N=false end end;if al==0 and gr then if p(f5,f6)==1 then q(f5,f6)end;if p(f7,f8)==1 then q(f7,f8)end;if p(f9,fa)==1 then q(f9,fa)end;if p(fb,fc)==1 then q(fb,fc)end;if p(fd,fe)==1 then q(fd,fe)end;gr=false end end else h0()end;if warpdrive~=nil then if d(warpdrive.getData()).destination~="Unknown"and d(warpdrive.getData()).distance>400000 then warpdrive.show()hl=true else warpdrive.hide()hl=false end end;aK.TenthTick()elseif gQ=="oneSecond"then local function hm(hn)local ho=0;av=""local hp=aD;local hq=0;local hr=0;local hs=0;local ht=0;local hu=""local hv=core.getElementHitPointsById;for cs in pairs(an)do local gd=0;local hw=0;hw=f(an[cs])gd=hv(an[cs])hq=hq+gd;if gd<hw then if gd==0 then hs=hs+1 else hr=hr+1 end;if aE and#au==0 then eS=vec3(core.getElementPositionById(an[cs]))local c6=eS.x;local c7=eS.y;local hx=eS.z;table.insert(au,core.spawnArrowSticker(c6,c7,hx+1,"down"))table.insert(au,core.spawnArrowSticker(c6,c7,hx+1,"down"))core.rotateSticker(au[2],0,0,90)table.insert(au,core.spawnArrowSticker(c6+1,c7,hx,"north"))table.insert(au,core.spawnArrowSticker(c6+1,c7,hx,"north"))core.rotateSticker(au[4],90,90,0)table.insert(au,core.spawnArrowSticker(c6-1,c7,hx,"south"))table.insert(au,core.spawnArrowSticker(c6-1,c7,hx,"south"))core.rotateSticker(au[6],90,-90,0)table.insert(au,core.spawnArrowSticker(c6,c7-1,hx,"east"))table.insert(au,core.spawnArrowSticker(c6,c7-1,hx,"east"))core.rotateSticker(au[8],90,0,90)table.insert(au,core.spawnArrowSticker(c6,c7+1,hx,"west"))table.insert(au,core.spawnArrowSticker(c6,c7+1,hx,"west"))core.rotateSticker(au[10],-90,0,90)table.insert(au,an[cs])end elseif aE and#au>0 and au[11]==an[cs]then for hy in pairs(au)do core.deleteSticker(au[hy])end;au={}end end;ho=z(hq/hp*100)if ho<100 then hn[#hn+1]=c5(0,0,"","pbright txt")ht=z(ho*2.55)hu=c("rgb(%d,%d,%d)",255-ht,ht,0)if ho<100 then hn[#hn+1]=c5("50%",1035,"Elemental Integrity: "..ho.."%","txtbig txtmid","fill:"..hu)if hs>0 then hn[#hn+1]=c5("50%",1055,"Disabled Modules: "..hs.." Damaged Modules: "..hr,"txtbig txtmid","fill:"..hu)elseif hr>0 then hn[#hn+1]=c5("50%",1055,"Damaged Modules: "..hr,"txtbig txtmid","fill:"..hu)end end end end;local function hz()if hA then if hB==nil and(hC~=nil or gp)then _autoconf.displayCategoryPanel(hA,weapon_size,"Weapons","weapon",true)hB=_autoconf.panels[_autoconf.panels_size]elseif hB~=nil and hC==nil and not gp then o(hB)hB=nil end end end;local function hD()local gf=l()local hE=bb;local hF=gf-ao;if hE>1.38889 then hE=hE/1000;local hG=hE*(gf-ao)hH=hH+hG;a7=a7+hG end;a8=a8+hF;hI=hI+hF;ao=gf end;hD()bv=core.getPlayersOnBoard()bw=core.getDockedConstructs()hz()local hn={}aK.OneSecond(hn)if hJ then hm(hn)end;ae=table.concat(hn,"")collectgarbage("collect")elseif gQ=="fiveSecond"then if not hK then return end;aj=dbHud_1.getStringValue("SPBAutopilotTargetName")if aj~=nil and aj~=""and aj~="SatNavNotChanged"then local cK=d(dbHud_1.getStringValue("SavedLocations"))if cK~=nil then _G["SavedLocations"]=cK;local fA=-1;local fH;for cs,ct in pairs(fB)do if ct.name and ct.name=="SatNav Location"then fA=cs;break end end;if fA~=-1 then fH=fB[fA]fA=-1;for cs,ct in pairs(b[0])do if ct.name and ct.name=="SatNav Location"then fA=cs;break end end;if fA>-1 then b[0][fA]=fH end;aL.UpdateAtlasLocationsList()a0=fH.name.." position updated"end end;for bY=1,#bl do if bl[bY].name==aj then f1=bY;system.print("Index = "..f1 .." "..bl[bY].name)aL.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif gQ=="msgTick"then local hn={}aK.DisplayMessage(hn,"empty")a0="empty"unit.stopTimer("msgTick")ac=3 elseif gQ=="animateTick"then aQ=true;aP=false;aa=0;ab=0;unit.stopTimer("animateTick")elseif gQ=="hudTick"then aK.hudtick()elseif gQ=="apTick"then aM.APTick()elseif gQ=="radarTick"then aN.UpdateRadar()elseif gQ=="tagTick"then if hL=="Off"then hL="All"elseif hL=="All"then hL="Longitude"elseif hL=="Longitude"then hL="Lateral"elseif hL=="Lateral"then hL="Vertical"else hL="Off"end;a0="Extra Engine Tags: "..hL;unit.stopTimer("tagTick")end end;function script.onFlush()local function hM(hN,hO)local hP=vec3()local hQ=vec3()if hN==axisCommandId.longitudinal then hP=vec3(core.getConstructOrientationForward())hQ=b7 elseif hN==axisCommandId.vertical then hP=vec3(core.getConstructOrientationUp())hQ=b6 elseif hN==axisCommandId.lateral then hP=vec3(core.getConstructOrientationRight())hQ=b8 else return vec3()end;local hR=vec3(core.getWorldGravity())local hS=hR:dot(hQ)local hT=vec3(core.getWorldAirFrictionAcceleration())local hU=hT:dot(hQ)local hV=b9:dot(hP)local hW=hO*constants.kph2m;if hX==nil then hX=pid.new(10,0,10.0)end;hX:inject(hW-hV)local hY=hX:get()local hZ=(hY-hU-hS)*hQ;return hZ end;local function h_(hN,hO)local hP=vec3()local hQ=vec3()if hN==axisCommandId.longitudinal then hP=vec3(core.getConstructOrientationForward())hQ=b7 elseif hN==axisCommandId.vertical then hP=vec3(core.getConstructOrientationUp())hQ=b6 elseif hN==axisCommandId.lateral then hP=vec3(core.getConstructOrientationRight())hQ=b8 else return vec3()end;local hR=vec3(core.getWorldGravity())local hS=hR:dot(hQ)local hT=vec3(core.getWorldAirFrictionAcceleration())local hU=hT:dot(hQ)local hV=b9:dot(hP)local hW=hO*constants.kph2m;if i0==nil then i0=pid.new(10,0,10.0)end;i0:inject(hW-hV)local hY=i0:get()local hZ=(hY-hU-hS)*hQ;return hZ end;local function i1(i2,i3,eX)local i4=i2:cross(eX):normalize_inplace()local i5=math.acos(m(i4:dot(-i3),-1,1))*constants.rad2deg;if i4:cross(-i3):dot(eX)<0 then i5=-i5 end;return i5 end;if antigrav and not fY then if not bg and antigrav.getBaseAltitude()~=fZ then antigrav.setBaseAltitude(fZ)end end;bi=n:getAxisCommandType(0)==axisCommandType.byThrottle;if bi and N then aM.cmdThrottle(0)N=false elseif not bi and not N then J=0;N=true end;i6=math.max(i6,0.01)i7=math.max(i7,0.01)i8=math.max(i8,0.01)i9=math.max(i9,0.01)ia=math.max(ia,0.01)ib=math.max(ib,0.01)ic=math.max(ic,0.01)local id=m(S+T+system.getControlDeviceForwardInput(),-1,1)local ie=m(V+Y+system.getControlDeviceYawInput(),-1,1)local ig=m(W+U-system.getControlDeviceLeftRightInput(),-1,1)local ih=X;bc=vec3(core.getWorldVertical())if bc==nil or bc:len()==0 then bc=(gz.center-be):normalize()end;b6=vec3(core.getConstructWorldOrientationUp())b7=vec3(core.getConstructWorldOrientationForward())b8=vec3(core.getConstructWorldOrientationRight())ba=vec3(core.getWorldVelocity())b9=vec3(core.getVelocity())be=vec3(core.getConstructWorldPos())ap=core.getConstructMass()bb=vec3(ba):len()bd=-bc:dot(ba)bk=getRoll(bc,b7,b8)local ii=bk/180*math.pi;local ij=math.cos(ii)local ik=math.sin(ii)bj=i1(bc,b7,b8*ij+b6*ik)local il=ba:normalize()local im=ce(bk)local io=utils.sign(bk)local ip=vec3(core.getWorldAngularVelocity())local iq=id*i6*b8+ie*i8*b7+ig*i7*b6;if aR==true and bc:len()>0.01 then local ir=ce(aW-bk)if((is or bJ or it or af or hk or bN)and ir>0 or al>0.0 and ir<iu and aS)and ie==0 and ce(bj)<85 then local iv=aW;local iw=ic;if al==0 then iw=iw/4;aW=0;iv=0 end;if ix==nil then ix=pid.new(iw*0.01,0,iw*0.1)end;ix:inject(iv-bk)local iy=ix:get()iq=iq+iy*b7 end end;local iz=1;local iA=0;local iB=1;local iC=system.getMouseWheel()if iC>0 then bD()elseif iC<0 then bD(true)else aq=true end;K=0;if ak and bF and bi then if iD==nil then iD=pid.new(0.5,0,1)end;iD:inject(aX/3.6-ba:dot(b7))local iE=iD:get()M=m(iE,-1,1)if M<J and al>0.005 then L=true;n:setThrottleCommand(axisCommandId.longitudinal,m(M,0.01,1))else L=false;n:setThrottleCommand(axisCommandId.longitudinal,J)end;if iF==nil then iF=pid.new(1*0.01,0,1*0.1)end;iF:inject(ba:len()-aX/3.6)local iG=m(iF:get(),0,1)if al>0 and bd<-80 or al>0.005 then K=iG end;if K>0 then if L and M==0.01 then n:setThrottleCommand(axisCommandId.longitudinal,0)end else M=m(M,0.01,1)end;local iH=''local iI=vec3()local iJ=hM(axisCommandId.vertical,a9*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",iJ,iA)local iK='thrust analog longitudinal 'if hL=="All"or hL=="Longitude"then iK=iK..iL end;local iM=n:getAxisCommandType(axisCommandId.longitudinal)local iN=n:composeAxisAccelerationFromThrottle(iK,axisCommandId.longitudinal)local iO=h_(axisCommandId.lateral,iP*1000)iH=iH..' , '.."lateral airfoil , lateral ground "iI=iI+iO;if iI:len()>constants.epsilon then a:setEngineForceCommand(iH,iI,iA,'','','',iB)end;a:setEngineForceCommand(iK,iN,iz)local iQ='thrust analog vertical fueled 'local iR='thrust analog lateral fueled 'if hL=="All"or hL=="Lateral"then iR=iR..iS end;if hL=="All"or hL=="Vertical"then iQ=iQ..iT end;if a9~=0 or it and gq or not gp and not gn then a:setEngineForceCommand(iQ,iJ,iz)else a:setEngineForceCommand(iQ,vec3(),iz)end;if iP~=0 then a:setEngineForceCommand(iR,iO,iz)else a:setEngineForceCommand(iR,vec3(),iz)end;if ih==0 then ih=K end;local iU=-ih*(ia*ba+ib*il)a:setEngineForceCommand('brake',iU)else if bF then n:setThrottleCommand(axisCommandId.longitudinal,J)end;local hO=unit.getAxisCommandValue(0)if not bi then if iF==nil then iF=pid.new(1*0.01,0,1*0.1)end;iF:inject(ba:len()-hO/3.6)local iG=m(iF:get(),0,1)ih=m(ih+iG,0,1)end;local iU=-ih*(ia*ba+ib*il)a:setEngineForceCommand('brake',iU)local iH=''local iI=vec3()local iV=false;local iK='thrust analog longitudinal 'if hL=="All"or hL=="Longitude"then iK=iK..iL end;local iM=n:getAxisCommandType(axisCommandId.longitudinal)if iM==axisCommandType.byThrottle then local iN=n:composeAxisAccelerationFromThrottle(iK,axisCommandId.longitudinal)a:setEngineForceCommand(iK,iN,iz)elseif iM==axisCommandType.byTargetSpeed then local iN=n:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)iH=iH..' , '..iK;iI=iI+iN;if n:getTargetSpeed(axisCommandId.longitudinal)==0 or n:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-n:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then iV=true end end;local iR='thrust analog lateral 'if hL=="All"or hL=="Lateral"then iR=iR..iS end;local iW=n:getAxisCommandType(axisCommandId.lateral)if iW==axisCommandType.byThrottle then local iX=n:composeAxisAccelerationFromThrottle(iR,axisCommandId.lateral)a:setEngineForceCommand(iR,iX,iz)elseif iW==axisCommandType.byTargetSpeed then local iO=n:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)iH=iH..' , '..iR;iI=iI+iO end;local iQ='thrust analog vertical 'if hL=="All"or hL=="Vertical"then iQ=iQ..iT end;local iY=n:getAxisCommandType(axisCommandId.vertical)if iY==axisCommandType.byThrottle then local iJ=n:composeAxisAccelerationFromThrottle(iQ,axisCommandId.vertical)if a9~=0 or it and gq then a:setEngineForceCommand(iQ,iJ,iz,'airfoil','ground','',iB)else a:setEngineForceCommand(iQ,vec3(),iz)a:setEngineForceCommand('airfoil vertical',iJ,iz,'airfoil','','',iB)a:setEngineForceCommand('ground vertical',iJ,iz,'ground','','',iB)end elseif iY==axisCommandType.byTargetSpeed then if a9<0 then a:setEngineForceCommand('hover',vec3(),iz)end;local iZ=n:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)iH=iH..' , '..iQ;iI=iI+iZ end;if iI:len()>constants.epsilon then if X~=0 or iV or ce(il:dot(b7))<0.5 then iH=iH..', brake'end;a:setEngineForceCommand(iH,iI,iA,'','','',iB)end end;local i_=i9*(iq-ip)local j0=vec3(core.getWorldAirFrictionAngularAcceleration())i_=i_-j0;a:setEngineTorqueCommand('torque',i_,iz,'airfoil','','',iB)a:setBoosterCommand('rocket_engine')if a1 and not j1 then local eo=b9:len()local j2=0.15;if not bi then local j3=n:getTargetSpeed(axisCommandId.longitudinal)if eo*3.6>j3*(1-j2)and j4 then j4=false;a:toggleBoosters()elseif eo*3.6<j3*(1-j2)and not j4 then j4=true;a:toggleBoosters()end else local h3=unit.getThrottle()if bF then h3=J*100 end;local hO=h3/100;if g==0 then hO=hO*bL;if eo>=hO*(1-j2)and j4 then j4=false;a:toggleBoosters()elseif eo<hO*(1-j2)and not j4 then j4=true;a:toggleBoosters()end else local j5=z(aX)hO=hO*j5/3.6;if eo>=hO*(1-j2)and j4 then j4=false;a:toggleBoosters()elseif eo<hO*(1-j2)and not j4 then j4=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not gE then local j6=coroutine.status(gF)if j6=="suspended"then local cP,j7=coroutine.resume(gF)if j7 then system.print("ERROR STARTUP: "..j7)end elseif j6=="dead"then gE=true end end;if gE then a:update()if not aP and j8~=j9 then system.setScreen(j8)end;j9=j8 end end;function script.onActionStart(ja)aO.startControl(ja)end;function script.onActionStop(ja)aO.stopControl(ja)end;function script.onActionLoop(ja)aO.loopControl(ja)end;function script.onInputText(c8)aO.inputTextControl(c8)end;function script.onEnter(cY)if radar_1 and not ak and not bm then unit.setTimer("contact",0.1)end end;function script.onLeave(cY)if radar_1 and jb then if#bp>650 then cY=tostring(cY)bp[cY]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
