name: ArchHud - Archaegeo v1.359 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.359;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local p=utils.clamp;local q=a.axisCommandManager;local r=system.destroyWidgetPanel;local s=system.updateData;local t=system.addDataToWidget;local u=system.lockView;local v=system.isViewLocked;local w=math.sqrt;local x=tonumber;local core=core;local function y(z,A)local mult=10^(A or 0)return d(z*mult+0.5)/mult end;local B=o()local C=o()local D=16;local E=13;local F=SafeR;local G=SafeB;local H=SafeG;local I=0;local J=0;local K=false;local L=0;local M=false;local N=false;local O=55;local P=false;local Q=false;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=false;local Z=false;local a0="empty"local a1=5;local a2=5;local a3=a1;local a4=a2;local a5=false;local a6,a7=0;local a8,a9=0;local aa=nil;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=false;local ak=false;local al=false;local am=-1;local an=""local ao=j()>0;local ap=j()local aq=core.getAltitude()local ar=core.getElementIdList()local as=o()local at=core.getConstructMass()local au=false;local av=nil;local aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]local ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]local ay={}local az=0;local aA=0;local aB=""local aC=true;local aD={}local aE=ResolutionX;local aF=ResolutionY;local aG={}local aH={}local aI={}local aJ=0;local aK=false;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=false;local aZ=false;local a_=autoRollPreference;local b0=LandingGearGroundHeight;local b1=false;local b2=o()local b3=0;local b4=0;local b5=0;local b6=AtmoSpeedLimit;local b7=0;local b8=nil;local b9=0;local ba=0;local bb=false;local bc=false;local bd={VectorToTarget=false}local be=false;local bf=0;local bg=nil;local bh=false;local bi=false;local bj=false;local bk=false;local bl=0;local bm=vec3(core.getConstructWorldOrientationUp())local bn=vec3(core.getConstructWorldOrientationForward())local bo=vec3(core.getConstructWorldOrientationRight())local bp=vec3(core.getWorldVelocity())local bq=vec3(bp):len()local br=vec3(core.getWorldVertical())local bs=-br:dot(bp)local bt=vec3(core.getConstructWorldPos())local bu=0;local bv=false;local bw=false;local bx=nil;local by=true;local bz=0;local bA=0;local bB=false;local bC={}local bD=showHud;local bE={}local bF=false;local bG=""local bH=nil;local bI={}local bJ=unit.getClosestPlanetInfluence()>0;local bK=false;local bL=nil;function Log(bM,bN)local self={}self.Name=bM or'Log'self.Value=bN=='number'and 0 or{}self.Type=bN or'mean'function self.Update(bO)if self.Type=='number'then self.Value=bO else self.Value[#self.Value]=bO end end;function self.getString()if self.Type=='number'then return tostring(self.Value)elseif self.Type=='time'then return utils.round(self.getMean()*1000,0.0001)..'ms ('..#self.Value..")"elseif self.Type=='mean'then return tostring(utils.round(self.getMean(),0.01))end end;function self.getValue()if self.Type=='number'then return self.value else return self.getMean()end end;function self.addValue(bO)if self.Type=='number'then return end;table.insert(self.Value,1,bO)if#self.Value>1000 then self.Value[1001]=nil end end;function self.getMean()local bP=0;for i=1,#self.Value do bP=bP+self.Value[i]end;return bP/#self.Value end;return self end;function Logger()local self={}self.Logs={}function self.CreateLog(bM,type)local bQ=Log(bM,type)Register(bQ)return bQ end;function self.getLogs()local bR={}for _,bS in pairs(self.Logs)do bR[#bR+1]=bS.Name..': '..bS.getString()end;return bR end;function Register(bQ)self.Logs[#self.Logs+1]=bQ end;return self end;local function bT(bU)local bV,bW,bX=aQ:getPlanetarySystem(0):castIntersections(bt,bU,function(bY)if bY.noAtmosphericDensityAltitude>0 then return bY.radius+bY.noAtmosphericDensityAltitude else return bY.radius+bY.surfaceMaxAltitude*1.5 end end)local bZ=bW;if bX~=nil and bW~=nil then bZ=math.min(bX,bW)end;if bZ~=nil then return bV,bZ else return nil,nil end end;local function b_(c0,c1,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)end end;local function c2(c3,c4)for i=1,#c4 do c3[#c3+1]=c4[i]end;return c3 end;local function c5(c6)local c7={}local c8={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local c9={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local ca={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cb={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c6 then c2(c7,c8)c2(c7,c9)c2(c7,ca)c2(c7,cb)return c7 elseif c6=="boolean"then return c8 elseif c6=="handling"then return c9 elseif c6=="hud"then return ca elseif c6=="physics"then return cb end end;local function cc(cd,ce,cf,cg,ch)if cg==nil then cg=""end;if ch==nil then ch=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cg,cd,ce,ch,cf)end;local function ci(cj,ck)if q:getAxisCommandType(0)~=axisCommandType.byThrottle and not ck then a.control.cancelCurrentControlMasterMode()end;q:setThrottleCommand(axisCommandId.longitudinal,cj)I=p(y(cj*100,0)/100,-1,1)end;local function cl(cj,ck)if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ck then a.control.cancelCurrentControlMasterMode()end;q:setTargetSpeedCommand(axisCommandId.longitudinal,cj)bx=cj end;local function cm(cn,co)if cn==0 then return c(co)<1e-09 end;if co==0 then return c(cn)<1e-09 end;return c(cn-co)<math.max(c(cn),c(co))*epsilon end;local function cp(ah,cq)local cr=ah>100000;if cq==nil then cq=1 end;if cr then return y(ah/1000/200,cq).."SU"elseif ah<1000 then return y(ah,cq).."M"else return y(ah/1000,cq).."KM"end end;local function cs()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;a_=true;ad=0;if ao and am==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cl(d(b6))end else bh=false;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function ct()bh=false;b9=nil;ba=nil;bl=0;if ap==0 then if IntoOrbit then b_("orOff","AP")IntoOrbit=false;bb=false;bg=nil;a_=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bd.VectorToTarget=false;bd.AutopilotAlign=false;be=false elseif bJ then b_("orOn","AP")IntoOrbit=true;a_=true;if bg==nil then bg=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a0="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bb=false;bg=nil;a_=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bd.VectorToTarget=false;bd.AutopilotAlign=false;be=false end end;local function cu()if B-b4<1.5 then if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;b_("11","EP")else if bJ then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=HoldAltitude;be=true;if not IntoOrbit then ct()end;bb=true end end;b4=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b4=B end;if bJ and ap==0 then bf=aq;be=true;bb=true;ct()if IntoOrbit then b4=B else b4=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Y=false;a_=true;LockPitch=nil;bh=false;if am==-1 then b_("altOn","AH")AutoTakeoff=false;if b4>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=aq end end;if VertTakeOff then cs()end else b_("lfs","LS")AutoTakeoff=true;if b4>-1 then HoldAltitude=aq+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;q:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bv then cs()end end;if ak then HoldAltitude=100000 end else b_("altOff","AH")if IntoOrbit then ct()end;if VertTakeOff then cs()end;a_=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b4=0 end end;local function cv()local function cw(SpaceTarget)bK=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cu()end end;VectorStatus="Proceeding to Waypoint"end;if B-b5<1.5 and ap>0 then if not bk then a0="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b_("orH","OH")end;b5=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b5=B end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ak and not IntoOrbit then aV.UpdateAutopilotTarget()aW.showWayPoint(aa,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then b_("apSpc","AP")if ap~=0 then ak=true;cu()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ap>0 then if not VectorToTarget then b_("vtt","AP")cw(SpaceTarget)end else b_("apOn","AP")if not(aa.name==planet.name and bJ)then bh=false;Autopilot=true elseif not ao then if IntoOrbit then ct()end;bf=planet.noAtmosphericDensityAltitude+LowOrbitHeight;be=true;bd.AutopilotAlign=true;bd.VectorToTarget=true;bb=false;if not IntoOrbit then ct()end end end else b_("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ap~=0 then ak=true;cu()else Autopilot=true end end elseif ap==0 then if CustomTarget==nil and(aa.name==planet.name and bJ)and not IntoOrbit then WaypointSet=false;bh=false;bb=false;ct()else b_("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Y=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;N=false;LockPitch=nil;WaypointSet=false end else b_("apP","AP")ak=true;cu()end else b_("apOff","AP")ak=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;N=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=aq;TargetSet=false;Reentry=false;if IntoOrbit then ct()end end end;local function cx()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;a_=autoRollPreference end;if BrakeIsOn then b_("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bH=nil;if not bw then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cs()end;if IntoOrbit then ct()end;a_=autoRollPreference;aj=false;al=false;ad=0 else b_("bkOff","B",1)end end;local function cy()if Reentry then a0="Re-Entry cancelled"b_("reOff","RE")Reentry=false;a_=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not P then Reentry=true;if q:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;a_=true;BrakeIsOn=false;a0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b6;b_("par","RE")else Reentry=true;AltitudeHold=true;a_=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cf=cp(HoldAltitude)a0="Beginning Re-entry.  Target speed: "..b6 .." Target Altitude: "..cf;b_("glide","RE")cl(d(b6))end;AutoTakeoff=false end;local function cz()if antigrav and not ExternalAGG then if bw then b_("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;b_("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cA(cB)local cC=0;local cD=0;local cE=0;if cB<60 then cB=d(cB)elseif cB<3600 then cC=d(cB/60)cB=d(cB%60)elseif cB<86400 then cD=d(cB/3600)cC=d(cB%3600/60)else cE=d(cB/86400)cD=d(cB%86400/3600)end;if cE>0 then return cE.."d "..cD.."h "elseif cD>0 then return cD.."h "..cC.."m "elseif cC>0 then return cC.."m "..cB.."s"elseif cB>0 then return cB.."s"else return"0s"end end;local function cF(cG)local function cH(cI)for cJ,bO in pairs(cI)do dbHud_1.setStringValue(bO,g(_G[bO]))if cG and dbHud_2 then dbHud_2.setStringValue(bO,g(_G[bO]))end end end;if dbHud_1 then cH(b)cH(c5())system.print("Saved Variables to Datacore")if cG and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end;local function cK()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cL()local function cM(cN)return type(cN)=='number'end;local function cO(cN)return type(x(cN))=='number'end;local function cP(cQ)return type(cQ)=='table'end;local function cR(cS)return type(cS)=='string'end;local function cT(bO)return cP(bO)and cM(bO.x and bO.y and bO.z)end;local function cU(bP)return cP(bP)and cM(bP.latitude and bP.longitude and bP.altitude and bP.bodyId and bP.systemId)end;local cV=math.pi/180;local cW=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cX='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cY(cN)local cZ=string.gsub(string.reverse(e('%.4f',cN)),'^0*%.?','')return cZ==''and'0'or string.reverse(cZ)end;local function c_(d0)if cT(d0)then return e('{x=%.3f,y=%.3f,z=%.3f}',d0.x,d0.y,d0.z)end;if cP(d0)and not getmetatable(d0)then local d1={}local d2=next(d0)if type(d2)=='nil'or d2==1 then d1=d0 else for cJ,bO in pairs(d0)do local cj=c_(bO)if type(cJ)=='number'then table.insert(d1,e('[%s]=%s',cJ,cj))else table.insert(d1,e('%s=%s',cJ,cj))end end end;return e('{%s}',table.concat(d1,','))end;if cR(d0)then return e("'%s'",d0:gsub("'",[[\']]))end;return tostring(d0)end;local d3={}d3.__index=d3;d3.__tostring=function(d0,d4)local d5={}for cJ in pairs(d0)do table.insert(d5,cJ)end;table.sort(d5)local d1={}for _,cJ in ipairs(d5)do local cj=c_(d0[cJ])if type(cJ)=='number'then table.insert(d1,e('[%s]=%s',cJ,cj))else table.insert(d1,e('%s=%s',cJ,cj))end end;if d4 then return e('%s%s',d4,table.concat(d1,',\n'..d4))end;return e('{%s}',table.concat(d1,','))end;d3.__eq=function(d6,d7)return d6.planetarySystemId==d7.planetarySystemId and d6.bodyId==d7.bodyId and cm(d6.radius,d7.radius)and cm(d6.center.x,d7.center.x)and cm(d6.center.y,d7.center.y)and cm(d6.center.z,d7.center.z)and cm(d6.GM,d7.GM)end;local function d8(d9,da,db,dc,dd)assert(cO(d9),'Argument 1 (planetarySystemId) must be a number:'..type(d9))assert(cO(da),'Argument 2 (bodyId) must be a number:'..type(da))assert(cO(db),'Argument 3 (radius) must be a number:'..type(db))assert(cP(dc),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dc))assert(cO(dd),'Argument 5 (GM) must be a number:'..type(dd))return setmetatable({planetarySystemId=x(d9),bodyId=x(da),radius=x(db),center=vec3(dc),GM=x(dd)},d3)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(de)return e('::pos{%d,%d,%s,%s,%s}',de.systemId,de.bodyId,cY(de.latitude*cW),cY(de.longitude*cW),cY(de.altitude))end;MapPosition.__eq=function(d6,d7)return d6.bodyId==d7.bodyId and d6.systemId==d7.systemId and cm(d6.latitude,d7.latitude)and cm(d6.altitude,d7.altitude)and(cm(d6.longitude,d7.longitude)or cm(d6.latitude,math.pi/2)or cm(d6.latitude,-math.pi/2))end;local function df(dg,da,dh,di,dj)local d9=dg;if cR(dg)and not di and not dj and not da and not dh then d9,da,dh,di,dj=n(dg,cX)assert(d9,'Argument 1 (position string) is malformed.')else assert(cO(d9),'Argument 1 (systemId) must be a number:'..type(d9))assert(cO(da),'Argument 2 (bodyId) must be a number:'..type(da))assert(cO(dh),'Argument 3 (latitude) must be in degrees:'..type(dh))assert(cO(di),'Argument 4 (longitude) must be in degrees:'..type(di))assert(cO(dj),'Argument 5 (altitude) must be in meters:'..type(dj))end;d9=x(d9)da=x(da)dh=x(dh)di=x(di)dj=x(dj)if da==0 then return setmetatable({latitude=dh,longitude=di,altitude=dj,bodyId=da,systemId=d9},MapPosition)end;return setmetatable({latitude=cV*p(dh,-90,90),longitude=cV*(di%360),altitude=dj,bodyId=da,systemId=d9},MapPosition)end;local dk={}dk.__index=dk;dk.__tostring=function(d0,d4)local dl=d4 and d4 ..'  'local dm={}local d5={}for cJ in pairs(d0)do table.insert(d5,cJ)end;table.sort(d5)for _,dn in ipairs(d5)do bdy=d0[dn]local dp=d3.__tostring(bdy,dl)if d4 then table.insert(dm,e('[%s]={\n%s\n%s}',dn,dp,d4))else table.insert(dm,e('  [%s]=%s',dn,dp))end end;if d4 then return e('\n%s%s%s',d4,table.concat(dm,',\n'..d4),d4)end;return e('{\n%s\n}',table.concat(dm,',\n'))end;local function dq(dr)local aL={}local pid;for _,bO in pairs(dr)do local ds=bO.planetarySystemId;if type(ds)~='number'then error('Invalid planetary system ID: '..tostring(ds))elseif pid and ds~=pid then error('Mistringmatch planetary system IDs: '..ds..' and '..pid)end;local dt=bO.bodyId;if type(dt)~='number'then error('Invalid body ID: '..tostring(dt))elseif aL[dt]then error('Duplicate body ID: '..tostring(dt))end;setmetatable(bO.center,getmetatable(vec3.unit_x))aL[dt]=setmetatable(bO,d3)pid=ds end;return setmetatable(aL,dk)end;aP={}local function du(dr)return setmetatable({galaxyAtlas=dr or{}},aP)end;aP.__index=function(cQ,i)if type(i)=='number'then local system=cQ.galaxyAtlas[i]return dq(system)end;return rawget(aP,i)end;aP.__pairs=function(d0)return function(cQ,cJ)local dv,nv=next(cQ,cJ)return dv,nv and dq(nv)end,d0.galaxyAtlas,nil end;aP.__tostring=function(d0)local dw={}for _,dx in pairs(d0 or{})do local dy=dx:getPlanetarySystemId()local dz=dk.__tostring(dx,'    ')table.insert(dw,e('  [%s]={%s\n  }',dy,dz))end;return e('{\n%s\n}\n',table.concat(dw,',\n'))end;aP.BodyParameters=d8;aP.MapPosition=df;aP.PlanetarySystem=dq;function aP.createBodyParameters(dA,da,dB,dC,dD,dE,dF)assert(cO(dA),'Argument 1 (planetarySystemId) must be a number:'..type(dA))assert(cO(da),'Argument 2 (bodyId) must be a number:'..type(da))assert(cO(dB),'Argument 3 (surfaceArea) must be a number:'..type(dB))assert(cP(dC),'Argument 4 (aPosition) must be an array or vec3:'..type(dC))assert(cP(dD),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dD))assert(cO(dE),'Argument 6 (altitude) must be in meters:'..type(dE))assert(cO(dF),'Argument 7 (gravityAtPosition) must be number:'..type(dF))local db=w(dB/4/math.pi)local ah=db+dE;local dG=vec3(dC)+ah*vec3(dD)local dd=dF*ah*ah;return d8(dA,da,db,dG,dd)end;aP.isMapPosition=cU;function aP:getPlanetarySystem(dg)if i==nil then i=0 end;if nv==nil then nv=0 end;local dA=dg;if cU(dg)then dA=dg.systemId end;if type(dA)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dk then system=dq(system)end;return system end end end;function dk:sizeCalculator(bY)return 1.05*bY.radius end;function dk:castIntersections(dH,dI,dJ,dK,dL,dM)local dN={}local dO=dL or self;for _,bY in pairs(dO)do table.insert(dN,bY)end;if not dM then table.sort(dN,function(dP,dQ)return(dP.center-dH):len()<(dQ.center-dH):len()end)end;local dR=dI:normalize()for _,bY in ipairs(dN)do local dS=bY.center-dH;local db=self:sizeCalculator(bY)local dT=dS:dot(dR)local dU=dT^2-(dS:len2()-db^2)if dU>=0 then local dV=w(dU)local bW=dT+dV;local bX=dT-dV;if bX>0 then return bY,bW,bX elseif bW>0 then return bY,bW,nil end end end;return nil,nil,nil end;function dk:closestBody(dW)assert(type(dW)=='table','Invalid coordinates.')local dX,bY;local dY=vec3(dW)for _,dZ in pairs(self)do local d_=(dZ.center-dY):len2()if(not bY or d_<dX)and dZ.name~="Space"then bY=dZ;dX=d_ end end;return bY end;function dk:convertToBodyIdAndWorldCoordinates(dg)local e0=dg;if cR(dg)then e0=df(dg)end;if e0.bodyId==0 then return 0,vec3(e0.latitude,e0.longitude,e0.altitude)end;local dZ=self:getBodyParameters(e0)if dZ then return e0.bodyId,dZ:convertToWorldCoordinates(e0)end end;function dk:getBodyParameters(dg)local da=dg;if cU(dg)then da=dg.bodyId end;assert(cO(da),'Argument 1 (bodyId) must be a number:'..type(da))return self[da]end;function dk:getPlanetarySystemId()local _,bO=next(self)return bO and bO.planetarySystemId end;function d3:convertToMapPosition(dc)assert(cP(dc),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dc))local e1=vec3(dc)if self.bodyId==0 then return setmetatable({latitude=e1.x,longitude=e1.y,altitude=e1.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local e2=e1-self.center;local ah=e2:len()local dj=ah-self.radius;local dh=0;local di=0;if not cm(ah,0)then local e3=m(e2.y,e2.x)di=e3>=0 and e3 or 2*math.pi+e3;dh=math.pi/2-math.acos(e2.z/ah)end;return setmetatable({latitude=dh,longitude=di,altitude=dj,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function d3:convertToWorldCoordinates(dg)local e0=cR(dg)and df(dg)or dg;if e0.bodyId==0 then return vec3(e0.latitude,e0.longitude,e0.altitude)end;assert(cU(e0),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e0.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e0.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local e4=math.cos(e0.latitude)return self.center+(self.radius+e0.altitude)*vec3(e4*math.cos(e0.longitude),e4*math.sin(e0.longitude),math.sin(e0.latitude))end;function d3:getAltitude(dc)return(vec3(dc)-self.center):len()-self.radius end;function d3:getDistance(dc)return(vec3(dc)-self.center):len()end;function d3:getGravity(dc)local e5=self.center-vec3(dc)local e6=e5:len2()return self.GM/e6*e5/w(e6)end;return setmetatable(aP,{__call=function(_,...)return du(...)end})end;local function e7()local aR={}local e8=30000000/3600;local e9=e8*e8;local ea=100;local function eb(bO)return 1/w(1-bO*bO/e9)end;function aR.computeAccelerationTime(ec,ed,ee)local ef=e8*math.asin(ec/e8)return(e8*math.asin(ee/e8)-ef)/ed end;function aR.computeDistanceAndTime(ec,ee,eg,eh,ei,ej)ei=ei or 0;ej=ej or 0;local ek=ec<=ee;local el=eh*(ek and 1 or-1)/eg;local em=-ej/eg;local en=el+em;if ek and en<=0 or not ek and en>=0 then return-1,-1 end;local eo,ep=0,0;if el~=0 and ei>0 then local ef=math.asin(ec/e8)local eq=math.pi*(el/2+em)local er=el*ei;local es=e8*math.pi;local bO=function(cQ)local et=(eq*cQ-er*math.sin(math.pi*cQ/2/ei)+es*ef)/es;local eu=math.tan(et)return e8*eu/w(eu*eu+1)end;local ev=ek and function(cS)return cS>=ee end or function(cS)return cS<=ee end;ep=2*ei;if ev(bO(ep))then local ew=0;while c(ep-ew)>0.5 do local cQ=(ep+ew)/2;if ev(bO(cQ))then ep=cQ else ew=cQ end end end;local ex=ec;local ey=ep/ea;for ez=1,ea do local eA=bO(ez*ey)eo=eo+(eA+ex)*ey/2;ex=eA end;if ep<2*ei then return eo,ep end;ec=ex end;local ef=e8*math.asin(ec/e8)local B=(e8*math.asin(ee/e8)-ef)/en;local eB=e9*math.cos(ef/e8)/en;local ah=eB-e9*math.cos((en*B+ef)/e8)/en;return ah+eo,B+ep end;function aR.computeTravelTime(ec,ed,ah)if ah==0 then return 0 end;if ed>0 then local ef=e8*math.asin(ec/e8)local eB=e9*math.cos(ef/e8)/ed;return(e8*math.acos(ed*(eB-ah)/e9)-ef)/ed end;if ec==0 then return-1 end;assert(ec>0,'Acceleration and initial speed are both zero.')return ah/ec end;function aR.lorentz(bO)return eb(bO)end;return aR end;local function eC()local vec3=require('cpml.vec3')local cL=cL()local function cR(cS)return type(cS)=='string'end;local function cP(cQ)return type(cQ)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dj)assert(self.body)local ah=dj+self.body.radius;if not cm(ah,0)then local orbit=w(self.body.GM/ah)return w(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dg,eD)assert(self.body)assert(cP(dg)or cR(dg))assert(cP(eD))local eE=(cR(dg)or cL.isMapPosition(dg))and self.body:convertToWorldCoordinates(dg)or vec3(dg)local bO=bp;local eF=eE-self.body.center;local eG=bO:len2()local eH=eF:len()local eI=self.body.GM;local eJ=((eG-eI/eH)*eF-eF:dot(bO)*bO)/eI;local cn=eI/(2*eI/eH-eG)local eK=eJ:len()local dR=eJ:normalize()local eL=cn*(1-eK)local eM=cn*(1+eK)local eN=eL*dR+self.body.center;local eO=eK<=1 and-eM*dR+self.body.center or nil;local eP=w(cn*eI*(1-eK*eK))local eQ=eO and 2*math.pi*w(cn^3/eI)local eR=math.acos(eJ:dot(eF)/(eK*eH))if eF:dot(bO)<0 then eR=-(eR-2*math.pi)end;local eS=math.acos((math.cos(eR)+eK)/(1+eK*math.cos(eR)))local eT=eS;if eT<0 then eT=eT+2*math.pi end;local eU=eT-eK*math.sin(eT)local eV=0;local eW=0;local eX=0;if eQ~=nil then eV=eU/(2*math.pi/eQ)eW=eQ-eV;eX=eW+eQ/2;if eR-math.pi>0 then eW=eV;eX=eW+eQ/2 end;if eX>eQ then eX=eX-eQ end end;return{periapsis={position=eN,speed=eP/eL,circularOrbitSpeed=w(eI/eL),altitude=eL-self.body.radius},apoapsis=eO and{position=eO,speed=eP/eM,circularOrbitSpeed=w(eI/eM),altitude=eM-self.body.radius},currentVelocity=bO,currentPosition=eE,eccentricity=eK,period=eQ,eccentricAnomaly=eS,meanAnomaly=eU,timeToPeriapsis=eW,timeToApoapsis=eX}end;local function eY(eZ)local dZ=cL.BodyParameters(eZ.planetarySystemId,eZ.bodyId,eZ.radius,eZ.center,eZ.GM)return setmetatable({body=dZ},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eY(...)end})end;local function e_()local f0={}local f1={}local f2={XS=13,S=27,M=55,L=110,XL=221}local f3={}local f4;local f5;local f6;local f7;local f8;local function f9()local function fa(fb,fc,fd,fe,ff,fg,fh,fi)fc,fe,fg,fi=vec3(fc),vec3(fe),vec3(fg),vec3(fi)local fj,fk,fl=fb*fb,fd*fd,ff*ff;local eG=fe-fc;local fm=eG:normalize()local fn=eG:len()local fo=fg-fc;local fp=(fo-fo:project_on(fm)):normalize()local fq,fr=fo:dot(fm),fo:dot(fp)local fs=fq*fq+fr*fr;local ft=fm:cross(fp)local cd=(fj-fk+fn*fn)/(2*fn)local ce=(fj-fl+fs-2*fq*cd)/(2*fr)local bP=fj-cd^2-ce^2;local fu=w(bP)local fv=fc+fm*cd+fp*ce+ft*fu;local fw=fc+fm*cd+fp*ce-ft*fu;if c((fi-fv):len()-fh)<c((fi-fw):len()-fh)then return fv else return fw end end;local function fx()local function fy()local fz=core.getConstructWorldOrientationRight()local eG=core.getConstructWorldOrientationForward()local fo=core.getConstructWorldOrientationUp()local fA=library.systemResolution3(fz,eG,fo,{1,0,0})local fB=library.systemResolution3(fz,eG,fo,{0,1,0})local fC=library.systemResolution3(fz,eG,fo,{0,0,1})return function(fD)return library.systemResolution3(fA,fB,fC,fD)end end;local fE=fy()local fF=core.getConstructWorldPos()local eE=core.getElementPositionById(1)local fG={eE[1]-D,eE[2]-D,eE[3]-D}local fH=fE(fG)local fI={fF[1]-fH[1],fF[2]-fH[2],fF[3]-fH[3]}return fI end;local function fJ(fK,eH,fL)local fM=fK.pts;local fN=#fM;local fO=fK.ref;if fN>3 then local fP,fQ,fR,fS=fM[fN],fM[fN-1],fM[fN-2],fM[fN-3]fK.ref=fL;local eE=fa(fP[1],fP[2],fQ[1],fQ[2],fR[1],fR[2],fS[1],fS[2])local cd,ce,fu=eE.x,eE.y,eE.z;if cd==cd and ce==ce and fu==fu then cd=cd+fO[1]ce=ce+fO[2]fu=fu+fO[3]local fT=vec3(cd,ce,fu)if not fK.lastPos then fK.center=fT elseif(fK.lastPos-fT):len()<2 then fK.center=fT;fK.skipCalc=true end;fK.lastPos=fT end;fK.pts={}else local fU={fL[1]-fO[1],fL[2]-fO[2],fL[3]-fO[3]}fM[fN+1]={eH,fU}end end;if radar_1 then f4=#radar_1.getEntries()local fV=radar_1.getData()local fW=fV:gmatch('{"constructId[^}]*}[^}]*}')if f4>0 then local fL=fx()local fX,fY=0,0;f8=0;for bO in fW do local ds,ah,fZ=bO:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local f_=f2[fZ]ah=x(ah)if radar_1.hasMatchingTransponder(ds)==1 then table.insert(f1,ds)end;local g0=radar_1.getConstructType(ds)if CollisionSystem then if f_>27 or g0=="static"or g0=="space"then f8=f8+1;local bM=radar_1.getConstructName(ds)local fK=bI[ds]if fK==nil then f_=f_+E;bI[ds]={pts={},ref=fL,name=bM,i=0,radius=f_,skipCalc=false}fK=bI[ds]end;if not fK.skipCalc then fJ(fK,ah,fL)fY=fY+1 end;if fK.center then table.insert(f3,fK)end end;fX=fX+1;if bJ and fX>700 or fY>70 or(not bJ and fX>300 or fY>30)then coroutine.yield()fX,fY=0,0 end end end;f7=#f3;if f7>0 and bq>20 then local bY,g1,g2,g3;local g4=0;local g5=aQ:getPlanetarySystem(0)g3=bp:normalize()while g4<f7 do coroutine.yield()local g6={table.unpack(f3,g4,math.min(g4+75,f7))}bY,g1,g2=g5:castIntersections(bt,g3,nil,nil,g6,true)if bY and g2 then bL={bY,g1,g2}break end;g4=g4+75 end;if not bY then bL=nil end else bL=nil end;f3={}f5=fV:find('identifiedConstructs":%[%]')else f6=fV:find('worksInEnvironment":false')end end end;function f0.UpdateRadar()local g7=coroutine.status(UpdateRadarCoroutine)if g7=="suspended"then local cj,g8=coroutine.resume(UpdateRadarCoroutine)if g8 then system.print("ERROR UPDATE RADAR: "..g8)end elseif g7=="dead"then UpdateRadarCoroutine=coroutine.create(f9)local cj,g8=coroutine.resume(UpdateRadarCoroutine)end end;function f0.GetRadarHud()return f5,f6,f4,f7,f8,f1 end;UpdateRadarCoroutine=coroutine.create(f9)return f0 end;local function g9()local ga=0;local gb=vec3({13771471,7435803,-128971})local gc=18000000;local gd=500000;local ge,gf=math.huge;local gg;local function gh(gi)ge=vec3(gi):dist(gb)if ge<gc then return true,c(ge-gc)end;gf=vec3(gi):dist(vec3(planet.center))if gf<gd then gg=true else gg=false end;if c(gf-gd)<c(ge-gc)then return gg,c(gf-gd)else return gg,c(ge-gc)end end;local function gj(bO)if aE==1920 then return bO else return y(aE*bO/1920,0)end end;local function gk(bO)if aF==1080 then return bO else return y(aF*bO/1080,0)end end;local function gl()return v()==0 and userControlScheme~="keyboard"and l()==0 end;local function gm()local gn="TRAVEL"if not by then gn="CRUISE"end;if Autopilot then gn="AUTOPILOT"end;return gn end;local go=""local gp=""local gq=1;local gr=2;local gs=3;local gt=4;local gu=5;local gv=6;local gw=""local gx=0;local gy=d(1/apTickRate)*2*hudTickRate;local gz={}local gA={}local gB={}local gC={}local gD={}local gE={}local function gF(cd,gG,gH,gI,gJ,gK)local gL=fuelY;local gM=fuelY+5;if not BarFuelDisplay then gM=gM+5 end;if l()==1 and not RemoteHud then gL=gL-50;gM=gM-50 end;if gH=="ATMO"then gw="atmofueltank"elseif gH=="SPACE"then gw="spacefueltank"else gw="rocketfueltank"end;gx=_G[gw.."_size"]if#gI>0 then for i=1,#gI do local bM=string.sub(gI[i][gr],1,12)local gN=0;for gO=1,gx do if gI[i][gr]==f(unit[gw.."_"..gO].getData()).name then gN=gO;break end end;local gP=o()if gJ[i]==nil or gK[i]==nil or gP-gI[i][gv]>gy then local gQ;local gR=0;if gN~=0 then gK[i]=f(unit[gw.."_"..gN].getData()).percentage;gJ[i]=f(unit[gw.."_"..gN].getData()).timeLeft;if gJ[i]=="n/a"then gJ[i]=0 end else gR=k(gI[i][gq])-gI[i][gt]gK[i]=d(0.5+gR*100/gI[i][gs])gQ=gI[i][gu]if gQ<=gR then gJ[i]=0 else gJ[i]=d(0.5+gR/((gQ-gR)/(gP-gI[i][gv])))end;gI[i][gu]=gR;gI[i][gv]=gP end end;if bM==gG then bM=e("%s %d",gH,i)end;if gN==0 then bM=bM.." *"end;local gS;if gJ[i]==0 then gS=""else gS=cA(gJ[i])end;if gK[i]~=nil then local gT=d(gK[i]*2.55)local gU=e("rgb(%d,%d,%d)",255-gT,gT,0)local cg=""if gS~=""and gJ[i]<120 or gK[i]<5 then cg=[[class="red"]]end;if BarFuelDisplay then gp=gp..e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cd,gM,gU,gK[i],cd,gM,cd+2,gM+10,gK[i],gS)gp=gp..cc(cd,gL,bM,cg.."txtstart pdim txtfuel")gL=gL-30;gM=gM-30 else gp=gp..cc(cd,gL,bM,cg.." pdim txtfuel")gp=gp..cc(cd,gM,e("%d%% %s",gK[i],gS),"pdim txtfuel","fill:"..gU)gL=gL+30;gM=gM+30 end end end end end;local function gV(gW,dj)if dj<200000 and not ao or dj and ao then local gX=0;if c(bs)>1 then gX=45*math.log(c(bs),10)if bs<0 then gX=-gX end end;gW[#gW+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bs),d(gX))end;return gW end;local function gY(gZ)local g_=-br;gZ=gZ-gZ:project_on(g_)local h0=vec3(0,0,1)h0=h0-h0:project_on(g_)local h1=h0:cross(g_)local gX=h0:angle_between(gZ)*constants.rad2deg;if gZ:dot(h1)<0 then gX=360-gX end;return gX end;local function h2(gW,centerX,centerY,h3,h4,bJ)local h5=circleRad;local h6=20;local h7=d(h3)if bJ then for i=-45,45,5 do local h8=i;gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],h8,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gW[#gW+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h5+h6-len,centerX,centerY+h5+h6)end;gW[#gW+1]=cc(centerX,centerY+h5+h6-35,h4,"pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY+h5+h6-25,h7 .." deg","pdim txt txtmid")gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h5+h6-20,centerX+5,centerY+h5+h6-20,centerX,centerY+h5+h6-15)gW[#gW+1]="</g>"end;local h9=h7;if bJ then h9=gY(bn)end;local ha=20;local hb=d(h9)local hc=0;local hd=centerY+h5+h6+20;local he=centerX;if h4~="YAW"then hd=gk(130)he=gj(960)end;local hf=[[<path class="txttick line" d="]]local hg=d(hb-(ha+10)-hb%5+0.5)for i=hg+60,hg,-5 do local cd=he-(-i*5+h9*5)if i%10==0 then hc=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;gW[#gW+1]=cc(cd+5,hd-12,z)elseif i%5==0 then hc=5 end;if hc==10 then hf=e([[%s M %f %f v %d]],hf,cd,hd-5,hc)else hf=e([[%s M %f %f v %d]],hf,cd,hd-2.5,hc)end end;gW[#gW+1]=hf..[["/>]]gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],he-5,hd+10,he+5,hd+10,he,hd+5)if bJ then h4="HDG"end;gW[#gW+1]=cc(he,hd+25,hb.."deg","pdim txt txtmid","")gW[#gW+1]=cc(he,hd+35,h4,"pdim txt txtmid","")end;local function hh(gW,hi,h3,centerX,centerY,bJ,hj,eA)local h5=circleRad;local hk=d(h5*3/5)if h5>0 then local hl=d(hi)local len=0;local hf=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h3,centerX,centerY)if not ao then hf=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gW[#gW+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h5-1,centerX,centerY)gW[#gW+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hl-30-hl%5+0.5),d(hl+30+hl%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local ce=centerY+-i*5+hi*5;if len==30 then hf=e([[%s M %d %f h %d]],hf,centerX-hk-len,ce,len)if ao then gW[#gW+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX-hk+10,ce,i)gW[#gW+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX+hk-10,ce,i)if i==0 or i==180 or i==-180 then gW[#gW+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+20,ce,hk*2-40)end else gW[#gW+1]=cc(centerX-hk+10,ce,i,"pdim txt txtmid")gW[#gW+1]=cc(centerX+hk-10,ce,i,"pdim txt txtmid")end;hf=e([[%s M %d %f h %d]],hf,centerX+hk,ce,len)else hf=e([[%s M %d %f h %d]],hf,centerX-hk-len,ce,len)hf=e([[%s M %d %f h %d]],hf,centerX+hk,ce,len)end end;gW[#gW+1]=hf..[["/>]]local hm="PITCH"if not bJ then hm="REL PITCH"end;if hi>90 and not ao then hi=90-(hi-90)elseif hi<-90 and not ao then hi=-90-(hi+90)end;if h5>200 then if ao then if eA>O then gW[#gW+1]=cc(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY+20,hj,"pdim txt txtmid")end;gW[#gW+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)else gW[#gW+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hk+25,centerY-5,centerX-hk+20,centerY,centerX-hk+25,centerY+5,centerX-hk+50,centerY+4,hl)gW[#gW+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hk-25,centerY-5,centerX+hk-20,centerY,centerX+hk-25,centerY+5,centerX+hk-30,centerY+4,hl)gW[#gW+1]="</g>"end;local hn=d(h5/3)gW[#gW+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hn,centerY,h5-hn)if not ao and bJ then gW[#gW+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+10,centerY,hk*2-20)end;gW[#gW+1]="</g>"if h5<200 then if ao and eA>O then gW[#gW+1]=cc(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY-h5+10,hl,"pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY+20,hj,"pdim txt txtmid")else gW[#gW+1]=cc(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=cc(centerX,centerY-h5+15,hl,"pdim txt txtmid")end end end end;local function ho(gW,dj,bJ)local hp=altMeterX;local hq=altMeterY;local hr=78;local hs=19;local ht=am;if am~=-1 then gW[#gW+1]=cc(hp+hr,hq+hs+20,e("AGL: %.1fm",am),"pdim altsm txtend")end;if bJ and(dj<200000 and not ao or dj and ao)then table.insert(gW,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hp-1,hq-4,hr+2,hs+6,hp+1,hq-1,hr-4,hs))local fN=0;local hu=1;local hv=0;local hw=dj<0;local hx=dj<planet.surfaceMaxAltitude;local hy=9;if hw then hy=0 end;local dj=c(dj)while fN<6 do local hz=11;local hA=16;local hB=9;local hC=14;local cg="altsm"if fN>2 then hA=hA+3;hz=hz+2;hC=hC+2;hB=hB-6;cg="altbig"end;if hw then cg=cg.." red"elseif hx then cg=cg.." orange"end;local hD=dj/hu%10;local hE=d(hD)local hF=d((hE+1)%10)local hG=hv;if fN==0 then hG=hD-hE;if hw then hG=1-hG end end;if hw and(fN==0 or hv~=0)then local hH=hF;hF=hE;hE=hH end;local hI=hA*(hG-1)local hJ=hI+hA;local cd=hp+hB+(6-fN)*hz;local ce=hq+hC;gW[#gW+1]=cc(cd,ce+hI,hF,cg)gW[#gW+1]=cc(cd,ce+hJ,hE,cg)fN=fN+1;hu=hu*10;if hE==hy then hv=hG else hv=0 end end;table.insert(gW,[[</g></g>]])end end;local function hK(eD)local hL=-math.deg(m(eD.y,eD.z))+180;hL=hL-90;if hL<0 then hL=360+hL end;if hL>180 then hL=-180+hL-180 end;return-hL end;local function hM(eD)local h9=math.deg(m(eD.y,eD.x))-90;if h9<-180 then h9=360+h9 end;return h9 end;local function hN(gW,eD,eA,centerX,centerY)if eA>5 and not ao or eA>O then local h5=circleRad;local hO=20;local hP=20;local hQ=hK(eD)local hR=hM(eD)local hS=14;local hT=hS/2;local hU=-hR/hP*h5;local hV=hQ/hO*h5;local cd=centerX+hU;local ce=centerY+hV;local ah=w(hU^2+hV^2)local hW=[[<circle
                            cx="]]..cd..[["
                            cy="]]..ce..[["
                            r="]]..hT/hS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cd..[["
                            cy="]]..ce..[["
                            r="]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cd-hS..[[,]]..ce..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cd+hT..[[,]]..ce..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cd..[[,]]..ce-hS..[[ v ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<h5 then gW[#gW+1]=hW else local gX=m(hV,hU)local hX=4;local hY=centerX+h5*math.cos(gX)local hZ=centerY+h5*math.sin(gX)gW[#gW+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gX*180/math.pi,hY,hZ,hY-hX,hZ-hX/2,hX*2,hX,hY+hX,hZ-hX,hX,hX,-hX,hX)end;if not ao then hQ=hK(-bp)hR=hM(-bp)hU=-hR/hP*h5;hV=hQ/hO*h5;cd=centerX+hU;ce=centerY+hV;ah=w(hU^2+hV^2)if ah<h5 then local h_=[[<circle
                                    cx="]]..cd..[["
                                    cy="]]..ce..[["
                                    r="]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cd..[[,]]..ce-hS..[[ v ]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cd..[[,]]..ce..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cd..[[,]]..ce..[[)" />
                                <path
                                    d="M ]]..cd-hT..[[,]]..ce..[[ h ]]..hS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cd..[[,]]..ce..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cd..[[,]]..ce..[[)"/>]]gW[#gW+1]=h_ end end end end;local function i0(gW,gn,i1,i2)i1=d(i1+0.5)local gL=throtPosY+10;local gM=throtPosY+20;if l()==1 and not RemoteHud then gL=55;gM=65 end;local i3="CRUISE"local unit="km/h"local cj=i2;if gn=="TRAVEL"or gn=="AUTOPILOT"then i3="THROT"unit="%"cj=i1;local i4="dim"if i1<0 then i4="red"end;gW[#gW+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i4,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i1),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gW[#gW+1]=cc(throtPosX+10,gL,i3,"pbright txtstart")gW[#gW+1]=cc(throtPosX+10,gM,e("%.0f %s",cj,unit),"pbright txtstart")if ao and AtmoSpeedAssist and by and K then i1=d(L*100+0.5)local i4="red"if i1<0 then i4="red"end;gW[#gW+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i4,1-c(i1),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gW[#gW+1]=cc(throtPosX+10,gL+40,"LIMIT","pbright txtstart")gW[#gW+1]=cc(throtPosX+10,gM+40,i1 .."%","pbright txtstart")end;if ao and AtmoSpeedAssist or Reentry then gW[#gW+1]=cc(throtPosX+10,gL-40,"LIMIT: "..b6 .." km/h","dim txtstart")elseif not ao and Autopilot then gW[#gW+1]=cc(throtPosX+10,gL-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i5(gW,i6)local i7=throtPosY-10;local i8=throtPosX+10;gW[#gW+1]=cc(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then i7=75 end;gW[#gW+1]=cc(i8,i7,d(i6).." km/h","pbright txtbig txtstart")end;local function i9(gW)gW[#gW+1]=cc(gj(1900),gk(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gW[#gW+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gW[#gW+1]=cc(gj(960),gk(550),"Warning: Invalid Control Scheme Detected","warnings")gW[#gW+1]=cc(gj(960),gk(600),"Keyboard Scheme must be selected","warnings")gW[#gW+1]=cc(gj(960),gk(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ia=gj(960)local ib=gk(860)local ic=gk(880)local id=gk(900)local ie=gk(960)local ig=gk(200)local ih=gk(250)local ii=gk(960)if l()==1 and not RemoteHud then ib=gk(135)ic=gk(155)id=gk(175)ig=gk(115)ih=gk(95)end;if BrakeIsOn then gW[#gW+1]=cc(ia,ib,"Brake Engaged","warnings")elseif J>0 then gW[#gW+1]=cc(ia,ib,"Auto-Brake Engaged","warnings","opacity:"..J)end;if ao and b1 and am==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bw and not VertTakeOff and not AutoTakeoff then gW[#gW+1]=cc(ia,ig+50,"** STALL WARNING **","warnings")b_("stall","SW",2)end end;if bH then gW[#gW+1]=cc(ia,ig+90,"Flight Assist in Progress","warnings")end;if av then gW[#gW+1]=cc(ia,ii,"Gyro Enabled","warnings")end;if GearExtended then if Q then gW[#gW+1]=cc(ia,ic,"Gear Extended","warn")else gW[#gW+1]=cc(ia,ic,"Landed (G: Takeoff)","warnings")end;local ij=cp(a:getTargetGroundAltitude())gW[#gW+1]=cc(ia,id,"Hover Height: "..ij,"warn")end;if a5 then gW[#gW+1]=cc(ia,ie+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bw and AntigravTargetAltitude~=nil then if c(aq-antigrav.getBaseAltitude())<501 then gW[#gW+1]=cc(ia,ig+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gW[#gW+1]=cc(ia,ig+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gW[#gW+1]=cc(ia,ig+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gW[#gW+1]=cc(ia,ig+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Y then gW[#gW+1]=cc(ia,ig+20,"Follow Mode Engaged","warn")elseif Reentry then gW[#gW+1]=cc(ia,ig+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ij=cp(HoldAltitude,2)if VertTakeOff then if bw then ij=cp(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gW[#gW+1]=cc(ia,ig,"VTO to "..ij,"warn")elseif AutoTakeoff and not IntoOrbit then if ak then gW[#gW+1]=cc(ia,ig,"Takeoff to "..AutopilotTargetName,"warn")else gW[#gW+1]=cc(ia,ig,"Takeoff to "..ij,"warn")end;if BrakeIsOn and not VertTakeOff then gW[#gW+1]=cc(ia,ig+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gW[#gW+1]=cc(ia,ig,"Altitude Hold: "..ij,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ap>0.1 then gW[#gW+1]=cc(ia,ig+20,"Beginning ascent","warn")elseif ap<0.09 and ap>0.05 then gW[#gW+1]=cc(ia,ig+20,"Aligning trajectory","warn")elseif ap<0.05 then gW[#gW+1]=cc(ia,ig+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b8~=nil then gW[#gW+1]=cc(ia,ig,b8,"warn")end end;if IntruderAlertSystem and safeMass==-1 then gW[#gW+1]=cc(ia,ig+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bu.."kg DETECTED","warnings")b_("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then gW[#gW+1]=cc(ia,ig,"Brake-Landing","warnings")else gW[#gW+1]=cc(ia,ig,"Coast-Landing","warnings")end end;if ProgradeIsOn then gW[#gW+1]=cc(ia,ig,"Prograde Alignment","crit")end;if RetrogradeIsOn then gW[#gW+1]=cc(ia,ig,"Retrograde Alignment","crit")end;if bK then local type;if string.find(bK,"COLLISION")then type="warnings"else type="crit"end;gW[#gW+1]=cc(ia,ih+20,bK,type)elseif ap==0 then local bV,bZ=bT(bp:normalize())if bZ~=nil then local ij=cp(bZ)local travelTime=aR.computeTravelTime(bq,0,bZ)local ik="Collision"if bV.noAtmosphericDensityAltitude>0 then ik="Atmosphere"end;gW[#gW+1]=cc(ia,ih+20,bV.name.." "..ik.." "..cA(travelTime).." In "..ij,"crit")end end;if VectorToTarget and not IntoOrbit then gW[#gW+1]=cc(ia,ig+35,VectorStatus,"warn")end;gW[#gW+1]="</g>"return gW end;local function il(eA)return d(y(eA*3.6,0)+0.5).." km/h"end;local function im(gW)local io=OrbitMapX;local ip=OrbitMapY;local iq=OrbitMapSize;local ir=4;local is=15;local cd=0;local ce=0;local it,iu,iv,iw;local function ix(type)local iy,B,eA,iz;if type=="Periapsis"then iy=orbit.periapsis.altitude;B=orbit.timeToPeriapsis;eA=orbit.periapsis.speed;iz=35 else iy=orbit.apoapsis.altitude;B=orbit.timeToApoapsis;eA=orbit.apoapsis.speed;iz=-35 end;gW[#gW+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cd+iz,ce-5,io+iq/2-it+iw,ce-5)gW[#gW+1]=cc(cd,ce,type)ce=ce+is;local ij=cp(iy)gW[#gW+1]=cc(cd,ce,ij)ce=ce+is;gW[#gW+1]=cc(cd,ce,cA(B))ce=ce+is;gW[#gW+1]=cc(cd,ce,il(eA))end;if orbit~=nil and ap<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then ip=ip+ir;cd=io+iq+io/2+ir;ce=ip+iq/2+5+ir;it=iq/4;iw=0;gW[#gW+1]=[[<g class="pbright txtorb txtmid">]]gW[#gW+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',iq+io*2,iq+ip,ir,ir)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iv=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(it*2)iu=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iv*(1-orbit.eccentricity)iw=it-orbit.periapsis.altitude/iv-planet.radius/iv;local iA=""if orbit.periapsis.altitude<=0 then iA='redout'end;gW[#gW+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iA,io+iq/2+iw+ir,ip+iq/2+ir,it,iu)gW[#gW+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',io+iq/2+ir,ip+iq/2+ir,planet.radius/iv)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then ix("Apoapsis")end;ce=ip+iq/2+5+ir;cd=io-io/2+10+ir;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then ix("Periapsis")end;gW[#gW+1]=cc(io+iq/2+ir,planet.name,20+ir,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iB=orbit.timeToApoapsis/orbit.period*2*math.pi;local iC=it*math.cos(iB)local iD=iu*math.sin(iB)gW[#gW+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',io+iq/2+iC+iw+ir,ip+iq/2+iD+ir)end;gW[#gW+1]=[[</g>]]return gW else return gW end end;local function iE(gW)local cd=30;local ce=275;local iF={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iG={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iH={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iI={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ao then c2(iF,iG)table.insert(iF,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if am~=-1 then if antigrav then if bw then table.insert(iF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iF,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iF,"Alt-6: Begins Vertical Takeoff.")else table.insert(iF,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iF,"G: Begin BrakeLanding or Land")end else c2(iF,iH)end;if AltitudeHold then table.insert(iF,"Alt-Spacebar/Alt-C will raise/lower target height")end;c2(iF,iI)for i=1,#iF do ce=ce+12;gW[#gW+1]=cc(cd,ce,iF[i],"pdim txttick txtstart")end end;local function iJ(iK,iL)local iM;local iN=(iL-iK):normalize()local eF=(bt-iK):dot(iN)/iN:dot(iN)if eF<=0.then return(bt-iK):len()elseif eF>=(iL-iK):len()then return(bt-iL):len()end;local iO=iK+eF*iN;iM=(iO-bt):len()return iM end;local function iP()local iM;local iQ=nil;local iR=nil;local iS=nil;for cJ,iT in pairs(aL[0])do if iT.hasAtmosphere then local ah=iJ(planet.center,iT.center)if iQ==nil or ah<iQ then iR=iT;iQ=ah;iS=planet end;if aa and aa.hasAtmosphere and aa.name~=planet.name then local d_=iJ(aa.center,iT.center)if d_<iQ then iR=iT;iQ=d_;iS=aa end end end end;local iU=gj(1770)local iV=gk(330)if iQ then local iW="txttick "local iX=500000;if iQ<iR.radius+iX or iQ<iS.radius+iX then if bF then iW="txttick red "else iW="txttick orange "end end;iM=cp(iQ,2)bG=cc(iU,iV,"Pipe ("..iS.name.."--"..iR.name.."): "..iM,iW.."pbright txtmid")end end;local iY={}function iY.HUDPrologue(gW)bF,ga=gh(bt)if not bF then F=PvPR;H=PvPG;G=PvPB else F=SafeR;H=SafeG;G=SafeB end;aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]local iZ=aw;local i_=ax;local j0=aw;local j1=ax;if gl()and not brightHud then iZ=[[rgb(]]..d(F*0.4+0.5)..","..d(H*0.4+0.5)..","..d(G*0.3+0.5)..[[)]]i_=[[rgb(]]..d(F*0.3+0.5)..","..d(H*0.3+0.5)..","..d(G*0.2+0.5)..[[)]]end;gW[#gW+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],iZ,iZ,j0,j0,i_,i_,j1,j1,aE,aF)return gW end;function iY.DrawVerticalSpeed(gW,dj)gV(gW,dj)end;function iY.UpdateHud(gW)local hL=bz;local j2=bA;local h3=j2;local hi=hL;local i1=d(unit.getThrottle())local i6=bq*3.6;local i2=unit.getAxisCommandValue(0)local j3=gj(1770)local j4=gk(310)if AtmoSpeedAssist and by then i2=I;i1=I*100 end;local gn=gm()local h4="ROLL"if i1==nil then i1=0 end;if not bJ then if bq>5 then hL=hK(bp)j2=hM(bp)else hL=0;j2=0 end;h4="YAW"end;if ga>50000 and not ao then local j5;j5=cp(ga)gW[#gW+1]=cc(j3,j4,"PvP Boundary: "..j5,"pbright txtbig txtmid")end;gW[#gW+1]=ai;gW[#gW+1]=aB;gW[#gW+1]=go;if bG~=""then gW[#gW+1]=bG end;if gp~=""then gW[#gW+1]=gp end;gV(gW,aq)if l()==0 or RemoteHud then if not gl()or brightHud then if bJ then h2(gW,centerX,centerY,h3,h4,bJ)hh(gW,hi,h3,centerX,centerY,bJ,d(hM(bp)),bq)else h2(gW,centerX,centerY,j2,h4,bJ)hh(gW,hL,j2,centerX,centerY,bJ,d(j2),bq)end;ho(gW,aq,bJ)hN(gW,bp,bq,centerX,centerY)end end;i0(gW,gn,i1,i2)i5(gW,i6)i9(gW)im(gW)if showHelp then iE(gW)end;return gW end;function iY.HUDEpilogue(gW)gW[#gW+1]="</svg>"return gW end;function iY.ExtraData(gW)local j6=gj(1240)local j7=gk(55)local j8=j7+10;local j9;local ja=0;local gn=gm()if VertTakeOffEngine then gn=gn.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bq>20 then gn=gn.."-COLLISION ON"end;if TurnBurn then gn="TB-"..gn end;if not stablized then gn=gn.."-DeCoupled"end;local jb=vec3(core.getWorldAcceleration()):len()/9.80665;j9=core.g()gW[#gW+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j6=gj(1120)j7=gk(55)j8=j7+10 elseif ao then local jc=gj(770)gW[#gW+1]=cc(jc,j7,"ATMOSPHERE","pdim txt txtend")gW[#gW+1]=cc(jc,j8,e("%.2f",ap),"pdim txt txtend","")end;gW[#gW+1]=cc(j6,j7,"GRAVITY","pdim txt txtend")gW[#gW+1]=cc(j6,j8,e("%.2f",j9/9.80665),"pdim txt txtend")gW[#gW+1]=cc(j6,j7+20,"ACCEL","pdim txt txtend")gW[#gW+1]=cc(j6,j8+20,e("%.2f",jb),"pdim txt txtend")gW[#gW+1]=cc(gj(960),gk(180),gn,"txtbig txtmid")end;function iY.DrawOdometer(gW,ab,TotalDistanceTravelled,ac)local j9;local jd=0;local je=0;local ja=0;if ao then ja=LastMaxBrakeInAtmo else ja=LastMaxBrake end;maxThrust=a:maxForceForward()j9=core.g()if j9>0.1 then je=at*j9;jd=maxThrust/j9 end;gW[#gW+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gj(660),gj(700),gk(35),gj(960),gk(55),gj(1240),gk(35),gj(1280))if l()==0 or RemoteHud then gW[#gW+1]=cc(gj(700),gk(20),e("Trip: %.2f km",ab),"txtstart")gW[#gW+1]=cc(gj(700),gk(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gW[#gW+1]=cc(gj(830),gk(20),"Trip Time: "..cA(ac),"txtstart")gW[#gW+1]=cc(gj(830),gk(30),"Total Time: "..cA(TotalFlightTime),"txtstart")gW[#gW+1]=cc(gj(970),gk(20),e("Mass: %.2f Tons",at/1000),"txtstart")gW[#gW+1]=cc(gj(1240),gk(10),e("Max Brake: %.2f kN",ja/1000),"txtend")gW[#gW+1]=cc(gj(1240),gk(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if j9>0.1 then gW[#gW+1]=cc(gj(970),gk(30),e("Max Mass: %.2f Tons",jd/1000),"txtstart")gW[#gW+1]=cc(gj(1240),gk(20),e("Req Thrust: %.2f kN",je/1000),"txtend")else gW[#gW+1]=cc(gj(970),gk(30),"Max Mass: n/a","txtstart")gW[#gW+1]=cc(gj(1240),gk(20),"Req Thrust: n/a","txtend")end end;gW[#gW+1]="</g>"return gW end;function iY.DrawWarnings(gW)return i9(gW)end;function iY.DisplayOrbitScreen(gW)return im(gW)end;function iY.DisplayMessage(gW,ij)if ij~="empty"then local ce=310;for jf in string.gmatch(ij,"([^\n]+)")do ce=ce+35;gW[#gW+1]=cc("50%",ce,jf,"msg")end end;if ag~=0 then unit.setTimer("msgTick",ag)ag=0 end end;function iY.DrawDeadZone(gW)gW[#gW+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iY.UpdatePipe()if ao then bG=""return end;iP()end;function iY.DrawSettings(gW)if#bC>0 then local cd=gj(640)local ce=gk(200)gW[#gW+1]=[[<g class="pbright txtvspd txtstart">]]for cJ,bO in pairs(bC)do gW[#gW+1]=cc(cd,ce,bO..": ".._G[bO])ce=ce+20;if cJ%12==0 then cd=cd+gj(350)ce=gk(200)end end;gW[#gW+1]=cc(gj(640),gk(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gW[#gW+1]="</g>"end;return gW end;local jg;local jh=gj(1770)local ji=gk(350)local jj=gk(15)local jk=gj(1370)local jl,jm;local jn=0;function iY.DrawRadarInfo()local function jo()if radarPanelID~=nil and jn==0 then r(radarPanelID)radarPanelID=nil;if jg~=nil then r(jg)jg=nil end else if jn==1 then r(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jg=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jn=0 end end;local f5,f6,f4,f7,f8,f1=aX.GetRadarHud()if f4>0 then if CollisionSystem then jl=f7 .."/"..f8 .." Plotted : "..f4-f8 .." Ignored"else jl="Radar Contacts: "..f4 end;go=cc(jh,ji,jl,"pbright txtbig txtmid")if#f1>0 then go=go..cc(jk,jj,"Friendlies In Range","pbright txtbig txtmid")for cJ,bO in pairs(f1)do jj=jj+20;go=go..cc(jk,jj,radar_1.getConstructName(bO),"pdim txtmid")end;f1={}end;if f5==nil and jg==nil then jn=1;jo()end;if f5~=nil and jg~=nil then jo()end;if radarPanelID==nil then jo()end else if f6 then go=cc(jh,ji,"Radar: Jammed","pbright txtbig txtmid")else go=cc(jh,ji,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jn=0;jo()end end end;function iY.DrawTanks()if fuelX~=0 and fuelY~=0 then gp=cc(fuelX,fuelY,"","txtstart pdim txtfuel")gF(fuelX,"Atmospheric ","ATMO",aG,gD,gE)gF(fuelX+120,"Space fuel t","SPACE",aH,gB,gC)gF(fuelX+240,"Rocket fuel ","ROCKET",aI,gz,gA)end end;return iY end;local function jp()local function jq(position)local de=sys:closestBody(position)if(position-de.center):len()>de.radius+de.noAtmosphericDensityAltitude then de=aL[0][0]end;return de end;local function jr()local function js(jt,ju)return jt.name<ju.name end;bE={}for cJ,bO in pairs(aL[0])do bE[#bE+1]={name=bO.name,index=cJ}end;table.sort(bE,js)end;local function jv(jw)for cJ,bO in pairs(jw)do if bO.name and bO.name==CustomTarget.name then return cJ end end;return-1 end;local function jx()if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local jy=bE[AutopilotTargetIndex].index;local jz=aL[0][jy]if jz.center then AutopilotTargetName=jz.name;aa=aQ[0][jy]if CustomTarget~=nil then if ap==0 then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end;if s(widgetTargetOrbitText,widgetTargetOrbit)~=1 then t(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jz;for _,bO in pairs(aQ[0])do if bO.name==CustomTarget.planetname then aa=bO;AutopilotTargetName=CustomTarget.name;break end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aT(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jA(g_)if not Autopilot and not VectorToTarget and not ak and not IntoOrbit then if g_==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bE then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bE end end;if AutopilotTargetIndex==0 then jx()else local jy=bE[AutopilotTargetIndex].index;local jz=aL[0][jy]if jz.name=="Space"or iphCondition=="Custom Only"and jz.center or iphCondition=="No Moons"and string.find(jz.name,"Moon")~=nil then if g_==nil then jA()else jA(1)end else jx()end end else a0="Disengage autopilot before changing Interplanetary Helper"b_("iph","AP")end end;local function jB()local fN=-1;fN=jv(aL[0])if fN>-1 then table.remove(aL[0],fN)end;fN=-1;fN=jv(SavedLocations)if fN~=-1 then a0=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fN)end;jA()jr()end;local function jC(bM,position,hH,jD)if dbHud_1 or hH then local de=jq(position)local j9=de.gravity;local jE=de.atmosphericDensityAboveSurface;if jD then jE=ap;j9=unit.getClosestPlanetInfluence()end;local jF={position=position,name=bM,atmosphere=jE,planetname=de.name,gravity=j9,safe=jD}if not hH then SavedLocations[#SavedLocations+1]=jF else for cJ,bO in pairs(aL[0])do if bO.name and bM==bO.name then table.remove(aL[0],cJ)end end end;table.insert(aL[0],jF)jr()jx()a0="Location saved as "..bM.."("..de.name..")"else a0="Databank must be installed to save permanent locations"end end;local cK={}function cK.UpdateAtlasLocationsList()jr()end;function cK.UpdateAutopilotTarget()jx()end;function cK.adjustAutopilotTargetIndex(g_)jA(g_)end;function cK.findAtlasIndex(jw)jv(jw)end;function cK.UpdatePosition(jG)local fN=jv(SavedLocations)if fN~=-1 then if jG~=nil then SavedLocations[fN].name=jG else local jH=SavedLocations[fN]jB()jC(jH.name,bt,false,true)end;a0=SavedLocations[fN].name.." position updated ("..SavedLocations[fN].planetname..")"else a0="Name Not Found"end end;function cK.AddNewLocation(bM,position,hH,jD)jC(bM,position,hH,jD)end;function cK.ClearCurrentPosition()jB()end;for cJ,bO in pairs(SavedLocations)do table.insert(aL[0],bO)end;jr()cK.UpdateAutopilotTarget()return cK end;local function jI()local jJ={}local function jK(eA)local jL=AutopilotEndSpeed;if not Autopilot then jL=0 end;if not ao then return aR.computeDistanceAndTime(eA,jL,at,0,0,LastMaxBrake-AutopilotPlanetGravity*at)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aR.computeDistanceAndTime(eA,jL,at,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*at)else return 0,0 end end end;local function jM(eA)local jL=AutopilotEndSpeed;if not Autopilot then jL=0 end;return aR.computeDistanceAndTime(eA,jL,at,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*at)end;local jN=false;function jJ.GetAutopilotBrakeDistanceAndTime(eA)return jK(eA)end;function jJ.GetAutopilotTBBrakeDistanceAndTime(eA)return jM(eA)end;local function jO(jP,jQ,jR)jQ=jQ:project_on_plane(jP)jR=jR:project_on_plane(jP)return m(jQ:cross(jR):dot(jP),jQ:dot(jR))end;local function jS()local function jT()local jU=-1;local jV=-1;if vBooster then jU=vBooster.distance()end;if hover then jV=hover.distance()end;if jU~=-1 and jV~=-1 then if jU<jV then return jU else return jV end elseif jU~=-1 then return jU elseif jV~=-1 then return jV else return-1 end end;local jW=jT()local jX=-1;if telemeter_1 then jX=telemeter_1.getDistance()end;if jW~=-1 and jX~=-1 then if jW<jX then return jW else return jX end elseif jW~=-1 then return jW else return jX end end;local function jY(planet,dW,jZ)local function j_(k0,dc)local e1=vec3(dc)if k0.bodyId==0 then return setmetatable({latitude=e1.x,longitude=e1.y,altitude=e1.z,bodyId=0,systemId=k0.planetarySystemId},MapPosition)end;local e2=e1-k0.center;local ah=e2:len()local dj=ah-k0.radius;local dh=0;local di=0;if not cm(ah,0)then local e3=m(e2.y,e2.x)di=e3>=0 and e3 or 2*math.pi+e3;dh=math.pi/2-math.acos(e2.z/ah)end;return setmetatable({latitude=math.deg(dh),longitude=math.deg(di),altitude=dj,bodyId=k0.bodyId,systemId=k0.planetarySystemId},MapPosition)end;local k1=j_(planet,dW)k1="::pos{"..k1.systemId..","..k1.bodyId..","..k1.latitude..","..k1.longitude..","..k1.altitude.."}"if jZ then return k1 else system.setWaypoint(k1)return true end end;local k2=false;function jJ.showWayPoint(planet,dW,jZ)return jY(planet,dW,jZ)end;function jJ.APTick()local function k3()if bL and not BrakeLanding then local bY=bL[1]local g1,g2=bL[2],bL[3]local k4=math.min(g1,g2 or g1)local k5=k4/bq;local k6=AutoTakeoff and(bq<42 or am~=-1)local k7=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if k7 and not k6 and(a6*1.5>k4 or k5<1)then BrakeIsOn=true;ci(0)if AltitudeHold then cu()end;if LockPitch then ToggleLockPitch()end;a0="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cv()end;StrongBrakes=true;BrakeLanding=true;a_=true end;if k5<11 then bK=bY.name.." COLLISION "..cA(k5).." / "..cp(k4,2)else bK=bY.name.." collision "..cA(k5)end;if k5<6 then b_("alarm","AL",2)end else bK=false end end;local function k8(bU,k9,ka)local function kb(bU,dI)bU=vec3(bU)dI=vec3(dI):normalize()local cZ=bU*dI;return cZ.x+cZ.y+cZ.z end;local kc=0.001;local kd=1;if not ao or not b1 or am~=-1 or bq<O then if ka==nil then ka=DampingMultiplier end;if k9==nil then k9=kc end;bU=vec3(bU):normalize()local ke=vec3()-bU;local kf=-kb(ke,core.getConstructWorldOrientationRight())*kd;local kg=-kb(ke,core.getConstructWorldOrientationUp())*kd;if az==0 then az=kf/2 end;if aA==0 then aA=kg/2 end;if c(kf)<0.1 then T=T-kf*2 else T=T-(kf+(kf-az)*ka)end;if c(kg)<0.1 then S=S+kg*2 else S=S+kg+(kg-aA)*ka end;az=kf;aA=kg;if c(kf)<k9 and c(kg)<k9 then return true end;return false elseif b1 and am==-1 then bU=bp;if ka==nil then ka=DampingMultiplier end;if k9==nil then k9=kc end;bU=vec3(bU):normalize()local ke=bn-bU;local kf=-kb(ke,core.getConstructWorldOrientationRight())*kd;local kg=-kb(ke,core.getConstructWorldOrientationUp())*kd;if az==0 then az=kf/2 end;if aA==0 then aA=kg/2 end;if c(kf)<0.1 then T=T-kf*5 else T=T-(kf+(kf-az)*ka)end;if c(kg)<0.1 then S=S+kg*5 else S=S+kg+(kg-aA)*ka end;az=kf;aA=kg;if c(kf)<k9 and c(kg)<k9 then return true end;return false end end;ao=j()>0;ap=j()aq=core.getAltitude()am=jS()B=o()b2=B;bJ=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k3()end;if antigrav then bw=antigrav.getState()==1 end;local kh=1;local ki=1;local kj=B-b2;local kk=-math.deg(jO(bm,bp,bn))local kl=math.deg(jO(bo,bp,bn))local g_=br*-1;b1=ao and kk<-YawStallAngle or kk>YawStallAngle or kl<-PitchStallAngle or kl>PitchStallAngle;local km=system.getMouseDeltaX()local kn=system.getMouseDeltaY()if InvertMouse and not Z then kn=-kn end;T=0;X=0;S=0;sys=aQ[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aT(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bp)if aq==0 then aq=(bt-planet.center):len()-planet.radius end;local j9=planet:getGravity(core.getConstructWorldPos()):len()*at;b3=0;aS=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if v()==0 then if l()==1 and Z then if not aY then ae=ae+km;af=af+kn end else ae=0;af=0 end else ae=ae+km;af=af+kn;ah=w(ae*ae+af*af)if not Z and l()==0 then if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then T=T-(ae-DeadZone)*MouseXSensitivity elseif ae<0 and ae<DeadZone*-1 then T=T-(ae+DeadZone)*MouseXSensitivity else T=0 end;if af>0 and af>DeadZone then S=S-(af-DeadZone)*MouseYSensitivity elseif af<0 and af<DeadZone*-1 then S=S-(af+DeadZone)*MouseYSensitivity else S=0 end else ae=0;af=0;if userControlScheme=="mouse"then S=(-utils.smoothstep(kn,-100,100)+0.5)*2*kh;T=(-utils.smoothstep(km,-100,100)+0.5)*2*ki end end end end;local ko=bq>8334;if bq>SpaceSpeedLimit/3.6 and not ao and not Autopilot and not ko then a0="Space Speed Engine Shutoff reached"ci(0)end;if not ko and LastIsWarping then if not BrakeIsOn then cx()end;if Autopilot then cv()end end;LastIsWarping=ko;if ao and ap>0.09 then if bq>b6/3.6 and not AtmoSpeedAssist and not jN then BrakeIsOn=true;jN=true elseif not AtmoSpeedAssist and jN then if bq<b6/3.6 then BrakeIsOn=false;jN=false end end end;if BrakeIsOn then W=1 else W=0 end;if ProgradeIsOn then if aj then BrakeIsOn=false;local kp=false;if CustomTarget~=nil then kp=k8(CustomTarget.position-bt,0.1)else kp=k8(vec3(bp),0.01)end;a_=true;if kp then cl(d(b6))if(c(bA)<2 or c(bz)>85)and bq>=b6/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;P=true;aj=false;al=true;Autopilot=false;cy()end elseif ao and AtmoSpeedAssist then ci(1)end elseif bq>O then k8(vec3(bp),0.01)end end;if RetrogradeIsOn then if ao then RetrogradeIsOn=false elseif bq>O then k8(-vec3(bp))end end;if not ProgradeIsOn and aj and not IntoOrbit then if ap==0 then P=true;cy()aj=false;al=true else aj=false;cv()end end;if al and CustomTarget~=nil and(aq<HoldAltitude+250 and aq>HoldAltitude-250)and bq*3.6>b6-250 and c(bs)<25 and ap>=0.1 and(CustomTarget.position-bt):len()>2000+aq then cv()al=false end;if VertTakeOff then a_=true;local kq=HoldAltitude;if bs<-30 then a0="Unable to achieve lift. Safety Landing."ad=0;a_=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bw or HoldAltitude<planet.spaceEngineMinAltitude then if bw then kq=antigrav.getBaseAltitude()end;if aq<kq-100 then b7=0;ad=15;BrakeIsOn=false elseif bs>0 then BrakeIsOn=true;ad=0 elseif bs<-30 then BrakeIsOn=true;ad=15 elseif aq>=kq then if bw then if Autopilot or VectorToTarget then cs()else BrakeIsOn=true;VertTakeOff=false end;a0="Takeoff complete. Singularity engaged"b_("aggLk","AG")else BrakeIsOn=false;a0="VTO complete. Engaging Horizontal Flight"b_("vtoc","VT")cs()end;ad=0 end else if ap>0.08 then b7=0;BrakeIsOn=false;ad=20 elseif ap<0.08 and ap>0 then BrakeIsOn=false;if bj then b7=0;ad=20 else ad=0;b7=36;cl(3500)end else a_=autoRollPreference;IntoOrbit=true;bh=false;CancelIntoOrbit=false;bb=false;b9=nil;ba=nil;if bg==nil then bg=planet end;bf=kq;be=true;VertTakeOff=false end end;if b7~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kr=p(b7-bz,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kr)local ks=p(vTpitchPID:get(),-1,1)S=ks end end;if IntoOrbit then local ke;local kt=false;local ku=cp(bf)if bg==nil then bg=planet;if VectorToTarget then bg=aa end end;if not be then bf=d(bg.radius+bg.surfaceMaxAltitude+LowOrbitHeight)if bg.hasAtmosphere then bf=d(bg.radius+bg.noAtmosphericDensityAltitude+LowOrbitHeight)end;be=true end;if bd.VectorToTarget then ke=CustomTarget.position-bt end;local kv,kw=aT(bg):escapeAndOrbitalSpeed((bt-bg.center):len()-bg.radius)local kx=bA;if not bb then local ky=false;local kz=false;ci(0)ba=0;b8="Aligning to orbital path - OrbitHeight: "..ku;if bd.VectorToTarget then k8(ke:normalize():project_on_plane(br))kt=bn:dot(ke:project_on_plane(bm):normalize())>0.95 else k8(bp)kt=kk<0.5;if bq<150 then kt=true end end;S=0;b9=0;if bz<=b9+1 and bz>=b9-1 then ky=true else ky=false end;if kx<=ba+1 and kx>=ba-1 then kz=true else kz=false end;if ky and kz and kt then b9=nil;ba=nil;bb=true end else if bd.VectorToTarget then k8(ke:normalize():project_on_plane(br))elseif bq>150 then k8(bp)end;S=0;if bd.VectorToTarget then local a6,_=aR.computeDistanceAndTime(bq,b6/3.6,at,0,0,LastMaxBrake)if bh and ke:len()>15000+a6+aq then b8="Orbiting to Target"if aq-100<=bg.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bg.noAtmosphericDensityAltitude then bh=false end elseif bh or ke:len()<15000+a6+aq then a0="Orbit complete, proceeding with reentry"b_("orCom","OB")AutopilotTargetCoords=CustomTarget.position;P=true;al=true;bd.VectorToTarget,bd.AutopilotAlign=false,false;ct()cy()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and aq>bf*0.9 and aq<bf*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bf*0.99 and orbit.apoapsis.altitude>=bf*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bh then if bh then BrakeIsOn=false;ci(0)b9=0;if not bd.VectorToTarget then a0="Orbit complete"b_("orCom","OB")ct()end else bl=bl+1;if bl>=2 then bh=true end end else b8="Adjusting Orbit - OrbitHeight: "..ku;bc=true;cl(kw*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kA=bs;local kB=aq-bf;local kC=c(kB)if bs<10 and c(bz)<10 and kC<100 then kA=bs*2 end;if kA<10 and c(bz)<10 and kC<100 then kA=kA*2 end;if kA<5 and c(bz)<5 and kC<100 then kA=kA*4 end;VSpdPID:inject(kA)b9=p(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kB)b9=p(b9-p(OrbitAltPID:get(),-15,15),-90,90)end end else local kD=2.75;local kE=c(y(kv*kD))local kF=kE%50;if kF>0 then kE=kE-kF+50 end;BrakeIsOn=false;if aq<bf*0.8 then b8="Escaping planet gravity - OrbitHeight: "..ku;b9=utils.map(bs,200,0,-15,80)elseif aq>=bf*0.8 and aq<bf*1.15 then b8="Approaching orbital corridor - OrbitHeight: "..ku;kE=kE*0.75;b9=utils.map(bs,100,-100,-15,65)elseif aq>=bf*1.15 and aq<bf*1.5 then b8="Approaching orbital corridor - OrbitHeight: "..ku;kE=kE*0.75;if bs<0 or bc then b9=utils.map(aq,bf*1.5,bf*1.01,-30,0)else b9=utils.map(aq,bf*0.99,bf*1.5,0,30)end elseif aq>bf*1.5 then b8="Reentering orbital corridor - OrbitHeight: "..ku;b9=-65;local kG=utils.map(bs,-150,-400,1,0.55)kE=kE*kG end;cl(d(kE))end end;if b9~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kH=b9-bz;OrbitPitchPID:inject(kH)local kI=p(OrbitPitchPID:get(),-0.5,0.5)S=kI end end;if Autopilot and ap==0 and not aj then local function kJ(jl,orbit)system.print(jl)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"ci(0)N=false;a0=jl;b_("apCom","AP")if orbit or aj then if orbit and AutopilotTargetOrbit~=nil and not aj then if not aq or aq==0 then return end;bf=aq;be=true end;ct()end end;local kK,kL=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kM=(CustomTarget.position-aa.center):normalize()local kN=kM:project_on_plane((aa.center-bt):normalize()):normalize()local kO=aa.center+kN*(aa.radius+AutopilotTargetOrbit)local kP=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bt-kO):len()<(bt-kP):len()then kK=kO else kK=kP;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kK;aW.showWayPoint(aa,AutopilotTargetCoords)kL=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kL=true;TargetSet=true;AutopilotRealigned=true;kK=CustomTarget.position+(bt-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kM=(bt+bp*100000-aa.center):normalize()local kN=kM:project_on_plane((aa.center-bt):normalize()):normalize()if kN:len()<1 then kM=(bt+bn*100000-aa.center):normalize()kN=kM:project_on_plane((aa.center-bt):normalize()):normalize()end;kK=aa.center+kN*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kK;TargetSet=true;kL=true;AutopilotRealigned=true;aW.showWayPoint(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kK)-bt):len()local bV,bW,bX=aQ:getPlanetarySystem(0):castIntersections(bt,bp:normalize(),function(bY)if bY.noAtmosphericDensityAltitude>0 then return bY.radius+bY.noAtmosphericDensityAltitude else return bY.radius+bY.surfaceMaxAltitude*1.5 end end)local bZ=bW;if bX~=nil and bW~=nil then bZ=math.min(bX,bW)end;if bZ~=nil and bZ<AutopilotDistance and bV.name==aa.name then AutopilotDistance=bZ end;local kp=true;local kQ=(aa.center-(bt+vec3(bp):normalize()*AutopilotDistance)):len()-aa.radius;local ij=cp(kQ)s(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ij..'"}')local a6,a7;if not TurnBurn then a6,a7=jK(bq)else a6,a7=jM(bq)end;if bq>300 and AutopilotAccelerating then local ke=vec3(kK)-bt;local kR=p(math.deg(jO(bm,bp:normalize(),ke:normalize()))*bq/500,-90,90)local kS=p(math.deg(jO(bo,bp:normalize(),ke:normalize()))*bq/500,-90,90)if c(kR)<20 and c(kS)<20 then kR=kR*2;kS=kS*2 end;if c(kR)<2 and c(kS)<2 then kR=kR*2;kS=kS*2 end;local kk=-math.deg(jO(bm,bn,bp:normalize()))local kl=-math.deg(jO(bo,bn,bp:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kS-kl)local kT=p(apPitchPID:get(),-1,1)S=S+kT;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kR-kk)local kU=p(apYawPID:get(),-1,1)T=T+kU;kL=true;if c(kR)>2 or c(kS)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"b_("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end end end;if kQ<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aT(aa):escapeAndOrbitalSpeed(kQ)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bV,bZ=bT((AutopilotTargetCoords-bt):normalize())if aa.name~=planet.name then if bV~=nil then a0="Collision with "..bV.name.." in "..cp(bZ).."\nClear LOS to continue."ag=5;k2=true else k2=false;a0=""end end end;if not k2 then if not AutopilotCruising and not AutopilotBraking and not kL then kp=k8((kK-bt):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kp=k8(-vec3(bp):normalize())end end;if AutopilotAccelerating then if not N then BrakeIsOn=false;ci(AutopilotInterplanetaryThrottle)I=y(AutopilotInterplanetaryThrottle,2)N=true end;local kV=unit.getThrottle()if AtmoSpeedAssist then kV=I end;if bp:len()>=MaxGameVelocity or kV==0 and N then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then b_("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;ci(0)end;if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then b_("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;ci(0)N=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;W=1 end;if TurnBurn then ci(1,true)end;local _,kw=aT(aa):escapeAndOrbitalSpeed((bt-planet.center):len()-planet.radius)local ke;if CustomTarget~=nil then ke=CustomTarget.position-bt end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bq<50 then kJ("Autopilot complete, arrived at space location")BrakeIsOn=true;W=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bq<=kw and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kJ("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;aW.showWayPoint(aa,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then b_("apCir","AP")AutopilotStatus="Circularizing"end;if bq<=kw then if CustomTarget~=nil then if bp:normalize():dot(ke:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then b_("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aW.showWayPoint(aa,CustomTarget.position)WaypointSet=true end else kJ("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;aW.showWayPoint(aa,CustomTarget.position)WaypointSet=false end else kJ("Autopilot completed, setting orbit",true)W=0 end end elseif AutopilotStatus=="Circularizing"then kJ("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then b_("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kV=unit.getThrottle()if AtmoSpeedAssist then kV=I end;if kV>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end;AutopilotCruising=false end else if kp then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not aj then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*bo;AutopilotShipUp=bm;AutopilotShipRight=bo end;AutopilotRealigned=true elseif kp and not k2 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end;if not N then ci(AutopilotInterplanetaryThrottle,true)I=y(AutopilotInterplanetaryThrottle,2)N=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ap>0)then a0="Autopilot complete, proceeding with reentry"b_("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"W=0;ci(0)N=false;ProgradeIsOn=true;aj=true;aW.showWayPoint(aa,CustomTarget.position)end;if Y then a_=true;local kS=0;local eE=bt+vec3(unit.getMasterPlayerRelativePosition())local kW=eE-bt;local kX=vec3(kW):project_on(bn):len()local kY=vec3(kW):project_on(bo):len()local ah=w(kX*kX+kY*kY)k8(kW:normalize())local kZ=40;local k_=ah<kZ;local l0=100;local l1=p((ah-kZ)/2,10,l0)S=0;local kp=c(T)<0.1;if kp and bq<l1 and not k_ then BrakeIsOn=false;kS=-20 else BrakeIsOn=true;kS=0 end;local l2=0;if c(kS-bz)>l2 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kS-bz)local kT=pitchPID:get()S=kT end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l3=LastMaxBrakeInAtmo;if l3 then l3=l3*p(bq/100,0.1,1)*ap else l3=LastMaxBrake end;if ap<0.01 then l3=LastMaxBrake end;local l4=vec3(core.getWorldAirFrictionAcceleration())local l5=w(l4:len()-l4:project_on(g_):len())*at;if bq>100 then a6,a7=aR.computeDistanceAndTime(bq,100,at,0,0,l3+l5)local l6,l7=aR.computeDistanceAndTime(100,0,at,0,0,l3/2)a6=a6+l6 else a6,a7=aR.computeDistanceAndTime(bq,0,at,0,0,l3/2)end;local l8=HoldAltitude-aq;local l9=500+bq;local la=1;if AutoTakeoff then la=p(bq/100,0.1,1)end;local kS=(utils.smoothstep(l8,-l9,l9)-0.5)*2*MaxPitch*la;if not Reentry and not aj and not VectorToTarget and bn:dot(bp:normalize())<0.99 then kS=(utils.smoothstep(l8,-l9*p(20-19*ap*10,1,20),l9*p(20-19*ap*10,1,20))-0.5)*2*MaxPitch*p(2-ap*10,1,2)*la end;if not AltitudeHold then kS=0 end;if LockPitch~=nil then if bJ and not IntoOrbit then kS=LockPitch else LockPitch=nil end end;a_=true;local lb=S;if Reentry then local lc=d(b6)local ld,le=aR.computeDistanceAndTime(bq,lc/3.6,at,0,0,LastMaxBrake-planet.gravity*9.8*at)local lf=aq-(planet.noAtmosphericDensityAltitude+5000)if not by and aq>planet.noAtmosphericDensityAltitude+5000 and bq<=lc/3.6 and bq>lc/3.6-10 and c(bp:normalize():dot(bn))>0.9 then ci(0)elseif by and bq>lc/3.6 and(ld>-1 and lf<=ld or aq<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cl(lc,true)if not P then kS=-80;if ap>0.02 then a0="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kS=0;a_=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and aq>planet.noAtmosphericDensityAltitude+5000 then a_=true elseif aq<=planet.noAtmosphericDensityAltitude+5000 then cl(lc)if not by and q:getTargetSpeed(axisCommandId.longitudinal)==b6 then P=false;Reentry=false;a_=true end end end;if bq>O and not ak and not VectorToTarget and not BrakeLanding and ForceAlignment then k8(vec3(bp))end;if bH or(VectorToTarget or ak)and AutopilotTargetIndex>0 and ap>0.01 then local ke;if bH then if type(bH)=="table"then ke=bH elseif bH<3 and bH>0 then ke=-br:cross(bp)*5000 elseif bH>=3 then ke=br:cross(bp)*5000 elseif bH<0 then ke=bp*25000 end elseif CustomTarget~=nil then ke=CustomTarget.position-bt else ke=aa.center-bt end;local kR=math.deg(jO(br:normalize(),bp,ke))*2;local lg=math.rad(c(bA))if bq>minRollVelocity and ap>0.01 then local lh=p(90-kS*2,-90,90)b3=p(kR*2,-lh,lh)local li=kR;kR=p(p(kR,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lg)+4*(bz-kS)*math.sin(math.rad(bA)),-YawStallAngle*0.80,YawStallAngle*0.80)kS=p(p(kS*math.cos(lg),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(p(c(li)*math.sin(lg),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b3=0;kR=p(kR,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lj=kk-kR;if bH and c(lj)<=0.0001 and(type(bH)=="table"or type(bH)~="table"and bH<0 and c(bA)<1)then if bH==-2 then cu()end;bH=nil;b_("180Off","BR")return end;if not b1 and bq>minRollVelocity and ap>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lj)local kU=p(yawPID:get(),-1,1)T=T+kU elseif ao and am>-1 or bq<minRollVelocity then k8(ke)elseif b1 and ap>0.01 then if(kk<-YawStallAngle or kk>YawStallAngle)and ap>0.01 then k8(bp)end;if(kl<-PitchStallAngle or kl>PitchStallAngle)and ap>0.01 then kS=p(bz-kl,bz-PitchStallAngle*0.80,bz+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ak then local kq=planet:getAltitude(CustomTarget.position)local lf=w(ke:len()^2-(aq-kq)^2)local lk=bp:len()-c(bs)StrongBrakes=true;if not ak and not Reentry and lf<=a6+bq*kj/2 and(bp:project_on_plane(br):normalize():dot(ke:project_on_plane(br):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"ci(0)if AltitudeHold then cu()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lk<0.1 or lf<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<lf)then if not bw then b_("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bK=false end;LastDistanceToTarget=lf end elseif VectorToTarget and ap==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ak or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local ke=CustomTarget.position-bt;local kq=planet:getAltitude(CustomTarget.position)local lf=w(ke:len()^2-(aq-kq)^2)local l3=LastMaxBrakeInAtmo;if l3 then a6,a7=aR.computeDistanceAndTime(bq,0,at,0,0,l3/2)StrongBrakes=true;if lf<=a6+bq*kj/2 and bp:project_on_plane(br):normalize():dot(ke:project_on_plane(br):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;P=true;aj=false;al=true;Autopilot=false;cy()end end;LastDistanceToTarget=lf end end end;if ap==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ak or IntoOrbit or Reentry)then if not bh and not IntoOrbit then bf=HoldAltitude;be=true;if VectorToTarget then bd.VectorToTarget=true end;ct()VectorToTarget=false;bb=true end end;if b1 and ap>0.01 and am==-1 and bq>minRollVelocity and VectorStatus~="Finalizing Approach"then k8(bp)kS=p(bz-kl,bz-PitchStallAngle*0.80,bz+PitchStallAngle*0.80)end;S=lb;local jX=-1;if BrakeLanding then kS=0;local ll=false;local lm=30;if aS~=nil and aS>0 then local ln=p(ap,0.4,2)local l3=LastMaxBrakeInAtmo*p(bq/100,0.1,1)*ln;local lo=aS*ln+l3-j9;local lp=l3/2-j9;local lq=bq-w(c(lp/2)*20/(0.5*at))*utils.sign(lp)if lq<0 then lq=0 end;local lr;if bq>100 then local ls,_=aR.computeDistanceAndTime(bq,100,at,0,0,l3)local lt,_=aR.computeDistanceAndTime(100,0,at,0,0,w(l3))lr=ls+lt else lr=aR.computeDistanceAndTime(bq,0,at,0,0,w(l3))end;if lr<20 then BrakeIsOn=false else local lu=0;if lq>100 then local lv,_=aR.computeDistanceAndTime(lq,100,at,0,0,lo)local lw,_=aR.computeDistanceAndTime(100,0,at,0,0,aS*ln+w(l3)-j9)lu=lv+lw else lu,_=aR.computeDistanceAndTime(lq,0,at,0,0,aS*ln+w(l3)-j9)end;lu=(lu+15+bq*kj)*1.1;local lx=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lx then local kq=planet:getAltitude(CustomTarget.position)local ly=aq-kq-100;local ke=CustomTarget.position-bt;local lz=w(ke:len()^2-(aq-kq)^2)if lz>100 then lx=false elseif ly<=lu or lu==-1 then BrakeIsOn=true;ll=true else BrakeIsOn=false;ll=true end end;if not lx and CalculateBrakeLandingSpeed then if lu>=lm then BrakeIsOn=true else BrakeIsOn=false end;ll=true end end end;if not by then ci(0)end;q:setTargetGroundAltitude(500)q:activateGroundEngineAltitudeStabilization(500)stablized=true;jX=am;if jX>-1 then a_=autoRollPreference;if bq<1 or bp:normalize():dot(br)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if Q then a.control.extendLandingGears()b_("grOut","LG",1)end;q:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bp:normalize():dot(-g_)<0.999 then BrakeIsOn=true elseif bs<-brakeLandingRate and not ll then BrakeIsOn=true elseif not ll then BrakeIsOn=false end end;if AutoTakeoff or ak then local bV,bX,bW;if AutopilotTargetCoords~=nil then bV,bX,bW=aQ:getPlanetarySystem(0):castIntersections(bt,(AutopilotTargetCoords-bt):normalize(),function(bY)return bY.radius+bY.noAtmosphericDensityAltitude end)end;if bw then if aq>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;ci(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kS)<15 and aq/HoldAltitude>0.75 then AutoTakeoff=false;if not ak then if by and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ak and bq<O then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;ci(0)elseif ak then ci(0)BrakeIsOn=true end elseif ak and ap==0 and aa~=nil and(bV==nil or bV.name==aa.name)then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;if not by then ci(0)end;AutopilotAccelerating=true end end;local lA=am>-1;local lB=bz;if(VectorToTarget or ak or bH)and not lA and bq>minRollVelocity and ap>0.01 then local lg=math.rad(c(bA))lB=bz*c(math.cos(lg))+kl*math.sin(lg)end;local lC=p(kS-lB,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ap<0.01 and VectorToTarget then lC=p(kS-lB,-85,MaxPitch)elseif ap<0.01 then lC=p(kS-lB,-MaxPitch,MaxPitch)end;if c(bA)<5 or VectorToTarget or bH or BrakeLanding or lA or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lC)local kT=pitchPID:get()S=S+kT end end;if antigrav~=nil and(antigrav and not ExternalAGG and aq<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;am=jS()return jJ end;function script.onStart()local lD={}local lE={}local lF=false;local function lG()local function lH(lI)local lJ=dbHud_1.hasKey;for cJ,bO in pairs(lI)do if lJ(bO)then local cZ=f(dbHud_1.getStringValue(bO))if cZ~=nil then _G[bO]=cZ;lF=true end end end end;if dbHud_1 then if not useTheseSettings then lH(c5())coroutine.yield()lH(b)else lH(b)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;lF=false end;coroutine.yield()if lF then a0="Loaded Saved Variables"aE=ResolutionX;aF=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)a_=autoRollPreference;b6=AtmoSpeedLimit;aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]elseif not useTheseSettings then a0="No Saved Variables Found - Exit HUD to save settings"end else a0="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<B then LastMaxBrakeInAtmo=0 end;LastStartTime=B;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=at end;VectorStatus="Proceeding to Waypoint"end;local function lK()local function lL(lM,lN)if lM>lN then lN=lM end;local lO,lP=0,0;if ContainerOptimization>0 then lO=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lP=FuelTankOptimization*0.05 end;lN=lN*(1-(lO+lP))return lN end;local lQ=core.getElementNameById;local lR=fuelX~=0 and fuelY~=0;for cJ in pairs(ar)do local type=core.getElementTypeById(ar[cJ])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(ar[cJ])),'^.*vertical.*$')then bv=true end end;if n(type,'^.*Space Engine$')then bk=true;if n(tostring(core.getElementTagsById(ar[cJ])),'^.*vertical.*$')then local lS=core.getElementRotationById(ar[cJ])if lS[4]<0 then if y(-lS[4],0.1)==0.5 then bi=true end else if y(lS[4],0.1)==0.5 then bj=true end end end end;if type=="Landing Gear"then Q=true end;if type=="Dynamic Core Unit"then local lT=h(ar[cJ])if lT>10000 then D=128;E=110 elseif lT>1000 then D=64;E=55 elseif lT>150 then D=32;E=27 end end;aJ=aJ+h(ar[cJ])if lR and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lT=h(ar[cJ])local lU=k(ar[cJ])local lM=0;local gP=o()if type=="Atmospheric Fuel Tank"then local lN=400;local lV=35.03;if lT>10000 then lN=51200;lV=5480 elseif lT>1300 then lN=6400;lV=988.67 elseif lT>150 then lN=1600;lV=182.67 end;lM=lU-lV;if fuelTankHandlingAtmo>0 then lN=lN+lN*fuelTankHandlingAtmo*0.2 end;lN=lL(lM,lN)aG[#aG+1]={ar[cJ],lQ(ar[cJ]),lN,lV,lM,gP}end;if type=="Rocket Fuel Tank"then local lN=320;local lV=173.42;if lT>65000 then lN=40000;lV=25740 elseif lT>6000 then lN=5120;lV=4720 elseif lT>700 then lN=640;lV=886.72 end;lM=lU-lV;if fuelTankHandlingRocket>0 then lN=lN+lN*fuelTankHandlingRocket*0.1 end;lN=lL(lM,lN)aI[#aI+1]={ar[cJ],lQ(ar[cJ]),lN,lV,lM,gP}end;if type=="Space Fuel Tank"then local lN=2400;local lV=182.67;if lT>10000 then lN=76800;lV=5480 elseif lT>1300 then lN=9600;lV=988.67 end;lM=lU-lV;if fuelTankHandlingSpace>0 then lN=lN+lN*fuelTankHandlingSpace*0.2 end;lN=lL(lM,lN)aH[#aH+1]={ar[cJ],lQ(ar[cJ]),lN,lV,lM,gP}end end end;if not bv then VertTakeOff,VertTakeOffEngine=false,false end end;local function lW()if gyro~=nil then av=gyro.getState()==1 end;if not stablized then q:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then u(1)else u(0)end;if door and(ao or not ao and aq<10000)then for _,bO in pairs(door)do bO.toggle()end end;if switch then for _,bO in pairs(switch)do bO.toggle()end end;if forcefield and(ao or not ao==0 and aq<10000)then for _,bO in pairs(forcefield)do bO.toggle()end end;if antigrav then bw=antigrav.getState()==1;if bw and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if Q then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if am~=-1 or not ao and bp:len()<50 then BrakeIsOn=true;GearExtended=true;if Q then a.control.extendLandingGears()end else BrakeIsOn=false end;q:setTargetGroundAltitude(b0)if ao and am~=-1 then aS=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ao end;local function lX(lY,lZ,l_,m0,cd,ce,m1,m2,m3,m4)local m5={enableName=lY,disableName=lZ,width=l_,height=m0,x=cd,y=ce,toggleVar=m1,toggleFunction=m2,drawCondition=m3,hovered=false}if m4 then table.insert(lE,m5)else table.insert(lD,m5)end;return m5 end;local function m6(m7)if not bB then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif m7=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif m7=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif m7=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bC=c5(m7)showHud=false else bC={}showHud=true end end;local function m8()bB=not bB;if bB then aD=lE;a0="Hold SHIFT to see Settings"bD=showHud else aD=lD;a0="Hold SHIFT to see Control Buttons"m6()showHud=bD end end;local function m9(bO)_G[bO]=not _G[bO]if _G[bO]then a0=bO.." set to true"else a0=bO.." set to false"end;if bO=="showHud"then bD=_G[bO]elseif bO=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif bO=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function ma()local mb=50;local mc=340;local cd=500;local ce=aF/2-400;local md=0;for cJ,bO in pairs(c5("boolean"))do if type(_G[bO])=="boolean"then lX(bO,bO,mc,mb,cd,ce,function()return _G[bO]end,function()m9(bO)end,function()return true end,true)ce=ce+mb+20;if md==9 then cd=cd+mc+20;ce=aF/2-400;md=0 else md=md+1 end end end;lX("Control View","Control View",mc,mb,10,aF/2-500,function()return true end,m8,function()return true end,true)lX("View Handling Settings",'Hide Handling Settings',mc,mb,10,aF/2-(500-mb),function()return showHandlingVariables end,function()m6("handling")end,function()return true end,true)lX("View Hud Settings",'Hide Hud Settings',mc,mb,10,aF/2-(500-mb*2),function()return showHudVariables end,function()m6("hud")end,function()return true end,true)lX("View Physics Settings",'Hide Physics Settings',mc,mb,10,aF/2-(500-mb*3),function()return showPhysicsVariables end,function()m6("physics")end,function()return true end,true)end;local function me()local function jC()local position=bt;local bM=planet.name..". "..#SavedLocations;if radar_1 then local ds,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if ds~=nil and ds~=""then bM=bM.." "..radar_1.getConstructName(ds)end end;return aV.AddNewLocation(bM,position,false,true)end;local function mf()TurnBurn=not TurnBurn end;local function mg(mh)if mh==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Y=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mi()mg(1)end;local function mj()aV.UpdatePosition()end;local function jB()aV.ClearCurrentPosition()end;local function mk()local bM=AutopilotTargetName;if bM==nil then local ij=cp((bt-CustomTarget.position):len())bM=CustomTarget.name.." "..ij end;if bM==nil then bM="None"end;return"Engage Autopilot: "..bM end;local function ml()local bM=AutopilotTargetName;if bM==nil then bM=CustomTarget.name end;if bM==nil then bM="None"end;return"Disable Autopilot: "..bM end;local function mm()if safeMass>0 then a0="Safe Mass set to "..y(at,2).." kg"else a0="Intruder Detection reset\nSafe Mass set to "..y(at,2).." kg"ag=5;bu=0 end;safeMass=at end;local function mn()if l()==1 then Y=not Y;if Y then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)b_("folOn","F")else b_("folOff","F")BrakeIsOn=true;a_=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()q:setTargetGroundAltitude(LandingGearGroundHeight)end end else a0="Follow Mode only works with Remote controller"Y=false end end;local mb=50;local mc=260;local mo=lX("Enable Brake Toggle","Disable Brake Toggle",mc,mb,aE/2-mc/2,aF/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a0="Brakes in Toggle Mode"else a0="Brakes in Default Mode"end end)lX("Align Prograde","Disable Prograde",mc,mb,aE/2-mc/2-50-mo.width,aF/2-mb+380,function()return ProgradeIsOn end,mi)lX("Align Retrograde","Disable Retrograde",mc,mb,aE/2-mc/2+mo.width+50,aF/2-mb+380,function()return RetrogradeIsOn end,mg,function()return ap==0 end)local mp=lX(mk,ml,600,60,aE/2-600/2,aF/2-60/2-400,function()return Autopilot end,cv)lX("Save Position","Save Position",200,mp.height,mp.x+mp.width+30,mp.y,function()return false end,jC,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lX("Update Position","Update Position",200,mp.height,mp.x+mp.width+30,mp.y,function()return false end,mj,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lX("Clear Position","Clear Position",200,mp.height,mp.x-200-30,mp.y,function()return true end,jB,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mb=60;mc=300;local cd=10;local ce=aF/2-500;lX("Show Help","Hide Help",mc,mb,cd,ce,function()return showHelp end,function()showHelp=not showHelp end)ce=ce+mb+20;lX("View Settings","View Settings",mc,mb,cd,ce,function()return true end,m8)local ce=aF/2-300;lX("Enable Turn and Burn","Disable Turn and Burn",mc,mb,cd,ce,function()return TurnBurn end,mf)lX("Horizontal Takeoff Mode","Vertical Takeoff Mode",mc,mb,cd+mc+20,ce,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a0="Vertical Takeoff Mode"else a0="Horizontal Takeoff Mode"end end,function()return bv end)ce=ce+mb+20;lX("Show Orbit Display","Hide Orbit Display",mc,mb,cd,ce,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a0="Orbit Display Enabled"else a0="Orbit Display Disabled"end end)lX("Engage Orbiting","Cancel Orbiting",mc,mb,cd+mc+20,ce,function()return IntoOrbit end,ct,function()return ap==0 and bJ end)ce=ce+mb+20;lX("Glide Re-Entry","Cancel Glide Re-Entry",mc,mb,cd,ce,function()return Reentry end,function()aj=true;mi()end,function()return planet.hasAtmosphere and not ao end)lX("Parachute Re-Entry","Cancel Parachute Re-Entry",mc,mb,cd+mc+20,ce,function()return Reentry end,cy,function()return planet.hasAtmosphere and not ao end)ce=ce+mb+20;lX("Engage Follow Mode","Disable Follow Mode",mc,mb,cd,ce,function()return Y end,mn,function()return l()==1 end)lX("Enable Repair Arrows","Disable Repair Arrows",mc,mb,cd+mc+20,ce,function()return aK end,function()aK=not aK;if aK then a0="Repair Arrows Enabled"else a0="Repair Arrows Diabled"end end,function()return l()==1 end)ce=ce+mb+20;if not ExternalAGG then lX("Enable AGG","Disable AGG",mc,mb,cd,ce,function()return bw end,cz,function()return antigrav~=nil end)end;lX("Reset Intruder Alert","Set Safe Mass",mc,mb,cd+mc+20,ce,function()return safeMass>0 end,mm,function()return IntruderAlertSystem end)ce=ce+mb+20;lX(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,mc*2,mb,cd,ce,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a0="IPH Mode: "..iphCondition end)ce=ce+mb+20;lX(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,mc*2,mb,cd,ce,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a0="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()Logs=Logger()_logCompute=Logs.CreateLog("Computation","time")q:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lG()coroutine.yield()lK()coroutine.yield()aW=jI()lW()ma()me()aD=lD;coroutine.yield()aL=cK()aP=cL()aQ=aP(cK())aR=e7()aT=eC()aX=e_()aU=g9()aV=jp()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)b_("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ap>0 or ap==0 and aq<10000)then for _,bO in pairs(door)do bO.toggle()end end;if switch then for _,bO in pairs(switch)do bO.toggle()end end;if forcefield and(ap>0 or ap==0 and aq<10000)then for _,bO in pairs(forcefield)do bO.toggle()end end;safeMass=at;cF()if button then button.activate()end;if SetWaypointOnExit then aW.showWayPoint(planet,bt)end;b_("stop","SU")for _,cS in pairs(Logs.getLogs())do system.print(cS)end end;function script.onTick(mq)local mr=nil;if mq=="contact"then if not contactTimer then contactTimer=0 end;if B>contactTimer+10 then a0="Radar Contact"b_("rdrCon","RC")contactTimer=B end;unit.stopTimer("contact")elseif mq=="tenthSecond"then local function ms()local mt=system.createData;local mu=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mu(panelInterplanetary,"value")interplanetaryHeaderText=mt('{"label": "Target Planet", "value": "N/A", "unit":""}')t(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mu(panelInterplanetary,"value")widgetDistanceText=mt('{"label": "distance", "value": "N/A", "unit":""}')t(widgetDistanceText,widgetDistance)widgetTravelTime=mu(panelInterplanetary,"value")widgetTravelTimeText=mt('{"label": "Travel Time", "value": "N/A", "unit":""}')t(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mu(panelInterplanetary,"value")widgetMaxMassText=mt('{"label": "Maximum Mass", "value": "N/A", "unit":""}')t(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mu(panelInterplanetary,"value")widgetTargetOrbitText=mt('{"label": "Target Altitude", "value": "N/A", "unit":""}')t(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mu(panelInterplanetary,"value")widgetCurBrakeDistanceText=mt('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mu(panelInterplanetary,"value")widgetCurBrakeTimeText=mt('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mu(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mt('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mu(panelInterplanetary,"value")widgetMaxBrakeTimeText=mt('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mu(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mt('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ao then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)t(widgetCurBrakeTimeText,widgetCurBrakeTime)t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mv()r(panelInterplanetary)panelInterplanetary=nil end;local function mw()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bt):len()else AutopilotDistance=(CustomTarget.position-bt):len()end end;local eA=bq;local kV=unit.getThrottle()/100;if AtmoSpeedAssist then kV=I end;local mx,my=aR.computeDistanceAndTime(bq,MaxGameVelocity,at,a:maxForceForward()*kV,warmup,0)local a6,a7;if not TurnBurn then a6,a7=aW.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=aW.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mz;if not TurnBurn and eA>0 then _,mz=aW.GetAutopilotBrakeDistanceAndTime(eA)else _,mz=aW.GetAutopilotTBBrakeDistanceAndTime(eA)end;local mA=0;local mB=0;if AutopilotCruising or not Autopilot and eA>5 then mB=aR.computeTravelTime(eA,0,AutopilotDistance)elseif a6+mx<AutopilotDistance then mA=AutopilotDistance-(a6+mx)mB=aR.computeTravelTime(8333.0556,0,mA)else local mC=(AutopilotDistance-a6)/mx;mx=AutopilotDistance-a6;my=my*mC end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mB elseif AutopilotBraking then return mz elseif AutopilotCruising then return mB+mz else return my+a7+mB end end;local function mD(j9,mE)if j9==nil then j9=core.g()end;j9=y(j9,5)if mE~=nil and mE or(mr==nil or mr~=j9)then local eA=bp:len()local mF=f(unit.getData()).maxBrake;if mF~=nil and mF>0 and ao then mF=mF/p(eA/100,0.1,1)mF=mF/ap;if ap>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mF)/2 else LastMaxBrakeInAtmo=mF end end end;if mF~=nil and mF>0 then LastMaxBrake=mF end;mr=j9 end end;mD(nil,true)if ap>0 and not WasInAtmo then if not by and AtmoSpeedAssist and(AltitudeHold or Reentry)then ci(1)M=false end end;if bx~=nil then if q:getTargetSpeed(axisCommandId.longitudinal)~=bx then cl(bx,TRUE)else bx=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then ms()end;if AutopilotTargetName~=nil then local mG=CustomTarget~=nil;local mH=LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()s(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mw()if mG and not Autopilot then ah=(bt-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bt):len()end;if not TurnBurn then a6,a7=aW.GetAutopilotBrakeDistanceAndTime(bq)a8,a9=aW.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=aW.GetAutopilotTBBrakeDistanceAndTime(bq)a8,a9=aW.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ij=cp(ah)s(widgetDistanceText,'{"label": "distance", "value": "'..ij..'"}')s(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cA(travelTime)..'", "unit":""}')ij=cp(a6)s(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ij..'"}')s(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cA(a7)..'", "unit":""}')ij=cp(a8)s(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ij..'"}')s(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cA(a9)..'", "unit":""}')s(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mH/1000)..'", "unit":" Tons"}')ij=cp(AutopilotTargetOrbit)s(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ij..'"}')if ap>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ap==0 and WasInAtmo then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mv()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aU.DrawTanks()elseif mq=="oneSecond"then local function mI(gW)local mJ=0;aB=""local mK=aJ;local mL=0;local mM=0;local mN=0;local gT=0;local gU=""local mO=core.getElementHitPointsById;for cJ in pairs(ar)do local lT=0;local mP=0;mP=h(ar[cJ])lT=mO(ar[cJ])mL=mL+lT;if lT<mP then if lT==0 then mN=mN+1 else mM=mM+1 end;if aK and#ay==0 then position=vec3(core.getElementPositionById(ar[cJ]))local cd=position.x-D;local ce=position.y-D;local fu=position.z-D;table.insert(ay,core.spawnArrowSticker(cd,ce,fu+1,"down"))table.insert(ay,core.spawnArrowSticker(cd,ce,fu+1,"down"))core.rotateSticker(ay[2],0,0,90)table.insert(ay,core.spawnArrowSticker(cd+1,ce,fu,"north"))table.insert(ay,core.spawnArrowSticker(cd+1,ce,fu,"north"))core.rotateSticker(ay[4],90,90,0)table.insert(ay,core.spawnArrowSticker(cd-1,ce,fu,"south"))table.insert(ay,core.spawnArrowSticker(cd-1,ce,fu,"south"))core.rotateSticker(ay[6],90,-90,0)table.insert(ay,core.spawnArrowSticker(cd,ce-1,fu,"east"))table.insert(ay,core.spawnArrowSticker(cd,ce-1,fu,"east"))core.rotateSticker(ay[8],90,0,90)table.insert(ay,core.spawnArrowSticker(cd,ce+1,fu,"west"))table.insert(ay,core.spawnArrowSticker(cd,ce+1,fu,"west"))core.rotateSticker(ay[10],-90,0,90)table.insert(ay,ar[cJ])end elseif aK and#ay>0 and ay[11]==ar[cJ]then for gO in pairs(ay)do core.deleteSticker(ay[gO])end;ay={}end end;mJ=d(mL/mK*100)if mJ<100 then gW[#gW+1]=cc(0,0,"","pbright txt")gT=d(mJ*2.55)gU=e("rgb(%d,%d,%d)",255-gT,gT,0)if mJ<100 then gW[#gW+1]=cc("50%",1035,"Elemental Integrity: "..mJ.."%","txtbig txtmid","fill:"..gU)if mN>0 then gW[#gW+1]=cc("50%",1055,"Disabled Modules: "..mN.." Damaged Modules: "..mM,"txtbig txtmid","fill:"..gU)elseif mM>0 then gW[#gW+1]=cc("50%",1055,"Damaged Modules: "..mM,"txtbig txtmid","fill:"..gU)end end end end;local function mQ()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then r(WeaponPanelID)WeaponPanelID=nil end end end;local function mR()local gP=o()local i6=bq;local mS=gP-as;if i6>1.38889 then i6=i6/1000;local mT=i6*(gP-as)TotalDistanceTravelled=TotalDistanceTravelled+mT;ab=ab+mT end;ac=ac+mS;TotalFlightTime=TotalFlightTime+mS;as=gP end;local function mU()if safeMass>0 then if at>safeMass+50 then bu=d(at-safeMass)safeMass=-1 elseif at<safeMass then safeMass=at end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mU()end;mR()aU.UpdatePipe()mQ()local gW={}aU.ExtraData(gW)if ShowOdometer then gW=aU.DrawOdometer(gW,ab,TotalDistanceTravelled,ac)end;if ShouldCheckDamage then mI(gW)end;ai=table.concat(gW,"")collectgarbage("collect")elseif mq=="fiveSecond"then if not UseSatNav then return end;an=dbHud_1.getStringValue("SPBAutopilotTargetName")if an~=nil and an~=""and an~="SatNavNotChanged"then local cZ=f(dbHud_1.getStringValue("SavedLocations"))if cZ~=nil then _G["SavedLocations"]=cZ;local fN=-1;local jF;for cJ,bO in pairs(SavedLocations)do if bO.name and bO.name=="SatNav Location"then fN=cJ;break end end;if fN~=-1 then jF=SavedLocations[fN]fN=-1;for cJ,bO in pairs(aL[0])do if bO.name and bO.name=="SatNav Location"then fN=cJ;break end end;if fN>-1 then aL[0][fN]=jF end;aV.UpdateAtlasLocationsList()a0=jF.name.." position updated"end end;for i=1,#bE do if bE[i].name==an then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bE[i].name)aV.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mq=="msgTick"then local gW={}aU.DisplayMessage(gW,"empty")a0="empty"unit.stopTimer("msgTick")ag=3 elseif mq=="animateTick"then aZ=true;aY=false;ae=0;af=0;unit.stopTimer("animateTick")elseif mq=="hudTick"then local function mV(gW)local mW=d(p(ah/(aE/4)*255,0,255))gW[#gW+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,d(F+0.5)+mW,d(H+0.5)-mW,d(G+0.5)-mW)end;local function mX()for _,bO in pairs(aD)do if bO.hovered then if not bO.drawCondition or bO.drawCondition()then bO.toggleFunction()end;bO.hovered=false end end end;local function mY()local function mZ(m_,n0,cd,ce,l_,m0)if m_>cd and m_<cd+l_ and n0>ce and n0<ce+m0 then return true else return false end end;local cd=ae+aE/2;local ce=af+aF/2;for _,bO in pairs(aD)do bO.hovered=mZ(cd,ce,bO.x,bO.y,bO.width,bO.height)end end;local function n1(gW)local function n2(gW,n3,hover,cd,ce,et,n4,n5,n6,n7,n8)if type(n7)=="function"then n7=n7()end;if type(n8)=="function"then n8=n8()end;gW[#gW+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cd,ce,et,n4)if n3 then gW[#gW+1]=e("%s'",n5)else gW[#gW+1]=n6 end;if hover then gW[#gW+1]=" style='stroke:white; stroke-width:2'"else gW[#gW+1]=" style='stroke:black; stroke-width:1'"end;gW[#gW+1]="></rect>"gW[#gW+1]=e("<text x='%f' y='%f' font-size='24' fill='",cd+et/2,ce+n4/2+5)if n3 then gW[#gW+1]="black"else gW[#gW+1]="white"end;gW[#gW+1]="' text-anchor='middle' font-family='Montserrat'>"if n3 then gW[#gW+1]=e("%s</text>",n7)else gW[#gW+1]=e("%s</text>",n8)end end;local n9="rgb(50,50,50)'"local na="rgb(210,200,200)"local nb=n2;for _,bO in pairs(aD)do local lZ=bO.disableName;local lY=bO.enableName;if type(lZ)=="function"then lZ=lZ()end;if type(lY)=="function"then lY=lY()end;if not bO.drawCondition or bO.drawCondition()then nb(gW,bO.toggleVar(),bO.hovered,bO.x,bO.y,bO.width,bO.height,na,n9,lZ,lY)end end end;local nc=y(ResolutionX/2,0)local nd=y(ResolutionY/2,0)local gW={}local ne=system.getTime()aU.HUDPrologue(gW)if showHud then local ne=system.getTime()aU.UpdateHud(gW)_logCompute.addValue(system.getTime()-ne)else if AlwaysVSpd then aU.DrawVerticalSpeed(gW,aq)end;aU.DisplayOrbitScreen(gW)aU.DrawWarnings(gW)end;if bB and bC~={}then aU.DrawSettings(gW)end;aU.DrawRadarInfo()aU.HUDEpilogue(gW)gW[#gW+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aE,aF)if a0~="empty"then aU.DisplayMessage(gW,a0)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aU.DrawDeadZone(gW)end end;if v()==0 then if l()==1 and Z then if not AltIsOn then mY()n1(gW)end;if not aY and not aZ then local nf=table.concat(gW,"")gW={}gW[#gW+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aE,aF)gW[#gW+1]=nf;gW[#gW+1]="</body>"aY=true;gW[#gW+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gW,"")system.setScreen(content)elseif aZ then local nf=table.concat(gW,"")gW={}gW[#gW+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aE,aF)gW[#gW+1]=nf;gW[#gW+1]="</body>"end;if not aY then gW[#gW+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nc,nd,ae,af)end else mX()end else if not Z and l()==0 then mX()if ah>DeadZone then if DisplayDeadZone then mV(gW)end end elseif not AltIsOn or AltIsOn and Z then mY()n1(gW)end;gW[#gW+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nc,nd,ae,af)end;gW[#gW+1]=[[</svg></body>]]content=table.concat(gW,"")elseif mq=="apTick"then aW.APTick()elseif mq=="radarTick"then aX.UpdateRadar()end end;function script.onFlush()local function ng(nh,l1)local ni=vec3()local nj=vec3()if nh==axisCommandId.longitudinal then ni=vec3(core.getConstructOrientationForward())nj=bn elseif nh==axisCommandId.vertical then ni=vec3(core.getConstructOrientationUp())nj=bm elseif nh==axisCommandId.lateral then ni=vec3(core.getConstructOrientationRight())nj=bo else return vec3()end;local nk=vec3(core.getWorldGravity())local nl=nk:dot(nj)local nm=vec3(core.getWorldAirFrictionAcceleration())local nn=nm:dot(nj)local no=bp;local np=no:dot(ni)local nq=l1*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nq-np)local nr=targetSpeedPID2:get()local ns=(nr-nn-nl)*nj;return ns end;local function nt(nh,l1)local ni=vec3()local nj=vec3()if nh==axisCommandId.longitudinal then ni=vec3(core.getConstructOrientationForward())nj=bn elseif nh==axisCommandId.vertical then ni=vec3(core.getConstructOrientationUp())nj=bm elseif nh==axisCommandId.lateral then ni=vec3(core.getConstructOrientationRight())nj=bo else return vec3()end;local nk=vec3(core.getWorldGravity())local nl=nk:dot(nj)local nm=vec3(core.getWorldAirFrictionAcceleration())local nn=nm:dot(nj)local no=bp;local np=no:dot(ni)local nq=l1*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nq-np)local nr=targetSpeedPID:get()local ns=(nr-nn-nl)*nj;return ns end;local function nu(nw,gZ,ju)local nx=nw:cross(ju):normalize_inplace()local hL=math.acos(p(nx:dot(-gZ),-1,1))*constants.rad2deg;if nx:cross(-gZ):dot(ju)<0 then hL=-hL end;return hL end;if antigrav and not ExternalAGG then if not bw and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;by=q:getAxisCommandType(0)==axisCommandType.byThrottle;if by and M then ci(0)M=false elseif not by and not M then I=0;M=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local ny=p(R+S+system.getControlDeviceForwardInput(),-1,1)local nz=p(U+X+system.getControlDeviceYawInput(),-1,1)local nA=p(V+T-system.getControlDeviceLeftRightInput(),-1,1)local nB=W;br=vec3(core.getWorldVertical())if br==nil or br:len()==0 then br=(planet.center-bt):normalize()end;bm=vec3(core.getConstructWorldOrientationUp())bn=vec3(core.getConstructWorldOrientationForward())bo=vec3(core.getConstructWorldOrientationRight())bp=vec3(core.getWorldVelocity())bt=vec3(core.getConstructWorldPos())at=core.getConstructMass()bq=vec3(bp):len()bs=-br:dot(bp)bA=getRoll(br,bn,bo)local nC=bA/180*math.pi;local nD=math.cos(nC)local nE=math.sin(nC)bz=nu(br,bn,bo*nD+bm*nE)local nF=bp:normalize()local nG=c(bA)local nH=utils.sign(bA)local nI=vec3(core.getWorldAngularVelocity())local nJ=ny*pitchSpeedFactor*bo+nz*rollSpeedFactor*bn+nA*yawSpeedFactor*bm;if a_==true and br:len()>0.01 then local nK=c(b3-bA)if((ProgradeIsOn or Reentry or BrakeLanding or aj or AltitudeHold or IntoOrbit)and nK>0 or ap>0.0 and nK<autoRollRollThreshold and autoRollPreference)and nz==0 and c(bz)<85 then local nL=b3;local nM=autoRollFactor;if ap==0 then nM=nM/4;b3=0;nL=0 end;if rollPID==nil then rollPID=pid.new(nM*0.01,0,nM*0.1)end;rollPID:inject(nL-bA)local nN=rollPID:get()nJ=nJ+nN*bn end end;if br:len()>0.01 and ap>0.0 then local nO=20.0;if turnAssist==true and nG>nO and ny==0 and nA==0 then local nP=turnAssistFactor*0.1;local nQ=turnAssistFactor*0.025;local nR=(nG-nO)/(180-nO)*180;local nS=0;if nR<90 then nS=nR/90 elseif nR<180 then nS=(180-nR)/90 end;nS=nS*nS;local nT=-nH*nQ*(1.0-nS)local nU=nP*nS;nJ=nJ+nU*bo+nT*bm end end;local nV=1;local nW=0;local nX=1;if system.getMouseWheel()>0 then if AltIsOn then if ap>0 or Reentry then b6=p(b6+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nY=I;I=y(p(I+speedChangeLarge/100,-1,1),2)if I>=0 and nY<0 then I=0;au=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ap>0 or Reentry then b6=p(b6-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nY=I;I=y(p(I-speedChangeLarge/100,-1,1),2)if I<=0 and nY>0 then I=0;au=false end end else au=true end;J=0;if ao and AtmoSpeedAssist and by then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b6/3.6-bp:dot(bn))local nZ=throttlePID:get()L=p(nZ,-1,1)if L<I and ap>0.005 then K=true;q:setThrottleCommand(axisCommandId.longitudinal,p(L,0.01,1))else K=false;q:setThrottleCommand(axisCommandId.longitudinal,I)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bp:len()-b6/3.6)local n_=p(brakePID:get(),0,1)if ap>0 and bs<-80 or ap>0.005 then J=n_ end;if J>0 then if K and L==0.01 then q:setThrottleCommand(axisCommandId.longitudinal,0)end else L=p(L,0.01,1)end;local o0=''local o1=vec3()local o2=ng(axisCommandId.vertical,ad*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o2,nW)local o3='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o3=o3 ..ExtraLongitudeTags end;local o4=q:getAxisCommandType(axisCommandId.longitudinal)local o5=q:composeAxisAccelerationFromThrottle(o3,axisCommandId.longitudinal)local o6=nt(axisCommandId.lateral,LeftAmount*1000)o0=o0 ..' , '.."lateral airfoil , lateral ground "o1=o1+o6;if o1:len()>constants.epsilon then a:setEngineForceCommand(o0,o1,nW,'','','',nX)end;a:setEngineForceCommand(o3,o5,nV)local o7='thrust analog vertical fueled 'local o8='thrust analog lateral fueled 'if ExtraLateralTags~="none"then o8=o8 ..ExtraLateralTags end;if ExtraVerticalTags~="none"then o7=o7 ..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o7,o2,nV)else a:setEngineForceCommand(o7,vec3(),nV)end;if LeftAmount~=0 then a:setEngineForceCommand(o8,o6,nV)else a:setEngineForceCommand(o8,vec3(),nV)end;if nB==0 then nB=J end;local o9=-nB*(brakeSpeedFactor*bp+brakeFlatFactor*nF)a:setEngineForceCommand('brake',o9)else if AtmoSpeedAssist then q:setThrottleCommand(axisCommandId.longitudinal,I)end;local l1=unit.getAxisCommandValue(0)if not by then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bp:len()-l1/3.6)local n_=p(brakePID:get(),0,1)nB=p(nB+n_,0,1)end;local o9=-nB*(brakeSpeedFactor*bp+brakeFlatFactor*nF)a:setEngineForceCommand('brake',o9)local o0=''local o1=vec3()local oa=false;local o3='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o3=o3 ..ExtraLongitudeTags end;local o4=q:getAxisCommandType(axisCommandId.longitudinal)if o4==axisCommandType.byThrottle then local o5=q:composeAxisAccelerationFromThrottle(o3,axisCommandId.longitudinal)a:setEngineForceCommand(o3,o5,nV)elseif o4==axisCommandType.byTargetSpeed then local o5=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)o0=o0 ..' , '..o3;o1=o1+o5;if q:getTargetSpeed(axisCommandId.longitudinal)==0 or q:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-q:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then oa=true end end;local o8='thrust analog lateral 'if ExtraLateralTags~="none"then o8=o8 ..ExtraLateralTags end;local ob=q:getAxisCommandType(axisCommandId.lateral)if ob==axisCommandType.byThrottle then local oc=q:composeAxisAccelerationFromThrottle(o8,axisCommandId.lateral)a:setEngineForceCommand(o8,oc,nV)elseif ob==axisCommandType.byTargetSpeed then local o6=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)o0=o0 ..' , '..o8;o1=o1+o6 end;local o7='thrust analog vertical 'if ExtraVerticalTags~="none"then o7=o7 ..ExtraVerticalTags end;local od=q:getAxisCommandType(axisCommandId.vertical)if od==axisCommandType.byThrottle then local o2=q:composeAxisAccelerationFromThrottle(o7,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o7,o2,nV,'airfoil','ground','',nX)else a:setEngineForceCommand(o7,vec3(),nV)a:setEngineForceCommand('airfoil vertical',o2,nV,'airfoil','','',nX)a:setEngineForceCommand('ground vertical',o2,nV,'ground','','',nX)end elseif od==axisCommandType.byTargetSpeed then if ad<0 then a:setEngineForceCommand('hover',vec3(),nV)end;local oe=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)o0=o0 ..' , '..o7;o1=o1+oe end;if o1:len()>constants.epsilon then if W~=0 or oa or c(nF:dot(bn))<0.8 then o0=o0 ..', brake'end;a:setEngineForceCommand(o0,o1,nW,'','','',nX)end end;local of=torqueFactor*(nJ-nI)local og=vec3(core.getWorldAirFrictionAngularAcceleration())of=of-og;a:setEngineTorqueCommand('torque',of,nV,'airfoil','','',nX)a:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local eA=core:len()local oh=0.15;if not by then local oi=q:getTargetSpeed(axisCommandId.longitudinal)if eA*3.6>oi*(1-oh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eA*3.6<oi*(1-oh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kV=unit.getThrottle()if AtmoSpeedAssist then kV=I*100 end;local l1=kV/100;if j==0 then l1=l1*MaxGameVelocity;if eA>=l1*(1-oh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eA<l1*(1-oh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lc=d(b6)l1=l1*lc/3.6;if eA>=l1*(1-oh)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eA<l1*(1-oh)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g7=coroutine.status(beginSetup)if g7=="suspended"then local cj,g8=coroutine.resume(beginSetup)if g8 then system.print("ERROR STARTUP: "..g8)end elseif g7=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aY and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(oj)local mult=1;local function ok(ol)local function om(on,ol)local oo={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local op=on;for _,bO in ipairs(oo)do if ol and op>bO then on=bO elseif on<bO and not ol then on=bO;break end end;return on end;if ol then mult=-1 end;if not ExternalAGG and bw then if Z and ol then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a2;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+mult*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if Z then bf=om(bf,ol)else bf=bf+mult*a1 end;if bf<planet.noAtmosphericDensityAltitude then bf=planet.noAtmosphericDensityAltitude end else if Z and ao then HoldAltitude=om(HoldAltitude,ol)else HoldAltitude=HoldAltitude+mult*a1 end end else q:updateTargetGroundAltitudeFromActionStart(mult*1.0)end end;local function oq(ol)if ol then mult=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then I=p(I+mult*speedChangeLarge/100,-1,1)else q:updateCommandFromActionStart(axisCommandId.longitudinal,mult*speedChangeLarge)end else if ol then mult=1 else mult=nil end;aV.adjustAutopilotTargetIndex(mult)end end;local function os(ot)if not ao then a0="Flight Assist in Atmo only"return end;local cQ=type(ot)if bH==nil then if cQ=="table"then if Autopilot or VectorToTarget then cv()end;b_("180On","BR")elseif ot==1 then b_("bnkLft","BR")else b_("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cu()if cQ~="table"then ot=ot+1 end end;bH=ot else b_("180Off","BR")bH=nil end end;if oj=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;ci(0)if vBooster or hover then if ao and am==-1 then b_("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;a_=true;GearExtended=false else if Q then b_("grOut","LG",1)a.control.extendLandingGears()end;q:setTargetGroundAltitude(LandingGearGroundHeight)if ao then BrakeIsOn=true end end end;if Q and not BrakeLanding and not(vBooster or hover)then b_("grOut","LG",1)a.control.extendLandingGears()end else if Q then b_("grIn","LG",1)a.control.retractLandingGears()end;q:setTargetGroundAltitude(TargetHoverHeight)end elseif oj=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif oj=="forward"then R=R-1 elseif oj=="backward"then if AltIsOn then os(-bp*5000)else R=R+1 end elseif oj=="left"then if AltIsOn then os(1)else U=U-1 end elseif oj=="right"then if AltIsOn then os(3)else U=U+1 end elseif oj=="yawright"then V=V-1 elseif oj=="yawleft"then V=V+1 elseif oj=="straferight"then q:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif oj=="strafeleft"then q:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif oj=="up"then ad=ad+1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif oj=="down"then ad=ad-1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif oj=="groundaltitudeup"then ok()elseif oj=="groundaltitudedown"then ok(true)elseif oj=="option1"then aV.adjustAutopilotTargetIndex()toggleView=false elseif oj=="option2"then aV.adjustAutopilotTargetIndex(1)toggleView=false elseif oj=="option3"then local function ou()aC=not aC;if not aC then b_("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else b_("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then r(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then r(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then r(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ou()toggleView=false elseif oj=="option4"then bH=nil;cv()toggleView=false elseif oj=="option5"then function ToggleLockPitch()if LockPitch==nil then b_("lkPOn","LP")if not Z then LockPitch=bz else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else b_("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif oj=="option6"then cu()toggleView=false elseif oj=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a0="Collision System Enabled"else a0="Collision System Secured"end;toggleView=false elseif oj=="option8"then stablized=not stablized;if not stablized then a0="DeCoupled Mode - Ground Stabilization off"q:deactivateGroundEngineAltitudeStabilization()b_("gsOff","GS")else a0="Coupled Mode - Ground Stabilization on"q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)b_("gsOn","GS")end;toggleView=false elseif oj=="option9"then if gyro~=nil then gyro.toggle()av=gyro.getState()==1;if av then b_("gyOn","GA")else b_("gyOff","GA")end end;toggleView=false elseif oj=="lshift"then if AltIsOn then Z=true end;if v()==1 then Z=true;PrevViewLock=v()u(1)elseif l()==1 and ShiftShowsRemoteButtons then Z=true;aZ=false;aY=false end elseif oj=="brake"then if BrakeToggleStatus then cx()elseif not BrakeIsOn then cx()else BrakeIsOn=true end elseif oj=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(1)end elseif oj=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a5 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a5=false end elseif oj=="stopengines"then local function ov()if B-C<1.5 then b_("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bH=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Y=false;N=false;aj=false;ak=false;P=false;a_=autoRollPreference;VectorToTarget=false;TurnBurn=false;av=false;LockPitch=nil;IntoOrbit=false end end;ov()C=B;if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if I~=0 then q:resetCommand(axisCommandId.longitudinal)ci(0)else ci(100)end else if q:getTargetSpeed(axisCommandId.longitudinal)~=0 then q:resetCommand(axisCommandId.longitudinal)else if ao then cl(AtmoSpeedLimit)else cl(MaxGameVelocity*3.6)end end end elseif oj=="speedup"then oq()elseif oj=="speeddown"then oq(true)elseif oj=="antigravity"and not ExternalAGG then if antigrav~=nil then cz()end end end;function script.onActionStop(oj)local function ow()if not ExternalAGG and bw then a4=a2 end;if AltitudeHold or VertTakeOff or IntoOrbit then a3=a1 end end;if oj=="forward"then R=0 elseif oj=="backward"then R=0 elseif oj=="left"then if bH then if bH==2 then bH=-2 else bH=-1 end end;U=0 elseif oj=="right"then if bH then if bH==4 then bH=-2 else bH=-1 end end;U=0 elseif oj=="yawright"then V=0 elseif oj=="yawleft"then V=0 elseif oj=="straferight"then q:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif oj=="strafeleft"then q:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif oj=="up"then ad=0;q:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oj=="down"then ad=0;q:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif oj=="groundaltitudeup"then ow()toggleView=false elseif oj=="groundaltitudedown"then ow()toggleView=false elseif oj=="lshift"then if v()==1 then ae=0;af=0;u(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then aZ=false;aY=false end;Z=false elseif oj=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cx()else BrakeIsOn=false end end elseif oj=="lalt"then if l()==0 and freeLookToggle then if toggleView then if v()==1 then u(0)else u(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(0)end;AltIsOn=false end end;function script.onActionLoop(oj)local function ox(ol)local mult=1;if ol then mult=-1 end;if not ExternalAGG and bw then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a4=p(a4*1.05,a2,500)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+mult*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bf=bf+mult*a3;if bf<planet.noAtmosphericDensityAltitude then bf=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+mult*a3 end;a3=p(a3*1.05,a1,500)else q:updateTargetGroundAltitudeFromActionLoop(mult*1.0)end end;local function oy(ol)if ol then mult=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then I=p(I+mult*speedChangeSmall/100,-1,1)else q:updateCommandFromActionLoop(axisCommandId.longitudinal,mult*speedChangeSmall)end end end;if oj=="groundaltitudeup"then if not Z then ox()end elseif oj=="groundaltitudedown"then if not Z then ox(true)end elseif oj=="speedup"then oy()elseif oj=="speeddown"then oy(true)end end;function script.onInputText(cf)local function oz()for cJ,bO in pairs(c5())do dbHud_1.setStringValue(bO,g(nil))end;for cJ,bO in pairs(b)do if bO~="SavedLocations"then dbHud_1.setStringValue(bO,g(nil))end end;a0="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ag=5 end;local function oA(oB,eE,hH)local function oC(eE)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cX='::pos{'..z..','..z..','..z..','..z..','..z..'}'local d9,da,dh,di,dj=n(eE,cX)if d9=="0"and da=="0"then return vec3(x(dh),x(di),x(dj))end;di=math.rad(di)dh=math.rad(dh)local planet=aL[x(d9)][x(da)]local e4=math.cos(dh)local oD=vec3(e4*math.cos(di),e4*math.sin(di),math.sin(dh))return planet.center+(planet.radius+dj)*oD end;local position=oC(eE)return aV.AddNewLocation(oB,position,hH)end;local i;local oE,oF=nil,nil;local oG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cf," ")oE=cf;if i~=nil then oE=string.sub(cf,0,i-1)oF=string.sub(cf,i+1)end;if oE=="/help"or oE=="/commands"then for jf in string.gmatch(oG,"([^\n]+)")do system.print(jf)end;return elseif oE=="/setname"then if oF==nil or oF==""then a0="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aV.UpdatePosition(oF)else a0="Select a saved target to rename first"end elseif oE=="/addlocation"or string.find(cf,"::pos")~=nil then local hH=false;local oB="0-Temp"if oF==nil or oF==""then oF=oE;hH=true end;i=string.find(oF,"::")if not hH then oB=string.sub(oF,1,i-2)end;local eE=string.sub(oF,i)oA(oB,eE,hH)elseif oE=="/agg"then if oF==nil or oF==""then a0="Usage: /agg targetheight"return end;oF=x(oF)if oF<1000 then oF=1000 end;AntigravTargetAltitude=oF;a0="AGG Target Height set to "..oF elseif oE=="/G"then if oF==nil or oF==""then a0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oF=="dump"then for cJ,bO in pairs(c5())do if type(_G[bO])=="boolean"then if _G[bO]==true then system.print(bO.." true")else system.print(bO.." false")end elseif _G[bO]==nil then system.print(bO.." nil")else system.print(bO.." ".._G[bO])end end;return end;i=string.find(oF," ")local oH=string.sub(oF,0,i-1)local oI=string.sub(oF,i+1)for cJ,bO in pairs(c5())do if bO==oH then a0="Variable "..oH.." changed to "..oI;local oJ=type(_G[bO])if oJ=="number"then oI=x(oI)elseif oJ=="boolean"then if string.lower(oI)=="true"then oI=true else oI=false end end;_G[bO]=oI;return end end;a0="No such global variable: "..oH elseif oE=="/copydatabank"then if dbHud_2 then cF(true)else a0="Spare Databank required to copy databank"end elseif oE=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aW.showWayPoint(aa,AutopilotTargetCoords,true))a0="::pos waypoint shown in lua chat"else a0="No target selected in IPH"end end end;function script.onEnter(ds)if radar_1 and not ao and not bF then unit.setTimer("contact",0.1)end end;function script.onLeave(ds)if radar_1 and CollisionSystem then if#bI>650 then ds=tostring(ds)bI[ds]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
