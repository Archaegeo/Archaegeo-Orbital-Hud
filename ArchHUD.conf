name: ArchHud - Archaegeo v0.725 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.725;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},DeadZone={set=function(K)au=K end,get=function()return au end},OrbitMapSize={set=function(K)av=K end,get=function()return av end},OrbitMapX={set=function(K)aw=K end,get=function()return aw end},OrbitMapY={set=function(K)ax=K end,get=function()return ax end},soundVolume={set=function(K)ay=K end,get=function()return ay end}}aA=5.0;aB=1.0;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR=0.0;aS="none"aT="none"aU="none"aV={speedChangeLarge={set=function(K)aA=K end,get=function()return aA end},speedChangeSmall={set=function(K)aB=K end,get=function()return aB end},MouseXSensitivity={set=function(K)aC=K end,get=function()return aC end},MouseYSensitivity={set=function(K)aD=K end,get=function()return aD end},autoRollFactor={set=function(K)aE=K end,get=function()return aE end},rollSpeedFactor={set=function(K)aF=K end,get=function()return aF end},autoRollRollThreshold={set=function(K)aG=K end,get=function()return aG end},minRollVelocity={set=function(K)aH=K end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(K)aI=K end,get=function()return aI end},torqueFactor={set=function(K)aJ=K end,get=function()return aJ end},pitchSpeedFactor={set=function(K)aK=K end,get=function()return aK end},yawSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeSpeedFactor={set=function(K)aM=K end,get=function()return aM end},brakeFlatFactor={set=function(K)aN=K end,get=function()return aN end},DampingMultiplier={set=function(K)aO=K end,get=function()return aO end},apTickRate={set=function(K)aP=K end,get=function()return aP end},hudTickRate={set=function(K)aQ=K end,get=function()return aQ end},ExtraEscapeThrust={set=function(K)aR=K end,get=function()return aR end},ExtraLongitudeTags={set=function(K)aS=K end,get=function()return aS end},ExtraLateralTags={set=function(K)aT=K end,get=function()return aT end},ExtraVerticalTags={set=function(K)aU=K end,get=function()return aU end}}aW=j;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=1000;b8=false;b9=false;ba=false;bb=false;bc=0;bd="Aligning"be=0;bf=1;bg="None"bh=nil;bi=0;bj=nil;bk=0.0;bl=0;bm={}bn=false;bo=0;bp=0;bq=nil;br=0;bs=1000;bt=0;bu=false;bv=0;bw=false;bx="All"by=true;bz="Off"bA=0.000;bB={}bC={}bD={VertTakeOff={set=function(K)b6=K end,get=function()return b6 end},VertTakeOffEngine={set=function(K)aX=K end,get=function()return aX end},SpaceTarget={set=function(K)bu=K end,get=function()return bu end},BrakeToggleStatus={set=function(K)aW=K end,get=function()return aW end},BrakeIsOn={set=function(K)aY=K end,get=function()return aY end},RetrogradeIsOn={set=function(K)aZ=K end,get=function()return aZ end},ProgradeIsOn={set=function(K)a_=K end,get=function()return a_ end},Autopilot={set=function(K)b0=K end,get=function()return b0 end},TurnBurn={set=function(K)b1=K end,get=function()return b1 end},AltitudeHold={set=function(K)b2=K end,get=function()return b2 end},BrakeLanding={set=function(K)b3=K end,get=function()return b3 end},Reentry={set=function(K)b5=K end,get=function()return b5 end},AutoTakeoff={set=function(K)b4=K end,get=function()return b4 end},HoldAltitude={set=function(K)b7=K end,get=function()return b7 end},AutopilotAccelerating={set=function(K)b8=K end,get=function()return b8 end},AutopilotBraking={set=function(K)ba=K end,get=function()return ba end},AutopilotCruising={set=function(K)bb=K end,get=function()return bb end},AutopilotRealigned={set=function(K)b9=K end,get=function()return b9 end},AutopilotEndSpeed={set=function(K)bc=K end,get=function()return bc end},AutopilotStatus={set=function(K)bd=K end,get=function()return bd end},AutopilotPlanetGravity={set=function(K)be=K end,get=function()return be end},PrevViewLock={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetName={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetCoords={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetIndex={set=function(K)bi=K end,get=function()return bi end},TotalDistanceTravelled={set=function(K)bk=K end,get=function()return bk end},TotalFlightTime={set=function(K)bl=K end,get=function()return bl end},SavedLocations={set=function(K)bm=K end,get=function()return bm end},VectorToTarget={set=function(K)bn=K end,get=function()return bn end},LocationIndex={set=function(K)bo=K end,get=function()return bo end},LastMaxBrake={set=function(K)bp=K end,get=function()return bp end},LockPitch={set=function(K)bq=K end,get=function()return bq end},LastMaxBrakeInAtmo={set=function(K)br=K end,get=function()return br end},AntigravTargetAltitude={set=function(K)bs=K end,get=function()return bs end},LastStartTime={set=function(K)bt=K end,get=function()return bt end},iphCondition={set=function(K)bx=K end,get=function()return bx end},stablized={set=function(K)by=K end,get=function()return by end},UseExtra={set=function(K)bz=K end,get=function()return bz end},SelectedTab={set=function(K)bE=K end,get=function()return bE end},saveRoute={set=function(K)bB=K end,get=function()return bB end},apRoute={set=function(K)bC=K end,get=function()return bC end}}local function bF(a,b,c,bG,bH,bI)bJ=bG()bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=0;bR=0;bS=0;bT=0;bU=false;bV=false;bW="empty"bX=3;bY=false;bZ=0;b_=0;c0=nil;c1=0;c2=0;c3=0;c4=false;c5=false;c6=false;c7=-1;c8=bI()>0;c9=bI()ca=b.getAltitude()cb=b.getConstructMass()cc=nil;cd=a9;ce=aa;cf={}cg={}ch={}ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=false;cs=false;ct=p;cu=false;cv=U;cw=nil;cx=0;cy=false;cz=false;cA=false;cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getVelocity())cE=vec3(b.getWorldVelocity())cF=vec3(cE):len()cG=vec3(b.getWorldVertical())cH=-cG:dot(cE)cI=vec3(b.getConstructWorldPos())cJ=false;cK=false;cL=true;cM=0;cN=0;cO={}cP=false;cQ=50000;cR=nil;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;cT=false;cU=nil;cV=false;cW=0;cX=nil;cY=nil;cZ={}c_=90;d0=w;d1=nil;d2=nil;d3={}d4={}d5=false;d6=nil;if shield_1 then d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d8(d,b,c,a,d9,da,db,dc,dd)local function de(df)return type(df)=='number'end;local function dg(df)return type(db(df))=='number'end;local function dh(di)return type(di)=='table'end;local function dj(a)return type(a)=='string'end;local function dk(dl)return dh(dl)and de(dl.x and dl.y and dl.z)end;local function dm(dn)return dh(dn)and de(dn.latitude and dn.longitude and dn.altitude and dn.id and dn.systemId)end;local dp=math.pi/180;local dq=180/math.pi;local dr=1e-10;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local utils=utils;local vec3=vec3;local function du(df)local dv=string.gsub(string.reverse(d9('%.4f',df)),'^0*%.?','')return dv==''and'0'or string.reverse(dv)end;local function dw(dx)if dk(dx)then return d9('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dh(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dA,dl in pairs(dx)do local dB=dw(dl)if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end end;return d9('{%s}',table.concat(dy,','))end;if dj(dx)then return d9("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dC={}dC.__index=dC;dC.__tostring=function(dx,dD)local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)local dy={}for dF,dA in ipairs(dE)do local dB=dw(dx[dA])if type(dA)=='number'then table.insert(dy,d9('[%s]=%s',dA,dB))else table.insert(dy,d9('%s=%s',dA,dB))end end;if dD then return d9('%s%s',dD,table.concat(dy,',\n'..dD))end;return d9('{%s}',table.concat(dy,','))end;dC.__eq=function(dG,dH)return dG.systemId==dH.systemId and dG.id==dH.id and dd(dG.radius,dH.radius)and dd(dG.center.x,dH.center.x)and dd(dG.center.y,dH.center.y)and dd(dG.center.z,dH.center.z)and dd(dG.GM,dH.GM)end;local function dI(dJ,dK,dL,dM,dN)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dL),'Argument 3 (radius) must be a number:'..type(dL))assert(dh(dM),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dM))assert(dg(dN),'Argument 5 (GM) must be a number:'..type(dN))return setmetatable({systemId=db(dJ),id=db(dK),radius=db(dL),center=vec3(dM),GM=db(dN)},dC)end;local dO={}dO.__index=dO;dO.__tostring=function(dP)return d9('::pos{%d,%d,%s,%s,%s}',dP.systemId,dP.id,du(dP.latitude*dq),du(dP.longitude*dq),du(dP.altitude))end;dO.__eq=function(dG,dH)return dG.id==dH.id and dG.systemId==dH.systemId and dd(dG.latitude,dH.latitude)and dd(dG.altitude,dH.altitude)and(dd(dG.longitude,dH.longitude)or dd(dG.latitude,math.pi/2)or dd(dG.latitude,-math.pi/2))end;local function dQ(dR,dK,dS,dT,dU)local dJ=dR;if dj(dR)and not dT and not dU and not dK and not dS then dJ,dK,dS,dT,dU=dV(dR,dt)assert(dJ,'Argument 1 (position string) is malformed.')else assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(dS),'Argument 3 (latitude) must be in degrees:'..type(dS))assert(dg(dT),'Argument 4 (longitude) must be in degrees:'..type(dT))assert(dg(dU),'Argument 5 (altitude) must be in meters:'..type(dU))end;dJ=db(dJ)dK=db(dK)dS=db(dS)dT=db(dT)dU=db(dU)if dK==0 then return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=dK,systemId=dJ},dO)end;return setmetatable({latitude=dp*da(dS,-90,90),longitude=dp*(dT%360),altitude=dU,id=dK,systemId=dJ},dO)end;local dW={}dW.__index=dW;dW.__tostring=function(dx,dD)local dX=dD and dD..'  'local dY={}local dE={}for dA in pairs(dx)do table.insert(dE,dA)end;table.sort(dE)for dF,dZ in ipairs(dE)do d_=dx[dZ]local e0=dC.__tostring(d_,dX)if dD then table.insert(dY,d9('[%s]={\n%s\n%s}',dZ,e0,dD))else table.insert(dY,d9('  [%s]=%s',dZ,e0))end end;if dD then return d9('\n%s%s%s',dD,table.concat(dY,',\n'..dD),dD)end;return d9('{\n%s\n}',table.concat(dY,',\n'))end;local function e1(e2)local e={}local pid;for dF,dl in pairs(e2)do local dK=dl.planetarySystemId;if type(dK)~='number'then error('Invalid planetary s ID: '..tostring(dK))elseif pid and dK~=pid then error('Mistringmatch planetary s IDs: '..dK..' and '..pid)end;local e3=dl.bodyId;if type(e3)~='number'then error('Invalid body ID: '..tostring(e3))elseif e[e3]then error('Duplicate body ID: '..tostring(e3))end;setmetatable(dl.center,getmetatable(vec3.unit_x))e[e3]=setmetatable(dl,dC)pid=dK end;return setmetatable(e,dW)end;e4={}local function e5(e2)return setmetatable({galaxyAtlas=e2 or{}},e4)end;e4.__index=function(di,K)if type(K)=='number'then local a=di.galaxyAtlas[K]return e1(a)end;return rawget(e4,K)end;e4.__pairs=function(dx)return function(di,dA)local e6,e7=next(di,dA)return e6,e7 and e1(e7)end,dx.galaxyAtlas,nil end;e4.__tostring=function(dx)local e8={}for dF,e9 in pairs(dx or{})do local ea=e9:getPlanetarySystemId()local eb=dW.__tostring(e9,'    ')table.insert(e8,d9('  [%s]={%s\n  }',ea,eb))end;return d9('{\n%s\n}\n',table.concat(e8,',\n'))end;e4.BodyParameters=dI;e4.MapPosition=dQ;e4.PlanetarySystem=e1;function e4.createBodyParameters(dJ,dK,ec,ed,ee,ef,eg)assert(dg(dJ),'Argument 1 (systemId) must be a number:'..type(dJ))assert(dg(dK),'Argument 2 (id) must be a number:'..type(dK))assert(dg(ec),'Argument 3 (surfaceArea) must be a number:'..type(ec))assert(dh(ed),'Argument 4 (aPosition) must be an array or vec3:'..type(ed))assert(dh(ee),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ee))assert(dg(ef),'Argument 6 (altitude) must be in meters:'..type(ef))assert(dg(eg),'Argument 7 (gravityAtPosition) must be number:'..type(eg))local dL=dc(ec/4/math.pi)local c3=dL+ef;local eh=vec3(ed)+c3*vec3(ee)local dN=eg*c3*c3;return dI(dJ,dK,dL,eh,dN)end;e4.isMapPosition=dm;function e4:getPlanetarySystem(dR)if K==nil then K=0 end;if e7==nil then e7=0 end;local dJ=dR;if dm(dR)then dJ=dR.systemId end;if type(dJ)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(e7)~=dW then a=e1(a)end;return a end end end;function dW:sizeCalculator(ei)return 1.05*ei.radius end;function dW:castIntersections(ej,ek,el,em,en,eo)local ep={}if en then for dF,ei in pairs(en)do table.insert(ep,ei)end else ep=cZ end;if not eo then table.sort(ep,function(eq,er)local es=eq.center;local et=er.center;return(es.x-ej.x)^2+(es.y-ej.y)^2+(es.z-ej.z)^2<(et.x-ej.x)^2+(et.y-ej.y)^2+(et.z-ej.z)^2 end)end;local eu=ek:normalize()for dF,ei in ipairs(ep)do local ev=ei.center-ej;local dL=self:sizeCalculator(ei)local ew=ev:dot(eu)local ex=ew^2-(ev:len2()-dL^2)if ex>=0 then local ey=dc(ex)local ez=ew+ey;local eA=ew-ey;if eA>0 then return ei,ez,eA elseif ez>0 then return ei,ez,nil end end end;return nil,nil,nil end;function dW:closestBody(eB)assert(type(eB)=='table','Invalid coordinates.')local eC,ei;local eD=vec3(eB)for dF,eE in pairs(self)do local eF=(eE.center-eD):len2()if(not ei or eF<eC)and eE.name~="Space"then ei=eE;eC=eF end end;return ei end;function dW:convertToBodyIdAndWorldCoordinates(dR)local eG=dR;if dj(dR)then eG=dQ(dR)end;if eG.id==0 then return 0,vec3(eG.latitude,eG.longitude,eG.altitude)end;local eE=self:getBodyParameters(eG)if eE then return eG.id,eE:convertToWorldCoordinates(eG)end end;function dW:getBodyParameters(dR)local dK=dR;if dm(dR)then dK=dR.id end;assert(dg(dK),'Argument 1 (id) must be a number:'..type(dK))return self[dK]end;function dW:getPlanetarySystemId()local dF,dl=next(self)return dl and dl.systemId end;function dC:convertToMapPosition(dM)assert(dh(dM),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dM))local eH=vec3(dM)if self.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=self.systemId},dO)end;local eI=eH-self.center;local c3=eI:len()local dU=c3-self.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=dS,longitude=dT,altitude=dU,id=self.id,systemId=self.systemId},dO)end;function dC:convertToWorldCoordinates(dR)local eG=dj(dR)and dQ(dR)or dR;if eG.id==0 then return vec3(eG.latitude,eG.longitude,eG.altitude)end;assert(dm(eG),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eG.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eG.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eL=math.cos(eG.latitude)return self.center+(self.radius+eG.altitude)*vec3(eL*math.cos(eG.longitude),eL*math.sin(eG.longitude),math.sin(eG.latitude))end;function dC:getAltitude(dM)return(vec3(dM)-self.center):len()-self.radius end;function dC:getDistance(dM)return(vec3(dM)-self.center):len()end;function dC:getGravity(dM)local eM=self.center-vec3(dM)local eN=eM:len2()return self.GM/eN*eM/dc(eN)end;return setmetatable(e4,{__call=function(dF,...)return e5(...)end})end;local function eO(d,b,c,a,dc,eP)local cj={}local eQ=30000000/3600;local eR=eQ*eQ;local eS=100;function cj.computeAccelerationTime(eT,eU,eV)local eW=eQ*math.asin(eT/eQ)return(eQ*math.asin(eV/eQ)-eW)/eU end;function cj.computeDistanceAndTime(eT,eV,eX,eY,eZ,e_)eZ=eZ or 0;e_=e_ or 0;local f0=eT<=eV;local f1=eY*(f0 and 1 or-1)/eX;local f2=-e_/eX;local f3=f1+f2;if f0 and f3<=0 or not f0 and f3>=0 then return-1,-1 end;local f4,f5=0,0;if f1~=0 and eZ>0 then local eW=math.asin(eT/eQ)local f6=math.pi*(f1/2+f2)local f7=f1*eZ;local f8=eQ*math.pi;local dl=function(di)local f9=(f6*di-f7*math.sin(math.pi*di/2/eZ)+f8*eW)/f8;local fa=math.tan(f9)return eQ*fa/dc(fa*fa+1)end;local fb=f0 and function(a)return a>=eV end or function(a)return a<=eV end;f5=2*eZ;if fb(dl(f5))then local fc=0;while eP(f5-fc)>0.5 do local di=(f5+fc)/2;if fb(dl(di))then f5=di else fc=di end end end;local fd=eT;local fe=f5/eS;for ff=1,eS do local fg=dl(ff*fe)f4=f4+(fg+fd)*fe/2;fd=fg end;if f5<2*eZ then return f4,f5 end;eT=fd end;local eW=eQ*math.asin(eT/eQ)local bJ=(eQ*math.asin(eV/eQ)-eW)/f3;local fh=eR*math.cos(eW/eQ)/f3;local c3=fh-eR*math.cos((f3*bJ+eW)/eQ)/f3;return c3+f4,bJ+f5 end;function cj.computeTravelTime(eT,eU,c3)if c3==0 then return 0 end;if eU>0 then local eW=eQ*math.asin(eT/eQ)local fh=eR*math.cos(eW/eQ)/eU;return(eQ*math.acos(eU*(fh-c3)/eR)-eW)/eU end;if eT==0 then return-1 end;assert(eT>0,'Acceleration and initial speed are both zero.')return c3/eT end;return cj end;local function fi(d,b,c,a,d9,da,db,dc,dd)local vec3=vec3;local d8=d8(d,b,c,a,d9,da,db,dc,dd)local function dj(a)return type(a)=='string'end;local function dh(di)return type(di)=='table'end;fj={}fj.__index=fj;function fj:escapeAndOrbitalSpeed(dU)assert(self.body)local c3=dU+self.body.radius;if not dd(c3,0)then local fk=dc(self.body.GM/c3)return dc(2)*fk,fk end;return nil,nil end;function fj:orbitalParameters(dR,fl)assert(self.body)assert(dh(dR)or dj(dR))assert(dh(fl))local fm=(dj(dR)or d8.isMapPosition(dR))and self.body:convertToWorldCoordinates(dR)or vec3(dR)local dl=vec3(fl)local fn=fm-self.body.center;local fo=dl:len2()local fp=fn:len()local fq=self.body.GM;local fr=((fo-fq/fp)*fn-fn:dot(dl)*dl)/fq;local es=fq/(2*fq/fp-fo)local fs=fr:len()local eu=fr:normalize()local ft=es*(1-fs)local fu=es*(1+fs)local fv=ft*eu+self.body.center;local fw=fs<=1 and-fu*eu+self.body.center or nil;local fx=dc(es*fq*(1-fs*fs))local fy=fw and 2*math.pi*dc(es^3/fq)local fz=math.acos(fr:dot(fn)/(fs*fp))if fn:dot(dl)<0 then fz=-(fz-2*math.pi)end;local fA=math.acos((math.cos(fz)+fs)/(1+fs*math.cos(fz)))local fB=fA;if fB<0 then fB=fB+2*math.pi end;local fC=fB-fs*math.sin(fB)local fD=0;local fE=0;local fF=0;if fy~=nil then fD=fC/(2*math.pi/fy)fE=fy-fD;fF=fE+fy/2;if fz-math.pi>0 then fE=fD;fF=fE+fy/2 end;if fF>fy then fF=fF-fy end end;return{periapsis={position=fv,speed=fx/ft,circularOrbitSpeed=dc(fq/ft),altitude=ft-self.body.radius},apoapsis=fw and{position=fw,speed=fx/fu,circularOrbitSpeed=dc(fq/fu),altitude=fu-self.body.radius},currentVelocity=dl,currentPosition=fm,eccentricity=fs,period=fy,eccentricAnomaly=fA,meanAnomaly=fC,timeToPeriapsis=fE,timeToApoapsis=fF,trueAnomaly=fz}end;local function fG(fH)local eE=d8.BodyParameters(fH.systemId,fH.id,fH.radius,fH.center,fH.GM)return setmetatable({body=eE},fj)end;return setmetatable(fj,{__call=function(dF,...)return fG(...)end})end;local function fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)local function fN(fO)local dP=fP:closestBody(fO)if(fO-dP.center):len()>dP.radius+dP.noAtmosphericDensityAltitude then dP=e[0][0]end;return dP end;local function fQ()local function fR(fS,fT)return fS.name<fT.name end;cO={}for dA,dl in pairs(e[0])do cO[#cO+1]={name=dl.name,index=dA}end;table.sort(cO,fR)end;local function fU(fV,fW)if not fW then fW=fX.name end;for dA,dl in pairs(fV)do if dl.name and dl.name==fW then return dA end end;return-1 end;local function fY()cW=bi;if bi==0 then bg="None"c0=nil;fX=nil;return true end;local fZ=cO[bi].index;local f_=e[0][fZ]if f_.center then bg=f_.name;c0=ci[0][fZ]if fX~=nil then if c9==0 then if fJ(g0,g1)~=1 then fK(g0,g1)end;if fJ(g2,g3)~=1 then fK(g2,g3)end;if fJ(g4,g5)~=1 then fK(g4,g5)end;if fJ(g6,g7)~=1 then fK(g6,g7)end;if fJ(g8,g9)~=1 then fK(g8,g9)end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end;if fJ(ge,gf)~=1 then fK(ge,gf)end end;fX=nil else fX=f_;for dF,dl in pairs(ci[0])do if dl.name==fX.planetname then c0=dl;bg=fX.name;break end end;if fJ(ga,gb)~=1 then fK(ga,gb)end;if fJ(gc,gd)~=1 then fK(gc,gd)end end;if fX==nil then bh=vec3(c0.center)else bh=fX.position end;if c0.planetname~="Space"then if c0.hasAtmosphere then gg=bH(c0.radius*(S-1)+c0.noAtmosphericDensityAltitude)else gg=bH(c0.radius*(S-1)+c0.surfaceMaxAltitude)end else gg=R end;if fX~=nil and fX.planetname=="Space"then bc=0 else dF,bc=ck(c0):escapeAndOrbitalSpeed(gg)end;be=0;b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"return true end;local function gh(gi)if not b0 and not bn and not c5 and not bw and not b5 and not c6 then if gi==nil then bi=bi+1;if bi>#cO then bi=0 end else bi=bi-1;if bi<0 then bi=#cO end end;if bi==0 then fY()else local fZ=cO[bi].index;local f_=e[0][fZ]if f_ and(f_~=nil and f_.name=="Space"or bx=="Custom Only"and f_.center or bx=="No Moons"and string.find(f_.name,"Moon")~=nil)then if gi==nil then gh()else gh(1)end else fY()end end else bW="Disengage autopilot before changing Interplanetary Helper"fL("iph","AP")end end;local function gj()local function gk(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=-1;gn=fU(e[0])if gn>-1 then table.remove(e[0],gn)end;gn=-1;gn=fU(gm)if gn~=-1 then bW=fX.name.." saved location cleared"table.remove(gm,gn)end;gh()fQ()return gm end;if string.sub(bg,1,1)=="*"then d3=gk(true)else bm=gk(false)end end;local function go(gp,fO,gq,gr)local function gs(gl)if gl then gm=d3 else gm=bm end;if dbHud_1 or gq or gl then local dP=fN(fO)local gt={position=fO,name=gp,planetname=dP.name,gravity=b.g(),safe=gr}if not gq then gm[#gm+1]=gt else for dA,dl in pairs(e[0])do if dl.name and gp==dl.name then table.remove(e[0],dA)end end end;table.insert(e[0],gt)fQ()fY()bW="Location saved as "..gp.."("..dP.name..")"return gm else bW="Databank must be installed to save permanent locations"end end;if string.sub(gp,1,1)=="*"then d3=gs(true)else bm=gs(false)end end;local gu={}function gu.UpdateAtlasLocationsList()fQ()end;function gu.UpdateAutopilotTarget()fY()end;function gu.adjustAutopilotTargetIndex(gi)gh(gi)end;function gu.findAtlasIndex(fV,fW)return fU(fV,fW)end;function gu.UpdatePosition(gv,gw,gx)local function gy(gl)local gm;if gl then gm=d3 else gm=bm end;local gn=fU(gm)if gn~=-1 then if gv~=nil then if gl then gv="*"..gv end;gm[gn].name=gv;bi=bi-1;gh()elseif gx~=nil then if gx then local gz=ca;if gz<1000 then gz=1000 end;gm[gn].agg=fM(gz,0)bW=gm[gn].name.." AGG Altitude:"..gm[gn].agg.." saved ("..gm[gn].planetname..")"return elseif gx==false then gm[gn].agg=nil;bW=gm[gn].name.." AGG Altitude cleared ("..gm[gn].planetname..")"return end else local gA=gm[gn]if gw then gA.heading=cC:cross(cG)*5000;bW=gm[gn].name.." heading saved ("..gm[gn].planetname..")"return elseif gw==false then gA.heading=nil;bW=gm[gn].name.." heading cleared ("..gm[gn].planetname..")"return end;gA.gravity=b.g()gA.position=cI;gA.safe=true end;bW=gm[gn].name.." position updated ("..gm[gn].planetname..")"else bW="Name Not Found"end end;if string.sub(bg,1,1)=="*"then gy(true)else gy(false)end end;function gu.AddNewLocation(gp,fO,gq,gr)go(gp,fO,gq,gr)end;function gu.ClearCurrentPosition()gj()end;for dA,dl in pairs(d4)do table.insert(e[0],dl)end;if gB then for dA,dl in pairs(gB)do gu[dA]=dl end end;fQ()if bi>#cO then bi=0 end;gu.UpdateAutopilotTarget()return gu end;local function gC(b,a,c,library,radar_1,radar_2,eP,gD,dc,gE,db,gF,fL)local gG={}local gH={}local gI={XS=13,S=27,M=55,L=110,XL=221}local gJ={}local gK;local gL;local gM;local gN;local gO;local gP={}local gQ="Atmo"local gR;local gS;local gT=0;local gU={}local function gV()local function gW(gX,gY,gZ,g_,h0,h1,h2,h3)gY,g_,h1,h3=vec3(gY),vec3(g_),vec3(h1),vec3(h3)local h4,h5,h6=gX*gX,gZ*gZ,h0*h0;local fo=g_-gY;local h7=fo:normalize()local h8=fo:len()local h9=h1-gY;local ha=(h9-h9:project_on(h7)):normalize()local hb,hc=h9:dot(h7),h9:dot(ha)local hd=hb*hb+hc*hc;local he=h7:cross(ha)local hf=(h4-h5+h8*h8)/(2*h8)local hg=(h4-h6+hd-2*hb*hf)/(2*hc)local dn=h4-hf^2-hg^2;local hh=dc(dn)local hi=gY+h7*hf+ha*hg+he*hh;local hj=gY+h7*hf+ha*hg-he*hh;if eP((h3-hi):len()-h2)<eP((h3-hj):len()-h2)then return hi else return hj end end;local function hk()local function hl()local hm=b.getConstructWorldOrientationRight()local fo=b.getConstructWorldOrientationForward()local h9=b.getConstructWorldOrientationUp()local hn=library.systemResolution3(hm,fo,h9,{1,0,0})local ho=library.systemResolution3(hm,fo,h9,{0,1,0})local hp=library.systemResolution3(hm,fo,h9,{0,0,1})return function(hq)return library.systemResolution3(hn,ho,hp,hq)end end;local hr=hl()local hs=b.getConstructWorldPos()local fm=b.getElementPositionById(1)local ht={fm[1],fm[2],fm[3]}local hu=hr(ht)local hv={hs[1]-hu[1],hs[2]-hu[2],hs[3]-hu[3]}return hv end;local function hw(hx,fp,hy)local hz=hx.pts;local gn=#hz;local hA=hx.ref;if gn>3 then local hB,hC,hD,hE=hz[gn],hz[gn-1],hz[gn-2],hz[gn-3]hx.ref=hy;local fm=gW(hB[1],hB[2],hC[1],hC[2],hD[1],hD[2],hE[1],hE[2])local hf,hg,hh=fm.x,fm.y,fm.z;if hf==hf and hg==hg and hh==hh then hf=hf+hA[1]hg=hg+hA[2]hh=hh+hA[3]local hF=vec3(hf,hg,hh)if not hx.lastPos then hx.center=hF elseif(hx.lastPos-hF):len()<2 then hx.center=hF;hx.skipCalc=true end;hx.lastPos=hF end;hx.pts={}else local hG={hy[1]-hA[1],hy[2]-hA[2],hy[3]-hA[3]}hz[gn+1]={fp,hG}end end;if radar_1 or radar_2 then co.assignRadar()end;if gP[1]then gK=#gP[1].getConstructIds()local hH=gP[1].getData()local hI=hH:gmatch('{"constructId[^}]*}[^}]*}')if gK>0 then local hy=hk()local hJ,hK=0,0;gO,gN=0,0;for dl in hI do local dK,c3,hL=dl:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hM=gI[hL]c3=db(c3)if gP[1].hasMatchingTransponder(dK)==1 then table.insert(gH,dK)end;local hN=gP[1].getConstructType(dK)if E then if hM>27 or F or hN=="static"or hN=="space"then gO=gO+1;local gp=gP[1].getConstructName(dK)local hx=gU[dK]if hx==nil then hM=hM+gF;gU[dK]={pts={},ref=hy,name=gp,i=0,radius=hM,skipCalc=false}hx=gU[dK]end;if not hx.skipCalc then hw(hx,c3,hy)hK=hK+1 end;if hx.center then if F and gP[1].isConstructAbandoned(dK)==1 and not hx.abandoned then fL("abRdr","RD")a.print("Abandoned Construct: "..gp.." ("..hN..") ::pos{0,0,"..hx.center.x..","..hx.center.y..","..hx.center.z.."}")bW="Abandoned Radar Contact ("..hN..") detected"hx.abandoned=true end;table.insert(gJ,hx)end end;hJ=hJ+1;if cS and hJ>700 or hK>70 or(not cS and hJ>300 or hK>30)then coroutine.yield()hJ,hK=0,0 end end end;gN=#gJ;if gN>0 and(cF>20 or b3)then local ei,hO,hP,hQ;local hR=0;local hS=ci:getPlanetarySystem(0)hQ=cE:normalize()while hR<gN do coroutine.yield()local hT={table.unpack(gJ,hR,math.min(hR+75,gN))}ei,hO,hP=hS:castIntersections(cI,hQ,nil,nil,hT,true)if ei and hP then cU={ei,hO,hP}break end;hR=hR+75 end;if not ei then cU=nil end else cU=nil end;gJ={}gL=hH:find('identifiedConstructs":%[%]')else gM=hH:find('worksInEnvironment":false')end end end;local function hU()if gP[1]then gQ="Atmo"if gP[1].getData():find('worksInAtmosphere":false')then gQ="Space"end end end;function gG.pickType()hU()end;function gG.assignRadar()if radar_1 and gP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gP[1]=radar_2 end;if gP[1]==radar_2 then hU()end elseif radar_2 and gP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gP[1]=radar_1 end;if gP[1]==radar_1 then hU()end end end;function gG.UpdateRadar()local hV=coroutine.status(gR)if hV=="suspended"then local dB,hW=coroutine.resume(gR)if hW then a.print("ERROR UPDATE RADAR: "..hW)end elseif hV=="dead"then gR=coroutine.create(gV)local dB,hW=coroutine.resume(gR)end end;function gG.GetRadarHud(hX,hY,hZ,h_)local i0=gH;local i1,i2;gH={}local ds=gN or 0;if gK>0 then if E then i2=ds.."/"..gO.." Plotted : "..gK-gO.." Ignored"else i2="Radar Contacts: "..gK end;i1=gE(hZ,h_,i2,"pbright txtbig txtmid")if#gH>0 then i1=i1 ..gE(hX,hY,"Friendlies In Range","pbright txtbig txtmid")for dA,dl in pairs(gH)do hY=hY+20;i1=i1 ..gE(hX,hY,gP[1].getConstructName(dl),"pdim txtmid")end end;if gL==nil and gS==nil then gT=1;co.ToggleRadarPanel()end;if gL~=nil and gS~=nil then co.ToggleRadarPanel()end;if d2==nil then co.ToggleRadarPanel()end else if gM then i1=gE(hZ,h_,gQ.." Radar: Jammed","pbright txtbig txtmid")else i1=gE(hZ,h_,"Radar: No "..gQ.." Contacts","pbright txtbig txtmid")end;if d2~=nil then gT=0;co.ToggleRadarPanel()end end;return i1 end;function gG.GetClosestName(gp)if gP[1]then local dK,dF=gP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dK~=nil and dK~=""then gp=gp.." "..gP[1].getConstructName(dK)end end;return gp end;function gG.ToggleRadarPanel()if d2~=nil and gT==0 then gD(d2)d2=nil;if gS~=nil then gD(gS)gS=nil end else if gT==1 then gD(d2)d2=nil;_autoconf.displayCategoryPanel(gP,1,"Periscope","periscope")gS=_autoconf.panels[_autoconf.panels_size]end;if d2==nil then _autoconf.displayCategoryPanel(gP,1,"Radar","radar")d2=_autoconf.panels[_autoconf.panels_size]end;gT=0 end end;function gG.ContactTick()if not i3 then i3=0 end;if bJ>i3+10 then bW="Radar Contact"fL("rdrCon","RC")i3=bJ end;c.stopTimer("contact")end;function gG.onEnter(dK)if radar_1 and not c8 and not cP then c.setTimer("contact",0.1)end end;function gG.onLeave(dK)if radar_1 and E then if#gU>650 then dK=tostring(dK)gU[dK]=nil end end end;gP[1]=nil;if radar_1 then gP[1]=radar_1;hU()end;gR=coroutine.create(gV)if i4 then for dA,dl in pairs(i4)do gG[dA]=dl end end;return gG end;local function i5(shield_1,dV,bH)local i6={}local i7=shield_1.getResistancesCooldown()local function i8()local i9=shield_1.getState()if G then if not cP and i9==0 then shield_1.toggle()elseif cP and i9==1 then shield_1.toggle()end end end;local function ia()local ib=shield_1.getStressRatioRaw()local ic=0.5999;if ib[1]==0.0 and ib[2]==0.0 and ib[3]==0.0 and ib[4]==0.0 then return end;local id=shield_1.setResistances(ic*ib[1],ic*ib[2],ic*ib[3],ic*ib[4])if id==1 then bW="Shield Resistances updated"else bW="Value Exceeded. Failed to update Shield Resistances"end end;function i6.shieldTick()d7=bH(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())i8()i7=shield_1.getResistancesCooldown()if i7==0 and d7<a7 then ia()end end;function i6.setResist(ie)if not shield_1 then bW="No shield found"return elseif ie==nil or i7>0 then bW="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt=ds..', '..ds..', '..ds..', '..ds;local ig,ih,ii,ij=dV(ie,dt)if ij==nil or ig+ih+ii+ij>0.6 then bW="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(ig,ih,ii,ij)==1 then bW="Shield Resistances set"else bW="Resistance setting failed."end end;function i6.ventShield()local ik=shield_1.getVentingCooldown()if ik>0 then bW="Cannot vent again for "..ik.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bW="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bW="Shields already at max hitpoints"end end;if il then for dA,dl in pairs(il)do i6[dA]=dl end end;return i6 end;local function im(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,io,eP,bH,d9,ip,bI,iq,ir,eK,bG,da,is,fK,fJ,gD,it,dc,fM,gE,fL,iu,iv,iw,ix,iy,iz)local iA=9.80665;local iB={}local iC={}local iD={}local iE={}local iF=nil;local iG=nil;local iH=nil;local iI=false;local iJ="none"local iK=""local iL=55;local iM=0;local iN=0;local iO=""local iP=nil;local iQ=ac;local iR=ad;local iS=ae;local iT=[[rgb(]]..bH(iQ+0.5)..","..bH(iR+0.5)..","..bH(iS+0.5)..[[)]]local iU=[[rgb(]]..bH(iQ*0.9+0.5)..","..bH(iR*0.9+0.5)..","..bH(iS*0.9+0.5)..[[)]]local iV=0;local iW=0;local iX=""local iY=bG()local iZ=false;local i_=vec3({13771471,7435803,-128971})local j0=18000000;local j1=500000;local j2,j3=math.huge;local j4;local function j5(j6)j2=vec3(j6):dist(i_)if j2<j0 then return true,eP(j2-j0)end;j3=vec3(j6):dist(vec3(j7.center))if j3<j1 then j4=true else j4=false end;if eP(j3-j1)<eP(j2-j0)then return j4,eP(j3-j1)else return j4,eP(j2-j0)end end;local function j8(dl)if cd==1920 then return dl else return fM(cd*dl/1920,0)end end;local function j9(dl)if ce==1080 then return dl else return fM(ce*dl/1080,0)end end;local function ja()return it()==0 and g~="keyboard"and ir()==0 end;local function jb()local jc="TRAVEL"if not cL then jc="CRUISE"end;if b0 then jc="AUTOPILOT"end;return jc end;local i1=""local jd=""local je=""local jf=1;local jg=2;local jh=3;local ji=4;local jj=5;local jk=6;local jl=""local jm=0;local jn=bH(1/aP)*2*aQ;local jo={}local jp={}local jq={}local jr={}local js={}local jt={}local ju={}ju["atmofueltank"],ju["spacefueltank"],ju["rocketfueltank"]=0,0,0;local jv=0;local function jw(hf,jx,jy,jz,jA,jB)local jC=jv;local jD=jv+5;if not B then jD=jD+5 end;if ir()==1 and not l then jC=jC-50;jD=jD-50 end;if jy=="ATMO"then jl="atmofueltank"elseif jy=="SPACE"then jl="spacefueltank"else jl="rocketfueltank"end;jm=_G[jl.."_size"]if#jz>0 then for K=1,#jz do local gp=string.sub(jz[K][jg],1,12)local jE=0;for jF=1,jm do if jz[K][jg]==ip(c[jl.."_"..jF].getData()).name then jE=jF;break end end;local jG=bG()if jA[K]==nil or jB[K]==nil or jG-jz[K][jk]>jn then local jH;local jI=0;jI=iq(jz[K][jf])-jz[K][ji]jH=jz[K][jj]if jH>jI then ju[jl]=ju[jl]+jH-jI end;if jE~=0 then jB[K]=ip(c[jl.."_"..jE].getData()).percentage;jA[K]=ip(c[jl.."_"..jE].getData()).timeLeft;if jA[K]=="n/a"then jA[K]=0 end else jB[K]=bH(0.5+jI*100/jz[K][jh])if jH<=jI then jA[K]=0 else jA[K]=bH(0.5+jI/((jH-jI)/(jG-jz[K][jk])))end end;jz[K][jk]=jG;jz[K][jj]=jI end;if gp==jx then gp=d9("%s %d",jy,K)end;if jE==0 then gp=gp.." *"end;local jJ;if jA[K]==0 then jJ=""else jJ=ix(jA[K])end;if jB[K]~=nil then local jK=bH(jB[K]*2.55)local jL=d9("rgb(%d,%d,%d)",255-jK,jK,0)local jM=""if jJ~=""and jA[K]<120 or jB[K]<5 then jM="red "end;local jN=d9("rgb(%d,%d,%d)",da(bH((255-jK)/2.55),50,100),da(bH(jK/2.55),0,50),50)local jO="rgb(196,0,255)"if jy=="ATMO"then jO="rgb(0,188,255)"elseif jy=="SPACE"then jO="rgb(239,255,0)"end;local jP=false;if jQ~=jO then jP=true end;jQ=jO;if B then if jP then jC=jC-5;jD=jD-5 end;jd=jd..d9([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jN,jO,hf,jD,jL,bH(jB[K]*1.7+0.5)-2,hf+1,jD+1,hf+5,jD+14,gp,jB[K],jJ)jC=jC-22;jD=jD-22 else jd=jd..gE(hf,jC,gp,jM.."pdim txtfuel")jd=jd..gE(hf,jD,d9("%d%% %s",jB[K],jJ),"pdim txtfuel","fill:"..jL)jC=jC+30;jD=jD+30 end end end end;jv=jC end;local function jR(jS,dU)if am==0 and an==0 then return end;if dU<200000 and not c8 or dU and c8 then local jT=0;if eP(cH)>1 then jT=45*math.log(eP(cH),10)if cH<0 then jT=-jT end end;jS[#jS+1]=d9([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bH(cH),bH(jT))end;return jS end;local function jU(jV)local gi=-cG;jV=jV-jV:project_on(gi)local jW=vec3(0,0,1)jW=jW-jW:project_on(gi)local jX=jW:cross(gi)local jT=jW:angle_between(jV)*constants.rad2deg;if jV:dot(jX)<0 then jT=360-jT end;return jT end;local function jY(jS,ai,aj,jZ,j_,cS)if ab==0 then return end;local k0=ab;local k1=20;local k2=bH(jZ)if cS then for K=-45,45,5 do local k3=K;jS[#jS+1]=d9([[<g transform="rotate(%f,%d,%d)">]],k3,ai,aj)k4=5;if K%15==0 then k4=15 elseif K%10==0 then k4=10 end;jS[#jS+1]=d9([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+k0+k1-k4,ai,aj+k0+k1)end;jS[#jS+1]=gE(ai,aj+k0+k1-35,j_,"pdim txt txtmid")jS[#jS+1]=gE(ai,aj+k0+k1-25,k2 .." deg","pdim txt txtmid")jS[#jS+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jZ,ai,aj)jS[#jS+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+k0+k1-20,ai+5,aj+k0+k1-20,ai,aj+k0+k1-15)jS[#jS+1]="</g>"end;jS[#jS+1]=[[<g style="clip-path: url(#headingClip);">]]local k5=k2;if cS then k5=jU(cB)end;local k6=20;local k7=bH(k5)local k8=0;local k9=aj+k0+k1+20;local ka=ai;if j_~="YAW"then k9=j9(130)ka=j8(960)end;local kb=[[<path class="txttick line" d="]]local kc=bH(k7-(k6+10)-k7%5+0.5)for K=kc+70,kc,-5 do local hf=ka-(-K*5+k5*5)if K%10==0 then k8=10;local ds=K;if ds==360 then ds=0 elseif ds>360 then ds=ds-360 elseif ds<0 then ds=ds+360 end;jS[#jS+1]=gE(hf,k9+15,ds,"txtmid bright")elseif K%5==0 then k8=5 end;if k8==10 then kb=d9([[%s M %f %f v %d]],kb,hf,k9-5,k8)else kb=d9([[%s M %f %f v %d]],kb,hf,k9-2.5,k8)end end;jS[#jS+1]=kb..[["/>]]jS[#jS+1]=d9([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],ka-5,k9-20,ka+5,k9-20,ka,k9-10)if I then if cS then j_="HDG"end;jS[#jS+1]=gE(j8(960),j9(100),k7 .."°","dim txt txtmid size14","")jS[#jS+1]=gE(j8(960),j9(85),j_,"dim txt txtmid size20","")end;jS[#jS+1]=[[</g>]]end;local function kd(jS,ke,jZ,ai,aj,cS,kf,fg)if ab==0 then return end;local k0=ab;local kg=bH(k0*3/5)if k0>0 then local kh=bH(ke)local k4=0;local kb=d9([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jZ,ai,aj)if not c8 then kb=d9([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jS[#jS+1]=d9([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k0-1,ai,aj)jS[#jS+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bH(kh-30-kh%5+0.5),bH(kh+30+kh%5+0.5),5 do if K%10==0 then k4=30 elseif K%5==0 then k4=20 end;local hg=aj+-K*5+ke*5;if k4==30 then kb=d9([[%s M %d %f h %d]],kb,ai-kg-k4,hg,k4)if c8 then jS[#jS+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jZ,ai,aj,ai-kg+10,hg+4,K)jS[#jS+1]=d9([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jZ,ai,aj,ai+kg-10,hg+4,K)if K==0 or K==180 or K==-180 then jS[#jS+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jZ,ai,aj,ai-kg+20,hg,kg*2-40)end else jS[#jS+1]=gE(ai-kg+10,hg,K,"pdim txt txtmid")jS[#jS+1]=gE(ai+kg-10,hg,K,"pdim txt txtmid")end;kb=d9([[%s M %d %f h %d]],kb,ai+kg,hg,k4)else kb=d9([[%s M %d %f h %d]],kb,ai-kg-k4,hg,k4)kb=d9([[%s M %d %f h %d]],kb,ai+kg,hg,k4)end end;jS[#jS+1]=kb..[["/>]]local ki="PITCH"if not cS then ki="REL PITCH"end;if ke>90 and not c8 then ke=90-(ke-90)elseif ke<-90 and not c8 then ke=-90-(ke+90)end;if k0>200 then if c8 then if fg>iL then jS[#jS+1]=gE(ai,aj-15,"Yaw","pdim txt txtmid")jS[#jS+1]=gE(ai,aj+20,kf,"pdim txt txtmid")end;jS[#jS+1]=d9([[<g transform="rotate(%f,%d,%d)">]],-jZ,ai,aj)else jS[#jS+1]=d9([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jS[#jS+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-kg+25,aj-5,ai-kg+20,aj,ai-kg+25,aj+5,ai-kg+50,aj+4,kh)jS[#jS+1]=d9([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+kg-25,aj-5,ai+kg-20,aj,ai+kg-25,aj+5,ai+kg-30,aj+4,kh)jS[#jS+1]="</g>"end;local kj=bH(k0/3)jS[#jS+1]=d9([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kj,aj,k0-kj)if not c8 and cS then jS[#jS+1]=d9([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jZ,ai,aj,ai-kg+10,aj,kg*2-20)end;jS[#jS+1]="</g>"if k0<200 then if c8 and fg>iL then jS[#jS+1]=gE(ai,aj-k0,ki,"pdim txt txtmid")jS[#jS+1]=gE(ai,aj-k0+10,kh,"pdim txt txtmid")jS[#jS+1]=gE(ai,aj-15,"Yaw","pdim txt txtmid")jS[#jS+1]=gE(ai,aj+20,kf,"pdim txt txtmid")else jS[#jS+1]=gE(ai,aj-k0,ki,"pdim txt txtmid")jS[#jS+1]=gE(ai,aj-k0+15,kh,"pdim txt txtmid")end end end end;local function kk(jS,dU,cS)local kl=ao;local km=ap;if kl==0 and km==0 then return end;local kn=78;local ko=19;local kp=c7;if c7~=-1 then jS[#jS+1]=gE(kl+kn,km+ko+20,d9("AGL: %.1fm",c7),"pdim altsm txtend")end;if cS and(dU<200000 and not c8 or dU and c8)then table.insert(jS,d9([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kl-1,km-4,kn+2,ko+6,kl+1,km-1,kn-4,ko))local gn=0;local kq=1;local kr=0;local ks=dU<0;local kt=dU<j7.surfaceMaxAltitude;local ku=9;if ks then ku=0 end;local dU=eP(dU)while gn<6 do local kv=11;local kw=16;local kx=9;local ky=14;local jM="altsm"if gn>2 then kw=kw+3;kv=kv+2;ky=ky+2;kx=kx-6;jM="altbig"end;if ks then jM=jM.." red"elseif kt then jM=jM.." orange"end;local kz=dU/kq%10;local kA=bH(kz)local kB=bH((kA+1)%10)local kC=kr;if gn==0 then kC=kz-kA;if ks then kC=1-kC end end;if ks and(gn==0 or kr~=0)then local gq=kB;kB=kA;kA=gq end;local kD=kw*(kC-1)local kE=kD+kw;local hf=kl+kx+(6-gn)*kv;local hg=km+ky;jS[#jS+1]=gE(hf,hg+kD,kB,jM)jS[#jS+1]=gE(hf,hg+kE,kA,jM)gn=gn+1;kq=kq*10;if kA==ku then kr=kC else kr=0 end end;table.insert(jS,[[</g></g>]])end end;local function kF(fl)local kG=-math.deg(eK(fl.y,fl.z))+180;kG=kG-90;if kG<0 then kG=360+kG end;if kG>180 then kG=-180+kG-180 end;return-kG end;local function kH(fl)local k5=math.deg(eK(fl.y,fl.x))-90;if k5<-180 then k5=360+k5 end;return k5 end;local function kI(jS,fl,fg,ai,aj)if fg>5 and not c8 or fg>iL then local k0=ab;local kJ=20;local kK=20;local kL=kF(fl)local kM=kH(fl)local kN=14;local kO=kN/2;local kP=-kM/kK*k0;local kQ=kL/kJ*k0;local hf=ai+kP;local hg=aj+kQ;local c3=dc(kP^2+kQ^2)local kR=[[<circle
                            cx="]]..hf..[["
                            cy="]]..hg..[["
                            r="]]..kO/kN..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hf..[["
                            cy="]]..hg..[["
                            r="]]..kO..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hf-kN..[[,]]..hg..[[ h ]]..kO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hf+kO..[[,]]..hg..[[ h ]]..kO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hf..[[,]]..hg-kN..[[ v ]]..kO..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c3<k0 then jS[#jS+1]=kR else local jT=eK(kQ,kP)local kS=4;local kT=ai+k0*math.cos(jT)local kU=aj+k0*math.sin(jT)jS[#jS+1]=d9('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jT*180/math.pi,kT,kU,kT-kS,kU-kS/2,kS*2,kS,kT+kS,kU-kS,kS,kS,-kS,kS)end;if not c8 then local kV=vec3(fl)kL=kF(-kV)kM=kH(-kV)kP=-kM/kK*k0;kQ=kL/kJ*k0;hf=ai+kP;hg=aj+kQ;c3=dc(kP^2+kQ^2)if c3<k0 then local kW=[[<circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hf..[[,]]..hg-kN..[[ v ]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hf..[[,]]..hg..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hf..[[,]]..hg..[[)" />
                                <path
                                    d="M ]]..hf-kO..[[,]]..hg..[[ h ]]..kN..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hf..[[,]]..hg..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hf..[[,]]..hg..[[)"/>]]jS[#jS+1]=kW end end end end;local function kX(jS,jc,kY,kZ)if ak==0 and al==0 then return end;kY=bH(kY+0.5)local jC=al+10;local jD=al+20;if ir()==1 and not l then jC=55;jD=65 end;local k_="CRUISE"local c="km/h"local dB=kZ;if jc=="TRAVEL"or jc=="AUTOPILOT"then k_="THROT"c="%"dB=kY;local l0="dim"if kY<0 then l0="red"end;jS[#jS+1]=d9([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l0,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eP(kY),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jS[#jS+1]=gE(ak+10,jC,k_,"pbright txtstart")jS[#jS+1]=gE(ak+10,jD,d9("%.0f %s",dB,c),"pbright txtstart")if c8 and t and cL and bM then kY=bH(bN*100+0.5)local l0="red"if kY<0 then l0="red"end;jS[#jS+1]=d9([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l0,1-eP(kY),ak-10,al+50,ak-15,al+53,ak-15,al+47)jS[#jS+1]=gE(ak+10,jC+40,"LIMIT","pbright txtstart")jS[#jS+1]=gE(ak+10,jD+40,kY.."%","pbright txtstart")end;if c8 and t or b5 then jS[#jS+1]=gE(ak+10,jC-40,"LIMIT: "..cv.." km/h","dim txtstart")elseif not c8 and b0 then jS[#jS+1]=gE(ak+10,jC-40,"LIMIT: "..bH(_*3.6+0.5).." km/h","dim txtstart")end end;local function l1(jS,l2)if ak==0 and al==0 then return end;local l3=al-10;local l4=ak+10;jS[#jS+1]=gE(0,0,"","pdim txt txtend")if ir()==1 and not l then l3=75 end;jS[#jS+1]=gE(l4,l3,bH(l2).." km/h","pbright txtbig txtstart")end;local function l5(jS)jS[#jS+1]=gE(j8(1900),j9(1070),d9("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jS[#jS+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jS[#jS+1]=gE(j8(960),j9(550),"Warning: Invalid Control Scheme Detected","warnings")jS[#jS+1]=gE(j8(960),j9(600),"Keyboard Scheme must be selected","warnings")jS[#jS+1]=gE(j8(960),j9(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l6=j8(960)local l7=j9(860)local l8=j9(880)local l9=j9(900)local la=j9(960)local lb=j9(200)local lc=j9(250)local ld=j9(960)if ir()==1 and not l then l7=j9(135)l8=j9(155)l9=j9(175)lb=j9(115)lc=j9(95)end;local le="#222222"local lf="white"local lg="dimmer"local lh="pbright"local li="#110000"local lj=le;local lk=lg;if aY then local ll=""if type(aY)=="string"then ll="-"..aY end;jS[#jS+1]=gE(l6,l7,"Brake Engaged"..ll,"warnings")li="#440000"lj=lf;lk=lh elseif bL>0 then jS[#jS+1]=gE(l6,l7,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local lm="#110000"local ln=le;local lo=lg;if c8 and cu and c7==-1 then if not b0 and not bn and not b3 and not cK and not b6 and not b4 then jS[#jS+1]=gE(l6,lb+50,"** STALL WARNING **","warnings")lm="#ff0000"ln=lf;lo=lh;fL("stall","SW",2)end end;if cR then jS[#jS+1]=gE(l6,lb+90,"Flight Assist in Progress","warnings")end;if cc then jS[#jS+1]=gE(l6,ld,"Gyro Enabled","warnings")end;local lp="#111100"local lq=le;local lr=lg;if bj then lp="#775500"lq=lf;lr=lh;if bP then jS[#jS+1]=gE(l6,l8,"Gear Extended","warn")else jS[#jS+1]=gE(l6,l8,"Landed (G: Takeoff)","warnings")end;local ls=iw(d:getTargetGroundAltitude())jS[#jS+1]=gE(l6,l9,"Hover Height: "..ls,"warn")end;local lt="#000011"local lu=le;local lv=lg;if bY then lt="#0000DD"lu=lf;lv=lh;jS[#jS+1]=gE(l6,la+20,"ROCKET BOOST ENABLED","warn")end;local lw="#001100"local lx=le;local ly=lg;if antigrav and not q and cK and bs~=nil then lw="#00DD00"lx=lf;ly=lh;local lz="warnings"if eP(ca-antigrav.getBaseAltitude())<501 then lz="warn"end;jS[#jS+1]=gE(l6,lb+40,d9("Target Altitude: %d Singularity Altitude: %d",bH(bs),bH(antigrav.getBaseAltitude())),lz)end;if b0 and bg~="None"then jS[#jS+1]=gE(l6,lb,"Autopilot "..bd,"warn")elseif bq~=nil then jS[#jS+1]=gE(l6,lb+20,d9("LockedPitch: %d",bH(bq)),"warn")elseif bU then jS[#jS+1]=gE(l6,lb+20,"Follow Mode Engaged","warn")elseif b5 or c6 then jS[#jS+1]=gE(l6,lb+20,"Re-entry in Progress","warn")end;if b2 or b6 then local ls=iw(b7,2)if b6 then if cK then ls=iw(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jS[#jS+1]=gE(l6,lb,"VTO to "..ls,"warn")elseif b4 and not bw then if c5 then jS[#jS+1]=gE(l6,lb,"Takeoff to "..bg,"warn")else jS[#jS+1]=gE(l6,lb,"Takeoff to "..ls,"warn")end;if aY and not b6 then jS[#jS+1]=gE(l6,lb+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jS[#jS+1]=gE(l6,lb,"Altitude Hold: "..d9("%.1fm",b7),"warn")end end;if b6 and(antigrav~=nil and antigrav)then if c9>0.1 then jS[#jS+1]=gE(l6,lb+20,"Beginning ascent","warn")elseif c9<0.09 and c9>0.05 then jS[#jS+1]=gE(l6,lb+20,"Aligning trajectory","warn")elseif c9<0.05 then jS[#jS+1]=gE(l6,lb+20,"Leaving atmosphere","warn")end end;if bw then if cw~=nil then jS[#jS+1]=gE(l6,lb,cw,"warn")end end;if b3 then if lA then local lB="Brake Landing"if d6 then lB=lB.."-Aligning"end;if d5 then lB=lB.."-Drift Limited"end;jS[#jS+1]=gE(l6,lb,lB,"warnings")else jS[#jS+1]=gE(l6,lb,"Coast-Landing","warnings")end end;if a_ then jS[#jS+1]=gE(l6,lb,"Prograde Alignment","crit")end;if aZ then jS[#jS+1]=gE(l6,lb,"Retrograde Alignment","crit")end;local lC="#110000"local lD=le;local lE=lg;if cT then lC="#FF0000"lD=lf;lE=lh;local type;if string.find(cT,"COLLISION")then type="warnings"else type="crit"end;jS[#jS+1]=gE(l6,lc+20,cT,type)elseif c9==0 then local lF,lG=cn.checkLOS(cE:normalize())if lG~=nil then lE=lh;lC="#FF0000"lD=lf;local ls=iw(lG)local lH=cj.computeTravelTime(cF,0,lG)local lI="Collision"if lF.noAtmosphericDensityAltitude>0 then lI="Atmosphere"end;jS[#jS+1]=gE(l6,lc+20,lF.name.." "..lI.." "..ix(lH).." In "..ls,"crit")end end;if bn and not bw then jS[#jS+1]=gE(l6,lb+60,lJ,"warn")end;local lK="#111100"local lL=le;local lM=lg;if cX and#cX>1 then lK="#DDDD00"lL=lf;lM=lh end;local lN=j8;local lO=j9;local lg="topButton"local lP="topButtonActive"local lQ=lg;if b0 or bn or c5 or bw then lQ=lP end;local lR=lg;if a_ then lR=lP end;local lS=lg;if b3 or bj then lS=lP end;local lT=lg;if b2 or bn then lT=lP end;local lU=lg;if aZ then lU=lP end;local lV=lg;if bw or cy and b0 then lV=lP end;if w and I then local lW=lO(30)jS[#jS+1]=d9([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lN(960),lO(54),lO(-53),lN(-120),lN(25),lO(50))jS[#jS+1]=gE(lN(910),lW,"AUTOPILOT")jS[#jS+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lN(865),lO(51),lN(-25),lO(-50),lN(-110),lN(25),lO(46))jS[#jS+1]=gE(lN(800),lW,"PROGRADE")jS[#jS+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lS,lN(755),lO(47),lN(-25),lO(-46),lN(-98),lN(44),lO(44))jS[#jS+1]=gE(lN(700),lW,"LAND")jS[#jS+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lT,lN(960),lO(54),lO(-53),lN(120),lN(-25),lO(50))jS[#jS+1]=gE(lN(1010),lW,"ALT HOLD")jS[#jS+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lU,lN(1055),lO(51),lN(25),lO(-50),lN(110),lN(-25),lO(46))jS[#jS+1]=gE(lN(1122),lW,"RETROGRADE")jS[#jS+1]=d9([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lV,lN(1165),lO(47),lN(25),lO(-46),lN(98),lN(-44),lO(44))jS[#jS+1]=gE(lN(1220),lW,"ORBIT")jS[#jS+1]=[[
                                    </g>
                                </g>]]jS[#jS+1]="</g>"end;return jS end;local function lX(fg)return bH(fM(fg*3.6,0)+0.5).." km/h"end;local function lY(gn)local gp=bg;if gn~=nil and type(gn)=="number"then if gn==0 then return"None"end;gp=cO[gn].name end;if gp==nil then gp=fX.name end;if gp==nil then gp="None"end;return gp end;local function lZ(jS)local l_=cn.routeWP(true)if not l_ or#l_==0 then return end;local hf=j8(750)local hg=j9(360)if b0 or bn then jS[#jS+1]=gE(hf,hg,"REMAINING ROUTE","pdim txtstart size20")else jS[#jS+1]=gE(hf,hg,"LOADED ROUTE","pdim txtstart size20")end;for dA,K in pairs(l_)do hg=hg+20;jS[#jS+1]=gE(hf,hg,dA..". "..l_[dA],"pdim txtstart size20")end end;local function m0(jS)local hf=aw+10;local hg=ax+20;local m1={}local m2={"Alt-4: AutoTakeoff to Target"}local m3={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m4={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local m5={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(m1,"--------------DYNAMIC-----------------")if c8 then if c7~=-1 then iu(m1,m2)if c0 and j7 and c0.name==j7.name then table.insert(m1,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aX then if antigrav then if cK then table.insert(m1,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(m1,"Turn on AGG to takeoff to AGG Height")end end;if aX then table.insert(m1,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(m1,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(m1,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bj then table.insert(m1,"G: Takeoff to hover height, raise gear")else table.insert(m1,"G: Lowergear and Land")end else iu(m1,m3)table.insert(m1,"G: Begin BrakeLanding or Land")end;if b6 then table.insert(m1,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iu(m1,m4)if shield_1 then table.insert(m1,"Alt-Shift-6: Vent shields")if not G then table.insert(m1,"Alt-Shift-7: Toggle shield off/on")end end end;if fX~=nil then table.insert(m1,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(m1,"Alt-9: Activate Gyroscope")end;if aT~="none"or aS~="none"or aU~="none"then table.insert(m1,"Alt-Shift-9: Cycles engines with Extra tags")end;if b2 then table.insert(m1,"Alt-Spacebar/C will raise/lower target height")table.insert(m1,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c8 then table.insert(m1,"LALT+Mousewheel will lower/raise speed limit")end;iu(m1,m5)for K=1,#m1 do hg=hg+12;jS[#jS+1]=gE(hf,hg,m1[K],"pdim txtbig txtstart")end end;local function m6(jS)local m7=aw;local m8=ax;local m9=av;local ma=4;local mb=15;local hf=0;local hg=0;local mc,md,me,mf;local mg;local function mh(type)local gz,bJ,fg,mi,jM,mj;if type=="Periapsis"then gz=mg.periapsis.altitude;bJ=mg.timeToPeriapsis;fg=mg.periapsis.speed;jM="txtend"mi=12;mj=math.min(hf,m7+m9-j7.radius/me-ma*2)else gz=mg.apoapsis.altitude;bJ=mg.timeToApoapsis;fg=mg.apoapsis.speed;mi=-12;jM="txtstart"mj=hf end;if cF<1 then bJ=0 end;jS[#jS+1]=d9([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mj+mi,hg-5,hf,hg-5)jS[#jS+1]=d9([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mj-mi*4,hg+2,hf,hg+2)jS[#jS+1]=gE(mj,hg,type,jM)hf=mj-mi*2;hg=hg+mb;local ls=iw(gz)jS[#jS+1]=gE(hf,hg,ls,jM)hg=hg+mb;jS[#jS+1]=gE(hf,hg,ix(bJ),jM)hg=hg+mb;jS[#jS+1]=gE(hf,hg,lX(fg),jM)end;local mk=m9*1.5;if bE=="INFO"then mk=25*9 end;if bE~="HIDE"then jS[#jS+1]=[[<g class="pbright txtorb txtmid">]]jS[#jS+1]=d9('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m9*2,mk,m7,m8)jS[#jS+1]=d9([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m9*2,mk,m7,m8)end;local ml=m9*1.5;local mm=m9*2;local mn=ml/2;local mo=m9;local mp=m7+mo;local mq=m8+mn;local mr=m7+mm;local ms=m8+ml;if bE=="ORBIT"then m8=m8+ma;mc=m9/2;mf=0;mg={}mg.periapsis={}mg.apoapsis={}if fk~=nil then if fk.periapsis~=nil then mg.periapsis.altitude=fk.periapsis.altitude;mg.periapsis.speed=fk.periapsis.speed end;if fk.apoapsis~=nil then mg.apoapsis.altitude=fk.apoapsis.altitude;mg.apoapsis.speed=fk.apoapsis.speed end;mg.period=fk.period;mg.eccentricity=fk.eccentricity;mg.timeToApoapsis=fk.timeToApoapsis;mg.timeToPeriapsis=fk.timeToPeriapsis;mg.eccentricAnomaly=fk.eccentricAnomaly;mg.trueAnomaly=fk.trueAnomaly end;if mg.periapsis==nil then mg.periapsis={}mg.periapsis.altitude=-j7.radius;mg.periapsis.speed=_ end;if mg.eccentricity==nil then mg.eccentricity=1 end;if mg.apoapsis==nil then mg.apoapsis={}mg.apoapsis.altitude=ca;mg.apoapsis.speed=0 end;if cF<1 then mg.apoapsis.altitude=ca;mg.apoapsis.speed=0 end;if mg.apoapsis.altitude then me=(mg.apoapsis.altitude+mg.periapsis.altitude+j7.radius*2)/(mc*2)md=(j7.radius+mg.apoapsis.altitude)/me*(1-mg.eccentricity)mf=mc-mg.periapsis.altitude/me-j7.radius/me;local mt=math.pi;if mg.period~=nil and mg.period>0 and mg.timeToApoapsis~=nil then mt=mg.eccentricAnomaly;if mg.timeToPeriapsis<mg.timeToApoapsis then mt=2*math.pi-mt end end;if cF<1 or mt~=mt then mt=math.pi end;local mu=-mc*math.cos(mt)+m7+mo+ma;local mv=md*math.sin(mt)+m8+mn+ma;local mw=""jS[#jS+1]='<g clip-path="url(#orbitRect)">'jS[#jS+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mw,m7+m9+ma,m8+m9*1.5/2+ma,mc,md)if md<1 then jS[#jS+1]=d9([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m7+m9+ma-mf,m8+m9*1.5/2+ma,mu,mv)end;jS[#jS+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m7+m9+ma-mf,m8+m9*1.5/2+ma,(j7.radius+j7.noAtmosphericDensityAltitude)/me)jS[#jS+1]=d9('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m7+m9+ma-mf,m8+m9*1.5/2+ma,(j7.radius+j7.noAtmosphericDensityAltitude)/me)jS[#jS+1]=d9([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m7+m9+ma,m8+m9*1.5/2+ma,mc,md)jS[#jS+1]=d9('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m7+m9+ma-mf,m8+m9*1.5/2+ma,j7.radius/me)jS[#jS+1]='</g>'local mx=math.floor(j7.radius/me+0.5)hf=m7+m9+ma*4+mc;hg=m8+m9*1.5/2+5+ma;if mg.apoapsis~=nil and mg.apoapsis.speed<_ then mh("Apoapsis")end;hg=m8+m9*1.5/2+5+ma;hf=m7+m9-ma*2-mc;if mg.periapsis~=nil and mg.periapsis.speed<_ and mg.periapsis.altitude>0 then mh("Periapsis")end;jS[#jS+1]=gE(m7+m9+ma,m8+20+ma,j7.name,"txtorbbig")jS[#jS+1]=d9('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mu,mv)jS[#jS+1]=[[</g>]]return jS else jS[#jS+1]='<g clip-path="url(#orbitRect)">'local my=""local mz=1.2*(mA-mB)/(m9*2)local mC=1.4*(mD-mE)/(m9*1.5)for dA,dl in pairs(e[0])do if dl.center then local hf=m7+m9+dl.center.x/mz;local hg=m8+m9*1.5/2+dl.center.y/mC;my=my..'<circle cx="'..hf..'" cy="'..hg..'" r="'..dl.radius/mz*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dl.name,"Moon")and not string.match(dl.name,"Sanctuary")and not string.match(dl.name,"Space")then my=my.."<text x='"..hf.."' y='"..hg+dl.radius/mz*30+20 .."' font-size='12' fill="..iT.." text-anchor='middle' font-family='Montserrat'>"..dl.name.."</text>"end end end;local fm=vec3(b.getConstructWorldPos())local hf=m7+m9+fm.x/mz;local hg=m8+m9*1.5/2+fm.y/mC;my=my..'<circle cx="'..hf..'" cy="'..hg..'" r="2" stroke="white" stroke-width="1" fill="red"/>'my=my.."<text x='"..hf.."' y='"..hg-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iF=mz;iG=mC;local mF=fm+cE*1000000;local mG=m7+m9+mF.x/mz;local jD=m8+m9*1.5/2+mF.y/mC;my=my..'<line x1="'..hf..'" y1="'..hg..'" x2="'..mG..'" y2="'..jD..'" stroke="purple" stroke-width="1"/>'jS[#jS+1]=my;jS[#jS+1]='</g>'end elseif bE=="INFO"then jS=cl.DrawOdometer(jS,iV,bk,iW)elseif bE=="HELP"then jS=m0(jS)elseif bE=="SCOPE"then jS[#jS+1]='<g clip-path="url(#orbitRect)">'local mH=c_;if c9>0 then table.sort(cZ,function(eq,er)local es,et=eq.center,er.center;return(es.x-cI.x)^2+(es.y-cI.y)^2+(es.z-cI.z)^2<(et.x-cI.x)^2+(et.y-cI.y)^2+(et.z-cI.z)^2 end)end;local gM={}local mI={}local mJ=120;local mK=nil;local mL=nil;for K,dl in ipairs(cZ)do local gL=dl.center-cI;local mM=gL:len()local mN=gL:normalize()local mO=gL:cross(cB):normalize()local mP=math.acos(mO:dot(cC))if mP~=mP then mP=0 end;if mO:cross(cC):dot(cB)<0 then mP=-mP end;local mQ=gL:project_on_plane(cB):len()local mR=math.sin(mP)*math.asin(mQ/mM)*constants.rad2deg;local mS=math.cos(mP)*math.asin(mQ/mM)*constants.rad2deg;if mN:dot(cB)<0 then mS=90*math.cos(mP)+90*math.cos(mP)-mS;mR=90*math.sin(mP)+90*math.sin(mP)-mR end;local hf=mp+mR/mH*ml;local hg=mq+mS/mH*ml;local mT=(hf-mp)*(hf-mp)+(hg-mq)*(hg-mq)local mU=math.asin((dl.radius+dl.surfaceMaxAltitude)/mM)*constants.rad2deg;if mU~=mU then mU=mH end;local hL=mU/mH*ml;local mV=math.asin(dl.atmosphereRadius/mM)*constants.rad2deg;if mV~=mV then mV=mU end;local mW=mV/mH*ml;local c3=iw(mM,1)local mX=dl.name;local mY=false;if hg>m8 then if hg>ms then if hg-mW<=ms then mY=true end else mY=true end else if hg+mW>=m8 then mY=true end end;local mZ=false;local m_=hf;if dl.systemId==0 then m_=hf+mJ else m_=hf-mJ end;if m_+mJ>m7 then if m_+mJ>mr then if m_-mW-mJ<=mr then mZ=true end else mZ=true end else if m_+mW+mJ>=m7 then mZ=true end end;local n0={}n0.x=hf;n0.y=hg;n0.planet=dl;n0.atmoSize=mW;if not mK or mT<mK then mK=mT;mL=n0 end;if mZ and mY then local n1=math.max(mW,5)if mT<n1*n1 then mX=mX.." - "..c3 end;n0.size=hL;n0.i=K;n0.displayString=mX;n0.distance=c3;n0.visible=true;mI[#mI+1]=n0 else n0.visible=false end end;local n2=false;table.sort(mI,function(es,et)return es.y<et.y end)for dA,fp in ipairs(mI)do local dl,hL,K,mW,hf,hg,mX,c3=fp.planet,fp.size,fp.i,fp.atmoSize,fp.x,fp.y,fp.displayString,fp.distance;local mj,n3,n4,n5;local n6=15;local jM="pdim"if dl.systemId~=0 then n4=j8(string.len(mX)*5)n6=-(15+n4)n5=j9(10)jM="pdimfill"else n4=j8(string.len(mX)*9)n5=j9(15)end;if hL*2>n4 then mj=da(hf,m7+n4/2,mr-n4/2)n3=da(hg,m8+n5,ms-5)mj=da(mj,hf-hL+n4/2,hf+hL-n4/2)n3=da(n3,hg-hL+n5,hg+hL)else mj=hf+n6;n3=hg end;for n7,fp in pairs(gM)do local n8=fp.textPositions;local n9=n8.y-n3;if n7~=K and eP(n9)<n8.height and n8.x+n8.width>mj and n8.x<mj+n4 then if hL>n4 then n3=da(n3+n5,m8+15,ms-5)else n3=n8.y+n8.height+1 end end end;local na=mX~=dl.name or mj<=mp and mj+n4>=mp and n3-n5<=mq and n3>=mq;fp.hovered=na;local nb=1;if na then nb=2;if hL*2<n4 then nb=10 end;if mX==dl.name then mX=mX.." - "..c3 end;jM="pbright"if dl.systemId~=0 then n4=j8(string.len(mX)*5)n6=-(15+n4)else n4=j8(string.len(mX)*7)end;if hL*2>n4 then mj=da(hf,m7+n4/2,mr-n4/2)mj=da(mj,hf-hL+n4/2,hf+hL-n4/2)else mj=hf+n6 end end;gM[K]={}gM[K].textPositions={}gM[K].textPositions.y=n3;gM[K].textPositions.x=mj;gM[K].textPositions.width=n4;gM[K].textPositions.height=n5;gM[K].output=""if hL*2>n4 then jM=jM.." txtmid"else jM=jM.." txtstart"end;if mW-hL>2 then gM[K].output=d9('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hf,hg,mW,iU,0.1*nb)end;gM[K].output=gM[K].output..d9('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hf,hg,hL,iU,0.2*nb)if dl.systemId==0 then gM[K].output=gM[K].output..d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mj,n3,iT,jM,mX)if hL*2<=n4 then gM[K].output=gM[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mj+n4,n3+2,mj,n3+2,hf,hg)end else gM[K].output=gM[K].output..d9([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mj,n3,iU,jM,mX)if hL*2<=n4 then gM[K].output=gM[K].output..d9("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mj,n3+2,mj+n4,n3+2,hf,hg)end end end;for dA=#cZ,1,-1 do if gM[dA]then jS[#jS+1]=gM[dA].output end end;if mL~=nil and c_<90 and not mL.hovered then local nc=mL.planet.atmosphereRadius/mL.atmoSize;local nd=dc(mK)*nc;local ne=iw(nd,1)local n4=j8(math.max(string.len(ne)*7,string.len(mL.planet.name)*7))local n5=j9(12)local mj=da(mL.x+(mp-mL.x)/2,m7+n4/2,mr-n4/2)local n3=da(mL.y+(mq-mL.y)/2,m8+n5*2,ms-5)jS[#jS+1]=d9("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mL.x,mL.y,mp,mq)jS[#jS+1]=d9([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mj,n3,"white",ne)if not mL.visible then jS[#jS+1]=d9([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mj,n3-n5,"white",mL.planet.name)end end;if cF>1 then local gL=cE;local mN=gL:normalize()local mQ=gL:project_on_plane(cB):len()local mO=gL:cross(cB):normalize()local mP=math.acos(mO:dot(cC))if mP~=mP then mP=0 end;if mO:cross(cC):dot(cB)<0 then mP=-mP end;local mR=math.sin(mP)*math.asin(mQ/gL:len())*constants.rad2deg;local mS=math.cos(mP)*math.asin(mQ/gL:len())*constants.rad2deg;if mN:dot(cB)<0 then mS=90*math.cos(mP)+90*math.cos(mP)-mS;mR=90*math.sin(mP)+90*math.sin(mP)-mR end;local hf=mp+mR/mH*ml;local hg=mq+mS/mH*ml;local kN=14;local kO=kN/2;local kR=[[<circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kO/kN..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hf..[["
                                    cy="]]..hg..[["
                                    r="]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hf-kN..[[,]]..hg..[[ h ]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hf+kO..[[,]]..hg..[[ h ]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hf..[[,]]..hg-kN..[[ v ]]..kO..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jS[#jS+1]=kR end;jS[#jS+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mp,mq-10,mp,mq+10)jS[#jS+1]=d9("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mp-10,mq,mp+10,mq)jS[#jS+1]='</g>'else return jS end end;local function nf(ng,nh)local ni;local nj=(nh-ng):normalize()local fn=(cI-ng):dot(nj)/nj:dot(nj)if fn<=0. then return(cI-ng):len()elseif fn>=(nh-ng):len()then return(cI-nh):len()end;local nk=ng+fn*nj;ni=(nk-cI):len()return ni end;local function nl()local ni;local nm=nil;local nn=nil;local no=nil;for dA,np in pairs(e[0])do if np.hasAtmosphere then local c3=nf(j7.center,np.center)if nm==nil or c3<nm then nn=np;nm=c3;no=j7 end;if c0 and c0.hasAtmosphere and c0.name~=j7.name then local eF=nf(c0.center,np.center)if eF<nm then nn=np;nm=eF;no=c0 end end end end;local nq=j8(1770)local nr=j9(330)if nm then local ns="txttick "local nt=500000;if nm<nn.radius+nt or nm<no.radius+nt then if cP then ns="txttick red "else ns="txttick orange "end end;ni=iw(nm,2)iK=gE(nq,nr,"Pipe ("..no.name.."--"..nn.name.."): "..ni,ns.."pbright txtmid")end end;local function nu(hf,hg,nv,nw,k_)local nx={x=hf,y=hg,width=nv,height=nw,label=k_}iE[k_]=nx;return nx end;local function ny(nz,nA,nv,nw,hf,hg,nB,nC,nD,nE,jM)local nx={enableName=nz,disableName=nA,width=nv,height=nw,x=hf,y=hg,toggleVar=nB,toggleFunction=nC,drawCondition=nD,hovered=false,class=jM}if nE then table.insert(iD,nx)else table.insert(iC,nx)end;return nx end;local function nF(nG)if not iI then nH=false;nI=false;nJ=false;w=true;return elseif nG=="handling"then nH=not nH;nI=false;nJ=false elseif nG=="hud"then nI=not nI;nH=false;nJ=false elseif nG=="physics"then nJ=not nJ;nH=false;nI=false end;if nJ or nI or nH then iJ=iv(nG)w=false else iJ="none"w=true end end;local function nK()iI=not iI;if iI then iB=iD;bW="Hold SHIFT to see Settings"d0=w else iB=iC;bW="Hold SHIFT to see Control Buttons"nF()w=d0 end end;local function nL()local function nM(dl,dA)dl.set(not dl.get())if dl.get()then bW=dA.." set to true"else bW=dA.." set to false"end;if dA=="showHud"then d0=dl.get()elseif dA=="BrakeToggleDefault"then aW=j end end;local nN=50;local nO=340;local hf=500;local hg=ce/2-400;local nP=0;for dA,dl in pairs(iv("boolean"))do if type(dl.get())=="boolean"then ny(dA,dA,nO,nN,hf,hg,function()return dl.get()end,function()nM(dl,dA)end,function()return true end,true)hg=hg+nN+20;if nP==9 then hf=hf+nO+20;hg=ce/2-400;nP=0 else nP=nP+1 end end end;ny("Control View","Control View",nO,nN,10,ce/2-500,function()return true end,nK,function()return true end,true)ny("View Handling Settings",'Hide Handling Settings',nO,nN,10,ce/2-(500-nN),function()return nH end,function()nF("handling")end,function()return true end,true)ny("View Hud Settings",'Hide Hud Settings',nO,nN,10,ce/2-(500-nN*2),function()return nI end,function()nF("hud")end,function()return true end,true)ny("View Physics Settings",'Hide Physics Settings',nO,nN,10,ce/2-(500-nN*3),function()return nJ end,function()nF("physics")end,function()return true end,true)end;local function nQ()local function go()local fO=cI;local gp=j7.name..". "..#bm;if radar_1 then gp=co.GetClosestName(gp)end;return cm.AddNewLocation(gp,fO,false,true)end;local function nR()b1=not b1 end;local function nS(nT)if nT==1 then a_=not a_;aZ=false else aZ=not aZ;a_=false end;b0=false;b2=false;bU=false;b3=false;bq=nil;b5=false;b4=false end;local function nU(nV,nW)cm.UpdatePosition(nil,nV,nW)end;local function gj()cm.ClearCurrentPosition()end;local function nX(gn)local l_=cn.routeWP(true)if l_ and#l_>0 then return"Engage Route: "..l_[1]end;return"Engage Autopilot: "..lY(gn)end;local function nY(gn)local l_=cn.routeWP(true)if l_ and#l_>0 then return"Next Route Point: "..l_[1]end;return"Disable Autopilot: "..lY(gn)end;local function nZ()if ir()==1 then bU=not bU;if bU then b0=false;aZ=false;a_=false;b2=false;b5=false;b3=false;b4=false;n_=bj;bj=false;d.control.retractLandingGears()is:setTargetGroundAltitude(X)fL("folOn","F")else fL("folOff","F")aY="Follow Off"ct=p;bj=n_;if bj then d.control.extendLandingGears()is:setTargetGroundAltitude(Y)end end else bW="Follow Mode only works with Remote controller"bU=false end end;local nN=50;local nO=260;local o0=j8(30)local o1=aw+av*2+2;local o2=ax+1;ny("+","+",o0,o0,o1,o2+o0+1,function()return false end,function()c_=c_/8 end,function()return bE=="SCOPE"end,nil,"ZoomButton")ny("-","-",o0,o0,o1,o2,function()return false end,function()c_=math.min(c_*8,90)end,function()return bE=="SCOPE"end,nil,"ZoomButton")ny("0","0",o0,o0,o1,o2+o0*2+2,function()return false end,function()c_=90 end,function()return bE=="SCOPE"and c_~=90 end,nil,"ZoomButton")local o3=ny("Enable Brake Toggle","Disable Brake Toggle",nO,nN,cd/2-nO/2,ce/2+350,function()return aW end,function()aW=not aW;if aW then bW="Brakes in Toggle Mode"else bW="Brakes in Default Mode"end end)ny("Align Prograde","Disable Prograde",nO,nN,cd/2-nO/2-50-o3.width,ce/2-nN+380,function()return a_ end,function()nS(1)end)ny("Align Retrograde","Disable Retrograde",nO,nN,cd/2-nO/2+o3.width+50,ce/2-nN+380,function()return aZ end,nS,function()return c9==0 end)o4=ny(nX,nY,600,60,cd/2-600/2,ce/2-60/2-330,function()return b0 or bn or c5 or bw end,function()end)local K;local function o5(o6)local gn=cW+o6;if gn>#cO then gn=gn-#cO-1 end;if gn<0 then gn=#cO+gn end;return gn end;o7={}for K=0,10 do local o8=ny(function(et)local gn=o5(et.apExtraIndex)if b0 or bn or c5 or bw then return"Redirect: "..lY(gn)end;return nX(gn)end,function(et)local gn=o5(et.apExtraIndex)return nY(gn)end,600,60,cd/2-600/2,ce/2-60/2-330+60*K,function(et)local gn=o5(et.apExtraIndex)return gn==bi and(b0 or bn or c5 or bw)end,function(et)local gn=o5(et.apExtraIndex)local o9=bi==gn;bi=gn;cm.UpdateAutopilotTarget()cn.ToggleAutopilot()if not o9 and not(b0 or bn or c5 or bw)then cn.ToggleAutopilot()end end,function()return cV and(#cn.routeWP(true)==0 or K==0)end)o8.apExtraIndex=K;o7[K]=o8 end;ny("Save Position","Save Position",200,o4.height,o4.x+o4.width+30,o4.y,function()return false end,go,function()return bi==0 or fX==nil end)ny("Update Position","Update Position",200,o4.height,o4.x+o4.width+30,o4.y,function()return false end,function()nU(nil)end,function()return bi>0 and fX~=nil end)ny("Save Heading","Clear Heading",200,o4.height,o4.x+o4.width+30,o4.y+o4.height+20,function()return fX.heading~=nil end,function()if fX.heading~=nil then nU(false)else nU(true)end end,function()return bi>0 and fX~=nil end)ny("Save AGG Alt","Clear AGG Alt",200,o4.height,o4.x+o4.width+30,o4.y+o4.height*2+40,function()return fX.agg~=nil end,function()if fX.agg~=nil then nU(nil,false)else nU(nil,true)end end,function()return bi>0 and fX~=nil and antigrav end)ny("Clear Position","Clear Position",200,o4.height,o4.x-200-30,o4.y,function()return true end,gj,function()return bi>0 and fX~=nil end)ny("Save Route","Save Route",200,o4.height,o4.x-200-30,o4.y+o4.height*2+40,function()return false end,function()cn.routeWP(false,false,2)end,function()return#cn.routeWP(true)>0 end)ny("Load Route","Clear Route",200,o4.height,o4.x-200-30,o4.y+o4.height+20,function()return#cn.routeWP(true)>0 end,function()if#cn.routeWP(true)>0 then cn.routeWP(false,true)elseif b0 or bn then bW="Disable Autopilot before loading route"return else cn.routeWP(false,false,1)end end,function()return true end)nN=60;nO=300;local hf=0;local hg=ce/2-150;ny("Enable Check Damage","Disable Check Damage",nO,nN,hf,hg-nN-20,function()return s end,function()s=not s end)ny("View Settings","View Settings",nO,nN,hf,hg,function()return true end,nK)hg=hg+nN+20;ny("Enable Turn and Burn","Disable Turn and Burn",nO,nN,hf,hg,function()return b1 end,nR)hf=10;hg=ce/2-300;ny("Horizontal Takeoff Mode","Vertical Takeoff Mode",nO,nN,hf+nO+20,hg,function()return aX end,function()aX=not aX;if aX then bW="Vertical Takeoff Mode"else bW="Horizontal Takeoff Mode"end end,function()return cJ end)hg=hg+nN+20;ny("Engage Orbiting","Cancel Orbiting",nO,nN,hf+nO+20,hg,function()return bw end,cn.ToggleIntoOrbit,function()return c9==0 and cS end)hg=ce/2-150;ny("Glide Re-Entry","Cancel Glide Re-Entry",nO,nN,hf+nO+20,hg,function()return b5 end,function()c4=1;nS(1)end,function()return j7.hasAtmosphere and not c8 end)hg=hg+nN+20;ny("Parachute Re-Entry","Cancel Parachute Re-Entry",nO,nN,hf+nO+20,hg,function()return b5 end,function()c4=2;nS(1)end,function()return j7.hasAtmosphere and not c8 end)hg=hg+nN+20;ny("Engage Follow Mode","Disable Follow Mode",nO,nN,hf,hg,function()return bU end,nZ,function()return ir()==1 end)ny("Enable Repair Arrows","Disable Repair Arrows",nO,nN,hf+nO+20,hg,function()return iZ end,function()iZ=not iZ;if iZ then bW="Repair Arrows Enabled"else bW="Repair Arrows Diabled"end end,function()return ir()==1 end)hg=hg+nN+20;if not q then ny("Enable AGG","Disable AGG",nO,nN,hf,hg,function()return cK end,cn.ToggleAntigrav,function()return antigrav~=nil end)end;ny(function()return d9("Switch IPH Mode - Current: %s",bx)end,function()return d9("IPH Mode: %s",bx)end,nO*2,nN,hf,hg,function()return false end,function()if bx=="All"then bx="Custom Only"elseif bx=="Custom Only"then bx="No Moons"else bx="All"end;bW="IPH Mode: "..bx end)hg=hg+nN+20;ny(function()return d9("Toggle Control Scheme - Current: %s",g)end,function()return d9("Control Scheme: %s",g)end,nO*2,nN,hf,hg,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bW="New Control Scheme: "..g end)local oa=j9(20)local o8=nu(0,0,j8(70),oa,"HELP")o8=nu(o8.x+o8.width,o8.y,j8(80),oa,"INFO")o8=nu(o8.x+o8.width,o8.y,j8(70),oa,"ORBIT")o8=nu(o8.x+o8.width,o8.y,j8(70),oa,"SCOPE")nu(o8.x+o8.width,o8.y,j8(70),oa,"HIDE")end;local ob={}local oc=nil;function ob.HUDPrologue(jS)cP,cQ=j5(cI)if not cP then iQ=af;iR=ag;iS=ah else iQ=ac;iR=ad;iS=ae end;iT=[[rgb(]]..bH(iQ+0.6)..","..bH(iR+0.6)..","..bH(iS+0.6)..[[)]]iU=[[rgb(]]..bH(iQ*0.8+0.5)..","..bH(iR*0.8+0.5)..","..bH(iS*0.8+0.5)..[[)]]local od=iT;local oe=iU;local of=[[rgb(]]..bH(iQ*0.4+0.5)..","..bH(iR*0.4+0.5)..","..bH(iS*0.4+0.5)..[[)]]local og=iT;local oh=iU;local oi=of;if ja()and not m then od=[[rgb(]]..bH(iQ*0.5+0.5)..","..bH(iR*0.5+0.5)..","..bH(iS*0.5+0.5)..[[)]]oe=[[rgb(]]..bH(iQ*0.3+0.5)..","..bH(iR*0.3+0.5)..","..bH(iS*0.2+0.5)..[[)]]of=[[rgb(]]..bH(iQ*0.2+0.5)..","..bH(iR*0.2+0.5)..","..bH(iS*0.2+0.5)..[[)]]end;local lN=j8;local lO=j9;jS[#jS+1]=d9([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],od,od,od,og,og,oe,oe,oh,oh,oe,od,of,oh,od,od,of,of,oi,of,cd,ce,oe,oe,oe,oe,oe,og,oe,oh,oi,oh,oh,oi)if not oc then oc=d9([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lN(630),lO(0),lN(675),lO(45),lN(960),lO(55),lN(1245),lO(45),lN(1290),lO(0),lN(1000),lO(105),lN(1040),lO(59),lN(1250),lO(51),lN(1300),lO(0),lN(1920),lO(0),lN(1920),lO(20),lN(1400),lO(20),lN(1300),lO(105),lN(920),lO(105),lN(880),lO(59),lN(670),lO(51),lN(620),lO(0),lN(0),lO(0),lN(0),lO(20),lN(520),lO(20),lN(620),lO(105),lN(890),lO(59),lN(960),lO(62),lN(1030),lO(59),lN(985),lO(112),lN(1150),lO(112),lN(1100),lO(152),lN(820),lO(152),lN(780),lO(112),lN(935),lO(112),lN(890),lO(59),lN(960),lO(62),lN(1030),lO(59),lN(985),lO(112),lN(1150),lO(112),lN(1100),lO(152),lN(820),lO(152),lN(780),lO(112),lN(935),lO(112))end;if w and I then jS[#jS+1]=oc end;return jS end;function ob.DrawVerticalSpeed(jS,dU)jR(jS,dU)end;function ob.UpdateHud(jS)local kG=cM;local oj=cN;local jZ=oj;local ke=kG;local kY=bH(c.getThrottle())local l2=cF*3.6;local kZ=c.getAxisCommandValue(0)local ok=j8(1770)local ol=j9(310)if t and cL then kZ=bK;kY=bK*100 end;local jc=jb()local j_="ROLL"if kY==nil then kY=0 end;if not cS then if cF>5 then kG=kF(cD)oj=kH(cD)else kG=0;oj=0 end;j_="YAW"end;if cQ>50000 and not c8 then local om;om=iw(cQ)jS[#jS+1]=gE(ok,ol,"PvP Boundary: "..om,"pbright txtbig txtmid")end;jS[#jS+1]=iX;jS[#jS+1]=iO;jS[#jS+1]=i1;if iK~=""then jS[#jS+1]=iK end;if jd~=""then jS[#jS+1]=jd end;if je~=""then jS[#jS+1]=je end;jR(jS,ca)if ir()==0 or l then if cS then jY(jS,ai,aj,jZ,j_,cS)else jY(jS,ai,aj,oj,j_,cS)end;if not ja()or m then if cS then jY(jS,ai,aj,jZ,j_,cS)kd(jS,ke,jZ,ai,aj,cS,bH(kH(cD)),cF)else jY(jS,ai,aj,oj,j_,cS)kd(jS,kG,oj,ai,aj,cS,bH(oj),cF)end;kk(jS,ca,cS)kI(jS,cD,cF,ai,aj)end end;kX(jS,jc,kY,kZ)l1(jS,l2)l5(jS)m6(jS)if not iI and bV then lZ(jS)end;return jS end;function ob.HUDEpilogue(jS)jS[#jS+1]="</svg>"return jS end;function ob.ExtraData(jS)local on=j8(1240)local oo=j9(55)local op=oo+10;local oq;local lN=j8;local lO=j9;local os=0;local jc=jb()if aX then jc=jc.."-VERTICAL"end;if E and not b4 and not b3 and cF>20 then jc=jc.."-COLLISION ON"end;if bz~="Off"then jc="("..bz..")-"..jc end;if b1 then jc="TB-"..jc end;if not by then jc=jc.."-DeCoupled"end;local ot=lO(99)local ou=lO(80)local ov=lO(85)local ow=lO(31)local ox=0;local oy=0;local oz=cb>1000000 and fM(cb/1000000,2).."kT"or fM(cb/1000,2).."T"if c8 then os=br else os=bp end;local oA,oB=cj.computeDistanceAndTime(cF,0,cb,0,0,os)if oA<0 then oA=0 end;os=fM(os/(cb*iA),2).."g"local oC=d:maxForceForward()oq=b.g()if oq>0.1 then oy=cb*oq;oy=fM(oy/(cb*iA),2).."g"ox=0.5*oC/oq;ox=ox>1000000 and fM(ox/1000000,2).."kT"or fM(ox/1000,2).."T"end;oC=fM(oC/(cb*iA),2).."g"local oD=vec3(b.getWorldAcceleration()):len()/9.80665;oq=b.g()jS[#jS+1]=[[<g class="dim txt txtend size14">]]if ir()==1 and not l then on=j8(1120)oo=j9(55)op=oo+10 elseif c8 and I then local oE=j8(770)jS[#jS+1]=gE(lN(895),ot,"ATMO","")jS[#jS+1]=d9([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lN(895),ov,lN(-80))jS[#jS+1]=gE(lN(815),ou,d9("%.1f%%",c9*100),"txtstart size20")end;if I then jS[#jS+1]=gE(lN(1025),ot,"GRAVITY","txtstart")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(1025),ov,lN(80))jS[#jS+1]=gE(lN(1105),ou,d9("%.2fg",oq/9.80665),"size20")jS[#jS+1]=gE(lN(1125),ot,"ACCEL","txtstart")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(1125),ov,lN(80))jS[#jS+1]=gE(lN(1205),ou,d9("%.2fg",oD),"size20")jS[#jS+1]=gE(lN(695),ot,"BRK TIME","")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(695),ov,lN(-80))jS[#jS+1]=gE(lN(615),ou,d9("%s",ix(oB)),"txtstart size20")jS[#jS+1]=gE(lN(635),lO(45),"TRIP","")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(635),lO(31),lN(-90))if lH then jS[#jS+1]=gE(lN(545),lO(26),d9("%s",ix(lH)),"txtstart size20")end;jS[#jS+1]=gE(lN(795),ot,"BRK DIST","")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(795),ov,lN(-80))jS[#jS+1]=gE(lN(715),ou,d9("%s",iw(oA)),"txtstart size20")jS[#jS+1]=gE(lN(1285),lO(45),"MASS","txtstart")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(1285),lO(31),lN(90))jS[#jS+1]=gE(lN(1375),lO(26),d9("%s",oz),"size20")jS[#jS+1]=gE(lN(1220),ot,"THRUST","txtstart")jS[#jS+1]=d9([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lN(1220),ov,lN(80))jS[#jS+1]=gE(lN(1300),ou,d9("%s",oC),"size20")jS[#jS+1]=gE(j8(960),j9(175),jc,"pbright txtbig txtmid size20")end;jS[#jS+1]="</g>"end;local oF=1-(a5*0.05+a6*0.05)function ob.FuelUsed(oG)local oH;if oG=="atmofueltank"then oH=d9("Atmo Fuel Used: %.1f L",ju[oG]/(4*oF))elseif oG=="spacefueltank"then oH=d9("Space Fuel Used: %.1f L",ju[oG]/(6*oF))else oH=d9("Rocket Fuel Used: %.1f L",ju[oG]/(0.8*oF))end;return oH end;function ob.DrawOdometer(jS,iV,bk,iW)if bE~="INFO"then return jS end;local oq;local ox=0;local oy=0;local os=0;local oz=cb>1000000 and fM(cb/1000000,2).." kTons"or fM(cb/1000,2).." Tons"if c8 then os=br else os=bp end;local oA,oB=cj.computeDistanceAndTime(cF,0,cb,0,0,os)os=fM(os/(cb*iA),2).." g"local oC=d:maxForceForward()oq=b.g()if oq>0.1 then oy=cb*oq;oy=fM(oy/(cb*iA),2).." g"ox=0.5*oC/oq;ox=ox>1000000 and fM(ox/1000000,2).." kTons"or fM(ox/1000,2).." Tons"end;oC=fM(oC/(cb*iA),2).." g"if ir()==0 or l then local oI=j8(aw+10)local oJ=j9(ax+20)local oK=j8(aw+10+av/1.25)local nw=25;jS[#jS+1]="<g class='txtstart size14 bright'>"jS[#jS+1]=gE(oI,oJ,d9("BrkTime: %s",ix(oB)))jS[#jS+1]=gE(oK,oJ,d9("Trip: %.2f km",iV))jS[#jS+1]=gE(oI,oJ+nw,d9("Lifetime: %.2f kSU",bk/200000))jS[#jS+1]=gE(oK,oJ+nw,d9("BrkDist: %s",iw(oA)))jS[#jS+1]=gE(oI,oJ+nw*2,"Trip Time: "..ix(iW))jS[#jS+1]=gE(oK,oJ+nw*2,"Total Time: "..ix(bl))jS[#jS+1]=gE(oI,oJ+nw*3,d9("Mass: %s",oz))jS[#jS+1]=gE(oK,oJ+nw*3,d9("Max Brake: %s",os))jS[#jS+1]=gE(oI,oJ+nw*4,d9("Max Thrust: %s",oC))if oq>0.1 then jS[#jS+1]=gE(oK,oJ+nw*4,d9("Max Thrust Mass: %s",ox))jS[#jS+1]=gE(oI,oJ+nw*5,d9("Req Thrust: %s",oy))else jS[#jS+1]=gE(oK,oJ+nw*4,"Max Mass: n/a")jS[#jS+1]=gE(oI,oJ+nw*5,"Req Thrust: n/a")end;jS[#jS+1]=gE(oK,oJ+nw*5,cl.FuelUsed("atmofueltank"))jS[#jS+1]=gE(oI,oJ+nw*6,cl.FuelUsed("spacefueltank"))jS[#jS+1]=gE(oK,oJ+nw*6,cl.FuelUsed("rocketfueltank"))if cF>833 then local oL=cb/math.sqrt(1-(cF/8333.33)^2)local oz=oL>1000000 and fM(oL/1000000,2).." kTons"or fM(oL/1000,2).." Tons"jS[#jS+1]=gE(oK,oJ+nw*7,d9("Rel. Mass: %s",oz))end end;jS[#jS+1]="</g></g>"return jS end;function ob.DrawWarnings(jS)return l5(jS)end;function ob.DisplayOrbitScreen(jS)return m6(jS)end;function ob.DisplayMessage(jS,ls)if ls~="empty"then local hg=310;for lB in string.gmatch(ls,"([^\n]+)")do hg=hg+35;jS[#jS+1]=gE("50%",hg,lB,"msg")end end;if bX~=0 then c.setTimer("msgTick",bX)bX=0 end end;function ob.DrawDeadZone(jS)jS[#jS+1]=d9([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function ob.UpdatePipe()if c8 then iK=""return end;nl()end;function ob.DrawSettings(jS)local hf=j8(640)local hg=j9(200)jS[#jS+1]=[[<g class="pbright txtvspd txtstart">]]local hJ=0;for dA,dl in pairs(iJ)do hJ=hJ+1;jS[#jS+1]=gE(hf,hg,dA..": "..dl.get())hg=hg+20;if hJ%12==0 then hf=hf+j8(350)hg=j9(200)end end;jS[#jS+1]=gE(j8(640),j9(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jS[#jS+1]="</g>"return jS end;local hZ=j8(1770)local h_=j9(350)local hY=j9(15)local hX=j8(1370)local i2,oM;function ob.DrawRadarInfo()i1=co.GetRadarHud(hX,hY,hZ,h_)end;function ob.DrawTanks()if aq~=0 and ar~=0 then jd=gE(aq,ar,"","txtstart pdim txtfuel")jv=ar;jw(aq,"Atmospheric ","ATMO",cf,js,jt)jw(aq,"Space Fuel T","SPACE",cg,jq,jr)jw(aq,"Rocket Fuel ","ROCKET",ch,jo,jp)end end;function ob.DrawShield()local i9=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oN=b.getPvPTimer()local oO=shield_1.getResistances()local oP="A: "..10+oO[1]*100 .."% / E: "..10+oO[2]*100 .."% / K:"..10+oO[3]*100 .."% / T: "..10+oO[4]*100 .."%"local hf,hg=as-60,at+30;local jK=bH(d7*2.55)local jL=d9("rgb(%d,%d,%d)",255-jK,jK,0)local jM=""je=gE(hf,hg,"","txtmid pdim txtfuel")if d7<10 and i9~="Shield Disabled"then jM="red "end;oN=oN>0 and"   PvPTime: "..ix(oN)or""je=je..d9([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hf,hg,jL,d7*2,hf,hg,hf+2,hg+10,d7,oN)je=je..gE(hf,hg-5,i9,jM.."txtstart pbright txtbig")je=je..gE(hf,hg+30,oP,jM.."txtstart pbright txtsmall")end;function ob.hudtick()if not j7 then return end;local function oQ(jS)local jO=bH(da(c3/(cd/4)*255,0,255))jS[#jS+1]=d9("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c1,c2,bH(iQ+0.5)+jO,bH(iR+0.5)-jO,bH(iS+0.5)-jO)end;local function oR()for dF,dl in pairs(iB)do if dl.hovered then if not dl.drawCondition or dl.drawCondition(dl)then dl.toggleFunction(dl)end;dl.hovered=false end end;for dF,dl in pairs(iE)do if dl.hovered then bE=dl.label;dl.hovered=false end end end;local function oS()local function oT(oU,oV,hf,hg,nv,nw)if oU>=hf and oU<=hf+nv and oV>=hg and oV<=hg+nw then return true else return false end end;local hf=c1+cd/2;local hg=c2+ce/2;for dF,dl in pairs(iB)do dl.hovered=oT(hf,hg,dl.x,dl.y,dl.width,dl.height)end;for dF,dl in pairs(iE)do dl.hovered=oT(hf,hg,dl.x,dl.y,dl.width,dl.height)end;if cV then local na=false;for dF,et in ipairs(o7)do if et.hovered then na=true;break end end;if o4.hovered then na=true end;cV=na else cV=o4.hovered;if not cV then cW=bi end end end;local function oW(jS)if not bE or bE==""then bE="HELP"end;if w then for dA,dl in pairs(iE)do local jM="dim brightstroke"local oX=0.2;if bE==dA then jM="pbright dimstroke"oX=0.6 end;local oY=""if dl.hovered then oX=0.8;oY=";stroke:white"end;jS[#jS+1]=d9([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dl.width,dl.height,dl.x,dl.y,jM,oX,oY)jS[#jS+1]=gE(dl.x+dl.width/2,dl.y+dl.height/2+5,dl.label,"txt txtmid pdim")end end end;local function oZ(jS)local function o_(jS,p0,hover,hf,hg,f9,p1,p2,p3,p4,p5,o8)if type(p4)=="function"then p4=p4(o8)end;if type(p5)=="function"then p5=p5(o8)end;jS[#jS+1]=d9("<rect x='%f' y='%f' width='%f' height='%f' fill='",hf,hg,f9,p1)if p0 then jS[#jS+1]=d9("%s'",p2)else jS[#jS+1]=p3 end;if hover then jS[#jS+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jS[#jS+1]=d9(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fM(ac*0.5,0),fM(ad*0.5,0),fM(ae*0.5,0))end;jS[#jS+1]=" rx='5'></rect>"jS[#jS+1]=d9("<text x='%f' y='%f' font-size='24' fill='",hf+f9/2,hg+p1/2+5)if p0 then jS[#jS+1]="black"else jS[#jS+1]="white"end;jS[#jS+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if p0 then jS[#jS+1]=d9("%s</text>",p4)else jS[#jS+1]=d9("%s</text>",p5)end end;local p6=d9("rgb(%d,%d,%d)'",fM(ac*0.1,0),fM(ad*0.1,0),fM(ae*0.1,0))local p7=d9("rgb(%d,%d,%d)",fM(ac*0.8,0),fM(ad*0.8,0),fM(ae*0.8,0))local p8=o_;for dF,dl in pairs(iB)do local nA=dl.disableName;local nz=dl.enableName;if type(nA)=="function"then nA=nA(dl)end;if type(nz)=="function"then nz=nz(dl)end;if not dl.drawCondition or dl.drawCondition(dl)then p8(jS,dl.toggleVar(dl),dl.hovered,dl.x,dl.y,dl.width,dl.height,p7,p6,nA,nz,dl)end end end;local p9=fM(cd/2,0)local pa=fM(ce/2,0)local jS={}if pb then jS[#jS+1]=pb end;cl.HUDPrologue(jS)if w then cl.UpdateHud(jS)else if A then cl.DrawVerticalSpeed(jS,ca)end;cl.DrawWarnings(jS)end;if iI and iJ~="none"then cl.DrawSettings(jS)end;if radar_1 then cl.DrawRadarInfo()end;cl.HUDEpilogue(jS)jS[#jS+1]=d9([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cd,ce)if bW~="empty"then cl.DisplayMessage(jS,bW)end;if ir()==0 and g=="virtual joystick"then if v then cl.DrawDeadZone(jS)end end;oW(jS)if it()==0 then if ir()==1 and bV then if not pc then oS()oZ(jS)end;if not cr and not cs then local pd=table.concat(jS,"")jS={}jS[#jS+1]=d9("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jS[#jS+1]=pd;jS[#jS+1]="</body>"cr=true;jS[#jS+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cs then local pd=table.concat(jS,"")jS={}jS[#jS+1]=d9("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cd,ce)jS[#jS+1]=pd;jS[#jS+1]="</body>"end;if not cr then jS[#jS+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p9,pa,c1,c2)end else oR()end else if not bV and ir()==0 then oR()if c3>au then if v then oQ(jS)end end elseif bV and(not pc or not i)then oS()oZ(jS)end;jS[#jS+1]=d9([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p9,pa,c1,c2)end;jS[#jS+1]=[[</svg></body>]]pe=table.concat(jS,"")end;function ob.TenthTick()local function pf()local pg=a.createData;local ph=a.createWidget;pi=a.createWidgetPanel("Interplanetary Helper")pj=ph(pi,"value")pk=pg('{"label": "Target Planet", "value": "N/A", "unit":""}')fK(pk,pj)pl=ph(pi,"value")pm=pg('{"label": "distance", "value": "N/A", "unit":""}')fK(pm,pl)gd=ph(pi,"value")gc=pg('{"label": "Travel Time", "value": "N/A", "unit":""}')fK(gc,gd)gb=ph(pi,"value")ga=pg('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fK(ga,gb)gf=ph(pi,"value")ge=pg('{"label": "Target Altitude", "value": "N/A", "unit":""}')fK(ge,gf)g7=ph(pi,"value")g6=pg('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g5=ph(pi,"value")g4=pg('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g3=ph(pi,"value")g2=pg('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g1=ph(pi,"value")g0=pg('{"label": "Max Brake Time", "value": "N/A", "unit":""}')g9=ph(pi,"value")g8=pg('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c8 then fK(g6,g7)fK(g4,g5)fK(g2,g3)fK(g0,g1)fK(g8,g9)end end;local function pn()gD(pi)pi=nil end;local function po()if not b0 then if fX==nil or fX.planetname~=j7.name then pp=(c0.center-cI):len()else pp=(fX.position-cI):len()end end;local fg=cF;local pq=c.getThrottle()/100;if t then pq=bK end;local pr,ps=cj.computeDistanceAndTime(cF,_,cb,d:maxForceForward()*pq,a1,0)local bZ,b_;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local dF,pt;if not b1 and fg>0 then dF,pt=cn.GetAutopilotBrakeDistanceAndTime(fg)else dF,pt=cn.GetAutopilotTBBrakeDistanceAndTime(fg)end;local pu=0;local pv=0;if bb or not b0 and fg>5 then pv=cj.computeTravelTime(fg,0,pp)elseif bZ+pr<pp then pu=pp-(bZ+pr)pv=cj.computeTravelTime(8333.0556,0,pu)else local pw=(pp-bZ)/pr;pr=pp-bZ;ps=ps*pw end;if fX~=nil and fX.planetname==j7.name and not b0 then return pv elseif ba then return pt elseif bb then return pv+pt else return ps+b_+pv end end;cl.DrawTanks()if shield_1 then cl.DrawShield()end;if bg~="None"then if pi==nil then pf()end;if bg~=nil then local px=fX~=nil;local py=0.5*br/c0:getGravity(c0.center+vec3(0,0,1)*c0.radius):len()py=py>1000000 and fM(py/1000000,2).." kTons"or fM(py/1000,2).." Tons"fJ(pk,'{"label": "Target", "value": "'..bg..'", "unit":""}')lH=po()if px and not b0 then c3=(cI-fX.position):len()else c3=(bh-cI):len()end;if not b1 then bZ,b_=cn.GetAutopilotBrakeDistanceAndTime(cF)iM,iN=cn.GetAutopilotBrakeDistanceAndTime(_)else bZ,b_=cn.GetAutopilotTBBrakeDistanceAndTime(cF)iM,iN=cn.GetAutopilotTBBrakeDistanceAndTime(_)end;local ls=iw(c3)fJ(pm,'{"label": "distance", "value": "'..ls..'"}')fJ(gc,'{"label": "Travel Time", "value": "'..ix(lH)..'", "unit":""}')ls=iw(bZ)fJ(g6,'{"label": "Cur Brake distance", "value": "'..ls..'"}')fJ(g4,'{"label": "Cur Brake Time", "value": "'..ix(b_)..'", "unit":""}')ls=iw(iM)fJ(g2,'{"label": "Max Brake distance", "value": "'..ls..'"}')fJ(g0,'{"label": "Max Brake Time", "value": "'..ix(iN)..'", "unit":""}')fJ(ga,'{"label": "Max Brake Mass", "value": "'..d9("%s",py)..'", "unit":""}')ls=iw(gg)fJ(ge,'{"label": "Target Orbit", "value": "'..ls..'"}')if c9>0 and not pz then a.removeDataFromWidget(g0,g1)a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)pz=true;if not cL and t and(b2 or b5 or c6)then cn.cmdThrottle(1)aY=false;bO=false end end;if c9==0 and pz then if fJ(g0,g1)==1 then fK(g0,g1)end;if fJ(g2,g3)==1 then fK(g2,g3)end;if fJ(g4,g5)==1 then fK(g4,g5)end;if fJ(g6,g7)==1 then fK(g6,g7)end;if fJ(g8,g9)==1 then fK(g8,g9)end;pz=false end end else pn()end;if warpdrive~=nil then if ip(warpdrive.getData()).destination~="Unknown"and ip(warpdrive.getData()).distance>400000 then warpdrive.show()pA=true else warpdrive.hide()pA=false end end end;function ob.OneSecondTick()local function pB()local jG=bG()local l2=cF;local pC=jG-iY;if l2>1.38889 then l2=l2/1000;local pD=l2*(jG-iY)bk=bk+pD;iV=iV+pD end;iW=iW+pC;bl=bl+pC;iY=jG end;local function pE(jS)local pF=0;iO=""local pG=iz;local pH=0;local pI=0;local pJ=0;local jK=0;local jL=""local pK=b.getElementHitPointsById;local pL=b.getElementMaxHitPointsById;local pM={}for dA in pairs(iy)do local pN=0;local pO=0;pO=pL(iy[dA])pN=pK(iy[dA])pH=pH+pN;if pN<pO then if pN==0 then pJ=pJ+1 else pI=pI+1 end;if iZ and#pM==0 then fO=vec3(b.getElementPositionById(iy[dA]))local hf=fO.x;local hg=fO.y;local hh=fO.z;table.insert(pM,b.spawnArrowSticker(hf,hg,hh+1,"down"))table.insert(pM,b.spawnArrowSticker(hf,hg,hh+1,"down"))b.rotateSticker(pM[2],0,0,90)table.insert(pM,b.spawnArrowSticker(hf+1,hg,hh,"north"))table.insert(pM,b.spawnArrowSticker(hf+1,hg,hh,"north"))b.rotateSticker(pM[4],90,90,0)table.insert(pM,b.spawnArrowSticker(hf-1,hg,hh,"south"))table.insert(pM,b.spawnArrowSticker(hf-1,hg,hh,"south"))b.rotateSticker(pM[6],90,-90,0)table.insert(pM,b.spawnArrowSticker(hf,hg-1,hh,"east"))table.insert(pM,b.spawnArrowSticker(hf,hg-1,hh,"east"))b.rotateSticker(pM[8],90,0,90)table.insert(pM,b.spawnArrowSticker(hf,hg+1,hh,"west"))table.insert(pM,b.spawnArrowSticker(hf,hg+1,hh,"west"))b.rotateSticker(pM[10],-90,0,90)table.insert(pM,iy[dA])end elseif iZ and#pM>0 and pM[11]==iy[dA]then for jF in pairs(pM)do b.deleteSticker(pM[jF])end;pM={}end end;pF=bH(pH/pG*100)if pF<100 then jS[#jS+1]=gE(0,0,"","pbright txt")jK=bH(pF*2.55)jL=d9("rgb(%d,%d,%d)",255-jK,jK,0)if pF<100 then jS[#jS+1]=gE("50%",1035,"Elemental Integrity: "..pF.."%","txtbig txtmid","fill:"..jL)if pJ>0 then jS[#jS+1]=gE("50%",1055,"Disabled Modules: "..pJ.." Damaged Modules: "..pI,"txtbig txtmid","fill:"..jL)elseif pI>0 then jS[#jS+1]=gE("50%",1055,"Damaged Modules: "..pI,"txtbig txtmid","fill:"..jL)end end end end;local function pP()if io then if iP==nil and(d2~=nil or bj)then _autoconf.displayCategoryPanel(io,weapon_size,"Weapons","weapon",true)iP=_autoconf.panels[_autoconf.panels_size]elseif iP~=nil and d2==nil and not bj then gD(iP)iP=nil end end end;cX=b.getPlayersOnBoard()cY=b.getDockedConstructs()local jS={}pB()if s then pE(jS)end;pP()cl.UpdatePipe()cl.ExtraData(jS)iX=table.concat(jS,"")collectgarbage("collect")end;function ob.AnimateTick()cs=true;cr=false;c1=0;c2=0;c.stopTimer("animateTick")end;function ob.MsgTick()local jS={}cl.DisplayMessage(jS,"empty")bW="empty"c.stopTimer("msgTick")bX=3 end;function ob.ButtonSetup()nL()nQ()iB=iC end;if pQ then for dA,dl in pairs(pQ)do ob[dA]=dl end end;return ob end;local function pR(d,b,c,a,e,vBooster,hover,pS,antigrav,warpdrive,dbHud_1,eP,bH,bI,ir,eK,bG,da,is,fJ,it,dc,fM,fL,iu,dd,iw,ix,pT,ip,d9,fK)local pU={}local pV=false;local pW=0;local pX=0;local pY=0;local pZ=bG()local p_=0;local q0=0;local q1=0;local q2=0;local q3=false;local q4=false;local q5=false;local q6=nil;local q7=0;local iL=55;local q8=nil;local q9=false;local qa=false;local qb=false;local qc=0;local qd=0;local qe=0;local qf=0;local qg=0;local qh={VectorToTarget=false}local qi=vec3(b.getConstructWorldOrientationUp())local qj=nil;local qk=0;local ql=-1;local qm=-1;local qn=false;local qo=false;local qp=0;local qq=false;local qr=false;local qs=false;local qt=false;local qu=""local qv=false;local qw=false;local qx=""local function qy(fg)local qz=bc;if not b0 then qz=0 end;if not c8 then return cj.computeDistanceAndTime(fg,qz,cb,0,0,bp-be*cb)else if br and br>0 then return cj.computeDistanceAndTime(fg,qz,cb,0,0,br-be*cb)else return 0,0 end end end;local function qA(fg)local qz=bc;if not b0 then qz=0 end;return cj.computeDistanceAndTime(fg,qz,cb,d:maxForceForward(),a1,bp-be*cb)end;local function qB(qC,qD,qE)qD=qD:project_on_plane(qC)qE=qE:project_on_plane(qC)return eK(qD:cross(qE):dot(qC),qD:dot(qE))end;local function qF()local function qG()local qH=-1;local qI=-1;if vBooster then qH=vBooster.getDistance()end;if hover then qI=hover.getDistance()end;if qH~=-1 and qI~=-1 then if qH<qI then return qH else return qI end elseif qH~=-1 then return qH elseif qI~=-1 then return qI else return-1 end end;local qJ=qG()local qK=-1;if pS then qK=pS.getDistance()end;if qJ~=-1 and qK~=-1 then if qJ<qK then return qJ else return qK end elseif qJ~=-1 then return qJ else return qK end end;local function qL(j7,eB,qM)local function qN(qO,dM)local eH=vec3(dM)if qO.id==0 then return setmetatable({latitude=eH.x,longitude=eH.y,altitude=eH.z,id=0,systemId=qO.systemId},dO)end;local eI=eH-qO.center;local c3=eI:len()local dU=c3-qO.radius;local dS=0;local dT=0;if not dd(c3,0)then local eJ=eK(eI.y,eI.x)dT=eJ>=0 and eJ or 2*math.pi+eJ;dS=math.pi/2-math.acos(eI.z/c3)end;return setmetatable({latitude=math.deg(dS),longitude=math.deg(dT),altitude=dU,id=qO.id,systemId=qO.systemId},dO)end;local qP=qN(j7,eB)qP="::pos{"..qP.systemId..","..qP.id..","..qP.latitude..","..qP.longitude..","..qP.altitude.."}"if qM then return qP else qs=qP;return true end end;local function qQ(qR,qS,qT)local function qU(qR,ek)qR=vec3(qR)ek=vec3(ek):normalize()local dv=qR*ek;return dv.x+dv.y+dv.z end;local qV=0.001;local qW=1;if not c8 or not cu or c7~=-1 or cF<iL then if qT==nil then qT=aO end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=vec3()-qR;local qY=-qU(qX,b.getConstructWorldOrientationRight())*qW;local qZ=-qU(qX,b.getConstructWorldOrientationUp())*qW;if pX==0 then pX=qY/2 end;if pY==0 then pY=qZ/2 end;if eP(qY)<0.1 then qd=qd-qY*2 else qd=qd-(qY+(qY-pX)*qT)end;if eP(qZ)<0.1 then qc=qc+qZ*2 else qc=qc+qZ+(qZ-pY)*qT end;pX=qY;pY=qZ;if eP(qY)<qS and eP(qZ)<qS then return true end;return false elseif cu and c7==-1 then qR=cE;if qT==nil then qT=aO end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=cB-qR;local qY=-qU(qX,b.getConstructWorldOrientationRight())*qW;local qZ=-qU(qX,b.getConstructWorldOrientationUp())*qW;if pX==0 then pX=qY/2 end;if pY==0 then pY=qZ/2 end;if eP(qY)<0.1 then qd=qd-qY*5 else qd=qd-(qY+(qY-pX)*qT)end;if eP(qZ)<0.1 then qc=qc+qZ*5 else qc=qc+qZ+(qZ-pY)*qT end;pX=qY;pY=qZ;if eP(qY)<qS and eP(qZ)<qS then return true end;return false end end;local function q_()if cU and not b3 then local ei=cU[1]local hO,hP=cU[2],cU[3]local r0=math.min(hO,hP or hO)local r1=r0/cF;local r2=b4 and(cF<42 or c7~=-1)local r3=b2 or bn or bq or b0;if r3 and not r2 and(bZ*1.5>r0 or r1<1)then aY="Collision"bC={}ql=0;if b2 then cn.ToggleAltitudeHold()end;if bq then cn.ToggleLockPitch()end;bW="Autopilot Cancelled due to possible collision"if bn or b0 then if not qw then qw=true end end;lA=true;b3=true;ct=true end;if r1<11 then cT=ei.name.." COLLISION "..ix(r1).." / "..iw(r0,2)else cT=ei.name.." collision "..ix(r1)end;if r1<6 then fL("alarm","AL",2)end else cT=false end end;function pU.clearAll()b8=false;ba=false;bb=false;b0=false;b9=false;bd="Aligning"aZ=false;a_=false;cR=nil;b2=false;b5=false;b3=false;aY=false;b4=false;b6=false;bU=false;qa=false;c4=false;c5=false;qb=false;ct=p;bn=false;b1=false;cc=false;bq=nil;bw=false;d5=false;d6=nil end;function pU.GetAutopilotBrakeDistanceAndTime(fg)return qy(fg)end;function pU.GetAutopilotTBBrakeDistanceAndTime(fg)return qA(fg)end;function pU.showWayPoint(j7,eB,qM)return qL(j7,eB,qM)end;function pU.APTick()qp=it()if qs then a.setWaypoint(qs)qs=false end;if qv then antigrav.setBaseAltitude(qv)qv=false end;if qt then fJ(qt,qu)qt=false;qu=""end;if ql~=-1 then cn.cmdThrottle(ql,qn)qn=false;ql=-1 end;if qm~=-1 then cn.cmdCruise(qm,qn)qn=false;qm=-1 end;if qo then d.control.extendLandingGears()qo=false end;if qw then cn.ToggleAutopilot(qw)end end;function pU.ToggleIntoOrbit()cy=false;q1=nil;q2=nil;q7=0;if not c8 then if bw then fL("orOff","AP")bw=false;q3=false;q6=nil;ct=p;if b2 then b2=false;b4=false end;qh.VectorToTarget=false;qh.AutopilotAlign=false;q5=false elseif cS then fL("orOn","AP")bw=true;ct=true;if q6==nil then q6=j7 end;if b2 then b2=false;b4=false end else bW="Unable to engage auto-orbit, not near a planet"end else bw=false;q3=false;q6=nil;ct=p;if b2 then b2=false end;qh.VectorToTarget=false;qh.AutopilotAlign=false;q5=false end end;function pU.ToggleVerticalTakeoff()b2=false;if b6 then lA=true;b5=false;b4=false;b3=true;ct=true;bT=0;if c8 and c7==-1 then b3=false;b2=true;bT=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qm=bH(cv)end else cy=false;bj=false;d.control.retractLandingGears()is:setTargetGroundAltitude(X)aY="VTO Takeoff"end;b6=not b6 end;function pU.checkLOS(qR)local lF,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,qR,function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lG=ez;if eA~=nil and ez~=nil then lG=math.min(eA,ez)end;if lG~=nil then return lF,lG else return nil,nil end end;function pU.ToggleAutopilot()local function r4(bu)cT=false;bn=not bn;if bn then b1=false;if not b2 and not bu then cn.ToggleAltitudeHold()end end;lJ="Proceeding to Waypoint"end;local function r5(gp)if gp then for K,dA in pairs(cO)do if dA.name and dA.name==gp then return K end end else return 0 end end;local r6=false;if bJ-q0<1.5 and c8 then if not cA then if c8 then b7=j7.spaceEngineMinAltitude-0.01*j7.noAtmosphericDensityAltitude;fL("11","EP")q0=-1;if b0 or bn or bw then return end else bW="No space engines detected, Orbital Hop not supported"return end elseif j7.hasAtmosphere then if c8 then b7=j7.noAtmosphericDensityAltitude+T;fL("orH","OH")end;q0=-1;if b0 or bn or bw then return end end else q0=bJ end;r7=false;if(bi>0 or#bC>0)and not b0 and not bn and not c5 and not bw then if 0.5*d:maxForceForward()/b.g()<cb then bW="WARNING: Heavy Loads may affect autopilot performance."bX=5 end;if#bC>0 and not c6 then bi=r5(bC[1])cm.UpdateAutopilotTarget()bW="Route Autopilot in Progress"local qX=fX.position-cI;local r8=qX:project_on_plane(cG):len()if r8>50000 and fX.planetname==j7.name then r6=true end end;cm.UpdateAutopilotTarget()cn.showWayPoint(c0,bh)if fX~=nil then if fX.agg and not q and antigrav then if not cK then cn.ToggleAntigrav()end;bs=fX.agg end;bq=nil;bu=fX.planetname=="Space"if bu then fL("apSpc","AP")if c8 then c5=true;cn.ToggleAltitudeHold()else b0=true end elseif j7.name==fX.planetname then lA=true;if c8 then if not bn then fL("vtt","AP")r4(bu)if r6 then b7=j7.noAtmosphericDensityAltitude+T end end else fL("apOn","AP")if not(c0.name==j7.name and ca<gg*1.5)then cy=false;b0=true elseif not c8 then if bw then cn.ToggleIntoOrbit()end;cx=j7.noAtmosphericDensityAltitude+T;q5=true;qh.AutopilotAlign=true;qh.VectorToTarget=true;q3=false;if not bw then cn.ToggleIntoOrbit()end end end else fL("apP","AP")aZ=false;a_=false;if c8 then c5=true;cn.ToggleAltitudeHold()else b0=true end end elseif not c8 then if fX==nil and(c0.name==j7.name and cS)and not bw then r9=false;cy=false;q3=false;cn.ToggleIntoOrbit()else fL("apP","AP")b0=true;aZ=false;a_=false;b9=false;bU=false;b2=false;b3=false;b5=false;b4=false;qa=false;bq=nil;r9=false end else fL("apP","AP")c5=true;cn.ToggleAltitudeHold()end;qw=false else fL("apOff","AP")cn.ResetAutopilots(1)if qw==2 then qw=true end end end;function pU.routeWP(ra,rb,rc)if rc then if rc==1 then bC={}bC=iu(bC,bB)if#bC>0 then bW="Route Loaded"else bW="No Saved Route found on Databank"end;return bC else bB={}bB=iu(bB,bC)bW="Route Saved"pT()return end end;if ra then return bC end;if rb then bC={}bW="Current Route Cleared"else bC[#bC+1]=fX.name;bW="Added "..fX.name.." to route. "end;return bC end;function pU.cmdThrottle(dB,rd)if is:getAxisCommandType(0)~=axisCommandType.byThrottle and not rd then d.control.cancelCurrentControlMasterMode()end;is:setThrottleCommand(axisCommandId.longitudinal,dB)bK=da(fM(dB*100,0)/100,-1,1)qj=nil end;function pU.cmdCruise(dB,rd)if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rd then d.control.cancelCurrentControlMasterMode()end;is:setTargetSpeedCommand(axisCommandId.longitudinal,dB)qj=dB end;function pU.ToggleLockPitch()if bq==nil then fL("lkPOn","LP")if not bV then bq=cM else bq=Q end;b4=false;b2=false;b3=false else fL("lkPOff","LP")bq=nil end end;function pU.ToggleAltitudeHold()if bJ-p_<1.5 then if j7.hasAtmosphere then if c8 then b7=j7.spaceEngineMinAltitude-0.01*j7.noAtmosphericDensityAltitude;fL("11","EP")else if cS then b7=j7.noAtmosphericDensityAltitude+T;cx=b7;q5=true;if not bw then cn.ToggleIntoOrbit()end;q3=true end end;p_=-1;if b2 or bw or b6 then return end end else p_=bJ end;if cS and not c8 then cx=ca;q5=true;q3=true;cn.ToggleIntoOrbit()if bw then p_=bJ else p_=0 end;return end;b2=not b2;b3=false;b5=false;if b2 then b0=false;a_=false;aZ=false;bU=false;ct=true;bq=nil;cy=false;if c7~=-1 and cF<20 then fL("lfs","LS")b4=true;if p_>-1 then b7=ca+W end;bj=false;d.control.retractLandingGears()aY="ATO Hold"is:setTargetGroundAltitude(X)if aX and cJ then cn.ToggleVerticalTakeoff()end else fL("altOn","AH")b4=false;if p_>-1 then if cS then b7=ca end end;if b6 then cn.ToggleVerticalTakeoff()end end;if cK and not q then local re=antigrav.getBaseAltitude()if fX.agg and fX.agg>ca then b7=fX.agg else b7=re end;if eP(ca-re)<50 and cF<20 then aY="AGG Hold"ql=0 end end;if c5 then b7=200000 end else fL("altOff","AH")if bw then cn.ToggleIntoOrbit()end;if b6 then cn.ToggleVerticalTakeoff()end;ct=p;b4=false;bn=false;p_=0 end end;function pU.ResetAutopilots(pU)if pU then c5=false;b0=false;b9=false;qa=false;b7=ca;r7=false;d5=false end;bn=false;b4=false;b5=false;a_=false;b3=false;d6=nil;rf=false;cR=nil;d5=false;if not cK then b2=false;bq=nil end;if b6 then cn.ToggleVerticalTakeoff()end;if bw then cn.ToggleIntoOrbit()end;ct=p;c4=false;c6=false;bT=0 end;function pU.BrakeToggle(rg)if not aY then if rg then aY=rg else aY=true end else aY=false end;if b3 then b3=false;ct=p;d5=false end;if aY then fL("bkOn","B",1)cn.ResetAutopilots()else fL("bkOff","B",1)end end;function pU.BeginReentry()if b5 then bW="Re-Entry cancelled"fL("reOff","RE")b5=false;ct=p;b2=false elseif not j7.hasAtmosphere then bW="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bX=5 elseif not qb then b5=true;if is:getAxisCommandType(0)~=rh.cruise then d.control.cancelCurrentControlMasterMode()end;ct=true;aY=false;bW="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cv;fL("par","RE")else b5=true;b2=true;ct=true;aY=false;b7=j7.surfaceMaxAltitude+Z;if b7>j7.spaceEngineMinAltitude then b7=j7.spaceEngineMinAltitude-0.01*j7.noAtmosphericDensityAltitude end;local ri=iw(b7)bW="Beginning Re-entry.  Target speed: "..cv.." Target Altitude: "..ri;fL("glide","RE")qm=bH(cv)end;b4=false end;function pU.ToggleAntigrav()if antigrav and not q then if cK then fL("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bs==nil then bs=ca end;if bs<1000 then bs=1000 end;fL("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pU.changeSpd(rj)local rk=1;if rj then rk=-1 end;if not bV then if t and not pc and q9 then local rl=bK;bK=fM(da(bK+rk*aA/100,-1,1),2)if bK>=0 and rl<0 then bK=0;q9=false end elseif pc then if c8 or b5 then cv=da(cv+rk*aA,0,U)elseif b0 then _=da(_+rk*aA/3.6*100,0,8333.00)end else is:updateCommandFromActionStart(axisCommandId.longitudinal,rk*aA/10)end else if b0 or bn or c5 or bw then cW=cW+1*rk*-1;if cW>#cO then cW=1 end;if cW<1 then cW=#cO end else if not rj then rk=1 else rk=nil end;cm.adjustAutopilotTargetIndex(rk)end end end;function pU.TenthTick()local function rm(oq,rn)if oq==nil then oq=b.g()end;oq=fM(oq,5)if rn~=nil and rn or(q8==nil or q8~=oq)then local fg=cD:len()local ro=ip(c.getData()).maxBrake;if ro~=nil and ro>0 and c8 then ro=ro/da(fg/100,0.1,1)ro=ro/c9;if c9>0.10 then if br then br=(br+ro)/2 else br=ro end end end;if ro~=nil and ro>0 then bp=ro end;q8=oq end end;rm(nil,true)if qj~=nil then if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or is:getTargetSpeed(axisCommandId.longitudinal)~=qj then qm=qj else qj=nil end end end;function pU.SatNavTick()if not r then return end;qx=dbHud_1.getStringValue("SPBAutopilotTargetName")if qx~=nil and qx~=""and qx~="SatNavNotChanged"then local dv=ip(dbHud_1.getStringValue("SavedLocations"))if dv~=nil then bm=dv;local gn=-1;local gt;for dA,dl in pairs(bm)do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn~=-1 then gt=bm[gn]gn=-1;for dA,dl in pairs(e[0])do if dl.name and dl.name=="SatNav Location"then gn=dA;break end end;if gn>-1 then e[0][gn]=gt end;cm.UpdateAtlasLocationsList()bW=gt.name.." position updated"end end;for K=1,#cO do if cO[K].name==qx then bi=K;a.print("Index = "..bi.." "..cO[K].name)cm.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pU.onFlush()local function rp(rq,rr)local rs=vec3()local rt=vec3()if rq==axisCommandId.longitudinal then rs=vec3(b.getConstructOrientationForward())rt=cB elseif rq==axisCommandId.vertical then rs=vec3(b.getConstructOrientationUp())rt=qi elseif rq==axisCommandId.lateral then rs=vec3(b.getConstructOrientationRight())rt=cC else return vec3()end;local ru=vec3(b.getWorldGravity())local rv=ru:dot(rt)local rw=vec3(b.getWorldAirFrictionAcceleration())local rx=rw:dot(rt)local ry=cD:dot(rs)local rz=rr*constants.kph2m;if rA==nil then rA=pid.new(10,0,10.0)end;rA:inject(rz-ry)local rB=rA:get()local rC=(rB-rx-rv)*rt;return rC end;local function rD(rq,rr)local rs=vec3()local rt=vec3()if rq==axisCommandId.longitudinal then rs=vec3(b.getConstructOrientationForward())rt=cB elseif rq==axisCommandId.vertical then rs=vec3(b.getConstructOrientationUp())rt=qi elseif rq==axisCommandId.lateral then rs=vec3(b.getConstructOrientationRight())rt=cC else return vec3()end;local ru=vec3(b.getWorldGravity())local rv=ru:dot(rt)local rw=vec3(b.getWorldAirFrictionAcceleration())local rx=rw:dot(rt)local ry=cD:dot(rs)local rz=rr*constants.kph2m;if rE==nil then rE=pid.new(10,0,10.0)end;rE:inject(rz-ry)local rB=rE:get()local rC=(rB-rx-rv)*rt;return rC end;local function rF(rG,jV,fT)local rH=rG:cross(fT):normalize_inplace()local kG=math.acos(da(rH:dot(-jV),-1,1))*constants.rad2deg;if rH:cross(-jV):dot(fT)<0 then kG=-kG end;return kG end;if antigrav and not q then if not cK and antigrav.getBaseAltitude()~=bs then qv=bs end end;cL=is:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local rI=da(bQ+qc+a.getControlDeviceForwardInput(),-1,1)local rJ=da(bR+qe+a.getControlDeviceYawInput(),-1,1)local rK=da(bS+qd-a.getControlDeviceLeftRightInput(),-1,1)local rL=aY and 1 or 0;cG=vec3(b.getWorldVertical())if cG==nil or cG:len()==0 then cG=(j7.center-cI):normalize()end;qi=vec3(b.getConstructWorldOrientationUp())cB=vec3(b.getConstructWorldOrientationForward())cC=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getWorldVelocity())cD=vec3(b.getVelocity())cI=vec3(b.getConstructWorldPos())cb=b.getConstructMass()cF=vec3(cE):len()cH=-cG:dot(cE)cN=getRoll(cG,cB,cC)local rM=cN/180*math.pi;local rN=math.cos(rM)local rO=math.sin(rM)cM=rF(cG,cB,cC*rN+qi*rO)local rP=cE:normalize()local rQ=eP(cN)local rR=utils.sign(cN)local rS=vec3(b.getWorldAngularVelocity())local rT=rI*aK*cC+rJ*aF*cB+rK*aL*qi;if ct==true and cG:len()>0.01 then local rU=eP(qf-cN)if((a_ or b5 or b3 or c4 or b2 or bw)and rU>0 or c8 and rU<aG and p)and rJ==0 and eP(cM)<85 then local rV=qf;local rW=aE;if not c8 then rW=rW/4;qf=0;rV=0 end;if rX==nil then rX=pid.new(rW*0.01,0,rW*0.1)end;rX:inject(rV-cN)local rY=rX:get()rT=rT+rY*cB end end;local rZ=1;local r_=0;local s0=1;bL=0;c8=false or ca<j7.noAtmosphericDensityAltitude;c9=bI()ca=b.getAltitude()c7=qF()bJ=bG()pZ=bJ;if E then q_()end;if antigrav then cK=antigrav.getState()==1 end;local s1=a.getMouseWheel()if s1>0 then cn.changeSpd()elseif s1<0 then cn.changeSpd(true)else q9=true end;local s2=1;local s3=1;local s4=bJ-pZ;local s5=-math.deg(qB(qi,cE,cB))local s6=math.deg(qB(cC,cE,cB))local gi=cG*-1;cu=c8 and s5<-L or s5>L or s6<-M or s6>M;local s7=a.getMouseDeltaX()local s8=a.getMouseDeltaY()if o and not bV then s8=-s8 end;qd=0;qe=0;qc=0;fP=ci[0]j7=fP:closestBody(b.getConstructWorldPos())s9=ck(j7)fk=s9:orbitalParameters(b.getConstructWorldPos(),cE)if ca==0 then ca=(cI-j7.center):len()-j7.radius end;cS=c.getClosestPlanetInfluence()>0 or ca>0 and ca<200000;local oq=j7:getGravity(b.getConstructWorldPos()):len()*cb;qf=0;local sa=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if qp==0 then if ir()==1 and bV then if not cr then c1=da(c1+s7/2,-cd/2,cd/2)c2=da(c2+s8/2,-ce/2,ce/2)end else c1=0;c2=0 end else c1=da(c1+s7/2,-cd/2,cd/2)c2=da(c2+s8/2,-ce/2,ce/2)c3=dc(c1*c1+c2*c2)if not bV and ir()==0 then local kP,kQ=1,1;if bE=="SCOPE"then kP,kQ=c_/90,c_/90 end;if g=="virtual joystick"then if c1>0 and c1>au then qd=qd-(c1-au)*aC*kP elseif c1<0 and c1<au*-1 then qd=qd-(c1+au)*aC*kP else qd=0 end;if c2>0 and c2>au then qc=qc-(c2-au)*aD*kQ elseif c2<0 and c2<au*-1 then qc=qc-(c2+au)*aD*kQ else qc=0 end else c1=0;c2=0;if g=="mouse"then qc=(-utils.smoothstep(s8,-100,100)+0.5)*2*s2;qd=(-utils.smoothstep(s7,-100,100)+0.5)*2*s3 end end end end;local sb=cF>8334;if cF>V/3.6 and not c8 and not b0 and not sb then bW="Space Speed Engine Shutoff reached"ql=0 end;if not sb and sc then if not aY then cn.BrakeToggle()end;if b0 then if not qw then qw=true end end end;sc=sb;if c9>0.09 then if cF>cv/3.6 and not t and not pV then aY="SpdLmt"pV=true elseif not t and pV then if cF<cv/3.6 then aY=false;pV=false end end end;if a_ then if c4 then aY=false;local sd=false;if fX and c4==true then sd=qQ(fX.position-cI,0.1)else sd=qQ(vec3(cE),0.01)end;ct=true;if sd then qm=bH(cv)if(eP(cN)<2 or eP(cM)>85)and cF>=cv/3.6-1 then aY=false;a_=false;if c4~=2 then qb=true end;if c4==true then c6=true end;c4=false;b0=false;cn.BeginReentry()end elseif c8 and t then ql=1 end elseif cF>iL then qQ(vec3(cE),0.01)end end;if aZ then if c8 then aZ=false elseif cF>iL then qQ(-vec3(cE))end end;if not a_ and c4 and not bw then if not c8 then if c4~=2 then qb=true end;cn.BeginReentry()c4=false;c6=true else c4=false;if not qw then qw=true end end end;if c6 and fX and(ca<b7+250 and ca>b7-250)and cF*3.6>cv-250 and eP(cH)<25 and c9>=0.1 and(fX.position-cI):len()>2000+ca then if not qw then qw=true end;c6=false end;if b6 then ct=true;local se=b7;if cH<-30 then bW="Unable to achieve lift. Safety Landing."bT=0;ct=p;b6=false;b3=true elseif not q and cK or b7<j7.spaceEngineMinAltitude then if cK then se=antigrav.getBaseAltitude()end;if ca<se-100 then qg=0;bT=15;aY=false elseif cH>0 then aY="VTO Limit"bT=0 elseif cH<-30 then aY="VTO Fall"bT=15 elseif ca>=se then if cK then if b0 or bn then cn.ToggleVerticalTakeoff()else aY="VTO Complete"b6=false end;bW="Takeoff complete. Singularity engaged"fL("aggLk","AG")else aY=false;bW="VTO complete. Engaging Horizontal Flight"fL("vtoc","VT")cn.ToggleVerticalTakeoff()end;bT=0 end else if c9>0.08 then qg=0;aY=false;bT=20 elseif c9<0.08 and c8 then aY=false;if cz then qg=0;bT=20 else bT=0;qg=36;qm=3500 end else ct=p;bw=true;cy=false;sf=false;q3=false;q1=nil;q2=nil;if q6==nil then q6=j7 end;cx=se;q5=true;b6=false end end;if qg~=nil then if sg==nil then sg=pid.new(2*0.01,0,2*0.1)end;local sh=da(qg-cM,-M*0.80,M*0.80)sg:inject(sh)local si=da(sg:get(),-1,1)qc=si end end;if bw then local function sj()if fk.periapsis.altitude>=cx*0.99 and fk.apoapsis.altitude>=cx*0.99 and fk.periapsis.altitude<fk.apoapsis.altitude and fk.periapsis.altitude*1.05>=fk.apoapsis.altitude and eP(cx-ca)<1000 then return true else return false end end;local qX;local sk=false;local sl=iw(cx)if q6==nil then q6=j7;if bn then q6=c0 end end;if not q5 then cx=bH(q6.radius+q6.surfaceMaxAltitude+T)if q6.hasAtmosphere then cx=bH(q6.radius+q6.noAtmosphericDensityAltitude+T)end;q5=true end;if qh.VectorToTarget and fX then qX=fX.position-cI end;local sm,sn=ck(q6):escapeAndOrbitalSpeed((cI-q6.center):len()-q6.radius)local so=cN;if not q3 then local sp=false;local sq=false;ql=0;q2=0;cw="Aligning to orbital path - OrbitHeight: "..sl;if qh.VectorToTarget then qQ(qX:normalize():project_on_plane(cG))sk=cB:dot(qX:project_on_plane(qi):normalize())>0.95 else qQ(cE)sk=s5<0.5;if cF<150 then sk=true end end;qc=0;q1=0;if cM<=q1+2 and cM>=q1-2 then sp=true else sp=false end;if so<=q2+2 and so>=q2-2 then sq=true else sq=false end;if sp and sq and sk then q1=nil;q2=nil;q3=true end else if qh.VectorToTarget then qQ(qX:normalize():project_on_plane(cG))elseif cF>150 then qQ(cE)end;qc=0;if qh.VectorToTarget and fX then local bZ,dF=cj.computeDistanceAndTime(cF,cv/3.6,cb,0,0,bp)if cy and qX:len()>15000+bZ+ca then cw="Orbiting to Target"if ca-100<=q6.noAtmosphericDensityAltitude or lH>fk.timeToPeriapsis and fk.periapsis.altitude<q6.noAtmosphericDensityAltitude or not sj()and fk.eccentricity>0.1 then bW="Re-Aligning Orbit"cy=false end elseif cy or qX:len()<15000+bZ+ca then bW="Orbit complete, proceeding with reentry"fL("orCom","OB")bh=fX.position;qb=true;c6=true;qh.VectorToTarget,qh.AutopilotAlign=false,false;cn.ToggleIntoOrbit()cn.BeginReentry()return end end;if fk.periapsis~=nil and fk.apoapsis~=nil and fk.eccentricity<1 and ca>cx*0.9 and ca<cx*1.4 then if fk.apoapsis~=nil then if sj()or cy then if cy then aY=false;ql=0;q1=0;if not qh.VectorToTarget then bW="Orbit complete"fL("orCom","OB")cn.ToggleIntoOrbit()end else q7=q7+1;if q7>=2 then cy=true end end else cw="Adjusting Orbit - OrbitHeight: "..sl;q4=true;qm=sn*3.6+1;local sr=cx-ca;if ss==nil then ss=pid.new(0.1,0,1*0.1)end;ss:inject(sr-cH*da(utils.smoothstep(2000-sr,-2000,2000)^6*10,1,10))q1=da(ss:get(),-60,60)end end else local st=2.75;local su=eP(fM(sm*st))local oF=su%50;if oF>0 then su=su-oF+50 end;aY=false;if ca<cx*0.8 then cw="Escaping planet gravity - OrbitHeight: "..sl;q1=utils.map(cH,200,0,-15,80)elseif ca>=cx*0.8 and ca<cx*1.15 then cw="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;q1=utils.map(cH,100,-100,-15,65)elseif ca>=cx*1.15 and ca<cx*1.5 then cw="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;if cH<0 or q4 then q1=utils.map(ca,cx*1.5,cx*1.01,-30,0)else q1=utils.map(ca,cx*0.99,cx*1.5,0,30)end elseif ca>cx*1.5 then cw="Reentering orbital corridor - OrbitHeight: "..sl;q1=-65;local sv=utils.map(cH,-150,-400,1,0.55)su=su*sv end;qm=bH(su)end end;if q1~=nil then if sw==nil then sw=pid.new(1*0.01,0,5*0.1)end;local sx=q1-cM;sw:inject(sx)local sy=da(sw:get(),-0.5,0.5)qc=sy end end;if b0 and not c8 and not c4 then local function sz(i2,fk)a.print(i2)aY=false;ba=false;b0=false;r7=false;bd="Aligning"ql=0;qa=false;bW=i2;fL("apCom","AP")if fk or c4 then if fk and gg~=nil and not c4 then if not ca or ca==0 then return end;cx=ca;q5=true end;cn.ToggleIntoOrbit()end end;local sA,sB=bh,false;if fX and fX.planetname~="Space"then b9=true;if not r7 then local sC=(fX.position-c0.center):normalize()local sD=sC:project_on_plane((c0.center-cI):normalize()):normalize()local sE=c0.center+sD*(c0.radius+gg)local sF=fX.position+(fX.position-c0.center):normalize()*(gg-c0:getAltitude(fX.position))if(cI-sE):len()<(cI-sF):len()then sA=sE else sA=sF;bc=0 end;bh=sA;cn.showWayPoint(c0,bh)sB=true;r7=true end;be=0 elseif fX and fX.planetname=="Space"then if not r7 then be=0;sB=true;b9=true;r7=true;sA=fX.position+(cI-fX.position):normalize()*R;bh=sA end elseif fX==nil then be=0;if not r7 then local sC=(cI+cE*100000-c0.center):normalize()local sD=sC:project_on_plane((c0.center-cI):normalize()):normalize()if sD:len()<1 then sC=(cI+cB*100000-c0.center):normalize()sD=sC:project_on_plane((c0.center-cI):normalize()):normalize()end;sA=c0.center+sD*(c0.radius+gg)bh=sA;r7=true;sB=true;b9=true;cn.showWayPoint(c0,bh)end end;pp=(vec3(sA)-cI):len()local lF,ez,eA=ci:getPlanetarySystem(0):castIntersections(cI,cE:normalize(),function(ei)if ei.noAtmosphericDensityAltitude>0 then return ei.radius+ei.noAtmosphericDensityAltitude else return ei.radius+ei.surfaceMaxAltitude*1.5 end end)local lG=ez;if eA~=nil and ez~=nil then lG=math.min(eA,ez)end;if lG~=nil and lG<pp and lF.name==c0.name then pp=lG end;local sd=true;local sG=(c0.center-(cI+vec3(cE):normalize()*pp)):len()-c0.radius;local ls=iw(sG)qt=g8;qu='{"label": "Projected Altitude", "value": "'..ls..'"}'local bZ,b_;if not b1 then bZ,b_=qy(cF)else bZ,b_=qA(cF)end;if cF>50 and b8 then local qX=vec3(sA)-cI;local sH=da(math.deg(qB(qi,cE:normalize(),qX:normalize()))*cF/500,-90,90)local sI=da(math.deg(qB(cC,cE:normalize(),qX:normalize()))*cF/500,-90,90)if eP(sH)<20 and eP(sI)<20 then sH=sH*2;sI=sI*2 end;if eP(sH)<2 and eP(sI)<2 then sH=sH*2;sI=sI*2 end;local s5=-math.deg(qB(qi,cB,cE:normalize()))local s6=-math.deg(qB(cC,cB,cE:normalize()))if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sI-s6)local sK=da(sJ:get(),-1,1)qc=qc+sK;if sL==nil then sL=pid.new(2*0.01,0,2*0.1)end;sL:inject(sH-s5)local sM=da(sL:get(),-1,1)qd=qd+sM;sB=true;if eP(sH)>2 or eP(sI)>2 then if bd~="Adjusting Trajectory"then bd="Adjusting Trajectory"fL("apAdj","AP")end else if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end end elseif b8 and cF<=50 then qQ((sA-cI):normalize())end;if sG<gg*1.5 then if fX and fX.planetname=="Space"then bc=0 elseif fX==nil then dF,bc=ck(c0):escapeAndOrbitalSpeed(sG)end end;if b0 and not b8 and not bb and not ba then local lF,lG=cn.checkLOS((bh-cI):normalize())if c0.name~=j7.name then if lF~=nil and c0.name~=lF.name and lG<pp then bW="Collision with "..lF.name.." in "..iw(lG).."\nClear LOS to continue."bX=5;qq=true else qq=false;bW=""end end end;if not qq then if not bb and not ba and not sB then sd=qQ((sA-cI):normalize())elseif b1 and(ba or bb)then sd=qQ(-vec3(cE):normalize())end end;if b8 then if not qa then aY=false;ql=a0;bK=fM(a0,2)qa=true end;local pq=c.getThrottle()if t then pq=bK end;local sN=99999;local oD=-vec3(b.getWorldAcceleration()):dot(cE:normalize())local sO=da(cE:dot((sA-cI):normalize()),0,cF)if sO>0 or oD>0 then sN=cj.computeTravelTime(sO,oD,pp-bZ)end;if cD:len()>=_ or pq==0 and qa or a1/4>sN then b8=false;if bd~="Cruising"then fL("apCru","AP")bd="Cruising"end;bb=true;ql=0 end;local sP=pp;if sP<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pW and cQ>2000 then if not qw then qw=true end;bW="Autopilot cancelled to prevent crossing PvP Line"aY="PvP Prevent"pW=cQ else pW=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true;ql=0;qa=false end elseif ba then if bd~="Orbiting to Target"then aY="AP Brk"end;if b1 then ql=1;qn=true end;local dF,sn=ck(c0):escapeAndOrbitalSpeed((cI-j7.center):len()-j7.radius)local qX;if fX then qX=fX.position-cI end;if fX and fX.planetname=="Space"and cF<50 then if#bC>0 then if not qw then table.remove(bC,1)end;if#bC>0 then aY=false;if not qw then qw=2 end;return end end;sz("Autopilot complete, arrived at space location")aY="Space Arrival"elseif fX and fX.planetname~="Space"and cF<=sn and(fk.apoapsis==nil or fk.periapsis==nil or fk.apoapsis.altitude<=0 or fk.periapsis.altitude<=0)then sz("Autopilot complete, commencing reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,bh)elseif(fX and fX.planetname~="Space"or fX==nil)and fk.periapsis~=nil and fk.periapsis.altitude>0 and fk.eccentricity<1 or bd=="Circularizing"then if bd~="Circularizing"then fL("apCir","AP")bd="Circularizing"end;if cF<=sn then if fX then if cE:normalize():dot(qX:normalize())>0.4 then if bd~="Orbiting to Target"then fL("apOrb","OB")bd="Orbiting to Target"end;if not r9 then aY=false;cn.showWayPoint(c0,fX.position)r9=true end else sz("Autopilot complete, proceeding with reentry")bh=fX.position;c4=true;cn.showWayPoint(c0,fX.position)r9=false end else sz("Autopilot completed, setting orbit",true)aY=false end end elseif bd=="Circularizing"then sz("Autopilot complete, fixing Orbit",true)end elseif bb then local sP=pp;if sP<=bZ or H and cQ<=bZ+10000 and cP then if H and cQ<=bZ+10000 and cP then if cQ<pW and cQ>2000 then if not qw then qw=true end;bW="Autopilot cancelled to prevent crossing PvP Line"aY="Prevent PvP"pW=cQ else pW=cQ;return end end;b8=false;if bd~="Braking"then fL("apBrk","AP")bd="Braking"end;ba=true end;local pq=c.getThrottle()if t then pq=bK end;if pq>0 then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;bb=false end else if sd then if not b9 and fX==nil or not b9 and fX and fX.planetname~="Space"then if not c4 then bh=vec3(c0.center)+(gg+c0.radius)*cC;sQ=qi;sR=cC end;b9=true elseif sd and not qq then b8=true;if bd~="Accelerating"then bd="Accelerating"fL("apAcc","AP")end;if not qa then ql=a0;qn=true;bK=fM(a0,2)qa=true;aY=false end end end end elseif b0 and(fX~=nil and fX.planetname~="Space"and c8)then bW="Autopilot complete, starting reentry"fL("apCom","AP")bh=fX.position;aY=false;ba=false;b0=false;r7=false;bd="Aligning"ql=0;qa=false;a_=true;c4=true;cn.showWayPoint(c0,fX.position)end;if bU then ct=true;local sI=0;local fm=cI+vec3(c.getMasterPlayerRelativePosition())local sS=fm-cI;local sT=vec3(sS):project_on(cB):len()local sU=vec3(sS):project_on(cC):len()local c3=dc(sT*sT+sU*sU)qQ(sS:normalize())local mM=40;local sV=c3<mM;local sW=100;local rr=da((c3-mM)/2,10,sW)qc=0;local sd=eP(qd)<0.1;if sd and cF<rr and not sV then aY=false;sI=-20 else aY="Follow"sI=0 end;local sX=0;if eP(sI-cM)>sX then if sY==nil then sY=pid.new(2*0.01,0,2*0.1)end;sY:inject(sI-cM)local sK=sY:get()qc=sK end end;if b2 or b3 or b5 or bn or bq~=nil then local sZ=br;if sZ then sZ=sZ*da(cF/100,0.1,1)*c9 else sZ=bp end;if not c8 then sZ=bp end;qk=cB:project_on_plane(cG):normalize():dot(cE)if qk>100 then bZ,b_=cj.computeDistanceAndTime(qk,100,cb,0,0,sZ)local s_,t0=cj.computeDistanceAndTime(100,0,cb,0,0,sZ*0.55)bZ=bZ+s_ else bZ,b_=cj.computeDistanceAndTime(qk,0,cb,0,0,sZ*0.55)end;if not q and cK and not b5 and b7<antigrav.getBaseAltitude()then b7=antigrav.getBaseAltitude()end;local sr=b7-ca-cH;local t1=200+cF;if b5 or c4 then t2=2000+cF end;local t3=1;if b4 then t3=da(cF/100,0.1,1)end;local sI=(utils.smoothstep(sr,-t1,t1)-0.5)*2*O*t3;if not b5 and not c4 and not bn and cB:dot(cE:normalize())<0.99 then sI=(utils.smoothstep(sr,-t1*da(20-19*c9*10,1,20),t1*da(20-19*c9*10,1,20))-0.5)*2*O*da(2-c9*10,1,2)*t3 end;if not b2 then sI=0 end;if bq~=nil then if cS and not bw then sI=bq else bq=nil end end;ct=true;local t4=qc;if b5 then local t5=bH(cv)local t6,t7=cj.computeDistanceAndTime(cF,t5/3.6,cb,0,0,bp-j7.gravity*9.8*cb)t6=t6==-1 and 5000 or t6;local r8=ca-(j7.noAtmosphericDensityAltitude+t6)local t8=ca>j7.noAtmosphericDensityAltitude+t6*1.35;if t8 then sI=P;if cF<=t5/3.6 and cF>t5/3.6-10 and eP(cE:normalize():dot(cB))>0.9 and not cL then bO=false;ql=1 end elseif(cL or is:getTargetSpeed(axisCommandId.longitudinal)~=t5)and not t8 and not c8 then qm=t5;qn=true end;if cL then if cF>t5/3.6 and not t8 then aY="Reentry Limit"else aY=false end else aY=false end;if cH>0 then aY="Reentry vSpd"end;if not qb then sI=-80;if ca<j7.surfaceMaxAltitude+(j7.atmosphereThickness-j7.surfaceMaxAltitude)*0.25 then bW="PARACHUTE DEPLOYED at "..fM(ca,0)b5=false;b3=true;lA=true;ql=0;sI=0;ct=p end elseif j7.noAtmosphericDensityAltitude>0 and t8 then ct=true elseif not t8 then if not c8 and(cL or is:getTargetSpeed(axisCommandId.longitudinal)~=t5)then qm=t5 end;if cF<t5/3.6+1 then aY=false;qb=false;b5=false;ct=true end end end;if cF>iL and not c5 and not bn and not b3 and u then qQ(vec3(cE))end;if cR or(bn or c5)and bi>0 and c8 then local qX;if cR then if type(cR)=="table"then qX=cR elseif cR<3 and cR>0 then qX=-cG:cross(cE)*5000 elseif cR>=3 then qX=cG:cross(cE)*5000 elseif cR<0 then qX=cE*25000 end elseif fX~=nil then qX=fX.position-cI else qX=c0.center-cI end;local sH=math.deg(qB(cG:normalize(),cE,qX))*2;local mP=math.rad(eP(cN))if cF>aH and c8 then local t9=1000+cF;local ta=(utils.smoothstep(sr-cH*10,-t9,t9)-0.5)*2*O;local tb=da(90-ta,0,180)qf=da(sH*2,-tb,tb)local tc=sH;sH=da(da(sH,-L*0.80,L*0.80)*math.cos(mP)+4*(cM-sI)*math.sin(math.rad(cN)),-L*0.80,L*0.80)local td=1;if qf~=0 then td=eP(mP/qf)end;td=(90-da(eP(qf-cN),0,90))/90;local te=sI;if eP(cN)>90 then te=-te end;sI=td*da(da(te*math.cos(mP),-M*0.8,M*0.8)+eP(da(eP(tc)*math.sin(mP),-M*0.80,M*0.80)),-M*0.80,M*0.80)else qf=0;sH=da(sH,-L*0.80,L*0.80)end;local tf=s5-sH;if cR and eP(tf)<=0.0001 and(type(cR)=="table"or type(cR)~="table"and cR<0 and eP(cN)<1)then if cR==-2 then cn.ToggleAltitudeHold()end;cR=nil;fL("180Off","BR")return end;if not cu and cF>aH and c8 then if tg==nil then tg=pid.new(2*0.01,0,2*0.1)end;tg:inject(tf)local sM=da(tg:get(),-1,1)qd=qd+sM elseif c8 and c7>-1 or cF<aH then qQ(qX)elseif cu and c8 then if(s5<-L or s5>L)and c8 then qQ(cE)end;if(s6<-M or s6>M)and c8 then sI=da(cM-s6,cM-M*0.80,cM+M*0.80)end end;if fX~=nil and not c5 then local se=j7:getAltitude(fX.position)local r8=qX:project_on_plane(cG):len()lA=true;if not c5 and not b4 and not b5 and(r8<=bZ and qX:len()<j7.radius)and(cE:project_on_plane(cG):normalize():dot(qX:project_on_plane(cG):normalize())>0.99 or lJ=="Finalizing Approach")then lJ="Finalizing Approach"if#bC>0 then if not qw then table.remove(bC,1)end;if#bC>0 then if not qw then qw=2 end;return end end;ql=0;if b2 then cn.ToggleAltitudeHold()bn=true end;aY="AP Finalizing"elseif not b4 then aY=false end;if lJ=="Finalizing Approach"and(qk<0.1 or r8<0.1 or th~=nil and th<r8)then fL("bklOn","BL")b3=true;d5=true;if fX.heading then d6=fX.heading else d6=nil end;bn=false;lJ="Proceeding to Waypoint"cT=false end;th=r8 end elseif bn and not c8 and b7>j7.noAtmosphericDensityAltitude and not(c5 or b5)then if fX~=nil and c0.name==j7.name then local qX=fX.position-cI;local se=j7:getAltitude(fX.position)local r8=dc(qX:len()^2-(ca-se)^2)local sZ=br;if sZ then bZ,b_=cj.computeDistanceAndTime(cF,0,cb,0,0,sZ/2)lA=true;if r8<=bZ+cF*s4/2 and cE:project_on_plane(cG):normalize():dot(qX:project_on_plane(cG):normalize())>0.99 then if j7.hasAtmosphere then aY=false;a_=false;qb=true;c4=false;c6=true;b0=false;cn.BeginReentry()end end;th=r8 end end end;if not c8 and(b2 and b7>j7.noAtmosphericDensityAltitude)and not(c5 or bw or b5)then if not cy and not bw then cx=b7;q5=true;if bn then qh.VectorToTarget=true end;cn.ToggleIntoOrbit()bn=false;q3=true end end;if cu and c8 and c7==-1 and cF>aH and lJ~="Finalizing Approach"then qQ(cE)sI=da(cM-s6,cM-M*0.80,cM+M*0.80)end;qc=t4;local qK=-1;if b3 then if not qr then if not cL then ql=0 end;is:setTargetGroundAltitude(500)is:activateGroundEngineAltitudeStabilization(500)by=true;qr=true end;sI=0;local ti=false;local tj=math.abs(qk)if not q and cK then ti=antigrav.getBaseAltitude()if ti<j7.surfaceMaxAltitude and fX==nil or fX~=nil and j7:getAltitude(fX.position)>ti then ti=false end end;if d6 then if tj<0.05 then if cH>-N then aY=false else aY="BL Align BLR"end;if qQ(d6,0.001)then d6=nil;ct=p else qc=0;ct=true end else aY="BL Align Hzn"end else local tk=false;local tl=30;if tj<10 and sa~=nil and sa>0 then local tm=da(c9,0.4,2)local sZ=br*da(cF/100,0.1,1)*tm;local tn=sa*tm+sZ-oq;local to=sZ/2-oq;local tp=cF-dc(eP(to/2)*20/(0.5*cb))*utils.sign(to)if tp<0 then tp=0 end;local tq;if cF>100 then local tr,dF=cj.computeDistanceAndTime(cF,100,cb,0,0,sZ)local ts,dF=cj.computeDistanceAndTime(100,0,cb,0,0,dc(sZ))tq=tr+ts else tq=cj.computeDistanceAndTime(cF,0,cb,0,0,dc(sZ))end;if tq<20 then aY=false else local tt=0;if tp>100 then local tu,dF=cj.computeDistanceAndTime(tp,100,cb,0,0,tn)local tv,dF=cj.computeDistanceAndTime(100,0,cb,0,0,sa*tm+dc(sZ)-oq)tt=tu+tv else tt,dF=cj.computeDistanceAndTime(tp,0,cb,0,0,sa*tm+dc(sZ)-oq)end;tt=(tt+15+cF*s4)*1.1;local tw=d5 and fX~=nil and j7:getAltitude(fX.position)>0 and fX.safe;local se=nil;if ti and ti<ca then se=ti elseif tw then se=j7:getAltitude(fX.position)+250 elseif ca>j7.surfaceMaxAltitude then se=j7.surfaceMaxAltitude end;if cU then local tx=j7:getAltitude(cU[1].center)if se then if tx>se then se=tx end else se=tx end end;if se~=nil then local ty=ca-se;tk=true;if ty<=tt or tt==-1 or tj>0.05 and d5 then if tj>0.05 and d5 then aY="BL AP Hzn"else aY="BL Stop Dist"end else aY=false end end end end;qK=c7;if qK==-1 and ti and eP(ca-ti)<100 then if not d6 then b3=false;ct=p;d5=false end;aY="BL AGG Comp"elseif qK>-1 then if(cF<1 or cE:normalize():dot(cG)<0)and not d6 then b3=false;b2=false;bj=true;if bP then qo=true;fL("grOut","LG",1)end;is:setTargetGroundAltitude(Y)bT=0;aY="BL Complete"ct=p;d5=false else aY="BL Slowing"end elseif not tk then if lA and cE:normalize():dot(-gi)<0.999 then aY="BL Strong"qQ()elseif tj>10 or tj>0.05 and d5 then aY="BL hSpd"elseif cH<-N then aY="BL BLR"else aY=false end end end else qr=false end;if b4 or c5 then local lF,eA,ez;if bh~=nil then lF,eA,ez=ci:getPlanetarySystem(0):castIntersections(cI,(bh-cI):normalize(),function(ei)return ei.radius+ei.noAtmosphericDensityAltitude end)end;if cK and not c5 then if ca>=b7-50 then b4=false;if not b0 and not bn then aY="ATO Agg Arrive"ql=0 end end elseif eP(sI)<15 and ca/b7>0.75 then b4=false;if not c5 then if cL and not t then d.control.cancelCurrentControlMasterMode()end elseif c5 and cF<iL then b0=true;c5=false;b2=false;b4=false;ql=0 elseif c5 then ql=0;aY="ATO Space"end elseif c5 and not c8 and c0~=nil and(lF==nil or lF.name==c0.name)then b0=true;c5=false;b2=false;b4=false;if not cL then ql=0 end;b8=true end end;local tz=c7>-1;local tA=cM;if(bn or c5 or cR)and not tz and cF>aH and c8 then local mP=math.rad(eP(cN))tA=cM*eP(math.cos(mP))+s6*math.sin(mP)end;local tB=da(sI-tA,-M*0.80,M*0.80)if not c8 and bn then tB=da(sI-tA,-85,O)elseif not c8 then tB=da(sI-tA,-O,O)end;if eP(cN)<5 or bn or cR or b3 or tz or b2 then if sY==nil then sY=pid.new(5*0.01,0,5*0.1)end;sY:inject(tB)local sK=sY:get()qc=qc+sK end end;if antigrav~=nil and(antigrav and not q and ca<200000)then if bs==nil or bs<1000 then bs=1000 end;if tC~=bs then tC=bs;qv=tC end end;if c8 and t and cL then if tD==nil then tD=pid.new(0.1,0,1)end;local tE=0;if aR>0 and not b5 and c9>0.005 and c9<0.1 and cH>-50 then tE=(0.1-c9)*cv*aR end;tD:inject(cv/3.6+tE-cE:dot(cB))local tF=tD:get()bN=da(tF,-1,1)if not d1 then if bN<bK and c9>0.005 then bM=true;d1=da(bN,0.01,1)else bM=false;d1=bK end end;if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cE:len()-cv/3.6-tE)local tH=da(tG:get(),0,1)if c8 and cH<-80 or c9>0.005 then bL=tH end;if bL>0 then if bM and bN==0.01 and not d1 then d1=0 end else bN=da(bN,0.01,1)end;local tI=''local tJ=vec3()local tK=rp(axisCommandId.vertical,bT*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tK,r_)local tL='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tL=tL..aS end;local tM=is:getAxisCommandType(axisCommandId.longitudinal)local tN=is:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)local tO=rD(axisCommandId.lateral,bv*1000)tI=tI..' , '.."lateral airfoil , lateral ground "tJ=tJ+tO;if tJ:len()>constants.epsilon then d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end;d:setEngineForceCommand(tL,tN,rZ)local tP='thrust analog vertical fueled 'local tQ='thrust analog lateral fueled 'if bz=="All"or bz=="Lateral"then tQ=tQ..aT end;if bz=="All"or bz=="Vertical"then tP=tP..aU end;if bT~=0 or b3 and aY or not bj and not by then d:setEngineForceCommand(tP,tK,rZ)else d:setEngineForceCommand(tP,vec3(),rZ)end;if bv~=0 then d:setEngineForceCommand(tQ,tO,rZ)else d:setEngineForceCommand(tQ,vec3(),rZ)end;if rL==0 then rL=bL end;local tR=-rL*(aM*cE+aN*rP)d:setEngineForceCommand('brake',tR)else if t then if not d1 then d1=bK end end;local rr=c.getAxisCommandValue(0)if not cL then if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cE:len()-rr/3.6)local tH=da(tG:get(),0,1)rL=da(rL+tH,0,1)end;local tR=-rL*(aM*cE+aN*rP)d:setEngineForceCommand('brake',tR)local tI=''local tJ=vec3()local tS=false;local tL='thrust analog longitudinal 'if bz=="All"or bz=="Longitude"then tL=tL..aS end;local tM=is:getAxisCommandType(axisCommandId.longitudinal)if tM==axisCommandType.byThrottle then local tN=is:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)d:setEngineForceCommand(tL,tN,rZ)elseif tM==axisCommandType.byTargetSpeed then local tN=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tI=tI..' , '..tL;tJ=tJ+tN;if is:getTargetSpeed(axisCommandId.longitudinal)==0 or is:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-is:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tS=true end end;local tQ='thrust analog lateral 'if bz=="All"or bz=="Lateral"then tQ=tQ..aT end;local tT=is:getAxisCommandType(axisCommandId.lateral)if tT==axisCommandType.byThrottle then local tU=is:composeAxisAccelerationFromThrottle(tQ,axisCommandId.lateral)d:setEngineForceCommand(tQ,tU,rZ)elseif tT==axisCommandType.byTargetSpeed then local tO=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tI=tI..' , '..tQ;tJ=tJ+tO end;local tP='thrust analog vertical 'if bz=="All"or bz=="Vertical"then tP=tP..aU end;local tV=is:getAxisCommandType(axisCommandId.vertical)if tV==axisCommandType.byThrottle then local tK=is:composeAxisAccelerationFromThrottle(tP,axisCommandId.vertical)if bT~=0 or b3 and aY then d:setEngineForceCommand(tP,tK,rZ,'airfoil','ground','',s0)else d:setEngineForceCommand(tP,vec3(),rZ)d:setEngineForceCommand('airfoil vertical',tK,rZ,'airfoil','','',s0)d:setEngineForceCommand('ground vertical',tK,rZ,'ground','','',s0)end elseif tV==axisCommandType.byTargetSpeed then if bT<0 then d:setEngineForceCommand('hover',vec3(),rZ)end;local tW=is:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tI=tI..' , '..tP;tJ=tJ+tW end;if tJ:len()>constants.epsilon then if rL~=0 or tS or eP(rP:dot(cB))<0.5 then tI=tI..', brake'end;d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end end;local tX=aJ*(rT-rS)local tY=vec3(b.getWorldAirFrictionAngularAcceleration())tX=tX-tY;d:setEngineTorqueCommand('torque',tX,rZ,'airfoil','','',s0)d:setBoosterCommand('rocket_engine')if bY and not n then local fg=cD:len()local tZ=0.15;if not cL then local t_=is:getTargetSpeed(axisCommandId.longitudinal)if fg*3.6>t_*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fg*3.6<t_*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local pq=c.getThrottle()if t then pq=bK*100 end;local rr=pq/100;if bI==0 then rr=rr*_;if fg>=rr*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fg<rr*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local t5=bH(cv)rr=rr*t5/3.6;if fg>=rr*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fg<rr*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end end end end end;if u1 then for dA,dl in pairs(u1)do pU[dA]=dl end end;c7=qF()return pU end;local function u2(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ir,is,it,u3,gD,fM,dV,db,da,fL,iv,pT)local u4={}local u5=true;local u6=5;local u7=5;local u8=u6;local u9=u7;local ua=bJ;function u4.startControl(ub)local function uc(rj)local rk=1;local function ud(ue,rj)local uf={j7.surfaceMaxAltitude+100,j7.spaceEngineMinAltitude-0.01*j7.noAtmosphericDensityAltitude,j7.noAtmosphericDensityAltitude+T,j7.radius*(S-1)+j7.noAtmosphericDensityAltitude}local ug=ue;for dF,dl in ipairs(uf)do if rj and ug>dl then ue=dl elseif ue<dl and not rj then ue=dl;break end end;return ue end;if rj then rk=-1 end;if not q and cK then if bV and rj then bs=1000 elseif bs~=nil then bs=bs+rk*u7;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end else bs=tC+rk*100 end elseif b2 or b6 or bw then if bw then if bV then cx=ud(cx,rj)else cx=cx+rk*u6 end;if cx<j7.noAtmosphericDensityAltitude then cx=j7.noAtmosphericDensityAltitude end else if bV and c8 then b7=ud(b7,rj)else b7=b7+rk*u6 end end else is:updateTargetGroundAltitudeFromActionStart(rk*1.0)end end;local function uh(ui)if not c8 then bW="Flight Assist in Atmo only"return end;local di=type(ui)if cR==nil then if di=="table"then if b0 or bn then cn.ToggleAutopilot()end;fL("180On","BR")elseif ui==1 then fL("bnkLft","BR")else fL("bnkRht","BR")end;if not b2 and not b0 and not bn then cn.ToggleAltitudeHold()if di~="table"then ui=ui+1 end end;cR=ui else fL("180Off","BR")cR=nil end end;if ub=="gear"then bj=not bj;if bj then bn=false;bq=nil;cn.cmdThrottle(0)if vBooster or hover then if c8 and c7==-1 then fL("bklOn","BL")lA=true;b5=false;b4=false;b6=false;b2=false;if b3 then d5=not d5 end;b3=true;ct=true;bj=false else if bP then fL("grOut","LG",1)d.control.extendLandingGears()end;d5=false;is:setTargetGroundAltitude(Y)if c8 then aY="Landing"end end end;if bP and not b3 and not(vBooster or hover)then fL("grOut","LG",1)d.control.extendLandingGears()end else if bP then fL("grIn","LG",1)d.control.retractLandingGears()end;is:setTargetGroundAltitude(X)end elseif ub=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ub=="forward"then bQ=bQ-1 elseif ub=="backward"then if pc then uh(-cE*5000)else bQ=bQ+1 end elseif ub=="left"then if pc then uh(1)else bR=bR-1 end elseif ub=="right"then if pc then uh(3)else bR=bR+1 end elseif ub=="yawright"then bS=bS-1;d6=nil elseif ub=="yawleft"then bS=bS+1;d6=nil elseif ub=="straferight"then is:updateCommandFromActionStart(axisCommandId.lateral,1.0)bv=1 elseif ub=="strafeleft"then is:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bv=-1 elseif ub=="up"then bT=bT+1;is:deactivateGroundEngineAltitudeStabilization()is:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ub=="down"then bT=bT-1;is:deactivateGroundEngineAltitudeStabilization()is:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ub=="groundaltitudeup"then uc()elseif ub=="groundaltitudedown"then uc(true)elseif ub=="option1"then uj=false;if pc and bV then local uk=""for K=1,#cX do uk=uk.."| Name: "..a.getPlayerName(cX[K]).." Mass: "..fM(b.getBoardedPlayerMass(cX[K])/1000,1).."t "end;a.print("Onboard: "..uk)return end;cm.adjustAutopilotTargetIndex()elseif ub=="option2"then uj=false;if pc and bV then for K=1,#cX do b.forceDeboard(cX[K])end;bW="Deboarded All Passengers"return end;cm.adjustAutopilotTargetIndex(1)elseif ub=="option3"then local function ul()u5=not u5;if not u5 then fL("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(um,atmofueltank_size,"Atmo Fuel","fuel_container")un=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uo,spacefueltank_size,"Space Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uq,rocketfueltank_size,"Rocket Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;us=a.createWidgetPanel("Docking")ut=a.createWidget(us,"parenting")a.addDataToWidget(c.getDataId(),ut)uu=a.createWidgetPanel("Core combat stress")uv=a.createWidget(uu,"core_stress")a.addDataToWidget(b.getDataId(),uv)if shield_1~=nil then shield_1.show()end else fL("hud","DH")c.hide()b.hide()if un~=nil then gD(un)un=nil end;if us~=nil then gD(us)us=nil end;if uu~=nil then gD(uu)uu=nil end;if up~=nil then gD(up)up=nil end;if ur~=nil then gD(ur)ur=nil end;if shield_1~=nil then shield_1.hide()end end end;uj=false;if pc and bV then local uk=""for K=1,#cY do uk=uk.."| ID: "..cY[K].." Mass: "..fM(b.getDockedConstructMass(cY[K])/1000,1).."t "end;a.print("Docked Ships: "..uk)return end;if x then if w then w=false else w=true end end;ul()elseif ub=="option4"then uj=false;if pc and bV then for K=1,#cY do b.forceUndock(cY[K])end;bW="Undocked all ships"return end;cR=nil;cn.ToggleAutopilot()elseif ub=="option5"then uj=false;cn.ToggleLockPitch()elseif ub=="option6"then uj=false;if pc and bV then if shield_1 then cq.ventShield()else bW="No shield found"end;return end;cn.ToggleAltitudeHold()elseif ub=="option7"then uj=false;if pc and bV then if shield_1 then shield_1.toggle()return else bW="No shield found"return end end;E=not E;if E then bW="Collision System Enabled"else bW="Collision System Secured"end elseif ub=="option8"then uj=false;if pc and bV then if bi>0 and fX~=nil then cn.routeWP()else bW="Select a saved wp on IPH to add to or remove from route"end;return end;by=not by;if not by then bW="DeCoupled Mode - Ground Stabilization off"is:deactivateGroundEngineAltitudeStabilization()fL("gsOff","GS")else bW="Coupled Mode - Ground Stabilization on"is:activateGroundEngineAltitudeStabilization(uw)d:setEngineForceCommand('hover',vec3(),1)fL("gsOn","GS")end elseif ub=="option9"then uj=false;if pc and bV then is:resetCommand(axisCommandId.longitudinal)is:resetCommand(axisCommandId.lateral)is:resetCommand(axisCommandId.vertical)cn.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cc=gyro.getState()==1;if cc then fL("gyOn","GA")else fL("gyOff","GA")end else bW="No gyro found"end elseif ub=="lshift"then cV=false;if pc then bV=true end;if it()==1 then bV=true;bf=it()u3(1)elseif ir()==1 and y then bV=true;cs=false;cr=false end elseif ub=="brake"then if aW or pc then cn.BrakeToggle("Manual")elseif not aY then cn.BrakeToggle("Manual")else aY="Manual"end elseif ub=="lalt"then uj=true;pc=true;if ir()==0 and not i and g=="keyboard"then u3(1)end elseif ub=="booster"then if n then d:toggleBoosters()elseif not bY then if not u0 then d:toggleBoosters()u0=true end;bY=true else if u0 then d:toggleBoosters()u0=false end;bY=false end elseif ub=="stopengines"then local function ux()if bJ-ua<1.5 then fL("clear","CA")cn.clearAll()end end;ux()ua=bJ;if is:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then is:resetCommand(axisCommandId.longitudinal)cn.cmdThrottle(0)else cn.cmdThrottle(100)end else if is:getTargetSpeed(axisCommandId.longitudinal)~=0 then is:resetCommand(axisCommandId.longitudinal)else if c8 then cn.cmdCruise(U)else cn.cmdCruise(_*3.6)end end end elseif ub=="speedup"then cn.changeSpd()elseif ub=="speeddown"then cn.changeSpd(true)elseif ub=="antigravity"and not q then if antigrav~=nil then cn.ToggleAntigrav()else bW="No antigrav found"end end end;function u4.stopControl(ub)local function uy()if not q and cK then u9=u7 end;if b2 or b6 or bw then u8=u6 end end;if ub=="forward"then bQ=0 elseif ub=="backward"then bQ=0 elseif ub=="left"then if cR then if cR==2 then cR=-2 else cR=-1 end end;bR=0 elseif ub=="right"then if cR then if cR==4 then cR=-2 else cR=-1 end end;bR=0 elseif ub=="yawright"then bS=0 elseif ub=="yawleft"then bS=0 elseif ub=="straferight"then is:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bv=0 elseif ub=="strafeleft"then is:updateCommandFromActionStop(axisCommandId.lateral,1.0)bv=0 elseif ub=="up"then bT=0;is:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if by then is:activateGroundEngineAltitudeStabilization(uw)d:setEngineForceCommand('hover',vec3(),1)end elseif ub=="down"then bT=0;is:updateCommandFromActionStop(axisCommandId.vertical,1.0)if by then is:activateGroundEngineAltitudeStabilization(uw)d:setEngineForceCommand('hover',vec3(),1)end elseif ub=="groundaltitudeup"then uy()uj=false elseif ub=="groundaltitudedown"then uy()uj=false elseif ub=="lshift"then if it()==1 then c1=0;c2=0;u3(bf)elseif ir()==1 and y then cs=false;cr=false end;bV=false elseif ub=="brake"then if not aW and not pc then if aY then cn.BrakeToggle()else aY=false end end elseif ub=="lalt"then if ir()==0 and i then if uj then if it()==1 then u3(0)else u3(1)end else uj=true end elseif ir()==0 and not i and g=="keyboard"then u3(0)end;pc=false end end;function u4.loopControl(ub)local function uz(rj)local rk=1;if rj then rk=-1 end;if not q and cK then if bs~=nil then bs=bs+rk*u9;if bs<1000 then bs=1000 end;if b2 and bs<b7+10 and bs>b7-10 then b7=bs end;u9=da(u9*1.05,u7,50)else bs=tC+rk*100 end elseif b2 or b6 or bw then if bw then cx=cx+rk*u8;if cx<j7.noAtmosphericDensityAltitude then cx=j7.noAtmosphericDensityAltitude end else b7=b7+rk*u8 end;u8=da(u8*1.05,u6,50)else is:updateTargetGroundAltitudeFromActionLoop(rk*1.0)end end;local function uA(rj)local rk=1;if rj then rk=-1 end;if not bV then if t and not pc then bK=da(bK+rk*aB/100,-1,1)else is:updateCommandFromActionLoop(axisCommandId.longitudinal,rk*aB)end end end;if ub=="groundaltitudeup"then if not bV then uz()end elseif ub=="groundaltitudedown"then if not bV then uz(true)end elseif ub=="speedup"then uA()elseif ub=="speeddown"then uA(true)end end;function u4.inputTextControl(ri)local function uB(uC,fm,gq)local function uD(fm)local ds=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dt='::pos{'..ds..','..ds..','..ds..','..ds..','..ds..'}'local dJ,dK,dS,dT,dU=dV(fm,dt)if dJ=="0"and dK=="0"then return vec3(db(dS),db(dT),db(dU))end;dT=math.rad(dT)dS=math.rad(dS)local j7=e[db(dJ)][db(dK)]local eL=math.cos(dS)local uE=vec3(eL*math.cos(dT),eL*math.sin(dT),math.sin(dS))return j7.center+(j7.radius+dU)*uE end;local fO=uD(fm)return cm.AddNewLocation(uC,fO,gq)end;local K;local uF,ie=nil,nil;local uG="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(ri," ")uF=ri;if K~=nil then uF=string.sub(ri,0,K-1)ie=string.sub(ri,K+1)end;if uF=="/help"or uF=="/commands"then for lB in string.gmatch(uG,"([^\n]+)")do a.print(lB)end;return elseif uF=="/setname"then if ie==nil or ie==""then bW="Usage: ah-setname Newname"return end;if bi>0 and fX~=nil then cm.UpdatePosition(ie)else bW="Select a saved target to rename first"end elseif shield_1 and uF=="/resist"then cq.setResist(ie)elseif uF=="/addlocation"or string.find(ri,"::pos")~=nil then local gq=false;local uC="0-Temp"if ie==nil or ie==""or uF~="/addlocation"then ie=uF;gq=true end;K=string.find(ie,"::")if not gq then uC=string.sub(ie,1,K-2)end;local fm=string.sub(ie,K)uB(uC,fm,gq)elseif uF=="/agg"then if ie==nil or ie==""then bW="Usage: /agg targetheight"return end;ie=db(ie)if ie<1000 then ie=1000 end;bs=ie;bW="AGG Target Height set to "..ie elseif uF=="/G"then if ie==nil or ie==""then bW="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ie=="dump"then for dA,dl in pairs(iv())do if type(dl.get())=="boolean"then if dl.get()==true then a.print(dA.." true")else a.print(dA.." false")end elseif dl.get()==nil then a.print(dA.." nil")else a.print(dA.." "..dl.get())end end;return end;K=string.find(ie," ")local uH=string.sub(ie,0,K-1)local uI=string.sub(ie,K+1)for dA,dl in pairs(iv())do if dA==uH then bW="Variable "..uH.." changed to "..uI;local uJ=type(dl.get())if uJ=="number"then uI=db(uI)if dA=="AtmoSpeedLimit"then cv=uI end elseif uJ=="boolean"then if string.lower(uI)=="true"then uI=true else uI=false end end;dl.set(uI)return end end;bW="No such global variable: "..uH elseif uF=="/deletewp"then if bi>0 and fX~=nil then cm.ClearCurrentPosition()else bW="Select a custom wp to delete first in IPH"end elseif uF=="/copydatabank"then if dbHud_2 then pT(true)else bW="Spare Databank required to copy databank"end elseif uF=="/iphWP"then if bi>0 then a.print(cn.showWayPoint(c0,bh,true))a.print(json.encode(bh))bW="::pos waypoint shown in lua chat in local and world format"else bW="No target selected in IPH"end elseif uF=="/createPrivate"then local uK="privatelocations = {\n"local uL=""if#d3>0 then for dA,dl in pairs(d3)do uK=uK.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uK=uK.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uK=uK.."safe = true},\n"else uK=uK.."safe = false},\n"end end end;uL=#d3 .."-Private "if ie=="all"then for dA,dl in pairs(bm)do uK=uK.."{position = {x = "..dl.position.x..", y = "..dl.position.y..", z = "..dl.position.z.."},\n ".."name = '*"..dl.name.."',\n planetname = '"..dl.planetname.."',\n gravity = "..dl.gravity..",\n"if dl.heading then uK=uK.."heading = {x = "..dl.heading.x..", y = "..dl.heading.y..", z = "..dl.heading.z.."},\n"end;if dl.safe then uK=uK.." safe = true},\n"else uK=uK.."safe = false},\n"end end;uL=uL..#bm.."-Public "end;uK=uK.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(uK)end;bW=uL.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bX=7 end end;function u4.tagTick()if bz=="Off"then bz="All"elseif bz=="All"then bz="Longitude"elseif bz=="Longitude"then bz="Lateral"elseif bz=="Lateral"then bz="Vertical"else bz="Off"end;bW="Extra Engine Tags: "..bz;c.stopTimer("tagTick")end;if uM then for dA,dl in pairs(uM)do u4[dA]=dl end end;return u4 end;local function uN(d,b,c,a,library,e,vBooster,hover,pS,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,io,screenHud_1)local uO={}local d9=string.format;local ip=json.decode;local uP=json.encode;local pL=b.getElementMaxHitPointsById;local iq=b.getElementMassById;local ir=d.control.isRemoteControlled;local dV=string.match;local gD=a.destroyWidgetPanel;local fJ=a.updateData;local fK=a.addDataToWidget;local u3=a.lockView;local it=a.isViewLocked;local dc=math.sqrt;local db=tonumber;local eP=math.abs;local bH=math.floor;local bI=c.getAtmosphereDensity;local eK=math.atan;local bG=a.getTime;local da=utils.clamp;local is=d.axisCommandManager;local uQ=Y;local gF=13;local iy=b.getElementIdList()local iz=0;local function dd(es,et)if es==0 then return eP(et)<1e-09 end;if et==0 then return eP(es)<1e-09 end;return eP(es-et)<math.max(eP(es),eP(et))*dr end;local function fM(ds,uR)local rk=10^(uR or 0)return bH(ds*rk+0.5)/rk end;local function iu(uS,uT)for dA,dl in pairs(uT)do if type(dA)=="string"then uS[dA]=dl else uS[#uS+1]=uT[dA]end end;return uS end;local function iv(uU)local uV={}if not uU then iu(uV,J)iu(uV,a8)iu(uV,az)iu(uV,aV)return uV elseif uU=="boolean"then return J elseif uU=="handling"then return a8 elseif uU=="hud"then return az elseif uU=="physics"then return aV end end;local function pT(uW)local function uX(uY)for dA,dl in pairs(uY)do dbHud_1.setStringValue(dA,uP(dl.get()))if uW and dbHud_2 then dbHud_2.setStringValue(dA,uP(dl.get()))end end end;if dbHud_1 then uX(bD)uX(iv())a.print("Saved Variables to Datacore")if uW and dbHud_2 then bW="Databank copied.  Remove copy when ready."end end end;local function fL(uZ,u_,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uZ..".mp3")end;local function gE(hf,hg,ri,jM,v0)if jM==nil then jM=""end;if v0==nil then v0=""end;return d9([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jM,hf,hg,v0,ri)end;local function iw(c3,v1)local v2=c3>100000;if v1==nil then v1=1 end;if v2 then return fM(c3/1000/200,v1).."SU"elseif c3<1000 then return fM(c3,v1).."M"else return fM(c3/1000,v1).."KM"end end;local function ix(v3)local v4=0;local v5=0;local v6=0;if v3<60 then v3=bH(v3)elseif v3<3600 then v4=bH(v3/60)v3=bH(v3%60)elseif v3<86400 then v5=bH(v3/3600)v4=bH(v3%3600/60)else v6=bH(v3/86400)v5=bH(v3%86400/3600)end;if v6>0 then return v6 .."d "..v5 .."h "elseif v5>0 then return v5 .."h "..v4 .."m "elseif v4>0 then return v4 .."m "..v3 .."s"elseif v3>0 then return v3 .."s"else return"0s"end end;function uO.onStart()local v7=false;local function v8()local function v9(va)local vb=dbHud_1.hasKey;for dA,dl in pairs(va)do if vb(dA)then local dv=ip(dbHud_1.getStringValue(dA))if dv~=nil then dl.set(dv)v7=true end end end end;if dbHud_1 then if not f then v9(iv())coroutine.yield()v9(bD)else v9(bD)bW="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bX=5;v7=false end;coroutine.yield()if v7 then bW="Loaded Saved Variables"cd=a9;ce=aa;aW=j;g=string.lower(g)ct=p;cv=U elseif not f then bW="No Saved Variables Found - Exit HUD to save settings"end;if bA<1.500 then if T<2000 then bW="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bA=VERSION_NUMBER;if#bm>0 then d4=iu(d4,bm)end else bW="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bt+180<bJ then br=0 end;bt=bJ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bW="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bX=7 end;if antigrav and not q then if bs==nil then bs=ca end;antigrav.setBaseAltitude(bs)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d3>0 then d4=iu(d4,d3)end end;lJ="Proceeding to Waypoint"end;local function vc()local function vd(ve,vf)if ve>vf then vf=ve end;local vg,vh=0,0;if a5>0 then vg=a5*0.05 end;if a6>0 then vh=a6*0.05 end;vf=vf*(1-(vg+vh))return vf end;local vi=b.getElementNameById;local vj=aq~=0 and ar~=0;for dA in pairs(iy)do local type=b.getElementTypeById(iy[dA])if dV(type,'^.*Atmospheric Engine$')then if dV(tostring(b.getElementTagsById(iy[dA])),'^.*vertical.*$')and b.getElementForwardById(iy[dA])[3]>0 then cJ=true end end;if dV(type,'^.*Space Engine$')then cA=true;if dV(tostring(b.getElementTagsById(iy[dA])),'^.*vertical.*$')then local vk=b.getElementForwardById(iy[dA])if vk[3]<0 then vl=true else cz=true end end end;if type=="Landing Gear"then bP=true end;if type=="Dynamic Core Unit"then local pN=pL(iy[dA])if pN>10000 then gF=110 elseif pN>1000 then gF=55 elseif pN>150 then gF=27 end end;iz=iz+pL(iy[dA])if vj and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pN=pL(iy[dA])local oz=iq(iy[dA])local ve=0;local jG=bG()if type=="Atmospheric Fuel Tank"then local vf=400;local vm=35.03;if pN>10000 then vf=51200;vm=5480 elseif pN>1300 then vf=6400;vm=988.67 elseif pN>150 then vf=1600;vm=182.67 end;ve=oz-vm;if a2>0 then vf=vf+vf*a2*0.2 end;vf=vd(ve,vf)cf[#cf+1]={iy[dA],vi(iy[dA]),vf,vm,ve,jG}end;if type=="Rocket Fuel Tank"then local vf=320;local vm=173.42;if pN>65000 then vf=40000;vm=25740 elseif pN>6000 then vf=5120;vm=4720 elseif pN>700 then vf=640;vm=886.72 end;ve=oz-vm;if a4>0 then vf=vf+vf*a4*0.1 end;vf=vd(ve,vf)ch[#ch+1]={iy[dA],vi(iy[dA]),vf,vm,ve,jG}end;if type=="Space Fuel Tank"then local vf=600;local vm=35.03;if pN>10000 then vf=76800;vm=5480 elseif pN>1300 then vf=9600;vm=988.67 elseif pN>150 then vf=2400;vm=182.67 end;ve=oz-vm;if a3>0 then vf=vf+vf*a3*0.2 end;vf=vd(ve,vf)cg[#cg+1]={iy[dA],vi(iy[dA]),vf,vm,ve,jG}end end end;if not cJ then b6,aX=false,false end end;local function vn()if gyro~=nil then cc=gyro.getState()==1 end;if not by then is:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u3(1)else u3(0)end;if door and(c8 or not c8 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c8 or not c8==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;if antigrav then cK=antigrav.getState()==1;if cK and not q then antigrav.show()end end;if ir()==1 and k then a.freeze(1)else a.freeze(0)end;if bP then bj=d.control.isAnyLandingGearExtended()==1;if bj then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if c7~=-1 or not c8 and cD:len()<50 then aY="Startup"bj=true;if bP then d.control.extendLandingGears()end else aY=false end;is:setTargetGroundAltitude(uQ)pz=c8 end;local function vo()local vp={}local function vq()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vr={[1]=4480,[6]=4480,[7]=6270}for vs,vt in pairs(e)do e[vs][0]=vq()e[vs][0].systemId=vs;vp[vs]={}for vu,j7 in pairs(e[vs])do j7.gravity=j7.gravity/9.8;j7.center=vec3(j7.center)j7.name=j7.name[1]j7.noAtmosphericDensityAltitude=j7.atmosphereThickness or j7.atmosphereRadius-j7.radius;j7.spaceEngineMinAltitude=vr[j7.id]or 0.68377*j7.atmosphereThickness;j7.planetarySystemId=vs;j7.bodyId=j7.id;vp[vs][vu]=j7;if mB==nil or j7.center.x<mB then mB=j7.center.x end;if mA==nil or j7.center.x>mA then mA=j7.center.x end;if mE==nil or j7.center.y<mE then mE=j7.center.y end;if mD==nil or j7.center.y>mD then mD=j7.center.y end;if j7.center and j7.name~="Space"then cZ[#cZ+1]=j7 end end end;e4=d8(d,b,c,a,d9,da,db,dc,dd)ci=e4(vp)cj=eO(d,b,c,a,dc,eP)ck=fi(d,b,c,a,d9,da,db,dc,dd)cm=fI(d,b,c,a,dbHud_1,e,fJ,fK,bH,db,dc,fL,fM)j7=ci[0]:closestBody(b.getConstructWorldPos())end;vv=false;vw=coroutine.create(function()is:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v8()coroutine.yield()vc()coroutine.yield()cn=pR(d,b,c,a,e,vBooster,hover,pS,antigrav,warpdrive,dbHud_1,eP,bH,bI,ir,eK,bG,da,is,fJ,it,dc,fM,fL,iu,dd,iw,ix,pT,ip,d9,fK)vn()coroutine.yield()vo()if radar_1 then co=gC(b,a,c,library,radar_1,radar_2,eP,gD,dc,gE,db,gF,fL)end;cl=im(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,io,eP,bH,d9,ip,bI,iq,ir,eK,bG,da,is,fK,fJ,gD,it,dc,fM,gE,fL,iu,iv,iw,ix,iy,iz)cl.ButtonSetup()cp=u2(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ir,is,it,u3,gD,fM,dV,db,da,fL,iv,pT)if shield_1 then cq=i5(shield_1,dV,bH)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",0.0166667)end;if vx then vy.ExtraOnStart()end;fL("start","SU")end)coroutine.resume(vw)end;function uO.onUpdate()if not vv then local hV=coroutine.status(vw)if hV=="suspended"then local dB,hW=coroutine.resume(vw)if hW then a.print("ERROR STARTUP: "..hW)end elseif hV=="dead"then vv=true end end;if vv then d:update()if c8 and t and cL then if cL and bO then cn.cmdThrottle(0)bO=false elseif not cL and not bO then bK=0;bO=true end end;if d1 then is:setThrottleCommand(axisCommandId.longitudinal,d1)d1=nil end;if not cr and pe~=vz then a.setScreen(pe)end;vz=pe;if vx then vy.ExtraOnUpdate()end end end;function uO.onFlush()if vv then cn.onFlush()if vx then vy.ExtraOnFlush()end end end;function uO.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(door)do dl.toggle()end end;if switch then for dF,dl in pairs(switch)do dl.toggle()end end;if forcefield and(c9>0 or c9==0 and ca<10000)then for dF,dl in pairs(forcefield)do dl.toggle()end end;w=d0;pT()if o8 then o8.activate()end;if z then cn.showWayPoint(j7,cI)end;a.print(cl.FuelUsed("atmofueltank")..", "..cl.FuelUsed("spacefueltank")..", "..cl.FuelUsed("rocketfueltank"))if vx then vy.ExtraOnStop()end;fL("stop","SU")end;function uO.controlStart(ub)if vv then cp.startControl(ub)end end;function uO.controlStop(ub)if vv then cp.stopControl(ub)end end;function uO.controlLoop(ub)if vv then cp.loopControl(ub)end end;function uO.controlInput(ri)if vv then cp.inputTextControl(ri)end end;function uO.radarEnter(dK)co.onEnter(dK)end;function uO.radarLeave(dK)co.onLeave(dK)end;function uO.onTick(vA)if vA=="tenthSecond"then cn.TenthTick()cl.TenthTick()elseif vA=="oneSecond"then cl.OneSecondTick()elseif vA=="fiveSecond"then cn.SatNavTick()elseif vA=="msgTick"then cl.MsgTick()elseif vA=="animateTick"then cl.AnimateTick()elseif vA=="hudTick"then cl.hudtick()elseif vA=="apTick"then cn.APTick()elseif vA=="radarTick"then co.UpdateRadar()elseif vA=="shieldTick"then cq.shieldTick()elseif vA=="tagTick"then cp.tagTick()elseif vA=="contact"then co.ContactTick()end end;if vx then for dA,dl in pairs(vx)do uO[dA]=dl end end;return uO end;function script.onStart()vy.onStart()end;function script.onStop()vy.onStop()end;function script.onTick(vA)vy.onTick(vA)end;function script.onFlush()vy.onFlush()end;function script.onUpdate()vy.onUpdate()end;function script.onActionStart(ub)vy.controlStart(ub)end;function script.onActionStop(ub)vy.controlStop(ub)end;function script.onActionLoop(ub)vy.controlLoop(ub)end;function script.onInputText(ri)vy.controlInput(ri)end;function script.onEnter(dK)vy.radarEnter(dK)end;function script.onLeave(dK)vy.radarLeave(dK)end;bF(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vy=uN(d,b,c,a,library,e,vBooster,hover,pS,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,io,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
