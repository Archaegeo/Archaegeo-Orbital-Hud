name: ArchHud - Archaegeo v0.018 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
  transponder:
    class: TransponderUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.018;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=5000;T=1.3;U=2000;V=1175;W=66000;X=1000;Y=50;Z=0;_=100000;a0=-1.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=1;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},AutopilotSpaceDistance={set=function(M)S=M end,get=function()return S end},TargetOrbitRadius={set=function(M)T=M end,get=function()return T end},LowOrbitHeight={set=function(M)U=M end,get=function()return U end},AtmoSpeedLimit={set=function(M)V=M end,get=function()return V end},SpaceSpeedLimit={set=function(M)W=M end,get=function()return W end},AutoTakeoffAltitude={set=function(M)X=M end,get=function()return X end},TargetHoverHeight={set=function(M)Y=M end,get=function()return Y end},LandingGearGroundHeight={set=function(M)Z=M end,get=function()return Z end},ReEntryHeight={set=function(M)_=M end,get=function()return _ end},MaxGameVelocity={set=function(M)a0=M end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(M)a1=M end,get=function()return a1 end},warmup={set=function(M)a2=M end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingSpace={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingRocket={set=function(M)a5=M end,get=function()return a5 end},ContainerOptimization={set=function(M)a6=M end,get=function()return a6 end},FuelTankOptimization={set=function(M)a7=M end,get=function()return a7 end},AutoShieldPercent={set=function(M)a8=M end,get=function()return a8 end},EmergencyWarp={set=function(M)a9=M end,get=function()return a9 end},DockingMode={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY=0.05;aZ=0.0;a_={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end},allowedHorizontalDrift={set=function(M)aY=M end,get=function()return aY end},FastOrbit={set=function(M)aZ=M end,get=function()return aZ end}}b0=k;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=false;bb=false;bc=1000;bd=false;be=false;bf=false;bg=false;bh=0;bi="Aligning"bj=0;bk=1;bl="None"bm=nil;bn=0;bo=nil;bp=0.0;bq=0;br={}bs=false;bt=0;bu=0;bv=nil;bw=0;bx=1000;by=0;bz=false;bA=0;bB=false;bC="All"bD=true;bE="Off"bF=0.000;bG={}bH={}bI={}bJ={VertTakeOff={set=function(M)bb=M end,get=function()return bb end},VertTakeOffEngine={set=function(M)b1=M end,get=function()return b1 end},SpaceTarget={set=function(M)bz=M end,get=function()return bz end},BrakeToggleStatus={set=function(M)b0=M end,get=function()return b0 end},BrakeIsOn={set=function(M)b2=M end,get=function()return b2 end},RetrogradeIsOn={set=function(M)b3=M end,get=function()return b3 end},ProgradeIsOn={set=function(M)b4=M end,get=function()return b4 end},Autopilot={set=function(M)b5=M end,get=function()return b5 end},TurnBurn={set=function(M)b6=M end,get=function()return b6 end},AltitudeHold={set=function(M)b7=M end,get=function()return b7 end},BrakeLanding={set=function(M)b8=M end,get=function()return b8 end},Reentry={set=function(M)ba=M end,get=function()return ba end},AutoTakeoff={set=function(M)b9=M end,get=function()return b9 end},HoldAltitude={set=function(M)bc=M end,get=function()return bc end},AutopilotAccelerating={set=function(M)bd=M end,get=function()return bd end},AutopilotBraking={set=function(M)bf=M end,get=function()return bf end},AutopilotCruising={set=function(M)bg=M end,get=function()return bg end},AutopilotRealigned={set=function(M)be=M end,get=function()return be end},AutopilotEndSpeed={set=function(M)bh=M end,get=function()return bh end},AutopilotStatus={set=function(M)bi=M end,get=function()return bi end},AutopilotPlanetGravity={set=function(M)bj=M end,get=function()return bj end},PrevViewLock={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetName={set=function(M)bl=M end,get=function()return bl end},AutopilotTargetCoords={set=function(M)bm=M end,get=function()return bm end},AutopilotTargetIndex={set=function(M)bn=M end,get=function()return bn end},TotalDistanceTravelled={set=function(M)bp=M end,get=function()return bp end},TotalFlightTime={set=function(M)bq=M end,get=function()return bq end},SavedLocations={set=function(M)br=M end,get=function()return br end},VectorToTarget={set=function(M)bs=M end,get=function()return bs end},LocationIndex={set=function(M)bt=M end,get=function()return bt end},LastMaxBrake={set=function(M)bu=M end,get=function()return bu end},LockPitch={set=function(M)bv=M end,get=function()return bv end},LastMaxBrakeInAtmo={set=function(M)bw=M end,get=function()return bw end},AntigravTargetAltitude={set=function(M)bx=M end,get=function()return bx end},LastStartTime={set=function(M)by=M end,get=function()return by end},iphCondition={set=function(M)bC=M end,get=function()return bC end},stablized={set=function(M)bD=M end,get=function()return bD end},UseExtra={set=function(M)bE=M end,get=function()return bE end},SelectedTab={set=function(M)bK=M end,get=function()return bK end},saveRoute={set=function(M)bG=M end,get=function()return bG end},apRoute={set=function(M)bH=M end,get=function()return bH end},ecuThrottle={set=function(M)bI=M end,get=function()return bI end}}local function bL(b,c,bM,bN,bO)local a=DUSystem;local bP=DUConstruct;bQ=bM()bR=0;bS=0;bT=false;bU=0;bV=false;bW=false;bX=0;bY=0;bZ=0;b_=0;c0=false;c1=false;c2=false;c3="empty"c4=3;c5=false;c6=0;c7=0;c8=nil;c9=0;ca=0;cb=0;cc=false;cd=false;ce=false;cf=-1;cg=bO()>0;ch=bO()ci=b.getAltitude()cj=DUConstruct.getMass()ck=nil;cl={}cm={}cn={}co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=nil;cx=false;cy=false;cz=q;cA=false;cB=V;cC=nil;cD=0;cE=false;cF=false;cG=false;cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cJ=vec3(bP.getVelocity())cK=vec3(bP.getWorldVelocity())cL=vec3(cK):len()cM=vec3(b.getWorldVertical())cN=-cM:dot(cK)cO=vec3(bP.getWorldPosition())cP=false;cQ=false;cR=true;cS=0;cT=0;cU={}cV=false;cW=50000;cX=nil;cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;cZ=false;c_=nil;d0=false;d1=0;d2={}d3={}d4={}d5=90;d6=w;d7=nil;d8=nil;d9={}da={}db=false;dc=nil;dd=0;de=false;df=bP.getMaxSpeed()dg=nil;dh=nil;di=false;if shield then dj=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dk(dl)a.print(bQ..": "..dl)end;local function dm(d,b,c,a,dn,dp,dq,dr,ds)local function dt(du)return type(du)=='number'end;local function dv(du)return type(dq(du))=='number'end;local function dw(dx)return type(dx)=='table'end;local function dy(a)return type(a)=='string'end;local function dz(dA)return dw(dA)and dt(dA.x and dA.y and dA.z)end;local function dB(dC)return dw(dC)and dt(dC.latitude and dC.longitude and dC.altitude and dC.id and dC.systemId)end;local dD=math.pi/180;local dE=180/math.pi;local dF=1e-10;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local utils=utils;local vec3=vec3;local function dI(du)local dJ=string.gsub(string.reverse(dn('%.4f',du)),'^0*%.?','')return dJ==''and'0'or string.reverse(dJ)end;local function dK(dL)if dz(dL)then return dn('{x=%.3f,y=%.3f,z=%.3f}',dL.x,dL.y,dL.z)end;if dw(dL)and not getmetatable(dL)then local dM={}local dN=next(dL)if type(dN)=='nil'or dN==1 then dM=dL else for dO,dA in pairs(dL)do local dP=dK(dA)if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end end;return dn('{%s}',table.concat(dM,','))end;if dy(dL)then return dn("'%s'",dL:gsub("'",[[\']]))end;return tostring(dL)end;local dQ={}dQ.__index=dQ;dQ.__tostring=function(dL,dR)local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)local dM={}for dT,dO in ipairs(dS)do local dP=dK(dL[dO])if type(dO)=='number'then table.insert(dM,dn('[%s]=%s',dO,dP))else table.insert(dM,dn('%s=%s',dO,dP))end end;if dR then return dn('%s%s',dR,table.concat(dM,',\n'..dR))end;return dn('{%s}',table.concat(dM,','))end;dQ.__eq=function(dU,dV)return dU.systemId==dV.systemId and dU.id==dV.id and ds(dU.radius,dV.radius)and ds(dU.center.x,dV.center.x)and ds(dU.center.y,dV.center.y)and ds(dU.center.z,dV.center.z)and ds(dU.GM,dV.GM)end;local function dW(dX,dY,dZ,d_,e0)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(dZ),'Argument 3 (radius) must be a number:'..type(dZ))assert(dw(d_),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(d_))assert(dv(e0),'Argument 5 (GM) must be a number:'..type(e0))return setmetatable({systemId=dq(dX),id=dq(dY),radius=dq(dZ),center=vec3(d_),GM=dq(e0)},dQ)end;local e1={}e1.__index=e1;e1.__tostring=function(dk)return dn('::pos{%d,%d,%s,%s,%s}',dk.systemId,dk.id,dI(dk.latitude*dE),dI(dk.longitude*dE),dI(dk.altitude))end;e1.__eq=function(dU,dV)return dU.id==dV.id and dU.systemId==dV.systemId and ds(dU.latitude,dV.latitude)and ds(dU.altitude,dV.altitude)and(ds(dU.longitude,dV.longitude)or ds(dU.latitude,math.pi/2)or ds(dU.latitude,-math.pi/2))end;local function e2(e3,dY,e4,e5,e6)local dX=e3;if dy(e3)and not e5 and not e6 and not dY and not e4 then dX,dY,e4,e5,e6=e7(e3,dH)assert(dX,'Argument 1 (position string) is malformed.')else assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(e4),'Argument 3 (latitude) must be in degrees:'..type(e4))assert(dv(e5),'Argument 4 (longitude) must be in degrees:'..type(e5))assert(dv(e6),'Argument 5 (altitude) must be in meters:'..type(e6))end;dX=dq(dX)dY=dq(dY)e4=dq(e4)e5=dq(e5)e6=dq(e6)if dY==0 then return setmetatable({latitude=e4,longitude=e5,altitude=e6,id=dY,systemId=dX},e1)end;return setmetatable({latitude=dD*dp(e4,-90,90),longitude=dD*(e5%360),altitude=e6,id=dY,systemId=dX},e1)end;local e8={}e8.__index=e8;e8.__tostring=function(dL,dR)local e9=dR and dR..'  'local ea={}local dS={}for dO in pairs(dL)do table.insert(dS,dO)end;table.sort(dS)for dT,eb in ipairs(dS)do ec=dL[eb]local ed=dQ.__tostring(ec,e9)if dR then table.insert(ea,dn('[%s]={\n%s\n%s}',eb,ed,dR))else table.insert(ea,dn('  [%s]=%s',eb,ed))end end;if dR then return dn('\n%s%s%s',dR,table.concat(ea,',\n'..dR),dR)end;return dn('{\n%s\n}',table.concat(ea,',\n'))end;local function ee(ef)local e={}local pid;for dT,dA in pairs(ef)do local dY=dA.planetarySystemId;if type(dY)~='number'then error('Invalid planetary s ID: '..tostring(dY))elseif pid and dY~=pid then error('Mistringmatch planetary s IDs: '..dY..' and '..pid)end;local eg=dA.bodyId;if type(eg)~='number'then error('Invalid body ID: '..tostring(eg))elseif e[eg]then error('Duplicate body ID: '..tostring(eg))end;setmetatable(dA.center,getmetatable(vec3.unit_x))e[eg]=setmetatable(dA,dQ)pid=dY end;return setmetatable(e,e8)end;eh={}local function ei(ef)return setmetatable({galaxyAtlas=ef or{}},eh)end;eh.__index=function(dx,M)if type(M)=='number'then local a=dx.galaxyAtlas[M]return ee(a)end;return rawget(eh,M)end;eh.__pairs=function(dL)return function(dx,dO)local ej,ek=next(dx,dO)return ej,ek and ee(ek)end,dL.galaxyAtlas,nil end;eh.__tostring=function(dL)local el={}for dT,em in pairs(dL or{})do local en=em:getPlanetarySystemId()local eo=e8.__tostring(em,'    ')table.insert(el,dn('  [%s]={%s\n  }',en,eo))end;return dn('{\n%s\n}\n',table.concat(el,',\n'))end;eh.BodyParameters=dW;eh.MapPosition=e2;eh.PlanetarySystem=ee;function eh.createBodyParameters(dX,dY,ep,eq,er,es,et)assert(dv(dX),'Argument 1 (systemId) must be a number:'..type(dX))assert(dv(dY),'Argument 2 (id) must be a number:'..type(dY))assert(dv(ep),'Argument 3 (surfaceArea) must be a number:'..type(ep))assert(dw(eq),'Argument 4 (aPosition) must be an array or vec3:'..type(eq))assert(dw(er),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(er))assert(dv(es),'Argument 6 (altitude) must be in meters:'..type(es))assert(dv(et),'Argument 7 (gravityAtPosition) must be number:'..type(et))local dZ=dr(ep/4/math.pi)local cb=dZ+es;local eu=vec3(eq)+cb*vec3(er)local e0=et*cb*cb;return dW(dX,dY,dZ,eu,e0)end;eh.isMapPosition=dB;function eh:getPlanetarySystem(e3)if M==nil then M=0 end;if ek==nil then ek=0 end;local dX=e3;if dB(e3)then dX=e3.systemId end;if type(dX)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(ek)~=e8 then a=ee(a)end;return a end end end;function e8:sizeCalculator(ev)return 1.05*ev.radius end;function e8:castIntersections(ew,ex,ey,ez,eA,eB)local eC={}if eA then for dT,ev in pairs(eA)do table.insert(eC,ev)end else eC=d4 end;if not eB then table.sort(eC,function(eD,eE)local eF=eD.center;local eG=eE.center;return(eF.x-ew.x)^2+(eF.y-ew.y)^2+(eF.z-ew.z)^2<(eG.x-ew.x)^2+(eG.y-ew.y)^2+(eG.z-ew.z)^2 end)end;local eH=ex:normalize()for dT,ev in ipairs(eC)do local eI=ev.center-ew;local dZ;if ey then dZ=ey(ev)else dZ=self:sizeCalculator(ev)end;local eJ=eI:dot(eH)local eK=eJ^2-(eI:len2()-dZ^2)if eK>=0 then local eL=dr(eK)local eM=eJ+eL;local eN=eJ-eL;if eN>0 then return ev,eM,eN elseif eM>0 then return ev,eM,nil end end end;return nil,nil,nil end;function e8:closestBody(eO)assert(type(eO)=='table','Invalid coordinates.')local eP,ev;local eQ=vec3(eO)for dT,eR in pairs(self)do local eS=(eR.center-eQ):len2()if(not ev or eS<eP)and eR.name~="Space"then ev=eR;eP=eS end end;return ev end;function e8:convertToBodyIdAndWorldCoordinates(e3)local eT=e3;if dy(e3)then eT=e2(e3)end;if eT.id==0 then return 0,vec3(eT.latitude,eT.longitude,eT.altitude)end;local eR=self:getBodyParameters(eT)if eR then return eT.id,eR:convertToWorldCoordinates(eT)end end;function e8:getBodyParameters(e3)local dY=e3;if dB(e3)then dY=e3.id end;assert(dv(dY),'Argument 1 (id) must be a number:'..type(dY))return self[dY]end;function e8:getPlanetarySystemId()local dT,dA=next(self)return dA and dA.systemId end;function dQ:convertToMapPosition(d_)assert(dw(d_),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(d_))local eU=vec3(d_)if self.id==0 then return setmetatable({latitude=eU.x,longitude=eU.y,altitude=eU.z,id=0,systemId=self.systemId},e1)end;local eV=eU-self.center;local cb=eV:len()local e6=cb-self.radius;local e4=0;local e5=0;if not ds(cb,0)then local eW=eX(eV.y,eV.x)e5=eW>=0 and eW or 2*math.pi+eW;e4=math.pi/2-math.acos(eV.z/cb)end;return setmetatable({latitude=e4,longitude=e5,altitude=e6,id=self.id,systemId=self.systemId},e1)end;function dQ:convertToWorldCoordinates(e3)local eT=dy(e3)and e2(e3)or e3;if eT.id==0 then return vec3(eT.latitude,eT.longitude,eT.altitude)end;assert(dB(eT),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eT.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eT.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eY=math.cos(eT.latitude)return self.center+(self.radius+eT.altitude)*vec3(eY*math.cos(eT.longitude),eY*math.sin(eT.longitude),math.sin(eT.latitude))end;function dQ:getAltitude(d_)return(vec3(d_)-self.center):len()-self.radius end;function dQ:getDistance(d_)return(vec3(d_)-self.center):len()end;function dQ:getGravity(d_)local eZ=self.center-vec3(d_)local e_=eZ:len2()return self.GM/e_*eZ/dr(e_)end;return setmetatable(eh,{__call=function(dT,...)return ei(...)end})end;local function f0(d,b,c,a,dr,f1)local cp={}local f2=100;function cp.computeAccelerationTime(f3,f4,f5)return(f5-f3)/f4 end;function cp.computeDistanceAndTime(f3,f5,f6,f7,f8,f9)f8=f8 or 0;f9=f9 or 0;local fa=f3<f5;local fb=f7/(fa and f6 or-f6)local fc=-f9/f6;local fd=fb+fc;if f3==f5 then return 0,0 elseif fa and fd<=0 or not fa and fd>=0 then return-1,-1 end;local fe,ff=0,0;if fb~=0 and f8>0 then local fg=math.pi/f8/2;local dA=function(dx)return fb*(dx/2-f8*math.sin(fg*dx)/math.pi)+fc*dx+f3 end;local fh=fa and function(a)return a>=f5 end or function(a)return a<=f5 end;ff=2*f8;if fh(dA(ff))then local fi=0;while math.abs(ff-fi)>0.25 do local dx=(ff+fi)/2;if fh(dA(dx))then ff=dx else fi=dx end end end;local fj=2*fb*f8^2/math.pi^2;fe=fj*(math.cos(fg*ff)-1)+(fb+2*fc)*ff^2/4+f3*ff;if ff<2*f8 then return fe,ff end;f3=dA(ff)end;local eF=fb+fc;local dx=cp.computeAccelerationTime(f3,eF,f5)local fk=f3*dx+eF*dx*dx/2;return fe+fk,ff+dx end;function cp.computeTravelTime(f3,f4,cb)if cb==0 then return 0 end;if f4~=0 then return(math.sqrt(2*f4*cb+f3^2)-f3)/f4 end;assert(f3>0,'Acceleration and initial speed are both zero.')return cb/f3 end;return cp end;local function fl(d,b,c,a,dn,dp,dq,dr,ds)local vec3=vec3;local dm=dm(d,b,c,a,dn,dp,dq,dr,ds)local function dy(a)return type(a)=='string'end;local function dw(dx)return type(dx)=='table'end;fm={}fm.__index=fm;function fm:escapeAndOrbitalSpeed(e6)assert(self.body)local cb=e6+self.body.radius;if not ds(cb,0)then local fn=dr(self.body.GM/cb)return dr(2)*fn,fn end;return nil,nil end;function fm:orbitalParameters(e3,fo)assert(self.body)assert(dw(e3)or dy(e3))assert(dw(fo))local fp=(dy(e3)or dm.isMapPosition(e3))and self.body:convertToWorldCoordinates(e3)or vec3(e3)local dA=vec3(fo)local fq=fp-self.body.center;local fr=dA:len2()local fk=fq:len()local fs=self.body.GM;local ft=((fr-fs/fk)*fq-fq:dot(dA)*dA)/fs;local eF=fs/(2*fs/fk-fr)local fu=ft:len()local eH=ft:normalize()local fv=eF*(1-fu)local fw=eF*(1+fu)local fx=fv*eH+self.body.center;local fy=fu<=1 and-fw*eH+self.body.center or nil;local fz=dr(eF*fs*(1-fu*fu))local fA=fy and 2*math.pi*dr(eF^3/fs)local fB=math.acos(ft:dot(fq)/(fu*fk))if fq:dot(dA)<0 then fB=-(fB-2*math.pi)end;local fC=math.acos((math.cos(fB)+fu)/(1+fu*math.cos(fB)))local fD=fC;if fD<0 then fD=fD+2*math.pi end;local fE=fD-fu*math.sin(fD)local fF=0;local fG=0;local fH=0;if fA~=nil then fF=fE/(2*math.pi/fA)fG=fA-fF;fH=fG+fA/2;if fB-math.pi>0 then fG=fF;fH=fG+fA/2 end;if fH>fA then fH=fH-fA end end;return{periapsis={position=fx,speed=fz/fv,circularOrbitSpeed=dr(fs/fv),altitude=fv-self.body.radius},apoapsis=fy and{position=fy,speed=fz/fw,circularOrbitSpeed=dr(fs/fw),altitude=fw-self.body.radius},currentVelocity=dA,currentPosition=fp,eccentricity=fu,period=fA,eccentricAnomaly=fC,meanAnomaly=fE,timeToPeriapsis=fG,timeToApoapsis=fH,trueAnomaly=fB}end;local function fI(fJ)local eR=dm.BodyParameters(fJ.systemId,fJ.id,fJ.radius,fJ.center,fJ.GM)return setmetatable({body=eR},fm)end;return setmetatable(fm,{__call=function(dT,...)return fI(...)end})end;local function fK(d,b,c,a,dbHud_1,e,fL,fM,bN,dq,dr,fN,fO,dl)local function fP(fQ)local dk=fR:closestBody(fQ)if(fQ-dk.center):len()>dk.radius+dk.noAtmosphericDensityAltitude then dk=e[0][0]end;return dk end;local function fS()local function fT(fU,fV)return fU.name<fV.name end;cU={}for dO,dA in pairs(e[0])do cU[#cU+1]={name=dA.name,index=dO}end;table.sort(cU,fT)end;local function fW(fX,fY)if not fY then fY=fZ.name end;for dO,dA in pairs(fX)do if dA.name and dA.name==fY then return dO end end;return-1 end;local function f_()d1=bn;if bn==0 then bl="None"c8=nil;fZ=nil;return true end;local g0=cU[bn].index;local g1=e[0][g0]if g1.center then bl=g1.name;c8=co[0][g0]if fZ~=nil then if ch==0 then if fL(g2,g3)~=1 then fM(g2,g3)end;if fL(g4,g5)~=1 then fM(g4,g5)end;if fL(g6,g7)~=1 then fM(g6,g7)end;if fL(g8,g9)~=1 then fM(g8,g9)end;if fL(ga,gb)~=1 then fM(ga,gb)end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end;if fL(gg,gh)~=1 then fM(gg,gh)end end;fZ=nil else fZ=g1;for dT,dA in pairs(co[0])do if dA.name==fZ.planetname then c8=dA;bl=fZ.name;break end end;if fL(gc,gd)~=1 then fM(gc,gd)end;if fL(ge,gf)~=1 then fM(ge,gf)end end;if fZ==nil then bm=vec3(c8.center)else bm=fZ.position end;if c8.planetname~="Space"then if c8.hasAtmosphere then gi=bN(c8.radius*(T-1)+c8.noAtmosphericDensityAltitude)else gi=bN(U+c8.surfaceMaxAltitude)end else gi=S end;if fZ~=nil and fZ.planetname=="Space"then bh=0 else dT,bh=cq(c8):escapeAndOrbitalSpeed(gi)end;bj=0;bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"return true end;local function gj(gk)if not di and not b5 and not bs and not cd and not bB and not ba and not ce then if gk==nil then bn=bn+1;if bn>#cU then bn=0 end else bn=bn-1;if bn<0 then bn=#cU end end;if bn==0 then f_()else local g0=cU[bn].index;local g1=e[0][g0]if g1 and(g1~=nil and g1.name=="Space"or bC=="Custom Only"and g1.center or bC=="No Moons-Asteroids"and(string.find(g1.name,"Moon")~=nil or string.find(g1.name,"Asteroid")~=nil))then if gk==nil then gj()else gj(1)end else f_()end end else dl("Disengage autopilot before changing Interplanetary Helper")fN("iph","AP")end end;local function gl()local function gm(gn)local go;if gn then go=d9 else go=br end;local gp=-1;gp=fW(e[0])if gp>-1 then table.remove(e[0],gp)end;gp=-1;gp=fW(go)if gp~=-1 then dl(fZ.name.." saved location cleared")table.remove(go,gp)end;gj()fS()return go end;if string.sub(bl,1,1)=="*"then d9=gm(true)else br=gm(false)end end;local function gq(gr,fQ,gs,gt)local function gu(gn)if gn then go=d9 else go=br end;if dbHud_1 or gs or gn then local dk=fP(fQ)local gv={position=fQ,name=gr,planetname=dk.name,gravity=b.getGravityIntensity(),safe=gt}if not gs then go[#go+1]=gv else for dO,dA in pairs(e[0])do if dA.name and gr==dA.name then table.remove(e[0],dO)end end end;table.insert(e[0],gv)fS()f_()dl("Location saved as "..gr.."("..dk.name..")")return go else dl("Databank must be installed to save permanent locations")end end;if string.sub(gr,1,1)=="*"then d9=gu(true)else br=gu(false)end end;local gw={}function gw.UpdateAtlasLocationsList()fS()end;function gw.UpdateAutopilotTarget()f_()end;function gw.adjustAutopilotTargetIndex(gk)gj(gk)end;function gw.findAtlasIndex(fX,fY)return fW(fX,fY)end;function gw.UpdatePosition(gx,gy,gz)local function gA(gn)local go;if gn then go=d9 else go=br end;local gp=fW(go)if gp~=-1 then if gx~=nil then if gn then gx="*"..gx end;go[gp].name=gx;bn=bn-1;gj()elseif gz~=nil then if gz then local gB=ci;if gB<1000 then gB=1000 end;go[gp].agg=fO(gB,0)dl(go[gp].name.." AGG Altitude:"..go[gp].agg.." saved ("..go[gp].planetname..")")return elseif gz==false then go[gp].agg=nil;dl(go[gp].name.." AGG Altitude cleared ("..go[gp].planetname..")")return end else local gC=go[gp]if gy then gC.heading=cI:cross(cM)*5000;dl(go[gp].name.." heading saved ("..go[gp].planetname..")")return elseif gy==false then gC.heading=nil;dl(go[gp].name.." heading cleared ("..go[gp].planetname..")")return end;gC.gravity=b.getGravityIntensity()gC.position=cO;gC.safe=true end;dl(go[gp].name.." position updated ("..go[gp].planetname..")")else dl("Name Not Found")end end;if string.sub(bl,1,1)=="*"then gA(true)else gA(false)end end;function gw.AddNewLocation(gr,fQ,gs,gt)gq(gr,fQ,gs,gt)end;function gw.ClearCurrentPosition()gl()end;for dO,dA in pairs(da)do table.insert(e[0],dA)end;if gD then for dO,dA in pairs(gD)do gw[dO]=dA end end;fS()if bn>#cU then bn=0 end;gw.UpdateAutopilotTarget()return gw end;local function gE(b,a,c,radar_1,radar_2,warpdrive,f1,gF,dr,gG,dq,gH,fN,dl)local gI={}local gJ={}local gK={XS=13,S=27,M=55,L=110,XL=221}local gL={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gM={}local gN=0;local gO;local gP;local gQ=0;local gR;local gS={gR}local gT="Atmo"local gU;local gV;local gW=0;local gX={}local gY;local gZ=0;local g_=table.insert;local h0=-4;local h1={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h2,h3;local h4,h5;local h6;local h7;local h8;local h9;local ha;local hb;local hc;local function hd()if he~=nil and gW==0 then gF(he)a.destroyWidget(h2)a.destroyData(h4)h2,h4,he=nil,nil,nil;if gV~=nil then gF(gV)a.destroyWidget(h3)a.destroyData(h5)gV,h3,h5=nil,nil,nil end else if gW==1 then gV=a.createWidgetPanel("PeriWinkle")h3=a.createWidget(gV,'periscope')h5=gR.getWidgetDataId()a.addDataToWidget(h5,h3)end;if he==nil and gN>0 then he=a.createWidgetPanel(gT)h2=a.createWidget(he,'radar')h4=gR.getWidgetDataId()a.addDataToWidget(h4,h2)end;gW=0 end end;local function hf()local function hg(hh,hi,hj,hk,hl,hm,hn,ho)hi,hk,hm,ho=vec3(hi),vec3(hk),vec3(hm),vec3(ho)local hp,hq,hr=hh*hh,hj*hj,hl*hl;local fr=hk-hi;local hs=fr:normalize()local ht=fr:len()local hu=hm-hi;local hv=(hu-hu:project_on(hs)):normalize()local hw,hx=hu:dot(hs),hu:dot(hv)local hy=hw*hw+hx*hx;local hz=hs:cross(hv)local hA=(hp-hq+ht*ht)/(2*ht)local hB=(hp-hr+hy-2*hw*hA)/(2*hx)local dC=hp-hA^2-hB^2;local hC=dr(dC)local hD=hi+hs*hA+hv*hB+hz*hC;local hE=hi+hs*hA+hv*hB-hz*hC;if f1((ho-hD):len()-hn)<f1((ho-hE):len()-hn)then return hD else return hE end end;local function hF(hG,fk,hH)local hI=hG.pts;local gp=#hI;local hJ=hG.ref;if gp>3 then local hK,hL,hM,hN=hI[gp],hI[gp-1],hI[gp-2],hI[gp-3]hG.ref=hH;local fp=hg(hK[1],hK[2],hL[1],hL[2],hM[1],hM[2],hN[1],hN[2])local hA,hB,hC=fp.x,fp.y,fp.z;if hA==hA and hB==hB and hC==hC then hA=hA+hJ[1]hB=hB+hJ[2]hC=hC+hJ[3]local hO=vec3(hA,hB,hC)hG.center=hO;if hG.lastPos then if(hG.lastPos-hO):len()<2 then local hP=(hO-vec3(hH)):len()if f1(hP-fk)<10 then hG.skipCalc=true end end end;hG.lastPos=hO end;hG.pts={}else local hQ={hH[1]-hJ[1],hH[2]-hJ[2],hH[3]-hJ[3]}hI[gp+1]={fk,hQ}end end;if radar_1 or radar_2 then cu.assignRadar()end;if gR then if#gY>0 then local hR,hS=0,0;local hT=cL*10;local cY=cY;gQ,gP=0,0;gJ={}for dT,dA in pairs(gY)do local cb=ha(dA)if cb>0.0 then if h6(dA)==1 then g_(gJ,dA)end;if not cV and warpdrive and cb<a9 and warpdrive.getStatus()==15 then dl("INITIATING WARP")c4=7;warpdrive.initiate()end;local hU=F and h8(dA)==1;if E or hU then local hV=hb(dA)local hW=gK[hV]local hX=h7(dA)if hU or cb<hT and(hW>27 or hX==4 or hX==6)then gQ=gQ+1;local hH={cO["x"],cO["y"],cO["z"]}local hG=gX[dA]if hG==nil then hW=hW+gH;gX[dA]={pts={},ref=hH,name=h9(dA),i=0,radius=hW,skipCalc=false}hG=gX[dA]end;if not hG.skipCalc then if hU or hX==4 or hX==6 then hG.center=vec3(hc(dA))hG.skipCalc=true else hF(hG,cb,hH)hS=hS+1 end;if hU and not hG.abandoned then local bQ=a.getArkTime()if gZ+5<bQ then gZ=bQ;fN("abRdr","RD")end;a.print("Abandoned Construct: "..hG.name.." ("..hV.." "..gL[hX]..") at ::pos{0,0,"..hG.center.x..","..hG.center.y..","..hG.center.z.."}")dl("Abandoned Radar Contact ("..hV.." "..gL[hX]..") detected")hG.abandoned=true end else g_(gM,hG)end end;hR=hR+1;if hR>300 or hS>30 then coroutine.yield()hR,hS=0,0 end end end end;gP=#gM;if gP>0 and(cL>20 or b8)then local ev,hY,hZ,h_;local i0=0;local i1=co:getPlanetarySystem(0)h_=cK:normalize()while i0<gP do coroutine.yield()local i2={table.unpack(gM,i0,math.min(i0+75,gP))}ev,hY,hZ=i1:castIntersections(cO,h_,nil,nil,i2,true)if ev and hZ then c_={ev,hY,hZ}break end;i0=i0+75 end;if not ev then c_=nil end else c_=nil end;gM={}gO=gR.getTargetId()end end end;local function i3()if gR then gT="Atmo"if string.find(gR.getName(),"Space")then gT="Space"end end end;function gI.pickType()i3()end;function gI.assignRadar()if radar_2 and h0~=1 then if h0==-1 then if gR==radar_2 then gR=radar_1 else gR=radar_2 end end;gS={gR}h6=gR.hasMatchingTransponder;h7=gR.getConstructKind;h8=gR.isConstructAbandoned;h9=gR.getConstructName;ha=gR.getConstructDistance;hb=gR.getConstructCoreSize;hc=gR.getConstructWorldPos;gY=gR.getConstructIds()i3()else gY=gR.getConstructIds()end;h0=gR.getOperationalState()end;function gI.UpdateRadar()local i4=coroutine.status(gU)if i4=="suspended"then local dP,i5=coroutine.resume(gU)if i5 then a.print("ERROR UPDATE RADAR: "..i5)end elseif i4=="dead"then gU=coroutine.create(hf)local dP,i5=coroutine.resume(gU)end end;function gI.GetRadarHud(i6,i7,ax,ay)local i8,dl;local dG=gP or 0;gN=#gY;if gN>0 then if E then dl=dG.."/"..gQ.." Known/InRange : "..gN.." Total"else dl="Radar Contacts: "..gN end;i8=gG(ax,ay,dl,"pbright txtbig txtmid")if#gJ>0 then i8=i8 ..gG(i6,i7,"Friendlies In Range","pbright txtbig txtmid")for dO,dA in pairs(gJ)do i7=i7+20;i8=i8 ..gG(i6,i7,gR.getConstructName(dA),"pdim txtmid")end end;local i9=#gR.getIdentifiedConstructIds()if gV==nil and i9>0 then gW=1;cu.ToggleRadarPanel()end;if gV~=nil and i9==0 then cu.ToggleRadarPanel()end;if he==nil then if w then cu.ToggleRadarPanel()end end else if h0~=1 then i8=gG(ax,ay,gT.." Radar: "..h1[h0],"pbright txtbig txtmid")else i8=gG(ax,ay,"Radar: No "..gT.." Contacts","pbright txtbig txtmid")end;if he~=nil then gW=0;cu.ToggleRadarPanel()end end;return i8 end;function gI.GetClosestName(gr)if gR then local ia=gR.getConstructName(gR.getConstructIds()[1])if ia then gr=gr.." "..ia end end;return gr end;function gI.ToggleRadarPanel()hd()end;function gI.ContactTick()if not ib then ib=0 end;if bQ>ib+10 then dl("Radar Contact")fN("rdrCon","RC")ib=bQ end;c.stopTimer("contact")end;function gI.onEnter(dY)if gR and not cg and not cV then c.setTimer("contact",0.1)end end;function gI.onLeave(dY)if gR and E then if#gX>650 then dY=tostring(dY)gX[dY]=nil end end end;local function ic()gR=nil;if radar_2 and radar_2.getOperationalState()==1 then gR=radar_2 else gR=radar_1 end;h0=gR.getOperationalState()h6=gR.hasMatchingTransponder;h7=gR.getConstructKind;h8=gR.isConstructAbandoned;h9=gR.getConstructName;ha=gR.getConstructDistance;hb=gR.getConstructCoreSize;hc=gR.getConstructWorldPos;gS={gR}gY=gR.getConstructIds()i3()gU=coroutine.create(hf)if id then for dO,dA in pairs(id)do gI[dO]=dA end end end;ic()return gI end;local function ie(shield,e7,bN,dl)local ig={}local ih=shield.getResistancesCooldown()local function ii()local ij=shield.isActive()if G then if not cV and ij==0 and shield.isVenting()~=1 then shield.toggle()elseif cV and ij==1 then shield.toggle()end end end;local function ik()local il=shield.getStressRatioRaw()local im=0.5999;if il[1]==0.0 and il[2]==0.0 and il[3]==0.0 and il[4]==0.0 then return end;local io=shield.setResistances(im*il[1],im*il[2],im*il[3],im*il[4])if io==1 then dl("Shield Resistances updated")else dl("Value Exceeded. Failed to update Shield Resistances")end end;function ig.shieldTick()dj=bN(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ii()ih=shield.getResistancesCooldown()if ih==0 and dj<a8 then ik()end end;function ig.setResist(ip)if not shield then dl("No shield found")return elseif ip==nil or ih>0 then dl("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH=dG..', '..dG..', '..dG..', '..dG;local iq,ir,is,it=e7(ip,dH)if it==nil or iq+ir+is+it>0.6 then dl("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(iq,ir,is,it)==1 then dl("Shield Resistances set")else dl("Resistance setting failed.")end end;function ig.ventShield()local iu=shield.getVentingCooldown()if iu>0 then dl("Cannot vent again for "..iu.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()dl("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else dl("Shields already at max hitpoints")end end;if iv then for dO,dA in pairs(iv)do ig[dO]=dA end end;return ig end;local function iw(d,b,c,a,e,antigrav,hover,shield,warpdrive,ix,f1,bN,dn,iy,bO,iz,iA,eX,bM,dp,iB,fM,fL,gF,iC,dr,fO,gG,fN,iD,iE,iF,iG,iH,iI,dl)local bP=DUConstruct;local iJ=9.80665;local iK={}local iL={}local iM={}local iN={}local iO=nil;local iP=nil;local iQ=nil;local iR=false;local iS="none"local iT=""local iU=55;local iV=0;local iW=0;local iX=nil;local iY=af;local iZ=ag;local i_=ah;local j0=[[rgb(]]..bN(iY+0.5)..","..bN(iZ+0.5)..","..bN(i_+0.5)..[[)]]local j1=[[rgb(]]..bN(iY*0.9+0.5)..","..bN(iZ*0.9+0.5)..","..bN(i_*0.9+0.5)..[[)]]local j2=0;local j3=0;local j4=""local j5=bM()local j6=false;local j7=false;local gR=false;local function j8(dA)if ac==1920 then return dA else return fO(ac*dA/1920,0)end end;local function j9(dA)if ad==1080 then return dA else return fO(ad*dA/1080,0)end end;local function ja()return iC()==0 and g~="keyboard"and iA()==0 end;local function jb()local jc="TRAVEL"if not cR then jc="CRUISE"end;if b5 then jc="AUTOPILOT"end;return jc end;local i8=""local jd=""local je=""local jf=1;local jg=2;local jh=3;local ji=4;local jj=5;local jk=6;local jl=7;local jm=""local jn=0;local jo=90.0*aT;local jp={}local jq={}local jr={}local js={}local jt={}local ju={}local jv={}jv["atmofueltank"],jv["spacefueltank"],jv["rocketfueltank"]=0,0,0;local jw=0;local function jx(hA,jy,jz,jA,jB,jC)local jD=jw;local jE=jw+5;if not B then jE=jE+5 end;if iA()==1 and not m then jD=jD-50;jE=jE-50 end;if jz=="ATMO"then jm="atmofueltank"elseif jz=="SPACE"then jm="spacefueltank"else jm="rocketfueltank"end;jn=_G[jm.."_size"]if#jA>0 then for M=1,#jA do local gr=jA[M][jg]local jF=jA[M][jl]for jG=1,jn do if jA[M][jg]==iy(c[jm.."_"..jG].getWidgetData()).name then jF=jG;break end end;local jH=bM()if jB[M]==nil or jC[M]==nil or jH-jA[M][jk]>jo then local jI;local jJ=0;jJ=iz(jA[M][jf])-jA[M][ji]jI=jA[M][jj]local jK=jI>jJ or false;if jK then jv[jm]=jv[jm]+jI-jJ end;if jF~=0 then local jL=iy(c[jm.."_"..jF].getWidgetData())jC[M]=jL.percentage;jB[M]=jL.timeLeft;if jB[M]=="n/a"then jB[M]=0 end else jC[M]=bN(0.5+jJ*100/jA[M][jh])if jK then jB[M]=bN(0.5+jJ/((jI-jJ)/(jH-jA[M][jk])))else jB[M]=0 end end;jA[M][jk]=jH;jA[M][jj]=jJ end;if gr==jy then gr=dn("%s %d",jz,M)end;if jF==0 then gr=gr.." *"end;local jM;jM=iG(jB[M])if jB[M]==0 or jM==">1y"then jM=""end;if jC[M]~=nil then local jN=bN(jC[M]*2.55)local jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)local jP=""if jM~=""and jB[M]<120 or jC[M]<5 then jP="red "end;local jQ=dn("rgb(%d,%d,%d)",dp(bN((255-jN)/2.55),50,100),dp(bN(jN/2.55),0,50),50)local jR="rgb(196,0,255)"if jz=="ATMO"then jR="rgb(0,188,255)"elseif jz=="SPACE"then jR="rgb(239,255,0)"end;local jS=false;if jT~=jR then jS=true end;jT=jR;if B then if jS then jD=jD-5;jE=jE-5 end;jd=jd..dn([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jQ,jR,hA,jE,jO,bN(jC[M]*1.7+0.5)-2,hA+1,jE+1,hA+5,jE+14,gr,jC[M],jM)jD=jD-22;jE=jE-22 else jd=jd..gG(hA,jD,gr,jP.."pdim txtfuel")jd=jd..gG(hA,jE,dn("%d%% %s",jC[M],jM),"pdim txtfuel","fill:"..jO)jD=jD+30;jE=jE+30 end end end end;jw=jD end;local function jU(jV,e6)if ap==0 and aq==0 then return end;if e6<200000 and not cg or e6 and cg then local jW=0;if f1(cN)>1 then jW=45*math.log(f1(cN),10)if cN<0 then jW=-jW end end;jV[#jV+1]=dn([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bN(cN),bN(jW))end;return jV end;local function jX(jY)local gk=-cM;jY=jY-jY:project_on(gk)local jZ=vec3(0,0,1)jZ=jZ-jZ:project_on(gk)local j_=jZ:cross(gk)local jW=jZ:angle_between(jY)*constants.rad2deg;if jY:dot(j_)<0 then jW=360-jW end;return jW end;local function k0(jV,al,am,k1,k2,cY)if ae==0 then return end;local k3=ae;local k4=20;local k5=bN(k1)if cY then for M=-45,45,5 do local k6=M;jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],k6,al,am)k7=5;if M%15==0 then k7=15 elseif M%10==0 then k7=10 end;jV[#jV+1]=dn([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k3+k4-k7,al,am+k3+k4)end;jV[#jV+1]=gG(al,am+k3+k4-35,k2,"pdim txt txtmid")jV[#jV+1]=gG(al,am+k3+k4-25,k5 .." deg","pdim txt txtmid")jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-k1,al,am)jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k3+k4-20,al+5,am+k3+k4-20,al,am+k3+k4-15)jV[#jV+1]="</g>"end;jV[#jV+1]=[[<g style="clip-path: url(#headingClip);">]]local k8=k5;if cY then k8=jX(cH)end;local k9=20;local ka=bN(k8)local kb=0;local kc=am+k3+k4+20;local kd=al;if k2~="YAW"then kc=j9(130)kd=j8(960)end;local ke=[[<path class="txttick line" d="]]local kf=bN(ka-(k9+10)-ka%5+0.5)for M=kf+70,kf,-5 do local hA=kd-(-M*5+k8*5)if M%10==0 then kb=10;local dG=M;if dG==360 then dG=0 elseif dG>360 then dG=dG-360 elseif dG<0 then dG=dG+360 end;jV[#jV+1]=gG(hA,kc+15,dG,"txtmid bright")elseif M%5==0 then kb=5 end;if kb==10 then ke=dn([[%s M %f %f v %d]],ke,hA,kc-5,kb)else ke=dn([[%s M %f %f v %d]],ke,hA,kc-2.5,kb)end end;jV[#jV+1]=ke..[["/>]]jV[#jV+1]=dn([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kd-5,kc-20,kd+5,kc-20,kd,kc-10)if cY then k2="HDG"end;jV[#jV+1]=gG(j8(960),j9(100),ka.."Â°","dim txt txtmid size14","")jV[#jV+1]=gG(j8(960),j9(85),k2,"dim txt txtmid size20","")jV[#jV+1]=[[</g>]]end;local function kg(jV,kh,k1,al,am,cY,ki,kj)if ae==0 then return end;local k3=ae;local kk=bN(k3*3/5)if k3>0 then local kl=bN(kh)local k7=0;local ke=dn([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k1,al,am)if not cg then ke=dn([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jV[#jV+1]=dn([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k3-1,al,am)jV[#jV+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bN(kl-30-kl%5+0.5),bN(kl+30+kl%5+0.5),5 do if M%10==0 then k7=30 elseif M%5==0 then k7=20 end;local hB=am+-M*5+kh*5;if k7==30 then ke=dn([[%s M %d %f h %d]],ke,al-kk-k7,hB,k7)if cg then jV[#jV+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k1,al,am,al-kk+10,hB+4,M)jV[#jV+1]=dn([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k1,al,am,al+kk-10,hB+4,M)if M==0 or M==180 or M==-180 then jV[#jV+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k1,al,am,al-kk+20,hB,kk*2-40)end else jV[#jV+1]=gG(al-kk+10,hB,M,"pdim txt txtmid")jV[#jV+1]=gG(al+kk-10,hB,M,"pdim txt txtmid")end;ke=dn([[%s M %d %f h %d]],ke,al+kk,hB,k7)else ke=dn([[%s M %d %f h %d]],ke,al-kk-k7,hB,k7)ke=dn([[%s M %d %f h %d]],ke,al+kk,hB,k7)end end;jV[#jV+1]=ke..[["/>]]local km="PITCH"if not cY then km="REL PITCH"end;if kh>90 and not cg then kh=90-(kh-90)elseif kh<-90 and not cg then kh=-90-(kh+90)end;if k3>200 then if cg then if kj>iU then jV[#jV+1]=gG(al,am-15,"Yaw","pdim txt txtmid")jV[#jV+1]=gG(al,am+20,ki,"pdim txt txtmid")end;jV[#jV+1]=dn([[<g transform="rotate(%f,%d,%d)">]],-k1,al,am)else jV[#jV+1]=dn([[<g transform="rotate(0,%d,%d)">]],al,am)end;jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kk+25,am-5,al-kk+20,am,al-kk+25,am+5,al-kk+50,am+4,kl)jV[#jV+1]=dn([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kk-25,am-5,al+kk-20,am,al+kk-25,am+5,al+kk-30,am+4,kl)jV[#jV+1]="</g>"end;local kn=bN(k3/3)jV[#jV+1]=dn([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-kn,am,k3-kn)if not cg and cY then jV[#jV+1]=dn([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k1,al,am,al-kk+10,am,kk*2-20)end;jV[#jV+1]="</g>"if k3<200 then if cg and kj>iU then jV[#jV+1]=gG(al,am-k3,km,"pdim txt txtmid")jV[#jV+1]=gG(al,am-k3+10,kl,"pdim txt txtmid")jV[#jV+1]=gG(al,am-15,"Yaw","pdim txt txtmid")jV[#jV+1]=gG(al,am+20,ki,"pdim txt txtmid")else jV[#jV+1]=gG(al,am-k3,km,"pdim txt txtmid")jV[#jV+1]=gG(al,am-k3+15,kl,"pdim txt txtmid")end end end end;local function ko(jV,e6,cY)local kp=ar;local kq=as;if kp==0 and kq==0 then return end;local kr=78;local ks=19;local kt=cf;if cf~=-1 then jV[#jV+1]=gG(kp+kr,kq+ks+20,dn("AGL: %.1fm",cf),"pdim altsm txtend")end;if cY and(e6<200000 and not cg or e6 and cg)then jV[#jV+1]=gG(kp+kr,kq-10,dn("%s",ku.name),"pdim altsm txtend")table.insert(jV,dn([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kp-1,kq-4,kr+2,ks+6,kp+1,kq-1,kr-4,ks))local gp=0;local kv=1;local kw=0;local kx=e6<0;local ky=e6<ku.surfaceMaxAltitude;local kz=9;if kx then kz=0 end;local e6=f1(e6)while gp<6 do local kA=11;local kB=16;local kC=9;local kD=14;local jP="altsm"if gp>2 then kB=kB+3;kA=kA+2;kD=kD+2;kC=kC-6;jP="altbig"end;if kx then jP=jP.." red"elseif ky then jP=jP.." orange"end;local kE=e6/kv%10;local kF=bN(kE)local kG=bN((kF+1)%10)local kH=kw;if gp==0 then kH=kE-kF;if kx then kH=1-kH end end;if kx and(gp==0 or kw~=0)then local gs=kG;kG=kF;kF=gs end;local kI=kB*(kH-1)local kJ=kI+kB;local hA=kp+kC+(6-gp)*kA;local hB=kq+kD;jV[#jV+1]=gG(hA,hB+kI,kG,jP)jV[#jV+1]=gG(hA,hB+kJ,kF,jP)gp=gp+1;kv=kv*10;if kF==kz then kw=kH else kw=0 end end;table.insert(jV,[[</g></g>]])end end;local function kK(fo)local kL=-math.deg(eX(fo.y,fo.z))+180;kL=kL-90;if kL<0 then kL=360+kL end;if kL>180 then kL=-180+kL-180 end;return-kL end;local function kM(fo)local k8=math.deg(eX(fo.y,fo.x))-90;if k8<-180 then k8=360+k8 end;return k8 end;local function kN(jV,fo,kj,al,am)if kj>5 and not cg or kj>iU then local k3=ae;local kO=20;local kP=20;local kQ=kK(fo)local kR=kM(fo)local kS=14;local kT=kS/2;local kU=-kR/kP*k3;local kV=kQ/kO*k3;local hA=al+kU;local hB=am+kV;local cb=dr(kU^2+kV^2)local kW=[[<circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kT/kS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hA..[["
                            cy="]]..hB..[["
                            r="]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hA-kS..[[,]]..hB..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA+kT..[[,]]..hB..[[ h ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<k3 then jV[#jV+1]=kW else local jW=eX(kV,kU)local kX=4;local kY=al+k3*math.cos(jW)local kZ=am+k3*math.sin(jW)jV[#jV+1]=dn('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jW*180/math.pi,kY,kZ,kY-kX,kZ-kX/2,kX*2,kX,kY+kX,kZ-kX,kX,kX,-kX,kX)end;if not cg then local k_=vec3(fo)kQ=kK(-k_)kR=kM(-k_)kU=-kR/kP*k3;kV=kQ/kO*k3;hA=al+kU;hB=am+kV;cb=dr(kU^2+kV^2)if cb<k3 then local l0=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hA..[[,]]..hB..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hA..[[,]]..hB..[[)" />
                                <path
                                    d="M ]]..hA-kT..[[,]]..hB..[[ h ]]..kS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hA..[[,]]..hB..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hA..[[,]]..hB..[[)"/>]]jV[#jV+1]=l0 end end end end;local function l1(jV,jc,l2,l3)if an==0 and ao==0 then return end;l2=bN(l2+0.5)local jD=ao+10;local jE=ao+20;if iA()==1 and not m then jD=55;jE=65 end;local l4="CRUISE"local c="km/h"local dP=l3;if jc=="TRAVEL"or jc=="AUTOPILOT"then l4="THROT"c="%"dP=l2;local l5="dim"if l2<0 then l5="red"end;jV[#jV+1]=dn([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l5,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-f1(l2),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jV[#jV+1]=gG(an+10,jD,l4,"pbright txtstart")jV[#jV+1]=gG(an+10,jE,dn("%.0f %s",dP,c),"pbright txtstart")if cg and t and cR and bT then l2=bN(bU*100+0.5)local l5="red"if l2<0 then l5="red"end;jV[#jV+1]=dn([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l5,1-f1(l2),an-10,ao+50,an-15,ao+53,an-15,ao+47)jV[#jV+1]=gG(an+10,jD+40,"LIMIT","pbright txtstart")jV[#jV+1]=gG(an+10,jE+40,l2 .."%","pbright txtstart")end;if cg and t or ba then jV[#jV+1]=gG(an+10,jD-40,"LIMIT: "..cB.." km/h","dim txtstart")elseif not cg and b5 then jV[#jV+1]=gG(an+10,jD-40,"LIMIT: "..bN(a0*3.6+0.5).." km/h","dim txtstart")end end;local function l6(jV,l7)if an==0 and ao==0 then return end;local l8=ao-10;local l9=an+10;jV[#jV+1]=gG(0,0,"","pdim txt txtend")if iA()==1 and not m then l8=75 end;jV[#jV+1]=gG(l9,l8,bN(l7).." km/h","pbright txtbig txtstart")end;local la=40;local function lb(jV)jV[#jV+1]=gG(j8(150),j9(1070),dn("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jV[#jV+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jV[#jV+1]=gG(j8(960),j9(550),"Warning: Invalid Control Scheme Detected","warnings")jV[#jV+1]=gG(j8(960),j9(600),"Keyboard Scheme must be selected","warnings")jV[#jV+1]=gG(j8(960),j9(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lc=j8(960)local ld=j9(860)local le=j9(880)local lf=j9(900)local lg=j9(960)local lh=j9(200)local li=j9(250)local lj=j9(960)if iA()==1 and not m then ld=j9(135)le=j9(155)lf=j9(175)lh=j9(115)li=j9(95)end;if b2 then local lk=""if type(b2)=="string"then lk="-"..b2 end;jV[#jV+1]=gG(lc,ld,"Brake Engaged"..lk,"warnings")elseif bS>0 then jV[#jV+1]=gG(lc,ld,"Auto-Brake Engaged","warnings","opacity:"..bS)end;if cg and cA and cf==-1 then if not b5 and not bs and not b8 and not cQ and not bb and not b9 then jV[#jV+1]=gG(lc,lh+50,"** STALL WARNING **","warnings")fN("stall","SW",2)end end;if cX then jV[#jV+1]=gG(lc,lh+90,"Flight Assist in Progress","warnings")end;if ck then jV[#jV+1]=gG(lc,lj,"Gyro Enabled","warnings")end;if ll then la=la-1;if la>20 then jV[#jV+1]=gG(lc,lj-20,"ECU Enabled","warnings")elseif la<0 then la=40 end end;if bo then if bW then jV[#jV+1]=gG(lc,le,"Gear Extended","warn")else jV[#jV+1]=gG(lc,le,"Landed (G: Takeoff)","warnings")end end;if cf>-1 and(not cQ or ci<100)then local lm=iF(d:getTargetGroundAltitude())jV[#jV+1]=gG(lc,lf,"Hover Height: "..lm,"warn")end;if c5 then jV[#jV+1]=gG(lc,lg+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cQ and bx~=nil then local ln="warnings"if f1(ci-antigrav.getBaseAltitude())<501 then ln="warn"end;jV[#jV+1]=gG(lc,lh+40,dn("Target Altitude: %d Singularity Altitude: %d",bN(bx),bN(antigrav.getBaseAltitude())),ln)end;if b5 and bl~="None"then jV[#jV+1]=gG(lc,lh,"Autopilot "..bi,"warn")elseif bv~=nil then jV[#jV+1]=gG(lc,lh+20,dn("LockedPitch: %d",bN(bv)),"warn")elseif c0 then jV[#jV+1]=gG(lc,lh+20,"Follow Mode Engaged","warn")elseif ba or ce then jV[#jV+1]=gG(lc,lh+20,"Re-entry in Progress","warn")end;if b7 or bb then local lm=iF(bc,2)if bb then if cQ then lm=iF(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jV[#jV+1]=gG(lc,lh,"VTO to "..lm,"warn")elseif(b9 or cd)and not bB then if cd then jV[#jV+1]=gG(lc,lh,"Takeoff to "..bl,"warn")else jV[#jV+1]=gG(lc,lh,"Takeoff to "..lm,"warn")end;if b2 and not bb then jV[#jV+1]=gG(lc,lh+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jV[#jV+1]=gG(lc,lh,"Altitude Hold: "..dn("%.1fm",bc),"warn")end end;if bb and(antigrav~=nil and antigrav)then if ch>0.1 then jV[#jV+1]=gG(lc,lh+20,"Beginning ascent","warn")elseif ch<0.09 and ch>0.05 then jV[#jV+1]=gG(lc,lh+20,"Aligning trajectory","warn")elseif ch<0.05 then jV[#jV+1]=gG(lc,lh+20,"Leaving atmosphere","warn")end end;if bB then if cC~=nil then jV[#jV+1]=gG(lc,lh,cC,"warn")end end;if b8 then local lo="Brake Landing"if dc then lo=lo.."-Aligning"end;if db then lo=lo.."-Drift Limited"end;jV[#jV+1]=gG(lc,lh,lo,"warnings")end;if b4 then jV[#jV+1]=gG(lc,lh+20,"Prograde Alignment","crit")end;if b3 then jV[#jV+1]=gG(lc,lh,"Retrograde Alignment","crit")end;if cZ then local type;if string.find(cZ,"COLLISION")then type="warnings"else type="crit"end;jV[#jV+1]=gG(lc,li+20,cZ,type)elseif ch==0 then local lp,lq=ct.checkLOS(cK:normalize())if lq~=nil and cL>0 then local lm=iF(lq)local lr=cp.computeTravelTime(cL,0,lq)local ls="Collision"if lp.noAtmosphericDensityAltitude>0 then ls="Atmosphere"end;jV[#jV+1]=gG(lc,li+20,lp.name.." "..ls.." "..iG(lr).." In "..lm,"crit")end end;if bs and not bB then jV[#jV+1]=gG(lc,lh+60,lt,"warn")end;if d2 and#d2>1 then end;local lu=j8;local lv=j9;local lw="topButton"local lx="topButtonActive"local ly=lw;if b5 or bs or cd or bB then ly=lx end;local lz=lw;if b4 then lz=lx end;local lA=lw;if b8 or bo then lA=lx end;local lB=lw;if b7 or bs then lB=lx end;local lC=lw;if b3 then lC=lx end;local lD=lw;if bB or cE and b5 then lD=lx end;if w and I then local lE=lv(30)jV[#jV+1]=dn([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],ly,lu(960),lv(54),lv(-53),lu(-120),lu(25),lv(50))jV[#jV+1]=gG(lu(910),lE,"AUTOPILOT")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lz,lu(865),lv(51),lu(-25),lv(-50),lu(-110),lu(25),lv(46))jV[#jV+1]=gG(lu(800),lE,"PROGRADE")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lA,lu(755),lv(47),lu(-25),lv(-46),lu(-98),lu(44),lv(44))jV[#jV+1]=gG(lu(700),lE,"LAND")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lB,lu(960),lv(54),lv(-53),lu(120),lu(-25),lv(50))jV[#jV+1]=gG(lu(1010),lE,"ALT HOLD")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lC,lu(1055),lv(51),lu(25),lv(-50),lu(110),lu(-25),lv(46))jV[#jV+1]=gG(lu(1122),lE,"RETROGRADE")jV[#jV+1]=dn([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,lu(1165),lv(47),lu(25),lv(-46),lu(98),lu(-44),lv(44))jV[#jV+1]=gG(lu(1220),lE,"ORBIT")jV[#jV+1]=[[
                                    </g>
                                </g>]]jV[#jV+1]="</g>"end;return jV end;local function lF(kj)return bN(fO(kj*3.6,0)+0.5).." km/h"end;local function lG(gp)local gr=bl;if gp~=nil and type(gp)=="number"then if gp==0 then return"None"end;gr=cU[gp].name end;if gr==nil then gr=fZ.name end;if gr==nil then gr="None"end;return gr end;local function lH(jV)local lI=ct.routeWP(true)if not lI or#lI==0 then return end;local hA=j8(750)local hB=j9(360)if b5 or bs then jV[#jV+1]=gG(hA,hB,"REMAINING ROUTE","pdim txtstart size20")else jV[#jV+1]=gG(hA,hB,"LOADED ROUTE","pdim txtstart size20")end;for dO,M in pairs(lI)do hB=hB+20;jV[#jV+1]=gG(hA,hB,dO..". "..lI[dO],"pdim txtstart size20")end end;local function lJ(jV)local lK=aB;local lL=aC;local lM=aA;local lN=4;local lO=15;local hA=0;local hB=0;local lP,lQ,lR,lS;local lT;local function lU(type)local gB,bQ,kj,lV,jP,lW;if type=="Periapsis"then gB=lT.periapsis.altitude;bQ=lT.timeToPeriapsis;kj=lT.periapsis.speed;jP="txtend"lV=12;lW=math.min(hA,lK+lM-ku.radius/lR-lN*2)else gB=lT.apoapsis.altitude;bQ=lT.timeToApoapsis;kj=lT.apoapsis.speed;lV=-12;jP="txtstart"lW=hA end;if cL<1 then bQ=0 end;jV[#jV+1]=dn([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lW+lV,hB-5,hA,hB-5)jV[#jV+1]=dn([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lW-lV*4,hB+2,hA,hB+2)jV[#jV+1]=gG(lW,hB,type,jP)hA=lW-lV*2;hB=hB+lO;local lm=iF(gB)jV[#jV+1]=gG(hA,hB,lm,jP)hB=hB+lO;jV[#jV+1]=gG(hA,hB,iG(bQ),jP)hB=hB+lO;jV[#jV+1]=gG(hA,hB,lF(kj),jP)end;local lX=lM*1.5;if bK=="INFO"then lX=25*10 end;if bK=="ORBIT"and ci<ku.spaceEngineMinAltitude then return jV end;if bK~="HIDE"then jV[#jV+1]=[[<g class="pbright txtorb txtmid">]]jV[#jV+1]=dn('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lM*2,lX,lK,lL)jV[#jV+1]=dn([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lM*2,lX,lK,lL)end;local lY=lM*1.5;local lZ=lM*2;local l_=lY/2;local m0=lM;local m1=lK+m0;local m2=lL+l_;local m3=lK+lZ;local m4=lL+lY;if bK=="ORBIT"then lL=lL+lN;lP=lM/2;lS=0;lT={}lT.periapsis={}lT.apoapsis={}if fn~=nil then if fn.periapsis~=nil then lT.periapsis.altitude=fn.periapsis.altitude;lT.periapsis.speed=fn.periapsis.speed end;if fn.apoapsis~=nil then lT.apoapsis.altitude=fn.apoapsis.altitude;lT.apoapsis.speed=fn.apoapsis.speed end;lT.period=fn.period;lT.eccentricity=fn.eccentricity;lT.timeToApoapsis=fn.timeToApoapsis;lT.timeToPeriapsis=fn.timeToPeriapsis;lT.eccentricAnomaly=fn.eccentricAnomaly;lT.trueAnomaly=fn.trueAnomaly end;if lT.periapsis==nil then lT.periapsis={}lT.periapsis.altitude=-ku.radius;lT.periapsis.speed=a0 end;if lT.eccentricity==nil then lT.eccentricity=1 end;if lT.apoapsis==nil then lT.apoapsis={}lT.apoapsis.altitude=ci;lT.apoapsis.speed=0 end;if cL<1 then lT.apoapsis.altitude=ci;lT.apoapsis.speed=0 end;if lT.apoapsis.altitude then lR=(lT.apoapsis.altitude+lT.periapsis.altitude+ku.radius*2)/(lP*2)lQ=(ku.radius+lT.apoapsis.altitude)/lR*(1-lT.eccentricity)lS=lP-lT.periapsis.altitude/lR-ku.radius/lR;local m5=math.pi;if lT.period~=nil and lT.period>0 and lT.timeToApoapsis~=nil then m5=lT.eccentricAnomaly;if lT.timeToPeriapsis<lT.timeToApoapsis then m5=2*math.pi-m5 end end;if cL<1 or m5~=m5 then m5=math.pi end;local m6=-lP*math.cos(m5)+lK+m0+lN;local m7=lQ*math.sin(m5)+lL+l_+lN;local m8=""jV[#jV+1]='<g clip-path="url(#orbitRect)">'jV[#jV+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m8,lK+lM+lN,lL+lM*1.5/2+lN,lP,lQ)if lQ<1 then jV[#jV+1]=dn([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lK+lM+lN-lS,lL+lM*1.5/2+lN,m6,m7)end;jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lK+lM+lN-lS,lL+lM*1.5/2+lN,(ku.radius+ku.noAtmosphericDensityAltitude)/lR)jV[#jV+1]=dn('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lK+lM+lN-lS,lL+lM*1.5/2+lN,(ku.radius+ku.noAtmosphericDensityAltitude)/lR)jV[#jV+1]=dn([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lK+lM+lN,lL+lM*1.5/2+lN,lP,lQ)jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lK+lM+lN-lS,lL+lM*1.5/2+lN,ku.radius/lR)jV[#jV+1]='</g>'local m9=math.floor(ku.radius/lR+0.5)hA=lK+lM+lN*4+lP;hB=lL+lM*1.5/2+5+lN;if lT.apoapsis~=nil and lT.apoapsis.speed<a0 then lU("Apoapsis")end;hB=lL+lM*1.5/2+5+lN;hA=lK+lM-lN*2-lP;if lT.periapsis~=nil and lT.periapsis.speed<a0 and lT.periapsis.altitude>0 then lU("Periapsis")end;jV[#jV+1]=gG(lK+lM+lN,lL+20+lN,ku.name,"txtorbbig")jV[#jV+1]=dn('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m6,m7)jV[#jV+1]=[[</g>]]return jV else jV[#jV+1]='<g clip-path="url(#orbitRect)">'local ma=""local mb=1.2*(mc-md)/(lM*2)local me=1.4*(mf-mg)/(lM*1.5)for dO,dA in pairs(e[0])do if dA.center then local hA=lK+lM+dA.center.x/mb;local hB=lL+lM*1.5/2+dA.center.y/me;ma=ma..'<circle cx="'..hA..'" cy="'..hB..'" r="'..dA.radius/mb*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dA.name,"Moon")and not string.match(dA.name,"Sanctuary")and not string.match(dA.name,"Space")then ma=ma.."<text x='"..hA.."' y='"..hB+dA.radius/mb*30+20 .."' font-size='12' fill="..j0 .." text-anchor='middle' font-family='Montserrat'>"..dA.name.."</text>"end end end;local fp=vec3(bP.getWorldPosition())local hA=lK+lM+fp.x/mb;local hB=lL+lM*1.5/2+fp.y/me;ma=ma..'<circle cx="'..hA..'" cy="'..hB..'" r="2" stroke="white" stroke-width="1" fill="red"/>'ma=ma.."<text x='"..hA.."' y='"..hB-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iO=mb;iP=me;local mh=fp+cK*1000000;local mi=lK+lM+mh.x/mb;local jE=lL+lM*1.5/2+mh.y/me;ma=ma..'<line x1="'..hA..'" y1="'..hB..'" x2="'..mi..'" y2="'..jE..'" stroke="purple" stroke-width="1"/>'jV[#jV+1]=ma;jV[#jV+1]='</g>'end elseif bK=="INFO"then jV=cr.DrawOdometer(jV,j2,bp,j3)elseif bK=="SCOPE"then jV[#jV+1]='<g clip-path="url(#orbitRect)">'local mj=d5;local mk=vec3(DUSystem.getCameraWorldPos())local ml=vec3(DUSystem.getCameraWorldRight())local mm=vec3(DUSystem.getCameraWorldForward())if iC()==1 then mk=cO;ml=cI;mm=cH end;if ch>0 then table.sort(d4,function(eD,eE)local eF,eG=eD.center,eE.center;return(eF.x-mk.x)^2+(eF.y-mk.y)^2+(eF.z-mk.z)^2<(eG.x-mk.x)^2+(eG.y-mk.y)^2+(eG.z-mk.z)^2 end)end;local mn={}local mo={}local mp=120;local mq=nil;local mr=nil;for M,dA in ipairs(d4)do local gO=dA.center-mk;local ms=gO:len()local mt=gO:normalize()local mu=gO:cross(mm):normalize()local mv=math.acos(mu:dot(ml))if mv~=mv then mv=0 end;if mu:cross(ml):dot(mm)<0 then mv=-mv end;local mw=gO:project_on_plane(mm):len()local mx=math.sin(mv)*math.asin(mw/ms)*constants.rad2deg;local my=math.cos(mv)*math.asin(mw/ms)*constants.rad2deg;if mt:dot(mm)<0 then my=90*math.cos(mv)+90*math.cos(mv)-my;mx=90*math.sin(mv)+90*math.sin(mv)-mx end;local hA=m1+mx/mj*lY;local hB=m2+my/mj*lY;local mz=(hA-m1)*(hA-m1)+(hB-m2)*(hB-m2)local mA=math.asin((dA.radius+dA.surfaceMaxAltitude)/ms)*constants.rad2deg;if mA~=mA then mA=mj end;local hV=mA/mj*lY;local mB=math.asin(dA.atmosphereRadius/ms)*constants.rad2deg;if mB~=mB then mB=mA end;local mC=mB/mj*lY;local cb=iF(ms,1)local mD=dA.name;local mE=false;if hB>lL then if hB>m4 then if hB-mC<=m4 then mE=true end else mE=true end else if hB+mC>=lL then mE=true end end;local mF=false;local mG=hA;if dA.systemId==0 then mG=hA+mp else mG=hA-mp end;if mG+mp>lK then if mG+mp>m3 then if mG-mC-mp<=m3 then mF=true end else mF=true end else if mG+mC+mp>=lK then mF=true end end;local mH={}mH.x=hA;mH.y=hB;mH.planet=dA;mH.atmoSize=mC;if not mq or mz<mq then mq=mz;mr=mH end;if mF and mE then local mI=math.max(mC,5)if mz<mI*mI then mD=mD.." - "..cb end;mH.size=hV;mH.i=M;mH.displayString=mD;mH.distance=cb;mH.visible=true;mo[#mo+1]=mH else mH.visible=false end end;local mJ=false;table.sort(mo,function(eF,eG)return eF.y<eG.y end)for dO,fk in ipairs(mo)do local dA,hV,M,mC,hA,hB,mD,cb=fk.planet,fk.size,fk.i,fk.atmoSize,fk.x,fk.y,fk.displayString,fk.distance;local lW,mK,mL,mM;local mN=15;local jP="pdim"if dA.systemId~=0 then mL=j8(string.len(mD)*5)mN=-(15+mL)mM=j9(10)jP="pdimfill"else mL=j8(string.len(mD)*9)mM=j9(15)end;if hV*2>mL then lW=dp(hA,lK+mL/2,m3-mL/2)mK=dp(hB,lL+mM,m4-5)lW=dp(lW,hA-hV+mL/2,hA+hV-mL/2)mK=dp(mK,hB-hV+mM,hB+hV)else lW=hA+mN;mK=hB end;for mO,fk in pairs(mn)do local mP=fk.textPositions;local mQ=mP.y-mK;if mO~=M and f1(mQ)<mP.height and mP.x+mP.width>lW and mP.x<lW+mL then if hV>mL then mK=dp(mK+mM,lL+15,m4-5)else mK=mP.y+mP.height+1 end end end;local mR=mD~=dA.name or lW<=m1 and lW+mL>=m1 and mK-mM<=m2 and mK>=m2;fk.hovered=mR;local mS=1;if mR then mS=2;if hV*2<mL then mS=10 end;if mD==dA.name then mD=mD.." - "..cb end;jP="pbright"if dA.systemId~=0 then mL=j8(string.len(mD)*5)mN=-(15+mL)else mL=j8(string.len(mD)*7)end;if hV*2>mL then lW=dp(hA,lK+mL/2,m3-mL/2)lW=dp(lW,hA-hV+mL/2,hA+hV-mL/2)else lW=hA+mN end end;mn[M]={}mn[M].textPositions={}mn[M].textPositions.y=mK;mn[M].textPositions.x=lW;mn[M].textPositions.width=mL;mn[M].textPositions.height=mM;mn[M].output=""if hV*2>mL then jP=jP.." txtmid"else jP=jP.." txtstart"end;if mC-hV>2 then mn[M].output=dn('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hA,hB,mC,j1,0.1*mS)end;mn[M].output=mn[M].output..dn('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hA,hB,hV,j1,0.2*mS)if dA.systemId==0 then mn[M].output=mn[M].output..dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lW,mK,j0,jP,mD)if hV*2<=mL then mn[M].output=mn[M].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lW+mL,mK+2,lW,mK+2,hA,hB)end else mn[M].output=mn[M].output..dn([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lW,mK,j1,jP,mD)if hV*2<=mL then mn[M].output=mn[M].output..dn("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lW,mK+2,lW+mL,mK+2,hA,hB)end end end;for dO=#d4,1,-1 do if mn[dO]then jV[#jV+1]=mn[dO].output end end;if mr~=nil and d5<90 and not mr.hovered then local mT=mr.planet.atmosphereRadius/mr.atmoSize;local mU=dr(mq)*mT;local mV=iF(mU,1)local mL=j8(math.max(string.len(mV)*7,string.len(mr.planet.name)*7))local mM=j9(12)local lW=dp(mr.x+(m1-mr.x)/2,lK+mL/2,m3-mL/2)local mK=dp(mr.y+(m2-mr.y)/2,lL+mM*2,m4-5)jV[#jV+1]=dn("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mr.x,mr.y,m1,m2)jV[#jV+1]=dn([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lW,mK,"white",mV)if not mr.visible then jV[#jV+1]=dn([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lW,mK-mM,"white",mr.planet.name)end end;if cL>1 then local gO=cK;local mt=gO:normalize()local mw=gO:project_on_plane(mm):len()local mu=gO:cross(mm):normalize()local mv=math.acos(mu:dot(ml))if mv~=mv then mv=0 end;if mu:cross(ml):dot(mm)<0 then mv=-mv end;local mx=math.sin(mv)*math.asin(mw/gO:len())*constants.rad2deg;local my=math.cos(mv)*math.asin(mw/gO:len())*constants.rad2deg;if mt:dot(mm)<0 then my=90*math.cos(mv)+90*math.cos(mv)-my;mx=90*math.sin(mv)+90*math.sin(mv)-mx end;local hA=m1+mx/mj*lY;local hB=m2+my/mj*lY;local kS=14;local kT=kS/2;local kW=[[<circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT/kS..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hA..[["
                                    cy="]]..hB..[["
                                    r="]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hA-kS..[[,]]..hB..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA+kT..[[,]]..hB..[[ h ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hA..[[,]]..hB-kS..[[ v ]]..kT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jV[#jV+1]=kW end;jV[#jV+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m1,m2-10,m1,m2+10)jV[#jV+1]=dn("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m1-10,m2,m1+10,m2)jV[#jV+1]='</g>'else return jV end end;local function mW(mX,mY)local mZ;local m_=(mY-mX):normalize()local fq=(cO-mX):dot(m_)/m_:dot(m_)if fq<=0. then return(cO-mX):len(),nil elseif fq>=(mY-mX):len()then return(cO-mY):len(),nil end;local n0=mX+fq*m_;mZ=(n0-cO):len()return mZ,n0 end;local function n1()local mZ;local n2,n3=nil,nil;local n4=nil;local n5=nil;local n6=nil;for dO,n7 in pairs(e[0])do if n7.hasAtmosphere then local cb,n2=mW(ku.center,n7.center)if n4==nil or cb<n4 then n5=n7;n4=cb;n3=n2;n6=ku end;if c8 and c8.hasAtmosphere and c8.name~=ku.name then local eS,n2=mW(c8.center,n7.center)if eS<n4 then n5=n7;n4=eS;n3=n2;n6=c8 end end end end;if n3 then dg=n3;dh=n5.center end;local n8=j8(1770)local n9=j9(330)if n4 then local na="txttick "local nb=500000;if n4<n5.radius+nb or n4<n6.radius+nb then if cV then na="txttick red "else na="txttick orange "end end;mZ=iF(n4,2)iT=gG(n8,n9,"Pipe ("..n6.name.."--"..n5.name.."): "..mZ,na.."pbright txtmid")end end;local function nc(hA,hB,nd,ne,l4)local nf={x=hA,y=hB,width=nd,height=ne,label=l4}iN[l4]=nf;return nf end;local function ng(nh,ni,nd,ne,hA,hB,nj,nk,nl,nm,jP)local nf={enableName=nh,disableName=ni,width=nd,height=ne,x=hA,y=hB,toggleVar=nj,toggleFunction=nk,drawCondition=nl,hovered=false,class=jP}if nm then table.insert(iM,nf)else table.insert(iL,nf)end;return nf end;local function nn(no)if not iR then np=false;nq=false;nr=false;w=true;return elseif no=="handling"then np=not np;nq=false;nr=false elseif no=="hud"then nq=not nq;np=false;nr=false elseif no=="physics"then nr=not nr;np=false;nq=false end;if nr or nq or np then iS=iE(no)w=false else iS="none"w=true end end;local function ns()iR=not iR;if iR then iK=iM;dl("Tap LMB to see Settings")d6=w else iK=iL;dl("Tap LMB to see Control Buttons")nn()w=d6 end end;local function nt()local function nu(dA,dO)dA.set(not dA.get())if dA.get()then dl(dO.." set to true")else dl(dO.." set to false")end;if dO=="showHud"then d6=dA.get()elseif dO=="BrakeToggleDefault"then b0=k end end;local nv=50;local nw=340;local hA=ac/2-530;local hB=ad/2-330+nv/2;local nx=0;for dO,dA in pairs(iE("boolean"))do if type(dA.get())=="boolean"then ng(dO,dO,nw,nv,hA,hB,function()return dA.get()end,function()nu(dA,dO)end,function()return true end,true)hB=hB+nv+20;if nx==9 then hA=hA+nw+20;hB=ad/2-330+nv/2;nx=0 else if hA>ac/2-nw and hA<ac/2+nw/2 and hB>ad/2-nv and hB<ad/2+nv then hB=hB+nv+20;nx=nx+1 end;nx=nx+1 end end end;ng("Control View","Control View",nw,nv,10,ad/2-500,function()return true end,ns,function()return true end,true)ng("View Handling Settings",'Hide Handling Settings',nw,nv,10,ad/2-(500-nv),function()return np end,function()nn("handling")end,function()return true end,true)ng("View Hud Settings",'Hide Hud Settings',nw,nv,10,ad/2-(500-nv*2),function()return nq end,function()nn("hud")end,function()return true end,true)ng("View Physics Settings",'Hide Physics Settings',nw,nv,10,ad/2-(500-nv*3),function()return nr end,function()nn("physics")end,function()return true end,true)end;local function ny()local function gq()local fQ=cO;local gr=ku.name..". "..#br;if cu then gr=cu.GetClosestName(gr)end;return cs.AddNewLocation(gr,fQ,false,true)end;local function nz()b6=not b6 end;local function nA(nB)if nB==1 then b4=not b4;b3=false else b3=not b3;b4=false end;b5=false;b7=false;c0=false;b8=false;bv=nil;ba=false;b9=false end;local function nC(nD,nE)cs.UpdatePosition(nil,nD,nE)end;local function gl()cs.ClearCurrentPosition()end;local function nF(gp)local lI=ct.routeWP(true)if lI and#lI>0 then return"Engage Route: "..lI[1]end;return"Engage Autopilot: "..lG(gp)end;local function nG(gp)local lI=ct.routeWP(true)if lI and#lI>0 then return"Next Route Point: "..lI[1]end;return"Disable Autopilot: "..lG(gp)end;local function nH()if iA()==1 then c0=not c0;if c0 then b5=false;b3=false;b4=false;b7=false;ba=false;b8=false;b9=false;nI=bo;bo=false;d.control.retractLandingGears()iB:setTargetGroundAltitude(Y)fN("folOn","F")else fN("folOff","F")b2="Follow Off"cz=q;bo=nI;if bo then d.control.deployLandingGears()iB:setTargetGroundAltitude(Z)end end else dl("Follow Mode only works with Remote controller")c0=false end end;local nv=50;local nw=260;local nJ=j8(30)local nK=aB+aA*2+2;local nL=aC+1;ng("+","+",nJ,nJ,nK,nL+nJ+1,function()return false end,function()d5=d5/8 end,function()return bK=="SCOPE"end,nil,"ZoomButton")ng("-","-",nJ,nJ,nK,nL,function()return false end,function()d5=math.min(d5*8,90)end,function()return bK=="SCOPE"end,nil,"ZoomButton")ng("0","0",nJ,nJ,nK,nL+nJ*2+2,function()return false end,function()d5=90 end,function()return bK=="SCOPE"and d5~=90 end,nil,"ZoomButton")local nM=ng("Enable Brake Toggle","Disable Brake Toggle",nw,nv,ac/2-nw/2,ad/2+350,function()return b0 end,function()b0=not b0;if b0 then dl("Brakes in Toggle Mode")else dl("Brakes in Default Mode")end end)ng("Align Prograde","Disable Prograde",nw,nv,ac/2-nw/2-50-nM.width,ad/2-nv+380,function()return b4 end,function()nA(1)end)ng("Align Retrograde","Disable Retrograde",nw,nv,ac/2-nw/2+nM.width+50,ad/2-nv+380,function()return b3 end,nA,function()return ch==0 end)nN=ng(nF,nG,600,60,ac/2-600/2,ad/2-60/2-330,function()return b5 or bs or cd or bB end,function()end)local M;local function nO(nP)local gp=d1+nP;if gp>#cU then gp=gp-#cU-1 end;if gp<0 then gp=#cU+gp end;return gp end;nQ={}for M=0,10 do local nR=ng(function(eG)local gp=nO(eG.apExtraIndex)if b5 or bs or cd or bB then return"Redirect: "..lG(gp)end;return nF(gp)end,function(eG)local gp=nO(eG.apExtraIndex)return nG(gp)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eG)local gp=nO(eG.apExtraIndex)return gp==bn and(b5 or bs or cd or bB)end,function(eG)local gp=nO(eG.apExtraIndex)local nS=bn==gp;bn=gp;cs.UpdateAutopilotTarget()ct.ToggleAutopilot()if not nS and not(b5 or bs or cd or bB)then ct.ToggleAutopilot()end end,function()return d0 and(#ct.routeWP(true)==0 or M==0)end)nR.apExtraIndex=M;nQ[M]=nR end;ng("Save Position","Save Position",200,nN.height,nN.x+nN.width+30,nN.y,function()return false end,gq,function()return bn==0 or fZ==nil end)ng("Update Position","Update Position",200,nN.height,nN.x+nN.width+30,nN.y,function()return false end,function()nC(nil)end,function()return bn>0 and fZ~=nil end)ng("Save Heading","Clear Heading",200,nN.height,nN.x+nN.width+30,nN.y+nN.height+20,function()return fZ.heading~=nil end,function()if fZ.heading~=nil then nC(false)else nC(true)end end,function()return bn>0 and fZ~=nil end)ng("Save AGG Alt","Clear AGG Alt",200,nN.height,nN.x+nN.width+30,nN.y+nN.height*2+40,function()return fZ.agg~=nil end,function()if fZ.agg~=nil then nC(nil,false)else nC(nil,true)end end,function()return bn>0 and fZ~=nil and antigrav end)ng("Clear Position","Clear Position",200,nN.height,nN.x-200-30,nN.y,function()return true end,gl,function()return bn>0 and fZ~=nil end)ng("Save Route","Save Route",200,nN.height,nN.x-200-30,nN.y+nN.height*2+40,function()return false end,function()ct.routeWP(false,false,2)end,function()return#ct.routeWP(true)>0 end)ng("Load Route","Clear Route",200,nN.height,nN.x-200-30,nN.y+nN.height+20,function()return#ct.routeWP(true)>0 end,function()if#ct.routeWP(true)>0 then ct.routeWP(false,true)elseif b5 or bs then dl("Disable Autopilot before loading route")return else ct.routeWP(false,false,1)end end,function()return true end)nv=60;nw=300;local hA=0;local hB=ad/2-150;ng("Enable Check Damage","Disable Check Damage",nw,nv,hA,hB-nv-20,function()return s end,function()s=not s end)ng("View Settings","View Settings",nw,nv,hA,hB,function()return true end,ns)hB=hB+nv+20;ng("Enable Turn and Burn","Disable Turn and Burn",nw,nv,hA,hB,function()return b6 end,nz)hA=10;hB=ad/2-300;ng("Horizontal Takeoff Mode","Vertical Takeoff Mode",nw,nv,ac/2-nw/2,hB+20,function()return b1 end,function()b1=not b1;if b1 then dl("Vertical Takeoff Mode")else dl("Horizontal Takeoff Mode")end end,function()return cP end)hB=hB+nv+20;ng("Engage Orbiting","Cancel Orbiting",nw,nv,hA+nw+20,hB,function()return bB end,ct.ToggleIntoOrbit,function()return ch==0 and cY end)hB=ad/2-150;ng("Glide Re-Entry","Cancel Glide Re-Entry",nw,nv,hA+nw+20,hB,function()return ba end,function()cc=1;nA(1)end,function()return ku.hasAtmosphere and not cg end)hB=hB+nv+20;ng("Parachute Re-Entry","Cancel Parachute Re-Entry",nw,nv,hA+nw+20,hB,function()return ba end,function()cc=2;nA(1)end,function()return ku.hasAtmosphere and not cg end)hB=hB+nv+20;ng("Engage Follow Mode","Disable Follow Mode",nw,nv,hA,hB,function()return c0 end,nH,function()return iA()==1 end)ng("Enable Repair Arrows","Disable Repair Arrows",nw,nv,hA+nw+20,hB,function()return j6 end,function()j6=not j6;if j6 then dl("Repair Arrows Enabled")else dl("Repair Arrows Diabled")end end,function()return iA()==1 end)hB=hB+nv+20;if not r then ng("Enable AGG","Disable AGG",nw,nv,hA,hB,function()return cQ end,ct.ToggleAntigrav,function()return antigrav~=nil end)end;ng(function()return dn("Switch IPH Mode - Current: %s",bC)end,function()return dn("IPH Mode: %s",bC)end,nw*2,nv,hA,hB,function()return false end,function()if bC=="All"then bC="Custom Only"elseif bC=="Custom Only"then bC="No Moons-Asteroids"else bC="All"end;dl("IPH Mode: "..bC)end)hB=hB+nv+20;ng(function()return dn("Toggle Control Scheme - Current: %s",g)end,function()return dn("Control Scheme: %s",g)end,nw*2,nv,hA,hB,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;dl("New Control Scheme: "..g)end)local nT=j9(20)local nR=nc(0,0,j8(80),nT,"INFO")nR=nc(nR.x+nR.width,nR.y,j8(70),nT,"ORBIT")nR=nc(nR.x+nR.width,nR.y,j8(70),nT,"SCOPE")nc(nR.x+nR.width,nR.y,j8(70),nT,"HIDE")end;local nU={}local nV=nil;function nU.HUDPrologue(jV)if not cV then iY=ai;iZ=aj;i_=ak else iY=af;iZ=ag;i_=ah end;j0=[[rgb(]]..bN(iY+0.6)..","..bN(iZ+0.6)..","..bN(i_+0.6)..[[)]]j1=[[rgb(]]..bN(iY*0.8+0.5)..","..bN(iZ*0.8+0.5)..","..bN(i_*0.8+0.5)..[[)]]local nW=j0;local nX=j1;local nY=[[rgb(]]..bN(iY*0.4+0.5)..","..bN(iZ*0.4+0.5)..","..bN(i_*0.4+0.5)..[[)]]local nZ=j0;local n_=j1;local o0=nY;if ja()and not n then nW=[[rgb(]]..bN(iY*0.5+0.5)..","..bN(iZ*0.5+0.5)..","..bN(i_*0.5+0.5)..[[)]]nX=[[rgb(]]..bN(iY*0.3+0.5)..","..bN(iZ*0.3+0.5)..","..bN(i_*0.2+0.5)..[[)]]nY=[[rgb(]]..bN(iY*0.2+0.5)..","..bN(iZ*0.2+0.5)..","..bN(i_*0.2+0.5)..[[)]]end;local lu=j8;local lv=j9;jV[#jV+1]=dn([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nW,nW,nW,nZ,nZ,nX,nX,n_,n_,nX,nW,nY,n_,nW,nW,nY,nY,o0,nY,ac,ad,nX,nX,nX,nX,nX,nZ,nX,n_,o0,n_,n_,o0)if not nV then nV=dn([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lu(630),lv(0),lu(675),lv(45),lu(960),lv(55),lu(1245),lv(45),lu(1290),lv(0),lu(1000),lv(105),lu(1040),lv(59),lu(1250),lv(51),lu(1300),lv(0),lu(1920),lv(0),lu(1920),lv(20),lu(1400),lv(20),lu(1300),lv(105),lu(920),lv(105),lu(880),lv(59),lu(670),lv(51),lu(620),lv(0),lu(0),lv(0),lu(0),lv(20),lu(520),lv(20),lu(620),lv(105),lu(890),lv(59),lu(960),lv(62),lu(1030),lv(59),lu(985),lv(112),lu(1150),lv(112),lu(1100),lv(152),lu(820),lv(152),lu(780),lv(112),lu(935),lv(112),lu(890),lv(59),lu(960),lv(62),lu(1030),lv(59),lu(985),lv(112),lu(1150),lv(112),lu(1100),lv(152),lu(820),lv(152),lu(780),lv(112),lu(935),lv(112))end;if w and I then jV[#jV+1]=nV end;return jV end;function nU.DrawVerticalSpeed(jV,e6)jU(jV,e6)end;function nU.UpdateHud(jV)local kL=cS;local o1=cT;local k1=o1;local kh=kL;local l2=bN(c.getThrottle())local l7=cL*3.6;local l3=c.getAxisCommandValue(0)local o2=j8(1770)local o3=j9(310)if t and cR then l3=bR;l2=bR*100 end;local jc=jb()local k2="ROLL"if l2==nil then l2=0 end;if not cY then if cL>5 then kL=kK(cJ)o1=kM(cJ)else kL=0;o1=0 end;k2="YAW"end;if cW>50000 and not cg then local o4;o4=iF(cW)jV[#jV+1]=gG(o2,o3,"PvP Boundary: "..o4,"pbright txtbig txtmid")end;jV[#jV+1]=j4;jV[#jV+1]=i8;if iT~=""then jV[#jV+1]=iT end;if jd~=""then jV[#jV+1]=jd end;if je~=""then jV[#jV+1]=je end;jU(jV,ci)if iA()==0 or m then if not ja()or n then if cY then k0(jV,al,am,k1,k2,cY)kg(jV,kh,k1,al,am,cY,bN(kM(cJ)),cL)else k0(jV,al,am,o1,k2,cY)kg(jV,kL,o1,al,am,cY,bN(o1),cL)end;ko(jV,ci,cY)kN(jV,cJ,cL,al,am)end end;l1(jV,jc,l2,l3)l6(jV,l7)lb(jV)lJ(jV)if not iR and c1 then lH(jV)end;return jV end;function nU.HUDEpilogue(jV)jV[#jV+1]="</svg>"return jV end;function nU.ExtraData(jV)local o5=j8(1240)local o6=j9(55)local o7=o6+10;local o8;local lu=j8;local lv=j9;local o9=0;local jc=jb()if b1 then jc=jc.."-VERTICAL"end;if E and gR and not b9 and not b8 and cL>20 then jc=jc.."-COLLISION ON"end;if bE~="Off"then jc="("..bE..")-"..jc end;if b6 then jc="TB-"..jc end;if not bD then jc=jc.."-DeCoupled"end;if di then jc="Alignment Lock-"..jc end;local oa=lv(99)local ob=lv(80)local oc=lv(85)local od=lv(31)local oe=0;local of=0;local f6=cj>1000000 and fO(cj/1000000,2).."kT"or fO(cj/1000,2).."T"if cg then o9=bw else o9=bu end;local og,oh=cp.computeDistanceAndTime(cL,0,cj,0,0,o9)if og<0 then og=0 end;o9=fO(o9/(cj*iJ),2).."g"local oi=d:maxForceForward()o8=b.getGravityIntensity()if o8>0.1 then of=cj*o8;of=fO(of/(cj*iJ),2).."g"oe=0.5*oi/o8;oe=oe>1000000 and fO(oe/1000000,2).."kT"or fO(oe/1000,2).."T"end;oi=fO(oi/(cj*iJ),2).."g"local oj=vec3(bP.getWorldAcceleration()):len()/9.80665;o8=b.getGravityIntensity()jV[#jV+1]=[[<g class="dim txt txtend size14">]]if iA()==1 and not m then o5=j8(1120)o6=j9(55)o7=o6+10 elseif cg and I then local ok=j8(770)jV[#jV+1]=gG(lu(895),oa,"ATMO","")jV[#jV+1]=dn([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lu(895),oc,lu(-80))jV[#jV+1]=gG(lu(815),ob,dn("%.1f%%",ch*100),"txtstart size20")end;if I then jV[#jV+1]=gG(lu(1025),oa,"GRAVITY","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1025),oc,lu(80))jV[#jV+1]=gG(lu(1105),ob,dn("%.2fg",o8/9.80665),"size20")jV[#jV+1]=gG(lu(1125),oa,"ACCEL","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1125),oc,lu(80))jV[#jV+1]=gG(lu(1205),ob,dn("%.2fg",oj),"size20")jV[#jV+1]=gG(lu(695),oa,"BRK TIME","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(695),oc,lu(-80))jV[#jV+1]=gG(lu(615),ob,dn("%s",iG(oh)),"txtstart size20")jV[#jV+1]=gG(lu(635),lv(45),"TRIP","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(635),lv(31),lu(-90))if lr then jV[#jV+1]=gG(lu(545),lv(26),dn("%s",iG(lr)),"txtstart size20")end;jV[#jV+1]=gG(lu(795),oa,"BRK DIST","")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(795),oc,lu(-80))jV[#jV+1]=gG(lu(715),ob,dn("%s",iF(og)),"txtstart size20")jV[#jV+1]=gG(lu(1285),lv(45),"MASS","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1285),lv(31),lu(90))jV[#jV+1]=gG(lu(1375),lv(26),dn("%s",f6),"size20")jV[#jV+1]=gG(lu(1220),oa,"THRUST","txtstart")jV[#jV+1]=dn([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lu(1220),oc,lu(80))jV[#jV+1]=gG(lu(1300),ob,dn("%s",oi),"size20")jV[#jV+1]=gG(j8(960),j9(175),jc,"pbright txtbig txtmid size20")end;jV[#jV+1]="</g>"end;local ol=1-(a6*0.05+a7*0.05)function nU.FuelUsed(om)local on;if om=="atmofueltank"then on=dn("Atmo Fuel Used: %.1f L",jv[om]/(4*ol))elseif om=="spacefueltank"then on=dn("Space Fuel Used: %.1f L",jv[om]/(6*ol))else on=dn("Rocket Fuel Used: %.1f L",jv[om]/(0.8*ol))end;return on end;local oo,op,oq,os,ot=0,0,0,{},0;local ou=0;local ov=0;local ow=0;local ox=0;function nU.DrawOdometer(jV,j2,bp,j3)if bK~="INFO"then return jV end;local o8;local o9=0;local of=0;local f6=cj>1000000 and fO(cj/1000000,2).." kTons"or fO(cj/1000,2).." Tons"if cg then o9=bw else o9=bu end;local og,oh=cp.computeDistanceAndTime(cL,0,cj,0,0,o9)local oi=d:maxForceForward()o8=b.getGravityIntensity()if cL<5 and cf~=-1 then local oy=vec3(bP.getOrientationForward())local oz=bP.getMaxThrustAlongAxis('thrust analog longitudinal ',{oy:unpack()})ou=0.5*oz[1]/o8;ou=ou>1000000 and fO(ou/1000000,1).." kTons"or fO(ou/1000,1).." Tons"ov=0.5*oz[3]/o8;ov=ov>1000000 and fO(ov/1000000,1).." kTons"or fO(ov/1000,1).." Tons"oy=vec3(bP.getOrientationUp())oz=bP.getMaxThrustAlongAxis('hover_engine, booster_engine',{oy:unpack()})ow=0.5*oz[1]/o8;ow=ow>1000000 and fO(ow/1000000,1).." kTons"or fO(ow/1000,1).." Tons"ox=0.5*o9/o8;ox=ox>1000000 and fO(ox/1000000,1).." kTons"or fO(ox/1000,1).." Tons"end;o9=fO(o9/(cj*iJ),2).." g"if o8>0.1 then of=cj*o8;of=fO(of/(cj*iJ),2).." g"else of="n/a"end;oi=fO(oi/(cj*iJ),2).." g"if iA()==0 or m then local oA=j8(aB+10)local oB=j9(aC+20)local oC=j8(aB+10+aA/1.25)local ne=25;local oD=bN(1/aT)if oq<oD then ot=ot+a.getActionUpdateDeltaTime()oq=oq+1 else oo=1/(ot/oD)table.insert(os,oo)oq,ot=0,0 end;op=0;for dO,dA in pairs(os)do op=op+dA end;if#os>0 then op=bN(op/#os)end;if#os>29 then table.remove(os,1)end;jV[#jV+1]="<g class='txtstart size14 bright'>"jV[#jV+1]=gG(oA,oB,dn("BrkTime: %s",iG(oh)))jV[#jV+1]=gG(oC,oB,dn("Trip: %.2f km",j2))jV[#jV+1]=gG(oA,oB+ne,dn("Lifetime: %.2f kSU",bp/200000))jV[#jV+1]=gG(oC,oB+ne,dn("BrkDist: %s",iF(og)))jV[#jV+1]=gG(oA,oB+ne*2,"Trip Time: "..iG(j3))jV[#jV+1]=gG(oC,oB+ne*2,"Total Time: "..iG(bq))jV[#jV+1]=gG(oA,oB+ne*3,dn("Mass: %s",f6))jV[#jV+1]=gG(oC,oB+ne*3,dn("Safe Brake Mass: %s",ox))jV[#jV+1]=gG(oA,oB+ne*4,dn("Max Thrust: %s",oi))jV[#jV+1]=gG(oC,oB+ne*4,dn("Safe Atmo Mass: %s",ou))jV[#jV+1]=gG(oA,oB+ne*5,dn("Max Brake: %s",o9))jV[#jV+1]=gG(oC,oB+ne*5,dn("Safe Space Mass: %s",ov))jV[#jV+1]=gG(oC,oB+ne*6,dn("Safe Hover Mass: %s",ow))jV[#jV+1]=gG(oA,oB+ne*6,dn("Influence: %s",ku.name))jV[#jV+1]=gG(oA,oB+ne*7,dn("Set Max Speed: %s",bN(a0*3.6+0.5)))jV[#jV+1]=gG(oC,oB+ne*7,dn("Actual Max Speed: %s",bN(df*3.6+0.5)))jV[#jV+1]=gG(oA,oB+ne*8,dn("Friction Burn Speed: %s",bN(bP.getFrictionBurnSpeed()*3.6)))jV[#jV+1]=gG(oC,oB+ne*8,dn("FPS (Avg): %s (%s)",bN(oo),op))end;jV[#jV+1]="</g></g>"return jV end;function nU.DrawWarnings(jV)return lb(jV)end;function nU.DisplayOrbitScreen(jV)return lJ(jV)end;function nU.DisplayMessage(jV,lm)if lm~="empty"then local hB=310;for lo in string.gmatch(lm,"([^\n]+)")do hB=hB+35;jV[#jV+1]=gG("50%",hB,lo,"msg")end end;if c4~=0 then c.setTimer("msgTick",c4)c4=0 end end;function nU.DrawDeadZone(jV)jV[#jV+1]=dn([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nU.UpdatePipe()if cg then iT=""return end;n1()end;function nU.DrawSettings(jV)local hA=j8(640)local hB=j9(200)jV[#jV+1]=[[<g class="pbright txtvspd txtstart">]]local hR=0;for dO,dA in pairs(iS)do hR=hR+1;jV[#jV+1]=gG(hA,hB,dO..": "..dA.get())hB=hB+20;if hR%12==0 then hA=hA+j8(350)hB=j9(200)end end;jV[#jV+1]=gG(j8(640),j9(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jV[#jV+1]="</g>"return jV end;local i7=j9(125)local i6=j8(1225)function nU.DrawRadarInfo()i8=cu.GetRadarHud(i6,i7,ax,ay)if i8 then gR=true end end;function nU.DrawTanks()if at~=0 and au~=0 then jd=gG(at,au,"","txtstart pdim txtfuel")jw=au;jx(at,"Atmospheric ","ATMO",cl,jt,ju)jx(at,"Space Fuel T","SPACE",cm,jr,js)jx(at,"Rocket Fuel ","ROCKET",cn,jp,jq)end end;function nU.DrawShield()local ij=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oE=bP.getPvPTimer()local oF=shield.getResistances()local oG="A: "..10+oF[1]*100 .."% / E: "..10+oF[2]*100 .."% / K:"..10+oF[3]*100 .."% / T: "..10+oF[4]*100 .."%"local hA,hB=av-60,aw+30;local jN=bN(dj*2.55)local jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)local jP=""je=gG(hA,hB,"","txtmid pdim txtfuel")if dj<10 and ij~="Shield Disabled"then jP="red "end;oE=oE>0 and"   PvPTime: "..iG(oE)or""je=je..dn([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hA,hB,jO,dj*2,hA,hB,hA+2,hB+10,dj,oE)je=je..gG(hA,hB-5,ij,jP.."txtstart pbright txtbig")je=je..gG(hA,hB+30,oG,jP.."txtstart pbright txtsmall")end;function nU.hudtick()if not ku then return end;local function oH(jV)local jR=bN(dp(dd/(ac/4)*255,0,255))jV[#jV+1]=dn("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bN(iY+0.5)+jR,bN(iZ+0.5)-jR,bN(i_+0.5)-jR)end;local function oI()if c2 then for dT,dA in pairs(iK)do if dA.hovered then if not dA.drawCondition or dA.drawCondition(dA)then dA.toggleFunction(dA)end;dA.hovered=false end end;for dT,dA in pairs(iN)do if dA.hovered then bK=dA.label;dA.hovered=false end end;c2=false end end;local function oJ()local function oK(oL,oM,hA,hB,nd,ne)if oL>=hA and oL<=hA+nd and oM>=hB and oM<=hB+ne then return true else return false end end;local hA=c9+ac/2;local hB=ca+ad/2;for dT,dA in pairs(iK)do dA.hovered=oK(hA,hB,dA.x,dA.y,dA.width,dA.height)end;for dT,dA in pairs(iN)do dA.hovered=oK(hA,hB,dA.x,dA.y,dA.width,dA.height)end;if d0 then local mR=false;for dT,eG in ipairs(nQ)do if eG.hovered then mR=true;break end end;if nN.hovered then mR=true end;d0=mR else d0=nN.hovered;if not d0 then d1=bn end end end;local function oN(jV)if not bK or bK==""then bK="INFO"end;if w then for dO,dA in pairs(iN)do local jP="dim brightstroke"local oO=0.2;if bK==dO then jP="pbright dimstroke"oO=0.6 end;local oP=""if dA.hovered then oO=0.8;oP=";stroke:white"end;jV[#jV+1]=dn([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dA.width,dA.height,dA.x,dA.y,jP,oO,oP)jV[#jV+1]=gG(dA.x+dA.width/2,dA.y+dA.height/2+5,dA.label,"txt txtmid pdim")end end end;local function oQ(jV)local function oR(jV,oS,hover,hA,hB,oT,oU,oV,oW,oX,oY,nR)if type(oX)=="function"then oX=oX(nR)end;if type(oY)=="function"then oY=oY(nR)end;jV[#jV+1]=dn("<rect x='%f' y='%f' width='%f' height='%f' fill='",hA,hB,oT,oU)if oS then jV[#jV+1]=dn("%s'",oV)else jV[#jV+1]=oW end;if hover then jV[#jV+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jV[#jV+1]=dn(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fO(af*0.5,0),fO(ag*0.5,0),fO(ah*0.5,0))end;jV[#jV+1]=" rx='5'></rect>"jV[#jV+1]=dn("<text x='%f' y='%f' font-size='24' fill='",hA+oT/2,hB+oU/2+5)if oS then jV[#jV+1]="black"else jV[#jV+1]="white"end;jV[#jV+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oS then jV[#jV+1]=dn("%s</text>",oX)else jV[#jV+1]=dn("%s</text>",oY)end end;local oZ=dn("rgb(%d,%d,%d)'",fO(af*0.1,0),fO(ag*0.1,0),fO(ah*0.1,0))local o_=dn("rgb(%d,%d,%d)",fO(af*0.8,0),fO(ag*0.8,0),fO(ah*0.8,0))local p0=oR;for dT,dA in pairs(iK)do local ni=dA.disableName;local nh=dA.enableName;if type(ni)=="function"then ni=ni(dA)end;if type(nh)=="function"then nh=nh(dA)end;if not dA.drawCondition or dA.drawCondition(dA)then p0(jV,dA.toggleVar(dA),dA.hovered,dA.x,dA.y,dA.width,dA.height,o_,oZ,ni,nh,dA)end end end;local p1=fO(ac/2,0)local p2=fO(ad/2,0)local jV={}if p3 then jV[#jV+1]=p3 end;cr.HUDPrologue(jV)if w then cr.UpdateHud(jV)else if A then cr.DrawVerticalSpeed(jV,ci)end;cr.DrawWarnings(jV)end;if iR and iS~="none"then cr.DrawSettings(jV)end;if cu then cr.DrawRadarInfo()else i8=""end;cr.HUDEpilogue(jV)jV[#jV+1]=dn([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c3~="empty"then cr.DisplayMessage(jV,c3)end;if iA()==0 and g=="virtual joystick"then if v then cr.DrawDeadZone(jV)end end;oN(jV)if iC()==0 then if iA()==1 and c1 then if not p4 then oJ()oQ(jV)end;if not cx and not cy then local p5=table.concat(jV,"")jV={}jV[#jV+1]=dn("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jV[#jV+1]=p5;jV[#jV+1]="</body>"cx=true;jV[#jV+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cy then local p5=table.concat(jV,"")jV={}jV[#jV+1]=dn("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jV[#jV+1]=p5;jV[#jV+1]="</body>"end;if not cx then jV[#jV+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end else oI()end else if not c1 and iA()==0 then oI()if dd>az then if v then oH(jV)end end elseif c1 and(not p4 or not j)then oJ()oQ(jV)end;jV[#jV+1]=dn([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c9,ca)end;jV[#jV+1]=[[</svg></body>]]p6=table.concat(jV,"")end;function nU.TenthTick()local function p7()local p8=a.createData;local p9=a.createWidget;pa=a.createWidgetPanel("Interplanetary Helper")pb=p9(pa,"value")pc=p8('{"label": "Target Planet", "value": "N/A", "unit":""}')fM(pc,pb)pd=p9(pa,"value")pe=p8('{"label": "distance", "value": "N/A", "unit":""}')fM(pe,pd)gf=p9(pa,"value")ge=p8('{"label": "Travel Time", "value": "N/A", "unit":""}')fM(ge,gf)gh=p9(pa,"value")gg=p8('{"label": "Target Altitude", "value": "N/A", "unit":""}')fM(gg,gh)pf=p9(pa,"value")pg=p8('{"label": "Space Engine", "value": "N/A", "unit":""}')fM(pg,pf)ph=p9(pa,"value")pi=p8('{"label": "End Speed", "value": "N/A", "unit":""}')g9=p9(pa,"value")g8=p8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g7=p9(pa,"value")g6=p8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g5=p9(pa,"value")g4=p8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g3=p9(pa,"value")g2=p8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gb=p9(pa,"value")ga=p8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cg then fM(pi,ph)fM(g8,g9)fM(g6,g7)fM(g4,g5)fM(g2,g3)fM(ga,gb)end end;local function pj()gF(pa)pa=nil end;cr.DrawTanks()if shield then cr.DrawShield()end;if bl~="None"then if pa==nil then p7()end;if bl~=nil then local ms;local pk=fZ~=nil;local pl=b5 and bh*3.6 or 0;fL(pc,'{"label": "Target", "value": "'..bl..'", "unit":""}')if pk and not b5 then ms=(cO-fZ.position):len()else ms=(bm-cO):len()end;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(cL)iV,iW=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(cL)iV,iW=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local lm=iF(ms)fL(pe,'{"label": "distance", "value": "'..lm..'"}')fL(ge,'{"label": "Travel Time", "value": "'..iG(lr)..'", "unit":""}')lm=iF(c6)fL(g8,'{"label": "Cur Brake distance", "value": "'..lm..'"}')fL(g6,'{"label": "Cur Brake Time", "value": "'..iG(c7)..'", "unit":""}')lm=iF(iV)fL(g4,'{"label": "Max Brake distance", "value": "'..lm..'"}')fL(g2,'{"label": "Max Brake Time", "value": "'..iG(iW)..'", "unit":""}')fL(pi,'{"label": "End Speed", "value": "'..dn("%.0fkph",pl)..'", "unit":""}')lm=iF(gi)fL(gg,'{"label": "High Orbit", "value": "'..lm..'"}')fL(pg,'{"label": "Space Engine Alt", "value": "'..c8.spaceEngineMinAltitude..'m"}')if cg and not pm then a.removeDataFromWidget(g2,g3)a.removeDataFromWidget(pi,ph)a.removeDataFromWidget(g4,g5)a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)pm=true;if not cR and t and(b7 or ba or ce)then ct.cmdThrottle(1)b2=false;bV=false end end;if not cg and pm then if fL(g2,g3)==1 then fM(g2,g3)end;if fL(g2,ph)==1 then fM(pi,ph)end;if fL(g4,g5)==1 then fM(g4,g5)end;if fL(g6,g7)==1 then fM(g6,g7)end;if fL(g8,g9)==1 then fM(g8,g9)end;if fL(ga,gb)==1 then fM(ga,gb)end;pm=false end end else pj()end;if warpdrive~=nil then local pn=iy(warpdrive.getWidgetData())if pn.destination~="Unknown"and pn.distance>400000 then if not j7 then warpdrive.showWidget()j7=true end elseif j7 then warpdrive.hideWidget()j7=false end end end;function nU.OneSecondTick()local function po()local jH=bM()local l7=cL;local pp=jH-j5;if l7>1.38889 then l7=l7/1000;local pq=l7*(jH-j5)bp=bp+pq;j2=j2+pq end;j3=j3+pp;bq=bq+pp;j5=jH end;local function pr(jV)local ps=0;local pt=iI;local pu=0;local pv=0;local pw=0;local jN=0;local jO=""local px=b.getElementHitPointsById;local py=b.getElementMaxHitPointsById;local pz={}for dO in pairs(iH)do local pA=0;local pB=0;pB=py(iH[dO])pA=px(iH[dO])pu=pu+pA;if pA+1<pB then if pA==0 then pw=pw+1 else pv=pv+1 end;if j6 and#pz==0 then fQ=vec3(b.getElementPositionById(iH[dO]))local hA=fQ.x;local hB=fQ.y;local hC=fQ.z;table.insert(pz,b.spawnArrowSticker(hA,hB,hC+1,"down"))table.insert(pz,b.spawnArrowSticker(hA,hB,hC+1,"down"))b.rotateSticker(pz[2],0,0,90)table.insert(pz,b.spawnArrowSticker(hA+1,hB,hC,"north"))table.insert(pz,b.spawnArrowSticker(hA+1,hB,hC,"north"))b.rotateSticker(pz[4],90,90,0)table.insert(pz,b.spawnArrowSticker(hA-1,hB,hC,"south"))table.insert(pz,b.spawnArrowSticker(hA-1,hB,hC,"south"))b.rotateSticker(pz[6],90,-90,0)table.insert(pz,b.spawnArrowSticker(hA,hB-1,hC,"east"))table.insert(pz,b.spawnArrowSticker(hA,hB-1,hC,"east"))b.rotateSticker(pz[8],90,0,90)table.insert(pz,b.spawnArrowSticker(hA,hB+1,hC,"west"))table.insert(pz,b.spawnArrowSticker(hA,hB+1,hC,"west"))b.rotateSticker(pz[10],-90,0,90)table.insert(pz,iH[dO])end elseif j6 and#pz>0 and pz[11]==iH[dO]then for jG in pairs(pz)do b.deleteSticker(pz[jG])end;pz={}end end;ps=fO(pu/pt*100,2)if pw>0 or pv>0 then jV[#jV+1]=gG(0,0,"","pbright txt")jN=bN(ps*2.55)jO=dn("rgb(%d,%d,%d)",255-jN,jN,0)jV[#jV+1]=gG("50%",1035,"Elemental Integrity: "..ps.."%","txtbig txtmid","fill:"..jO)if pw>0 then jV[#jV+1]=gG("50%",1055,"Disabled Modules: "..pw.." Damaged Modules: "..pv,"txtbig txtmid","fill:"..jO)elseif pv>0 then jV[#jV+1]=gG("50%",1055,"Damaged Modules: "..pv,"txtbig txtmid","fill:"..jO)end end end;local function pC()if ix then if iX==nil and(he~=nil or bo)then _autoconf.displayCategoryPanel(ix,weapon_size,"Weapons","weapon",true)iX=_autoconf.panels[_autoconf.panels_size]elseif iX~=nil and he==nil and not bo then gF(iX)iX=nil end end end;local jV={}po()if s then pr(jV)end;pC()cr.UpdatePipe()cr.ExtraData(jV)j4=table.concat(jV,"")end;function nU.AnimateTick()cy=true;cx=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nU.MsgTick()local jV={}cr.DisplayMessage(jV,"empty")c3="empty"c.stopTimer("msgTick")c4=3 end;function nU.ButtonSetup()nt()ny()iK=iL end;if pD then for dO,dA in pairs(pD)do nU[dO]=dA end end;return nU end;local function pE(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,f1,bN,bO,iA,eX,bM,dp,iB,fL,iC,dr,fO,fN,iD,ds,iF,iG,pG,iy,dl)local a=DUSystem;local bP=DUConstruct;local pH={}local pI=false;local pJ=0;local pK=0;local pL=0;local pM=bM()local pN=0;local pO=0;local pP=0;local pQ=0;local pR=false;local pS=false;local pT=false;local pU=nil;local pV=0;local iU=55;local pW=nil;local pX=false;local pY=false;local pZ=false;local p_=0;local q0=0;local q1=0;local q2=0;local q3=0;local q4={VectorToTarget=false}local q5=vec3(bP.getWorldOrientationUp())local q6=nil;local q7=0;local q8=-1;local q9=-1;local qa=false;local qb=false;local qc=0;local qd=false;local qe=false;local qf=false;local qg=false;local qh=""local qi=false;local qj=false;local qk=""local ql=false;local qm=0;local qn=0;local function qo()return bP.isInPvPZone()~=1,f1(bP.getDistanceToSafeZone())end;local function qp(kj)local qq=bh;if not b5 then qq=0 end;local qr=bu;if cg then if bw and bw>0 then qr=bw else return 0,0 end end;return cp.computeDistanceAndTime(kj,qq,cj,0,0,qr-bj*cj)end;local function qs(kj)local qq=bh;if not b5 then qq=0 end;return cp.computeDistanceAndTime(kj,qq,cj,d:maxForceForward(),a2,bu-bj*cj)end;local function qt(qu,qv,qw)qv=qv:project_on_plane(qu)qw=qw:project_on_plane(qu)return eX(qv:cross(qw):dot(qu),qv:dot(qw))end;local qx=-1;local qy=-1;local function qz()local function qA()local qB=-1;local qC=-1;if vBooster then qB=vBooster.getDistance()if qB>-1 and qB<0.01 then qB=qx else qx=qB end end;if hover then qC=hover.getDistance()if qC>-1 and qC<0.01 then qC=qy else qy=qC end end;if qB~=-1 and qC~=-1 then if qB<qC then return qB else return qC end elseif qB~=-1 then return qB elseif qC~=-1 then return qC else return-1 end end;local qD=qA()local qE=-1;if antigrav and antigrav.isActive()==1 and not r and cL<iU then local qF=f1(ci-antigrav.getBaseAltitude())if qF<50 then return qF end end;if pF then qE=pF.raycast().distance;if qE==0 then qE=-1 end end;if qD~=-1 and qE~=-1 then if qD<qE then return qD else return qE end elseif qD~=-1 then return qD else return qE end end;local function qG(ku,eO,qH)local function qI(qJ,d_)local eU=vec3(d_)if qJ.id==0 then return setmetatable({latitude=eU.x,longitude=eU.y,altitude=eU.z,id=0,systemId=qJ.systemId},e1)end;local eV=eU-qJ.center;local cb=eV:len()local e6=cb-qJ.radius;local e4=0;local e5=0;if not ds(cb,0)then local eW=eX(eV.y,eV.x)e5=eW>=0 and eW or 2*math.pi+eW;e4=math.pi/2-math.acos(eV.z/cb)end;return setmetatable({latitude=math.deg(e4),longitude=math.deg(e5),altitude=e6,id=qJ.id,systemId=qJ.systemId},e1)end;local qK=qI(ku,eO)qK="::pos{"..qK.systemId..","..qK.id..","..qK.latitude..","..qK.longitude..","..qK.altitude.."}"if qH then return qK else qf=qK;return true end end;local function qL(qM,qN,qO)local function qP(qM,ex)qM=vec3(qM)ex=vec3(ex):normalize()local dJ=qM*ex;return dJ.x+dJ.y+dJ.z end;local qQ=0.001;local qR=1;if not cg or not cA or cf~=-1 or cL<iU then if qO==nil then qO=aS end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=vec3()-qM;local qT=-qP(qS,bP.getWorldOrientationRight())*qR;local qU=-qP(qS,bP.getWorldOrientationUp())*qR;if pK==0 then pK=qT/2 end;if pL==0 then pL=qU/2 end;if f1(qT)<0.1 then q0=q0-qT*2 else q0=q0-(qT+(qT-pK)*qO)end;if f1(qU)<0.1 then p_=p_+qU*2 else p_=p_+qU+(qU-pL)*qO end;pK=qT;pL=qU;if f1(qT)<qN and f1(qU)<qN then return true end;return false elseif cA and cf==-1 then qM=cK;if qO==nil then qO=aS end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=cH-qM;local qT=-qP(qS,bP.getWorldOrientationRight())*qR;local qU=-qP(qS,bP.getWorldOrientationUp())*qR;if pK==0 then pK=qT/2 end;if pL==0 then pL=qU/2 end;if f1(qT)<0.1 then q0=q0-qT*5 else q0=q0-(qT+(qT-pK)*qO)end;if f1(qU)<0.1 then p_=p_+qU*5 else p_=p_+qU+(qU-pL)*qO end;pK=qT;pL=qU;if f1(qT)<qN and f1(qU)<qN then return true end;return false end end;function pH.clearAll()bd=false;bf=false;bg=false;b5=false;be=false;bi="Aligning"b3=false;b4=false;cX=nil;b7=false;ba=false;b8=false;b9=false;bb=false;c0=false;pY=false;cc=false;cd=false;pZ=false;cz=q;bs=false;b6=false;ck=false;bv=nil;bB=false;db=false;dc=nil;ce=false end;function pH.GetAutopilotBrakeDistanceAndTime(kj)return qp(kj)end;function pH.GetAutopilotTBBrakeDistanceAndTime(kj)return qs(kj)end;function pH.showWayPoint(ku,eO,qH)return qG(ku,eO,qH)end;function pH.APTick()local qV=a.getMouseWheel()if qV>0 then ct.changeSpd()elseif qV<0 then ct.changeSpd(true)else pX=true end;qc=iC()if qf then a.setWaypoint(qf)qf=false end;if qi then antigrav.setTargetAltitude(qi)qi=false end;if qg then fL(qg,qh)qg=false;qh=""end;if q9~=-1 then ct.cmdCruise(q9,qa)qa=false;q9=-1 end;if q6~=nil then if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iB:getTargetSpeed(axisCommandId.longitudinal)~=q6 then iB:setTargetSpeedCommand(axisCommandId.longitudinal,q6)else q6=nil end end;if q8~=-1 then ct.cmdThrottle(q8,qa)qa=false;q8=-1 end;if qb then cv.landingGear(qb)qb=false end;if qj then ct.ToggleAutopilot()end end;function pH.ToggleIntoOrbit()cE=false;pP=nil;pQ=nil;pV=0;pS=false;if not cg then if bB then fN("orOff","AP")bB=false;pR=false;pU=nil;cz=q;if b7 then b7=false;b9=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false elseif cY then fN("orOn","AP")bB=true;cz=true;if pU==nil then pU=ku end;if b7 then b7=false;b9=false end else dl("Unable to engage auto-orbit, not near a planet")end else bB=false;pR=false;pU=nil;cz=q;if b7 then b7=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false end end;function pH.ToggleVerticalTakeoff()b7=false;if bb then qW=true;ba=false;b9=false;b8=true;cz=true;b_=0;if cg and cf==-1 then b8=false;b7=true;b_=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q9=bN(cB)end else cE=false;bo=false;d.control.retractLandingGears()iB:setTargetGroundAltitude(Y)b2="VTO Takeoff"end;bb=not bb end;function pH.checkLOS(qM)local lp,eM,eN=co:getPlanetarySystem(0):castIntersections(cO,qM,function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)local lq=eM;if eN~=nil and eM~=nil then lq=math.min(eN,eM)end;if lq~=nil then return lp,lq else return nil,nil end end;local function qX(qY,qZ)if qZ then b_=0;iB:updateCommandFromActionStop(axisCommandId.vertical,qZ)if bD then iB:activateGroundEngineAltitudeStabilization(q_)de=true end else b_=b_+qY;iB:deactivateGroundEngineAltitudeStabilization()iB:updateCommandFromActionStart(axisCommandId.vertical,qY)end end;function pH.vertical(qY,qZ)qX(qY,qZ)end;function pH.ToggleAutopilot()local function r0(bz)cZ=false;bs=not bs;if bs then b6=false;if not b7 and not bz then ct.ToggleAltitudeHold()end end;lt="Proceeding to Waypoint"end;local function r1(gr)if gr then for M,dO in pairs(cU)do if dO.name and dO.name==gr then return M end end else return 0 end end;local r2=false;if bQ-pO<1.5 and cg then if not cG then if cg then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude;fN("11","EP")pO=-1;if b5 or bs or bB then return end else dl("No space engines detected, Orbital Hop not supported")return end elseif ku.hasAtmosphere then if cg then bc=ku.noAtmosphericDensityAltitude+U;fN("orH","OH")end;pO=-1;if b5 or bs or bB then return end end else pO=bQ end;r3=false;di=false;if(bn>0 or#bH>0)and not b5 and not bs and not cd and not bB then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cj then dl("WARNING: Heavy Loads may affect autopilot performance.")end;if#bH>0 and not ce then bn=r1(bH[1])cs.UpdateAutopilotTarget()dl("Route Autopilot in Progress")local qS=fZ.position-cO;local r4=qS:project_on_plane(cM):len()if r4>50000 and fZ.planetname==ku.name then r2=true end end;cs.UpdateAutopilotTarget()ct.showWayPoint(c8,bm)if fZ~=nil then if fZ.agg and not r and antigrav then if not cQ then ct.ToggleAntigrav()end;bx=fZ.agg end;bv=nil;bz=fZ.planetname=="Space"if bz then fN("apSpc","AP")if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end elseif ku.name==fZ.planetname then qW=true;if cg then if not bs then fN("vtt","AP")r0(bz)if r2 then bc=ku.noAtmosphericDensityAltitude+U end end else fN("apOn","AP")if not(c8.name==ku.name and ci<gi*1.5)then cE=false;b5=true elseif not cg then if bB then ct.ToggleIntoOrbit()end;cD=(ku.noAtmosphericDensityAltitude>0 and ku.noAtmosphericDensityAltitude or ku.surfaceMaxAltitude)+U;pT=true;q4.AutopilotAlign=true;q4.VectorToTarget=true;pR=false;if not bB then ct.ToggleIntoOrbit()end end end else fN("apP","AP")b3=false;b4=false;if cg then cd=true;ct.ToggleAltitudeHold()else b5=true end end elseif not cg then if fZ==nil and(c8.name==ku.name and cY)and not bB then r5=false;cE=false;pR=false;cD=(ku.noAtmosphericDensityAltitude>0 and ku.noAtmosphericDensityAltitude or ku.surfaceMaxAltitude)+U;pT=true;ct.ToggleIntoOrbit()else fN("apP","AP")b5=true;b3=false;b4=false;be=false;c0=false;b7=false;b8=false;ba=false;b9=false;pY=false;bv=nil;r5=false end else fN("apP","AP")cd=true;ct.ToggleAltitudeHold()end;qj=false else fN("apOff","AP")ct.ResetAutopilots(1)if qj==2 then qj=true end end end;function pH.routeWP(r6,r7,r8)if r8 then if r8==1 then bH={}bH=iD(bH,bG)if#bH>0 then dl("Route Loaded")else dl("No Saved Route found on Databank")end;return bH else bG={}bG=iD(bG,bH)dl("Route Saved")pG()return end end;if r6 then return bH end;if r7 then bH={}dl("Current Route Cleared")else bH[#bH+1]=fZ.name;dl("Added "..fZ.name.." to route. ")end;return bH end;function pH.cmdThrottle(dP,r9)if iB:getAxisCommandType(0)~=axisCommandType.byThrottle and not r9 then d.control.cancelCurrentControlMasterMode()end;iB:setThrottleCommand(axisCommandId.longitudinal,dP)bR=dp(fO(dP*100,0)/100,-1,1)q6=nil end;function pH.cmdCruise(dP,r9)if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r9 then d.control.cancelCurrentControlMasterMode()end;iB:setTargetSpeedCommand(axisCommandId.longitudinal,dP)q6=dP end;function pH.ToggleLockPitch()if bv==nil then fN("lkPOn","LP")if not c1 then bv=cS else bv=ra end;b9=false;b7=false;b8=false else fN("lkPOff","LP")bv=nil end end;function pH.ToggleAltitudeHold()if bQ-pN<1.5 then if ku.hasAtmosphere then if cg then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude;fN("11","EP")else if cY then bc=ku.noAtmosphericDensityAltitude+U;cD=bc;pT=true;if not bB then ct.ToggleIntoOrbit()end;pR=true end end;pN=-1;if b7 or bB or bb then return end end else pN=bQ end;if cY and not cg and cf==-1 then cD=ci;pT=true;pR=true;ct.ToggleIntoOrbit()if bB then pN=bQ else pN=0 end;return end;b7=not b7;b8=false;ba=false;di=false;if b7 then b5=false;b4=false;b3=false;c0=false;cz=true;bv=nil;cE=false;if cf~=-1 then if cL<20 then if bo then cv.landingGear()end;fN("lfs","LS")b9=true;if cg then bc=ci+X else bc=ku.surfaceMaxAltitude+100 end;b2="ATO Hold"iB:setTargetGroundAltitude(Y)if b1 and cP then ct.ToggleVerticalTakeoff()end end else fN("altOn","AH")b9=false;if pN>-1 then if cY then bc=ci end end;if bb then ct.ToggleVerticalTakeoff()end end;if cQ and not r then local rb=antigrav.getBaseAltitude()if bs and fZ.agg and fZ.agg>ci then bc=fZ.agg elseif b9 then bc=rb end;if f1(ci-rb)<100 and cL<20 then bc=rb;b2="AGG Hold"q8=0 end end;if cd then bc=200000 end else fN("altOff","AH")if bB then ct.ToggleIntoOrbit()end;if bb then ct.ToggleVerticalTakeoff()end;cz=q;b9=false;bs=false;pN=0 end end;function pH.ResetAutopilots(pH)if pH then cd=false;b5=false;be=false;pY=false;bc=ci;r3=false;db=false;bi="Aligning"end;bs=false;b9=false;ba=false;di=false;b4=false;b8=false;dc=nil;rc=false;cX=nil;db=false;if not cQ then b7=false;bv=nil end;if bb then ct.ToggleVerticalTakeoff()end;if bB then ct.ToggleIntoOrbit()end;cz=q;cc=false;ce=false;b_=0 end;function pH.BrakeToggle(rd)if not b2 then if rd then b2=rd else b2=true end else b2=false end;if b8 then b8=false;cz=q;db=false end;if b2 then fN("bkOn","B",1)ct.ResetAutopilots()else fN("bkOff","B",1)end end;function pH.BeginReentry()if ba then dl("Re-Entry cancelled")fN("reOff","RE")ba=false;cz=q;b7=false elseif not ku.hasAtmosphere then dl("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")c4=5 elseif not pZ then ba=true;if iB:getAxisCommandType(0)~=re.cruise then d.control.cancelCurrentControlMasterMode()end;cz=true;b2=false;dl("Beginning Parachute Re-Entry - Strap In.  Target speed: "..cB)fN("par","RE")else ba=true;b7=true;cz=true;b2=false;bc=ku.surfaceMaxAltitude+_;if bc>ku.spaceEngineMinAltitude then bc=ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude end;local rf=iF(bc)dl("Beginning Re-entry.  Target speed: "..cB.." Target Altitude: "..rf)fN("glide","RE")q9=bN(cB)end;b9=false end;function pH.ToggleAntigrav()if antigrav and not r then if cQ then fN("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bx==nil then bx=ci end;if bx<1000 then bx=1000 end;fN("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pH.changeSpd(rg)local rh=1;if rg then rh=-1 end;if not c1 then if t and not p4 and pX then local ri=bR;bR=fO(dp(bR+rh*aE/100,-1,1),2)if bR>=0 and ri<0 then bR=0;pX=false end elseif p4 then if cg or ba then cB=dp(cB+rh*aE,0,V)elseif b5 then a0=dp(a0+rh*aE/3.6*100,0,df-0.2)end else iB:updateCommandFromActionStart(axisCommandId.longitudinal,rh*aE/10)end else if b5 or bs or cd or bB then d1=d1+1*rh*-1;if d1>#cU then d1=1 end;if d1<1 then d1=#cU end else if not rg then rh=1 else rh=nil end;cs.adjustAutopilotTargetIndex(rh)end end end;function pH.TenthTick()local function rj()if not b5 then if fZ==nil or fZ.planetname~=ku.name then rk=(c8.center-cO):len()else rk=(fZ.position-cO):len()end end;local kj=cL;local rl=c.getThrottle()/100;if t then rl=bR end;local rm,rn=cp.computeDistanceAndTime(cL,a0,cj,d:maxForceForward()*rl,a2,0)local c6,c7;if not b6 then c6,c7=ct.GetAutopilotBrakeDistanceAndTime(a0)else c6,c7=ct.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dT,ro;if not b6 and kj>0 then dT,ro=ct.GetAutopilotBrakeDistanceAndTime(kj)else dT,ro=ct.GetAutopilotTBBrakeDistanceAndTime(kj)end;local rp=0;local rq=0;if bg or not b5 and kj>5 then rq=cp.computeTravelTime(kj,0,rk)elseif c6+rm<rk then rp=rk-(c6+rm)rq=cp.computeTravelTime(a0,0,rp)else local rr=(rk-c6)/rm;rm=rk-c6;rn=rn*rr end;if fZ~=nil and fZ.planetname==ku.name and not b5 then return rq elseif bf then return ro elseif bg then return rq+ro else return rn+c7+rq end end;local function rs()local o8=b.getGravityIntensity()o8=fO(o8,5)if pW==nil or pW~=o8 then local kj=cJ:len()local rt=bP.getMaxBrake()if rt~=nil and rt>0 and cg then rt=rt/dp(kj/100,0.1,1)rt=rt/ch;if ch>0.10 then bw=rt end end;if rt~=nil and rt>0 then bu=rt end;pW=o8 end end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()qn=0;for M=1,#d3 do qn=qn+bP.getDockedConstructMass(d3[M])end;local ru=0;for M=1,#d2 do ru=ru+bP.getBoardedPlayerMass(d2[M])end;if ru>20000 then qn=qn+ru-20000 end;cV,cW=qo()df=bP.getMaxSpeed()if bl~="None"and(c8 or fZ)then lr=rj()end;rs()end;local rv=pid.new(10,0,10.0)local function rw(rx,ry)local oy=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oy=vec3(bP.getOrientationForward())rz=cH elseif rx==axisCommandId.vertical then oy=vec3(bP.getOrientationUp())rz=q5 elseif rx==axisCommandId.lateral then oy=vec3(bP.getOrientationRight())rz=cI else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bP.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cJ:dot(oy)local rF=ry*constants.kph2m;rv:inject(rF-rE)local rG=rv:get()local rH=(rG-rD-rB)*rz;return rH end;local rI=pid.new(10,0,10.0)local function rJ(rx,ry)local oy=vec3()local rz=vec3()if rx==axisCommandId.longitudinal then oy=vec3(bP.getOrientationForward())rz=cH elseif rx==axisCommandId.vertical then oy=vec3(bP.getOrientationUp())rz=q5 elseif rx==axisCommandId.lateral then oy=vec3(bP.getOrientationRight())rz=cI else return vec3()end;local rA=vec3(b.getWorldGravity())local rB=rA:dot(rz)local rC=vec3(bP.getWorldAirFrictionAcceleration())local rD=rC:dot(rz)local rE=cJ:dot(oy)local rF=ry*constants.kph2m;rI:inject(rF-rE)local rG=rI:get()local rH=(rG-rD-rB)*rz;return rH end;local function rK(rL,jY,fV)local rM=rL:cross(fV):normalize_inplace()local kL=math.acos(dp(rM:dot(-jY),-1,1))*constants.rad2deg;if rM:cross(-jY):dot(fV)<0 then kL=-kL end;return kL end;local function rN()if c_ and not b8 then local ev=c_[1]local hY,hZ=c_[2],c_[3]local rO=math.min(hY,hZ or hY)local rP=rO/cL;local rQ=b9 and(cL<42 or cf~=-1)local rR=b7 or bs or bv or b5;if rR and not rQ and(c6*1.5>rO or rP<1)then b2="Collision"bH={}q8=0;if b7 then ct.ToggleAltitudeHold()end;if bv then ct.ToggleLockPitch()end;dl("Autopilot Cancelled due to possible collision")a.print(ev.name.." COLLISION "..iG(rP).." / "..iF(rO,2))ct.ResetAutopilots(1)qW=true;if cg then b8=true end;cz=true end;if rP<11 then cZ=ev.name.." COLLISION "..iG(rP).." / "..iF(rO,2)else cZ=ev.name.." collision "..iG(rP)end;if rP<6 then fN("alarm","AL",2)end else cZ=false end end;local rS=1;local rT=0;local rU=1;local rV=1;local rW=1;local rX=false;local rY=pid.new(0.1,0,1*0.1)local rZ=pid.new(1*0.01,0,5*0.1)local r_=pid.new(aI*0.01,0,aI*0.1)local s0=pid.new(2*0.01,0,2*0.1)local rZ=pid.new(1*0.01,0,5*0.1)local s1=pid.new(2*0.01,0,2*0.1)local s2=pid.new(2*0.01,0,2*0.1)local s3=pid.new(2*0.01,0,2*0.1)local s4=pid.new(2*0.01,0,2*0.1)local s5=pid.new(0.1,0,1)local s6=pid.new(1*0.01,0,1*0.1)function pH.onFlush()if antigrav and not r and not cQ and antigrav.getBaseAltitude()~=bx then qi=bx end;if de then d:setEngineForceCommand('hover',vec3(),1)de=false end;cR=iB:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local s7=dp(bX+p_+a.getControlDeviceForwardInput(),-1,1)local s8=dp(bY+q1+a.getControlDeviceYawInput(),-1,1)local s9=dp(bZ+q0-a.getControlDeviceLeftRightInput(),-1,1)local sa=b2 and 1 or 0;if cg then cM=vec3(b.getWorldVertical())if cM==nil or cM:len()==0 then cM=(ku.center-cO):normalize()end else cM=(ku.center-cO):normalize()end;q5=vec3(bP.getWorldOrientationUp())cH=vec3(bP.getWorldOrientationForward())cI=vec3(bP.getWorldOrientationRight())cK=vec3(bP.getWorldVelocity())cJ=vec3(bP.getVelocity())cO=vec3(bP.getWorldPosition())cj=bP.getMass()+qn;cL=vec3(cK):len()cN=-cM:dot(cK)cT=getRoll(cM,cH,cI)local sb=cT/180*math.pi;local sc=math.cos(sb)local sd=math.sin(sb)cS=rK(cM,cH,cI*sc+q5*sd)local se=cK:normalize()local sf=f1(cT)local sg=utils.sign(cT)local sh=vec3(bP.getWorldAngularVelocity())local si=s7*aO*cI+s8*aJ*cH+s9*aP*q5;if cz==true and cM:len()>0.01 then local sj=f1(q2-cT)if((b4 or ba or b8 or cc or b7 or bB)and sj>0 or cg and sj<aK and q)and s8==0 and f1(cS)<85 then local sk=q2;if not cg then q2=0;sk=0 end;r_:inject(sk-cT)local sl=r_:get()si=si+sl*cH end end;bS=0;ch=bO()cg=false or ci<ku.noAtmosphericDensityAltitude and ch>0.00001;ci=(cO-ku.center):len()-ku.radius;cf=qz()bQ=bM()pM=bQ;if bo and cf>-1 and cf-3<Z then if iB.targetGroundAltitudeActivated then iB:deactivateGroundEngineAltitudeStabilization()end;iB:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if cu then ql=not ql;if ql then cu.UpdateRadar()end;if E then rN()end end;if antigrav then cQ=antigrav.isActive()==1 end;local sm=bQ-pM;local sn=-math.deg(qt(q5,cK,cH))local so=math.deg(qt(cI,cK,cH))local gk=cM*-1;cA=cg and sn<-N or sn>N or so<-O or so>O;local sp=a.getMouseDeltaX()local sq=a.getMouseDeltaY()if qm then local sr=bM()-qm;sp=sp*sr/0.016;sq=sq*sr/0.016 end;qm=bM()if p and not c1 then sq=-sq end;q0=0;q1=0;p_=0;local ss=bP.getWorldPosition()ku=fR:closestBody(ss)st=cq(ku)fn=st:orbitalParameters(ss,cK)cY=c.getClosestPlanetInfluence()>0 or ci>0 and ci<200000;local o8=ku:getGravity(ss):len()*cj;q2=0;local su=bP.getMaxThrustAlongAxis("ground",bP.getOrientationUp())[1]if qc==0 then if iA()==1 and c1 then if not cx then c9=dp(c9+sp/2,-ac/2,ac/2)ca=dp(ca+sq/2,-ad/2,ad/2)end else c9=0;ca=0 end else c9=dp(c9+sp/2,-ac/2,ac/2)ca=dp(ca+sq/2,-ad/2,ad/2)dd=dr(c9*c9+ca*ca)if not c1 and iA()==0 then local kU,kV=1,1;if bK=="SCOPE"then kU,kV=d5/90,d5/90 end;if g=="virtual joystick"then if dd>az then q0=q0-dp(f1(c9)-az,0,ac/2)*utils.sign(c9)*aG*kU;p_=p_-dp(f1(ca)-az,0,ad/2)*utils.sign(ca)*aH*kV end else c9=0;ca=0;if g=="mouse"then p_=(-utils.smoothstep(sq,-100,100)+0.5)*2*rV;q0=(-utils.smoothstep(sp,-100,100)+0.5)*2*rW end end end end;local sv=cL>27777;if cL>W/3.6 and not cg and not b5 and not sv then dl("Space Speed Engine Shutoff reached")q8=0 end;if not sv and sw then if not b2 then ct.BrakeToggle()end;if b5 then ct.ResetAutopilots(1)end;q8=0 end;sw=sv;if ch>0.09 then if cL>cB/3.6 and not t and not pI then b2="SpdLmt"pI=true elseif not t and pI then if cL<cB/3.6 then b2=false;pI=false end end end;if b4 then if cc then b2=false;local sx=false;sx=qL(fZ.position-cO,0.1)cz=true;if sx then q9=bN(cB)if(f1(cT)<2 or f1(cS)>85)and cL>=cB/3.6-1 then b2=false;b4=false;if cc~=2 then pZ=true end;if cc==true then ce=true end;cc=false;b5=false;ct.BeginReentry()end elseif cg and t then q8=1 end elseif cL>iU then qL(vec3(cK),0.01)end end;if b3 then if cg then b3=false elseif cL>iU then qL(-vec3(cK))end end;if not b4 and cc and not bB then if not cg then if cc~=2 then pZ=true end;ct.BeginReentry()cc=false;ce=true else cc=false;if not qj then qj=true end end end;if ce and fZ and(ci<bc+250 and ci>bc-250)and f1(cN)<25 and ch>=0.1 and(fZ.position-cO):len()>2000+ci then if not qj then qj=true end;ce=false end;if bb then cz=true;local sy=bc;if cN<-30 then dl("Unable to achieve lift. Safety Landing.")b_=0;cz=q;bb=false;b8=true elseif not r and cQ or bc<ku.spaceEngineMinAltitude then if cQ then sy=antigrav.getBaseAltitude()end;if ci<sy-100 then q3=0;b_=15;b2=false elseif cN>0 then b2="VTO Limit"b_=0 elseif cN<-30 then b2="VTO Fall"b_=15 elseif ci>=sy then if cQ then if b5 or bs then ct.ToggleVerticalTakeoff()else b2="VTO Complete"bb=false end;dl("Takeoff complete. Singularity engaged")fN("aggLk","AG")else b2=false;dl("VTO complete. Engaging Horizontal Flight")fN("vtoc","VT")ct.ToggleVerticalTakeoff()end;b_=0 end else if ch>0.08 then q3=0;b2=false;b_=20 elseif ch<0.08 and cg then b2=false;if cF then q3=0;b_=20 else b_=0;q3=36;q9=3500 end else cz=q;bB=true;cE=false;sz=false;pR=false;pP=nil;pQ=nil;if pU==nil then pU=ku end;cD=sy;pT=true;bb=false end end;if q3~=nil then local sA=dp(q3-cS,-O*0.80,O*0.80)s0:inject(sA)local sB=dp(s0:get(),-1,1)p_=sB end end;if di then local gO=di*(bm-cO)qL(gO,0.1)end;if bB then local function sC()if not fn.apoapsis or not fn.periapsis then return false end;if fn.periapsis.altitude>=cD*0.99 and fn.apoapsis.altitude>=cD*0.99 and fn.periapsis.altitude<fn.apoapsis.altitude and fn.periapsis.altitude*1.05>=fn.apoapsis.altitude and f1(cD-ci)<1000 then return true else return false end end;local qS;local sD=false;local sE=iF(cD,4)if pU==nil then pU=ku;if bs then pU=c8 end end;if not pT then cD=bN(pU.radius+pU.surfaceMaxAltitude+U)if pU.hasAtmosphere then cD=bN(pU.radius+pU.noAtmosphericDensityAltitude+U)end;pT=true end;if q4.VectorToTarget and fZ then qS=fZ.position-cO end;local sF,sG=cq(pU):escapeAndOrbitalSpeed((cO-pU.center):len()-pU.radius)sG=sG*3.6+1+(K and aZ*sG*3.6 or 0)local sH=cT;if not pR then local sI=false;local sJ=false;q8=0;pQ=0;cC="Aligning to orbital path - OrbitHeight: "..sE;if q4.VectorToTarget then qL(qS:normalize():project_on_plane(cM))sD=cH:dot(qS:project_on_plane(q5):normalize())>0.95 else qL(cK)sD=sn<0.5;if cL<150 then sD=true end end;p_=0;pP=0;if cS<=pP+2 and cS>=pP-2 then sI=true else sI=false end;if sH<=pQ+2 and sH>=pQ-2 then sJ=true else sJ=false end;if sI and sJ and sD then pP=nil;pQ=nil;pR=true end else if q4.VectorToTarget then qL(qS:normalize():project_on_plane(cM))elseif cL>150 then qL(cK)end;p_=0;if q4.VectorToTarget and fZ then local c6,dT=cp.computeDistanceAndTime(cL,cB/3.6,cj,0,0,bu)if cE and qS:len()>15000+c6+ci then cC="Orbiting to Target"if ci-100<=pU.noAtmosphericDensityAltitude or lr>fn.timeToPeriapsis and fn.periapsis.altitude<pU.noAtmosphericDensityAltitude or not sC()and fn.eccentricity>0.1 then dl("Re-Aligning Orbit")cE=false end elseif cE or qS:len()<15000+c6+ci then dl("Orbit complete, proceeding with reentry")fN("orCom","OB")bm=fZ.position;pZ=true;ce=true;q4.VectorToTarget,q4.AutopilotAlign=false,false;ct.ToggleIntoOrbit()ct.BeginReentry()return end end;if pS or fn.periapsis~=nil and fn.apoapsis~=nil and fn.eccentricity<1 and ci>cD*0.9 and ci<cD*1.4 then if fn.apoapsis~=nil or pS then if(sC()or cE)and not K then if cE then b2=false;q8=0;pP=0;if not q4.VectorToTarget then dl("Orbit complete")fN("orCom","OB")ct.ToggleIntoOrbit()end else pV=pV+1;if pV>=2 then cE=true end end else if sC()then cC="Maintaining "else cC="Adjusting "pS=true;q9=sG;local sK=cD-ci;rY:inject(sK-cN*dp(utils.smoothstep(2000-sK,-2000,2000)^6*10,1,10))pP=dp(rY:get(),-75,75)end;cC=cC.." - OrbitHeight: "..sE end end else local sL=2.75;local sM=f1(fO(sF*sL))local ol=sM%50;if ol>0 then sM=sM-ol+50 end;b2=false;if ci<cD*0.8 then cC="Escaping planet gravity - OrbitHeight: "..sE;pP=utils.map(cN,200,0,-15,80)elseif ci>=cD*0.8 and ci<cD*1.15 then cC="Approaching orbital corridor - OrbitHeight: "..sE;sM=sM*0.75;pP=utils.map(cN,100,-100,-15,65)elseif ci>=cD*1.15 and ci<cD*1.5 then cC="Approaching orbital corridor - OrbitHeight: "..sE;sM=sM*0.75;if cN<0 or pS then pP=utils.map(ci,cD*1.5,cD*1.01,-30,0)else pP=utils.map(ci,cD*0.99,cD*1.5,0,30)end elseif ci>cD*1.5 then cC="Reentering orbital corridor - OrbitHeight: "..sE;pP=-65;local sN=utils.map(cN,-150,-400,1,0.55)sM=sM*sN end;q9=bN(sM)end end;if pP~=nil then local sO=pP-cS;rZ:inject(sO)local sP=dp(rZ:get(),-0.5,0.5)p_=sP end end;if b5 and not cg and not cc then local function sQ(sR,fn)a.print(sR)b4=false;b2=false;bf=false;b5=false;r3=false;bi="Aligning"q8=0;pY=false;dl(sR)fN("apCom","AP")if fn or cc then if fn and gi~=nil and not cc then if not ci or ci==0 then return end;cD=ci;pT=true end;ct.ToggleIntoOrbit()end end;local sS,sT=bm,false;if fZ and fZ.planetname~="Space"then be=true;if not r3 then local sU=(fZ.position-c8.center):normalize()local sV=sU:project_on_plane((c8.center-cO):normalize()):normalize()local sW=c8.center+sV*(c8.radius+gi)local sX=fZ.position+(fZ.position-c8.center):normalize()*(gi-c8:getAltitude(fZ.position))if(cO-sW):len()<(cO-sX):len()then sS=sW else sS=sX;bh=0 end;bm=sS;ct.showWayPoint(c8,bm)sT=true;r3=true end;bj=0 elseif fZ and fZ.planetname=="Space"then if not r3 then bj=0;sT=true;be=true;r3=true;sS=fZ.position+(cO-fZ.position):normalize()*S;bm=sS end elseif fZ==nil then bj=0;if not r3 then local sU=(cO+cK*100000-c8.center):normalize()local sV=sU:project_on_plane((c8.center-cO):normalize()):normalize()if sV:len()<1 then sU=(cO+cH*100000-c8.center):normalize()sV=sU:project_on_plane((c8.center-cO):normalize()):normalize()end;sS=c8.center+sV*(c8.radius+gi)bm=sS;r3=true;sT=true;be=true;ct.showWayPoint(c8,bm)end end;rk=(vec3(sS)-cO):len()local lp,eM,eN=co:getPlanetarySystem(0):castIntersections(cO,cK:normalize(),function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)local lq=eM;if eN~=nil and eM~=nil then lq=math.min(eN,eM)end;if lq~=nil and lq<rk and lp.name==c8.name then rk=lq end;local sx=true;local sY=(c8.center-(cO+vec3(cK):normalize()*rk)):len()-c8.radius;local lm=iF(sY)qg=ga;qh='{"label": "Projected Altitude", "value": "'..lm..'"}'if cL>50 and bd then local qS=vec3(sS)-cO;local sZ=dp(math.deg(qt(q5,cK:normalize(),qS:normalize()))*cL/500,-90,90)local s_=dp(math.deg(qt(cI,cK:normalize(),qS:normalize()))*cL/500,-90,90)if f1(sZ)<20 and f1(s_)<20 then sZ=sZ*2;s_=s_*2 end;if f1(sZ)<2 and f1(s_)<2 then sZ=sZ*2;s_=s_*2 end;local sn=-math.deg(qt(q5,cH,cK:normalize()))local so=-math.deg(qt(cI,cH,cK:normalize()))s1:inject(s_-so)local t0=dp(s1:get(),-1,1)p_=p_+t0;s2:inject(sZ-sn)local t1=dp(s2:get(),-1,1)q0=q0+t1;sT=true;if f1(sZ)>2 or f1(s_)>2 then if bi~="Adjusting Trajectory"then bi="Adjusting Trajectory"fN("apAdj","AP")end else if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end end elseif bd and cL<=50 then qL((sS-cO):normalize())end;if sY<gi*1.5 then bh=cB/3.6;if fZ==nil then dT,bh=cq(c8):escapeAndOrbitalSpeed(sY)end end;local c6,c7;if not b6 then c6,c7=qp(cL)else c6,c7=qs(cL)end;if b5 and not bd and not bg and not bf then local lp,lq=ct.checkLOS((bm-cO):normalize())if c8.name~=ku.name then if lp~=nil and c8.name~=lp.name and lq<rk then cZ="Attempting to clear LOS between "..lp.name.." and waypoint."qd=true else qd=false;cZ=false end end end;if not qd then if not bg and not bf and not sT then sx=qL((sS-cO):normalize())elseif b6 and(bf or bg)then sx=qL(-vec3(cK):normalize())end end;if bd then if not pY then b2=false;q8=a1;bR=fO(a1,2)pY=true end;local rl=c.getThrottle()if t then rl=bR end;local t2=99999;local oj=-vec3(bP.getWorldAcceleration()):dot(cK:normalize())local t3=dp(cK:dot((sS-cO):normalize()),0,cL)if t3>0 or oj>0 then t2=cp.computeTravelTime(t3,oj,rk-c6)end;if a0>df then a0=df-0.2 end;if cJ:len()>=a0 or rl==0 and pY or a2/4>t2 then bd=false;if bi~="Cruising"then fN("apCru","AP")bi="Cruising"end;bg=true;q8=0 end;local t4=rk;if t4<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV and not sv then if cW<pJ and cW>2000 then ct.ResetAutopilots(1)dl("Autopilot cancelled to prevent crossing PvP Line")b2="PvP Prevent"pJ=cW else pJ=cW;return end end;bd=false;if bi~="Braking"then fN("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end;q8=0;pY=false end elseif bf then if bi~="Orbiting to Target"then b2="AP Brk"end;if b6 then q8=1;qa=true end;local dT,sG=cq(c8):escapeAndOrbitalSpeed((cO-ku.center):len()-ku.radius)local qS;if fZ then qS=fZ.position-cO end;if fZ and fZ.planetname=="Space"and cL<50 then if#bH>0 then if not qj then table.remove(bH,1)end;if#bH>0 then b2=false;if not qj then qj=2 end;return end end;sQ("Autopilot complete, arrived at space location")b2="Space Arrival"elseif fZ and fZ.planetname~="Space"and cL<=sG and(fn.apoapsis==nil or fn.periapsis==nil or fn.apoapsis.altitude<=0 or fn.periapsis.altitude<=0)then sQ("Autopilot complete, commencing reentry")bm=fZ.position;cc=true;ct.showWayPoint(c8,bm)elseif(fZ and fZ.planetname~="Space"or fZ==nil)and fn.periapsis~=nil and fn.periapsis.altitude>0 and fn.eccentricity<1 or bi=="Circularizing"then if bi~="Circularizing"then fN("apCir","AP")bi="Circularizing"end;if cL<=sG then if fZ then if cK:normalize():dot(qS:normalize())>0.4 then if bi~="Orbiting to Target"then fN("apOrb","OB")bi="Orbiting to Target"end;if not r5 then b2=false;ct.showWayPoint(c8,fZ.position)r5=true end else sQ("Autopilot complete, proceeding with reentry")bm=fZ.position;cc=true;ct.showWayPoint(c8,fZ.position)r5=false end else sQ("Autopilot completed, setting orbit",true)b2=false end end elseif bi=="Circularizing"then sQ("Autopilot complete, fixing Orbit",true)end elseif bg then local t4=rk;if t4<=c6 or H and cW<=c6+10000 and cV then if H and cW<=c6+10000 and cV then if cW<pJ and cW>2000 then if not qj then qj=true end;dl("Autopilot cancelled to prevent crossing PvP Line")b2="Prevent PvP"pJ=cW else pJ=cW;return end end;bd=false;if bi~="Braking"then fN("apBrk","AP")bi="Braking"end;bf=true;if not b6 then b4=true;cz=true end end;local rl=c.getThrottle()if t then rl=bR end;if rl>0 then bd=true;if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end;bg=false end else if sx then if not be and fZ==nil or not be and fZ and fZ.planetname~="Space"then if not cc then bm=vec3(c8.center)+(gi+c8.radius)*cI;t5=q5;t6=cI end;be=true elseif sx and not qd then bd=true;if bi~="Accelerating"then bi="Accelerating"fN("apAcc","AP")end;if not pY then q8=a1;qa=true;bR=fO(a1,2)pY=true;b2=false end end end end elseif b5 and(fZ~=nil and fZ.planetname~="Space"and cg)then dl("Autopilot complete, starting reentry")fN("apCom","AP")bm=fZ.position;b2=false;bf=false;b5=false;r3=false;bi="Aligning"q8=0;pY=false;b4=true;cc=true;ct.showWayPoint(c8,fZ.position)end;if c0 then cz=true;local s_=0;local fp=vec3(DUPlayer.getWorldPosition())local t7=fp-cO;local t8=vec3(t7):project_on(cH):len()local t9=vec3(t7):project_on(cI):len()local cb=dr(t8*t8+t9*t9)qL(t7:normalize())local ms=40;local ta=cb<ms;local tb=100;local ry=dp((cb-ms)/2,10,tb)p_=0;local sx=f1(q0)<0.1;if sx and cL<ry and not ta then b2=false;s_=-20 else b2="Follow"s_=0 end;local tc=0;if f1(s_-cS)>tc then s3:inject(s_-cS)local t0=s3:get()p_=t0 end end;if b7 or b8 or ba or bs or bv~=nil then local td=bw;if td then td=td*dp(cL/100,0.1,1)*ch else td=bu end;if not cg then td=bu end;q7=cH:project_on_plane(cM):normalize():dot(cK)if q7>100 then c6,c7=cp.computeDistanceAndTime(q7,100,cj,0,0,td)local te,dT=cp.computeDistanceAndTime(100,0,cj,0,0,td*0.55)c6=c6+te else c6,c7=cp.computeDistanceAndTime(q7,0,cj,0,0,td*0.55)end;local sK=bc-ci-cN;local tf=200+cL;if ba or cc then tg=2000+cL end;local th=1;if b9 then th=dp(cL/100,0.1,1)end;local s_=(utils.smoothstep(sK,-tf,tf)-0.5)*2*Q*th;if not ba and not cc and not bs and cH:dot(cK:normalize())<0.99 then s_=(utils.smoothstep(sK,-tf*dp(20-19*ch*10,1,20),tf*dp(20-19*ch*10,1,20))-0.5)*2*Q*dp(2-ch*10,1,2)*th end;if not b7 then s_=0 end;if bv~=nil then if cY and not bB then s_=bv else bv=nil end end;cz=true;local ti=p_;if ba then local tj=bN(cB)local tk,tl=cp.computeDistanceAndTime(cL,tj/3.6,cj,0,0,bu-ku.gravity*9.8*cj)tk=tk==-1 and 5000 or tk;local r4=ci-(ku.noAtmosphericDensityAltitude+tk)local tm=ci>ku.noAtmosphericDensityAltitude+tk*1.35;if tm then s_=R;if cL<=tj/3.6 and cL>tj/3.6-10 and f1(cK:normalize():dot(cH))>0.9 and not cR then bV=false;q8=1 end elseif(cR or iB:getTargetSpeed(axisCommandId.longitudinal)~=tj)and not tm and not cg then q9=tj;qa=true end;if cR then if cL>tj/3.6 and not tm then b2="Reentry Limit"if bR>0 then q8=0 end else b2=false end else b2=false end;if cN>0 then b2="Reentry vSpd"end;if not pZ then s_=-80;if ci<ku.surfaceMaxAltitude+(ku.atmosphereThickness-ku.surfaceMaxAltitude)*0.25 then dl("PARACHUTE DEPLOYED at "..fO(ci,0))ba=false;b8=true;qW=true;q8=0;s_=0;cz=q end elseif ku.noAtmosphericDensityAltitude>0 and tm then cz=true elseif not tm then if not cg and(cR or iB:getTargetSpeed(axisCommandId.longitudinal)~=tj)then q9=tj end;if cL<tj/3.6+1 then b2=false;pZ=false;ba=false;cz=true;q8=1 end end end;if cL>iU and not cd and not bs and not b8 and u then qL(vec3(cK))end;if cX or(bs or cd)and bn>0 and cg then local qS;if cX then if type(cX)=="table"then qS=cX elseif cX<3 and cX>0 then qS=-cM:cross(cK)*5000 elseif cX>=3 then qS=cM:cross(cK)*5000 elseif cX<0 then qS=cK*25000 end elseif fZ~=nil then qS=fZ.position-cO else qS=c8.center-cO end;local sZ=math.deg(qt(cM:normalize(),cK,qS))*2;local mv=math.rad(f1(cT))if cL>aL and cg then local tn=1000+cL;local to=(utils.smoothstep(sK-cN*10,-tn,tn)-0.5)*2*Q;local tp=dp(90-to,0,180)q2=dp(sZ*2,-tp,tp)local tq=sZ;sZ=dp(dp(sZ,-N*0.80,N*0.80)*math.cos(mv)+4*(cS-s_)*math.sin(math.rad(cT)),-N*0.80,N*0.80)local tr=1;if q2~=0 then tr=f1(mv/q2)end;tr=(90-dp(f1(q2-cT),0,90))/90;local ts=s_;if f1(cT)>90 then ts=-ts end;s_=tr*dp(dp(ts*math.cos(mv),-O*0.8,O*0.8)+f1(dp(f1(tq)*math.sin(mv),-O*0.80,O*0.80)),-O*0.80,O*0.80)else q2=0;sZ=dp(sZ,-N*0.80,N*0.80)end;local tt=sn-sZ;if cX and f1(tt)<=0.0001 and(type(cX)=="table"or type(cX)~="table"and cX<0 and f1(cT)<1)then if cX==-2 then ct.ToggleAltitudeHold()end;cX=nil;fN("180Off","BR")return end;if not cA and cL>aL and cg then s4:inject(tt)local t1=dp(s4:get(),-1,1)q0=q0+t1 elseif cg and cf>-1 or cL<aL then qL(qS)elseif cA and cg then if(sn<-N or sn>N)and cg then qL(cK)end;if(so<-O or so>O)and cg then s_=dp(cS-so,cS-O*0.80,cS+O*0.80)end end;if fZ~=nil and not cd then local sy=ku:getAltitude(fZ.position)local r4=qS:project_on_plane(cM):len()qW=true;if bc<ku.noAtmosphericDensityAltitude and not cd and not b9 and not ba and(r4<=c6 and qS:len()<ku.radius)and(cK:project_on_plane(cM):normalize():dot(qS:project_on_plane(cM):normalize())>0.99 or lt=="Finalizing Approach")then lt="Finalizing Approach"if#bH>0 then if not qj then table.remove(bH,1)end;if#bH>0 then if not qj then qj=2 end;return end end;q8=0;if b7 then ct.ToggleAltitudeHold()bs=true end;b2="AP Finalizing"elseif not b9 then b2=false end;if lt=="Finalizing Approach"and(q7<0.1 or r4<0.1 or tu~=nil and tu<r4)then fN("bklOn","BL")b8=true;db=true;if fZ.heading then dc=fZ.heading else dc=nil end;bs=false;lt="Proceeding to Waypoint"cZ=false end;tu=r4 end elseif bs and not cg and bc>ku.noAtmosphericDensityAltitude and not(cd or ba)then if fZ~=nil and c8.name==ku.name then local qS=fZ.position-cO;local sy=ku:getAltitude(fZ.position)local r4=dr(qS:len()^2-(ci-sy)^2)local td=bw;if td then c6,c7=cp.computeDistanceAndTime(cL,0,cj,0,0,td/2)qW=true;if r4<=c6+cL*sm/2 and cK:project_on_plane(cM):normalize():dot(qS:project_on_plane(cM):normalize())>0.99 then if ku.hasAtmosphere then b2=false;b4=false;pZ=true;cc=false;ce=true;b5=false;ct.BeginReentry()end end;tu=r4 end end end;if not cg and cf==-1 and(b7 and bc>ku.noAtmosphericDensityAltitude)and not(cd or bB or ba)then if not cE and not bB then cD=bc;pT=true;if bs then q4.VectorToTarget=true end;ct.ToggleIntoOrbit()bs=false;pR=true end end;if cA and cg and cf==-1 and cL>aL and lt~="Finalizing Approach"then qL(cK)s_=dp(cS-so,cS-O*0.80,cS+O*0.80)end;p_=ti;local qE=-1;if b8 then local tv=aY or 0.05;if not qe then rX=false;if not cR then q8=0 end;if cf==-1 then iB:setTargetGroundAltitude(500)iB:activateGroundEngineAltitudeStabilization(500)end;if not cg then rX=true end;qe=true end;s_=0;local tw=false;local tx=math.abs(q7)if not r and cQ then tw=antigrav.getBaseAltitude()if tw<ku.surfaceMaxAltitude and fZ==nil or fZ~=nil and ku:getAltitude(fZ.position)>tw then tw=false end else tw=false end;if dc then if tx<tv then if cN>-P then b2=false else b2="BL Align BLR"end;if qL(dc,0.001)then dc=nil;cz=q else p_=0;cz=true end else b2="BL Align Hzn"end;if tw and f1(ci-tw)<250 then b2="AGG Align"end else local ty=false;local tz=30;if tx<10 and su~=nil and su>0 then local tA=dp(ch,0.4,2)local td=bw*dp(cL/100,0.1,1)*tA;local tB=su*tA+td-o8;local tC=td/2-o8;local tD=cL-dr(f1(tC/2)*20/(0.5*cj))*utils.sign(tC)if tD<0 then tD=0 end;local tE;if cL>100 then local tF,dT=cp.computeDistanceAndTime(cL,100,cj,0,0,td)local tG,dT=cp.computeDistanceAndTime(100,0,cj,0,0,dr(td))tE=tF+tG else tE=cp.computeDistanceAndTime(cL,0,cj,0,0,dr(td))end;if tE<20 then b2=false else local tH=0;if tD>100 then local tI,dT=cp.computeDistanceAndTime(tD,100,cj,0,0,tB)local tJ,dT=cp.computeDistanceAndTime(100,0,cj,0,0,su*tA+dr(td)-o8)tH=tI+tJ else tH,dT=cp.computeDistanceAndTime(tD,0,cj,0,0,su*tA+dr(td)-o8)end;tH=(tH+15+cL*sm)*1.1;local tK=db and fZ~=nil and ku:getAltitude(fZ.position)>0 and fZ.safe;local sy=nil;if tw and tw<ci then sy=tw elseif tK then sy=ku:getAltitude(fZ.position)+250 elseif ci>ku.surfaceMaxAltitude then sy=ku.surfaceMaxAltitude end;if c_ then local tL=ku:getAltitude(c_[1].center)if sy then if tL>sy then sy=tL end else sy=tL end end;if sy~=nil then local tM=ci-sy;ty=true;if tM<=tH or tH==-1 or tx>tv and db then if sy==ku.surfaceMaxAltitude and cN<-P then b2="BL Stop BLR"elseif tx>tv and db then b2="BL AP Hzn"else b2="BL Stop Dist"end else b2=false end end end end;qE=cf;if qE>-1 then b2=false;if not tw and not bo then qb=true;iB:setTargetGroundAltitude(Z)end;if(cL<1 or cK:normalize():dot(cM)<0)and not dc and qE-3<Z and(bD or cL==0)then b8=false;b7=false;b_=0;qX(0,1)b2="BL Complete"cz=q;db=false;qe=false else if cN<-5 or tx>tv*10 then qX(0,1)b2="BL Slowing"else b2=false;qX(-1)end end elseif not ty then if qW and cK:normalize():dot(-gk)<0.999 then b2="BL Strong"qL()elseif tx>10 or tx>tv and db then b2="BL hSpd"elseif cN<-P then b2="BL BLR"qX(0,1)else qX(-1)b2=false end end end else qe=false end;if b9 or cd then local lp,eN,eM;if bm~=nil then lp,eN,eM=co:getPlanetarySystem(0):castIntersections(cO,(bm-cO):normalize(),function(ev)if ev.noAtmosphericDensityAltitude>0 then return ev.radius+ev.noAtmosphericDensityAltitude else return ev.radius+ev.surfaceMaxAltitude*1.5 end end)end;if lp~=nil then if lp.name~=c8.name and not cg then cZ="Clearing LOS between "..lp.name.." and waypoint."end end;if cQ and not cd then if ci>=bc-50 and cL>iU then b9=false;if not b5 and not bs then b2="ATO Agg Arrive"q8=0 end end elseif f1(s_)<15 and ci/bc>0.75 then b9=false;if not cd then if cR and not t then d.control.cancelCurrentControlMasterMode()end elseif cd and cL<iU then b5=true;cd=false;b7=false;b9=false;q8=0 elseif cd then q8=0;b2="ATO Space"end elseif cd and not cg and c8~=nil and(lp==nil or lp.name==c8.name)then b5=true;cZ=false;cd=false;b7=false;b9=false;if not cR then q8=0 end;bd=true end end;local tN=cf>-1;local tO=cS;if(bs or cd or cX)and not tN and cL>aL and cg then local mv=math.rad(f1(cT))tO=cS*f1(math.cos(mv))+so*math.sin(mv)end;local tP=dp(s_-tO,-O*0.80,O*0.80)if not cg and bs then tP=dp(s_-tO,-85,Q)elseif not cg then tP=dp(s_-tO,-Q,Q)end;if f1(cT)<5 or bs or cX or b8 or tN or b7 then s3:inject(tP)local t0=s3:get()p_=p_+t0 end end;if antigrav~=nil and(antigrav and not r and ci<200000)then if bx==nil or bx<1000 then bx=1000 end;if tQ~=bx then tQ=bx;qi=tQ end end;if(cg or ba or ce)and t and cR then local tR=0;if aU>0 and not ba and ch>0.005 and ch<0.1 and cN>-50 then local tS=bP.getFrictionBurnSpeed()*aU;local tT=cB/3.6;if tS>tT then tR=tS-tT-1 end end;s5:inject(cB/3.6+tR-cK:dot(cH))local tU=s5:get()bU=dp(tU,-1,1)if not d7 then if bU<bR and(ch>0.005 or ba or ce)then bT=true;d7=dp(bU,0.01,1)else bT=false;d7=bR end end;s6:inject(cK:len()-cB/3.6-tR)local tV=dp(s6:get(),0,1)if cg and cN<-80 or(ch>0.005 or ba or ce)then bS=tV end;if bS>0 then if bT and bU==0.01 and not d7 then d7=0 end else bU=dp(bU,0.01,1)end;local tW=''local tX=vec3()local tY=rw(axisCommandId.vertical,b_*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tY,rT)local tZ='thrust analog longitudinal 'if bE=="All"or bE=="Longitude"then tZ=tZ..aV end;local t_=iB:getAxisCommandType(axisCommandId.longitudinal)local u0=iB:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)local u1=rJ(axisCommandId.lateral,bA*1000)tW=tW..' , '.."lateral airfoil , lateral ground "tX=tX+u1;if tX:len()>constants.epsilon then d:setEngineForceCommand(tW,tX,rT,'','','',rU)end;d:setEngineForceCommand(tZ,u0,rS)local u2='thrust analog vertical fueled 'local u3='thrust analog lateral fueled 'if bE=="All"or bE=="Lateral"then u3=u3 ..aW end;if bE=="All"or bE=="Vertical"then u2=u2 ..aX end;if b_~=0 or b8 and b2 or not bo and not bD then d:setEngineForceCommand(u2,tY,rS)else d:setEngineForceCommand(u2,vec3(),rS)end;if bA~=0 then d:setEngineForceCommand(u3,u1,rS)else d:setEngineForceCommand(u3,vec3(),rS)end;if sa==0 then sa=bS end;local u4=-sa*(aQ*cK+aR*se)d:setEngineForceCommand('brake',u4)else if t then if not d7 then d7=bR end end;local ry=c.getAxisCommandValue(0)if not cR then s6:inject(cK:len()-ry/3.6)local tV=dp(s6:get(),0,1)sa=dp(sa+tV,0,1)end;local u4=-sa*(aQ*cK+aR*se)d:setEngineForceCommand('brake',u4)local tW=''local tX=vec3()local u5=false;local tZ='thrust analog longitudinal 'if aV~="none"and(bE=="All"or bE=="Longitude")then tZ=tZ..aV end;local t_=iB:getAxisCommandType(axisCommandId.longitudinal)if t_==axisCommandType.byThrottle then local u0=iB:composeAxisAccelerationFromThrottle(tZ,axisCommandId.longitudinal)d:setEngineForceCommand(tZ,u0,rS)elseif t_==axisCommandType.byTargetSpeed then local u0=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tW=tW..' , '..tZ;tX=tX+u0;if iB:getTargetSpeed(axisCommandId.longitudinal)==0 or iB:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iB:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u5=true end end;local u3='thrust analog lateral 'if aW~="none"and(bE=="All"or bE=="Lateral")then u3=u3 ..aW end;local u6=iB:getAxisCommandType(axisCommandId.lateral)if u6==axisCommandType.byThrottle then local u7=iB:composeAxisAccelerationFromThrottle(u3,axisCommandId.lateral)d:setEngineForceCommand(u3,u7,rS)elseif u6==axisCommandType.byTargetSpeed then local u1=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tW=tW..' , '..u3;tX=tX+u1 end;local u2='thrust analog vertical 'if aX~="none"and(bE=="All"or bE=="Vertical")then u2=u2 ..aX end;local u8=iB:getAxisCommandType(axisCommandId.vertical)if u8==axisCommandType.byThrottle then local tY=iB:composeAxisAccelerationFromThrottle(u2,axisCommandId.vertical)if b_~=0 or b8 and b2 then d:setEngineForceCommand(u2,tY,rS,'airfoil','ground','',rU)else d:setEngineForceCommand(u2,vec3(),rS)d:setEngineForceCommand('airfoil vertical',tY,rS,'airfoil','','',rU)d:setEngineForceCommand('ground vertical',tY,rS,'ground','','',rU)end elseif u8==axisCommandType.byTargetSpeed then if b_<0 then d:setEngineForceCommand('hover',vec3(),rS)end;local u9=iB:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tW=tW..' , '..u2;tX=tX+u9 end;if tX:len()>constants.epsilon then if sa~=0 or u5 or f1(se:dot(cH))<0.5 then tW=tW..', brake'end;d:setEngineForceCommand(tW,tX,rT,'','','',rU)end end;local ua=aN*(si-sh)local ub=vec3(bP.getWorldAirFrictionAngularAcceleration())ua=ua-ub;d:setEngineTorqueCommand('torque',ua,rS,'airfoil','','',rU)d:setBoosterCommand('rocket_engine')if c5 and not o then local kj=cJ:len()local uc=0.15;if not cR then local ud=iB:getTargetSpeed(axisCommandId.longitudinal)if kj*3.6>ud*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kj*3.6<ud*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local rl=c.getThrottle()if t then rl=bR*100 end;local ry=rl/100;if not cg then ry=ry*a0;if kj>=ry*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kj<ry*(1-uc)and not ue then ue=true;d:toggleBoosters()end else local tj=bN(cB)ry=ry*tj/3.6;if kj>=ry*(1-uc)and ue then ue=false;d:toggleBoosters()elseif kj<ry*(1-uc)and not ue then ue=true;d:toggleBoosters()end end end end end;if uf then for dO,dA in pairs(uf)do pH[dO]=dA end end;cf=qz()return pH end;local function ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iA,iB,iC,ui,gF,fO,e7,dq,dp,fN,iE,pG,dl,uj,uk)local bP=DUConstruct;local ul={}local um=true;local un=5;local uo=5;local up=un;local uq=uo;local ur=bQ;local us=bQ;function ul.landingGear(qb)bo=not bo;if bo then if b5 or bs or cd or bB then ct.ResetAutopilots(true)end;bv=nil;ct.cmdThrottle(0)if vBooster or hover then if(cg or ci<20000)and not qb and cf==-1 then fN("bklOn","BL")qW=true;ba=false;b9=false;bb=false;if b8 then db=not db end;cz=true;bo=false;b8=true else if bW then fN("grOut","LG",1)d.control.deployLandingGears()end;db=false;if cg then cz=q;b2="Landing"end end;if qb or cf~=-1 and cf>Z-3 or not bD then b8=true end;iB:activateGroundEngineAltitudeStabilization(q_)iB:setTargetGroundAltitude(Z)b7=false elseif bW and not b8 then fN("grOut","LG",1)d.control.deployLandingGears()end else if b8 then b8=false end;if bW then fN("grIn","LG",1)d.control.retractLandingGears()end;iB:activateGroundEngineAltitudeStabilization(q_)if bD then if Z<iB.targetGroundAltitude then iB:setTargetGroundAltitude(iB.targetGroundAltitude)else iB:setTargetGroundAltitude(Y)end else iB:setTargetGroundAltitude(Y)end end end;function ul.startControl(ut)local function uu(rg)local rh=1;local function uv(uw,rg)local ux={ku.surfaceMaxAltitude+100,ku.spaceEngineMinAltitude-0.01*ku.noAtmosphericDensityAltitude,ku.noAtmosphericDensityAltitude+U,ku.radius*(T-1)+ku.noAtmosphericDensityAltitude}local uy=uw;for dT,dA in ipairs(ux)do if rg and uy>dA then uw=dA elseif uw<dA and not rg then uw=dA;break end end;return uw end;if rg then rh=-1 end;if not r and cQ then if c1 and rg then bx=1000 elseif bx~=nil then bx=bx+rh*uo;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end else bx=tQ+rh*100 end elseif b7 or bb or bB then if bB then if c1 then cD=uv(cD,rg)else cD=cD+rh*un end;if cD<ku.noAtmosphericDensityAltitude then cD=ku.noAtmosphericDensityAltitude end else if c1 and cg then bc=uv(bc,rg)else bc=bc+rh*un end end else iB:updateTargetGroundAltitudeFromActionStart(rh*1.0)end end;local function uz(uA)if not cg then dl("Flight Assist in Atmo only")return end;local dx=type(uA)if cX==nil then if dx=="table"then if b5 or bs then ct.ToggleAutopilot()end;fN("180On","BR")elseif uA==1 then fN("bnkLft","BR")else fN("bnkRht","BR")end;if not b7 and not b5 and not bs then ct.ToggleAltitudeHold()if dx~="table"then uA=uA+1 end end;cX=uA else fN("180Off","BR")cX=nil end end;local function uB()if iC()==1 then c9=0;ca=0;ui(bk)elseif iA()==1 and y then cy=false;cx=false end;c1=false end;if ut=="gear"then cv.landingGear()elseif ut=="light"then if p4 then if iA()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)dl("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)dl("Player Frozen, pitch/yaw/roll enabled")end else dl("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ut=="forward"then if p4 and not cg and not b5 then b4=not b4;b3=false else bX=bX-1 end elseif ut=="backward"then if p4 then if not cg then if not b5 then b3=not b3;b4=false else b6=not b6 end else uz(-cK*5000)end else bX=bX+1 end elseif ut=="left"then if p4 then uz(1)else bY=bY-1 end elseif ut=="right"then if p4 then uz(3)else bY=bY+1 end elseif ut=="yawright"then bZ=bZ-1;dc=nil elseif ut=="yawleft"then bZ=bZ+1;dc=nil elseif ut=="straferight"then iB:updateCommandFromActionStart(axisCommandId.lateral,1.0)bA=1 elseif ut=="strafeleft"then iB:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bA=-1 elseif ut=="up"then ct.vertical(1)if cf-3<Z and ci>0 and bo then cv.landingGear()end elseif ut=="down"then ct.vertical(-1)elseif ut=="groundaltitudeup"then uu()elseif ut=="groundaltitudedown"then uu(true)elseif ut=="option1"then uC=false;if p4 and c1 then local uD=""for M=1,#d2 do uD=uD.."| Name: "..a.getPlayerName(d2[M]).." Mass: "..fO(bP.getBoardedPlayerMass(d2[M])/1000,1).."t "end;a.print("Onboard: "..uD)return end;cs.adjustAutopilotTargetIndex()elseif ut=="option2"then uC=false;if p4 and c1 then for M=1,#d2 do bP.forceDeboard(d2[M])bP.forceInterruptVRSession(d2[M])end;dl("Deboarded All Passengers")return end;cs.adjustAutopilotTargetIndex(1)elseif ut=="option3"then uC=false;if p4 and c1 then local uD=""for M=1,#d3 do uD=uD.."| ID: "..d3[M].." Mass: "..fO(bP.getDockedConstructMass(d3[M])/1000,1).."t "end;a.print("Docked Ships: "..uD)return end;if x then if w then w=false else w=true end;if cu then cu.ToggleRadarPanel()end end elseif ut=="option4"then uC=false;if p4 and c1 then for M=1,#d3 do bP.forceUndock(d3[M])end;dl("Undocked all ships")return end;cX=nil;ct.ToggleAutopilot()elseif ut=="option5"then uC=false;if p4 and c1 then di=false;ct.ToggleLockPitch()return end;if bQ-us<1.5 then if di then di=-1;dl("Retrograde Alignment lock to "..bl)return end end;us=bQ;if di then di=false;dl("Alignment cancelled")elseif not b5 and not bs and not cd and not bB and not ba and not ce and not b7 then di=1;dl("Alignment lock to "..bl)else dl("Disengage autopilot before using Alignment Lock")end elseif ut=="option6"then uC=false;if p4 and c1 then if shield then cw.ventShield()else dl("No shield found")end;return end;ct.ToggleAltitudeHold()elseif ut=="option7"then uC=false;if p4 and c1 then if shield then shield.toggle()return else dl("No shield found")return end end;E=not E;if E then dl("Collision System Enabled")else dl("Collision System Secured")end elseif ut=="option8"then uC=false;if p4 and c1 then if bn>0 and fZ~=nil then ct.routeWP()else dl("Select a saved wp on IPH to add to or remove from route")end;return end;bD=not bD;if not bD then dl("DeCoupled Mode - Ground Stabilization off")iB:deactivateGroundEngineAltitudeStabilization()fN("gsOff","GS")else dl("Coupled Mode - Ground Stabilization on")iB:activateGroundEngineAltitudeStabilization(q_)de=true;fN("gsOn","GS")end elseif ut=="option9"then uC=false;if p4 and c1 then iB:resetCommand(axisCommandId.longitudinal)iB:resetCommand(axisCommandId.lateral)iB:resetCommand(axisCommandId.vertical)ct.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ck=gyro.isActive()==1;if ck then fN("gyOn","GA")else fN("gyOff","GA")end else dl("No gyro found")end elseif ut=="lshift"then if p4 then c1=true end elseif ut=="brake"then if b0 or p4 then ct.BrakeToggle("Manual")elseif not b2 then ct.BrakeToggle("Manual")else b2="Manual"end elseif ut=="lalt"then uC=true;p4=true;if iA()==0 and not j and g=="keyboard"then ui(1)end elseif ut=="booster"then if p4 then if uj then uj.toggle()if uj.isActive()==1 then dl("Transponder On")else dl("Transponder Off")end else dl("No transponder found")end else if o then d:toggleBoosters()elseif not c5 then if not ue then d:toggleBoosters()ue=true end;c5=true else if ue then d:toggleBoosters()ue=false end;c5=false end end elseif ut=="stopengines"then local function uE()if bQ-ur<1.5 then fN("clear","CA")ct.clearAll()end end;uE()ur=bQ;if iB:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p4 then if cB>0 then cB=0 else cB=V end elseif bR~=0 then iB:resetCommand(axisCommandId.longitudinal)ct.cmdThrottle(0)else ct.cmdThrottle(100)end else if iB:getTargetSpeed(axisCommandId.longitudinal)~=0 then iB:resetCommand(axisCommandId.longitudinal)else if cg then ct.cmdCruise(cB)else ct.cmdCruise(a0*3.6)end end end elseif ut=="speedup"then ct.changeSpd()elseif ut=="speeddown"then ct.changeSpd(true)elseif ut=="antigravity"and not r then if antigrav~=nil then ct.ToggleAntigrav()else dl("No antigrav found")end elseif ut=="leftmouse"then c2=true;if c1 then uB()uC=false else c1=true;bk=iC()ui(1)end end end;function ul.stopControl(ut)local function uF()if not r and cQ then uq=uo end;if b7 or bb or bB then up=un end end;if ut=="forward"then bX=0 elseif ut=="backward"then bX=0 elseif ut=="left"then if cX then if cX==2 then cX=-2 else cX=-1 end end;bY=0 elseif ut=="right"then if cX then if cX==4 then cX=-2 else cX=-1 end end;bY=0 elseif ut=="yawright"then bZ=0 elseif ut=="yawleft"then bZ=0 elseif ut=="straferight"then iB:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bA=0 elseif ut=="strafeleft"then iB:updateCommandFromActionStop(axisCommandId.lateral,1.0)bA=0 elseif ut=="up"then ct.vertical(0,-1)elseif ut=="down"then ct.vertical(0,1)elseif ut=="groundaltitudeup"then uF()uC=false elseif ut=="groundaltitudedown"then uF()uC=false elseif ut=="brake"then if not b0 and not p4 then if b2 then ct.BrakeToggle()else b2=false end end elseif ut=="lalt"then if c1 then c1=false end;if iA()==0 and j then if uC then if iC()==1 then ui(0)else ui(1)end else uC=true end elseif iA()==0 and not j and g=="keyboard"then ui(0)end;p4=false end end;function ul.loopControl(ut)local function uG(rg)local rh=1;if rg then rh=-1 end;if not r and cQ then if bx~=nil then bx=bx+rh*uq;if bx<1000 then bx=1000 end;if b7 and bx<bc+10 and bx>bc-10 then bc=bx end;uq=dp(uq*1.05,uo,50)else bx=tQ+rh*100 end elseif b7 or bb or bB then if bB then cD=cD+rh*up;if cD<ku.noAtmosphericDensityAltitude then cD=ku.noAtmosphericDensityAltitude end else bc=bc+rh*up end;up=dp(up*1.05,un,50)else iB:updateTargetGroundAltitudeFromActionLoop(rh*1.0)end end;local function uH(rg)local rh=1;if rg then rh=-1 end;if not c1 then if t and not p4 then bR=dp(bR+rh*aF/100,-1,1)else iB:updateCommandFromActionLoop(axisCommandId.longitudinal,rh*aF)end end end;if ut=="groundaltitudeup"then if not c1 then uG()end elseif ut=="groundaltitudedown"then if not c1 then uG(true)end elseif ut=="speedup"then uH()elseif ut=="speeddown"then uH(true)end end;function ul.inputTextControl(rf)local function uI(uJ,fp,gs)local function uK(fp)local dG=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dH='::pos{'..dG..','..dG..','..dG..','..dG..','..dG..'}'local dX,dY,e4,e5,e6=e7(fp,dH)if dX=="0"and dY=="0"then return vec3(dq(e4),dq(e5),dq(e6))end;e5=math.rad(e5)e4=math.rad(e4)local ku=e[dq(dX)][dq(dY)]local eY=math.cos(e4)local uL=vec3(eY*math.cos(e5),eY*math.sin(e5),math.sin(e4))return ku.center+(ku.radius+e6)*uL end;local fQ=uK(fp)return cs.AddNewLocation(uJ,fQ,gs)end;local M;local uM,ip=nil,nil;local uN="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations.\n".."/trans (whatever) - shows the current transponder setting, whatever, if present, is the new tag that is set.\n".."/pipecenter - Shows a waypoint to closest pipe center and prints loc in lua chat and sets it to 1-Temp in IPH for use with autopilot"M=string.find(rf," ")uM=rf;if M~=nil and string.find(rf,"::")~=1 then uM=string.sub(rf,0,M-1)ip=string.sub(rf,M+1)end;if uM=="/help"or uM=="/commands"then for lo in string.gmatch(uN,"([^\n]+)")do a.print(lo)end;return elseif uM=="/setname"then if ip==nil or ip==""then dl("Usage: ah-setname Newname")return end;if bn>0 and fZ~=nil then cs.UpdatePosition(ip)else dl("Select a saved target to rename first")end elseif shield and uM=="/resist"then cw.setResist(ip)elseif uM=="/addlocation"or string.find(rf,"::pos")~=nil then local gs=false;local uJ="0-Temp"if ip==nil or ip==""or uM~="/addlocation"then ip=uM;gs=true end;M=string.find(ip,"::")if not gs then uJ=string.sub(ip,1,M-2)end;local fp=string.sub(ip,M)fp=fp:gsub("%s+","")uI(uJ,fp,gs)elseif uM=="/agg"then if ip==nil or ip==""then dl("Usage: /agg targetheight")return end;ip=dq(ip)if ip<1000 then ip=1000 end;bx=ip;dl("AGG Target Height set to "..ip)elseif uM=="/G"then if ip==nil or ip==""then dl("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if ip=="dump"then for dO,dA in pairs(iE())do if type(dA.get())=="boolean"then if dA.get()==true then a.print(dO.." true")else a.print(dO.." false")end elseif dA.get()==nil then a.print(dO.." nil")else a.print(dO.." "..dA.get())end end;return end;M=string.find(ip," ")local uO=string.sub(ip,0,M-1)local uP=string.sub(ip,M+1)for dO,dA in pairs(iE())do if dO==uO then local uQ=type(dA.get())if uQ=="number"then uP=dq(uP)if dO=="AtmoSpeedLimit"then cB=uP end end;dl("Variable "..uO.." changed to "..uP)if dO=="MaxGameVelocity"then uP=uP/3.6;if uP>df-0.2 then uP=df-0.2;dl("Variable "..uO.." changed to "..fO(uP*3.6,1))end end;if uQ=="boolean"then if string.lower(uP)=="true"then uP=true else uP=false end end;dA.set(uP)return end end;dl("No such global variable: "..uO)elseif uM=="/deletewp"then if bn>0 and fZ~=nil then cs.ClearCurrentPosition()else dl("Select a custom wp to delete first in IPH")end elseif uM=="/copydatabank"then if dbHud_2 then pG(true)else dl("Spare Databank required to copy databank")end elseif uM=="/iphWP"then if bn>0 then a.print(ct.showWayPoint(c8,bm,true))a.print(json.encode(bm))dl("::pos waypoint shown in lua chat in local and world format")else dl("No target selected in IPH")end elseif uM=="/trans"then if uj then if ip==nil or ip==""then dl("Current tag: "..uk(uj.getTags()))return else uj.setTags({ip})dl("Transponder tag set to: "..ip)end else dl("No transponder found.")end elseif uM=="/createPrivate"then local uR="privatelocations = {\n"local uS=""if#d9>0 then for dO,dA in pairs(d9)do uR=uR.."{position = {x = "..dA.position.x..", y = "..dA.position.y..", z = "..dA.position.z.."},\n ".."name = '"..dA.name.."',\n planetname = '"..dA.planetname.."',\n gravity = "..dA.gravity..",\n"if dA.heading then uR=uR.."heading = {x = "..dA.heading.x..", y = "..dA.heading.y..", z = "..dA.heading.z.."},\n"end;if dA.safe then uR=uR.."safe = true},\n"else uR=uR.."safe = false},\n"end end end;uS=#d9 .."-Private "if ip=="all"then for dO,dA in pairs(br)do uR=uR.."{position = {x = "..dA.position.x..", y = "..dA.position.y..", z = "..dA.position.z.."},\n ".."name = '*"..dA.name.."',\n planetname = '"..dA.planetname.."',\n gravity = "..dA.gravity..",\n"if dA.heading then uR=uR.."heading = {x = "..dA.heading.x..", y = "..dA.heading.y..", z = "..dA.heading.z.."},\n"end;if dA.safe then uR=uR.." safe = true},\n"else uR=uR.."safe = false},\n"end end;uS=uS..#br.."-Public "end;uR=uR.."}\n return privatelocations"if uh then uh.setHTML(uR)end;dl(uS.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")c4=7 elseif uM=="/pipecenter"then if dg~=nil then local fp="::pos{0,0,"..dg["x"]..","..dg["y"]..","..dg["z"].."}"a.setWaypoint(fp)uI("1-PipeCenter",fp,true)fp=cO+dh-dg;fp="::pos{0,0,"..fp["x"]..","..fp["y"]..","..fp["z"].."}"uI("2-PipeParallel",fp,true)else dl("No Pipe Center known")end end end;function ul.tagTick()if bE=="Off"then bE="All"elseif bE=="All"then bE="Longitude"elseif bE=="Longitude"then bE="Lateral"elseif bE=="Lateral"then bE="Vertical"else bE="Off"end;dl("Extra Engine Tags: "..bE)c.stopTimer("tagTick")end;if uT then for dO,dA in pairs(uT)do ul[dO]=dA end end;return ul end;local function uU(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ix,uh,uj)local a=DUSystem;local bP=DUConstruct;local uV=DUPlayer;local uW=DULibrary;local uX={}local dn=string.format;local iy=json.decode;local uk=json.encode;local py=b.getElementMaxHitPointsById;local iz=b.getElementMassById;local iA=d.control.isRemoteControlled;local e7=string.match;local gF=a.destroyWidgetPanel;local fL=a.updateData;local fM=a.addDataToWidget;local ui=a.lockView;local iC=a.isViewLocked;local dr=math.sqrt;local dq=tonumber;local f1=math.abs;local bN=math.floor;local bO=c.getAtmosphereDensity;local eX=math.atan;local bM=a.getArkTime;local dp=utils.clamp;local iB=d.axisCommandManager;local gH=13;local iH=b.getElementIdList()local iI=0;local function ds(eF,eG)if eF==0 then return f1(eG)<1e-09 elseif eG==0 then return f1(eF)<1e-09 else return f1(eF-eG)<math.max(f1(eF),f1(eG))*dF end end;local function fO(dG,uY)local rh=10^(uY or 0)return bN(dG*rh+0.5)/rh end;local function iD(uZ,u_)for dO,dA in pairs(u_)do if type(dO)=="string"then uZ[dO]=dA else uZ[#uZ+1]=u_[dO]end end;return uZ end;local function iE(v0)local v1={}if not v0 then iD(v1,L)iD(v1,ab)iD(v1,aD)iD(v1,a_)return v1 elseif v0=="boolean"then return L elseif v0=="handling"then return ab elseif v0=="hud"then return aD elseif v0=="physics"then return a_ end end;local function dl(sR)if not sR then return end;if c3~="empty"then if not string.find(c3,sR)then c3=c3 .."\n"..sR;c4=7 end else c3=sR end end;local function pG(v2)local function v3(v4)for dO,dA in pairs(v4)do dbHud_1.setStringValue(dO,uk(dA.get()))if v2 and dbHud_2 then dbHud_2.setStringValue(dO,uk(dA.get()))end end end;if dbHud_1 then v3(bJ)v3(iE())a.print("Saved Variables to Datacore")if v2 and dbHud_2 then dl("Databank copied.  Remove copy when ready.")end end end;local function fN(v5,v6,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v5 ..".mp3")end;local function gG(hA,hB,rf,jP,v7)return dn([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jP or"",hA,hB,v7 or"",rf)end;local function iF(cb,v8)v8=v8 or 1;local unit="m"if cb>100000 then cb=cb/200000;unit="su"elseif cb>1000 then cb=cb/1000;unit="km"end;return fO(cb,v8)..unit end;local function iG(v9)local va=0;local vb=0;local vc=0;if v9<60 then v9=bN(v9)elseif v9<3600 then va=bN(v9/60)v9=bN(v9%60)elseif v9<86400 then vb=bN(v9/3600)va=bN(v9%3600/60)else vc=bN(v9/86400)vb=bN(v9%86400/3600)end;if vc>365 then return">1y"elseif vc>0 then return vc.."d "..vb.."h "elseif vb>0 then return vb.."h "..va.."m "elseif va>0 then return va.."m "..v9 .."s"elseif v9>0 then return v9 .."s"else return"0s"end end;local function vd()if radar_1 then cu=gE(b,a,c,radar_1,radar_2,warpdrive,f1,gF,dr,gG,dq,gH,fN,dl)end end;function uX.radarSetup()vd()end;function uX.onStart()local ve=false;local function vf()local function vg(vh)local vi=dbHud_1.hasKey;for dO,dA in pairs(vh)do if vi(dO)then local dJ=iy(dbHud_1.getStringValue(dO))if dJ~=nil then dA.set(dJ)ve=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vg(iE())coroutine.yield()vg(bJ)else vg(bJ)dl("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")c4=5;ve=false end;coroutine.yield()if ve then dl("Loaded Saved Variables")elseif not f then dl("No Databank Saved Variables Found\nVariables will save to Databank on standing")c4=5 end;if#br>0 then da=iD(da,br)end else dl("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;b0=k;g=string.lower(g)cz=q;cB=V;if by+180<bQ then bw=0 end;by=bQ;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then dl("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")c4=7 end;if antigrav and not r then if bx==nil then bx=ci end;antigrav.setTargetAltitude(bx)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d9>0 then da=iD(da,d9)end end;lt="Proceeding to Waypoint"if not a0 or a0<0 then a0=bP.getMaxSpeed()-0.1 end end;local function vj()local function vk(vl,vm)if vl>vm then vm=vl end;local vn,vo=0,0;if a6>0 then vn=a6*0.05 end;if a7>0 then vo=a7*0.05 end;vm=vm*(1-(vn+vo))return vm end;local vp=b.getElementNameById;local vq=at~=0 and au~=0;local vr=_G["atmofueltank_size"]local vs=_G["spacefueltank_size"]local vt=_G["rocketfueltank_size"]for dO in pairs(iH)do local type=b.getElementDisplayNameById(iH[dO])if e7(type,'^.*Atmospheric Engine$')then if e7(tostring(b.getElementTagsById(iH[dO])),'^.*vertical.*$')and b.getElementForwardById(iH[dO])[3]>0 then cP=true end end;if e7(type,'^.*Space Engine$')then cG=true;if e7(tostring(b.getElementTagsById(iH[dO])),'^.*vertical.*$')then local vu=b.getElementForwardById(iH[dO])if vu[3]<0 then vv=true else cF=true end end end;if type=="Landing Gear"then bW=true end;if type=="Dynamic Core Unit"then local pA=py(iH[dO])if pA>10000 then gH=110 elseif pA>1000 then gH=55 elseif pA>150 then gH=27 end end;iI=iI+py(iH[dO])if vq and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pA=py(iH[dO])local f6=iz(iH[dO])local vl=0;local jH=bM()if type=="Atmospheric Fuel Tank"then local vm=400;local vw=35.03;if pA>10000 then vm=51200;vw=5480 elseif pA>1300 then vm=6400;vw=988.67 elseif pA>150 then vm=1600;vw=182.67 end;vl=f6-vw;if a3>0 then vm=vm+vm*a3*0.2 end;vm=vk(vl,vm)local gr=vp(iH[dO])local jF=0;for jG=1,vr do if gr==iy(c["atmofueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vx={iH[dO],string.sub(gr,1,12),vm,vw,vl,jH,jF}cl[#cl+1]=vx end;if type=="Rocket Fuel Tank"then local vm=320;local vw=173.42;if pA>65000 then vm=40000;vw=25740 elseif pA>6000 then vm=5120;vw=4720 elseif pA>700 then vm=640;vw=886.72 end;vl=f6-vw;if a5>0 then vm=vm+vm*a5*0.1 end;vm=vk(vl,vm)local gr=vp(iH[dO])local jF=0;for jG=1,vt do if gr==iy(c["rocketfueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vx={iH[dO],string.sub(gr,1,12),vm,vw,vl,jH,jF}cn[#cn+1]=vx end;if type=="Space Fuel Tank"then local vm=600;local vw=35.03;if pA>10000 then vm=76800;vw=5480 elseif pA>1300 then vm=9600;vw=988.67 elseif pA>150 then vm=2400;vw=182.67 end;vl=f6-vw;if a4>0 then vm=vm+vm*a4*0.2 end;vm=vk(vl,vm)local gr=vp(iH[dO])local jF=0;for jG=1,vs do if gr==iy(c["spacefueltank_"..jG].getWidgetData()).name then jF=jG;break end end;local vx={iH[dO],string.sub(gr,1,12),vm,vw,vl,jH,jF}cm[#cm+1]=vx end end end;if not cP then bb,b1=false,false end end;local function vy()if gyro~=nil then ck=gyro.isActive()==1 end;if not bD then iB:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ui(1)else ui(0)end;if door and(cg or not cg and ci<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(cg or not cg==0 and ci<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;if antigrav then cQ=antigrav.isActive()==1;if cQ and not r then antigrav.showWidget()end end;if iA()==1 and l then uV.freeze(1)else uV.freeze(0)end;if bW then if cf~=-1 and not cQ then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bo=d.control.isAnyLandingGearDeployed()==1 or not bD or cf~=-1 and cf-3<Z;local vz=cJ:len()<30;if cf~=-1 and vA or(not cg or not vA)and vz then b2="Startup"else b2=false end;iB:setTargetGroundAltitude(Z)pm=cg end;local function vB()local vC={}local function vD()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vE={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vF,vG in pairs(e)do e[vF][0]=vD()e[vF][0].systemId=vF;vC[vF]={}for vH,ku in pairs(e[vF])do ku.gravity=ku.gravity/9.8;ku.center=vec3(ku.center)ku.name=ku.name[1]ku.noAtmosphericDensityAltitude=ku.atmosphereThickness;ku.spaceEngineMinAltitude=vE[ku.id]or 0.5353125*ku.atmosphereThickness;ku.planetarySystemId=vF;ku.bodyId=ku.id;vC[vF][vH]=ku;if md==nil or ku.center.x<md then md=ku.center.x end;if mc==nil or ku.center.x>mc then mc=ku.center.x end;if mg==nil or ku.center.y<mg then mg=ku.center.y end;if mf==nil or ku.center.y>mf then mf=ku.center.y end;if ku.center and ku.name~="Space"then d4[#d4+1]=ku end end end;eh=dm(d,b,c,a,dn,dp,dq,dr,ds)co=eh(vC)fR=co[0]cp=f0(d,b,c,a,dr,f1)cq=fl(d,b,c,a,dn,dp,dq,dr,ds)cs=fK(d,b,c,a,dbHud_1,e,fL,fM,bN,dq,dr,fN,fO,dl)ku=co[0]:closestBody(bP.getWorldPosition())end;vI=false;vJ=coroutine.create(function()iB:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vf()coroutine.yield()vj()coroutine.yield()ct=pE(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,f1,bN,bO,iA,eX,bM,dp,iB,fL,iC,dr,fO,fN,iD,ds,iF,iG,pG,iy,dl)vy()coroutine.yield()vB()vd()if iw then cr=iw(d,b,c,a,e,antigrav,hover,shield,warpdrive,ix,f1,bN,dn,iy,bO,iz,iA,eX,bM,dp,iB,fM,fL,gF,iC,dr,fO,gG,fN,iD,iE,iF,iG,iH,iI,dl)end;if cr then cr.ButtonSetup()end;cv=ug(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uh,iA,iB,iC,ui,gF,fO,e7,dq,dp,fN,iE,pG,dl,uj,uk)if shield then cw=ie(shield,e7,bN,dl)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uh then uh.setCenteredText("")end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)bP.setDockingMode(aa)if shield then c.setTimer("shieldTick",0.0166667)end;if vK then vL.ExtraOnStart()end;local function vM()if bI[1]==0 then ct.cmdThrottle(bI[2])else if ch>0 then cB=bI[2]ct.cmdThrottle(1)end end end;ll=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if ll then if cf>-1 and cL<1 and cf-3<Z then c.exit()else if J then vM()else if ch==0 then b2="ECU Braking"elseif cf==-1 then cv.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bI[3]+3>bM()then vM()end;d3=bP.getDockedConstructs()d2=bP.getPlayersOnBoard()local vN;vN=#d2>1 and"Passengers: "..#d2-1 .." "or""vN=vN..(#d3>0 and"Ships: "..#d3 or"")if vN~=""then dl("NOTICE: Docked "..vN)end;fN("start","SU")end)coroutine.resume(vJ)end;function uX.onUpdate()if vI then d:update()if cg and t and cR then if cR and bV then ct.cmdThrottle(0)bV=false elseif not cR and not bV then bR=0;bV=true end end;if d7 then iB:setThrottleCommand(axisCommandId.longitudinal,d7)d7=nil end;if not cx and p6~=vO then a.setScreen(p6)end;vO=p6;if ll and not J and ch>0 and cf==-1 then cv.landingGear()end;if ll and cf>-1 and cL<1 and cf-3<Z then c.exit()end;if vK then vL.ExtraOnUpdate()end else local i4=coroutine.status(vJ)if i4=="suspended"then local dP,i5=coroutine.resume(vJ)if i5 then a.print("ERROR STARTUP: "..i5)end elseif i4=="dead"then vI=true end end end;function uX.onFlush()if vI then ct.onFlush()if vK then vL.ExtraOnFlush()end end end;function uX.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(ch>0 or ch==0 and ci<10000)then for dT,dA in pairs(door)do dA.toggle()end end;if switch then for dT,dA in pairs(switch)do dA.toggle()end end;if forcefield and(ch>0 or ch==0 and ci<10000)then for dT,dA in pairs(forcefield)do dA.toggle()end end;w=d6;local vP=0;if ll then vP=bM()end;if iB:getAxisCommandType(0)==0 then bI={0,bR,vP}else bI={1,iB:getTargetSpeed(axisCommandId.longitudinal),vP}end;pG()if nR then nR.activate()end;if z then ct.showWayPoint(ku,cO)end;if cr then a.print(cr.FuelUsed("atmofueltank")..", "..cr.FuelUsed("spacefueltank")..", "..cr.FuelUsed("rocketfueltank"))end;if vK then vL.ExtraOnStop()end;fN("stop","SU")end;function uX.controlStart(ut)if vI then cv.startControl(ut)end end;function uX.controlStop(ut)if vI then cv.stopControl(ut)end end;function uX.controlLoop(ut)if vI then cv.loopControl(ut)end end;function uX.controlInput(rf)if vI then cv.inputTextControl(rf)end end;function uX.radarEnter(dY)if cu then cu.onEnter(dY)end end;function uX.radarLeave(dY)if cu then cu.onLeave(dY)end end;function uX.onTick(vQ)if vQ=="tenthSecond"then if ct then ct.TenthTick()end;if cr then cr.TenthTick()end elseif vQ=="oneSecond"then if cr then cr.OneSecondTick()end elseif vQ=="msgTick"then if cr then cr.MsgTick()end elseif vQ=="animateTick"then if cr then cr.AnimateTick()end elseif vQ=="hudTick"then if cr then cr.hudtick()end elseif vQ=="apTick"then if ct then ct.APTick()end elseif vQ=="shieldTick"then cw.shieldTick()elseif vQ=="tagTick"then cv.tagTick()elseif vQ=="contact"then cu.ContactTick()end end;if vK then for dO,dA in pairs(vK)do uX[dO]=dA end end;return uX end;function script.onStart()vL.onStart()end;function script.onOnStop()vL.onStop()end;function script.onTick(vQ)vL.onTick(vQ)end;function script.onOnFlush()vL.onFlush()end;function script.onOnUpdate()vL.onUpdate()end;function script.onActionStart(ut)vL.controlStart(ut)end;function script.onActionStop(ut)vL.controlStop(ut)end;function script.onActionLoop(ut)vL.controlLoop(ut)end;function script.onInputText(rf)vL.controlInput(rf)end;function script.onEnter(dY)vL.radarEnter(dY)end;function script.onLeave(dY)vL.radarLeave(dY)end;bL(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vL=uU(d,core,unit,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ix,uh,vR)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
