name: ArchHud - Archaegeo v0.728 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.728;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},DeadZone={set=function(K)au=K end,get=function()return au end},OrbitMapSize={set=function(K)av=K end,get=function()return av end},OrbitMapX={set=function(K)aw=K end,get=function()return aw end},OrbitMapY={set=function(K)ax=K end,get=function()return ax end},soundVolume={set=function(K)ay=K end,get=function()return ay end}}aA=5.0;aB=1.0;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0666667;aQ=0.0;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(K)aA=K end,get=function()return aA end},speedChangeSmall={set=function(K)aB=K end,get=function()return aB end},MouseXSensitivity={set=function(K)aC=K end,get=function()return aC end},MouseYSensitivity={set=function(K)aD=K end,get=function()return aD end},autoRollFactor={set=function(K)aE=K end,get=function()return aE end},rollSpeedFactor={set=function(K)aF=K end,get=function()return aF end},autoRollRollThreshold={set=function(K)aG=K end,get=function()return aG end},minRollVelocity={set=function(K)aH=K end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(K)aI=K end,get=function()return aI end},torqueFactor={set=function(K)aJ=K end,get=function()return aJ end},pitchSpeedFactor={set=function(K)aK=K end,get=function()return aK end},yawSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeSpeedFactor={set=function(K)aM=K end,get=function()return aM end},brakeFlatFactor={set=function(K)aN=K end,get=function()return aN end},DampingMultiplier={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraEscapeThrust={set=function(K)aQ=K end,get=function()return aQ end},ExtraLongitudeTags={set=function(K)aR=K end,get=function()return aR end},ExtraLateralTags={set=function(K)aS=K end,get=function()return aS end},ExtraVerticalTags={set=function(K)aT=K end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={}bC={VertTakeOff={set=function(K)b5=K end,get=function()return b5 end},VertTakeOffEngine={set=function(K)aW=K end,get=function()return aW end},SpaceTarget={set=function(K)bt=K end,get=function()return bt end},BrakeToggleStatus={set=function(K)aV=K end,get=function()return aV end},BrakeIsOn={set=function(K)aX=K end,get=function()return aX end},RetrogradeIsOn={set=function(K)aY=K end,get=function()return aY end},ProgradeIsOn={set=function(K)aZ=K end,get=function()return aZ end},Autopilot={set=function(K)a_=K end,get=function()return a_ end},TurnBurn={set=function(K)b0=K end,get=function()return b0 end},AltitudeHold={set=function(K)b1=K end,get=function()return b1 end},BrakeLanding={set=function(K)b2=K end,get=function()return b2 end},Reentry={set=function(K)b4=K end,get=function()return b4 end},AutoTakeoff={set=function(K)b3=K end,get=function()return b3 end},HoldAltitude={set=function(K)b6=K end,get=function()return b6 end},AutopilotAccelerating={set=function(K)b7=K end,get=function()return b7 end},AutopilotBraking={set=function(K)b9=K end,get=function()return b9 end},AutopilotCruising={set=function(K)ba=K end,get=function()return ba end},AutopilotRealigned={set=function(K)b8=K end,get=function()return b8 end},AutopilotEndSpeed={set=function(K)bb=K end,get=function()return bb end},AutopilotStatus={set=function(K)bc=K end,get=function()return bc end},AutopilotPlanetGravity={set=function(K)bd=K end,get=function()return bd end},PrevViewLock={set=function(K)be=K end,get=function()return be end},AutopilotTargetName={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetCoords={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetIndex={set=function(K)bh=K end,get=function()return bh end},TotalDistanceTravelled={set=function(K)bj=K end,get=function()return bj end},TotalFlightTime={set=function(K)bk=K end,get=function()return bk end},SavedLocations={set=function(K)bl=K end,get=function()return bl end},VectorToTarget={set=function(K)bm=K end,get=function()return bm end},LocationIndex={set=function(K)bn=K end,get=function()return bn end},LastMaxBrake={set=function(K)bo=K end,get=function()return bo end},LockPitch={set=function(K)bp=K end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(K)bq=K end,get=function()return bq end},AntigravTargetAltitude={set=function(K)br=K end,get=function()return br end},LastStartTime={set=function(K)bs=K end,get=function()return bs end},iphCondition={set=function(K)bw=K end,get=function()return bw end},stablized={set=function(K)bx=K end,get=function()return bx end},UseExtra={set=function(K)by=K end,get=function()return by end},SelectedTab={set=function(K)bD=K end,get=function()return bD end},saveRoute={set=function(K)bA=K end,get=function()return bA end},apRoute={set=function(K)bB=K end,get=function()return bB end}}local function bE(a,b,c,bF,bG,bH)bI=bF()bJ=0;bK=0;bL=false;bM=0;bN=false;bO=false;bP=0;bQ=0;bR=0;bS=0;bT=false;bU=false;bV="empty"bW=3;bX=false;bY=0;bZ=0;b_=nil;c0=0;c1=0;c2=0;c3=false;c4=false;c5=false;c6=-1;c7=bH()>0;c8=bH()c9=b.getAltitude()ca=b.getConstructMass()cb=nil;cc=a9;cd=aa;ce={}cf={}cg={}ch=nil;ci=nil;cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=false;cr=false;cs=p;ct=false;cu=U;cv=nil;cw=0;cx=false;cy=false;cz=false;cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cC=vec3(b.getVelocity())cD=vec3(b.getWorldVelocity())cE=vec3(cD):len()cF=vec3(b.getWorldVertical())cG=-cF:dot(cD)cH=vec3(b.getConstructWorldPos())cI=false;cJ=false;cK=true;cL=0;cM=0;cN={}cO=false;cP=50000;cQ=nil;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;cS=false;cT=nil;cU=false;cV=0;cW=nil;cX=nil;cY={}cZ=90;c_=w;d0=nil;d1=nil;d2={}d3={}d4=false;d5=nil;d6=0;d7=false;if shield_1 then d8=bG(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())end end;local function d9(d,b,c,a,da,db,dc,dd,de)local function df(dg)return type(dg)=='number'end;local function dh(dg)return type(dc(dg))=='number'end;local function di(dj)return type(dj)=='table'end;local function dk(a)return type(a)=='string'end;local function dl(dm)return di(dm)and df(dm.x and dm.y and dm.z)end;local function dn(dp)return di(dp)and df(dp.latitude and dp.longitude and dp.altitude and dp.id and dp.systemId)end;local dq=math.pi/180;local dr=180/math.pi;local ds=1e-10;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local utils=utils;local vec3=vec3;local function dv(dg)local dw=string.gsub(string.reverse(da('%.4f',dg)),'^0*%.?','')return dw==''and'0'or string.reverse(dw)end;local function dx(dy)if dl(dy)then return da('{x=%.3f,y=%.3f,z=%.3f}',dy.x,dy.y,dy.z)end;if di(dy)and not getmetatable(dy)then local dz={}local dA=next(dy)if type(dA)=='nil'or dA==1 then dz=dy else for dB,dm in pairs(dy)do local dC=dx(dm)if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end end;return da('{%s}',table.concat(dz,','))end;if dk(dy)then return da("'%s'",dy:gsub("'",[[\']]))end;return tostring(dy)end;local dD={}dD.__index=dD;dD.__tostring=function(dy,dE)local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)local dz={}for dG,dB in ipairs(dF)do local dC=dx(dy[dB])if type(dB)=='number'then table.insert(dz,da('[%s]=%s',dB,dC))else table.insert(dz,da('%s=%s',dB,dC))end end;if dE then return da('%s%s',dE,table.concat(dz,',\n'..dE))end;return da('{%s}',table.concat(dz,','))end;dD.__eq=function(dH,dI)return dH.systemId==dI.systemId and dH.id==dI.id and de(dH.radius,dI.radius)and de(dH.center.x,dI.center.x)and de(dH.center.y,dI.center.y)and de(dH.center.z,dI.center.z)and de(dH.GM,dI.GM)end;local function dJ(dK,dL,dM,dN,dO)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dM),'Argument 3 (radius) must be a number:'..type(dM))assert(di(dN),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dN))assert(dh(dO),'Argument 5 (GM) must be a number:'..type(dO))return setmetatable({systemId=dc(dK),id=dc(dL),radius=dc(dM),center=vec3(dN),GM=dc(dO)},dD)end;local dP={}dP.__index=dP;dP.__tostring=function(dQ)return da('::pos{%d,%d,%s,%s,%s}',dQ.systemId,dQ.id,dv(dQ.latitude*dr),dv(dQ.longitude*dr),dv(dQ.altitude))end;dP.__eq=function(dH,dI)return dH.id==dI.id and dH.systemId==dI.systemId and de(dH.latitude,dI.latitude)and de(dH.altitude,dI.altitude)and(de(dH.longitude,dI.longitude)or de(dH.latitude,math.pi/2)or de(dH.latitude,-math.pi/2))end;local function dR(dS,dL,dT,dU,dV)local dK=dS;if dk(dS)and not dU and not dV and not dL and not dT then dK,dL,dT,dU,dV=dW(dS,du)assert(dK,'Argument 1 (position string) is malformed.')else assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(dT),'Argument 3 (latitude) must be in degrees:'..type(dT))assert(dh(dU),'Argument 4 (longitude) must be in degrees:'..type(dU))assert(dh(dV),'Argument 5 (altitude) must be in meters:'..type(dV))end;dK=dc(dK)dL=dc(dL)dT=dc(dT)dU=dc(dU)dV=dc(dV)if dL==0 then return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=dL,systemId=dK},dP)end;return setmetatable({latitude=dq*db(dT,-90,90),longitude=dq*(dU%360),altitude=dV,id=dL,systemId=dK},dP)end;local dX={}dX.__index=dX;dX.__tostring=function(dy,dE)local dY=dE and dE..'  'local dZ={}local dF={}for dB in pairs(dy)do table.insert(dF,dB)end;table.sort(dF)for dG,d_ in ipairs(dF)do e0=dy[d_]local e1=dD.__tostring(e0,dY)if dE then table.insert(dZ,da('[%s]={\n%s\n%s}',d_,e1,dE))else table.insert(dZ,da('  [%s]=%s',d_,e1))end end;if dE then return da('\n%s%s%s',dE,table.concat(dZ,',\n'..dE),dE)end;return da('{\n%s\n}',table.concat(dZ,',\n'))end;local function e2(e3)local e={}local pid;for dG,dm in pairs(e3)do local dL=dm.planetarySystemId;if type(dL)~='number'then error('Invalid planetary s ID: '..tostring(dL))elseif pid and dL~=pid then error('Mistringmatch planetary s IDs: '..dL..' and '..pid)end;local e4=dm.bodyId;if type(e4)~='number'then error('Invalid body ID: '..tostring(e4))elseif e[e4]then error('Duplicate body ID: '..tostring(e4))end;setmetatable(dm.center,getmetatable(vec3.unit_x))e[e4]=setmetatable(dm,dD)pid=dL end;return setmetatable(e,dX)end;e5={}local function e6(e3)return setmetatable({galaxyAtlas=e3 or{}},e5)end;e5.__index=function(dj,K)if type(K)=='number'then local a=dj.galaxyAtlas[K]return e2(a)end;return rawget(e5,K)end;e5.__pairs=function(dy)return function(dj,dB)local e7,e8=next(dj,dB)return e7,e8 and e2(e8)end,dy.galaxyAtlas,nil end;e5.__tostring=function(dy)local e9={}for dG,ea in pairs(dy or{})do local eb=ea:getPlanetarySystemId()local ec=dX.__tostring(ea,'    ')table.insert(e9,da('  [%s]={%s\n  }',eb,ec))end;return da('{\n%s\n}\n',table.concat(e9,',\n'))end;e5.BodyParameters=dJ;e5.MapPosition=dR;e5.PlanetarySystem=e2;function e5.createBodyParameters(dK,dL,ed,ee,ef,eg,eh)assert(dh(dK),'Argument 1 (systemId) must be a number:'..type(dK))assert(dh(dL),'Argument 2 (id) must be a number:'..type(dL))assert(dh(ed),'Argument 3 (surfaceArea) must be a number:'..type(ed))assert(di(ee),'Argument 4 (aPosition) must be an array or vec3:'..type(ee))assert(di(ef),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ef))assert(dh(eg),'Argument 6 (altitude) must be in meters:'..type(eg))assert(dh(eh),'Argument 7 (gravityAtPosition) must be number:'..type(eh))local dM=dd(ed/4/math.pi)local c2=dM+eg;local ei=vec3(ee)+c2*vec3(ef)local dO=eh*c2*c2;return dJ(dK,dL,dM,ei,dO)end;e5.isMapPosition=dn;function e5:getPlanetarySystem(dS)if K==nil then K=0 end;if e8==nil then e8=0 end;local dK=dS;if dn(dS)then dK=dS.systemId end;if type(dK)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(e8)~=dX then a=e2(a)end;return a end end end;function dX:sizeCalculator(ej)return 1.05*ej.radius end;function dX:castIntersections(ek,el,em,en,eo,ep)local eq={}if eo then for dG,ej in pairs(eo)do table.insert(eq,ej)end else eq=cY end;if not ep then table.sort(eq,function(er,es)local et=er.center;local eu=es.center;return(et.x-ek.x)^2+(et.y-ek.y)^2+(et.z-ek.z)^2<(eu.x-ek.x)^2+(eu.y-ek.y)^2+(eu.z-ek.z)^2 end)end;local ev=el:normalize()for dG,ej in ipairs(eq)do local ew=ej.center-ek;local dM=self:sizeCalculator(ej)local ex=ew:dot(ev)local ey=ex^2-(ew:len2()-dM^2)if ey>=0 then local ez=dd(ey)local eA=ex+ez;local eB=ex-ez;if eB>0 then return ej,eA,eB elseif eA>0 then return ej,eA,nil end end end;return nil,nil,nil end;function dX:closestBody(eC)assert(type(eC)=='table','Invalid coordinates.')local eD,ej;local eE=vec3(eC)for dG,eF in pairs(self)do local eG=(eF.center-eE):len2()if(not ej or eG<eD)and eF.name~="Space"then ej=eF;eD=eG end end;return ej end;function dX:convertToBodyIdAndWorldCoordinates(dS)local eH=dS;if dk(dS)then eH=dR(dS)end;if eH.id==0 then return 0,vec3(eH.latitude,eH.longitude,eH.altitude)end;local eF=self:getBodyParameters(eH)if eF then return eH.id,eF:convertToWorldCoordinates(eH)end end;function dX:getBodyParameters(dS)local dL=dS;if dn(dS)then dL=dS.id end;assert(dh(dL),'Argument 1 (id) must be a number:'..type(dL))return self[dL]end;function dX:getPlanetarySystemId()local dG,dm=next(self)return dm and dm.systemId end;function dD:convertToMapPosition(dN)assert(di(dN),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dN))local eI=vec3(dN)if self.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=self.systemId},dP)end;local eJ=eI-self.center;local c2=eJ:len()local dV=c2-self.radius;local dT=0;local dU=0;if not de(c2,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c2)end;return setmetatable({latitude=dT,longitude=dU,altitude=dV,id=self.id,systemId=self.systemId},dP)end;function dD:convertToWorldCoordinates(dS)local eH=dk(dS)and dR(dS)or dS;if eH.id==0 then return vec3(eH.latitude,eH.longitude,eH.altitude)end;assert(dn(eH),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eH.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eH.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eM=math.cos(eH.latitude)return self.center+(self.radius+eH.altitude)*vec3(eM*math.cos(eH.longitude),eM*math.sin(eH.longitude),math.sin(eH.latitude))end;function dD:getAltitude(dN)return(vec3(dN)-self.center):len()-self.radius end;function dD:getDistance(dN)return(vec3(dN)-self.center):len()end;function dD:getGravity(dN)local eN=self.center-vec3(dN)local eO=eN:len2()return self.GM/eO*eN/dd(eO)end;return setmetatable(e5,{__call=function(dG,...)return e6(...)end})end;local function eP(d,b,c,a,dd,eQ)local ci={}local eR=30000000/3600;local eS=eR*eR;local eT=100;function ci.computeAccelerationTime(eU,eV,eW)local eX=eR*math.asin(eU/eR)return(eR*math.asin(eW/eR)-eX)/eV end;function ci.computeDistanceAndTime(eU,eW,eY,eZ,e_,f0)e_=e_ or 0;f0=f0 or 0;local f1=eU<=eW;local f2=eZ*(f1 and 1 or-1)/eY;local f3=-f0/eY;local f4=f2+f3;if f1 and f4<=0 or not f1 and f4>=0 then return-1,-1 end;local f5,f6=0,0;if f2~=0 and e_>0 then local eX=math.asin(eU/eR)local f7=math.pi*(f2/2+f3)local f8=f2*e_;local f9=eR*math.pi;local dm=function(dj)local fa=(f7*dj-f8*math.sin(math.pi*dj/2/e_)+f9*eX)/f9;local fb=math.tan(fa)return eR*fb/dd(fb*fb+1)end;local fc=f1 and function(a)return a>=eW end or function(a)return a<=eW end;f6=2*e_;if fc(dm(f6))then local fd=0;while eQ(f6-fd)>0.5 do local dj=(f6+fd)/2;if fc(dm(dj))then f6=dj else fd=dj end end end;local fe=eU;local ff=f6/eT;for fg=1,eT do local fh=dm(fg*ff)f5=f5+(fh+fe)*ff/2;fe=fh end;if f6<2*e_ then return f5,f6 end;eU=fe end;local eX=eR*math.asin(eU/eR)local bI=(eR*math.asin(eW/eR)-eX)/f4;local fi=eS*math.cos(eX/eR)/f4;local c2=fi-eS*math.cos((f4*bI+eX)/eR)/f4;return c2+f5,bI+f6 end;function ci.computeTravelTime(eU,eV,c2)if c2==0 then return 0 end;if eV>0 then local eX=eR*math.asin(eU/eR)local fi=eS*math.cos(eX/eR)/eV;return(eR*math.acos(eV*(fi-c2)/eS)-eX)/eV end;if eU==0 then return-1 end;assert(eU>0,'Acceleration and initial speed are both zero.')return c2/eU end;return ci end;local function fj(d,b,c,a,da,db,dc,dd,de)local vec3=vec3;local d9=d9(d,b,c,a,da,db,dc,dd,de)local function dk(a)return type(a)=='string'end;local function di(dj)return type(dj)=='table'end;fk={}fk.__index=fk;function fk:escapeAndOrbitalSpeed(dV)assert(self.body)local c2=dV+self.body.radius;if not de(c2,0)then local fl=dd(self.body.GM/c2)return dd(2)*fl,fl end;return nil,nil end;function fk:orbitalParameters(dS,fm)assert(self.body)assert(di(dS)or dk(dS))assert(di(fm))local fn=(dk(dS)or d9.isMapPosition(dS))and self.body:convertToWorldCoordinates(dS)or vec3(dS)local dm=vec3(fm)local fo=fn-self.body.center;local fp=dm:len2()local fq=fo:len()local fr=self.body.GM;local fs=((fp-fr/fq)*fo-fo:dot(dm)*dm)/fr;local et=fr/(2*fr/fq-fp)local ft=fs:len()local ev=fs:normalize()local fu=et*(1-ft)local fv=et*(1+ft)local fw=fu*ev+self.body.center;local fx=ft<=1 and-fv*ev+self.body.center or nil;local fy=dd(et*fr*(1-ft*ft))local fz=fx and 2*math.pi*dd(et^3/fr)local fA=math.acos(fs:dot(fo)/(ft*fq))if fo:dot(dm)<0 then fA=-(fA-2*math.pi)end;local fB=math.acos((math.cos(fA)+ft)/(1+ft*math.cos(fA)))local fC=fB;if fC<0 then fC=fC+2*math.pi end;local fD=fC-ft*math.sin(fC)local fE=0;local fF=0;local fG=0;if fz~=nil then fE=fD/(2*math.pi/fz)fF=fz-fE;fG=fF+fz/2;if fA-math.pi>0 then fF=fE;fG=fF+fz/2 end;if fG>fz then fG=fG-fz end end;return{periapsis={position=fw,speed=fy/fu,circularOrbitSpeed=dd(fr/fu),altitude=fu-self.body.radius},apoapsis=fx and{position=fx,speed=fy/fv,circularOrbitSpeed=dd(fr/fv),altitude=fv-self.body.radius},currentVelocity=dm,currentPosition=fn,eccentricity=ft,period=fz,eccentricAnomaly=fB,meanAnomaly=fD,timeToPeriapsis=fF,timeToApoapsis=fG,trueAnomaly=fA}end;local function fH(fI)local eF=d9.BodyParameters(fI.systemId,fI.id,fI.radius,fI.center,fI.GM)return setmetatable({body=eF},fk)end;return setmetatable(fk,{__call=function(dG,...)return fH(...)end})end;local function fJ(d,b,c,a,dbHud_1,e,fK,fL,bG,dc,dd,fM,fN)local function fO(fP)local dQ=fQ:closestBody(fP)if(fP-dQ.center):len()>dQ.radius+dQ.noAtmosphericDensityAltitude then dQ=e[0][0]end;return dQ end;local function fR()local function fS(fT,fU)return fT.name<fU.name end;cN={}for dB,dm in pairs(e[0])do cN[#cN+1]={name=dm.name,index=dB}end;table.sort(cN,fS)end;local function fV(fW,fX)if not fX then fX=fY.name end;for dB,dm in pairs(fW)do if dm.name and dm.name==fX then return dB end end;return-1 end;local function fZ()cV=bh;if bh==0 then bf="None"b_=nil;fY=nil;return true end;local f_=cN[bh].index;local g0=e[0][f_]if g0.center then bf=g0.name;b_=ch[0][f_]if fY~=nil then if c8==0 then if fK(g1,g2)~=1 then fL(g1,g2)end;if fK(g3,g4)~=1 then fL(g3,g4)end;if fK(g5,g6)~=1 then fL(g5,g6)end;if fK(g7,g8)~=1 then fL(g7,g8)end;if fK(g9,ga)~=1 then fL(g9,ga)end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end;if fK(gf,gg)~=1 then fL(gf,gg)end end;fY=nil else fY=g0;for dG,dm in pairs(ch[0])do if dm.name==fY.planetname then b_=dm;bf=fY.name;break end end;if fK(gb,gc)~=1 then fL(gb,gc)end;if fK(gd,ge)~=1 then fL(gd,ge)end end;if fY==nil then bg=vec3(b_.center)else bg=fY.position end;if b_.planetname~="Space"then if b_.hasAtmosphere then gh=bG(b_.radius*(S-1)+b_.noAtmosphericDensityAltitude)else gh=bG(b_.radius*(S-1)+b_.surfaceMaxAltitude)end else gh=R end;if fY~=nil and fY.planetname=="Space"then bb=0 else dG,bb=cj(b_):escapeAndOrbitalSpeed(gh)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gi(gj)if not a_ and not bm and not c4 and not bv and not b4 and not c5 then if gj==nil then bh=bh+1;if bh>#cN then bh=0 end else bh=bh-1;if bh<0 then bh=#cN end end;if bh==0 then fZ()else local f_=cN[bh].index;local g0=e[0][f_]if g0 and(g0~=nil and g0.name=="Space"or bw=="Custom Only"and g0.center or bw=="No Moons"and string.find(g0.name,"Moon")~=nil)then if gj==nil then gi()else gi(1)end else fZ()end end else bV="Disengage autopilot before changing Interplanetary Helper"fM("iph","AP")end end;local function gk()local function gl(gm)local gn;if gm then gn=d2 else gn=bl end;local go=-1;go=fV(e[0])if go>-1 then table.remove(e[0],go)end;go=-1;go=fV(gn)if go~=-1 then bV=fY.name.." saved location cleared"table.remove(gn,go)end;gi()fR()return gn end;if string.sub(bf,1,1)=="*"then d2=gl(true)else bl=gl(false)end end;local function gp(gq,fP,gr,gs)local function gt(gm)if gm then gn=d2 else gn=bl end;if dbHud_1 or gr or gm then local dQ=fO(fP)local gu={position=fP,name=gq,planetname=dQ.name,gravity=b.g(),safe=gs}if not gr then gn[#gn+1]=gu else for dB,dm in pairs(e[0])do if dm.name and gq==dm.name then table.remove(e[0],dB)end end end;table.insert(e[0],gu)fR()fZ()bV="Location saved as "..gq.."("..dQ.name..")"return gn else bV="Databank must be installed to save permanent locations"end end;if string.sub(gq,1,1)=="*"then d2=gt(true)else bl=gt(false)end end;local gv={}function gv.UpdateAtlasLocationsList()fR()end;function gv.UpdateAutopilotTarget()fZ()end;function gv.adjustAutopilotTargetIndex(gj)gi(gj)end;function gv.findAtlasIndex(fW,fX)return fV(fW,fX)end;function gv.UpdatePosition(gw,gx,gy)local function gz(gm)local gn;if gm then gn=d2 else gn=bl end;local go=fV(gn)if go~=-1 then if gw~=nil then if gm then gw="*"..gw end;gn[go].name=gw;bh=bh-1;gi()elseif gy~=nil then if gy then local gA=c9;if gA<1000 then gA=1000 end;gn[go].agg=fN(gA,0)bV=gn[go].name.." AGG Altitude:"..gn[go].agg.." saved ("..gn[go].planetname..")"return elseif gy==false then gn[go].agg=nil;bV=gn[go].name.." AGG Altitude cleared ("..gn[go].planetname..")"return end else local gB=gn[go]if gx then gB.heading=cB:cross(cF)*5000;bV=gn[go].name.." heading saved ("..gn[go].planetname..")"return elseif gx==false then gB.heading=nil;bV=gn[go].name.." heading cleared ("..gn[go].planetname..")"return end;gB.gravity=b.g()gB.position=cH;gB.safe=true end;bV=gn[go].name.." position updated ("..gn[go].planetname..")"else bV="Name Not Found"end end;if string.sub(bf,1,1)=="*"then gz(true)else gz(false)end end;function gv.AddNewLocation(gq,fP,gr,gs)gp(gq,fP,gr,gs)end;function gv.ClearCurrentPosition()gk()end;for dB,dm in pairs(d3)do table.insert(e[0],dm)end;if gC then for dB,dm in pairs(gC)do gv[dB]=dm end end;fR()if bh>#cN then bh=0 end;gv.UpdateAutopilotTarget()return gv end;local function gD(b,a,c,library,radar_1,radar_2,eQ,gE,dd,gF,dc,gG,fM)local gH={}local gI={}local gJ={XS=13,S=27,M=55,L=110,XL=221}local gK={}local gL=0;local gM;local gN;local gO;local gP;local gQ={}local gR="Atmo"local gS;local gT;local gU=0;local gV={}local function gW()local function gX(gY,gZ,g_,h0,h1,h2,h3,h4)gZ,h0,h2,h4=vec3(gZ),vec3(h0),vec3(h2),vec3(h4)local h5,h6,h7=gY*gY,g_*g_,h1*h1;local fp=h0-gZ;local h8=fp:normalize()local h9=fp:len()local ha=h2-gZ;local hb=(ha-ha:project_on(h8)):normalize()local hc,hd=ha:dot(h8),ha:dot(hb)local he=hc*hc+hd*hd;local hf=h8:cross(hb)local hg=(h5-h6+h9*h9)/(2*h9)local hh=(h5-h7+he-2*hc*hg)/(2*hd)local dp=h5-hg^2-hh^2;local hi=dd(dp)local hj=gZ+h8*hg+hb*hh+hf*hi;local hk=gZ+h8*hg+hb*hh-hf*hi;if eQ((h4-hj):len()-h3)<eQ((h4-hk):len()-h3)then return hj else return hk end end;local function hl(hm,fq,hn)local ho=hm.pts;local go=#ho;local hp=hm.ref;if go>3 then local hq,hr,hs,ht=ho[go],ho[go-1],ho[go-2],ho[go-3]hm.ref=hn;local fn=gX(hq[1],hq[2],hr[1],hr[2],hs[1],hs[2],ht[1],ht[2])local hg,hh,hi=fn.x,fn.y,fn.z;if hg==hg and hh==hh and hi==hi then hg=hg+hp[1]hh=hh+hp[2]hi=hi+hp[3]local hu=vec3(hg,hh,hi)hm.center=hu;if hm.lastPos then if(hm.lastPos-hu):len()<2 then local hv=(hu-vec3(hn)):len()if eQ(hv-fq)<10 then hm.skipCalc=true end end end;hm.lastPos=hu end;hm.pts={}else local hw={hn[1]-hp[1],hn[2]-hp[2],hn[3]-hp[3]}ho[go+1]={fq,hw}end end;if radar_1 or radar_2 then cn.assignRadar()end;if gQ[1]then gL=#gQ[1].getConstructIds()local hx=gQ[1].getData()local hy=hx:gmatch('{"constructId[^}]*}[^}]*}')if gL>0 then local hn={cH["x"],cH["y"],cH["z"]}local hz,hA=0,0;gP,gO=0,0;for dm in hy do local dL,c2,hB=dm:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hC=gJ[hB]c2=dc(c2)if gQ[1].hasMatchingTransponder(dL)==1 then table.insert(gI,dL)end;if E then local hD=gQ[1].getConstructType(dL)if hC>27 or F or hD=="static"or hD=="space"then gP=gP+1;local gq=gQ[1].getConstructName(dL)local hm=gV[dL]if hm==nil then hC=hC+gG;gV[dL]={pts={},ref=hn,name=gq,i=0,radius=hC,skipCalc=false}hm=gV[dL]end;if not hm.skipCalc then hl(hm,c2,hn)if F and not hm.abandoned and gQ[1].isConstructAbandoned(dL)==1 and hm.center then fM("abRdr","RD")a.print("Abandoned Construct: "..gq.." ("..hD..") rough ::pos{0,0,"..hm.center.x..","..hm.center.y..","..hm.center.z.."}")bV="Abandoned Radar Contact ("..hD..") detected"hm.abandoned=true end;hA=hA+1 else table.insert(gK,hm)end end;hz=hz+1;if cR and hz>700 or hA>70 or(not cR and hz>300 or hA>30)then coroutine.yield()hz,hA=0,0 end end end;gO=#gK;if gO>0 and(cE>20 or b2)then local ej,hE,hF,hG;local hH=0;local hI=ch:getPlanetarySystem(0)hG=cD:normalize()while hH<gO do coroutine.yield()local hJ={table.unpack(gK,hH,math.min(hH+75,gO))}ej,hE,hF=hI:castIntersections(cH,hG,nil,nil,hJ,true)if ej and hF then cT={ej,hE,hF}break end;hH=hH+75 end;if not ej then cT=nil end else cT=nil end;gK={}gM=hx:find('identifiedConstructs":%[%]')else gN=hx:find('worksInEnvironment":false')end end end;local function hK()if gQ[1]then gR="Atmo"if gQ[1].getData():find('worksInAtmosphere":false')then gR="Space"end end end;function gH.pickType()hK()end;function gH.assignRadar()if radar_1 and gQ[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gQ[1]=radar_2 end;if gQ[1]==radar_2 then hK()end elseif radar_2 and gQ[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gQ[1]=radar_1 end;if gQ[1]==radar_1 then hK()end end end;function gH.UpdateRadar()local hL=coroutine.status(gS)if hL=="suspended"then local dC,hM=coroutine.resume(gS)if hM then a.print("ERROR UPDATE RADAR: "..hM)end elseif hL=="dead"then gS=coroutine.create(gW)local dC,hM=coroutine.resume(gS)end end;function gH.GetRadarHud(hN,hO,hP,hQ)local hR=gI;local hS,hT;gI={}local dt=gO or 0;if gL>0 then if E then hT=dt.."/"..gP.." Plotted : "..gL-gP.." Ignored"else hT="Radar Contacts: "..gL end;hS=gF(hP,hQ,hT,"pbright txtbig txtmid")if#gI>0 then hS=hS..gF(hN,hO,"Friendlies In Range","pbright txtbig txtmid")for dB,dm in pairs(gI)do hO=hO+20;hS=hS..gF(hN,hO,gQ[1].getConstructName(dm),"pdim txtmid")end end;if gM==nil and gT==nil then gU=1;cn.ToggleRadarPanel()end;if gM~=nil and gT~=nil then cn.ToggleRadarPanel()end;if d1==nil then cn.ToggleRadarPanel()end else if gN then hS=gF(hP,hQ,gR.." Radar: Jammed","pbright txtbig txtmid")else hS=gF(hP,hQ,"Radar: No "..gR.." Contacts","pbright txtbig txtmid")end;if d1~=nil then gU=0;cn.ToggleRadarPanel()end end;return hS end;function gH.GetClosestName(gq)if gQ[1]then local dL,dG=gQ[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dL~=nil and dL~=""then gq=gq.." "..gQ[1].getConstructName(dL)end end;return gq end;function gH.ToggleRadarPanel()if d1~=nil and gU==0 then gE(d1)d1=nil;if gT~=nil then gE(gT)gT=nil end else if gU==1 then gE(d1)d1=nil;_autoconf.displayCategoryPanel(gQ,1,"Periscope","periscope")gT=_autoconf.panels[_autoconf.panels_size]end;if d1==nil then _autoconf.displayCategoryPanel(gQ,1,"Radar","radar")d1=_autoconf.panels[_autoconf.panels_size]end;gU=0 end end;function gH.ContactTick()if not hU then hU=0 end;if bI>hU+10 then bV="Radar Contact"fM("rdrCon","RC")hU=bI end;c.stopTimer("contact")end;function gH.onEnter(dL)if radar_1 and not c7 and not cO then c.setTimer("contact",0.1)end end;function gH.onLeave(dL)if radar_1 and E then if#gV>650 then dL=tostring(dL)gV[dL]=nil end end end;gQ[1]=nil;if radar_1 then gQ[1]=radar_1;hK()end;gS=coroutine.create(gW)if hV then for dB,dm in pairs(hV)do gH[dB]=dm end end;return gH end;local function hW(shield_1,dW,bG)local hX={}local hY=shield_1.getResistancesCooldown()local function hZ()local h_=shield_1.getState()if G then if not cO and h_==0 then shield_1.toggle()elseif cO and h_==1 then shield_1.toggle()end end end;local function i0()local i1=shield_1.getStressRatioRaw()local i2=0.5999;if i1[1]==0.0 and i1[2]==0.0 and i1[3]==0.0 and i1[4]==0.0 then return end;local i3=shield_1.setResistances(i2*i1[1],i2*i1[2],i2*i1[3],i2*i1[4])if i3==1 then bV="Shield Resistances updated"else bV="Value Exceeded. Failed to update Shield Resistances"end end;function hX.shieldTick()d8=bG(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())hZ()hY=shield_1.getResistancesCooldown()if hY==0 and d8<a7 then i0()end end;function hX.setResist(i4)if not shield_1 then bV="No shield found"return elseif i4==nil or hY>0 then bV="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du=dt..', '..dt..', '..dt..', '..dt;local i5,i6,i7,i8=dW(i4,du)if i8==nil or i5+i6+i7+i8>0.6 then bV="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(i5,i6,i7,i8)==1 then bV="Shield Resistances set"else bV="Resistance setting failed."end end;function hX.ventShield()local i9=shield_1.getVentingCooldown()if i9>0 then bV="Cannot vent again for "..i9 .." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()bV="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bV="Shields already at max hitpoints"end end;if ia then for dB,dm in pairs(ia)do hX[dB]=dm end end;return hX end;local function ib(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ic,eQ,bG,da,id,bH,ie,ig,eL,bF,db,ih,fL,fK,gE,ii,dd,fN,gF,fM,ij,ik,il,im,io,ip)local iq=9.80665;local ir={}local is={}local it={}local iu={}local iv=nil;local iw=nil;local ix=nil;local iy=false;local iz="none"local iA=""local iB=55;local iC=0;local iD=0;local iE=""local iF=nil;local iG=ac;local iH=ad;local iI=ae;local iJ=[[rgb(]]..bG(iG+0.5)..","..bG(iH+0.5)..","..bG(iI+0.5)..[[)]]local iK=[[rgb(]]..bG(iG*0.9+0.5)..","..bG(iH*0.9+0.5)..","..bG(iI*0.9+0.5)..[[)]]local iL=0;local iM=0;local iN=""local iO=bF()local iP=false;local iQ=vec3({13771471,7435803,-128971})local iR=18000000;local iS=500000;local iT,iU=math.huge;local iV;local function iW(iX)iT=vec3(iX):dist(iQ)if iT<iR then return true,eQ(iT-iR)end;iU=vec3(iX):dist(vec3(iY.center))if iU<iS then iV=true else iV=false end;if eQ(iU-iS)<eQ(iT-iR)then return iV,eQ(iU-iS)else return iV,eQ(iT-iR)end end;local function iZ(dm)if cc==1920 then return dm else return fN(cc*dm/1920,0)end end;local function i_(dm)if cd==1080 then return dm else return fN(cd*dm/1080,0)end end;local function j0()return ii()==0 and g~="keyboard"and ig()==0 end;local function j1()local j2="TRAVEL"if not cK then j2="CRUISE"end;if a_ then j2="AUTOPILOT"end;return j2 end;local hS=""local j3=""local j4=""local j5=1;local j6=2;local j7=3;local j8=4;local j9=5;local ja=6;local jb=7;local jc=""local jd=0;local je=120.0*aP;local jf={}local jg={}local jh={}local ji={}local jj={}local jk={}local jl={}jl["atmofueltank"],jl["spacefueltank"],jl["rocketfueltank"]=0,0,0;local jm=0;local function jn(hg,jo,jp,jq,jr,js)local jt=jm;local ju=jm+5;if not B then ju=ju+5 end;if ig()==1 and not l then jt=jt-50;ju=ju-50 end;if jp=="ATMO"then jc="atmofueltank"elseif jp=="SPACE"then jc="spacefueltank"else jc="rocketfueltank"end;jd=_G[jc.."_size"]if#jq>0 then for K=1,#jq do local gq=jq[K][j6]local jv=jq[K][jb]for jw=1,jd do if jq[K][j6]==id(c[jc.."_"..jw].getData()).name then jv=jw;break end end;local jx=bF()if jr[K]==nil or js[K]==nil or jx-jq[K][ja]>je then local jy;local jz=0;jz=ie(jq[K][j5])-jq[K][j8]jy=jq[K][j9]if jy>jz then jl[jc]=jl[jc]+jy-jz end;if jv~=0 then local jA=id(c[jc.."_"..jv].getData())js[K]=jA.percentage;jr[K]=jA.timeLeft;if jr[K]=="n/a"then jr[K]=0 end else js[K]=bG(0.5+jz*100/jq[K][j7])if jy<=jz then jr[K]=0 else jr[K]=bG(0.5+jz/((jy-jz)/(jx-jq[K][ja])))end end;jq[K][ja]=jx;jq[K][j9]=jz end;if gq==jo then gq=da("%s %d",jp,K)end;if jv==0 then gq=gq.." *"end;local jB;if jr[K]==0 then jB=""else jB=im(jr[K])end;if js[K]~=nil then local jC=bG(js[K]*2.55)local jD=da("rgb(%d,%d,%d)",255-jC,jC,0)local jE=""if jB~=""and jr[K]<120 or js[K]<5 then jE="red "end;local jF=da("rgb(%d,%d,%d)",db(bG((255-jC)/2.55),50,100),db(bG(jC/2.55),0,50),50)local jG="rgb(196,0,255)"if jp=="ATMO"then jG="rgb(0,188,255)"elseif jp=="SPACE"then jG="rgb(239,255,0)"end;local jH=false;if jI~=jG then jH=true end;jI=jG;if B then if jH then jt=jt-5;ju=ju-5 end;j3=j3 ..da([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jF,jG,hg,ju,jD,bG(js[K]*1.7+0.5)-2,hg+1,ju+1,hg+5,ju+14,gq,js[K],jB)jt=jt-22;ju=ju-22 else j3=j3 ..gF(hg,jt,gq,jE.."pdim txtfuel")j3=j3 ..gF(hg,ju,da("%d%% %s",js[K],jB),"pdim txtfuel","fill:"..jD)jt=jt+30;ju=ju+30 end end end end;jm=jt end;local function jJ(jK,dV)if am==0 and an==0 then return end;if dV<200000 and not c7 or dV and c7 then local jL=0;if eQ(cG)>1 then jL=45*math.log(eQ(cG),10)if cG<0 then jL=-jL end end;jK[#jK+1]=da([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bG(cG),bG(jL))end;return jK end;local function jM(jN)local gj=-cF;jN=jN-jN:project_on(gj)local jO=vec3(0,0,1)jO=jO-jO:project_on(gj)local jP=jO:cross(gj)local jL=jO:angle_between(jN)*constants.rad2deg;if jN:dot(jP)<0 then jL=360-jL end;return jL end;local function jQ(jK,ai,aj,jR,jS,cR)if ab==0 then return end;local jT=ab;local jU=20;local jV=bG(jR)if cR then for K=-45,45,5 do local jW=K;jK[#jK+1]=da([[<g transform="rotate(%f,%d,%d)">]],jW,ai,aj)jX=5;if K%15==0 then jX=15 elseif K%10==0 then jX=10 end;jK[#jK+1]=da([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jT+jU-jX,ai,aj+jT+jU)end;jK[#jK+1]=gF(ai,aj+jT+jU-35,jS,"pdim txt txtmid")jK[#jK+1]=gF(ai,aj+jT+jU-25,jV.." deg","pdim txt txtmid")jK[#jK+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jR,ai,aj)jK[#jK+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jT+jU-20,ai+5,aj+jT+jU-20,ai,aj+jT+jU-15)jK[#jK+1]="</g>"end;jK[#jK+1]=[[<g style="clip-path: url(#headingClip);">]]local jY=jV;if cR then jY=jM(cA)end;local jZ=20;local j_=bG(jY)local k0=0;local k1=aj+jT+jU+20;local k2=ai;if jS~="YAW"then k1=i_(130)k2=iZ(960)end;local k3=[[<path class="txttick line" d="]]local k4=bG(j_-(jZ+10)-j_%5+0.5)for K=k4+70,k4,-5 do local hg=k2-(-K*5+jY*5)if K%10==0 then k0=10;local dt=K;if dt==360 then dt=0 elseif dt>360 then dt=dt-360 elseif dt<0 then dt=dt+360 end;jK[#jK+1]=gF(hg,k1+15,dt,"txtmid bright")elseif K%5==0 then k0=5 end;if k0==10 then k3=da([[%s M %f %f v %d]],k3,hg,k1-5,k0)else k3=da([[%s M %f %f v %d]],k3,hg,k1-2.5,k0)end end;jK[#jK+1]=k3 ..[["/>]]jK[#jK+1]=da([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k2-5,k1-20,k2+5,k1-20,k2,k1-10)if I then if cR then jS="HDG"end;jK[#jK+1]=gF(iZ(960),i_(100),j_.."Â°","dim txt txtmid size14","")jK[#jK+1]=gF(iZ(960),i_(85),jS,"dim txt txtmid size20","")end;jK[#jK+1]=[[</g>]]end;local function k5(jK,k6,jR,ai,aj,cR,k7,fh)if ab==0 then return end;local jT=ab;local k8=bG(jT*3/5)if jT>0 then local k9=bG(k6)local jX=0;local k3=da([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jR,ai,aj)if not c7 then k3=da([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jK[#jK+1]=da([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jT-1,ai,aj)jK[#jK+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bG(k9-30-k9%5+0.5),bG(k9+30+k9%5+0.5),5 do if K%10==0 then jX=30 elseif K%5==0 then jX=20 end;local hh=aj+-K*5+k6*5;if jX==30 then k3=da([[%s M %d %f h %d]],k3,ai-k8-jX,hh,jX)if c7 then jK[#jK+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jR,ai,aj,ai-k8+10,hh+4,K)jK[#jK+1]=da([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jR,ai,aj,ai+k8-10,hh+4,K)if K==0 or K==180 or K==-180 then jK[#jK+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jR,ai,aj,ai-k8+20,hh,k8*2-40)end else jK[#jK+1]=gF(ai-k8+10,hh,K,"pdim txt txtmid")jK[#jK+1]=gF(ai+k8-10,hh,K,"pdim txt txtmid")end;k3=da([[%s M %d %f h %d]],k3,ai+k8,hh,jX)else k3=da([[%s M %d %f h %d]],k3,ai-k8-jX,hh,jX)k3=da([[%s M %d %f h %d]],k3,ai+k8,hh,jX)end end;jK[#jK+1]=k3 ..[["/>]]local ka="PITCH"if not cR then ka="REL PITCH"end;if k6>90 and not c7 then k6=90-(k6-90)elseif k6<-90 and not c7 then k6=-90-(k6+90)end;if jT>200 then if c7 then if fh>iB then jK[#jK+1]=gF(ai,aj-15,"Yaw","pdim txt txtmid")jK[#jK+1]=gF(ai,aj+20,k7,"pdim txt txtmid")end;jK[#jK+1]=da([[<g transform="rotate(%f,%d,%d)">]],-jR,ai,aj)else jK[#jK+1]=da([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jK[#jK+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-k8+25,aj-5,ai-k8+20,aj,ai-k8+25,aj+5,ai-k8+50,aj+4,k9)jK[#jK+1]=da([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+k8-25,aj-5,ai+k8-20,aj,ai+k8-25,aj+5,ai+k8-30,aj+4,k9)jK[#jK+1]="</g>"end;local kb=bG(jT/3)jK[#jK+1]=da([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kb,aj,jT-kb)if not c7 and cR then jK[#jK+1]=da([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jR,ai,aj,ai-k8+10,aj,k8*2-20)end;jK[#jK+1]="</g>"if jT<200 then if c7 and fh>iB then jK[#jK+1]=gF(ai,aj-jT,ka,"pdim txt txtmid")jK[#jK+1]=gF(ai,aj-jT+10,k9,"pdim txt txtmid")jK[#jK+1]=gF(ai,aj-15,"Yaw","pdim txt txtmid")jK[#jK+1]=gF(ai,aj+20,k7,"pdim txt txtmid")else jK[#jK+1]=gF(ai,aj-jT,ka,"pdim txt txtmid")jK[#jK+1]=gF(ai,aj-jT+15,k9,"pdim txt txtmid")end end end end;local function kc(jK,dV,cR)local kd=ao;local ke=ap;if kd==0 and ke==0 then return end;local kf=78;local kg=19;local kh=c6;if c6~=-1 then jK[#jK+1]=gF(kd+kf,ke+kg+20,da("AGL: %.1fm",c6),"pdim altsm txtend")end;if cR and(dV<200000 and not c7 or dV and c7)then table.insert(jK,da([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kd-1,ke-4,kf+2,kg+6,kd+1,ke-1,kf-4,kg))local go=0;local ki=1;local kj=0;local kk=dV<0;local kl=dV<iY.surfaceMaxAltitude;local km=9;if kk then km=0 end;local dV=eQ(dV)while go<6 do local kn=11;local ko=16;local kp=9;local kq=14;local jE="altsm"if go>2 then ko=ko+3;kn=kn+2;kq=kq+2;kp=kp-6;jE="altbig"end;if kk then jE=jE.." red"elseif kl then jE=jE.." orange"end;local kr=dV/ki%10;local ks=bG(kr)local kt=bG((ks+1)%10)local ku=kj;if go==0 then ku=kr-ks;if kk then ku=1-ku end end;if kk and(go==0 or kj~=0)then local gr=kt;kt=ks;ks=gr end;local kv=ko*(ku-1)local kw=kv+ko;local hg=kd+kp+(6-go)*kn;local hh=ke+kq;jK[#jK+1]=gF(hg,hh+kv,kt,jE)jK[#jK+1]=gF(hg,hh+kw,ks,jE)go=go+1;ki=ki*10;if ks==km then kj=ku else kj=0 end end;table.insert(jK,[[</g></g>]])end end;local function kx(fm)local ky=-math.deg(eL(fm.y,fm.z))+180;ky=ky-90;if ky<0 then ky=360+ky end;if ky>180 then ky=-180+ky-180 end;return-ky end;local function kz(fm)local jY=math.deg(eL(fm.y,fm.x))-90;if jY<-180 then jY=360+jY end;return jY end;local function kA(jK,fm,fh,ai,aj)if fh>5 and not c7 or fh>iB then local jT=ab;local kB=20;local kC=20;local kD=kx(fm)local kE=kz(fm)local kF=14;local kG=kF/2;local kH=-kE/kC*jT;local kI=kD/kB*jT;local hg=ai+kH;local hh=aj+kI;local c2=dd(kH^2+kI^2)local kJ=[[<circle
                            cx="]]..hg..[["
                            cy="]]..hh..[["
                            r="]]..kG/kF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hg..[["
                            cy="]]..hh..[["
                            r="]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hg-kF..[[,]]..hh..[[ h ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hg+kG..[[,]]..hh..[[ h ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hg..[[,]]..hh-kF..[[ v ]]..kG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c2<jT then jK[#jK+1]=kJ else local jL=eL(kI,kH)local kK=4;local kL=ai+jT*math.cos(jL)local kM=aj+jT*math.sin(jL)jK[#jK+1]=da('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jL*180/math.pi,kL,kM,kL-kK,kM-kK/2,kK*2,kK,kL+kK,kM-kK,kK,kK,-kK,kK)end;if not c7 then local kN=vec3(fm)kD=kx(-kN)kE=kz(-kN)kH=-kE/kC*jT;kI=kD/kB*jT;hg=ai+kH;hh=aj+kI;c2=dd(kH^2+kI^2)if c2<jT then local kO=[[<circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hg..[[,]]..hh-kF..[[ v ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hg..[[,]]..hh..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hg..[[,]]..hh..[[)" />
                                <path
                                    d="M ]]..hg-kG..[[,]]..hh..[[ h ]]..kF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hg..[[,]]..hh..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hg..[[,]]..hh..[[)"/>]]jK[#jK+1]=kO end end end end;local function kP(jK,j2,kQ,kR)if ak==0 and al==0 then return end;kQ=bG(kQ+0.5)local jt=al+10;local ju=al+20;if ig()==1 and not l then jt=55;ju=65 end;local kS="CRUISE"local c="km/h"local dC=kR;if j2=="TRAVEL"or j2=="AUTOPILOT"then kS="THROT"c="%"dC=kQ;local kT="dim"if kQ<0 then kT="red"end;jK[#jK+1]=da([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kT,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eQ(kQ),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jK[#jK+1]=gF(ak+10,jt,kS,"pbright txtstart")jK[#jK+1]=gF(ak+10,ju,da("%.0f %s",dC,c),"pbright txtstart")if c7 and t and cK and bL then kQ=bG(bM*100+0.5)local kT="red"if kQ<0 then kT="red"end;jK[#jK+1]=da([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kT,1-eQ(kQ),ak-10,al+50,ak-15,al+53,ak-15,al+47)jK[#jK+1]=gF(ak+10,jt+40,"LIMIT","pbright txtstart")jK[#jK+1]=gF(ak+10,ju+40,kQ.."%","pbright txtstart")end;if c7 and t or b4 then jK[#jK+1]=gF(ak+10,jt-40,"LIMIT: "..cu.." km/h","dim txtstart")elseif not c7 and a_ then jK[#jK+1]=gF(ak+10,jt-40,"LIMIT: "..bG(_*3.6+0.5).." km/h","dim txtstart")end end;local function kU(jK,kV)if ak==0 and al==0 then return end;local kW=al-10;local kX=ak+10;jK[#jK+1]=gF(0,0,"","pdim txt txtend")if ig()==1 and not l then kW=75 end;jK[#jK+1]=gF(kX,kW,bG(kV).." km/h","pbright txtbig txtstart")end;local function kY(jK)jK[#jK+1]=gF(iZ(1900),i_(1070),da("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jK[#jK+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jK[#jK+1]=gF(iZ(960),i_(550),"Warning: Invalid Control Scheme Detected","warnings")jK[#jK+1]=gF(iZ(960),i_(600),"Keyboard Scheme must be selected","warnings")jK[#jK+1]=gF(iZ(960),i_(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kZ=iZ(960)local k_=i_(860)local l0=i_(880)local l1=i_(900)local l2=i_(960)local l3=i_(200)local l4=i_(250)local l5=i_(960)if ig()==1 and not l then k_=i_(135)l0=i_(155)l1=i_(175)l3=i_(115)l4=i_(95)end;local l6="#222222"local l7="white"local l8="dimmer"local l9="pbright"local la="#110000"local lb=l6;local lc=l8;if aX then local ld=""if type(aX)=="string"then ld="-"..aX end;jK[#jK+1]=gF(kZ,k_,"Brake Engaged"..ld,"warnings")la="#440000"lb=l7;lc=l9 elseif bK>0 then jK[#jK+1]=gF(kZ,k_,"Auto-Brake Engaged","warnings","opacity:"..bK)end;local le="#110000"local lf=l6;local lg=l8;if c7 and ct and c6==-1 then if not a_ and not bm and not b2 and not cJ and not b5 and not b3 then jK[#jK+1]=gF(kZ,l3+50,"** STALL WARNING **","warnings")le="#ff0000"lf=l7;lg=l9;fM("stall","SW",2)end end;if cQ then jK[#jK+1]=gF(kZ,l3+90,"Flight Assist in Progress","warnings")end;if cb then jK[#jK+1]=gF(kZ,l5,"Gyro Enabled","warnings")end;local lh="#111100"local li=l6;local lj=l8;if bi then lh="#775500"li=l7;lj=l9;if bO then jK[#jK+1]=gF(kZ,l0,"Gear Extended","warn")else jK[#jK+1]=gF(kZ,l0,"Landed (G: Takeoff)","warnings")end end;if c6>-1 and(not cJ or c9<100)then local lk=il(d:getTargetGroundAltitude())jK[#jK+1]=gF(kZ,l1,"Hover Height: "..lk,"warn")end;local ll="#000011"local lm=l6;local ln=l8;if bX then ll="#0000DD"lm=l7;ln=l9;jK[#jK+1]=gF(kZ,l2+20,"ROCKET BOOST ENABLED","warn")end;local lo="#001100"local lp=l6;local lq=l8;if antigrav and not q and cJ and br~=nil then lo="#00DD00"lp=l7;lq=l9;local lr="warnings"if eQ(c9-antigrav.getBaseAltitude())<501 then lr="warn"end;jK[#jK+1]=gF(kZ,l3+40,da("Target Altitude: %d Singularity Altitude: %d",bG(br),bG(antigrav.getBaseAltitude())),lr)end;if a_ and bf~="None"then jK[#jK+1]=gF(kZ,l3,"Autopilot "..bc,"warn")elseif bp~=nil then jK[#jK+1]=gF(kZ,l3+20,da("LockedPitch: %d",bG(bp)),"warn")elseif bT then jK[#jK+1]=gF(kZ,l3+20,"Follow Mode Engaged","warn")elseif b4 or c5 then jK[#jK+1]=gF(kZ,l3+20,"Re-entry in Progress","warn")end;if b1 or b5 then local lk=il(b6,2)if b5 then if cJ then lk=il(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jK[#jK+1]=gF(kZ,l3,"VTO to "..lk,"warn")elseif b3 and not bv then if c4 then jK[#jK+1]=gF(kZ,l3,"Takeoff to "..bf,"warn")else jK[#jK+1]=gF(kZ,l3,"Takeoff to "..lk,"warn")end;if aX and not b5 then jK[#jK+1]=gF(kZ,l3+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jK[#jK+1]=gF(kZ,l3,"Altitude Hold: "..da("%.1fm",b6),"warn")end end;if b5 and(antigrav~=nil and antigrav)then if c8>0.1 then jK[#jK+1]=gF(kZ,l3+20,"Beginning ascent","warn")elseif c8<0.09 and c8>0.05 then jK[#jK+1]=gF(kZ,l3+20,"Aligning trajectory","warn")elseif c8<0.05 then jK[#jK+1]=gF(kZ,l3+20,"Leaving atmosphere","warn")end end;if bv then if cv~=nil then jK[#jK+1]=gF(kZ,l3,cv,"warn")end end;if b2 then if ls then local lt="Brake Landing"if d5 then lt=lt.."-Aligning"end;if d4 then lt=lt.."-Drift Limited"end;jK[#jK+1]=gF(kZ,l3,lt,"warnings")else jK[#jK+1]=gF(kZ,l3,"Coast-Landing","warnings")end end;if aZ then jK[#jK+1]=gF(kZ,l3,"Prograde Alignment","crit")end;if aY then jK[#jK+1]=gF(kZ,l3,"Retrograde Alignment","crit")end;local lu="#110000"local lv=l6;local lw=l8;if cS then lu="#FF0000"lv=l7;lw=l9;local type;if string.find(cS,"COLLISION")then type="warnings"else type="crit"end;jK[#jK+1]=gF(kZ,l4+20,cS,type)elseif c8==0 then local lx,ly=cm.checkLOS(cD:normalize())if ly~=nil then lw=l9;lu="#FF0000"lv=l7;local lk=il(ly)local lz=ci.computeTravelTime(cE,0,ly)local lA="Collision"if lx.noAtmosphericDensityAltitude>0 then lA="Atmosphere"end;jK[#jK+1]=gF(kZ,l4+20,lx.name.." "..lA.." "..im(lz).." In "..lk,"crit")end end;if bm and not bv then jK[#jK+1]=gF(kZ,l3+60,lB,"warn")end;local lC="#111100"local lD=l6;local lE=l8;if cW and#cW>1 then lC="#DDDD00"lD=l7;lE=l9 end;local lF=iZ;local lG=i_;local l8="topButton"local lH="topButtonActive"local lI=l8;if a_ or bm or c4 or bv then lI=lH end;local lJ=l8;if aZ then lJ=lH end;local lK=l8;if b2 or bi then lK=lH end;local lL=l8;if b1 or bm then lL=lH end;local lM=l8;if aY then lM=lH end;local lN=l8;if bv or cx and a_ then lN=lH end;if w and I then local lO=lG(30)jK[#jK+1]=da([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lI,lF(960),lG(54),lG(-53),lF(-120),lF(25),lG(50))jK[#jK+1]=gF(lF(910),lO,"AUTOPILOT")jK[#jK+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lF(865),lG(51),lF(-25),lG(-50),lF(-110),lF(25),lG(46))jK[#jK+1]=gF(lF(800),lO,"PROGRADE")jK[#jK+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lK,lF(755),lG(47),lF(-25),lG(-46),lF(-98),lF(44),lG(44))jK[#jK+1]=gF(lF(700),lO,"LAND")jK[#jK+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lL,lF(960),lG(54),lG(-53),lF(120),lF(-25),lG(50))jK[#jK+1]=gF(lF(1010),lO,"ALT HOLD")jK[#jK+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lM,lF(1055),lG(51),lF(25),lG(-50),lF(110),lF(-25),lG(46))jK[#jK+1]=gF(lF(1122),lO,"RETROGRADE")jK[#jK+1]=da([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lN,lF(1165),lG(47),lF(25),lG(-46),lF(98),lF(-44),lG(44))jK[#jK+1]=gF(lF(1220),lO,"ORBIT")jK[#jK+1]=[[
                                    </g>
                                </g>]]jK[#jK+1]="</g>"end;return jK end;local function lP(fh)return bG(fN(fh*3.6,0)+0.5).." km/h"end;local function lQ(go)local gq=bf;if go~=nil and type(go)=="number"then if go==0 then return"None"end;gq=cN[go].name end;if gq==nil then gq=fY.name end;if gq==nil then gq="None"end;return gq end;local function lR(jK)local lS=cm.routeWP(true)if not lS or#lS==0 then return end;local hg=iZ(750)local hh=i_(360)if a_ or bm then jK[#jK+1]=gF(hg,hh,"REMAINING ROUTE","pdim txtstart size20")else jK[#jK+1]=gF(hg,hh,"LOADED ROUTE","pdim txtstart size20")end;for dB,K in pairs(lS)do hh=hh+20;jK[#jK+1]=gF(hg,hh,dB..". "..lS[dB],"pdim txtstart size20")end end;local function lT(jK)local hg=aw+10;local hh=ax+20;local lU={}local lV={"Alt-4: AutoTakeoff to Target"}local lW={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lX={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lY={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lU,"--------------DYNAMIC-----------------")if c7 then if c6~=-1 then ij(lU,lV)if b_ and iY and b_.name==iY.name then table.insert(lU,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if cJ then table.insert(lU,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lU,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lU,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lU,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lU,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lU,"G: Takeoff to hover height, raise gear")else table.insert(lU,"G: Lowergear and Land")end else ij(lU,lW)table.insert(lU,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lU,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ij(lU,lX)if shield_1 then table.insert(lU,"Alt-Shift-6: Vent shields")if not G then table.insert(lU,"Alt-Shift-7: Toggle shield off/on")end end end;if fY~=nil then table.insert(lU,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lU,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lU,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lU,"Alt-Spacebar/C will raise/lower target height")table.insert(lU,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c7 then table.insert(lU,"LALT+Mousewheel will lower/raise speed limit")end;ij(lU,lY)for K=1,#lU do hh=hh+12;jK[#jK+1]=gF(hg,hh,lU[K],"pdim txtbig txtstart")end end;local function lZ(jK)local l_=aw;local m0=ax;local m1=av;local m2=4;local m3=15;local hg=0;local hh=0;local m4,m5,m6,m7;local m8;local function m9(type)local gA,bI,fh,ma,jE,mb;if type=="Periapsis"then gA=m8.periapsis.altitude;bI=m8.timeToPeriapsis;fh=m8.periapsis.speed;jE="txtend"ma=12;mb=math.min(hg,l_+m1-iY.radius/m6-m2*2)else gA=m8.apoapsis.altitude;bI=m8.timeToApoapsis;fh=m8.apoapsis.speed;ma=-12;jE="txtstart"mb=hg end;if cE<1 then bI=0 end;jK[#jK+1]=da([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mb+ma,hh-5,hg,hh-5)jK[#jK+1]=da([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mb-ma*4,hh+2,hg,hh+2)jK[#jK+1]=gF(mb,hh,type,jE)hg=mb-ma*2;hh=hh+m3;local lk=il(gA)jK[#jK+1]=gF(hg,hh,lk,jE)hh=hh+m3;jK[#jK+1]=gF(hg,hh,im(bI),jE)hh=hh+m3;jK[#jK+1]=gF(hg,hh,lP(fh),jE)end;local mc=m1*1.5;if bD=="INFO"then mc=25*9 end;if bD~="HIDE"then jK[#jK+1]=[[<g class="pbright txtorb txtmid">]]jK[#jK+1]=da('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m1*2,mc,l_,m0)jK[#jK+1]=da([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m1*2,mc,l_,m0)end;local md=m1*1.5;local me=m1*2;local mf=md/2;local mg=m1;local mh=l_+mg;local mi=m0+mf;local mj=l_+me;local mk=m0+md;if bD=="ORBIT"then m0=m0+m2;m4=m1/2;m7=0;m8={}m8.periapsis={}m8.apoapsis={}if fl~=nil then if fl.periapsis~=nil then m8.periapsis.altitude=fl.periapsis.altitude;m8.periapsis.speed=fl.periapsis.speed end;if fl.apoapsis~=nil then m8.apoapsis.altitude=fl.apoapsis.altitude;m8.apoapsis.speed=fl.apoapsis.speed end;m8.period=fl.period;m8.eccentricity=fl.eccentricity;m8.timeToApoapsis=fl.timeToApoapsis;m8.timeToPeriapsis=fl.timeToPeriapsis;m8.eccentricAnomaly=fl.eccentricAnomaly;m8.trueAnomaly=fl.trueAnomaly end;if m8.periapsis==nil then m8.periapsis={}m8.periapsis.altitude=-iY.radius;m8.periapsis.speed=_ end;if m8.eccentricity==nil then m8.eccentricity=1 end;if m8.apoapsis==nil then m8.apoapsis={}m8.apoapsis.altitude=c9;m8.apoapsis.speed=0 end;if cE<1 then m8.apoapsis.altitude=c9;m8.apoapsis.speed=0 end;if m8.apoapsis.altitude then m6=(m8.apoapsis.altitude+m8.periapsis.altitude+iY.radius*2)/(m4*2)m5=(iY.radius+m8.apoapsis.altitude)/m6*(1-m8.eccentricity)m7=m4-m8.periapsis.altitude/m6-iY.radius/m6;local ml=math.pi;if m8.period~=nil and m8.period>0 and m8.timeToApoapsis~=nil then ml=m8.eccentricAnomaly;if m8.timeToPeriapsis<m8.timeToApoapsis then ml=2*math.pi-ml end end;if cE<1 or ml~=ml then ml=math.pi end;local mm=-m4*math.cos(ml)+l_+mg+m2;local mn=m5*math.sin(ml)+m0+mf+m2;local mo=""jK[#jK+1]='<g clip-path="url(#orbitRect)">'jK[#jK+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mo,l_+m1+m2,m0+m1*1.5/2+m2,m4,m5)if m5<1 then jK[#jK+1]=da([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],l_+m1+m2-m7,m0+m1*1.5/2+m2,mm,mn)end;jK[#jK+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',l_+m1+m2-m7,m0+m1*1.5/2+m2,(iY.radius+iY.noAtmosphericDensityAltitude)/m6)jK[#jK+1]=da('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',l_+m1+m2-m7,m0+m1*1.5/2+m2,(iY.radius+iY.noAtmosphericDensityAltitude)/m6)jK[#jK+1]=da([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",l_+m1+m2,m0+m1*1.5/2+m2,m4,m5)jK[#jK+1]=da('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',l_+m1+m2-m7,m0+m1*1.5/2+m2,iY.radius/m6)jK[#jK+1]='</g>'local mp=math.floor(iY.radius/m6+0.5)hg=l_+m1+m2*4+m4;hh=m0+m1*1.5/2+5+m2;if m8.apoapsis~=nil and m8.apoapsis.speed<_ then m9("Apoapsis")end;hh=m0+m1*1.5/2+5+m2;hg=l_+m1-m2*2-m4;if m8.periapsis~=nil and m8.periapsis.speed<_ and m8.periapsis.altitude>0 then m9("Periapsis")end;jK[#jK+1]=gF(l_+m1+m2,m0+20+m2,iY.name,"txtorbbig")jK[#jK+1]=da('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mm,mn)jK[#jK+1]=[[</g>]]return jK else jK[#jK+1]='<g clip-path="url(#orbitRect)">'local mq=""local mr=1.2*(ms-mt)/(m1*2)local mu=1.4*(mv-mw)/(m1*1.5)for dB,dm in pairs(e[0])do if dm.center then local hg=l_+m1+dm.center.x/mr;local hh=m0+m1*1.5/2+dm.center.y/mu;mq=mq..'<circle cx="'..hg..'" cy="'..hh..'" r="'..dm.radius/mr*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dm.name,"Moon")and not string.match(dm.name,"Sanctuary")and not string.match(dm.name,"Space")then mq=mq.."<text x='"..hg.."' y='"..hh+dm.radius/mr*30+20 .."' font-size='12' fill="..iJ.." text-anchor='middle' font-family='Montserrat'>"..dm.name.."</text>"end end end;local fn=vec3(b.getConstructWorldPos())local hg=l_+m1+fn.x/mr;local hh=m0+m1*1.5/2+fn.y/mu;mq=mq..'<circle cx="'..hg..'" cy="'..hh..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mq=mq.."<text x='"..hg.."' y='"..hh-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iv=mr;iw=mu;local mx=fn+cD*1000000;local my=l_+m1+mx.x/mr;local ju=m0+m1*1.5/2+mx.y/mu;mq=mq..'<line x1="'..hg..'" y1="'..hh..'" x2="'..my..'" y2="'..ju..'" stroke="purple" stroke-width="1"/>'jK[#jK+1]=mq;jK[#jK+1]='</g>'end elseif bD=="INFO"then jK=ck.DrawOdometer(jK,iL,bj,iM)elseif bD=="HELP"then jK=lT(jK)elseif bD=="SCOPE"then jK[#jK+1]='<g clip-path="url(#orbitRect)">'local mz=cZ;if c8>0 then table.sort(cY,function(er,es)local et,eu=er.center,es.center;return(et.x-cH.x)^2+(et.y-cH.y)^2+(et.z-cH.z)^2<(eu.x-cH.x)^2+(eu.y-cH.y)^2+(eu.z-cH.z)^2 end)end;local gN={}local mA={}local mB=120;local mC=nil;local mD=nil;for K,dm in ipairs(cY)do local gM=dm.center-cH;local mE=gM:len()local mF=gM:normalize()local mG=gM:cross(cA):normalize()local mH=math.acos(mG:dot(cB))if mH~=mH then mH=0 end;if mG:cross(cB):dot(cA)<0 then mH=-mH end;local mI=gM:project_on_plane(cA):len()local mJ=math.sin(mH)*math.asin(mI/mE)*constants.rad2deg;local mK=math.cos(mH)*math.asin(mI/mE)*constants.rad2deg;if mF:dot(cA)<0 then mK=90*math.cos(mH)+90*math.cos(mH)-mK;mJ=90*math.sin(mH)+90*math.sin(mH)-mJ end;local hg=mh+mJ/mz*md;local hh=mi+mK/mz*md;local mL=(hg-mh)*(hg-mh)+(hh-mi)*(hh-mi)local mM=math.asin((dm.radius+dm.surfaceMaxAltitude)/mE)*constants.rad2deg;if mM~=mM then mM=mz end;local hB=mM/mz*md;local mN=math.asin(dm.atmosphereRadius/mE)*constants.rad2deg;if mN~=mN then mN=mM end;local mO=mN/mz*md;local c2=il(mE,1)local mP=dm.name;local mQ=false;if hh>m0 then if hh>mk then if hh-mO<=mk then mQ=true end else mQ=true end else if hh+mO>=m0 then mQ=true end end;local mR=false;local mS=hg;if dm.systemId==0 then mS=hg+mB else mS=hg-mB end;if mS+mB>l_ then if mS+mB>mj then if mS-mO-mB<=mj then mR=true end else mR=true end else if mS+mO+mB>=l_ then mR=true end end;local mT={}mT.x=hg;mT.y=hh;mT.planet=dm;mT.atmoSize=mO;if not mC or mL<mC then mC=mL;mD=mT end;if mR and mQ then local mU=math.max(mO,5)if mL<mU*mU then mP=mP.." - "..c2 end;mT.size=hB;mT.i=K;mT.displayString=mP;mT.distance=c2;mT.visible=true;mA[#mA+1]=mT else mT.visible=false end end;local mV=false;table.sort(mA,function(et,eu)return et.y<eu.y end)for dB,fq in ipairs(mA)do local dm,hB,K,mO,hg,hh,mP,c2=fq.planet,fq.size,fq.i,fq.atmoSize,fq.x,fq.y,fq.displayString,fq.distance;local mb,mW,mX,mY;local mZ=15;local jE="pdim"if dm.systemId~=0 then mX=iZ(string.len(mP)*5)mZ=-(15+mX)mY=i_(10)jE="pdimfill"else mX=iZ(string.len(mP)*9)mY=i_(15)end;if hB*2>mX then mb=db(hg,l_+mX/2,mj-mX/2)mW=db(hh,m0+mY,mk-5)mb=db(mb,hg-hB+mX/2,hg+hB-mX/2)mW=db(mW,hh-hB+mY,hh+hB)else mb=hg+mZ;mW=hh end;for m_,fq in pairs(gN)do local n0=fq.textPositions;local n1=n0.y-mW;if m_~=K and eQ(n1)<n0.height and n0.x+n0.width>mb and n0.x<mb+mX then if hB>mX then mW=db(mW+mY,m0+15,mk-5)else mW=n0.y+n0.height+1 end end end;local n2=mP~=dm.name or mb<=mh and mb+mX>=mh and mW-mY<=mi and mW>=mi;fq.hovered=n2;local n3=1;if n2 then n3=2;if hB*2<mX then n3=10 end;if mP==dm.name then mP=mP.." - "..c2 end;jE="pbright"if dm.systemId~=0 then mX=iZ(string.len(mP)*5)mZ=-(15+mX)else mX=iZ(string.len(mP)*7)end;if hB*2>mX then mb=db(hg,l_+mX/2,mj-mX/2)mb=db(mb,hg-hB+mX/2,hg+hB-mX/2)else mb=hg+mZ end end;gN[K]={}gN[K].textPositions={}gN[K].textPositions.y=mW;gN[K].textPositions.x=mb;gN[K].textPositions.width=mX;gN[K].textPositions.height=mY;gN[K].output=""if hB*2>mX then jE=jE.." txtmid"else jE=jE.." txtstart"end;if mO-hB>2 then gN[K].output=da('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hg,hh,mO,iK,0.1*n3)end;gN[K].output=gN[K].output..da('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hg,hh,hB,iK,0.2*n3)if dm.systemId==0 then gN[K].output=gN[K].output..da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mb,mW,iJ,jE,mP)if hB*2<=mX then gN[K].output=gN[K].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mb+mX,mW+2,mb,mW+2,hg,hh)end else gN[K].output=gN[K].output..da([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mb,mW,iK,jE,mP)if hB*2<=mX then gN[K].output=gN[K].output..da("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mb,mW+2,mb+mX,mW+2,hg,hh)end end end;for dB=#cY,1,-1 do if gN[dB]then jK[#jK+1]=gN[dB].output end end;if mD~=nil and cZ<90 and not mD.hovered then local n4=mD.planet.atmosphereRadius/mD.atmoSize;local n5=dd(mC)*n4;local n6=il(n5,1)local mX=iZ(math.max(string.len(n6)*7,string.len(mD.planet.name)*7))local mY=i_(12)local mb=db(mD.x+(mh-mD.x)/2,l_+mX/2,mj-mX/2)local mW=db(mD.y+(mi-mD.y)/2,m0+mY*2,mk-5)jK[#jK+1]=da("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mD.x,mD.y,mh,mi)jK[#jK+1]=da([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mb,mW,"white",n6)if not mD.visible then jK[#jK+1]=da([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mb,mW-mY,"white",mD.planet.name)end end;if cE>1 then local gM=cD;local mF=gM:normalize()local mI=gM:project_on_plane(cA):len()local mG=gM:cross(cA):normalize()local mH=math.acos(mG:dot(cB))if mH~=mH then mH=0 end;if mG:cross(cB):dot(cA)<0 then mH=-mH end;local mJ=math.sin(mH)*math.asin(mI/gM:len())*constants.rad2deg;local mK=math.cos(mH)*math.asin(mI/gM:len())*constants.rad2deg;if mF:dot(cA)<0 then mK=90*math.cos(mH)+90*math.cos(mH)-mK;mJ=90*math.sin(mH)+90*math.sin(mH)-mJ end;local hg=mh+mJ/mz*md;local hh=mi+mK/mz*md;local kF=14;local kG=kF/2;local kJ=[[<circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kG/kF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hg..[["
                                    cy="]]..hh..[["
                                    r="]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hg-kF..[[,]]..hh..[[ h ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hg+kG..[[,]]..hh..[[ h ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hg..[[,]]..hh-kF..[[ v ]]..kG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jK[#jK+1]=kJ end;jK[#jK+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mh,mi-10,mh,mi+10)jK[#jK+1]=da("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mh-10,mi,mh+10,mi)jK[#jK+1]='</g>'else return jK end end;local function n7(n8,n9)local na;local nb=(n9-n8):normalize()local fo=(cH-n8):dot(nb)/nb:dot(nb)if fo<=0. then return(cH-n8):len()elseif fo>=(n9-n8):len()then return(cH-n9):len()end;local nc=n8+fo*nb;na=(nc-cH):len()return na end;local function nd()local na;local ne=nil;local nf=nil;local ng=nil;for dB,nh in pairs(e[0])do if nh.hasAtmosphere then local c2=n7(iY.center,nh.center)if ne==nil or c2<ne then nf=nh;ne=c2;ng=iY end;if b_ and b_.hasAtmosphere and b_.name~=iY.name then local eG=n7(b_.center,nh.center)if eG<ne then nf=nh;ne=eG;ng=b_ end end end end;local ni=iZ(1770)local nj=i_(330)if ne then local nk="txttick "local nl=500000;if ne<nf.radius+nl or ne<ng.radius+nl then if cO then nk="txttick red "else nk="txttick orange "end end;na=il(ne,2)iA=gF(ni,nj,"Pipe ("..ng.name.."--"..nf.name.."): "..na,nk.."pbright txtmid")end end;local function nm(hg,hh,nn,no,kS)local np={x=hg,y=hh,width=nn,height=no,label=kS}iu[kS]=np;return np end;local function nq(nr,ns,nn,no,hg,hh,nt,nu,nv,nw,jE)local np={enableName=nr,disableName=ns,width=nn,height=no,x=hg,y=hh,toggleVar=nt,toggleFunction=nu,drawCondition=nv,hovered=false,class=jE}if nw then table.insert(it,np)else table.insert(is,np)end;return np end;local function nx(ny)if not iy then nz=false;nA=false;nB=false;w=true;return elseif ny=="handling"then nz=not nz;nA=false;nB=false elseif ny=="hud"then nA=not nA;nz=false;nB=false elseif ny=="physics"then nB=not nB;nz=false;nA=false end;if nB or nA or nz then iz=ik(ny)w=false else iz="none"w=true end end;local function nC()iy=not iy;if iy then ir=it;bV="Hold SHIFT to see Settings"c_=w else ir=is;bV="Hold SHIFT to see Control Buttons"nx()w=c_ end end;local function nD()local function nE(dm,dB)dm.set(not dm.get())if dm.get()then bV=dB.." set to true"else bV=dB.." set to false"end;if dB=="showHud"then c_=dm.get()elseif dB=="BrakeToggleDefault"then aV=j end end;local nF=50;local nG=340;local hg=500;local hh=cd/2-400;local nH=0;for dB,dm in pairs(ik("boolean"))do if type(dm.get())=="boolean"then nq(dB,dB,nG,nF,hg,hh,function()return dm.get()end,function()nE(dm,dB)end,function()return true end,true)hh=hh+nF+20;if nH==9 then hg=hg+nG+20;hh=cd/2-400;nH=0 else nH=nH+1 end end end;nq("Control View","Control View",nG,nF,10,cd/2-500,function()return true end,nC,function()return true end,true)nq("View Handling Settings",'Hide Handling Settings',nG,nF,10,cd/2-(500-nF),function()return nz end,function()nx("handling")end,function()return true end,true)nq("View Hud Settings",'Hide Hud Settings',nG,nF,10,cd/2-(500-nF*2),function()return nA end,function()nx("hud")end,function()return true end,true)nq("View Physics Settings",'Hide Physics Settings',nG,nF,10,cd/2-(500-nF*3),function()return nB end,function()nx("physics")end,function()return true end,true)end;local function nI()local function gp()local fP=cH;local gq=iY.name..". "..#bl;if radar_1 then gq=cn.GetClosestName(gq)end;return cl.AddNewLocation(gq,fP,false,true)end;local function nJ()b0=not b0 end;local function nK(nL)if nL==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;bT=false;b2=false;bp=nil;b4=false;b3=false end;local function nM(nN,nO)cl.UpdatePosition(nil,nN,nO)end;local function gk()cl.ClearCurrentPosition()end;local function nP(go)local lS=cm.routeWP(true)if lS and#lS>0 then return"Engage Route: "..lS[1]end;return"Engage Autopilot: "..lQ(go)end;local function nQ(go)local lS=cm.routeWP(true)if lS and#lS>0 then return"Next Route Point: "..lS[1]end;return"Disable Autopilot: "..lQ(go)end;local function nR()if ig()==1 then bT=not bT;if bT then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;nS=bi;bi=false;d.control.retractLandingGears()ih:setTargetGroundAltitude(X)fM("folOn","F")else fM("folOff","F")aX="Follow Off"cs=p;bi=nS;if bi then d.control.extendLandingGears()ih:setTargetGroundAltitude(Y)end end else bV="Follow Mode only works with Remote controller"bT=false end end;local nF=50;local nG=260;local nT=iZ(30)local nU=aw+av*2+2;local nV=ax+1;nq("+","+",nT,nT,nU,nV+nT+1,function()return false end,function()cZ=cZ/8 end,function()return bD=="SCOPE"end,nil,"ZoomButton")nq("-","-",nT,nT,nU,nV,function()return false end,function()cZ=math.min(cZ*8,90)end,function()return bD=="SCOPE"end,nil,"ZoomButton")nq("0","0",nT,nT,nU,nV+nT*2+2,function()return false end,function()cZ=90 end,function()return bD=="SCOPE"and cZ~=90 end,nil,"ZoomButton")local nW=nq("Enable Brake Toggle","Disable Brake Toggle",nG,nF,cc/2-nG/2,cd/2+350,function()return aV end,function()aV=not aV;if aV then bV="Brakes in Toggle Mode"else bV="Brakes in Default Mode"end end)nq("Align Prograde","Disable Prograde",nG,nF,cc/2-nG/2-50-nW.width,cd/2-nF+380,function()return aZ end,function()nK(1)end)nq("Align Retrograde","Disable Retrograde",nG,nF,cc/2-nG/2+nW.width+50,cd/2-nF+380,function()return aY end,nK,function()return c8==0 end)nX=nq(nP,nQ,600,60,cc/2-600/2,cd/2-60/2-330,function()return a_ or bm or c4 or bv end,function()end)local K;local function nY(nZ)local go=cV+nZ;if go>#cN then go=go-#cN-1 end;if go<0 then go=#cN+go end;return go end;n_={}for K=0,10 do local o0=nq(function(eu)local go=nY(eu.apExtraIndex)if a_ or bm or c4 or bv then return"Redirect: "..lQ(go)end;return nP(go)end,function(eu)local go=nY(eu.apExtraIndex)return nQ(go)end,600,60,cc/2-600/2,cd/2-60/2-330+60*K,function(eu)local go=nY(eu.apExtraIndex)return go==bh and(a_ or bm or c4 or bv)end,function(eu)local go=nY(eu.apExtraIndex)local o1=bh==go;bh=go;cl.UpdateAutopilotTarget()cm.ToggleAutopilot()if not o1 and not(a_ or bm or c4 or bv)then cm.ToggleAutopilot()end end,function()return cU and(#cm.routeWP(true)==0 or K==0)end)o0.apExtraIndex=K;n_[K]=o0 end;nq("Save Position","Save Position",200,nX.height,nX.x+nX.width+30,nX.y,function()return false end,gp,function()return bh==0 or fY==nil end)nq("Update Position","Update Position",200,nX.height,nX.x+nX.width+30,nX.y,function()return false end,function()nM(nil)end,function()return bh>0 and fY~=nil end)nq("Save Heading","Clear Heading",200,nX.height,nX.x+nX.width+30,nX.y+nX.height+20,function()return fY.heading~=nil end,function()if fY.heading~=nil then nM(false)else nM(true)end end,function()return bh>0 and fY~=nil end)nq("Save AGG Alt","Clear AGG Alt",200,nX.height,nX.x+nX.width+30,nX.y+nX.height*2+40,function()return fY.agg~=nil end,function()if fY.agg~=nil then nM(nil,false)else nM(nil,true)end end,function()return bh>0 and fY~=nil and antigrav end)nq("Clear Position","Clear Position",200,nX.height,nX.x-200-30,nX.y,function()return true end,gk,function()return bh>0 and fY~=nil end)nq("Save Route","Save Route",200,nX.height,nX.x-200-30,nX.y+nX.height*2+40,function()return false end,function()cm.routeWP(false,false,2)end,function()return#cm.routeWP(true)>0 end)nq("Load Route","Clear Route",200,nX.height,nX.x-200-30,nX.y+nX.height+20,function()return#cm.routeWP(true)>0 end,function()if#cm.routeWP(true)>0 then cm.routeWP(false,true)elseif a_ or bm then bV="Disable Autopilot before loading route"return else cm.routeWP(false,false,1)end end,function()return true end)nF=60;nG=300;local hg=0;local hh=cd/2-150;nq("Enable Check Damage","Disable Check Damage",nG,nF,hg,hh-nF-20,function()return s end,function()s=not s end)nq("View Settings","View Settings",nG,nF,hg,hh,function()return true end,nC)hh=hh+nF+20;nq("Enable Turn and Burn","Disable Turn and Burn",nG,nF,hg,hh,function()return b0 end,nJ)hg=10;hh=cd/2-300;nq("Horizontal Takeoff Mode","Vertical Takeoff Mode",nG,nF,hg+nG+20,hh,function()return aW end,function()aW=not aW;if aW then bV="Vertical Takeoff Mode"else bV="Horizontal Takeoff Mode"end end,function()return cI end)hh=hh+nF+20;nq("Engage Orbiting","Cancel Orbiting",nG,nF,hg+nG+20,hh,function()return bv end,cm.ToggleIntoOrbit,function()return c8==0 and cR end)hh=cd/2-150;nq("Glide Re-Entry","Cancel Glide Re-Entry",nG,nF,hg+nG+20,hh,function()return b4 end,function()c3=1;nK(1)end,function()return iY.hasAtmosphere and not c7 end)hh=hh+nF+20;nq("Parachute Re-Entry","Cancel Parachute Re-Entry",nG,nF,hg+nG+20,hh,function()return b4 end,function()c3=2;nK(1)end,function()return iY.hasAtmosphere and not c7 end)hh=hh+nF+20;nq("Engage Follow Mode","Disable Follow Mode",nG,nF,hg,hh,function()return bT end,nR,function()return ig()==1 end)nq("Enable Repair Arrows","Disable Repair Arrows",nG,nF,hg+nG+20,hh,function()return iP end,function()iP=not iP;if iP then bV="Repair Arrows Enabled"else bV="Repair Arrows Diabled"end end,function()return ig()==1 end)hh=hh+nF+20;if not q then nq("Enable AGG","Disable AGG",nG,nF,hg,hh,function()return cJ end,cm.ToggleAntigrav,function()return antigrav~=nil end)end;nq(function()return da("Switch IPH Mode - Current: %s",bw)end,function()return da("IPH Mode: %s",bw)end,nG*2,nF,hg,hh,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;bV="IPH Mode: "..bw end)hh=hh+nF+20;nq(function()return da("Toggle Control Scheme - Current: %s",g)end,function()return da("Control Scheme: %s",g)end,nG*2,nF,hg,hh,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bV="New Control Scheme: "..g end)local o2=i_(20)local o0=nm(0,0,iZ(70),o2,"HELP")o0=nm(o0.x+o0.width,o0.y,iZ(80),o2,"INFO")o0=nm(o0.x+o0.width,o0.y,iZ(70),o2,"ORBIT")o0=nm(o0.x+o0.width,o0.y,iZ(70),o2,"SCOPE")nm(o0.x+o0.width,o0.y,iZ(70),o2,"HIDE")end;local o3={}local o4=nil;function o3.HUDPrologue(jK)cO,cP=iW(cH)if not cO then iG=af;iH=ag;iI=ah else iG=ac;iH=ad;iI=ae end;iJ=[[rgb(]]..bG(iG+0.6)..","..bG(iH+0.6)..","..bG(iI+0.6)..[[)]]iK=[[rgb(]]..bG(iG*0.8+0.5)..","..bG(iH*0.8+0.5)..","..bG(iI*0.8+0.5)..[[)]]local o5=iJ;local o6=iK;local o7=[[rgb(]]..bG(iG*0.4+0.5)..","..bG(iH*0.4+0.5)..","..bG(iI*0.4+0.5)..[[)]]local o8=iJ;local o9=iK;local oa=o7;if j0()and not m then o5=[[rgb(]]..bG(iG*0.5+0.5)..","..bG(iH*0.5+0.5)..","..bG(iI*0.5+0.5)..[[)]]o6=[[rgb(]]..bG(iG*0.3+0.5)..","..bG(iH*0.3+0.5)..","..bG(iI*0.2+0.5)..[[)]]o7=[[rgb(]]..bG(iG*0.2+0.5)..","..bG(iH*0.2+0.5)..","..bG(iI*0.2+0.5)..[[)]]end;local lF=iZ;local lG=i_;jK[#jK+1]=da([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o5,o5,o5,o8,o8,o6,o6,o9,o9,o6,o5,o7,o9,o5,o5,o7,o7,oa,o7,cc,cd,o6,o6,o6,o6,o6,o8,o6,o9,oa,o9,o9,oa)if not o4 then o4=da([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lF(630),lG(0),lF(675),lG(45),lF(960),lG(55),lF(1245),lG(45),lF(1290),lG(0),lF(1000),lG(105),lF(1040),lG(59),lF(1250),lG(51),lF(1300),lG(0),lF(1920),lG(0),lF(1920),lG(20),lF(1400),lG(20),lF(1300),lG(105),lF(920),lG(105),lF(880),lG(59),lF(670),lG(51),lF(620),lG(0),lF(0),lG(0),lF(0),lG(20),lF(520),lG(20),lF(620),lG(105),lF(890),lG(59),lF(960),lG(62),lF(1030),lG(59),lF(985),lG(112),lF(1150),lG(112),lF(1100),lG(152),lF(820),lG(152),lF(780),lG(112),lF(935),lG(112),lF(890),lG(59),lF(960),lG(62),lF(1030),lG(59),lF(985),lG(112),lF(1150),lG(112),lF(1100),lG(152),lF(820),lG(152),lF(780),lG(112),lF(935),lG(112))end;if w and I then jK[#jK+1]=o4 end;return jK end;function o3.DrawVerticalSpeed(jK,dV)jJ(jK,dV)end;function o3.UpdateHud(jK)local ky=cL;local ob=cM;local jR=ob;local k6=ky;local kQ=bG(c.getThrottle())local kV=cE*3.6;local kR=c.getAxisCommandValue(0)local oc=iZ(1770)local od=i_(310)if t and cK then kR=bJ;kQ=bJ*100 end;local j2=j1()local jS="ROLL"if kQ==nil then kQ=0 end;if not cR then if cE>5 then ky=kx(cC)ob=kz(cC)else ky=0;ob=0 end;jS="YAW"end;if cP>50000 and not c7 then local oe;oe=il(cP)jK[#jK+1]=gF(oc,od,"PvP Boundary: "..oe,"pbright txtbig txtmid")end;jK[#jK+1]=iN;jK[#jK+1]=iE;jK[#jK+1]=hS;if iA~=""then jK[#jK+1]=iA end;if j3~=""then jK[#jK+1]=j3 end;if j4~=""then jK[#jK+1]=j4 end;jJ(jK,c9)if ig()==0 or l then if not j0()or m then if cR then jQ(jK,ai,aj,jR,jS,cR)k5(jK,k6,jR,ai,aj,cR,bG(kz(cC)),cE)else jQ(jK,ai,aj,ob,jS,cR)k5(jK,ky,ob,ai,aj,cR,bG(ob),cE)end;kc(jK,c9,cR)kA(jK,cC,cE,ai,aj)end end;kP(jK,j2,kQ,kR)kU(jK,kV)kY(jK)lZ(jK)if not iy and bU then lR(jK)end;return jK end;function o3.HUDEpilogue(jK)jK[#jK+1]="</svg>"return jK end;function o3.ExtraData(jK)local of=iZ(1240)local og=i_(55)local oh=og+10;local oi;local lF=iZ;local lG=i_;local oj=0;local j2=j1()if aW then j2=j2 .."-VERTICAL"end;if E and not b3 and not b2 and cE>20 then j2=j2 .."-COLLISION ON"end;if by~="Off"then j2="("..by..")-"..j2 end;if b0 then j2="TB-"..j2 end;if not bx then j2=j2 .."-DeCoupled"end;local ok=lG(99)local ol=lG(80)local om=lG(85)local on=lG(31)local oo=0;local op=0;local oq=ca>1000000 and fN(ca/1000000,2).."kT"or fN(ca/1000,2).."T"if c7 then oj=bq else oj=bo end;local os,ot=ci.computeDistanceAndTime(cE,0,ca,0,0,oj)if os<0 then os=0 end;oj=fN(oj/(ca*iq),2).."g"local ou=d:maxForceForward()oi=b.g()if oi>0.1 then op=ca*oi;op=fN(op/(ca*iq),2).."g"oo=0.5*ou/oi;oo=oo>1000000 and fN(oo/1000000,2).."kT"or fN(oo/1000,2).."T"end;ou=fN(ou/(ca*iq),2).."g"local ov=vec3(b.getWorldAcceleration()):len()/9.80665;oi=b.g()jK[#jK+1]=[[<g class="dim txt txtend size14">]]if ig()==1 and not l then of=iZ(1120)og=i_(55)oh=og+10 elseif c7 and I then local ow=iZ(770)jK[#jK+1]=gF(lF(895),ok,"ATMO","")jK[#jK+1]=da([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lF(895),om,lF(-80))jK[#jK+1]=gF(lF(815),ol,da("%.1f%%",c8*100),"txtstart size20")end;if I then jK[#jK+1]=gF(lF(1025),ok,"GRAVITY","txtstart")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(1025),om,lF(80))jK[#jK+1]=gF(lF(1105),ol,da("%.2fg",oi/9.80665),"size20")jK[#jK+1]=gF(lF(1125),ok,"ACCEL","txtstart")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(1125),om,lF(80))jK[#jK+1]=gF(lF(1205),ol,da("%.2fg",ov),"size20")jK[#jK+1]=gF(lF(695),ok,"BRK TIME","")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(695),om,lF(-80))jK[#jK+1]=gF(lF(615),ol,da("%s",im(ot)),"txtstart size20")jK[#jK+1]=gF(lF(635),lG(45),"TRIP","")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(635),lG(31),lF(-90))if lz then jK[#jK+1]=gF(lF(545),lG(26),da("%s",im(lz)),"txtstart size20")end;jK[#jK+1]=gF(lF(795),ok,"BRK DIST","")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(795),om,lF(-80))jK[#jK+1]=gF(lF(715),ol,da("%s",il(os)),"txtstart size20")jK[#jK+1]=gF(lF(1285),lG(45),"MASS","txtstart")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(1285),lG(31),lF(90))jK[#jK+1]=gF(lF(1375),lG(26),da("%s",oq),"size20")jK[#jK+1]=gF(lF(1220),ok,"THRUST","txtstart")jK[#jK+1]=da([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lF(1220),om,lF(80))jK[#jK+1]=gF(lF(1300),ol,da("%s",ou),"size20")jK[#jK+1]=gF(iZ(960),i_(175),j2,"pbright txtbig txtmid size20")end;jK[#jK+1]="</g>"end;local ox=1-(a5*0.05+a6*0.05)function o3.FuelUsed(oy)local oz;if oy=="atmofueltank"then oz=da("Atmo Fuel Used: %.1f L",jl[oy]/(4*ox))elseif oy=="spacefueltank"then oz=da("Space Fuel Used: %.1f L",jl[oy]/(6*ox))else oz=da("Rocket Fuel Used: %.1f L",jl[oy]/(0.8*ox))end;return oz end;function o3.DrawOdometer(jK,iL,bj,iM)if bD~="INFO"then return jK end;local oi;local oo=0;local op=0;local oj=0;local oq=ca>1000000 and fN(ca/1000000,2).." kTons"or fN(ca/1000,2).." Tons"if c7 then oj=bq else oj=bo end;local os,ot=ci.computeDistanceAndTime(cE,0,ca,0,0,oj)oj=fN(oj/(ca*iq),2).." g"local ou=d:maxForceForward()oi=b.g()if oi>0.1 then op=ca*oi;op=fN(op/(ca*iq),2).." g"oo=0.5*ou/oi;oo=oo>1000000 and fN(oo/1000000,2).." kTons"or fN(oo/1000,2).." Tons"end;ou=fN(ou/(ca*iq),2).." g"if ig()==0 or l then local oA=iZ(aw+10)local oB=i_(ax+20)local oC=iZ(aw+10+av/1.25)local no=25;jK[#jK+1]="<g class='txtstart size14 bright'>"jK[#jK+1]=gF(oA,oB,da("BrkTime: %s",im(ot)))jK[#jK+1]=gF(oC,oB,da("Trip: %.2f km",iL))jK[#jK+1]=gF(oA,oB+no,da("Lifetime: %.2f kSU",bj/200000))jK[#jK+1]=gF(oC,oB+no,da("BrkDist: %s",il(os)))jK[#jK+1]=gF(oA,oB+no*2,"Trip Time: "..im(iM))jK[#jK+1]=gF(oC,oB+no*2,"Total Time: "..im(bk))jK[#jK+1]=gF(oA,oB+no*3,da("Mass: %s",oq))jK[#jK+1]=gF(oC,oB+no*3,da("Max Brake: %s",oj))jK[#jK+1]=gF(oA,oB+no*4,da("Max Thrust: %s",ou))if oi>0.1 then jK[#jK+1]=gF(oC,oB+no*4,da("Max Thrust Mass: %s",oo))jK[#jK+1]=gF(oA,oB+no*5,da("Req Thrust: %s",op))else jK[#jK+1]=gF(oC,oB+no*4,"Max Mass: n/a")jK[#jK+1]=gF(oA,oB+no*5,"Req Thrust: n/a")end;jK[#jK+1]=gF(oC,oB+no*5,ck.FuelUsed("atmofueltank"))jK[#jK+1]=gF(oA,oB+no*6,ck.FuelUsed("spacefueltank"))jK[#jK+1]=gF(oC,oB+no*6,ck.FuelUsed("rocketfueltank"))if cE>833 then local oD=ca/math.sqrt(1-(cE/8333.33)^2)local oq=oD>1000000 and fN(oD/1000000,2).." kTons"or fN(oD/1000,2).." Tons"jK[#jK+1]=gF(oC,oB+no*7,da("Rel. Mass: %s",oq))end end;jK[#jK+1]="</g></g>"return jK end;function o3.DrawWarnings(jK)return kY(jK)end;function o3.DisplayOrbitScreen(jK)return lZ(jK)end;function o3.DisplayMessage(jK,lk)if lk~="empty"then local hh=310;for lt in string.gmatch(lk,"([^\n]+)")do hh=hh+35;jK[#jK+1]=gF("50%",hh,lt,"msg")end end;if bW~=0 then c.setTimer("msgTick",bW)bW=0 end end;function o3.DrawDeadZone(jK)jK[#jK+1]=da([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function o3.UpdatePipe()if c7 then iA=""return end;nd()end;function o3.DrawSettings(jK)local hg=iZ(640)local hh=i_(200)jK[#jK+1]=[[<g class="pbright txtvspd txtstart">]]local hz=0;for dB,dm in pairs(iz)do hz=hz+1;jK[#jK+1]=gF(hg,hh,dB..": "..dm.get())hh=hh+20;if hz%12==0 then hg=hg+iZ(350)hh=i_(200)end end;jK[#jK+1]=gF(iZ(640),i_(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jK[#jK+1]="</g>"return jK end;local hP=iZ(1770)local hQ=i_(350)local hO=i_(15)local hN=iZ(1370)local hT,oE;function o3.DrawRadarInfo()hS=cn.GetRadarHud(hN,hO,hP,hQ)end;function o3.DrawTanks()if aq~=0 and ar~=0 then j3=gF(aq,ar,"","txtstart pdim txtfuel")jm=ar;jn(aq,"Atmospheric ","ATMO",ce,jj,jk)jn(aq,"Space Fuel T","SPACE",cf,jh,ji)jn(aq,"Rocket Fuel ","ROCKET",cg,jf,jg)end end;function o3.DrawShield()local h_=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local oF=b.getPvPTimer()local oG=shield_1.getResistances()local oH="A: "..10+oG[1]*100 .."% / E: "..10+oG[2]*100 .."% / K:"..10+oG[3]*100 .."% / T: "..10+oG[4]*100 .."%"local hg,hh=as-60,at+30;local jC=bG(d8*2.55)local jD=da("rgb(%d,%d,%d)",255-jC,jC,0)local jE=""j4=gF(hg,hh,"","txtmid pdim txtfuel")if d8<10 and h_~="Shield Disabled"then jE="red "end;oF=oF>0 and"   PvPTime: "..im(oF)or""j4=j4 ..da([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hg,hh,jD,d8*2,hg,hh,hg+2,hh+10,d8,oF)j4=j4 ..gF(hg,hh-5,h_,jE.."txtstart pbright txtbig")j4=j4 ..gF(hg,hh+30,oH,jE.."txtstart pbright txtsmall")end;function o3.hudtick()if not iY then return end;local function oI(jK)local jG=bG(db(d6/(cc/4)*255,0,255))jK[#jK+1]=da("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c0,c1,bG(iG+0.5)+jG,bG(iH+0.5)-jG,bG(iI+0.5)-jG)end;local function oJ()for dG,dm in pairs(ir)do if dm.hovered then if not dm.drawCondition or dm.drawCondition(dm)then dm.toggleFunction(dm)end;dm.hovered=false end end;for dG,dm in pairs(iu)do if dm.hovered then bD=dm.label;dm.hovered=false end end end;local function oK()local function oL(oM,oN,hg,hh,nn,no)if oM>=hg and oM<=hg+nn and oN>=hh and oN<=hh+no then return true else return false end end;local hg=c0+cc/2;local hh=c1+cd/2;for dG,dm in pairs(ir)do dm.hovered=oL(hg,hh,dm.x,dm.y,dm.width,dm.height)end;for dG,dm in pairs(iu)do dm.hovered=oL(hg,hh,dm.x,dm.y,dm.width,dm.height)end;if cU then local n2=false;for dG,eu in ipairs(n_)do if eu.hovered then n2=true;break end end;if nX.hovered then n2=true end;cU=n2 else cU=nX.hovered;if not cU then cV=bh end end end;local function oO(jK)if not bD or bD==""then bD="HELP"end;if w then for dB,dm in pairs(iu)do local jE="dim brightstroke"local oP=0.2;if bD==dB then jE="pbright dimstroke"oP=0.6 end;local oQ=""if dm.hovered then oP=0.8;oQ=";stroke:white"end;jK[#jK+1]=da([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dm.width,dm.height,dm.x,dm.y,jE,oP,oQ)jK[#jK+1]=gF(dm.x+dm.width/2,dm.y+dm.height/2+5,dm.label,"txt txtmid pdim")end end end;local function oR(jK)local function oS(jK,oT,hover,hg,hh,fa,oU,oV,oW,oX,oY,o0)if type(oX)=="function"then oX=oX(o0)end;if type(oY)=="function"then oY=oY(o0)end;jK[#jK+1]=da("<rect x='%f' y='%f' width='%f' height='%f' fill='",hg,hh,fa,oU)if oT then jK[#jK+1]=da("%s'",oV)else jK[#jK+1]=oW end;if hover then jK[#jK+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jK[#jK+1]=da(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fN(ac*0.5,0),fN(ad*0.5,0),fN(ae*0.5,0))end;jK[#jK+1]=" rx='5'></rect>"jK[#jK+1]=da("<text x='%f' y='%f' font-size='24' fill='",hg+fa/2,hh+oU/2+5)if oT then jK[#jK+1]="black"else jK[#jK+1]="white"end;jK[#jK+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oT then jK[#jK+1]=da("%s</text>",oX)else jK[#jK+1]=da("%s</text>",oY)end end;local oZ=da("rgb(%d,%d,%d)'",fN(ac*0.1,0),fN(ad*0.1,0),fN(ae*0.1,0))local o_=da("rgb(%d,%d,%d)",fN(ac*0.8,0),fN(ad*0.8,0),fN(ae*0.8,0))local p0=oS;for dG,dm in pairs(ir)do local ns=dm.disableName;local nr=dm.enableName;if type(ns)=="function"then ns=ns(dm)end;if type(nr)=="function"then nr=nr(dm)end;if not dm.drawCondition or dm.drawCondition(dm)then p0(jK,dm.toggleVar(dm),dm.hovered,dm.x,dm.y,dm.width,dm.height,o_,oZ,ns,nr,dm)end end end;local p1=fN(cc/2,0)local p2=fN(cd/2,0)local jK={}if p3 then jK[#jK+1]=p3 end;ck.HUDPrologue(jK)if w then ck.UpdateHud(jK)else if A then ck.DrawVerticalSpeed(jK,c9)end;ck.DrawWarnings(jK)end;if iy and iz~="none"then ck.DrawSettings(jK)end;if radar_1 then ck.DrawRadarInfo()end;ck.HUDEpilogue(jK)jK[#jK+1]=da([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cc,cd)if bV~="empty"then ck.DisplayMessage(jK,bV)end;if ig()==0 and g=="virtual joystick"then if v then ck.DrawDeadZone(jK)end end;oO(jK)if ii()==0 then if ig()==1 and bU then if not p4 then oK()oR(jK)end;if not cq and not cr then local p5=table.concat(jK,"")jK={}jK[#jK+1]=da("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jK[#jK+1]=p5;jK[#jK+1]="</body>"cq=true;jK[#jK+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cr then local p5=table.concat(jK,"")jK={}jK[#jK+1]=da("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cc,cd)jK[#jK+1]=p5;jK[#jK+1]="</body>"end;if not cq then jK[#jK+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c0,c1)end else oJ()end else if not bU and ig()==0 then oJ()if d6>au then if v then oI(jK)end end elseif bU and(not p4 or not i)then oK()oR(jK)end;jK[#jK+1]=da([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p1,p2,c0,c1)end;jK[#jK+1]=[[</svg></body>]]p6=table.concat(jK,"")end;function o3.TenthTick()local function p7()local p8=a.createData;local p9=a.createWidget;pa=a.createWidgetPanel("Interplanetary Helper")pb=p9(pa,"value")pc=p8('{"label": "Target Planet", "value": "N/A", "unit":""}')fL(pc,pb)pd=p9(pa,"value")pe=p8('{"label": "distance", "value": "N/A", "unit":""}')fL(pe,pd)ge=p9(pa,"value")gd=p8('{"label": "Travel Time", "value": "N/A", "unit":""}')fL(gd,ge)gc=p9(pa,"value")gb=p8('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fL(gb,gc)gg=p9(pa,"value")gf=p8('{"label": "Target Altitude", "value": "N/A", "unit":""}')fL(gf,gg)g8=p9(pa,"value")g7=p8('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')g6=p9(pa,"value")g5=p8('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g4=p9(pa,"value")g3=p8('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g2=p9(pa,"value")g1=p8('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ga=p9(pa,"value")g9=p8('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c7 then fL(g7,g8)fL(g5,g6)fL(g3,g4)fL(g1,g2)fL(g9,ga)end end;local function pf()gE(pa)pa=nil end;local function pg()if not a_ then if fY==nil or fY.planetname~=iY.name then ph=(b_.center-cH):len()else ph=(fY.position-cH):len()end end;local fh=cE;local pi=c.getThrottle()/100;if t then pi=bJ end;local pj,pk=ci.computeDistanceAndTime(cE,_,ca,d:maxForceForward()*pi,a1,0)local bY,bZ;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(_)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(_)end;local dG,pl;if not b0 and fh>0 then dG,pl=cm.GetAutopilotBrakeDistanceAndTime(fh)else dG,pl=cm.GetAutopilotTBBrakeDistanceAndTime(fh)end;local pm=0;local pn=0;if ba or not a_ and fh>5 then pn=ci.computeTravelTime(fh,0,ph)elseif bY+pj<ph then pm=ph-(bY+pj)pn=ci.computeTravelTime(8333.0556,0,pm)else local po=(ph-bY)/pj;pj=ph-bY;pk=pk*po end;if fY~=nil and fY.planetname==iY.name and not a_ then return pn elseif b9 then return pl elseif ba then return pn+pl else return pk+bZ+pn end end;ck.DrawTanks()if shield_1 then ck.DrawShield()end;if bf~="None"then if pa==nil then p7()end;if bf~=nil then local mE;local pp=fY~=nil;local pq=0.5*bq/b_:getGravity(b_.center+vec3(0,0,1)*b_.radius):len()pq=pq>1000000 and fN(pq/1000000,2).." kTons"or fN(pq/1000,2).." Tons"fK(pc,'{"label": "Target", "value": "'..bf..'", "unit":""}')lz=pg()if pp and not a_ then mE=(cH-fY.position):len()else mE=(bg-cH):len()end;if not b0 then bY,bZ=cm.GetAutopilotBrakeDistanceAndTime(cE)iC,iD=cm.GetAutopilotBrakeDistanceAndTime(_)else bY,bZ=cm.GetAutopilotTBBrakeDistanceAndTime(cE)iC,iD=cm.GetAutopilotTBBrakeDistanceAndTime(_)end;local lk=il(mE)fK(pe,'{"label": "distance", "value": "'..lk..'"}')fK(gd,'{"label": "Travel Time", "value": "'..im(lz)..'", "unit":""}')lk=il(bY)fK(g7,'{"label": "Cur Brake distance", "value": "'..lk..'"}')fK(g5,'{"label": "Cur Brake Time", "value": "'..im(bZ)..'", "unit":""}')lk=il(iC)fK(g3,'{"label": "Max Brake distance", "value": "'..lk..'"}')fK(g1,'{"label": "Max Brake Time", "value": "'..im(iD)..'", "unit":""}')fK(gb,'{"label": "Max Brake Mass", "value": "'..da("%s",pq)..'", "unit":""}')lk=il(gh)fK(gf,'{"label": "Target Orbit", "value": "'..lk..'"}')if c8>0 and not pr then a.removeDataFromWidget(g1,g2)a.removeDataFromWidget(g3,g4)a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)pr=true;if not cK and t and(b1 or b4 or c5)then cm.cmdThrottle(1)aX=false;bN=false end end;if c8==0 and pr then if fK(g1,g2)==1 then fL(g1,g2)end;if fK(g3,g4)==1 then fL(g3,g4)end;if fK(g5,g6)==1 then fL(g5,g6)end;if fK(g7,g8)==1 then fL(g7,g8)end;if fK(g9,ga)==1 then fL(g9,ga)end;pr=false end end else pf()end;if warpdrive~=nil then if id(warpdrive.getData()).destination~="Unknown"and id(warpdrive.getData()).distance>400000 then warpdrive.show()ps=true else warpdrive.hide()ps=false end end end;function o3.OneSecondTick()local function pt()local jx=bF()local kV=cE;local pu=jx-iO;if kV>1.38889 then kV=kV/1000;local pv=kV*(jx-iO)bj=bj+pv;iL=iL+pv end;iM=iM+pu;bk=bk+pu;iO=jx end;local function pw(jK)local px=0;iE=""local py=ip;local pz=0;local pA=0;local pB=0;local jC=0;local jD=""local pC=b.getElementHitPointsById;local pD=b.getElementMaxHitPointsById;local pE={}for dB in pairs(io)do local pF=0;local pG=0;pG=pD(io[dB])pF=pC(io[dB])pz=pz+pF;if pF<pG then if pF==0 then pB=pB+1 else pA=pA+1 end;if iP and#pE==0 then fP=vec3(b.getElementPositionById(io[dB]))local hg=fP.x;local hh=fP.y;local hi=fP.z;table.insert(pE,b.spawnArrowSticker(hg,hh,hi+1,"down"))table.insert(pE,b.spawnArrowSticker(hg,hh,hi+1,"down"))b.rotateSticker(pE[2],0,0,90)table.insert(pE,b.spawnArrowSticker(hg+1,hh,hi,"north"))table.insert(pE,b.spawnArrowSticker(hg+1,hh,hi,"north"))b.rotateSticker(pE[4],90,90,0)table.insert(pE,b.spawnArrowSticker(hg-1,hh,hi,"south"))table.insert(pE,b.spawnArrowSticker(hg-1,hh,hi,"south"))b.rotateSticker(pE[6],90,-90,0)table.insert(pE,b.spawnArrowSticker(hg,hh-1,hi,"east"))table.insert(pE,b.spawnArrowSticker(hg,hh-1,hi,"east"))b.rotateSticker(pE[8],90,0,90)table.insert(pE,b.spawnArrowSticker(hg,hh+1,hi,"west"))table.insert(pE,b.spawnArrowSticker(hg,hh+1,hi,"west"))b.rotateSticker(pE[10],-90,0,90)table.insert(pE,io[dB])end elseif iP and#pE>0 and pE[11]==io[dB]then for jw in pairs(pE)do b.deleteSticker(pE[jw])end;pE={}end end;px=bG(pz/py*100)if px<100 then jK[#jK+1]=gF(0,0,"","pbright txt")jC=bG(px*2.55)jD=da("rgb(%d,%d,%d)",255-jC,jC,0)if px<100 then jK[#jK+1]=gF("50%",1035,"Elemental Integrity: "..px.."%","txtbig txtmid","fill:"..jD)if pB>0 then jK[#jK+1]=gF("50%",1055,"Disabled Modules: "..pB.." Damaged Modules: "..pA,"txtbig txtmid","fill:"..jD)elseif pA>0 then jK[#jK+1]=gF("50%",1055,"Damaged Modules: "..pA,"txtbig txtmid","fill:"..jD)end end end end;local function pH()if ic then if iF==nil and(d1~=nil or bi)then _autoconf.displayCategoryPanel(ic,weapon_size,"Weapons","weapon",true)iF=_autoconf.panels[_autoconf.panels_size]elseif iF~=nil and d1==nil and not bi then gE(iF)iF=nil end end end;cW=b.getPlayersOnBoard()cX=b.getDockedConstructs()local jK={}pt()if s then pw(jK)end;pH()ck.UpdatePipe()ck.ExtraData(jK)iN=table.concat(jK,"")end;function o3.AnimateTick()cr=true;cq=false;c0=0;c1=0;c.stopTimer("animateTick")end;function o3.MsgTick()local jK={}ck.DisplayMessage(jK,"empty")bV="empty"c.stopTimer("msgTick")bW=3 end;function o3.ButtonSetup()nD()nI()ir=is end;if pI then for dB,dm in pairs(pI)do o3[dB]=dm end end;return o3 end;local function pJ(d,b,c,a,e,vBooster,hover,pK,antigrav,warpdrive,dbHud_1,radar_1,eQ,bG,bH,ig,eL,bF,db,ih,fK,ii,dd,fN,fM,ij,de,il,im,pL,id,da,fL)local pM={}local pN=false;local pO=0;local pP=0;local pQ=0;local pR=bF()local pS=0;local pT=0;local pU=0;local pV=0;local pW=false;local pX=false;local pY=false;local pZ=nil;local p_=0;local iB=55;local q0=nil;local q1=false;local q2=false;local q3=false;local q4=0;local q5=0;local q6=0;local q7=0;local q8=0;local q9={VectorToTarget=false}local qa=vec3(b.getConstructWorldOrientationUp())local qb=nil;local qc=0;local qd=-1;local qe=-1;local qf=false;local qg=false;local qh=0;local qi=false;local qj=false;local qk=false;local ql=false;local qm=""local qn=false;local qo=false;local qp=""local qq=false;local qr=0;local function qs(fh)local qt=bb;if not a_ then qt=0 end;if not c7 then return ci.computeDistanceAndTime(fh,qt,ca,0,0,bo-bd*ca)else if bq and bq>0 then return ci.computeDistanceAndTime(fh,qt,ca,0,0,bq-bd*ca)else return 0,0 end end end;local function qu(fh)local qt=bb;if not a_ then qt=0 end;return ci.computeDistanceAndTime(fh,qt,ca,d:maxForceForward(),a1,bo-bd*ca)end;local function qv(qw,qx,qy)qx=qx:project_on_plane(qw)qy=qy:project_on_plane(qw)return eL(qx:cross(qy):dot(qw),qx:dot(qy))end;local function qz()local function qA()local qB=-1;local qC=-1;if vBooster then qB=vBooster.getDistance()end;if hover then qC=hover.getDistance()end;if qB~=-1 and qC~=-1 then if qB<qC then return qB else return qC end elseif qB~=-1 then return qB elseif qC~=-1 then return qC else return-1 end end;local qD=qA()local qE=-1;if antigrav and antigrav.getState()==1 and not q and cE<iB then local qF=eQ(c9-antigrav.getBaseAltitude())if qF<50 then return qF end end;if pK then qE=pK.getDistance()end;if qD~=-1 and qE~=-1 then if qD<qE then return qD else return qE end elseif qD~=-1 then return qD else return qE end end;local function qG(iY,eC,qH)local function qI(qJ,dN)local eI=vec3(dN)if qJ.id==0 then return setmetatable({latitude=eI.x,longitude=eI.y,altitude=eI.z,id=0,systemId=qJ.systemId},dP)end;local eJ=eI-qJ.center;local c2=eJ:len()local dV=c2-qJ.radius;local dT=0;local dU=0;if not de(c2,0)then local eK=eL(eJ.y,eJ.x)dU=eK>=0 and eK or 2*math.pi+eK;dT=math.pi/2-math.acos(eJ.z/c2)end;return setmetatable({latitude=math.deg(dT),longitude=math.deg(dU),altitude=dV,id=qJ.id,systemId=qJ.systemId},dP)end;local qK=qI(iY,eC)qK="::pos{"..qK.systemId..","..qK.id..","..qK.latitude..","..qK.longitude..","..qK.altitude.."}"if qH then return qK else qk=qK;return true end end;local function qL(qM,qN,qO)local function qP(qM,el)qM=vec3(qM)el=vec3(el):normalize()local dw=qM*el;return dw.x+dw.y+dw.z end;local qQ=0.001;local qR=1;if not c7 or not ct or c6~=-1 or cE<iB then if qO==nil then qO=aO end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=vec3()-qM;local qT=-qP(qS,b.getConstructWorldOrientationRight())*qR;local qU=-qP(qS,b.getConstructWorldOrientationUp())*qR;if pP==0 then pP=qT/2 end;if pQ==0 then pQ=qU/2 end;if eQ(qT)<0.1 then q5=q5-qT*2 else q5=q5-(qT+(qT-pP)*qO)end;if eQ(qU)<0.1 then q4=q4+qU*2 else q4=q4+qU+(qU-pQ)*qO end;pP=qT;pQ=qU;if eQ(qT)<qN and eQ(qU)<qN then return true end;return false elseif ct and c6==-1 then qM=cD;if qO==nil then qO=aO end;if qN==nil then qN=qQ end;qM=vec3(qM):normalize()local qS=cA-qM;local qT=-qP(qS,b.getConstructWorldOrientationRight())*qR;local qU=-qP(qS,b.getConstructWorldOrientationUp())*qR;if pP==0 then pP=qT/2 end;if pQ==0 then pQ=qU/2 end;if eQ(qT)<0.1 then q5=q5-qT*5 else q5=q5-(qT+(qT-pP)*qO)end;if eQ(qU)<0.1 then q4=q4+qU*5 else q4=q4+qU+(qU-pQ)*qO end;pP=qT;pQ=qU;if eQ(qT)<qN and eQ(qU)<qN then return true end;return false end end;function pM.clearAll()b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;cQ=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;bT=false;q2=false;c3=false;c4=false;q3=false;cs=p;bm=false;b0=false;cb=false;bp=nil;bv=false;d4=false;d5=nil end;function pM.GetAutopilotBrakeDistanceAndTime(fh)return qs(fh)end;function pM.GetAutopilotTBBrakeDistanceAndTime(fh)return qu(fh)end;function pM.showWayPoint(iY,eC,qH)return qG(iY,eC,qH)end;function pM.APTick()local qV=a.getMouseWheel()if qV>0 then cm.changeSpd()elseif qV<0 then cm.changeSpd(true)else q1=true end;qh=ii()if qk then a.setWaypoint(qk)qk=false end;if qn then antigrav.setBaseAltitude(qn)qn=false end;if ql then fK(ql,qm)ql=false;qm=""end;if qd~=-1 then cm.cmdThrottle(qd,qf)qf=false;qd=-1 end;if qe~=-1 then cm.cmdCruise(qe,qf)qf=false;qe=-1 end;if qg then co.landingGear()qg=false end;if qo then cm.ToggleAutopilot()end end;function pM.ToggleIntoOrbit()cx=false;pU=nil;pV=nil;p_=0;if not c7 then if bv then fM("orOff","AP")bv=false;pW=false;pZ=nil;cs=p;if b1 then b1=false;b3=false end;q9.VectorToTarget=false;q9.AutopilotAlign=false;pY=false elseif cR then fM("orOn","AP")bv=true;cs=true;if pZ==nil then pZ=iY end;if b1 then b1=false;b3=false end else bV="Unable to engage auto-orbit, not near a planet"end else bv=false;pW=false;pZ=nil;cs=p;if b1 then b1=false end;q9.VectorToTarget=false;q9.AutopilotAlign=false;pY=false end end;function pM.ToggleVerticalTakeoff()b1=false;if b5 then ls=true;b4=false;b3=false;b2=true;cs=true;bS=0;if c7 and c6==-1 then b2=false;b1=true;bS=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qe=bG(cu)end else cx=false;bi=false;d.control.retractLandingGears()ih:setTargetGroundAltitude(X)aX="VTO Takeoff"end;b5=not b5 end;function pM.checkLOS(qM)local lx,eA,eB=ch:getPlanetarySystem(0):castIntersections(cH,qM,function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local ly=eA;if eB~=nil and eA~=nil then ly=math.min(eB,eA)end;if ly~=nil then return lx,ly else return nil,nil end end;function pM.ToggleAutopilot()local function qW(bt)cS=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cm.ToggleAltitudeHold()end end;lB="Proceeding to Waypoint"end;local function qX(gq)if gq then for K,dB in pairs(cN)do if dB.name and dB.name==gq then return K end end else return 0 end end;local qY=false;if bI-pT<1.5 and c7 then if not cz then if c7 then b6=iY.spaceEngineMinAltitude-0.01*iY.noAtmosphericDensityAltitude;fM("11","EP")pT=-1;if a_ or bm or bv then return end else bV="No space engines detected, Orbital Hop not supported"return end elseif iY.hasAtmosphere then if c7 then b6=iY.noAtmosphericDensityAltitude+T;fM("orH","OH")end;pT=-1;if a_ or bm or bv then return end end else pT=bI end;qZ=false;if(bh>0 or#bB>0)and not a_ and not bm and not c4 and not bv then if 0.5*d:maxForceForward()/b.g()<ca then bV="WARNING: Heavy Loads may affect autopilot performance."bW=5 end;if#bB>0 and not c5 then bh=qX(bB[1])cl.UpdateAutopilotTarget()bV="Route Autopilot in Progress"local qS=fY.position-cH;local q_=qS:project_on_plane(cF):len()if q_>50000 and fY.planetname==iY.name then qY=true end end;cl.UpdateAutopilotTarget()cm.showWayPoint(b_,bg)if fY~=nil then if fY.agg and not q and antigrav then if not cJ then cm.ToggleAntigrav()end;br=fY.agg end;bp=nil;bt=fY.planetname=="Space"if bt then fM("apSpc","AP")if c7 then c4=true;cm.ToggleAltitudeHold()else a_=true end elseif iY.name==fY.planetname then ls=true;if c7 then if not bm then fM("vtt","AP")qW(bt)if qY then b6=iY.noAtmosphericDensityAltitude+T end end else fM("apOn","AP")if not(b_.name==iY.name and c9<gh*1.5)then cx=false;a_=true elseif not c7 then if bv then cm.ToggleIntoOrbit()end;cw=iY.noAtmosphericDensityAltitude+T;pY=true;q9.AutopilotAlign=true;q9.VectorToTarget=true;pW=false;if not bv then cm.ToggleIntoOrbit()end end end else fM("apP","AP")aY=false;aZ=false;if c7 then c4=true;cm.ToggleAltitudeHold()else a_=true end end elseif not c7 then if fY==nil and(b_.name==iY.name and cR)and not bv then r0=false;cx=false;pW=false;cm.ToggleIntoOrbit()else fM("apP","AP")a_=true;aY=false;aZ=false;b8=false;bT=false;b1=false;b2=false;b4=false;b3=false;q2=false;bp=nil;r0=false end else fM("apP","AP")c4=true;cm.ToggleAltitudeHold()end;qo=false else fM("apOff","AP")cm.ResetAutopilots(1)if qo==2 then qo=true end end end;function pM.routeWP(r1,r2,r3)if r3 then if r3==1 then bB={}bB=ij(bB,bA)if#bB>0 then bV="Route Loaded"else bV="No Saved Route found on Databank"end;return bB else bA={}bA=ij(bA,bB)bV="Route Saved"pL()return end end;if r1 then return bB end;if r2 then bB={}bV="Current Route Cleared"else bB[#bB+1]=fY.name;bV="Added "..fY.name.." to route. "end;return bB end;function pM.cmdThrottle(dC,r4)if ih:getAxisCommandType(0)~=axisCommandType.byThrottle and not r4 then d.control.cancelCurrentControlMasterMode()end;ih:setThrottleCommand(axisCommandId.longitudinal,dC)bJ=db(fN(dC*100,0)/100,-1,1)qb=nil end;function pM.cmdCruise(dC,r4)if ih:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r4 then d.control.cancelCurrentControlMasterMode()end;ih:setTargetSpeedCommand(axisCommandId.longitudinal,dC)qb=dC end;function pM.ToggleLockPitch()if bp==nil then fM("lkPOn","LP")if not bU then bp=cL else bp=Q end;b3=false;b1=false;b2=false else fM("lkPOff","LP")bp=nil end end;function pM.ToggleAltitudeHold()if bI-pS<1.5 then if iY.hasAtmosphere then if c7 then b6=iY.spaceEngineMinAltitude-0.01*iY.noAtmosphericDensityAltitude;fM("11","EP")else if cR then b6=iY.noAtmosphericDensityAltitude+T;cw=b6;pY=true;if not bv then cm.ToggleIntoOrbit()end;pW=true end end;pS=-1;if b1 or bv or b5 then return end end else pS=bI end;if cR and not c7 then cw=c9;pY=true;pW=true;cm.ToggleIntoOrbit()if bv then pS=bI else pS=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;bT=false;cs=true;bp=nil;cx=false;if c6~=-1 and cE<20 then co.landingGear()fM("lfs","LS")b3=true;if pS>-1 then b6=c9+W end;aX="ATO Hold"ih:setTargetGroundAltitude(X)if aW and cI then cm.ToggleVerticalTakeoff()end else fM("altOn","AH")b3=false;if pS>-1 then if cR then b6=c9 end end;if b5 then cm.ToggleVerticalTakeoff()end end;if cJ and not q then local r5=antigrav.getBaseAltitude()if bm and fY.agg and fY.agg>c9 then b6=fY.agg elseif b3 then b6=r5 end;if eQ(c9-r5)<100 and cE<20 then b6=r5;aX="AGG Hold"qd=0 end end;if c4 then b6=200000 end else fM("altOff","AH")if bv then cm.ToggleIntoOrbit()end;if b5 then cm.ToggleVerticalTakeoff()end;cs=p;b3=false;bm=false;pS=0 end end;function pM.ResetAutopilots(pM)if pM then c4=false;a_=false;b8=false;q2=false;b6=c9;qZ=false;d4=false;bc="Aligning"end;bm=false;b3=false;b4=false;aZ=false;b2=false;d5=nil;r6=false;cQ=nil;d4=false;if not cJ then b1=false;bp=nil end;if b5 then cm.ToggleVerticalTakeoff()end;if bv then cm.ToggleIntoOrbit()end;cs=p;c3=false;c5=false;bS=0 end;function pM.BrakeToggle(r7)if not aX then if r7 then aX=r7 else aX=true end else aX=false end;if b2 then b2=false;cs=p;d4=false end;if aX then fM("bkOn","B",1)cm.ResetAutopilots()else fM("bkOff","B",1)end end;function pM.BeginReentry()if b4 then bV="Re-Entry cancelled"fM("reOff","RE")b4=false;cs=p;b1=false elseif not iY.hasAtmosphere then bV="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bW=5 elseif not q3 then b4=true;if ih:getAxisCommandType(0)~=r8.cruise then d.control.cancelCurrentControlMasterMode()end;cs=true;aX=false;bV="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cu;fM("par","RE")else b4=true;b1=true;cs=true;aX=false;b6=iY.surfaceMaxAltitude+Z;if b6>iY.spaceEngineMinAltitude then b6=iY.spaceEngineMinAltitude-0.01*iY.noAtmosphericDensityAltitude end;local r9=il(b6)bV="Beginning Re-entry.  Target speed: "..cu.." Target Altitude: "..r9;fM("glide","RE")qe=bG(cu)end;b3=false end;function pM.ToggleAntigrav()if antigrav and not q then if cJ then fM("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=c9 end;if br<1000 then br=1000 end;fM("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pM.changeSpd(ra)local rb=1;if ra then rb=-1 end;if not bU then if t and not p4 and q1 then local rc=bJ;bJ=fN(db(bJ+rb*aA/100,-1,1),2)if bJ>=0 and rc<0 then bJ=0;q1=false end elseif p4 then if c7 or b4 then cu=db(cu+rb*aA,0,U)elseif a_ then _=db(_+rb*aA/3.6*100,0,8333.00)end else ih:updateCommandFromActionStart(axisCommandId.longitudinal,rb*aA/10)end else if a_ or bm or c4 or bv then cV=cV+1*rb*-1;if cV>#cN then cV=1 end;if cV<1 then cV=#cN end else if not ra then rb=1 else rb=nil end;cl.adjustAutopilotTargetIndex(rb)end end end;function pM.TenthTick()local function rd(oi,re)if oi==nil then oi=b.g()end;oi=fN(oi,5)if re~=nil and re or(q0==nil or q0~=oi)then local fh=cC:len()local rf=id(c.getData()).maxBrake;if rf~=nil and rf>0 and c7 then rf=rf/db(fh/100,0.1,1)rf=rf/c8;if c8>0.10 then if bq then bq=(bq+rf)/2 else bq=rf end end end;if rf~=nil and rf>0 then bo=rf end;q0=oi end end;rd(nil,true)if qb~=nil then if ih:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ih:getTargetSpeed(axisCommandId.longitudinal)~=qb then qe=qb else qb=nil end end end;function pM.SatNavTick()if not r then return end;qp=dbHud_1.getStringValue("SPBAutopilotTargetName")if qp~=nil and qp~=""and qp~="SatNavNotChanged"then local dw=id(dbHud_1.getStringValue("SavedLocations"))if dw~=nil then bl=dw;local go=-1;local gu;for dB,dm in pairs(bl)do if dm.name and dm.name=="SatNav Location"then go=dB;break end end;if go~=-1 then gu=bl[go]go=-1;for dB,dm in pairs(e[0])do if dm.name and dm.name=="SatNav Location"then go=dB;break end end;if go>-1 then e[0][go]=gu end;cl.UpdateAtlasLocationsList()bV=gu.name.." position updated"end end;for K=1,#cN do if cN[K].name==qp then bh=K;a.print("Index = "..bh.." "..cN[K].name)cl.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pM.onFlush()local function rg(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(b.getConstructOrientationForward())rk=cA elseif rh==axisCommandId.vertical then rj=vec3(b.getConstructOrientationUp())rk=qa elseif rh==axisCommandId.lateral then rj=vec3(b.getConstructOrientationRight())rk=cB else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(b.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cC:dot(rj)local rq=ri*constants.kph2m;if rr==nil then rr=pid.new(10,0,10.0)end;rr:inject(rq-rp)local rs=rr:get()local rt=(rs-ro-rm)*rk;return rt end;local function ru(rh,ri)local rj=vec3()local rk=vec3()if rh==axisCommandId.longitudinal then rj=vec3(b.getConstructOrientationForward())rk=cA elseif rh==axisCommandId.vertical then rj=vec3(b.getConstructOrientationUp())rk=qa elseif rh==axisCommandId.lateral then rj=vec3(b.getConstructOrientationRight())rk=cB else return vec3()end;local rl=vec3(b.getWorldGravity())local rm=rl:dot(rk)local rn=vec3(b.getWorldAirFrictionAcceleration())local ro=rn:dot(rk)local rp=cC:dot(rj)local rq=ri*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(rq-rp)local rs=rv:get()local rt=(rs-ro-rm)*rk;return rt end;local function rw(rx,jN,fU)local ry=rx:cross(fU):normalize_inplace()local ky=math.acos(db(ry:dot(-jN),-1,1))*constants.rad2deg;if ry:cross(-jN):dot(fU)<0 then ky=-ky end;return ky end;local function rz()if cT and not b2 then local ej=cT[1]local hE,hF=cT[2],cT[3]local rA=math.min(hE,hF or hE)local rB=rA/cE;local rC=b3 and(cE<42 or c6~=-1)local rD=b1 or bm or bp or a_;if rD and not rC and(bY*1.5>rA or rB<1)then aX="Collision"bB={}qd=0;if b1 then cm.ToggleAltitudeHold()end;if bp then cm.ToggleLockPitch()end;bV="Autopilot Cancelled due to possible collision"a.print(ej.name.." COLLISION "..im(rB).." / "..il(rA,2))cm.ResetAutopilots(1)ls=true;if c7 then b2=true end;cs=true end;if rB<11 then cS=ej.name.." COLLISION "..im(rB).." / "..il(rA,2)else cS=ej.name.." collision "..im(rB)end;if rB<6 then fM("alarm","AL",2)end else cS=false end end;if antigrav and not q then if not cJ and antigrav.getBaseAltitude()~=br then qn=br end end;if d7 then d:setEngineForceCommand('hover',vec3(),1)d7=false end;cK=ih:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local rE=db(bP+q4+a.getControlDeviceForwardInput(),-1,1)local rF=db(bQ+q6+a.getControlDeviceYawInput(),-1,1)local rG=db(bR+q5-a.getControlDeviceLeftRightInput(),-1,1)local rH=aX and 1 or 0;cF=vec3(b.getWorldVertical())if cF==nil or cF:len()==0 then cF=(iY.center-cH):normalize()end;qa=vec3(b.getConstructWorldOrientationUp())cA=vec3(b.getConstructWorldOrientationForward())cB=vec3(b.getConstructWorldOrientationRight())cD=vec3(b.getWorldVelocity())cC=vec3(b.getVelocity())cH=vec3(b.getConstructWorldPos())ca=b.getConstructMass()cE=vec3(cD):len()cG=-cF:dot(cD)cM=getRoll(cF,cA,cB)local rI=cM/180*math.pi;local rJ=math.cos(rI)local rK=math.sin(rI)cL=rw(cF,cA,cB*rJ+qa*rK)local rL=cD:normalize()local rM=eQ(cM)local rN=utils.sign(cM)local rO=vec3(b.getWorldAngularVelocity())local rP=rE*aK*cB+rF*aF*cA+rG*aL*qa;if cs==true and cF:len()>0.01 then local rQ=eQ(q7-cM)if((aZ or b4 or b2 or c3 or b1 or bv)and rQ>0 or c7 and rQ<aG and p)and rF==0 and eQ(cL)<85 then local rR=q7;local rS=aE;if not c7 then rS=rS/4;q7=0;rR=0 end;if rT==nil then rT=pid.new(rS*0.01,0,rS*0.1)end;rT:inject(rR-cM)local rU=rT:get()rP=rP+rU*cA end end;local rV=1;local rW=0;local rX=1;bK=0;c7=false or c9<iY.noAtmosphericDensityAltitude;c8=bH()c9=b.getAltitude()c6=qz()bI=bF()pR=bI;if bi and c6>-1 and c6-3<Y then if ih.targetGroundAltitudeActivated then ih:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qq=not qq;if qq then cn.UpdateRadar()end;if E then rz()end end;if antigrav then cJ=antigrav.getState()==1 end;local rY=1;local rZ=1;local r_=bI-pR;local s0=-math.deg(qv(qa,cD,cA))local s1=math.deg(qv(cB,cD,cA))local gj=cF*-1;ct=c7 and s0<-L or s0>L or s1<-M or s1>M;local s2=a.getMouseDeltaX()local s3=a.getMouseDeltaY()if qr then local s4=bF()-qr;s2=s2*s4/0.016;s3=s3*s4/0.016 end;qr=bF()if o and not bU then s3=-s3 end;q5=0;q6=0;q4=0;fQ=ch[0]iY=fQ:closestBody(b.getConstructWorldPos())s5=cj(iY)fl=s5:orbitalParameters(b.getConstructWorldPos(),cD)if c9==0 then c9=(cH-iY.center):len()-iY.radius end;cR=c.getClosestPlanetInfluence()>0 or c9>0 and c9<200000;local oi=iY:getGravity(b.getConstructWorldPos()):len()*ca;q7=0;local s6=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if qh==0 then if ig()==1 and bU then if not cq then c0=db(c0+s2/2,-cc/2,cc/2)c1=db(c1+s3/2,-cd/2,cd/2)end else c0=0;c1=0 end else c0=db(c0+s2/2,-cc/2,cc/2)c1=db(c1+s3/2,-cd/2,cd/2)d6=dd(c0*c0+c1*c1)if not bU and ig()==0 then local kH,kI=1,1;if bD=="SCOPE"then kH,kI=cZ/90,cZ/90 end;if g=="virtual joystick"then if d6>au then q5=q5-db(eQ(c0)-au,0,cc/2)*utils.sign(c0)*aC*kH;q4=q4-db(eQ(c1)-au,0,cd/2)*utils.sign(c1)*aD*kI end else c0=0;c1=0;if g=="mouse"then q4=(-utils.smoothstep(s3,-100,100)+0.5)*2*rY;q5=(-utils.smoothstep(s2,-100,100)+0.5)*2*rZ end end end end;local s7=cE>8334;if cE>V/3.6 and not c7 and not a_ and not s7 then bV="Space Speed Engine Shutoff reached"qd=0 end;if not s7 and s8 then if not aX then cm.BrakeToggle()end;if a_ then cm.ResetAutopilots(1)end end;s8=s7;if c8>0.09 then if cE>cu/3.6 and not t and not pN then aX="SpdLmt"pN=true elseif not t and pN then if cE<cu/3.6 then aX=false;pN=false end end end;if aZ then if c3 then aX=false;local s9=false;if fY and c3==true then s9=qL(fY.position-cH,0.1)else s9=qL(vec3(cD),0.01)end;cs=true;if s9 then qe=bG(cu)if(eQ(cM)<2 or eQ(cL)>85)and cE>=cu/3.6-1 then aX=false;aZ=false;if c3~=2 then q3=true end;if c3==true then c5=true end;c3=false;a_=false;cm.BeginReentry()end elseif c7 and t then qd=1 end elseif cE>iB then qL(vec3(cD),0.01)end end;if aY then if c7 then aY=false elseif cE>iB then qL(-vec3(cD))end end;if not aZ and c3 and not bv then if not c7 then if c3~=2 then q3=true end;cm.BeginReentry()c3=false;c5=true else c3=false;if not qo then qo=true end end end;if c5 and fY and(c9<b6+250 and c9>b6-250)and cE*3.6>cu-250 and eQ(cG)<25 and c8>=0.1 and(fY.position-cH):len()>2000+c9 then if not qo then qo=true end;c5=false end;if b5 then cs=true;local sa=b6;if cG<-30 then bV="Unable to achieve lift. Safety Landing."bS=0;cs=p;b5=false;b2=true elseif not q and cJ or b6<iY.spaceEngineMinAltitude then if cJ then sa=antigrav.getBaseAltitude()end;if c9<sa-100 then q8=0;bS=15;aX=false elseif cG>0 then aX="VTO Limit"bS=0 elseif cG<-30 then aX="VTO Fall"bS=15 elseif c9>=sa then if cJ then if a_ or bm then cm.ToggleVerticalTakeoff()else aX="VTO Complete"b5=false end;bV="Takeoff complete. Singularity engaged"fM("aggLk","AG")else aX=false;bV="VTO complete. Engaging Horizontal Flight"fM("vtoc","VT")cm.ToggleVerticalTakeoff()end;bS=0 end else if c8>0.08 then q8=0;aX=false;bS=20 elseif c8<0.08 and c7 then aX=false;if cy then q8=0;bS=20 else bS=0;q8=36;qe=3500 end else cs=p;bv=true;cx=false;sb=false;pW=false;pU=nil;pV=nil;if pZ==nil then pZ=iY end;cw=sa;pY=true;b5=false end end;if q8~=nil then if sc==nil then sc=pid.new(2*0.01,0,2*0.1)end;local sd=db(q8-cL,-M*0.80,M*0.80)sc:inject(sd)local se=db(sc:get(),-1,1)q4=se end end;if bv then local function sf()if fl.periapsis.altitude>=cw*0.99 and fl.apoapsis.altitude>=cw*0.99 and fl.periapsis.altitude<fl.apoapsis.altitude and fl.periapsis.altitude*1.05>=fl.apoapsis.altitude and eQ(cw-c9)<1000 then return true else return false end end;local qS;local sg=false;local sh=il(cw)if pZ==nil then pZ=iY;if bm then pZ=b_ end end;if not pY then cw=bG(pZ.radius+pZ.surfaceMaxAltitude+T)if pZ.hasAtmosphere then cw=bG(pZ.radius+pZ.noAtmosphericDensityAltitude+T)end;pY=true end;if q9.VectorToTarget and fY then qS=fY.position-cH end;local si,sj=cj(pZ):escapeAndOrbitalSpeed((cH-pZ.center):len()-pZ.radius)local sk=cM;if not pW then local sl=false;local sm=false;qd=0;pV=0;cv="Aligning to orbital path - OrbitHeight: "..sh;if q9.VectorToTarget then qL(qS:normalize():project_on_plane(cF))sg=cA:dot(qS:project_on_plane(qa):normalize())>0.95 else qL(cD)sg=s0<0.5;if cE<150 then sg=true end end;q4=0;pU=0;if cL<=pU+2 and cL>=pU-2 then sl=true else sl=false end;if sk<=pV+2 and sk>=pV-2 then sm=true else sm=false end;if sl and sm and sg then pU=nil;pV=nil;pW=true end else if q9.VectorToTarget then qL(qS:normalize():project_on_plane(cF))elseif cE>150 then qL(cD)end;q4=0;if q9.VectorToTarget and fY then local bY,dG=ci.computeDistanceAndTime(cE,cu/3.6,ca,0,0,bo)if cx and qS:len()>15000+bY+c9 then cv="Orbiting to Target"if c9-100<=pZ.noAtmosphericDensityAltitude or lz>fl.timeToPeriapsis and fl.periapsis.altitude<pZ.noAtmosphericDensityAltitude or not sf()and fl.eccentricity>0.1 then bV="Re-Aligning Orbit"cx=false end elseif cx or qS:len()<15000+bY+c9 then bV="Orbit complete, proceeding with reentry"fM("orCom","OB")bg=fY.position;q3=true;c5=true;q9.VectorToTarget,q9.AutopilotAlign=false,false;cm.ToggleIntoOrbit()cm.BeginReentry()return end end;if fl.periapsis~=nil and fl.apoapsis~=nil and fl.eccentricity<1 and c9>cw*0.9 and c9<cw*1.4 then if fl.apoapsis~=nil then if sf()or cx then if cx then aX=false;qd=0;pU=0;if not q9.VectorToTarget then bV="Orbit complete"fM("orCom","OB")cm.ToggleIntoOrbit()end else p_=p_+1;if p_>=2 then cx=true end end else cv="Adjusting Orbit - OrbitHeight: "..sh;pX=true;qe=sj*3.6+1;local sn=cw-c9;if so==nil then so=pid.new(0.1,0,1*0.1)end;so:inject(sn-cG*db(utils.smoothstep(2000-sn,-2000,2000)^6*10,1,10))pU=db(so:get(),-60,60)end end else local sp=2.75;local sq=eQ(fN(si*sp))local ox=sq%50;if ox>0 then sq=sq-ox+50 end;aX=false;if c9<cw*0.8 then cv="Escaping planet gravity - OrbitHeight: "..sh;pU=utils.map(cG,200,0,-15,80)elseif c9>=cw*0.8 and c9<cw*1.15 then cv="Approaching orbital corridor - OrbitHeight: "..sh;sq=sq*0.75;pU=utils.map(cG,100,-100,-15,65)elseif c9>=cw*1.15 and c9<cw*1.5 then cv="Approaching orbital corridor - OrbitHeight: "..sh;sq=sq*0.75;if cG<0 or pX then pU=utils.map(c9,cw*1.5,cw*1.01,-30,0)else pU=utils.map(c9,cw*0.99,cw*1.5,0,30)end elseif c9>cw*1.5 then cv="Reentering orbital corridor - OrbitHeight: "..sh;pU=-65;local sr=utils.map(cG,-150,-400,1,0.55)sq=sq*sr end;qe=bG(sq)end end;if pU~=nil then if ss==nil then ss=pid.new(1*0.01,0,5*0.1)end;local st=pU-cL;ss:inject(st)local su=db(ss:get(),-0.5,0.5)q4=su end end;if a_ and not c7 and not c3 then local function sv(hT,fl)a.print(hT)aX=false;b9=false;a_=false;qZ=false;bc="Aligning"qd=0;q2=false;bV=hT;fM("apCom","AP")if fl or c3 then if fl and gh~=nil and not c3 then if not c9 or c9==0 then return end;cw=c9;pY=true end;cm.ToggleIntoOrbit()end end;local sw,sx=bg,false;if fY and fY.planetname~="Space"then b8=true;if not qZ then local sy=(fY.position-b_.center):normalize()local sz=sy:project_on_plane((b_.center-cH):normalize()):normalize()local sA=b_.center+sz*(b_.radius+gh)local sB=fY.position+(fY.position-b_.center):normalize()*(gh-b_:getAltitude(fY.position))if(cH-sA):len()<(cH-sB):len()then sw=sA else sw=sB;bb=0 end;bg=sw;cm.showWayPoint(b_,bg)sx=true;qZ=true end;bd=0 elseif fY and fY.planetname=="Space"then if not qZ then bd=0;sx=true;b8=true;qZ=true;sw=fY.position+(cH-fY.position):normalize()*R;bg=sw end elseif fY==nil then bd=0;if not qZ then local sy=(cH+cD*100000-b_.center):normalize()local sz=sy:project_on_plane((b_.center-cH):normalize()):normalize()if sz:len()<1 then sy=(cH+cA*100000-b_.center):normalize()sz=sy:project_on_plane((b_.center-cH):normalize()):normalize()end;sw=b_.center+sz*(b_.radius+gh)bg=sw;qZ=true;sx=true;b8=true;cm.showWayPoint(b_,bg)end end;ph=(vec3(sw)-cH):len()local lx,eA,eB=ch:getPlanetarySystem(0):castIntersections(cH,cD:normalize(),function(ej)if ej.noAtmosphericDensityAltitude>0 then return ej.radius+ej.noAtmosphericDensityAltitude else return ej.radius+ej.surfaceMaxAltitude*1.5 end end)local ly=eA;if eB~=nil and eA~=nil then ly=math.min(eB,eA)end;if ly~=nil and ly<ph and lx.name==b_.name then ph=ly end;local s9=true;local sC=(b_.center-(cH+vec3(cD):normalize()*ph)):len()-b_.radius;local lk=il(sC)ql=g9;qm='{"label": "Projected Altitude", "value": "'..lk..'"}'local bY,bZ;if not b0 then bY,bZ=qs(cE)else bY,bZ=qu(cE)end;if cE>50 and b7 then local qS=vec3(sw)-cH;local sD=db(math.deg(qv(qa,cD:normalize(),qS:normalize()))*cE/500,-90,90)local sE=db(math.deg(qv(cB,cD:normalize(),qS:normalize()))*cE/500,-90,90)if eQ(sD)<20 and eQ(sE)<20 then sD=sD*2;sE=sE*2 end;if eQ(sD)<2 and eQ(sE)<2 then sD=sD*2;sE=sE*2 end;local s0=-math.deg(qv(qa,cA,cD:normalize()))local s1=-math.deg(qv(cB,cA,cD:normalize()))if sF==nil then sF=pid.new(2*0.01,0,2*0.1)end;sF:inject(sE-s1)local sG=db(sF:get(),-1,1)q4=q4+sG;if sH==nil then sH=pid.new(2*0.01,0,2*0.1)end;sH:inject(sD-s0)local sI=db(sH:get(),-1,1)q5=q5+sI;sx=true;if eQ(sD)>2 or eQ(sE)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"fM("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"fM("apAcc","AP")end end elseif b7 and cE<=50 then qL((sw-cH):normalize())end;if sC<gh*1.5 then if fY and fY.planetname=="Space"then bb=0 elseif fY==nil then dG,bb=cj(b_):escapeAndOrbitalSpeed(sC)end end;if a_ and not b7 and not ba and not b9 then local lx,ly=cm.checkLOS((bg-cH):normalize())if b_.name~=iY.name then if lx~=nil and b_.name~=lx.name and ly<ph then bV="Collision with "..lx.name.." in "..il(ly).."\nClear LOS to continue."bW=5;qi=true else qi=false;bV=""end end end;if not qi then if not ba and not b9 and not sx then s9=qL((sw-cH):normalize())elseif b0 and(b9 or ba)then s9=qL(-vec3(cD):normalize())end end;if b7 then if not q2 then aX=false;qd=a0;bJ=fN(a0,2)q2=true end;local pi=c.getThrottle()if t then pi=bJ end;local sJ=99999;local ov=-vec3(b.getWorldAcceleration()):dot(cD:normalize())local sK=db(cD:dot((sw-cH):normalize()),0,cE)if sK>0 or ov>0 then sJ=ci.computeTravelTime(sK,ov,ph-bY)end;if cC:len()>=_ or pi==0 and q2 or a1/4>sJ then b7=false;if bc~="Cruising"then fM("apCru","AP")bc="Cruising"end;ba=true;qd=0 end;local sL=ph;if sL<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pO and cP>2000 then cm.ResetAutopilots(1)bV="Autopilot cancelled to prevent crossing PvP Line"aX="PvP Prevent"pO=cP else pO=cP;return end end;b7=false;if bc~="Braking"then fM("apBrk","AP")bc="Braking"end;b9=true;qd=0;q2=false end elseif b9 then if bc~="Orbiting to Target"then aX="AP Brk"end;if b0 then qd=1;qf=true end;local dG,sj=cj(b_):escapeAndOrbitalSpeed((cH-iY.center):len()-iY.radius)local qS;if fY then qS=fY.position-cH end;if fY and fY.planetname=="Space"and cE<50 then if#bB>0 then if not qo then table.remove(bB,1)end;if#bB>0 then aX=false;if not qo then qo=2 end;return end end;sv("Autopilot complete, arrived at space location")aX="Space Arrival"elseif fY and fY.planetname~="Space"and cE<=sj and(fl.apoapsis==nil or fl.periapsis==nil or fl.apoapsis.altitude<=0 or fl.periapsis.altitude<=0)then sv("Autopilot complete, commencing reentry")bg=fY.position;c3=true;cm.showWayPoint(b_,bg)elseif(fY and fY.planetname~="Space"or fY==nil)and fl.periapsis~=nil and fl.periapsis.altitude>0 and fl.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then fM("apCir","AP")bc="Circularizing"end;if cE<=sj then if fY then if cD:normalize():dot(qS:normalize())>0.4 then if bc~="Orbiting to Target"then fM("apOrb","OB")bc="Orbiting to Target"end;if not r0 then aX=false;cm.showWayPoint(b_,fY.position)r0=true end else sv("Autopilot complete, proceeding with reentry")bg=fY.position;c3=true;cm.showWayPoint(b_,fY.position)r0=false end else sv("Autopilot completed, setting orbit",true)aX=false end end elseif bc=="Circularizing"then sv("Autopilot complete, fixing Orbit",true)end elseif ba then local sL=ph;if sL<=bY or H and cP<=bY+10000 and cO then if H and cP<=bY+10000 and cO then if cP<pO and cP>2000 then if not qo then qo=true end;bV="Autopilot cancelled to prevent crossing PvP Line"aX="Prevent PvP"pO=cP else pO=cP;return end end;b7=false;if bc~="Braking"then fM("apBrk","AP")bc="Braking"end;b9=true end;local pi=c.getThrottle()if t then pi=bJ end;if pi>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"fM("apAcc","AP")end;ba=false end else if s9 then if not b8 and fY==nil or not b8 and fY and fY.planetname~="Space"then if not c3 then bg=vec3(b_.center)+(gh+b_.radius)*cB;sM=qa;sN=cB end;b8=true elseif s9 and not qi then b7=true;if bc~="Accelerating"then bc="Accelerating"fM("apAcc","AP")end;if not q2 then qd=a0;qf=true;bJ=fN(a0,2)q2=true;aX=false end end end end elseif a_ and(fY~=nil and fY.planetname~="Space"and c7)then bV="Autopilot complete, starting reentry"fM("apCom","AP")bg=fY.position;aX=false;b9=false;a_=false;qZ=false;bc="Aligning"qd=0;q2=false;aZ=true;c3=true;cm.showWayPoint(b_,fY.position)end;if bT then cs=true;local sE=0;local fn=cH+vec3(c.getMasterPlayerRelativePosition())local sO=fn-cH;local sP=vec3(sO):project_on(cA):len()local sQ=vec3(sO):project_on(cB):len()local c2=dd(sP*sP+sQ*sQ)qL(sO:normalize())local mE=40;local sR=c2<mE;local sS=100;local ri=db((c2-mE)/2,10,sS)q4=0;local s9=eQ(q5)<0.1;if s9 and cE<ri and not sR then aX=false;sE=-20 else aX="Follow"sE=0 end;local sT=0;if eQ(sE-cL)>sT then if sU==nil then sU=pid.new(2*0.01,0,2*0.1)end;sU:inject(sE-cL)local sG=sU:get()q4=sG end end;if b1 or b2 or b4 or bm or bp~=nil then local sV=bq;if sV then sV=sV*db(cE/100,0.1,1)*c8 else sV=bo end;if not c7 then sV=bo end;qc=cA:project_on_plane(cF):normalize():dot(cD)if qc>100 then bY,bZ=ci.computeDistanceAndTime(qc,100,ca,0,0,sV)local sW,sX=ci.computeDistanceAndTime(100,0,ca,0,0,sV*0.55)bY=bY+sW else bY,bZ=ci.computeDistanceAndTime(qc,0,ca,0,0,sV*0.55)end;local sn=b6-c9-cG;local sY=200+cE;if b4 or c3 then sZ=2000+cE end;local s_=1;if b3 then s_=db(cE/100,0.1,1)end;local sE=(utils.smoothstep(sn,-sY,sY)-0.5)*2*O*s_;if not b4 and not c3 and not bm and cA:dot(cD:normalize())<0.99 then sE=(utils.smoothstep(sn,-sY*db(20-19*c8*10,1,20),sY*db(20-19*c8*10,1,20))-0.5)*2*O*db(2-c8*10,1,2)*s_ end;if not b1 then sE=0 end;if bp~=nil then if cR and not bv then sE=bp else bp=nil end end;cs=true;local t0=q4;if b4 then local t1=bG(cu)local t2,t3=ci.computeDistanceAndTime(cE,t1/3.6,ca,0,0,bo-iY.gravity*9.8*ca)t2=t2==-1 and 5000 or t2;local q_=c9-(iY.noAtmosphericDensityAltitude+t2)local t4=c9>iY.noAtmosphericDensityAltitude+t2*1.35;if t4 then sE=P;if cE<=t1/3.6 and cE>t1/3.6-10 and eQ(cD:normalize():dot(cA))>0.9 and not cK then bN=false;qd=1 end elseif(cK or ih:getTargetSpeed(axisCommandId.longitudinal)~=t1)and not t4 and not c7 then qe=t1;qf=true end;if cK then if cE>t1/3.6 and not t4 then aX="Reentry Limit"else aX=false end else aX=false end;if cG>0 then aX="Reentry vSpd"end;if not q3 then sE=-80;if c9<iY.surfaceMaxAltitude+(iY.atmosphereThickness-iY.surfaceMaxAltitude)*0.25 then bV="PARACHUTE DEPLOYED at "..fN(c9,0)b4=false;b2=true;ls=true;qd=0;sE=0;cs=p end elseif iY.noAtmosphericDensityAltitude>0 and t4 then cs=true elseif not t4 then if not c7 and(cK or ih:getTargetSpeed(axisCommandId.longitudinal)~=t1)then qe=t1 end;if cE<t1/3.6+1 then aX=false;q3=false;b4=false;cs=true end end end;if cE>iB and not c4 and not bm and not b2 and u then qL(vec3(cD))end;if cQ or(bm or c4)and bh>0 and c7 then local qS;if cQ then if type(cQ)=="table"then qS=cQ elseif cQ<3 and cQ>0 then qS=-cF:cross(cD)*5000 elseif cQ>=3 then qS=cF:cross(cD)*5000 elseif cQ<0 then qS=cD*25000 end elseif fY~=nil then qS=fY.position-cH else qS=b_.center-cH end;local sD=math.deg(qv(cF:normalize(),cD,qS))*2;local mH=math.rad(eQ(cM))if cE>aH and c7 then local t5=1000+cE;local t6=(utils.smoothstep(sn-cG*10,-t5,t5)-0.5)*2*O;local t7=db(90-t6,0,180)q7=db(sD*2,-t7,t7)local t8=sD;sD=db(db(sD,-L*0.80,L*0.80)*math.cos(mH)+4*(cL-sE)*math.sin(math.rad(cM)),-L*0.80,L*0.80)local t9=1;if q7~=0 then t9=eQ(mH/q7)end;t9=(90-db(eQ(q7-cM),0,90))/90;local ta=sE;if eQ(cM)>90 then ta=-ta end;sE=t9*db(db(ta*math.cos(mH),-M*0.8,M*0.8)+eQ(db(eQ(t8)*math.sin(mH),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q7=0;sD=db(sD,-L*0.80,L*0.80)end;local tb=s0-sD;if cQ and eQ(tb)<=0.0001 and(type(cQ)=="table"or type(cQ)~="table"and cQ<0 and eQ(cM)<1)then if cQ==-2 then cm.ToggleAltitudeHold()end;cQ=nil;fM("180Off","BR")return end;if not ct and cE>aH and c7 then if tc==nil then tc=pid.new(2*0.01,0,2*0.1)end;tc:inject(tb)local sI=db(tc:get(),-1,1)q5=q5+sI elseif c7 and c6>-1 or cE<aH then qL(qS)elseif ct and c7 then if(s0<-L or s0>L)and c7 then qL(cD)end;if(s1<-M or s1>M)and c7 then sE=db(cL-s1,cL-M*0.80,cL+M*0.80)end end;if fY~=nil and not c4 then local sa=iY:getAltitude(fY.position)local q_=qS:project_on_plane(cF):len()ls=true;if not c4 and not b3 and not b4 and(q_<=bY and qS:len()<iY.radius)and(cD:project_on_plane(cF):normalize():dot(qS:project_on_plane(cF):normalize())>0.99 or lB=="Finalizing Approach")then lB="Finalizing Approach"if#bB>0 then if not qo then table.remove(bB,1)end;if#bB>0 then if not qo then qo=2 end;return end end;qd=0;if b1 then cm.ToggleAltitudeHold()bm=true end;aX="AP Finalizing"elseif not b3 then aX=false end;if lB=="Finalizing Approach"and(qc<0.1 or q_<0.1 or td~=nil and td<q_)then fM("bklOn","BL")b2=true;d4=true;if fY.heading then d5=fY.heading else d5=nil end;bm=false;lB="Proceeding to Waypoint"cS=false end;td=q_ end elseif bm and not c7 and b6>iY.noAtmosphericDensityAltitude and not(c4 or b4)then if fY~=nil and b_.name==iY.name then local qS=fY.position-cH;local sa=iY:getAltitude(fY.position)local q_=dd(qS:len()^2-(c9-sa)^2)local sV=bq;if sV then bY,bZ=ci.computeDistanceAndTime(cE,0,ca,0,0,sV/2)ls=true;if q_<=bY+cE*r_/2 and cD:project_on_plane(cF):normalize():dot(qS:project_on_plane(cF):normalize())>0.99 then if iY.hasAtmosphere then aX=false;aZ=false;q3=true;c3=false;c5=true;a_=false;cm.BeginReentry()end end;td=q_ end end end;if not c7 and(b1 and b6>iY.noAtmosphericDensityAltitude)and not(c4 or bv or b4)then if not cx and not bv then cw=b6;pY=true;if bm then q9.VectorToTarget=true end;cm.ToggleIntoOrbit()bm=false;pW=true end end;if ct and c7 and c6==-1 and cE>aH and lB~="Finalizing Approach"then qL(cD)sE=db(cL-s1,cL-M*0.80,cL+M*0.80)end;q4=t0;local qE=-1;if b2 then if not qj then if not cK then qd=0 end;ih:setTargetGroundAltitude(500)ih:activateGroundEngineAltitudeStabilization(500)bx=true;qj=true end;sE=0;local te=false;local tf=math.abs(qc)if not q and cJ then te=antigrav.getBaseAltitude()if te<iY.surfaceMaxAltitude and fY==nil or fY~=nil and iY:getAltitude(fY.position)>te then te=false end else te=false end;if d5 then if tf<0.05 then if cG>-N then aX=false else aX="BL Align BLR"end;if qL(d5,0.001)then d5=nil;cs=p else q4=0;cs=true end else aX="BL Align Hzn"end;if te and eQ(c9-te)<250 then aX="AGG Align"end else local tg=false;local th=30;if tf<10 and s6~=nil and s6>0 then local ti=db(c8,0.4,2)local sV=bq*db(cE/100,0.1,1)*ti;local tj=s6*ti+sV-oi;local tk=sV/2-oi;local tl=cE-dd(eQ(tk/2)*20/(0.5*ca))*utils.sign(tk)if tl<0 then tl=0 end;local tm;if cE>100 then local tn,dG=ci.computeDistanceAndTime(cE,100,ca,0,0,sV)local to,dG=ci.computeDistanceAndTime(100,0,ca,0,0,dd(sV))tm=tn+to else tm=ci.computeDistanceAndTime(cE,0,ca,0,0,dd(sV))end;if tm<20 then aX=false else local tp=0;if tl>100 then local tq,dG=ci.computeDistanceAndTime(tl,100,ca,0,0,tj)local tr,dG=ci.computeDistanceAndTime(100,0,ca,0,0,s6*ti+dd(sV)-oi)tp=tq+tr else tp,dG=ci.computeDistanceAndTime(tl,0,ca,0,0,s6*ti+dd(sV)-oi)end;tp=(tp+15+cE*r_)*1.1;local ts=d4 and fY~=nil and iY:getAltitude(fY.position)>0 and fY.safe;local sa=nil;if te and te<c9 then sa=te elseif ts then sa=iY:getAltitude(fY.position)+250 elseif c9>iY.surfaceMaxAltitude then sa=iY.surfaceMaxAltitude end;if cT then local tt=iY:getAltitude(cT[1].center)if sa then if tt>sa then sa=tt end else sa=tt end end;if sa~=nil then local tu=c9-sa;tg=true;if tu<=tp or tp==-1 or tf>0.05 and d4 then if tf>0.05 and d4 then aX="BL AP Hzn"else aX="BL Stop Dist"end else aX=false end end end end;qE=c6;if qE>-1 then if(cE<1 or cD:normalize():dot(cF)<0)and not d5 then b2=false;b1=false;if not te then qg=true;ih:setTargetGroundAltitude(Y)end;bS=0;aX="BL Complete"cs=p;d4=false else aX="BL Slowing"end elseif not tg then if ls and cD:normalize():dot(-gj)<0.999 then aX="BL Strong"qL()elseif tf>10 or tf>0.05 and d4 then aX="BL hSpd"elseif cG<-N then aX="BL BLR"else aX=false end end end else qj=false end;if b3 or c4 then local lx,eB,eA;if bg~=nil then lx,eB,eA=ch:getPlanetarySystem(0):castIntersections(cH,(bg-cH):normalize(),function(ej)return ej.radius+ej.noAtmosphericDensityAltitude end)end;if cJ and not c4 then if c9>=b6-50 and cE>iB then b3=false;if not a_ and not bm then aX="ATO Agg Arrive"qd=0 end end elseif eQ(sE)<15 and c9/b6>0.75 then b3=false;if not c4 then if cK and not t then d.control.cancelCurrentControlMasterMode()end elseif c4 and cE<iB then a_=true;c4=false;b1=false;b3=false;qd=0 elseif c4 then qd=0;aX="ATO Space"end elseif c4 and not c7 and b_~=nil and(lx==nil or lx.name==b_.name)then a_=true;c4=false;b1=false;b3=false;if not cK then qd=0 end;b7=true end end;local tv=c6>-1;local tw=cL;if(bm or c4 or cQ)and not tv and cE>aH and c7 then local mH=math.rad(eQ(cM))tw=cL*eQ(math.cos(mH))+s1*math.sin(mH)end;local tx=db(sE-tw,-M*0.80,M*0.80)if not c7 and bm then tx=db(sE-tw,-85,O)elseif not c7 then tx=db(sE-tw,-O,O)end;if eQ(cM)<5 or bm or cQ or b2 or tv or b1 then if sU==nil then sU=pid.new(5*0.01,0,5*0.1)end;sU:inject(tx)local sG=sU:get()q4=q4+sG end end;if antigrav~=nil and(antigrav and not q and c9<200000)then if br==nil or br<1000 then br=1000 end;if ty~=br then ty=br;qn=ty end end;if c7 and t and cK then if tz==nil then tz=pid.new(0.1,0,1)end;local tA=0;if aQ>0 and not b4 and c8>0.005 and c8<0.1 and cG>-50 then tA=(0.1-c8)*cu*aQ end;tz:inject(cu/3.6+tA-cD:dot(cA))local tB=tz:get()bM=db(tB,-1,1)if not d0 then if bM<bJ and c8>0.005 then bL=true;d0=db(bM,0.01,1)else bL=false;d0=bJ end end;if tC==nil then tC=pid.new(1*0.01,0,1*0.1)end;tC:inject(cD:len()-cu/3.6-tA)local tD=db(tC:get(),0,1)if c7 and cG<-80 or c8>0.005 then bK=tD end;if bK>0 then if bL and bM==0.01 and not d0 then d0=0 end else bM=db(bM,0.01,1)end;local tE=''local tF=vec3()local tG=rg(axisCommandId.vertical,bS*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tG,rW)local tH='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tH=tH..aR end;local tI=ih:getAxisCommandType(axisCommandId.longitudinal)local tJ=ih:composeAxisAccelerationFromThrottle(tH,axisCommandId.longitudinal)local tK=ru(axisCommandId.lateral,bu*1000)tE=tE..' , '.."lateral airfoil , lateral ground "tF=tF+tK;if tF:len()>constants.epsilon then d:setEngineForceCommand(tE,tF,rW,'','','',rX)end;d:setEngineForceCommand(tH,tJ,rV)local tL='thrust analog vertical fueled 'local tM='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then tM=tM..aS end;if by=="All"or by=="Vertical"then tL=tL..aT end;if bS~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(tL,tG,rV)else d:setEngineForceCommand(tL,vec3(),rV)end;if bu~=0 then d:setEngineForceCommand(tM,tK,rV)else d:setEngineForceCommand(tM,vec3(),rV)end;if rH==0 then rH=bK end;local tN=-rH*(aM*cD+aN*rL)d:setEngineForceCommand('brake',tN)else if t then if not d0 then d0=bJ end end;local ri=c.getAxisCommandValue(0)if not cK then if tC==nil then tC=pid.new(1*0.01,0,1*0.1)end;tC:inject(cD:len()-ri/3.6)local tD=db(tC:get(),0,1)rH=db(rH+tD,0,1)end;local tN=-rH*(aM*cD+aN*rL)d:setEngineForceCommand('brake',tN)local tE=''local tF=vec3()local tO=false;local tH='thrust analog longitudinal 'if by=="All"or by=="Longitude"then tH=tH..aR end;local tI=ih:getAxisCommandType(axisCommandId.longitudinal)if tI==axisCommandType.byThrottle then local tJ=ih:composeAxisAccelerationFromThrottle(tH,axisCommandId.longitudinal)d:setEngineForceCommand(tH,tJ,rV)elseif tI==axisCommandType.byTargetSpeed then local tJ=ih:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tE=tE..' , '..tH;tF=tF+tJ;if ih:getTargetSpeed(axisCommandId.longitudinal)==0 or ih:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ih:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tO=true end end;local tM='thrust analog lateral 'if by=="All"or by=="Lateral"then tM=tM..aS end;local tP=ih:getAxisCommandType(axisCommandId.lateral)if tP==axisCommandType.byThrottle then local tQ=ih:composeAxisAccelerationFromThrottle(tM,axisCommandId.lateral)d:setEngineForceCommand(tM,tQ,rV)elseif tP==axisCommandType.byTargetSpeed then local tK=ih:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tE=tE..' , '..tM;tF=tF+tK end;local tL='thrust analog vertical 'if by=="All"or by=="Vertical"then tL=tL..aT end;local tR=ih:getAxisCommandType(axisCommandId.vertical)if tR==axisCommandType.byThrottle then local tG=ih:composeAxisAccelerationFromThrottle(tL,axisCommandId.vertical)if bS~=0 or b2 and aX then d:setEngineForceCommand(tL,tG,rV,'airfoil','ground','',rX)else d:setEngineForceCommand(tL,vec3(),rV)d:setEngineForceCommand('airfoil vertical',tG,rV,'airfoil','','',rX)d:setEngineForceCommand('ground vertical',tG,rV,'ground','','',rX)end elseif tR==axisCommandType.byTargetSpeed then if bS<0 then d:setEngineForceCommand('hover',vec3(),rV)end;local tS=ih:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tE=tE..' , '..tL;tF=tF+tS end;if tF:len()>constants.epsilon then if rH~=0 or tO or eQ(rL:dot(cA))<0.5 then tE=tE..', brake'end;d:setEngineForceCommand(tE,tF,rW,'','','',rX)end end;local tT=aJ*(rP-rO)local tU=vec3(b.getWorldAirFrictionAngularAcceleration())tT=tT-tU;d:setEngineTorqueCommand('torque',tT,rV,'airfoil','','',rX)d:setBoosterCommand('rocket_engine')if bX and not n then local fh=cC:len()local tV=0.15;if not cK then local tW=ih:getTargetSpeed(axisCommandId.longitudinal)if fh*3.6>tW*(1-tV)and tX then tX=false;d:toggleBoosters()elseif fh*3.6<tW*(1-tV)and not tX then tX=true;d:toggleBoosters()end else local pi=c.getThrottle()if t then pi=bJ*100 end;local ri=pi/100;if bH==0 then ri=ri*_;if fh>=ri*(1-tV)and tX then tX=false;d:toggleBoosters()elseif fh<ri*(1-tV)and not tX then tX=true;d:toggleBoosters()end else local t1=bG(cu)ri=ri*t1/3.6;if fh>=ri*(1-tV)and tX then tX=false;d:toggleBoosters()elseif fh<ri*(1-tV)and not tX then tX=true;d:toggleBoosters()end end end end end;if tY then for dB,dm in pairs(tY)do pM[dB]=dm end end;c6=qz()return pM end;local function tZ(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ig,ih,ii,t_,gE,fN,dW,dc,db,fM,ik,pL)local u0={}local u1=true;local u2=5;local u3=5;local u4=u2;local u5=u3;local u6=bI;function u0.landingGear()bi=not bi;if bi then bm=false;bp=nil;cm.cmdThrottle(0)if vBooster or hover then if c7 and c6==-1 then fM("bklOn","BL")ls=true;b4=false;b3=false;b5=false;b1=false;if b2 then d4=not d4 end;b2=true;cs=true;bi=false else if bO then fM("grOut","LG",1)d.control.extendLandingGears()end;d4=false;ih:setTargetGroundAltitude(Y)if c7 then aX="Landing"end end end;if bO and not b2 and not(vBooster or hover)then fM("grOut","LG",1)d.control.extendLandingGears()end else if bO then fM("grIn","LG",1)d.control.retractLandingGears()end;ih:activateGroundEngineAltitudeStabilization(u7)if bx then ih:setTargetGroundAltitude(X)end end end;function u0.startControl(u8)local function u9(ra)local rb=1;local function ua(ub,ra)local uc={iY.surfaceMaxAltitude+100,iY.spaceEngineMinAltitude-0.01*iY.noAtmosphericDensityAltitude,iY.noAtmosphericDensityAltitude+T,iY.radius*(S-1)+iY.noAtmosphericDensityAltitude}local ud=ub;for dG,dm in ipairs(uc)do if ra and ud>dm then ub=dm elseif ub<dm and not ra then ub=dm;break end end;return ub end;if ra then rb=-1 end;if not q and cJ then if bU and ra then br=1000 elseif br~=nil then br=br+rb*u3;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=ty+rb*100 end elseif b1 or b5 or bv then if bv then if bU then cw=ua(cw,ra)else cw=cw+rb*u2 end;if cw<iY.noAtmosphericDensityAltitude then cw=iY.noAtmosphericDensityAltitude end else if bU and c7 then b6=ua(b6,ra)else b6=b6+rb*u2 end end else if not ra and c6-3<Y and c9>0 then co.landingGear()end;ih:updateTargetGroundAltitudeFromActionStart(rb*1.0)end end;local function ue(uf)if not c7 then bV="Flight Assist in Atmo only"return end;local dj=type(uf)if cQ==nil then if dj=="table"then if a_ or bm then cm.ToggleAutopilot()end;fM("180On","BR")elseif uf==1 then fM("bnkLft","BR")else fM("bnkRht","BR")end;if not b1 and not a_ and not bm then cm.ToggleAltitudeHold()if dj~="table"then uf=uf+1 end end;cQ=uf else fM("180Off","BR")cQ=nil end end;if u8=="gear"then co.landingGear()elseif u8=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif u8=="forward"then bP=bP-1 elseif u8=="backward"then if p4 then ue(-cD*5000)else bP=bP+1 end elseif u8=="left"then if p4 then ue(1)else bQ=bQ-1 end elseif u8=="right"then if p4 then ue(3)else bQ=bQ+1 end elseif u8=="yawright"then bR=bR-1;d5=nil elseif u8=="yawleft"then bR=bR+1;d5=nil elseif u8=="straferight"then ih:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif u8=="strafeleft"then ih:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif u8=="up"then bS=bS+1;if c6-3<Y and c9>0 then co.landingGear()end;ih:deactivateGroundEngineAltitudeStabilization()ih:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif u8=="down"then bS=bS-1;ih:deactivateGroundEngineAltitudeStabilization()ih:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif u8=="groundaltitudeup"then u9()elseif u8=="groundaltitudedown"then u9(true)elseif u8=="option1"then ug=false;if p4 and bU then local uh=""for K=1,#cW do uh=uh.."| Name: "..a.getPlayerName(cW[K]).." Mass: "..fN(b.getBoardedPlayerMass(cW[K])/1000,1).."t "end;a.print("Onboard: "..uh)return end;cl.adjustAutopilotTargetIndex()elseif u8=="option2"then ug=false;if p4 and bU then for K=1,#cW do b.forceDeboard(cW[K])end;bV="Deboarded All Passengers"return end;cl.adjustAutopilotTargetIndex(1)elseif u8=="option3"then local function ui()u1=not u1;if not u1 then fM("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uj,atmofueltank_size,"Atmo Fuel","fuel_container")uk=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(ul,spacefueltank_size,"Space Fuel","fuel_container")um=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(un,rocketfueltank_size,"Rocket Fuel","fuel_container")uo=_autoconf.panels[_autoconf.panels_size]end;up=a.createWidgetPanel("Docking")uq=a.createWidget(up,"parenting")a.addDataToWidget(c.getDataId(),uq)ur=a.createWidgetPanel("Core combat stress")us=a.createWidget(ur,"core_stress")a.addDataToWidget(b.getDataId(),us)if shield_1~=nil then shield_1.show()end else fM("hud","DH")c.hide()b.hide()if uk~=nil then gE(uk)uk=nil end;if up~=nil then gE(up)up=nil end;if ur~=nil then gE(ur)ur=nil end;if um~=nil then gE(um)um=nil end;if uo~=nil then gE(uo)uo=nil end;if shield_1~=nil then shield_1.hide()end end end;ug=false;if p4 and bU then local uh=""for K=1,#cX do uh=uh.."| ID: "..cX[K].." Mass: "..fN(b.getDockedConstructMass(cX[K])/1000,1).."t "end;a.print("Docked Ships: "..uh)return end;if x then if w then w=false else w=true end end;ui()elseif u8=="option4"then ug=false;if p4 and bU then for K=1,#cX do b.forceUndock(cX[K])end;bV="Undocked all ships"return end;cQ=nil;cm.ToggleAutopilot()elseif u8=="option5"then ug=false;cm.ToggleLockPitch()elseif u8=="option6"then ug=false;if p4 and bU then if shield_1 then cp.ventShield()else bV="No shield found"end;return end;cm.ToggleAltitudeHold()elseif u8=="option7"then ug=false;if p4 and bU then if shield_1 then shield_1.toggle()return else bV="No shield found"return end end;E=not E;if E then bV="Collision System Enabled"else bV="Collision System Secured"end elseif u8=="option8"then ug=false;if p4 and bU then if bh>0 and fY~=nil then cm.routeWP()else bV="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then bV="DeCoupled Mode - Ground Stabilization off"ih:deactivateGroundEngineAltitudeStabilization()fM("gsOff","GS")else bV="Coupled Mode - Ground Stabilization on"ih:activateGroundEngineAltitudeStabilization(u7)d7=true;fM("gsOn","GS")end elseif u8=="option9"then ug=false;if p4 and bU then ih:resetCommand(axisCommandId.longitudinal)ih:resetCommand(axisCommandId.lateral)ih:resetCommand(axisCommandId.vertical)cm.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cb=gyro.getState()==1;if cb then fM("gyOn","GA")else fM("gyOff","GA")end else bV="No gyro found"end elseif u8=="lshift"then cU=false;if p4 then bU=true end;if ii()==1 then bU=true;be=ii()t_(1)elseif ig()==1 and y then bU=true;cr=false;cq=false end elseif u8=="brake"then if aV or p4 then cm.BrakeToggle("Manual")elseif not aX then cm.BrakeToggle("Manual")else aX="Manual"end elseif u8=="lalt"then ug=true;p4=true;if ig()==0 and not i and g=="keyboard"then t_(1)end elseif u8=="booster"then if n then d:toggleBoosters()elseif not bX then if not tX then d:toggleBoosters()tX=true end;bX=true else if tX then d:toggleBoosters()tX=false end;bX=false end elseif u8=="stopengines"then local function ut()if bI-u6<1.5 then fM("clear","CA")cm.clearAll()end end;ut()u6=bI;if ih:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bJ~=0 then ih:resetCommand(axisCommandId.longitudinal)cm.cmdThrottle(0)else cm.cmdThrottle(100)end else if ih:getTargetSpeed(axisCommandId.longitudinal)~=0 then ih:resetCommand(axisCommandId.longitudinal)else if c7 then cm.cmdCruise(U)else cm.cmdCruise(_*3.6)end end end elseif u8=="speedup"then cm.changeSpd()elseif u8=="speeddown"then cm.changeSpd(true)elseif u8=="antigravity"and not q then if antigrav~=nil then cm.ToggleAntigrav()else bV="No antigrav found"end end end;function u0.stopControl(u8)local function uu()if not q and cJ then u5=u3 end;if b1 or b5 or bv then u4=u2 end end;if u8=="forward"then bP=0 elseif u8=="backward"then bP=0 elseif u8=="left"then if cQ then if cQ==2 then cQ=-2 else cQ=-1 end end;bQ=0 elseif u8=="right"then if cQ then if cQ==4 then cQ=-2 else cQ=-1 end end;bQ=0 elseif u8=="yawright"then bR=0 elseif u8=="yawleft"then bR=0 elseif u8=="straferight"then ih:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif u8=="strafeleft"then ih:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif u8=="up"then bS=0;ih:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then ih:activateGroundEngineAltitudeStabilization(u7)d7=true end elseif u8=="down"then bS=0;ih:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then ih:activateGroundEngineAltitudeStabilization(u7)d7=true end elseif u8=="groundaltitudeup"then uu()ug=false elseif u8=="groundaltitudedown"then uu()ug=false elseif u8=="lshift"then if ii()==1 then c0=0;c1=0;t_(be)elseif ig()==1 and y then cr=false;cq=false end;bU=false elseif u8=="brake"then if not aV and not p4 then if aX then cm.BrakeToggle()else aX=false end end elseif u8=="lalt"then if ig()==0 and i then if ug then if ii()==1 then t_(0)else t_(1)end else ug=true end elseif ig()==0 and not i and g=="keyboard"then t_(0)end;p4=false end end;function u0.loopControl(u8)local function uv(ra)local rb=1;if ra then rb=-1 end;if not q and cJ then if br~=nil then br=br+rb*u5;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;u5=db(u5*1.05,u3,50)else br=ty+rb*100 end elseif b1 or b5 or bv then if bv then cw=cw+rb*u4;if cw<iY.noAtmosphericDensityAltitude then cw=iY.noAtmosphericDensityAltitude end else b6=b6+rb*u4 end;u4=db(u4*1.05,u2,50)else ih:updateTargetGroundAltitudeFromActionLoop(rb*1.0)end end;local function uw(ra)local rb=1;if ra then rb=-1 end;if not bU then if t and not p4 then bJ=db(bJ+rb*aB/100,-1,1)else ih:updateCommandFromActionLoop(axisCommandId.longitudinal,rb*aB)end end end;if u8=="groundaltitudeup"then if not bU then uv()end elseif u8=="groundaltitudedown"then if not bU then uv(true)end elseif u8=="speedup"then uw()elseif u8=="speeddown"then uw(true)end end;function u0.inputTextControl(r9)local function ux(uy,fn,gr)local function uz(fn)local dt=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..dt..','..dt..','..dt..','..dt..','..dt..'}'local dK,dL,dT,dU,dV=dW(fn,du)if dK=="0"and dL=="0"then return vec3(dc(dT),dc(dU),dc(dV))end;dU=math.rad(dU)dT=math.rad(dT)local iY=e[dc(dK)][dc(dL)]local eM=math.cos(dT)local uA=vec3(eM*math.cos(dU),eM*math.sin(dU),math.sin(dT))return iY.center+(iY.radius+dV)*uA end;local fP=uz(fn)return cl.AddNewLocation(uy,fP,gr)end;local K;local uB,i4=nil,nil;local uC="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r9," ")uB=r9;if K~=nil then uB=string.sub(r9,0,K-1)i4=string.sub(r9,K+1)end;if uB=="/help"or uB=="/commands"then for lt in string.gmatch(uC,"([^\n]+)")do a.print(lt)end;return elseif uB=="/setname"then if i4==nil or i4==""then bV="Usage: ah-setname Newname"return end;if bh>0 and fY~=nil then cl.UpdatePosition(i4)else bV="Select a saved target to rename first"end elseif shield_1 and uB=="/resist"then cp.setResist(i4)elseif uB=="/addlocation"or string.find(r9,"::pos")~=nil then local gr=false;local uy="0-Temp"if i4==nil or i4==""or uB~="/addlocation"then i4=uB;gr=true end;K=string.find(i4,"::")if not gr then uy=string.sub(i4,1,K-2)end;local fn=string.sub(i4,K)ux(uy,fn,gr)elseif uB=="/agg"then if i4==nil or i4==""then bV="Usage: /agg targetheight"return end;i4=dc(i4)if i4<1000 then i4=1000 end;br=i4;bV="AGG Target Height set to "..i4 elseif uB=="/G"then if i4==nil or i4==""then bV="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i4=="dump"then for dB,dm in pairs(ik())do if type(dm.get())=="boolean"then if dm.get()==true then a.print(dB.." true")else a.print(dB.." false")end elseif dm.get()==nil then a.print(dB.." nil")else a.print(dB.." "..dm.get())end end;return end;K=string.find(i4," ")local uD=string.sub(i4,0,K-1)local uE=string.sub(i4,K+1)for dB,dm in pairs(ik())do if dB==uD then bV="Variable "..uD.." changed to "..uE;local uF=type(dm.get())if uF=="number"then uE=dc(uE)if dB=="AtmoSpeedLimit"then cu=uE end elseif uF=="boolean"then if string.lower(uE)=="true"then uE=true else uE=false end end;dm.set(uE)return end end;bV="No such global variable: "..uD elseif uB=="/deletewp"then if bh>0 and fY~=nil then cl.ClearCurrentPosition()else bV="Select a custom wp to delete first in IPH"end elseif uB=="/copydatabank"then if dbHud_2 then pL(true)else bV="Spare Databank required to copy databank"end elseif uB=="/iphWP"then if bh>0 then a.print(cm.showWayPoint(b_,bg,true))a.print(json.encode(bg))bV="::pos waypoint shown in lua chat in local and world format"else bV="No target selected in IPH"end elseif uB=="/createPrivate"then local uG="privatelocations = {\n"local uH=""if#d2>0 then for dB,dm in pairs(d2)do uG=uG.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then uG=uG.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then uG=uG.."safe = true},\n"else uG=uG.."safe = false},\n"end end end;uH=#d2 .."-Private "if i4=="all"then for dB,dm in pairs(bl)do uG=uG.."{position = {x = "..dm.position.x..", y = "..dm.position.y..", z = "..dm.position.z.."},\n ".."name = '*"..dm.name.."',\n planetname = '"..dm.planetname.."',\n gravity = "..dm.gravity..",\n"if dm.heading then uG=uG.."heading = {x = "..dm.heading.x..", y = "..dm.heading.y..", z = "..dm.heading.z.."},\n"end;if dm.safe then uG=uG.." safe = true},\n"else uG=uG.."safe = false},\n"end end;uH=uH..#bl.."-Public "end;uG=uG.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(uG)end;bV=uH.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bW=7 end end;function u0.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;bV="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;if uI then for dB,dm in pairs(uI)do u0[dB]=dm end end;return u0 end;local function uJ(d,b,c,a,library,e,vBooster,hover,pK,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ic,screenHud_1)local uK={}local da=string.format;local id=json.decode;local uL=json.encode;local pD=b.getElementMaxHitPointsById;local ie=b.getElementMassById;local ig=d.control.isRemoteControlled;local dW=string.match;local gE=a.destroyWidgetPanel;local fK=a.updateData;local fL=a.addDataToWidget;local t_=a.lockView;local ii=a.isViewLocked;local dd=math.sqrt;local dc=tonumber;local eQ=math.abs;local bG=math.floor;local bH=c.getAtmosphereDensity;local eL=math.atan;local bF=a.getTime;local db=utils.clamp;local ih=d.axisCommandManager;local uM=Y;local gG=13;local io=b.getElementIdList()local ip=0;local function de(et,eu)if et==0 then return eQ(eu)<1e-09 end;if eu==0 then return eQ(et)<1e-09 end;return eQ(et-eu)<math.max(eQ(et),eQ(eu))*ds end;local function fN(dt,uN)local rb=10^(uN or 0)return bG(dt*rb+0.5)/rb end;local function ij(uO,uP)for dB,dm in pairs(uP)do if type(dB)=="string"then uO[dB]=dm else uO[#uO+1]=uP[dB]end end;return uO end;local function ik(uQ)local uR={}if not uQ then ij(uR,J)ij(uR,a8)ij(uR,az)ij(uR,aU)return uR elseif uQ=="boolean"then return J elseif uQ=="handling"then return a8 elseif uQ=="hud"then return az elseif uQ=="physics"then return aU end end;local function pL(uS)local function uT(uU)for dB,dm in pairs(uU)do dbHud_1.setStringValue(dB,uL(dm.get()))if uS and dbHud_2 then dbHud_2.setStringValue(dB,uL(dm.get()))end end end;if dbHud_1 then uT(bC)uT(ik())a.print("Saved Variables to Datacore")if uS and dbHud_2 then bV="Databank copied.  Remove copy when ready."end end end;local function fM(uV,uW,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uV..".mp3")end;local function gF(hg,hh,r9,jE,uX)if jE==nil then jE=""end;if uX==nil then uX=""end;return da([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jE,hg,hh,uX,r9)end;local function il(c2,uY)local uZ=c2>100000;if uY==nil then uY=1 end;if uZ then return fN(c2/1000/200,uY).."SU"elseif c2<1000 then return fN(c2,uY).."M"else return fN(c2/1000,uY).."KM"end end;local function im(u_)local v0=0;local v1=0;local v2=0;if u_<60 then u_=bG(u_)elseif u_<3600 then v0=bG(u_/60)u_=bG(u_%60)elseif u_<86400 then v1=bG(u_/3600)v0=bG(u_%3600/60)else v2=bG(u_/86400)v1=bG(u_%86400/3600)end;if v2>0 then return v2 .."d "..v1 .."h "elseif v1>0 then return v1 .."h "..v0 .."m "elseif v0>0 then return v0 .."m "..u_.."s"elseif u_>0 then return u_.."s"else return"0s"end end;function uK.onStart()local v3=false;local function v4()local function v5(v6)local v7=dbHud_1.hasKey;for dB,dm in pairs(v6)do if v7(dB)then local dw=id(dbHud_1.getStringValue(dB))if dw~=nil then dm.set(dw)v3=true end end end end;if dbHud_1 then if not f then v5(ik())coroutine.yield()v5(bC)else v5(bC)bV="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bW=5;v3=false end;coroutine.yield()if v3 then bV="Loaded Saved Variables"cc=a9;cd=aa;aV=j;g=string.lower(g)cs=p;cu=U elseif not f then bV="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if T<2000 then bV="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bz=VERSION_NUMBER;if#bl>0 then d3=ij(d3,bl)end else bV="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bI then bq=0 end;bs=bI;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bV="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bW=7 end;if antigrav and not q then if br==nil then br=c9 end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d2>0 then d3=ij(d3,d2)end end;lB="Proceeding to Waypoint"end;local function v8()local function v9(va,vb)if va>vb then vb=va end;local vc,vd=0,0;if a5>0 then vc=a5*0.05 end;if a6>0 then vd=a6*0.05 end;vb=vb*(1-(vc+vd))return vb end;local ve=b.getElementNameById;local vf=aq~=0 and ar~=0;local vg=_G["atmofueltank_size"]local vh=_G["spacefueltank_size"]local vi=_G["rocketfueltank_size"]for dB in pairs(io)do local type=b.getElementTypeById(io[dB])if dW(type,'^.*Atmospheric Engine$')then if dW(tostring(b.getElementTagsById(io[dB])),'^.*vertical.*$')and b.getElementForwardById(io[dB])[3]>0 then cI=true end end;if dW(type,'^.*Space Engine$')then cz=true;if dW(tostring(b.getElementTagsById(io[dB])),'^.*vertical.*$')then local vj=b.getElementForwardById(io[dB])if vj[3]<0 then vk=true else cy=true end end end;if type=="Landing Gear"then bO=true end;if type=="Dynamic Core Unit"then local pF=pD(io[dB])if pF>10000 then gG=110 elseif pF>1000 then gG=55 elseif pF>150 then gG=27 end end;ip=ip+pD(io[dB])if vf and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pF=pD(io[dB])local oq=ie(io[dB])local va=0;local jx=bF()if type=="Atmospheric Fuel Tank"then local vb=400;local vl=35.03;if pF>10000 then vb=51200;vl=5480 elseif pF>1300 then vb=6400;vl=988.67 elseif pF>150 then vb=1600;vl=182.67 end;va=oq-vl;if a2>0 then vb=vb+vb*a2*0.2 end;vb=v9(va,vb)local gq=ve(io[dB])local jv=0;for jw=1,vg do if gq==id(c["atmofueltank_"..jw].getData()).name then jv=jw;break end end;local vm={io[dB],string.sub(gq,1,12),vb,vl,va,jx,jv}ce[#ce+1]=vm end;if type=="Rocket Fuel Tank"then local vb=320;local vl=173.42;if pF>65000 then vb=40000;vl=25740 elseif pF>6000 then vb=5120;vl=4720 elseif pF>700 then vb=640;vl=886.72 end;va=oq-vl;if a4>0 then vb=vb+vb*a4*0.1 end;vb=v9(va,vb)local gq=ve(io[dB])local jv=0;for jw=1,vi do if gq==id(c["rocketfueltank_"..jw].getData()).name then jv=jw;break end end;local vm={io[dB],string.sub(gq,1,12),vb,vl,va,jx,jv}cg[#cg+1]=vm end;if type=="Space Fuel Tank"then local vb=600;local vl=35.03;if pF>10000 then vb=76800;vl=5480 elseif pF>1300 then vb=9600;vl=988.67 elseif pF>150 then vb=2400;vl=182.67 end;va=oq-vl;if a3>0 then vb=vb+vb*a3*0.2 end;vb=v9(va,vb)local gq=ve(io[dB])local jv=0;for jw=1,vh do if gq==id(c["spacefueltank_"..jw].getData()).name then jv=jw;break end end;local vm={io[dB],string.sub(gq,1,12),vb,vl,va,jx,jv}cf[#cf+1]=vm end end end;if not cI then b5,aW=false,false end end;local function vn()if gyro~=nil then cb=gyro.getState()==1 end;if not bx then ih:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then t_(1)else t_(0)end;if door and(c7 or not c7 and c9<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c7 or not c7==0 and c9<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;if antigrav then cJ=antigrav.getState()==1;if cJ and not q then antigrav.show()end end;if ig()==1 and k then a.freeze(1)else a.freeze(0)end;if bO then if c6~=-1 and not cJ then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bi=d.control.isAnyLandingGearExtended()==1 or c6-3<Y;if c6~=-1 or not c7 and cC:len()<50 then aX="Startup"else aX=false end;ih:setTargetGroundAltitude(uM)pr=c7 end;local function vo()local vp={}local function vq()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vr={[1]=4480,[6]=4480,[7]=6270}for vs,vt in pairs(e)do e[vs][0]=vq()e[vs][0].systemId=vs;vp[vs]={}for vu,iY in pairs(e[vs])do iY.gravity=iY.gravity/9.8;iY.center=vec3(iY.center)iY.name=iY.name[1]iY.noAtmosphericDensityAltitude=iY.atmosphereThickness or iY.atmosphereRadius-iY.radius;iY.spaceEngineMinAltitude=vr[iY.id]or 0.68377*iY.atmosphereThickness;iY.planetarySystemId=vs;iY.bodyId=iY.id;vp[vs][vu]=iY;if mt==nil or iY.center.x<mt then mt=iY.center.x end;if ms==nil or iY.center.x>ms then ms=iY.center.x end;if mw==nil or iY.center.y<mw then mw=iY.center.y end;if mv==nil or iY.center.y>mv then mv=iY.center.y end;if iY.center and iY.name~="Space"then cY[#cY+1]=iY end end end;e5=d9(d,b,c,a,da,db,dc,dd,de)ch=e5(vp)ci=eP(d,b,c,a,dd,eQ)cj=fj(d,b,c,a,da,db,dc,dd,de)cl=fJ(d,b,c,a,dbHud_1,e,fK,fL,bG,dc,dd,fM,fN)iY=ch[0]:closestBody(b.getConstructWorldPos())end;vv=false;vw=coroutine.create(function()ih:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v4()coroutine.yield()v8()coroutine.yield()cm=pJ(d,b,c,a,e,vBooster,hover,pK,antigrav,warpdrive,dbHud_1,radar_1,eQ,bG,bH,ig,eL,bF,db,ih,fK,ii,dd,fN,fM,ij,de,il,im,pL,id,da,fL)vn()coroutine.yield()vo()if radar_1 then cn=gD(b,a,c,library,radar_1,radar_2,eQ,gE,dd,gF,dc,gG,fM)end;ck=ib(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,warpdrive,ic,eQ,bG,da,id,bH,ie,ig,eL,bF,db,ih,fL,fK,gE,ii,dd,fN,gF,fM,ij,ik,il,im,io,ip)ck.ButtonSetup()co=tZ(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,gyro,screenHud_1,ig,ih,ii,t_,gE,fN,dW,dc,db,fM,ik,pL)if shield_1 then cp=hW(shield_1,dW,bG)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield_1 then c.setTimer("shieldTick",0.0166667)end;if vx then vy.ExtraOnStart()end;fM("start","SU")end)coroutine.resume(vw)end;function uK.onUpdate()if not vv then local hL=coroutine.status(vw)if hL=="suspended"then local dC,hM=coroutine.resume(vw)if hM then a.print("ERROR STARTUP: "..hM)end elseif hL=="dead"then vv=true end end;if vv then d:update()if c7 and t and cK then if cK and bN then cm.cmdThrottle(0)bN=false elseif not cK and not bN then bJ=0;bN=true end end;if d0 then ih:setThrottleCommand(axisCommandId.longitudinal,d0)d0=nil end;if not cq and p6~=vz then a.setScreen(p6)end;vz=p6;if vx then vy.ExtraOnUpdate()end end end;function uK.onFlush()if vv then cm.onFlush()if vx then vy.ExtraOnFlush()end end end;function uK.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(c8>0 or c8==0 and c9<10000)then for dG,dm in pairs(door)do dm.toggle()end end;if switch then for dG,dm in pairs(switch)do dm.toggle()end end;if forcefield and(c8>0 or c8==0 and c9<10000)then for dG,dm in pairs(forcefield)do dm.toggle()end end;w=c_;pL()if o0 then o0.activate()end;if z then cm.showWayPoint(iY,cH)end;a.print(ck.FuelUsed("atmofueltank")..", "..ck.FuelUsed("spacefueltank")..", "..ck.FuelUsed("rocketfueltank"))if vx then vy.ExtraOnStop()end;fM("stop","SU")end;function uK.controlStart(u8)if vv then co.startControl(u8)end end;function uK.controlStop(u8)if vv then co.stopControl(u8)end end;function uK.controlLoop(u8)if vv then co.loopControl(u8)end end;function uK.controlInput(r9)if vv then co.inputTextControl(r9)end end;function uK.radarEnter(dL)cn.onEnter(dL)end;function uK.radarLeave(dL)cn.onLeave(dL)end;function uK.onTick(vA)if vA=="tenthSecond"then cm.TenthTick()ck.TenthTick()elseif vA=="oneSecond"then ck.OneSecondTick()elseif vA=="fiveSecond"then cm.SatNavTick()elseif vA=="msgTick"then ck.MsgTick()elseif vA=="animateTick"then ck.AnimateTick()elseif vA=="hudTick"then ck.hudtick()elseif vA=="apTick"then cm.APTick()elseif vA=="shieldTick"then cp.shieldTick()elseif vA=="tagTick"then co.tagTick()elseif vA=="contact"then cn.ContactTick()end end;if vx then for dB,dm in pairs(vx)do uK[dB]=dm end end;return uK end;function script.onStart()vy.onStart()end;function script.onStop()vy.onStop()end;function script.onTick(vA)vy.onTick(vA)end;function script.onFlush()vy.onFlush()end;function script.onUpdate()vy.onUpdate()end;function script.onActionStart(u8)vy.controlStart(u8)end;function script.onActionStop(u8)vy.controlStop(u8)end;function script.onActionLoop(u8)vy.controlLoop(u8)end;function script.onInputText(r9)vy.controlInput(r9)end;function script.onEnter(dL)vy.radarEnter(dL)end;function script.onLeave(dL)vy.radarLeave(dL)end;bE(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)vy=uJ(d,b,c,a,library,e,vBooster,hover,pK,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield_1,gyro,warpdrive,ic,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
