name: ArchHud - Archaegeo v1.5201 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5201;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=""local aC=true;local aD=ResolutionX;local aE=ResolutionY;local aF={}local aG={}local aH={}local aI=0;local aJ=false;local aK=nil;local aL=nil;local aM=nil;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=false;local aU=false;local aV=autoRollPreference;local aW=LandingGearGroundHeight;local aX=false;local aY=0;local aZ=AtmoSpeedLimit;local a_=0;local b0=nil;local b1={VectorToTarget=false}local b2=0;local b3=false;local b4=false;local b5=false;local b6=false;local b7=vec3(core.getConstructWorldOrientationUp())local b8=vec3(core.getConstructWorldOrientationForward())local b9=vec3(core.getConstructWorldOrientationRight())local ba=vec3(core.getVelocity())local bb=vec3(core.getWorldVelocity())local bc=vec3(bb):len()local bd=vec3(core.getWorldVertical())local be=-bd:dot(bb)local bf=vec3(core.getConstructWorldPos())local bg=false;local bh=false;local bi=nil;local bj=true;local bk=0;local bl=0;local bm={}local bn=false;local bo=50000;local bp=nil;local bq={}local br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bs=false;local bt=nil;local bu={}local bv="Atmo"local bw=false;local bx=0;local by={}local bz=nil;local bA=nil;local bB={}scopeFOV=90;function p(bC)system.print(E..": "..bC)end;local function bD(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bF=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bF<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then aZ=r(aZ+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bx=bx+1*D*-1;if bx>#bm then bx=1 end;if bx<1 then bx=#bm end else if not bE then D=1 else D=nil end;aQ.adjustAutopilotTargetIndex(D)end end end;local function bG(bH,bI,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bH.."|"..bI.."|"..soundVolume)end end;local function bJ(bK,bL)for i=1,#bL do bK[#bK+1]=bL[i]end;return bK end;local function bM(bN)local bO={}local bP={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local bQ={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local bR={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local bS={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not bN then bJ(bO,bP)bJ(bO,bQ)bJ(bO,bR)bJ(bO,bS)return bO elseif bN=="boolean"then return bP elseif bN=="handling"then return bQ elseif bN=="hud"then return bR elseif bN=="physics"then return bS end end;local function bT(bU,bV,bW,bX,bY)if bX==nil then bX=""end;if bY==nil then bY=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],bX,bU,bV,bY,bW)end;local function bZ(b_,c0)if b_==0 then return d(c0)<1e-09 end;if c0==0 then return d(b_)<1e-09 end;return d(b_-c0)<math.max(d(b_),d(c0))*epsilon end;local function c1(aj,c2)local c3=aj>100000;if c2==nil then c2=1 end;if c3 then return A(aj/1000/200,c2).."SU"elseif aj<1000 then return A(aj,c2).."M"else return A(aj/1000,c2).."KM"end end;local function c4(c5)local c6=0;local c7=0;local c8=0;if c5<60 then c5=e(c5)elseif c5<3600 then c6=e(c5/60)c5=e(c5%60)elseif c5<86400 then c7=e(c5/3600)c6=e(c5%3600/60)else c8=e(c5/86400)c7=e(c5%86400/3600)end;if c8>0 then return c8 .."d "..c7 .."h "elseif c7>0 then return c7 .."h "..c6 .."m "elseif c6>0 then return c6 .."m "..c5 .."s"elseif c5>0 then return c5 .."s"else return"0s"end end;local function c9(ca)local function cb(cc)for cd,ce in pairs(cc)do dbHud_1.setStringValue(ce,h(_G[ce]))if ca and dbHud_2 then dbHud_2.setStringValue(ce,h(_G[ce]))end end end;if dbHud_1 then cb(c)cb(bM())system.print("Saved Variables to Datacore")if ca and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cf()local function cg(ch)return type(ch)=='number'end;local function ci(ch)return type(z(ch))=='number'end;local function cj(ck)return type(ck)=='table'end;local function cl(cm)return type(cm)=='string'end;local function cn(ce)return cj(ce)and cg(ce.x and ce.y and ce.z)end;local function co(cp)return cj(cp)and cg(cp.latitude and cp.longitude and cp.altitude and cp.id and cp.systemId)end;local cq=math.pi/180;local cr=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function ct(ch)local cu=string.gsub(string.reverse(f('%.4f',ch)),'^0*%.?','')return cu==''and'0'or string.reverse(cu)end;local function cv(cw)if cn(cw)then return f('{x=%.3f,y=%.3f,z=%.3f}',cw.x,cw.y,cw.z)end;if cj(cw)and not getmetatable(cw)then local cx={}local cy=next(cw)if type(cy)=='nil'or cy==1 then cx=cw else for cd,ce in pairs(cw)do local cz=cv(ce)if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end end;return f('{%s}',table.concat(cx,','))end;if cl(cw)then return f("'%s'",cw:gsub("'",[[\']]))end;return tostring(cw)end;local cA={}cA.__index=cA;cA.__tostring=function(cw,cB)local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)local cx={}for _,cd in ipairs(cC)do local cz=cv(cw[cd])if type(cd)=='number'then table.insert(cx,f('[%s]=%s',cd,cz))else table.insert(cx,f('%s=%s',cd,cz))end end;if cB then return f('%s%s',cB,table.concat(cx,',\n'..cB))end;return f('{%s}',table.concat(cx,','))end;cA.__eq=function(cD,cE)return cD.systemId==cE.systemId and cD.id==cE.id and bZ(cD.radius,cE.radius)and bZ(cD.center.x,cE.center.x)and bZ(cD.center.y,cE.center.y)and bZ(cD.center.z,cE.center.z)and bZ(cD.GM,cE.GM)end;local function cF(cG,cH,cI,cJ,cK)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cI),'Argument 3 (radius) must be a number:'..type(cI))assert(cj(cJ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(cJ))assert(ci(cK),'Argument 5 (GM) must be a number:'..type(cK))return setmetatable({systemId=z(cG),id=z(cH),radius=z(cI),center=vec3(cJ),GM=z(cK)},cA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,ct(p.latitude*cr),ct(p.longitude*cr),ct(p.altitude))end;MapPosition.__eq=function(cD,cE)return cD.id==cE.id and cD.systemId==cE.systemId and bZ(cD.latitude,cE.latitude)and bZ(cD.altitude,cE.altitude)and(bZ(cD.longitude,cE.longitude)or bZ(cD.latitude,math.pi/2)or bZ(cD.latitude,-math.pi/2))end;local function cL(cM,cH,cN,cO,cP)local cG=cM;if cl(cM)and not cO and not cP and not cH and not cN then cG,cH,cN,cO,cP=o(cM,cs)assert(cG,'Argument 1 (position string) is malformed.')else assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(cN),'Argument 3 (latitude) must be in degrees:'..type(cN))assert(ci(cO),'Argument 4 (longitude) must be in degrees:'..type(cO))assert(ci(cP),'Argument 5 (altitude) must be in meters:'..type(cP))end;cG=z(cG)cH=z(cH)cN=z(cN)cO=z(cO)cP=z(cP)if cH==0 then return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=cH,systemId=cG},MapPosition)end;return setmetatable({latitude=cq*r(cN,-90,90),longitude=cq*(cO%360),altitude=cP,id=cH,systemId=cG},MapPosition)end;local cQ={}cQ.__index=cQ;cQ.__tostring=function(cw,cB)local cR=cB and cB..'  'local cS={}local cC={}for cd in pairs(cw)do table.insert(cC,cd)end;table.sort(cC)for _,cT in ipairs(cC)do bdy=cw[cT]local cU=cA.__tostring(bdy,cR)if cB then table.insert(cS,f('[%s]={\n%s\n%s}',cT,cU,cB))else table.insert(cS,f('  [%s]=%s',cT,cU))end end;if cB then return f('\n%s%s%s',cB,table.concat(cS,',\n'..cB),cB)end;return f('{\n%s\n}',table.concat(cS,',\n'))end;local function cV(cW)local b={}local pid;for _,ce in pairs(cW)do local cH=ce.planetarySystemId;if type(cH)~='number'then error('Invalid planetary system ID: '..tostring(cH))elseif pid and cH~=pid then error('Mistringmatch planetary system IDs: '..cH..' and '..pid)end;local cX=ce.bodyId;if type(cX)~='number'then error('Invalid body ID: '..tostring(cX))elseif b[cX]then error('Duplicate body ID: '..tostring(cX))end;setmetatable(ce.center,getmetatable(vec3.unit_x))b[cX]=setmetatable(ce,cA)pid=cH end;return setmetatable(b,cQ)end;aK={}local function cY(cW)return setmetatable({galaxyAtlas=cW or{}},aK)end;aK.__index=function(ck,i)if type(i)=='number'then local system=ck.galaxyAtlas[i]return cV(system)end;return rawget(aK,i)end;aK.__pairs=function(cw)return function(ck,cd)local cZ,nv=next(ck,cd)return cZ,nv and cV(nv)end,cw.galaxyAtlas,nil end;aK.__tostring=function(cw)local c_={}for _,d0 in pairs(cw or{})do local d1=d0:getPlanetarySystemId()local d2=cQ.__tostring(d0,'    ')table.insert(c_,f('  [%s]={%s\n  }',d1,d2))end;return f('{\n%s\n}\n',table.concat(c_,',\n'))end;aK.BodyParameters=cF;aK.MapPosition=cL;aK.PlanetarySystem=cV;function aK.createBodyParameters(cG,cH,d3,d4,d5,d6,d7)assert(ci(cG),'Argument 1 (systemId) must be a number:'..type(cG))assert(ci(cH),'Argument 2 (id) must be a number:'..type(cH))assert(ci(d3),'Argument 3 (surfaceArea) must be a number:'..type(d3))assert(cj(d4),'Argument 4 (aPosition) must be an array or vec3:'..type(d4))assert(cj(d5),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(d5))assert(ci(d6),'Argument 6 (altitude) must be in meters:'..type(d6))assert(ci(d7),'Argument 7 (gravityAtPosition) must be number:'..type(d7))local cI=y(d3/4/math.pi)local aj=cI+d6;local d8=vec3(d4)+aj*vec3(d5)local cK=d7*aj*aj;return cF(cG,cH,cI,d8,cK)end;aK.isMapPosition=co;function aK:getPlanetarySystem(cM)if i==nil then i=0 end;if nv==nil then nv=0 end;local cG=cM;if co(cM)then cG=cM.systemId end;if type(cG)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=cQ then system=cV(system)end;return system end end end;function cQ:sizeCalculator(d9)return 1.05*d9.radius end;function cQ:castIntersections(da,db,dc,dd,de,df)local dg={}local dh=de or self;for _,d9 in pairs(dh)do table.insert(dg,d9)end;if not df then table.sort(dg,function(di,dj)return(di.center-da):len()<(dj.center-da):len()end)end;local dk=db:normalize()for _,d9 in ipairs(dg)do local dl=d9.center-da;local cI=self:sizeCalculator(d9)local dm=dl:dot(dk)local dn=dm^2-(dl:len2()-cI^2)if dn>=0 then local dp=y(dn)local dq=dm+dp;local dr=dm-dp;if dr>0 then return d9,dq,dr elseif dq>0 then return d9,dq,nil end end end;return nil,nil,nil end;function cQ:closestBody(ds)assert(type(ds)=='table','Invalid coordinates.')local dt,d9;local du=vec3(ds)for _,dv in pairs(self)do local dw=(dv.center-du):len2()if(not d9 or dw<dt)and dv.name~="Space"then d9=dv;dt=dw end end;return d9 end;function cQ:convertToBodyIdAndWorldCoordinates(cM)local dx=cM;if cl(cM)then dx=cL(cM)end;if dx.id==0 then return 0,vec3(dx.latitude,dx.longitude,dx.altitude)end;local dv=self:getBodyParameters(dx)if dv then return dx.id,dv:convertToWorldCoordinates(dx)end end;function cQ:getBodyParameters(cM)local cH=cM;if co(cM)then cH=cM.id end;assert(ci(cH),'Argument 1 (id) must be a number:'..type(cH))return self[cH]end;function cQ:getPlanetarySystemId()local _,ce=next(self)return ce and ce.systemId end;function cA:convertToMapPosition(cJ)assert(cj(cJ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(cJ))local dy=vec3(cJ)if self.id==0 then return setmetatable({latitude=dy.x,longitude=dy.y,altitude=dy.z,id=0,systemId=self.systemId},MapPosition)end;local dz=dy-self.center;local aj=dz:len()local cP=aj-self.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dA=n(dz.y,dz.x)cO=dA>=0 and dA or 2*math.pi+dA;cN=math.pi/2-math.acos(dz.z/aj)end;return setmetatable({latitude=cN,longitude=cO,altitude=cP,id=self.id,systemId=self.systemId},MapPosition)end;function cA:convertToWorldCoordinates(cM)local dx=cl(cM)and cL(cM)or cM;if dx.id==0 then return vec3(dx.latitude,dx.longitude,dx.altitude)end;assert(co(dx),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dx.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dx.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dB=math.cos(dx.latitude)return self.center+(self.radius+dx.altitude)*vec3(dB*math.cos(dx.longitude),dB*math.sin(dx.longitude),math.sin(dx.latitude))end;function cA:getAltitude(cJ)return(vec3(cJ)-self.center):len()-self.radius end;function cA:getDistance(cJ)return(vec3(cJ)-self.center):len()end;function cA:getGravity(cJ)local dC=self.center-vec3(cJ)local dD=dC:len2()return self.GM/dD*dC/y(dD)end;return setmetatable(aK,{__call=function(_,...)return cY(...)end})end;local function dE()local aM={}local dF=30000000/3600;local dG=dF*dF;local dH=100;function aM.computeAccelerationTime(dI,dJ,dK)local dL=dF*math.asin(dI/dF)return(dF*math.asin(dK/dF)-dL)/dJ end;function aM.computeDistanceAndTime(dI,dK,dM,dN,dO,dP)dO=dO or 0;dP=dP or 0;local dQ=dI<=dK;local dR=dN*(dQ and 1 or-1)/dM;local dS=-dP/dM;local dT=dR+dS;if dQ and dT<=0 or not dQ and dT>=0 then return-1,-1 end;local dU,dV=0,0;if dR~=0 and dO>0 then local dL=math.asin(dI/dF)local dW=math.pi*(dR/2+dS)local dX=dR*dO;local dY=dF*math.pi;local ce=function(ck)local dZ=(dW*ck-dX*math.sin(math.pi*ck/2/dO)+dY*dL)/dY;local d_=math.tan(dZ)return dF*d_/y(d_*d_+1)end;local e0=dQ and function(cm)return cm>=dK end or function(cm)return cm<=dK end;dV=2*dO;if e0(ce(dV))then local e1=0;while d(dV-e1)>0.5 do local ck=(dV+e1)/2;if e0(ce(ck))then dV=ck else e1=ck end end end;local e2=dI;local e3=dV/dH;for e4=1,dH do local e5=ce(e4*e3)dU=dU+(e5+e2)*e3/2;e2=e5 end;if dV<2*dO then return dU,dV end;dI=e2 end;local dL=dF*math.asin(dI/dF)local E=(dF*math.asin(dK/dF)-dL)/dT;local e6=dG*math.cos(dL/dF)/dT;local aj=e6-dG*math.cos((dT*E+dL)/dF)/dT;return aj+dU,E+dV end;function aM.computeTravelTime(dI,dJ,aj)if aj==0 then return 0 end;if dJ>0 then local dL=dF*math.asin(dI/dF)local e6=dG*math.cos(dL/dF)/dJ;return(dF*math.acos(dJ*(e6-aj)/dG)-dL)/dJ end;if dI==0 then return-1 end;assert(dI>0,'Acceleration and initial speed are both zero.')return aj/dI end;return aM end;local function e7()local vec3=require('cpml.vec3')local cf=cf()local function cl(cm)return type(cm)=='string'end;local function cj(ck)return type(ck)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(cP)assert(self.body)local aj=cP+self.body.radius;if not bZ(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(cM,e8)assert(self.body)assert(cj(cM)or cl(cM))assert(cj(e8))local e9=(cl(cM)or cf.isMapPosition(cM))and self.body:convertToWorldCoordinates(cM)or vec3(cM)local ce=vec3(e8)local ea=e9-self.body.center;local eb=ce:len2()local ec=ea:len()local ed=self.body.GM;local ee=((eb-ed/ec)*ea-ea:dot(ce)*ce)/ed;local b_=ed/(2*ed/ec-eb)local ef=ee:len()local dk=ee:normalize()local eg=b_*(1-ef)local eh=b_*(1+ef)local ei=eg*dk+self.body.center;local ej=ef<=1 and-eh*dk+self.body.center or nil;local ek=y(b_*ed*(1-ef*ef))local el=ej and 2*math.pi*y(b_^3/ed)local em=math.acos(ee:dot(ea)/(ef*ec))if ea:dot(ce)<0 then em=-(em-2*math.pi)end;local en=math.acos((math.cos(em)+ef)/(1+ef*math.cos(em)))local eo=en;if eo<0 then eo=eo+2*math.pi end;local ep=eo-ef*math.sin(eo)local eq=0;local er=0;local es=0;if el~=nil then eq=ep/(2*math.pi/el)er=el-eq;es=er+el/2;if em-math.pi>0 then er=eq;es=er+el/2 end;if es>el then es=es-el end end;return{periapsis={position=ei,speed=ek/eg,circularOrbitSpeed=y(ed/eg),altitude=eg-self.body.radius},apoapsis=ej and{position=ej,speed=ek/eh,circularOrbitSpeed=y(ed/eh),altitude=eh-self.body.radius},currentVelocity=ce,currentPosition=e9,eccentricity=ef,period=el,eccentricAnomaly=en,meanAnomaly=ep,timeToPeriapsis=er,timeToApoapsis=es,trueAnomaly=em}end;local function et(eu)local dv=cf.BodyParameters(eu.systemId,eu.id,eu.radius,eu.center,eu.GM)return setmetatable({body=dv},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return et(...)end})end;local function ev()local ew={}local ex={}local ey={XS=13,S=27,M=55,L=110,XL=221}local ez={}local eA;local eB;local eC;local eD;local eE;local function eF()local function eG(eH,eI,eJ,eK,eL,eM,eN,eO)eI,eK,eM,eO=vec3(eI),vec3(eK),vec3(eM),vec3(eO)local eP,eQ,eR=eH*eH,eJ*eJ,eL*eL;local eb=eK-eI;local eS=eb:normalize()local eT=eb:len()local eU=eM-eI;local eV=(eU-eU:project_on(eS)):normalize()local eW,eX=eU:dot(eS),eU:dot(eV)local eY=eW*eW+eX*eX;local eZ=eS:cross(eV)local bU=(eP-eQ+eT*eT)/(2*eT)local bV=(eP-eR+eY-2*eW*bU)/(2*eX)local cp=eP-bU^2-bV^2;local e_=y(cp)local f0=eI+eS*bU+eV*bV+eZ*e_;local f1=eI+eS*bU+eV*bV-eZ*e_;if d((eO-f0):len()-eN)<d((eO-f1):len()-eN)then return f0 else return f1 end end;local function f2()local function f3()local f4=core.getConstructWorldOrientationRight()local eb=core.getConstructWorldOrientationForward()local eU=core.getConstructWorldOrientationUp()local f5=library.systemResolution3(f4,eb,eU,{1,0,0})local f6=library.systemResolution3(f4,eb,eU,{0,1,0})local f7=library.systemResolution3(f4,eb,eU,{0,0,1})return function(f8)return library.systemResolution3(f5,f6,f7,f8)end end;local f9=f3()local fa=core.getConstructWorldPos()local e9=core.getElementPositionById(1)local fb={e9[1],e9[2],e9[3]}local fc=f9(fb)local fd={fa[1]-fc[1],fa[2]-fc[2],fa[3]-fc[3]}return fd end;local function fe(ff,ec,fg)local fh=ff.pts;local fi=#fh;local fj=ff.ref;if fi>3 then local fk,fl,fm,fn=fh[fi],fh[fi-1],fh[fi-2],fh[fi-3]ff.ref=fg;local e9=eG(fk[1],fk[2],fl[1],fl[2],fm[1],fm[2],fn[1],fn[2])local bU,bV,e_=e9.x,e9.y,e9.z;if bU==bU and bV==bV and e_==e_ then bU=bU+fj[1]bV=bV+fj[2]e_=e_+fj[3]local fo=vec3(bU,bV,e_)if not ff.lastPos then ff.center=fo elseif(ff.lastPos-fo):len()<2 then ff.center=fo;ff.skipCalc=true end;ff.lastPos=fo end;ff.pts={}else local fp={fg[1]-fj[1],fg[2]-fj[2],fg[3]-fj[3]}fh[fi+1]={ec,fp}end end;if bu[1]then eA=#bu[1].getConstructIds()local fq=bu[1].getData()local fr=fq:gmatch('{"constructId[^}]*}[^}]*}')if eA>0 then local fg=f2()local fs,ft=0,0;eE,eD=0,0;for ce in fr do local cH,aj,fu=ce:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fv=ey[fu]aj=z(aj)if bu[1].hasMatchingTransponder(cH)==1 then table.insert(ex,cH)end;local fw=bu[1].getConstructType(cH)if CollisionSystem then if fv>27 or fw=="static"or fw=="space"then eE=eE+1;local fx=bu[1].getConstructName(cH)local ff=bq[cH]if ff==nil then fv=fv+G;bq[cH]={pts={},ref=fg,name=fx,i=0,radius=fv,skipCalc=false}ff=bq[cH]end;if not ff.skipCalc then fe(ff,aj,fg)ft=ft+1 end;if ff.center then table.insert(ez,ff)end end;fs=fs+1;if br and fs>700 or ft>70 or(not br and fs>300 or ft>30)then coroutine.yield()fs,ft=0,0 end end end;eD=#ez;if eD>0 and bc>20 then local d9,fy,fz,fA;local fB=0;local fC=aL:getPlanetarySystem(0)fA=bb:normalize()while fB<eD do coroutine.yield()local fD={table.unpack(ez,fB,math.min(fB+75,eD))}d9,fy,fz=fC:castIntersections(bf,fA,nil,nil,fD,true)if d9 and fz then bt={d9,fy,fz}break end;fB=fB+75 end;if not d9 then bt=nil end else bt=nil end;ez={}eB=fq:find('identifiedConstructs":%[%]')else eC=fq:find('worksInEnvironment":false')end end end;local function fE()if bu[1]then bv="Atmo"if bu[1].getData():find('worksInAtmosphere":false')then bv="Space"end end end;function ew.pickType()fE()end;function ew.assignRadar()if radar_1 and bu[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bu[1]=radar_2 end;if bu[1]==radar_2 then fE()end elseif radar_2 and bu[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bu[1]=radar_1 end;if bu[1]==radar_1 then fE()end end end;function ew.UpdateRadar()local fF=coroutine.status(UpdateRadarCoroutine)if fF=="suspended"then local cz,fG=coroutine.resume(UpdateRadarCoroutine)if fG then system.print("ERROR UPDATE RADAR: "..fG)end elseif fF=="dead"then UpdateRadarCoroutine=coroutine.create(eF)local cz,fG=coroutine.resume(UpdateRadarCoroutine)end end;function ew.GetRadarHud()local fH=ex;ex={}return eB,eC,eA,eD,eE,fH end;UpdateRadarCoroutine=coroutine.create(eF)return ew end;local function fI()local fJ=9.80665;local fK={}local fL={}local fM={}local by={}local fN=nil;local fO=nil;local fP=nil;local fQ=false;local fR={}local fS=showHud;local fT=""local fU=vec3({13771471,7435803,-128971})local fV=18000000;local fW=500000;local fX,fY=math.huge;local fZ;local function f_(g0)fX=vec3(g0):dist(fU)if fX<fV then return true,d(fX-fV)end;fY=vec3(g0):dist(vec3(planet.center))if fY<fW then fZ=true else fZ=false end;if d(fY-fW)<d(fX-fV)then return fZ,d(fY-fW)else return fZ,d(fX-fV)end end;local function g1(ce)if aD==1920 then return ce else return A(aD*ce/1920,0)end end;local function g2(ce)if aE==1080 then return ce else return A(aE*ce/1080,0)end end;local function g3()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function g4()local g5="TRAVEL"if not bj then g5="CRUISE"end;if Autopilot then g5="AUTOPILOT"end;return g5 end;local g6={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local g7=""local g8=""local g9=""local ga=1;local gb=2;local gc=3;local gd=4;local ge=5;local gf=6;local gg=""local gh=0;local gi=e(1/apTickRate)*2*hudTickRate;local gj={}local gk={}local gl={}local gm={}local gn={}local go={}local function gp(bU,gq,gr,gs,gt,gu)local gv=tankY;local gw=tankY+5;if not BarFuelDisplay then gw=gw+5 end;if m()==1 and not RemoteHud then gv=gv-50;gw=gw-50 end;if gr=="ATMO"then gg="atmofueltank"elseif gr=="SPACE"then gg="spacefueltank"else gg="rocketfueltank"end;gh=_G[gg.."_size"]if#gs>0 then for i=1,#gs do local fx=string.sub(gs[i][gb],1,12)local gx=0;for gy=1,gh do if gs[i][gb]==g(unit[gg.."_"..gy].getData()).name then gx=gy;break end end;local gz=q()if gt[i]==nil or gu[i]==nil or gz-gs[i][gf]>gi then local gA;local gB=0;if gx~=0 then gu[i]=g(unit[gg.."_"..gx].getData()).percentage;gt[i]=g(unit[gg.."_"..gx].getData()).timeLeft;if gt[i]=="n/a"then gt[i]=0 end else gB=l(gs[i][ga])-gs[i][gd]gu[i]=e(0.5+gB*100/gs[i][gc])gA=gs[i][ge]if gA<=gB then gt[i]=0 else gt[i]=e(0.5+gB/((gA-gB)/(gz-gs[i][gf])))end;gs[i][ge]=gB;gs[i][gf]=gz end end;if fx==gq then fx=f("%s %d",gr,i)end;if gx==0 then fx=fx.." *"end;local gC;if gt[i]==0 then gC=""else gC=c4(gt[i])end;if gu[i]~=nil then local gD=e(gu[i]*2.55)local gE=f("rgb(%d,%d,%d)",255-gD,gD,0)local bX=""if gC~=""and gt[i]<120 or gu[i]<5 then bX="red "end;local gF=f("rgb(%d,%d,%d)",r(e((255-gD)/2.55),50,100),r(e(gD/2.55),0,50),50)local gG="rgb(196,0,255)"if gr=="ATMO"then gG="rgb(0,188,255)"elseif gr=="SPACE"then gG="rgb(239,255,0)"end;local gH=false;if previous~=gG then gH=true end;previous=gG;if BarFuelDisplay then if gH then gv=gv-5;gw=gw-5 end;g8=g8 ..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gF,gG,bU,gw,gE,e(gu[i]*1.7+0.5)-2,bU+1,gw+1,bU+5,gw+14,fx,gu[i],gC)gv=gv-22;gw=gw-22 else g8=g8 ..bT(bU,gv,fx,bX.."pdim txtfuel")g8=g8 ..bT(bU,gw,f("%d%% %s",gu[i],gC),"pdim txtfuel","fill:"..gE)gv=gv+30;gw=gw+30 end end end end;tankY=gv end;local function gI(gJ,cP)if cP<200000 and not aq or cP and aq then local gK=0;if d(be)>1 then gK=45*math.log(d(be),10)if be<0 then gK=-gK end end;gJ[#gJ+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(be),e(gK))end;return gJ end;local function gL(gM)local gN=-bd;gM=gM-gM:project_on(gN)local gO=vec3(0,0,1)gO=gO-gO:project_on(gN)local gP=gO:cross(gN)local gK=gO:angle_between(gM)*constants.rad2deg;if gM:dot(gP)<0 then gK=360-gK end;return gK end;local function gQ(gJ,centerX,centerY,gR,gS,br)local gT=circleRad;local gU=20;local gV=e(gR)if br then for i=-45,45,5 do local gW=i;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],gW,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gJ[#gJ+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gT+gU-len,centerX,centerY+gT+gU)end;gJ[#gJ+1]=bT(centerX,centerY+gT+gU-35,gS,"pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY+gT+gU-25,gV.." deg","pdim txt txtmid")gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gT+gU-20,centerX+5,centerY+gT+gU-20,centerX,centerY+gT+gU-15)gJ[#gJ+1]="</g>"end;gJ[#gJ+1]=[[<g style="clip-path: url(#headingClip);">]]local gX=gV;if br then gX=gL(b8)end;local gY=20;local gZ=e(gX)local g_=0;local h0=centerY+gT+gU+20;local h1=centerX;if gS~="YAW"then h0=g2(130)h1=g1(960)end;local h2=[[<path class="txttick line" d="]]local h3=e(gZ-(gY+10)-gZ%5+0.5)for i=h3+70,h3,-5 do local bU=h1-(-i*5+gX*5)if i%10==0 then g_=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gJ[#gJ+1]=bT(bU,h0+15,B,"txtmid bright")elseif i%5==0 then g_=5 end;if g_==10 then h2=f([[%s M %f %f v %d]],h2,bU,h0-5,g_)else h2=f([[%s M %f %f v %d]],h2,bU,h0-2.5,g_)end end;gJ[#gJ+1]=h2 ..[["/>]]gJ[#gJ+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],h1-5,h0-20,h1+5,h0-20,h1,h0-10)if br then gS="HDG"end;gJ[#gJ+1]=bT(g1(960),g2(100),gZ.."°","dim txt txtmid size14","")gJ[#gJ+1]=bT(g1(960),g2(85),gS,"dim txt txtmid size20","")gJ[#gJ+1]=[[</g>]]end;local function h4(gJ,h5,gR,centerX,centerY,br,h6,e5)local gT=circleRad;local h7=e(gT*3/5)if gT>0 then local h8=e(h5)local len=0;local h2=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gR,centerX,centerY)if not aq then h2=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gJ[#gJ+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gT-1,centerX,centerY)gJ[#gJ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(h8-30-h8%5+0.5),e(h8+30+h8%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local bV=centerY+-i*5+h5*5;if len==30 then h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bV,len)if aq then gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX-h7+10,bV+4,i)gJ[#gJ+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gR,centerX,centerY,centerX+h7-10,bV+4,i)if i==0 or i==180 or i==-180 then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+20,bV,h7*2-40)end else gJ[#gJ+1]=bT(centerX-h7+10,bV,i,"pdim txt txtmid")gJ[#gJ+1]=bT(centerX+h7-10,bV,i,"pdim txt txtmid")end;h2=f([[%s M %d %f h %d]],h2,centerX+h7,bV,len)else h2=f([[%s M %d %f h %d]],h2,centerX-h7-len,bV,len)h2=f([[%s M %d %f h %d]],h2,centerX+h7,bV,len)end end;gJ[#gJ+1]=h2 ..[["/>]]local h9="PITCH"if not br then h9="REL PITCH"end;if h5>90 and not aq then h5=90-(h5-90)elseif h5<-90 and not aq then h5=-90-(h5+90)end;if gT>200 then if aq then if e5>Q then gJ[#gJ+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY+20,h6,"pdim txt txtmid")end;gJ[#gJ+1]=f([[<g transform="rotate(%f,%d,%d)">]],-gR,centerX,centerY)else gJ[#gJ+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-h7+25,centerY-5,centerX-h7+20,centerY,centerX-h7+25,centerY+5,centerX-h7+50,centerY+4,h8)gJ[#gJ+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+h7-25,centerY-5,centerX+h7-20,centerY,centerX+h7-25,centerY+5,centerX+h7-30,centerY+4,h8)gJ[#gJ+1]="</g>"end;local ha=e(gT/3)gJ[#gJ+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ha,centerY,gT-ha)if not aq and br then gJ[#gJ+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gR,centerX,centerY,centerX-h7+10,centerY,h7*2-20)end;gJ[#gJ+1]="</g>"if gT<200 then if aq and e5>Q then gJ[#gJ+1]=bT(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY-gT+10,h8,"pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY-15,"Yaw","pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY+20,h6,"pdim txt txtmid")else gJ[#gJ+1]=bT(centerX,centerY-gT,h9,"pdim txt txtmid")gJ[#gJ+1]=bT(centerX,centerY-gT+15,h8,"pdim txt txtmid")end end end end;local function hb(gJ,cP,br)local hc=altMeterX;local hd=altMeterY;local he=78;local hf=19;local hg=ao;if ao~=-1 then gJ[#gJ+1]=bT(hc+he,hd+hf+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if br and(cP<200000 and not aq or cP and aq)then table.insert(gJ,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hc-1,hd-4,he+2,hf+6,hc+1,hd-1,he-4,hf))local fi=0;local hh=1;local hi=0;local hj=cP<0;local hk=cP<planet.surfaceMaxAltitude;local hl=9;if hj then hl=0 end;local cP=d(cP)while fi<6 do local hm=11;local hn=16;local ho=9;local hp=14;local bX="altsm"if fi>2 then hn=hn+3;hm=hm+2;hp=hp+2;ho=ho-6;bX="altbig"end;if hj then bX=bX.." red"elseif hk then bX=bX.." orange"end;local hq=cP/hh%10;local hr=e(hq)local hs=e((hr+1)%10)local ht=hi;if fi==0 then ht=hq-hr;if hj then ht=1-ht end end;if hj and(fi==0 or hi~=0)then local hu=hs;hs=hr;hr=hu end;local hv=hn*(ht-1)local hw=hv+hn;local bU=hc+ho+(6-fi)*hm;local bV=hd+hp;gJ[#gJ+1]=bT(bU,bV+hv,hs,bX)gJ[#gJ+1]=bT(bU,bV+hw,hr,bX)fi=fi+1;hh=hh*10;if hr==hl then hi=ht else hi=0 end end;table.insert(gJ,[[</g></g>]])end end;local function hx(e8)local hy=-math.deg(n(e8.y,e8.z))+180;hy=hy-90;if hy<0 then hy=360+hy end;if hy>180 then hy=-180+hy-180 end;return-hy end;local function hz(e8)local gX=math.deg(n(e8.y,e8.x))-90;if gX<-180 then gX=360+gX end;return gX end;local function hA(gJ,e8,e5,centerX,centerY)if e5>5 and not aq or e5>Q then local gT=circleRad;local hB=20;local hC=20;local hD=hx(e8)local hE=hz(e8)local hF=14;local hG=hF/2;local hH=-hE/hC*gT;local hI=hD/hB*gT;local bU=centerX+hH;local bV=centerY+hI;local aj=y(hH^2+hI^2)local hJ=[[<circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hG/hF..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..bU..[["
                            cy="]]..bV..[["
                            r="]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..bU-hF..[[,]]..bV..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU+hG..[[,]]..bV..[[ h ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..bU..[[,]]..bV-hF..[[ v ]]..hG..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<gT then gJ[#gJ+1]=hJ else local gK=n(hI,hH)local hK=4;local hL=centerX+gT*math.cos(gK)local hM=centerY+gT*math.sin(gK)gJ[#gJ+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gK*180/math.pi,hL,hM,hL-hK,hM-hK/2,hK*2,hK,hL+hK,hM-hK,hK,hK,-hK,hK)end;if not aq then local hN=vec3(e8)hD=hx(-hN)hE=hz(-hN)hH=-hE/hC*gT;hI=hD/hB*gT;bU=centerX+hH;bV=centerY+hI;aj=y(hH^2+hI^2)if aj<gT then local hO=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..bU..[[,]]..bV..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..bU..[[,]]..bV..[[)" />
                                <path
                                    d="M ]]..bU-hG..[[,]]..bV..[[ h ]]..hF..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..bU..[[,]]..bV..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..bU..[[,]]..bV..[[)"/>]]gJ[#gJ+1]=hO end end end end;local function hP(gJ,g5,hQ,hR)hQ=e(hQ+0.5)local gv=throtPosY+10;local gw=throtPosY+20;if m()==1 and not RemoteHud then gv=55;gw=65 end;local hS="CRUISE"local unit="km/h"local cz=hR;if g5=="TRAVEL"or g5=="AUTOPILOT"then hS="THROT"unit="%"cz=hQ;local hT="dim"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hT,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gJ[#gJ+1]=bT(throtPosX+10,gv,hS,"pbright txtstart")gJ[#gJ+1]=bT(throtPosX+10,gw,f("%.0f %s",cz,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bj and M then hQ=e(N*100+0.5)local hT="red"if hQ<0 then hT="red"end;gJ[#gJ+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hT,1-d(hQ),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gJ[#gJ+1]=bT(throtPosX+10,gv+40,"LIMIT","pbright txtstart")gJ[#gJ+1]=bT(throtPosX+10,gw+40,hQ.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gJ[#gJ+1]=bT(throtPosX+10,gv-40,"LIMIT: "..aZ.." km/h","dim txtstart")elseif not aq and Autopilot then gJ[#gJ+1]=bT(throtPosX+10,gv-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hU(gJ,hV)local hW=throtPosY-10;local hX=throtPosX+10;gJ[#gJ+1]=bT(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then hW=75 end;gJ[#gJ+1]=bT(hX,hW,e(hV).." km/h","pbright txtbig txtstart")end;local function hY(gJ)gJ[#gJ+1]=bT(g1(1900),g2(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gJ[#gJ+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gJ[#gJ+1]=bT(g1(960),g2(550),"Warning: Invalid Control Scheme Detected","warnings")gJ[#gJ+1]=bT(g1(960),g2(600),"Keyboard Scheme must be selected","warnings")gJ[#gJ+1]=bT(g1(960),g2(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hZ=g1(960)local h_=g2(860)local i0=g2(880)local i1=g2(900)local i2=g2(960)local i3=g2(200)local i4=g2(250)local i5=g2(960)if m()==1 and not RemoteHud then h_=g2(135)i0=g2(155)i1=g2(175)i3=g2(115)i4=g2(95)end;local i6="#222222"local i7="white"local i8="dimmer"local i9="pbright"local ia="#110000"local ib=i6;local ic=i8;if BrakeIsOn then gJ[#gJ+1]=bT(hZ,h_,"Brake Engaged","warnings")ia="#440000"ib=i7;ic=i9 elseif L>0 then gJ[#gJ+1]=bT(hZ,h_,"Auto-Brake Engaged","warnings","opacity:"..L)end;local id="#110000"local ie=i6;local ig=i8;if aq and aX and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bh and not VertTakeOff and not AutoTakeoff then gJ[#gJ+1]=bT(hZ,i3+50,"** STALL WARNING **","warnings")id="#ff0000"ie=i7;ig=i9;bG("stall","SW",2)end end;if bp then gJ[#gJ+1]=bT(hZ,i3+90,"Flight Assist in Progress","warnings")end;if ax then gJ[#gJ+1]=bT(hZ,i5,"Gyro Enabled","warnings")end;local ih="#111100"local ii=i6;local ij=i8;if GearExtended then ih="#775500"ii=i7;ij=i9;if S then gJ[#gJ+1]=bT(hZ,i0,"Gear Extended","warn")else gJ[#gJ+1]=bT(hZ,i0,"Landed (G: Takeoff)","warnings")end;local ik=c1(a:getTargetGroundAltitude())gJ[#gJ+1]=bT(hZ,i1,"Hover Height: "..ik,"warn")end;local il="#000011"local im=i6;local io=i8;if a7 then il="#0000DD"im=i7;io=i9;gJ[#gJ+1]=bT(hZ,i2+20,"ROCKET BOOST ENABLED","warn")end;local ip="#001100"local iq=i6;local ir=i8;if antigrav and not ExternalAGG and bh and AntigravTargetAltitude~=nil then ip="#00DD00"iq=i7;ir=i9;if d(as-antigrav.getBaseAltitude())<501 then gJ[#gJ+1]=bT(hZ,i3+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gJ[#gJ+1]=bT(hZ,i3+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gJ[#gJ+1]=bT(hZ,i3+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gJ[#gJ+1]=bT(hZ,i3+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gJ[#gJ+1]=bT(hZ,i3+20,"Follow Mode Engaged","warn")elseif Reentry or an then gJ[#gJ+1]=bT(hZ,i3+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=c1(HoldAltitude,2)if VertTakeOff then if bh then ik=c1(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gJ[#gJ+1]=bT(hZ,i3,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gJ[#gJ+1]=bT(hZ,i3,"Takeoff to "..AutopilotTargetName,"warn")else gJ[#gJ+1]=bT(hZ,i3,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gJ[#gJ+1]=bT(hZ,i3+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gJ[#gJ+1]=bT(hZ,i3,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gJ[#gJ+1]=bT(hZ,i3+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gJ[#gJ+1]=bT(hZ,i3+20,"Aligning trajectory","warn")elseif ar<0.05 then gJ[#gJ+1]=bT(hZ,i3+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b0~=nil then gJ[#gJ+1]=bT(hZ,i3,b0,"warn")end end;if BrakeLanding then if StrongBrakes then gJ[#gJ+1]=bT(hZ,i3,"Brake-Landing","warnings")else gJ[#gJ+1]=bT(hZ,i3,"Coast-Landing","warnings")end end;if ProgradeIsOn then gJ[#gJ+1]=bT(hZ,i3,"Prograde Alignment","crit")end;if RetrogradeIsOn then gJ[#gJ+1]=bT(hZ,i3,"Retrograde Alignment","crit")end;local is="#110000"local it=i6;local iu=i8;if bs then is="#FF0000"it=i7;iu=i9;local type;if string.find(bs,"COLLISION")then type="warnings"else type="crit"end;gJ[#gJ+1]=bT(hZ,i4+20,bs,type)elseif ar==0 then local iv,iw=aR.checkLOS(bb:normalize())if iw~=nil then iu=i9;is="#FF0000"it=i7;local ik=c1(iw)local travelTime=aM.computeTravelTime(bc,0,iw)local ix="Collision"if iv.noAtmosphericDensityAltitude>0 then ix="Atmosphere"end;gJ[#gJ+1]=bT(hZ,i4+20,iv.name.." "..ix.." "..c4(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gJ[#gJ+1]=bT(hZ,i3+35,VectorStatus,"warn")end;local iy="#111100"local iz=i6;local iA=i8;if bz and#bz>1 then iy="#DDDD00"iz=i7;iA=i9 end;local iB=g1;local iC=g2;local i8="topButton"local iD="topButtonActive"local iE=i8;if Autopilot or VectorToTarget or am or IntoOrbit then iE=iD end;local iF=i8;if ProgradeIsOn then iF=iD end;local iG=i8;if BrakeLanding or GearExtended then iG=iD end;local iH=i8;if AltitudeHold or VectorToTarget then iH=iD end;local iI=i8;if RetrogradeIsOn then iI=iD end;local iJ=i8;if IntoOrbit or b3 and Autopilot then iJ=iD end;local iK=iC(30)gJ[#gJ+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iE,iB(960),iC(54),iC(-53),iB(-120),iB(25),iC(50))gJ[#gJ+1]=bT(iB(910),iK,"AUTOPILOT")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iF,iB(865),iC(51),iB(-25),iC(-50),iB(-110),iB(25),iC(46))gJ[#gJ+1]=bT(iB(800),iK,"PROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iG,iB(755),iC(47),iB(-25),iC(-46),iB(-98),iB(44),iC(44))gJ[#gJ+1]=bT(iB(700),iK,"LAND")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iH,iB(960),iC(54),iC(-53),iB(120),iB(-25),iC(50))gJ[#gJ+1]=bT(iB(1010),iK,"ALT HOLD")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iI,iB(1055),iC(51),iB(25),iC(-50),iB(110),iB(-25),iC(46))gJ[#gJ+1]=bT(iB(1122),iK,"RETROGRADE")gJ[#gJ+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iJ,iB(1165),iC(47),iB(25),iC(-46),iB(98),iB(-44),iC(44))gJ[#gJ+1]=bT(iB(1220),iK,"ORBIT")gJ[#gJ+1]=[[
                                </g>
                            </g>]]gJ[#gJ+1]="</g>"return gJ end;local function iL(e5)return e(A(e5*3.6,0)+0.5).." km/h"end;local function iM(gJ)local bU=OrbitMapX+10;local bV=OrbitMapY+20;local iN={}local iO={"Alt-4: AutoTakeoff to Target"}local iP={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iQ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iR={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iN,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then bJ(iN,iO)if ac and planet and ac.name==planet.name then table.insert(iN,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if bh then table.insert(iN,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iN,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iN,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iN,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iN,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iN,"G: Takeoff to hover height, raise gear")else table.insert(iN,"G: Lowergear and Land")end else bJ(iN,iP)table.insert(iN,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iN,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else bJ(iN,iQ)if shield_1 then table.insert(iN,"Alt-Shift-5: Toggle shield off and on")table.insert(iN,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iN,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iN,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iN,"Alt-Spacebar/C will raise/lower target height")table.insert(iN,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iN,"LALT+Mousewheel will lower/raise speed limit")end;bJ(iN,iR)for i=1,#iN do bV=bV+12;gJ[#gJ+1]=bT(bU,bV,iN[i],"pdim txtbig txtstart")end end;local function iS(gJ)local iT=OrbitMapX;local iU=OrbitMapY;local iV=OrbitMapSize;local iW=4;local iX=15;local bU=0;local bV=0;local iY,iZ,i_,j0;local j1;local function j2(type)local j3,E,e5,j4,bX,j5;if type=="Periapsis"then j3=j1.periapsis.altitude;E=j1.timeToPeriapsis;e5=j1.periapsis.speed;bX="txtend"j4=12;j5=math.min(bU,iT+iV-planet.radius/i_-iW*2)else j3=j1.apoapsis.altitude;E=j1.timeToApoapsis;e5=j1.apoapsis.speed;j4=-12;bX="txtstart"j5=bU end;if bc<1 then E=0 end;gJ[#gJ+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5+j4,bV-5,bU,bV-5)gJ[#gJ+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],j5-j4*4,bV+2,bU,bV+2)gJ[#gJ+1]=bT(j5,bV,type,bX)bU=j5-j4*2;bV=bV+iX;local ik=c1(j3)gJ[#gJ+1]=bT(bU,bV,ik,bX)bV=bV+iX;gJ[#gJ+1]=bT(bU,bV,c4(E),bX)bV=bV+iX;gJ[#gJ+1]=bT(bU,bV,iL(e5),bX)end;local j6=iV*1.5;if SelectedTab=="INFO"then j6=25*7 end;if SelectedTab~="HIDE"then gJ[#gJ+1]=[[<g class="pbright txtorb txtmid">]]gJ[#gJ+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',iV*2,j6,iT,iU)gJ[#gJ+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],iV*2,j6,iT,iU)end;local j7=iV*1.5;local j8=iV*2;local j9=j7/2;local ja=iV;local jb=iT+ja;local jc=iU+j9;local jd=iT+j8;local je=iU+j7;if SelectedTab=="ORBIT"then iU=iU+iW;iY=iV/2;j0=0;j1={}j1.periapsis={}j1.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then j1.periapsis.altitude=orbit.periapsis.altitude;j1.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then j1.apoapsis.altitude=orbit.apoapsis.altitude;j1.apoapsis.speed=orbit.apoapsis.speed end;j1.period=orbit.period;j1.eccentricity=orbit.eccentricity;j1.timeToApoapsis=orbit.timeToApoapsis;j1.timeToPeriapsis=orbit.timeToPeriapsis;j1.eccentricAnomaly=orbit.eccentricAnomaly;j1.trueAnomaly=orbit.trueAnomaly end;if j1.periapsis==nil then j1.periapsis={}j1.periapsis.altitude=-planet.radius;j1.periapsis.speed=MaxGameVelocity end;if j1.eccentricity==nil then j1.eccentricity=1 end;if j1.apoapsis==nil then j1.apoapsis={}j1.apoapsis.altitude=as;j1.apoapsis.speed=0 end;if bc<1 then j1.apoapsis.altitude=as;j1.apoapsis.speed=0 end;if j1.apoapsis.altitude then i_=(j1.apoapsis.altitude+j1.periapsis.altitude+planet.radius*2)/(iY*2)iZ=(planet.radius+j1.apoapsis.altitude)/i_*(1-j1.eccentricity)j0=iY-j1.periapsis.altitude/i_-planet.radius/i_;local jf=math.pi;if j1.period~=nil and j1.period>0 and j1.timeToApoapsis~=nil then jf=j1.eccentricAnomaly;if j1.timeToPeriapsis<j1.timeToApoapsis then jf=2*math.pi-jf end end;if bc<1 or jf~=jf then jf=math.pi end;local jg=-iY*math.cos(jf)+iT+ja+iW;local jh=iZ*math.sin(jf)+iU+j9+iW;local ji=""gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'gJ[#gJ+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ji,iT+iV+iW,iU+iV*1.5/2+iW,iY,iZ)if iZ<1 then gJ[#gJ+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],iT+iV+iW-j0,iU+iV*1.5/2+iW,jg,jh)end;gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',iT+iV+iW-j0,iU+iV*1.5/2+iW,(planet.radius+planet.noAtmosphericDensityAltitude)/i_)gJ[#gJ+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',iT+iV+iW-j0,iU+iV*1.5/2+iW,(planet.radius+planet.noAtmosphericDensityAltitude)/i_)gJ[#gJ+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",iT+iV+iW,iU+iV*1.5/2+iW,iY,iZ)gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',iT+iV+iW-j0,iU+iV*1.5/2+iW,planet.radius/i_)gJ[#gJ+1]='</g>'local jj=math.floor(planet.radius/i_+0.5)local jk=g6.Generic_Moon;if g6[planet.name]then jk=g6[planet.name]end;bU=iT+iV+iW*4+iY;bV=iU+iV*1.5/2+5+iW;if j1.apoapsis~=nil and j1.apoapsis.speed<MaxGameVelocity then j2("Apoapsis")end;bV=iU+iV*1.5/2+5+iW;bU=iT+iV-iW*2-iY;if j1.periapsis~=nil and j1.periapsis.speed<MaxGameVelocity and j1.periapsis.altitude>0 then j2("Periapsis")end;gJ[#gJ+1]=bT(iT+iV+iW,iU+20+iW,planet.name,"txtorbbig")gJ[#gJ+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jg,jh)gJ[#gJ+1]=[[</g>]]return gJ else gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jl=""local jm=1.2*(maxAtlasX-minAtlasX)/(iV*2)local jn=1.4*(maxAtlasY-minAtlasY)/(iV*1.5)for cd,ce in pairs(b[0])do if ce.center then local bU=iT+iV+ce.center.x/jm;local bV=iU+iV*1.5/2+ce.center.y/jn;jl=jl..'<circle cx="'..bU..'" cy="'..bV..'" r="'..ce.radius/jm*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ce.name,"Moon")and not string.match(ce.name,"Sanctuary")and not string.match(ce.name,"Space")then jl=jl.."<text x='"..bU.."' y='"..bV+ce.radius/jm*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..ce.name.."</text>"end end end;local e9=vec3(core.getConstructWorldPos())local bU=iT+iV+e9.x/jm;local bV=iU+iV*1.5/2+e9.y/jn;jl=jl..'<circle cx="'..bU..'" cy="'..bV..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jl=jl.."<text x='"..bU.."' y='"..bV-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"fN=jm;fO=jn;local jo=e9+bb*1000000;local jp=iT+iV+jo.x/jm;local gw=iU+iV*1.5/2+jo.y/jn;jl=jl..'<line x1="'..bU..'" y1="'..bV..'" x2="'..jp..'" y2="'..gw..'" stroke="purple" stroke-width="1"/>'gJ[#gJ+1]=jl;gJ[#gJ+1]='</g>'end elseif SelectedTab=="INFO"then gJ=aP.DrawOdometer(gJ,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gJ=iM(gJ)elseif SelectedTab=="SCOPE"then gJ[#gJ+1]='<g clip-path="url(#orbitRect)">'local jm=(maxAtlasX-minAtlasX)/j8;local jn=(maxAtlasY-minAtlasY)/j7;local jq=scopeFOV;table.sort(bB,function(b_,c0)return(b_.center-bf):len2()>(c0.center-bf):len2()end)local eC={}local jr={}local js=120;local jt=100;local ju=nil;local jv=nil;for i=#bB,1,-1 do local ce=bB[i]local eB=ce.center-bf;local jw=eB:len()local jx=eB:normalize()local jy=eB:cross(b8):normalize()local jz=math.acos(jy:dot(b9))if jy:cross(b9):dot(b8)<0 then jz=-jz end;local jA=eB:project_on_plane(b8):len()local jB=eB:project_on_plane(b9)local jC=eB:project_on_plane(b7)local jD=math.sin(jz)*math.asin(jA/jw)*constants.rad2deg;local jE=math.cos(jz)*math.asin(jA/jw)*constants.rad2deg;if jx:dot(b8)<0 then jE=90*math.cos(jz)+90*math.cos(jz)-jE;jD=90*math.sin(jz)+90*math.sin(jz)-jD end;local bU=jb+jD/jq*j7;local bV=jc+jE/jq*j7;local jF=(bU-jb)*(bU-jb)+(bV-jc)*(bV-jc)local jG=math.asin((ce.radius+ce.surfaceMaxAltitude)/jw)*constants.rad2deg;local fu=jG/jq*j7;local jH=math.asin(ce.atmosphereRadius/jw)*constants.rad2deg;local jI=jH/jq*j7;local aj=c1(jw,1)local jJ=ce.name;local jK=false;if bV>iU then if bV>je then if bV-jI<=je then jK=true end else jK=true end else if bV+jI>=iU then jK=true end end;local jL=false;local jM=bU;if ce.systemId==0 then jM=bU+js else jM=bU-js end;if jM+js>iT then if jM+js>jd then if jM-jI-js<=jd then jL=true end else jL=true end else if jM+jI+js>=iT then jL=true end end;local jN={}jN.x=bU;jN.y=bV;jN.planet=ce;jN.atmoSize=jI;if not ju or jF<ju then ju=jF;jv=jN end;if jL and jK then local jO=math.max(jI,5)if jF<jO*jO then jJ=jJ.." - "..aj end;jN.size=fu;jN.i=i;jN.displayString=jJ;jN.distance=aj;jN.visible=true;jr[#jr+1]=jN else jN.visible=false end end;local jP=false;table.sort(jr,function(b_,c0)return b_.y<c0.y end)for cd,ec in ipairs(jr)do local ce,fu,i,jI,bU,bV,jJ,aj=ec.planet,ec.size,ec.i,ec.atmoSize,ec.x,ec.y,ec.displayString,ec.distance;local j5,jQ,jR,jS;local jT=15;local bX="pdim"if ce.systemId~=0 then jR=g1(string.len(jJ)*5)jT=-(15+jR)jS=g2(10)bX="pdimfill"else jR=g1(string.len(jJ)*9)jS=g2(15)end;if fu*2>jR then j5=r(bU,iT+jR/2,jd-jR/2)jQ=r(bV,iU+jS,je-5)j5=r(j5,bU-fu+jR/2,bU+fu-jR/2)jQ=r(jQ,bV-fu+jS,bV+fu)else j5=bU+jT;jQ=bV end;local jU;repeat jU=false;for jV,ec in pairs(eC)do local jW=ec.textPositions;local jX=jW.y-jQ;if jV~=i and d(jX)<jW.height and jW.x+jW.width>j5 and jW.x<j5+jR then if fu>jR then jQ=r(jQ+jS,iU+15,je-5)else jQ=jW.y+jW.height+1;jU=true end;break end end until not jU;local jY=jJ~=ce.name or j5<=jb and j5+jR>=jb and jQ-jS<=jc and jQ>=jc;ec.hovered=jY;local jZ=1;if jY then jZ=2;if fu*2<jR then jZ=10 end;if jJ==ce.name then jJ=jJ.." - "..aj end;bX="pbright"if ce.systemId~=0 then jR=g1(string.len(jJ)*5)jT=-(15+jR)else jR=g1(string.len(jJ)*7)end;if fu*2>jR then j5=r(bU,iT+jR/2,jd-jR/2)j5=r(j5,bU-fu+jR/2,bU+fu-jR/2)else j5=bU+jT end;if not Autopilot and not VectorToTarget and not am and not IntoOrbit and not jP then jP=true;if AutopilotTargetName~=ce.name then for j_,cH in ipairs(bm)do if cH.index==ce.id then AutopilotTargetIndex=j_;aQ.UpdateAutopilotTarget()break end end end end end;eC[i]={}eC[i].textPositions={}eC[i].textPositions.y=jQ;eC[i].textPositions.x=j5;eC[i].textPositions.width=jR;eC[i].textPositions.height=jS;eC[i].output=""if fu*2>jR then bX=bX.." txtmid"else bX=bX.." txtstart"end;if jI-fu>2 then eC[i].output=f('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',bU,bV,jI,az,0.1*jZ)end;eC[i].output=eC[i].output..f('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',bU,bV,fu,az,0.2*jZ)if ce.systemId==0 then eC[i].output=eC[i].output..f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j5,jQ,ay,bX,jJ)if fu*2<=jR then eC[i].output=eC[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j5+jR,jQ+2,j5,jQ+2,bU,bV)end else eC[i].output=eC[i].output..f([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],j5,jQ,az,bX,jJ)if fu*2<=jR then eC[i].output=eC[i].output..f("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",j5,jQ+2,j5+jR,jQ+2,bU,bV)end end end;for cd,ce in ipairs(bB)do if eC[cd]then gJ[#gJ+1]=eC[cd].output end end;if jv~=nil and scopeFOV<90 and not jv.hovered then local k0=jv.planet.atmosphereRadius/jv.atmoSize;local k1=y(ju)*k0;local k2=c1(k1,1)local jR=g1(math.max(string.len(k2)*7,string.len(jv.planet.name)*7))local jS=g2(12)local j5=r(jv.x+(jb-jv.x)/2,iT+jR/2,jd-jR/2)local jQ=r(jv.y+(jc-jv.y)/2,iU+jS*2,je-5)gJ[#gJ+1]=f("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",jv.x,jv.y,jb,jc)gJ[#gJ+1]=f([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j5,jQ,"white",k2)if not jv.visible then gJ[#gJ+1]=f([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],j5,jQ-jS,"white",jv.planet.name)end end;if bc>1 then local eB=bb;local jx=eB:normalize()local jA=eB:project_on_plane(b8):len()local jB=eB:project_on_plane(b9)local jC=eB:project_on_plane(b7)local jy=eB:cross(b8):normalize()local jz=math.acos(jy:dot(b9))if jy:cross(b9):dot(b8)<0 then jz=-jz end;local jD=math.sin(jz)*math.asin(jA/eB:len())*constants.rad2deg;local jE=math.cos(jz)*math.asin(jA/eB:len())*constants.rad2deg;if jx:dot(b8)<0 then jE=90*math.cos(jz)+90*math.cos(jz)-jE;jD=90*math.sin(jz)+90*math.sin(jz)-jD end;local bU=jb+jD/jq*j7;local bV=jc+jE/jq*j7;local hF=14;local hG=hF/2;local hJ=[[<circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hG/hF..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..bU..[["
                                    cy="]]..bV..[["
                                    r="]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..bU-hF..[[,]]..bV..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU+hG..[[,]]..bV..[[ h ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..bU..[[,]]..bV-hF..[[ v ]]..hG..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]gJ[#gJ+1]=hJ end;gJ[#gJ+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jb,jc-10,jb,jc+10)gJ[#gJ+1]=f("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",jb-10,jc,jb+10,jc)gJ[#gJ+1]='</g>'else return gJ end end;local function k3(k4,k5)local k6;local k7=(k5-k4):normalize()local ea=(bf-k4):dot(k7)/k7:dot(k7)if ea<=0.then return(bf-k4):len()elseif ea>=(k5-k4):len()then return(bf-k5):len()end;local k8=k4+ea*k7;k6=(k8-bf):len()return k6 end;local function k9()local k6;local ka=nil;local kb=nil;local kc=nil;for cd,kd in pairs(b[0])do if kd.hasAtmosphere then local aj=k3(planet.center,kd.center)if ka==nil or aj<ka then kb=kd;ka=aj;kc=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dw=k3(ac.center,kd.center)if dw<ka then kb=kd;ka=dw;kc=ac end end end end;local ke=g1(1770)local kf=g2(330)if ka then local kg="txttick "local kh=500000;if ka<kb.radius+kh or ka<kc.radius+kh then if bn then kg="txttick red "else kg="txttick orange "end end;k6=c1(ka,2)fT=bT(ke,kf,"Pipe ("..kc.name.."--"..kb.name.."): "..k6,kg.."pbright txtmid")end end;local function ki(bU,bV,kj,kk,hS)local kl={x=bU,y=bV,width=kj,height=kk,label=hS}by[hS]=kl;return kl end;local function km(kn,ko,kj,kk,bU,bV,kp,kq,kr,ks,bX)local kl={enableName=kn,disableName=ko,width=kj,height=kk,x=bU,y=bV,toggleVar=kp,toggleFunction=kq,drawCondition=kr,hovered=false,class=bX}if ks then table.insert(fM,kl)else table.insert(fL,kl)end;return kl end;local function kt(ku)if not fQ then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ku=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ku=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ku=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then fR=bM(ku)showHud=false else fR={}showHud=true end end;local function kv()fQ=not fQ;if fQ then fK=fM;a2="Hold SHIFT to see Settings"fS=showHud else fK=fL;a2="Hold SHIFT to see Control Buttons"kt()showHud=fS end end;local function kw()local function kx(ce)_G[ce]=not _G[ce]if _G[ce]then a2=ce.." set to true"else a2=ce.." set to false"end;if ce=="showHud"then fS=_G[ce]elseif ce=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local ky=50;local kz=340;local bU=500;local bV=aE/2-400;local kA=0;for cd,ce in pairs(bM("boolean"))do if type(_G[ce])=="boolean"then km(ce,ce,kz,ky,bU,bV,function()return _G[ce]end,function()kx(ce)end,function()return true end,true)bV=bV+ky+20;if kA==9 then bU=bU+kz+20;bV=aE/2-400;kA=0 else kA=kA+1 end end end;km("Control View","Control View",kz,ky,10,aE/2-500,function()return true end,kv,function()return true end,true)km("View Handling Settings",'Hide Handling Settings',kz,ky,10,aE/2-(500-ky),function()return showHandlingVariables end,function()kt("handling")end,function()return true end,true)km("View Hud Settings",'Hide Hud Settings',kz,ky,10,aE/2-(500-ky*2),function()return showHudVariables end,function()kt("hud")end,function()return true end,true)km("View Physics Settings",'Hide Physics Settings',kz,ky,10,aE/2-(500-ky*3),function()return showPhysicsVariables end,function()kt("physics")end,function()return true end,true)end;local function kB()local function kC()local position=bf;local fx=planet.name..". "..#SavedLocations;if bu[1]then local cH,_=bu[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if cH~=nil and cH~=""then fx=fx.." "..bu[1].getConstructName(cH)end end;return aQ.AddNewLocation(fx,position,false,true)end;local function kD()TurnBurn=not TurnBurn end;local function kE(kF)if kF==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kG()aQ.UpdatePosition()end;local function kH()aQ.ClearCurrentPosition()end;local function kI(fi)local fx=AutopilotTargetName;if fi~=nil and type(fi)=="number"then if fi==0 then return"None"end;fx=bm[fi].name end;if fx==nil then fx=CustomTarget.name end;if fx==nil then fx="None"end;return fx end;local function kJ(fi)return"Engage Autopilot: "..kI(fi)end;local function kK(fi)return"Disable Autopilot: "..kI(fi)end;local function kL()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bG("folOn","F")else bG("folOff","F")BrakeIsOn=true;aV=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local ky=50;local kz=260;local kM=g1(30)local kN=OrbitMapX+OrbitMapSize*2+2;local kO=OrbitMapY+1;km("+","+",kM,kM,kN,kO+kM+1,function()return false end,function()scopeFOV=scopeFOV/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")km("-","-",kM,kM,kN,kO,function()return false end,function()scopeFOV=math.min(scopeFOV*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")km("0","0",kM,kM,kN,kO+kM*2+2,function()return false end,function()scopeFOV=90 end,function()return SelectedTab=="SCOPE"and scopeFOV~=90 end,nil,"ZoomButton")local kP=km("Enable Brake Toggle","Disable Brake Toggle",kz,ky,aD/2-kz/2,aE/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)km("Align Prograde","Disable Prograde",kz,ky,aD/2-kz/2-50-kP.width,aE/2-ky+380,function()return ProgradeIsOn end,function()kE(1)end)km("Align Retrograde","Disable Retrograde",kz,ky,aD/2-kz/2+kP.width+50,aE/2-ky+380,function()return RetrogradeIsOn end,kE,function()return ar==0 end)apbutton=km(kJ,kK,600,60,aD/2-600/2,aE/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kQ(kR)local fi=bx+kR;if fi>#bm then fi=fi-#bm-1 end;if fi<0 then fi=#bm+fi end;return fi end;apExtraButtons={}for i=0,10 do local button=km(function(c0)local fi=kQ(c0.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..kI(fi)end;return kJ(fi)end,function(c0)local fi=kQ(c0.apExtraIndex)return kK(fi)end,600,60,aD/2-600/2,aE/2-60/2-330+60*i,function(c0)local fi=kQ(c0.apExtraIndex)return fi==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(c0)local fi=kQ(c0.apExtraIndex)local kS=AutopilotTargetIndex==fi;AutopilotTargetIndex=fi;aQ.UpdateAutopilotTarget()aR.ToggleAutopilot()if not kS and not(Autopilot or VectorToTarget or am or IntoOrbit)then aR.ToggleAutopilot()end end,function()return bw end)button.apExtraIndex=i;apExtraButtons[i]=button end;km("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kC,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)km("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kG,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)km("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ky=60;kz=300;local bU=0;local bV=aE/2-150;km("View Settings","View Settings",kz,ky,bU,bV,function()return true end,kv)bV=bV+ky+20;km("Enable Turn and Burn","Disable Turn and Burn",kz,ky,bU,bV,function()return TurnBurn end,kD)bU=10;bV=aE/2-300;km("Horizontal Takeoff Mode","Vertical Takeoff Mode",kz,ky,bU+kz+20,bV,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bg end)bV=bV+ky+20;km("Engage Orbiting","Cancel Orbiting",kz,ky,bU+kz+20,bV,function()return IntoOrbit end,aR.ToggleIntoOrbit,function()return ar==0 and br end)bV=aE/2-150;km("Glide Re-Entry","Cancel Glide Re-Entry",kz,ky,bU+kz+20,bV,function()return Reentry end,function()al=1;kE(1)end,function()return planet.hasAtmosphere and not aq end)bV=bV+ky+20;km("Parachute Re-Entry","Cancel Parachute Re-Entry",kz,ky,bU+kz+20,bV,function()return Reentry end,aR.BeginReentry,function()return planet.hasAtmosphere and not aq end)bV=bV+ky+20;km("Engage Follow Mode","Disable Follow Mode",kz,ky,bU,bV,function()return a0 end,kL,function()return m()==1 end)km("Enable Repair Arrows","Disable Repair Arrows",kz,ky,bU+kz+20,bV,function()return aJ end,function()aJ=not aJ;if aJ then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)bV=bV+ky+20;if not ExternalAGG then km("Enable AGG","Disable AGG",kz,ky,bU,bV,function()return bh end,aR.ToggleAntigrav,function()return antigrav~=nil end)end;km(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,kz*2,ky,bU,bV,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)bV=bV+ky+20;km(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,kz*2,ky,bU,bV,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kT=g2(20)local button=ki(0,0,g1(70),kT,"HELP")button=ki(button.x+button.width,button.y,g1(80),kT,"INFO")button=ki(button.x+button.width,button.y,g1(70),kT,"ORBIT")button=ki(button.x+button.width,button.y,g1(70),kT,"SCOPE")ki(button.x+button.width,button.y,g1(70),kT,"HIDE")end;local kU={}local kV=nil;function kU.HUDPrologue(gJ)bn,bo=f_(bf)if not bn then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.6)..","..e(J+0.6)..","..e(I+0.6)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kW=ay;local kX=az;local kY=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.4+0.5)..[[)]]local kZ=ay;local k_=az;local l0=kY;if g3()and not brightHud then kW=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kX=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]kY=[[rgb(]]..e(H*0.2+0.5)..","..e(J*0.2+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iB=g1;local iC=g2;gJ[#gJ+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .pdimfill {fill: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                    <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="1"/>
                                    </radialGradient>
                                    <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="66%%" stop-color="%s" stop-opacity="1"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/>
                                    </radialGradient>                            
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kW,kW,kW,kZ,kZ,kX,kX,k_,k_,kX,kW,kY,k_,kW,kW,kY,kY,l0,kY,aD,aE,kX,kX,kX,kX,kX,kZ,kX,k_,l0,k_,k_,l0)if not kV then kV=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iB(630),iC(0),iB(675),iC(45),iB(960),iC(55),iB(1245),iC(45),iB(1290),iC(0),iB(1000),iC(105),iB(1040),iC(59),iB(1250),iC(51),iB(1300),iC(0),iB(1920),iC(0),iB(1920),iC(20),iB(1400),iC(20),iB(1300),iC(105),iB(920),iC(105),iB(880),iC(59),iB(670),iC(51),iB(620),iC(0),iB(0),iC(0),iB(0),iC(20),iB(520),iC(20),iB(620),iC(105),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112),iB(890),iC(59),iB(960),iC(62),iB(1030),iC(59),iB(985),iC(112),iB(1150),iC(112),iB(1100),iC(152),iB(820),iC(152),iB(780),iC(112),iB(935),iC(112))end;gJ[#gJ+1]=kV;return gJ end;function kU.DrawVerticalSpeed(gJ,cP)gI(gJ,cP)end;function kU.UpdateHud(gJ)local hy=bk;local l1=bl;local gR=l1;local h5=hy;local hQ=e(unit.getThrottle())local hV=bc*3.6;local hR=unit.getAxisCommandValue(0)local l2=g1(1770)local l3=g2(310)if AtmoSpeedAssist and bj then hR=K;hQ=K*100 end;local g5=g4()local gS="ROLL"if hQ==nil then hQ=0 end;if not br then if bc>5 then hy=hx(ba)l1=hz(ba)else hy=0;l1=0 end;gS="YAW"end;if bo>50000 and not aq then local l4;l4=c1(bo)gJ[#gJ+1]=bT(l2,l3,"PvP Boundary: "..l4,"pbright txtbig txtmid")end;gJ[#gJ+1]=ak;gJ[#gJ+1]=aB;gJ[#gJ+1]=g7;if fT~=""then gJ[#gJ+1]=fT end;if g8~=""then gJ[#gJ+1]=g8 end;if g9~=""then gJ[#gJ+1]=g9 end;gI(gJ,as)if m()==0 or RemoteHud then if br then gQ(gJ,centerX,centerY,gR,gS,br)else gQ(gJ,centerX,centerY,l1,gS,br)end;if not g3()or brightHud then if br then gQ(gJ,centerX,centerY,gR,gS,br)h4(gJ,h5,gR,centerX,centerY,br,e(hz(ba)),bc)else gQ(gJ,centerX,centerY,l1,gS,br)h4(gJ,hy,l1,centerX,centerY,br,e(l1),bc)end;hb(gJ,as,br)hA(gJ,ba,bc,centerX,centerY)end end;hP(gJ,g5,hQ,hR)hU(gJ,hV)hY(gJ)iS(gJ)return gJ end;function kU.HUDEpilogue(gJ)gJ[#gJ+1]="</svg>"return gJ end;function kU.ExtraData(gJ)local l5=g1(1240)local l6=g2(55)local l7=l6+10;local l8;local iB=g1;local iC=g2;local l9=0;local g5=g4()if VertTakeOffEngine then g5=g5 .."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bc>20 then g5=g5 .."-COLLISION ON"end;if UseExtra~="Off"then g5="("..UseExtra..")-"..g5 end;if TurnBurn then g5="TB-"..g5 end;if not stablized then g5=g5 .."-DeCoupled"end;local la=iC(99)local lb=iC(80)local lc=iC(85)local ld=iC(31)local le=0;local lf=0;local lg=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then l9=LastMaxBrakeInAtmo else l9=LastMaxBrake end;local lh,li=aM.computeDistanceAndTime(bc,0,av,0,0,l9)if lh<0 then lh=0 end;l9=A(l9/(av*fJ),2).."g"local lj=a:maxForceForward()l8=core.g()if l8>0.1 then lf=av*l8;lf=A(lf/(av*fJ),2).."g"le=0.5*lj/l8;le=le>1000000 and A(le/1000000,2).."kT"or A(le/1000,2).."T"end;lj=A(lj/(av*fJ),2).."g"local lk=vec3(core.getWorldAcceleration()):len()/9.80665;l8=core.g()gJ[#gJ+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then l5=g1(1120)l6=g2(55)l7=l6+10 elseif aq then local ll=g1(770)gJ[#gJ+1]=bT(iB(895),la,"ATMO","")gJ[#gJ+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iB(895),lc,iB(-80))gJ[#gJ+1]=bT(iB(815),lb,f("%.1f%%",ar*100),"txtstart size20")end;gJ[#gJ+1]=bT(iB(1025),la,"GRAVITY","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1025),lc,iB(80))gJ[#gJ+1]=bT(iB(1105),lb,f("%.2fg",l8/9.80665),"size20")gJ[#gJ+1]=bT(iB(1125),la,"ACCEL","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1125),lc,iB(80))gJ[#gJ+1]=bT(iB(1205),lb,f("%.2fg",lk),"size20")gJ[#gJ+1]=bT(iB(695),la,"BRK TIME","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(695),lc,iB(-80))gJ[#gJ+1]=bT(iB(615),lb,f("%s",c4(li)),"txtstart size20")gJ[#gJ+1]=bT(iB(635),iC(45),"TRIP","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(635),iC(31),iB(-90))if travelTime then gJ[#gJ+1]=bT(iB(532),iC(23),f("%s",c4(travelTime)),"txtstart size20")end;gJ[#gJ+1]=bT(iB(795),la,"BRK DIST","")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(795),lc,iB(-80))gJ[#gJ+1]=bT(iB(715),lb,f("%s",c1(lh)),"txtstart size20")gJ[#gJ+1]=bT(iB(1285),iC(45),"MASS","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1285),iC(31),iB(90))gJ[#gJ+1]=bT(iB(1388),iC(23),f("%s",lg),"size20")gJ[#gJ+1]=bT(iB(1220),la,"THRUST","txtstart")gJ[#gJ+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iB(1220),lc,iB(80))gJ[#gJ+1]=bT(iB(1300),lb,f("%s",lj),"size20")gJ[#gJ+1]=bT(g1(960),g2(175),g5,"pbright txtbig txtmid size20")gJ[#gJ+1]="</g>"end;function kU.DrawOdometer(gJ,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gJ end;local l8;local le=0;local lf=0;local l9=0;local lg=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then l9=LastMaxBrakeInAtmo else l9=LastMaxBrake end;local lh,li=aM.computeDistanceAndTime(bc,0,av,0,0,l9)l9=A(l9/(av*fJ),2).." g"local lj=a:maxForceForward()l8=core.g()if l8>0.1 then lf=av*l8;lf=A(lf/(av*fJ),2).." g"le=0.5*lj/l8;le=le>1000000 and A(le/1000000,2).." kTons"or A(le/1000,2).." Tons"end;lj=A(lj/(av*fJ),2).." g"if m()==0 or RemoteHud then local lm=g1(OrbitMapX+10)local ln=g2(OrbitMapY+20)local lo=g1(OrbitMapX+10+OrbitMapSize/1.25)local kk=25;gJ[#gJ+1]="<g class='txtstart size14 bright'>"gJ[#gJ+1]=bT(lm,ln,f("BrkTime: %s",c4(li)))gJ[#gJ+1]=bT(lo,ln,f("Trip: %.2f km",ad))gJ[#gJ+1]=bT(lm,ln+kk,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gJ[#gJ+1]=bT(lo,ln+kk,f("BrkDist: %s",c1(lh)))gJ[#gJ+1]=bT(lm,ln+kk*2,"Trip Time: "..c4(ae))gJ[#gJ+1]=bT(lo,ln+kk*2,"Total Time: "..c4(TotalFlightTime))gJ[#gJ+1]=bT(lm,ln+kk*3,f("Mass: %s",lg))gJ[#gJ+1]=bT(lo,ln+kk*3,f("Max Brake: %s",l9))gJ[#gJ+1]=bT(lm,ln+kk*4,f("Max Thrust: %s",lj))if l8>0.1 then gJ[#gJ+1]=bT(lo,ln+kk*4,f("Max Thrust Mass: %s",le))gJ[#gJ+1]=bT(lm,ln+kk*5,f("Req Thrust: %s",lf))else gJ[#gJ+1]=bT(lo,ln+kk*5,"Max Mass: n/a")gJ[#gJ+1]=bT(lm,ln+kk*6,"Req Thrust: n/a")end end;gJ[#gJ+1]="</g></g>"return gJ end;function kU.DrawWarnings(gJ)return hY(gJ)end;function kU.DisplayOrbitScreen(gJ)return iS(gJ)end;function kU.DisplayMessage(gJ,ik)if ik~="empty"then local bV=310;for lp in string.gmatch(ik,"([^\n]+)")do bV=bV+35;gJ[#gJ+1]=bT("50%",bV,lp,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kU.DrawDeadZone(gJ)gJ[#gJ+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kU.UpdatePipe()if aq then fT=""return end;k9()end;function kU.DrawSettings(gJ)if#fR>0 then local bU=g1(640)local bV=g2(200)gJ[#gJ+1]=[[<g class="pbright txtvspd txtstart">]]for cd,ce in pairs(fR)do gJ[#gJ+1]=bT(bU,bV,ce..": ".._G[ce])bV=bV+20;if cd%12==0 then bU=bU+g1(350)bV=g2(200)end end;gJ[#gJ+1]=bT(g1(640),g2(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gJ[#gJ+1]="</g>"end;return gJ end;local lq;local lr=g1(1770)local ls=g2(350)local lt=g2(15)local lu=g1(1370)local bC,lv;local lw=0;function kU.DrawRadarInfo()local function lx()if radarPanelID~=nil and lw==0 then t(radarPanelID)radarPanelID=nil;if lq~=nil then t(lq)lq=nil end else if lw==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bu,1,"Periscope","periscope")lq=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bu,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;lw=0 end end;local eB,eC,eA,eD,eE,ex=aS.GetRadarHud()local B=eD or 0;if eA>0 then if CollisionSystem then bC=B.."/"..eE.." Plotted : "..eA-eE.." Ignored"else bC="Radar Contacts: "..eA end;g7=bT(lr,ls,bC,"pbright txtbig txtmid")if#ex>0 then g7=g7 ..bT(lu,lt,"Friendlies In Range","pbright txtbig txtmid")for cd,ce in pairs(ex)do lt=lt+20;g7=g7 ..bT(lu,lt,bu[1].getConstructName(ce),"pdim txtmid")end end;if eB==nil and lq==nil then lw=1;lx()end;if eB~=nil and lq~=nil then lx()end;if radarPanelID==nil then lx()end else if eC then g7=bT(lr,ls,bv.." Radar: Jammed","pbright txtbig txtmid")else g7=bT(lr,ls,"Radar: No "..bv.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then lw=0;lx()end end end;function kU.DrawTanks()if fuelX~=0 and fuelY~=0 then g8=bT(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gp(fuelX,"Atmospheric ","ATMO",aF,gn,go)gp(fuelX,"Space Fuel T","SPACE",aG,gl,gm)gp(fuelX,"Rocket Fuel ","ROCKET",aH,gj,gk)end end;function kU.DrawShield()local ly=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local lz=core.getPvPTimer()local lA=shield_1.getResistances()local lB="A: "..10+lA[1]*100 .."% / E: "..10+lA[2]*100 .."% / K:"..10+lA[3]*100 .."% / T: "..10+lA[4]*100 .."%"local bU,bV=shieldX-60,shieldY+30;local lC=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gD=e(lC*2.55)local gE=f("rgb(%d,%d,%d)",255-gD,gD,0)local bX=""g9=bT(bU,bV,"","txtmid pdim txtfuel")if lC<10 and ly~="Shield Disabled"then bX="red "end;lz=lz>0 and"   PvPTime: "..c4(lz)or""g9=g9 ..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],bU,bV,gE,lC*2,bU,bV,bU+2,bV+10,lC,lz)g9=g9 ..bT(bU,bV-5,ly,bX.."txtstart pbright txtbig")g9=g9 ..bT(bU,bV+30,lB,bX.."txtstart pbright txtsmall")end;function kU.hudtick()if not planet then return end;local function lD(gJ)local gG=e(r(aj/(aD/4)*255,0,255))gJ[#gJ+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gG,e(J+0.5)-gG,e(I+0.5)-gG)end;local function lE()for _,ce in pairs(fK)do if ce.hovered then if not ce.drawCondition or ce.drawCondition(ce)then ce.toggleFunction(ce)end;ce.hovered=false end end;for _,ce in pairs(by)do if ce.hovered then SelectedTab=ce.label;ce.hovered=false end end end;local function lF()local function lG(lH,lI,bU,bV,kj,kk)if lH>=bU and lH<=bU+kj and lI>=bV and lI<=bV+kk then return true else return false end end;local bU=ag+aD/2;local bV=ah+aE/2;for _,ce in pairs(fK)do ce.hovered=lG(bU,bV,ce.x,ce.y,ce.width,ce.height)end;for _,ce in pairs(by)do ce.hovered=lG(bU,bV,ce.x,ce.y,ce.width,ce.height)end;if bw then local jY=false;for _,c0 in ipairs(apExtraButtons)do if c0.hovered then jY=true;break end end;if apbutton.hovered then jY=true end;bw=jY else bw=apbutton.hovered;if not bw then bx=AutopilotTargetIndex end end end;local function lJ(gJ)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cd,ce in pairs(by)do local bX="dim brightstroke"local lK=0.2;if SelectedTab==cd then bX="pbright dimstroke"lK=0.6 end;local lL=""if ce.hovered then lK=0.8;lL=";stroke:white"end;gJ[#gJ+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ce.width,ce.height,ce.x,ce.y,bX,lK,lL)gJ[#gJ+1]=bT(ce.x+ce.width/2,ce.y+ce.height/2+5,ce.label,"txt txtmid pdim")end end;local function lM(gJ)local function lN(gJ,lO,hover,bU,bV,dZ,lP,lQ,lR,lS,lT,button)if type(lS)=="function"then lS=lS(button)end;if type(lT)=="function"then lT=lT(button)end;gJ[#gJ+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",bU,bV,dZ,lP)if lO then gJ[#gJ+1]=f("%s'",lQ)else gJ[#gJ+1]=lR end;if hover then gJ[#gJ+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gJ[#gJ+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gJ[#gJ+1]=" rx='5'></rect>"gJ[#gJ+1]=f("<text x='%f' y='%f' font-size='24' fill='",bU+dZ/2,bV+lP/2+5)if lO then gJ[#gJ+1]="black"else gJ[#gJ+1]="white"end;gJ[#gJ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lO then gJ[#gJ+1]=f("%s</text>",lS)else gJ[#gJ+1]=f("%s</text>",lT)end end;local lU=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local lV=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lW=lN;for _,ce in pairs(fK)do local ko=ce.disableName;local kn=ce.enableName;if type(ko)=="function"then ko=ko(ce)end;if type(kn)=="function"then kn=kn(ce)end;if not ce.drawCondition or ce.drawCondition(ce)then lW(gJ,ce.toggleVar(ce),ce.hovered,ce.x,ce.y,ce.width,ce.height,lV,lU,ko,kn,ce)end end end;local lX=A(aD/2,0)local lY=A(aE/2,0)local gJ={}aP.HUDPrologue(gJ)if showHud then aP.UpdateHud(gJ)else if AlwaysVSpd then aP.DrawVerticalSpeed(gJ,as)end;aP.DisplayOrbitScreen(gJ)aP.DrawWarnings(gJ)end;if fQ and fR~={}then aP.DrawSettings(gJ)end;if radar_1 or radar_2 then aS.assignRadar()end;if bu[1]then aP.DrawRadarInfo()end;aP.HUDEpilogue(gJ)gJ[#gJ+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aD,aE)if a2~="empty"then aP.DisplayMessage(gJ,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aP.DrawDeadZone(gJ)end end;lJ(gJ)if x()==0 then if m()==1 and a1 then if not AltIsOn then lF()lM(gJ)end;if not aT and not aU then local lZ=table.concat(gJ,"")gJ={}gJ[#gJ+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gJ[#gJ+1]=lZ;gJ[#gJ+1]="</body>"aT=true;gJ[#gJ+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gJ,"")system.setScreen(content)elseif aU then local lZ=table.concat(gJ,"")gJ={}gJ[#gJ+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aD,aE)gJ[#gJ+1]=lZ;gJ[#gJ+1]="</body>"end;if not aT then gJ[#gJ+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lX,lY,ag,ah)end else lE()end else if not a1 and m()==0 then lE()if aj>DeadZone then if DisplayDeadZone then lD(gJ)end end elseif a1 and(not AltIsOn or not freeLookToggle)then lF()lM(gJ)end;gJ[#gJ+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lX,lY,ag,ah)end;gJ[#gJ+1]=[[</svg></body>]]content=table.concat(gJ,"")end;function kU.TenthTick()aP.DrawTanks()if shield_1 then aP.DrawShield()end end;function kU.OneSecond(gJ)local function l_()local gz=q()local hV=bc;local m0=gz-au;if hV>1.38889 then hV=hV/1000;local m1=hV*(gz-au)TotalDistanceTravelled=TotalDistanceTravelled+m1;ad=ad+m1 end;ae=ae+m0;TotalFlightTime=TotalFlightTime+m0;au=gz end;l_()aP.UpdatePipe()aP.ExtraData(gJ)end;function kU.ButtonSetup()kw()kB()fK=fL end;return kU end;local function m2()local function m3(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function m4()local function m5(m6,m7)return m6.name<m7.name end;bm={}for cd,ce in pairs(b[0])do bm[#bm+1]={name=ce.name,index=cd}end;table.sort(bm,m5)end;local function m8(m9)for cd,ce in pairs(m9)do if ce.name and ce.name==CustomTarget.name then return cd end end;return-1 end;local function ma()bx=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local mb=bm[AutopilotTargetIndex].index;local mc=b[0][mb]if mc.center then AutopilotTargetName=mc.name;ac=aL[0][mb]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=mc;for _,ce in pairs(aL[0])do if ce.name==CustomTarget.planetname then ac=ce;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function md(gN)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gN==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bm end end;if AutopilotTargetIndex==0 then ma()else local mb=bm[AutopilotTargetIndex].index;local mc=b[0][mb]if mc~=nil and mc.name=="Space"or iphCondition=="Custom Only"and mc.center or iphCondition=="No Moons"and string.find(mc.name,"Moon")~=nil then if gN==nil then md()else md(1)end else ma()end end else a2="Disengage autopilot before changing Interplanetary Helper"bG("iph","AP")end end;local function kH()local fi=-1;fi=m8(b[0])if fi>-1 then table.remove(b[0],fi)end;fi=-1;fi=m8(SavedLocations)if fi~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fi)end;md()m4()end;local function kC(fx,position,hu,me)if dbHud_1 or hu then local p=m3(position)local l8=p.gravity;if me then l8=unit.getClosestPlanetInfluence()end;local mf={position=position,name=fx,planetname=p.name,gravity=l8,safe=me}if not hu then SavedLocations[#SavedLocations+1]=mf else for cd,ce in pairs(b[0])do if ce.name and fx==ce.name then table.remove(b[0],cd)end end end;table.insert(b[0],mf)m4()ma()a2="Location saved as "..fx.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local mg={}function mg.UpdateAtlasLocationsList()m4()end;function mg.UpdateAutopilotTarget()ma()end;function mg.adjustAutopilotTargetIndex(gN)md(gN)end;function mg.findAtlasIndex(m9)m8(m9)end;function mg.UpdatePosition(mh)local fi=m8(SavedLocations)if fi~=-1 then if mh~=nil then SavedLocations[fi].name=mh;AutopilotTargetIndex=AutopilotTargetIndex-1;md()else local mi=SavedLocations[fi]mi.gravity=unit.getClosestPlanetInfluence()mi.position=bf;mi.safe=true end;a2=SavedLocations[fi].name.." position updated ("..SavedLocations[fi].planetname..")"else a2="Name Not Found"end end;function mg.AddNewLocation(fx,position,hu,me)kC(fx,position,hu,me)end;function mg.ClearCurrentPosition()kH()end;for cd,ce in pairs(SavedLocations)do table.insert(b[0],ce)end;m4()if AutopilotTargetIndex>#bm then AutopilotTargetIndex=0 end;mg.UpdateAutopilotTarget()return mg end;local function mj()local mk={}local function ml(e5)local mm=AutopilotEndSpeed;if not Autopilot then mm=0 end;if not aq then return aM.computeDistanceAndTime(e5,mm,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aM.computeDistanceAndTime(e5,mm,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function mn(e5)local mm=AutopilotEndSpeed;if not Autopilot then mm=0 end;return aM.computeDistanceAndTime(e5,mm,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local mo=false;local mp=0;local mq=0;local mr=0;local ms=q()local mt=0;local mu=0;local mv=0;local mw=0;local mx=false;local my=false;local mz=false;local mA=nil;local mB=0;function mk.GetAutopilotBrakeDistanceAndTime(e5)return ml(e5)end;function mk.GetAutopilotTBBrakeDistanceAndTime(e5)return mn(e5)end;local function mC(mD,mE,mF)mE=mE:project_on_plane(mD)mF=mF:project_on_plane(mD)return n(mE:cross(mF):dot(mD),mE:dot(mF))end;local function mG()local function mH()local mI=-1;local mJ=-1;if vBooster then mI=vBooster.getDistance()end;if hover then mJ=hover.getDistance()end;if mI~=-1 and mJ~=-1 then if mI<mJ then return mI else return mJ end elseif mI~=-1 then return mI elseif mJ~=-1 then return mJ else return-1 end end;local mK=mH()local mL=-1;if telemeter_1 then mL=telemeter_1.getDistance()end;if mK~=-1 and mL~=-1 then if mK<mL then return mK else return mL end elseif mK~=-1 then return mK else return mL end end;local function mM(planet,ds,mN)local function mO(mP,cJ)local dy=vec3(cJ)if mP.id==0 then return setmetatable({latitude=dy.x,longitude=dy.y,altitude=dy.z,id=0,systemId=mP.systemId},MapPosition)end;local dz=dy-mP.center;local aj=dz:len()local cP=aj-mP.radius;local cN=0;local cO=0;if not bZ(aj,0)then local dA=n(dz.y,dz.x)cO=dA>=0 and dA or 2*math.pi+dA;cN=math.pi/2-math.acos(dz.z/aj)end;return setmetatable({latitude=math.deg(cN),longitude=math.deg(cO),altitude=cP,id=mP.id,systemId=mP.systemId},MapPosition)end;local mQ=mO(planet,ds)mQ="::pos{"..mQ.systemId..","..mQ.id..","..mQ.latitude..","..mQ.longitude..","..mQ.altitude.."}"if mN then return mQ else system.setWaypoint(mQ)return true end end;local mR=false;function mk.showWayPoint(planet,ds,mN)return mM(planet,ds,mN)end;function mk.APTick()local function mS()if bt and not BrakeLanding then local d9=bt[1]local fy,fz=bt[2],bt[3]local mT=math.min(fy,fz or fy)local mU=mT/bc;local mV=AutoTakeoff and(bc<42 or ao~=-1)local mW=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mW and not mV and(a8*1.5>mT or mU<1)then BrakeIsOn=true;aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()end;if LockPitch then aR.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aR.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;aV=true end;if mU<11 then bs=d9.name.." COLLISION "..c4(mU).." / "..c1(mT,2)else bs=d9.name.." collision "..c4(mU)end;if mU<6 then bG("alarm","AL",2)end else bs=false end end;local function mX(mY,mZ,m_)local function n0(mY,db)mY=vec3(mY)db=vec3(db):normalize()local cu=mY*db;return cu.x+cu.y+cu.z end;local n1=0.001;local n2=1;if not aq or not aX or ao~=-1 or bc<Q then if m_==nil then m_=DampingMultiplier end;if mZ==nil then mZ=n1 end;mY=vec3(mY):normalize()local n3=vec3()-mY;local n4=-n0(n3,core.getConstructWorldOrientationRight())*n2;local n5=-n0(n3,core.getConstructWorldOrientationUp())*n2;if mq==0 then mq=n4/2 end;if mr==0 then mr=n5/2 end;if d(n4)<0.1 then V=V-n4*2 else V=V-(n4+(n4-mq)*m_)end;if d(n5)<0.1 then U=U+n5*2 else U=U+n5+(n5-mr)*m_ end;mq=n4;mr=n5;if d(n4)<mZ and d(n5)<mZ then return true end;return false elseif aX and ao==-1 then mY=bb;if m_==nil then m_=DampingMultiplier end;if mZ==nil then mZ=n1 end;mY=vec3(mY):normalize()local n3=b8-mY;local n4=-n0(n3,core.getConstructWorldOrientationRight())*n2;local n5=-n0(n3,core.getConstructWorldOrientationUp())*n2;if mq==0 then mq=n4/2 end;if mr==0 then mr=n5/2 end;if d(n4)<0.1 then V=V-n4*5 else V=V-(n4+(n4-mq)*m_)end;if d(n5)<0.1 then U=U+n5*5 else U=U+n5+(n5-mr)*m_ end;mq=n4;mr=n5;if d(n4)<mZ and d(n5)<mZ then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=mG()E=q()ms=E;if CollisionSystem then mS()end;if antigrav then bh=antigrav.getState()==1 end;local n6=1;local n7=1;local n8=E-ms;local n9=-math.deg(mC(b7,bb,b8))local na=math.deg(mC(b9,bb,b8))local gN=bd*-1;aX=aq and n9<-YawStallAngle or n9>YawStallAngle or na<-PitchStallAngle or na>PitchStallAngle;local nb=system.getMouseDeltaX()local nc=system.getMouseDeltaY()if InvertMouse and not a1 then nc=-nc end;V=0;Z=0;U=0;sys=aL[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aO(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bb)if as==0 then as=(bf-planet.center):len()-planet.radius end;br=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local l8=planet:getGravity(core.getConstructWorldPos()):len()*av;aY=0;aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aT then ag=r(ag+nb,-aD/2,aD/2)ah=r(ah+nc,-aE/2,aE/2)end else ag=0;ah=0 end else ag=r(ag+nb,-aD/2,aD/2)ah=r(ah+nc,-aE/2,aE/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then local hH,hI=nb,nc;if SelectedTab=="SCOPE"then hH,hI=scopeFOV/90,scopeFOV/90 end;if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity*hH elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity*hH else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity*hI elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity*hI else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(nc,-100,100)+0.5)*2*n6;V=(-utils.smoothstep(nb,-100,100)+0.5)*2*n7 end end end end;local nd=bc>8334;if bc>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not nd then a2="Space Speed Engine Shutoff reached"aR.cmdThrottle(0)end;if not nd and LastIsWarping then if not BrakeIsOn then aR.BrakeToggle()end;if Autopilot then aR.ToggleAutopilot()end end;LastIsWarping=nd;if aq and ar>0.09 then if bc>aZ/3.6 and not AtmoSpeedAssist and not mo then BrakeIsOn=true;mo=true elseif not AtmoSpeedAssist and mo then if bc<aZ/3.6 then BrakeIsOn=false;mo=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local ne=false;if CustomTarget and al~=1 then ne=mX(CustomTarget.position-bf,0.1)else ne=mX(vec3(bb),0.01)end;aV=true;if ne then aR.cmdCruise(e(aZ))if(d(bl)<2 or d(bk)>85)and bc>=aZ/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aR.BeginReentry()end elseif aq and AtmoSpeedAssist then aR.cmdThrottle(1)end elseif bc>Q then mX(vec3(bb),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bc>Q then mX(-vec3(bb))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aR.BeginReentry()al=false;an=true else al=false;aR.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bc*3.6>aZ-250 and d(be)<25 and ar>=0.1 and(CustomTarget.position-bf):len()>2000+as then aR.ToggleAutopilot()an=false end;if VertTakeOff then aV=true;local nf=HoldAltitude;if be<-30 then a2="Unable to achieve lift. Safety Landing."af=0;aV=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bh or HoldAltitude<planet.spaceEngineMinAltitude then if bh then nf=antigrav.getBaseAltitude()end;if as<nf-100 then a_=0;af=15;BrakeIsOn=false elseif be>0 then BrakeIsOn=true;af=0 elseif be<-30 then BrakeIsOn=true;af=15 elseif as>=nf then if bh then if Autopilot or VectorToTarget then aR.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bG("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bG("vtoc","VT")aR.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then a_=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if b5 then a_=0;af=20 else af=0;a_=36;aR.cmdCruise(3500)end else aV=autoRollPreference;IntoOrbit=true;b3=false;CancelIntoOrbit=false;mx=false;mv=nil;mw=nil;if mA==nil then mA=planet end;b2=nf;mz=true;VertTakeOff=false end end;if a_~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ng=r(a_-bk,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ng)local nh=r(vTpitchPID:get(),-1,1)U=nh end end;if IntoOrbit then local n3;local ni=false;local nj=c1(b2)if mA==nil then mA=planet;if VectorToTarget then mA=ac end end;if not mz then b2=e(mA.radius+mA.surfaceMaxAltitude+LowOrbitHeight)if mA.hasAtmosphere then b2=e(mA.radius+mA.noAtmosphericDensityAltitude+LowOrbitHeight)end;mz=true end;if b1.VectorToTarget and CustomTarget then n3=CustomTarget.position-bf end;local nk,nl=aO(mA):escapeAndOrbitalSpeed((bf-mA.center):len()-mA.radius)local nm=bl;if not mx then local nn=false;local no=false;aR.cmdThrottle(0)mw=0;b0="Aligning to orbital path - OrbitHeight: "..nj;if b1.VectorToTarget then mX(n3:normalize():project_on_plane(bd))ni=b8:dot(n3:project_on_plane(b7):normalize())>0.95 else mX(bb)ni=n9<0.5;if bc<150 then ni=true end end;U=0;mv=0;if bk<=mv+1 and bk>=mv-1 then nn=true else nn=false end;if nm<=mw+1 and nm>=mw-1 then no=true else no=false end;if nn and no and ni then mv=nil;mw=nil;mx=true end else if b1.VectorToTarget then mX(n3:normalize():project_on_plane(bd))elseif bc>150 then mX(bb)end;U=0;if b1.VectorToTarget and CustomTarget then local a8,_=aM.computeDistanceAndTime(bc,aZ/3.6,av,0,0,LastMaxBrake)if b3 and n3:len()>15000+a8+as then b0="Orbiting to Target"if as-100<=mA.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<mA.noAtmosphericDensityAltitude then b3=false end elseif b3 or n3:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bG("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;b1.VectorToTarget,b1.AutopilotAlign=false,false;aR.ToggleIntoOrbit()aR.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>b2*0.9 and as<b2*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=b2*0.99 and orbit.apoapsis.altitude>=b2*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or b3 then if b3 then BrakeIsOn=false;aR.cmdThrottle(0)mv=0;if not b1.VectorToTarget then a2="Orbit complete"bG("orCom","OB")aR.ToggleIntoOrbit()end else mB=mB+1;if mB>=2 then b3=true end end else b0="Adjusting Orbit - OrbitHeight: "..nj;my=true;aR.cmdCruise(nl*3.6+1)local np=b2-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(np-be*r(utils.smoothstep(2000-np,-2000,2000)^6*10,1,10))mv=r(VSpdPID:get(),-60,60)end end else local nq=2.75;local nr=d(A(nk*nq))local ns=nr%50;if ns>0 then nr=nr-ns+50 end;BrakeIsOn=false;if as<b2*0.8 then b0="Escaping planet gravity - OrbitHeight: "..nj;mv=utils.map(be,200,0,-15,80)elseif as>=b2*0.8 and as<b2*1.15 then b0="Approaching orbital corridor - OrbitHeight: "..nj;nr=nr*0.75;mv=utils.map(be,100,-100,-15,65)elseif as>=b2*1.15 and as<b2*1.5 then b0="Approaching orbital corridor - OrbitHeight: "..nj;nr=nr*0.75;if be<0 or my then mv=utils.map(as,b2*1.5,b2*1.01,-30,0)else mv=utils.map(as,b2*0.99,b2*1.5,0,30)end elseif as>b2*1.5 then b0="Reentering orbital corridor - OrbitHeight: "..nj;mv=-65;local nt=utils.map(be,-150,-400,1,0.55)nr=nr*nt end;aR.cmdCruise(e(nr))end end;if mv~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nu=mv-bk;OrbitPitchPID:inject(nu)local nw=r(OrbitPitchPID:get(),-0.5,0.5)U=nw end end;if Autopilot and ar==0 and not al then local function nx(bC,orbit)system.print(bC)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aR.cmdThrottle(0)P=false;a2=bC;bG("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;b2=as;mz=true end;aR.ToggleIntoOrbit()end end;local ny,nz=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nA=(CustomTarget.position-ac.center):normalize()local nB=nA:project_on_plane((ac.center-bf):normalize()):normalize()local nC=ac.center+nB*(ac.radius+AutopilotTargetOrbit)local nD=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bf-nC):len()<(bf-nD):len()then ny=nC else ny=nD;AutopilotEndSpeed=0 end;AutopilotTargetCoords=ny;aR.showWayPoint(ac,AutopilotTargetCoords)nz=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nz=true;AutopilotRealigned=true;TargetSet=true;ny=CustomTarget.position+(bf-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=ny end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local nA=(bf+bb*100000-ac.center):normalize()local nB=nA:project_on_plane((ac.center-bf):normalize()):normalize()if nB:len()<1 then nA=(bf+b8*100000-ac.center):normalize()nB=nA:project_on_plane((ac.center-bf):normalize()):normalize()end;ny=ac.center+nB*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=ny;TargetSet=true;nz=true;AutopilotRealigned=true;aR.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(ny)-bf):len()local iv,dq,dr=aL:getPlanetarySystem(0):castIntersections(bf,bb:normalize(),function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iw=dq;if dr~=nil and dq~=nil then iw=math.min(dr,dq)end;if iw~=nil and iw<AutopilotDistance and iv.name==ac.name then AutopilotDistance=iw end;local ne=true;local nE=(ac.center-(bf+vec3(bb):normalize()*AutopilotDistance)):len()-ac.radius;local ik=c1(nE)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a8,a9;if not TurnBurn then a8,a9=ml(bc)else a8,a9=mn(bc)end;if bc>50 and AutopilotAccelerating then local n3=vec3(ny)-bf;local nF=r(math.deg(mC(b7,bb:normalize(),n3:normalize()))*bc/500,-90,90)local nG=r(math.deg(mC(b9,bb:normalize(),n3:normalize()))*bc/500,-90,90)if d(nF)<20 and d(nG)<20 then nF=nF*2;nG=nG*2 end;if d(nF)<2 and d(nG)<2 then nF=nF*2;nG=nG*2 end;local n9=-math.deg(mC(b7,b8,bb:normalize()))local na=-math.deg(mC(b9,b8,bb:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nG-na)local nH=r(apPitchPID:get(),-1,1)U=U+nH;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nF-n9)local nI=r(apYawPID:get(),-1,1)V=V+nI;nz=true;if d(nF)>2 or d(nG)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bG("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end end elseif AutopilotAccelerating and bc<=50 then mX((ny-bf):normalize())end;if nE<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aO(ac):escapeAndOrbitalSpeed(nE)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iv,iw=aR.checkLOS((AutopilotTargetCoords-bf):normalize())if ac.name~=planet.name then if iv~=nil and ac.name~=iv.name and iw<AutopilotDistance then a2="Collision with "..iv.name.." in "..c1(iw).."\nClear LOS to continue."ai=5;mR=true else mR=false;a2=""end end end;if not mR then if not AutopilotCruising and not AutopilotBraking and not nz then ne=mX((ny-bf):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then ne=mX(-vec3(bb):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aR.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local nJ=unit.getThrottle()if AtmoSpeedAssist then nJ=K end;local nK=99999;local lk=-vec3(core.getWorldAcceleration()):dot(bb:normalize())local nL=r(bb:dot((ny-bf):normalize()),0,bc)if nL>0 or lk>0 then nK=aM.computeTravelTime(nL,lk,AutopilotDistance-a8)end;if ba:len()>=MaxGameVelocity or nJ==0 and P or warmup/4>nK then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bG("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aR.cmdThrottle(0)end;local nM=AutopilotDistance;if nM<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mp and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mp=bo else mp=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aR.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aR.cmdThrottle(1,true)end;local _,nl=aO(ac):escapeAndOrbitalSpeed((bf-planet.center):len()-planet.radius)local n3;if CustomTarget then n3=CustomTarget.position-bf end;if CustomTarget and CustomTarget.planetname=="Space"and bc<50 then nx("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bc<=nl and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then nx("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bG("apCir","AP")AutopilotStatus="Circularizing"end;if bc<=nl then if CustomTarget then if bb:normalize():dot(n3:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bG("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else nx("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aR.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else nx("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then nx("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nM=AutopilotDistance;if nM<=a8 or PreventPvP and bo<=a8+10000 and bn then if PreventPvP and bo<=a8+10000 and bn then if bo<mp and bo>2000 then aR.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;mp=bo else mp=bo;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bG("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local nJ=unit.getThrottle()if AtmoSpeedAssist then nJ=K end;if nJ>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;AutopilotCruising=false end else if ne then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*b9;AutopilotShipUp=b7;AutopilotShipRight=b9 end;AutopilotRealigned=true elseif ne and not mR then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bG("apAcc","AP")end;if not P then aR.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bG("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aR.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aR.showWayPoint(ac,CustomTarget.position)end;if a0 then aV=true;local nG=0;local e9=bf+vec3(unit.getMasterPlayerRelativePosition())local nN=e9-bf;local nO=vec3(nN):project_on(b8):len()local nP=vec3(nN):project_on(b9):len()local aj=y(nO*nO+nP*nP)mX(nN:normalize())local jw=40;local nQ=aj<jw;local nR=100;local nS=r((aj-jw)/2,10,nR)U=0;local ne=d(V)<0.1;if ne and bc<nS and not nQ then BrakeIsOn=false;nG=-20 else BrakeIsOn=true;nG=0 end;local nT=0;if d(nG-bk)>nT then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nG-bk)local nH=pitchPID:get()U=nH end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local nU=LastMaxBrakeInAtmo;if nU then nU=nU*r(bc/100,0.1,1)*ar else nU=LastMaxBrake end;if ar<0.01 then nU=LastMaxBrake end;local nV=b8:project_on_plane(bd):normalize():dot(bb)local nW=vec3(core.getWorldAirFrictionAcceleration())local nX=nW:len()*av;if nV>100 then a8,a9=aM.computeDistanceAndTime(nV,100,av,0,0,nU)local nY,nZ=aM.computeDistanceAndTime(100,0,av,0,0,nU*0.55)a8=a8+nY else a8,a9=aM.computeDistanceAndTime(nV,0,av,0,0,nU*0.55)end;local np=HoldAltitude-as-be;local n_=200+bc;if Reentry or al then minMax=2000+bc end;local o0=1;if AutoTakeoff then o0=r(bc/100,0.1,1)end;local nG=(utils.smoothstep(np,-n_,n_)-0.5)*2*MaxPitch*o0;if not Reentry and not al and not VectorToTarget and b8:dot(bb:normalize())<0.99 then nG=(utils.smoothstep(np,-n_*r(20-19*ar*10,1,20),n_*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*o0 end;if not AltitudeHold then nG=0 end;if LockPitch~=nil then if br and not IntoOrbit then nG=LockPitch else LockPitch=nil end end;aV=true;local o1=U;if Reentry then local o2=e(aZ)local o3,o4=aM.computeDistanceAndTime(bc,o2/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)o3=o3==-1 and 5000 or o3;local o5=as-(planet.noAtmosphericDensityAltitude+o3)local o6=as>planet.noAtmosphericDensityAltitude+o3*1.35;if o6 then nG=ReEntryPitch;if bc<=o2/3.6 and bc>o2/3.6-10 and d(bb:normalize():dot(b8))>0.9 and not bj then O=false;aR.cmdThrottle(1)end elseif bj and not o6 and not aq then aR.cmdCruise(o2,true)end;if bj then if bc>o2/3.6 and not o6 then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if be>0 then BrakeIsOn=true end;if not R then nG=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;nG=0;aV=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and o6 then aV=true elseif not o6 then if not aq and(bj or s:getTargetSpeed(axisCommandId.longitudinal)~=o2)then aR.cmdCruise(o2)end;if bc<o2/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;aV=true end end end;if bc>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then mX(vec3(bb))end;if bp or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local n3;if bp then if type(bp)=="table"then n3=bp elseif bp<3 and bp>0 then n3=-bd:cross(bb)*5000 elseif bp>=3 then n3=bd:cross(bb)*5000 elseif bp<0 then n3=bb*25000 end elseif CustomTarget~=nil then n3=CustomTarget.position-bf else n3=ac.center-bf end;local nF=math.deg(mC(bd:normalize(),bb,n3))*2;local jz=math.rad(d(bl))if bc>minRollVelocity and ar>0.01 then local o7=1000+bc;local o8=(utils.smoothstep(np-be*10,-o7,o7)-0.5)*2*MaxPitch;local o9=r(90-o8,0,180)aY=r(nF*2,-o9,o9)local oa=nF;nF=r(r(nF,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jz)+4*(bk-nG)*math.sin(math.rad(bl)),-YawStallAngle*0.80,YawStallAngle*0.80)local ob=1;if aY~=0 then ob=d(jz/aY)end;ob=(90-r(d(aY-bl),0,90))/90;local oc=nG;if d(bl)>90 then oc=-oc end;nG=ob*r(r(oc*math.cos(jz),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(oa)*math.sin(jz),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else aY=0;nF=r(nF,-YawStallAngle*0.80,YawStallAngle*0.80)end;local od=n9-nF;if bp and d(od)<=0.0001 and(type(bp)=="table"or type(bp)~="table"and bp<0 and d(bl)<1)then if bp==-2 then aR.ToggleAltitudeHold()end;bp=nil;bG("180Off","BR")return end;if not aX and bc>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(od)local nI=r(yawPID:get(),-1,1)V=V+nI elseif aq and ao>-1 or bc<minRollVelocity then mX(n3)elseif aX and ar>0.01 then if(n9<-YawStallAngle or n9>YawStallAngle)and ar>0.01 then mX(bb)end;if(na<-PitchStallAngle or na>PitchStallAngle)and ar>0.01 then nG=r(bk-na,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local nf=planet:getAltitude(CustomTarget.position)local o5=n3:project_on_plane(bd):len()StrongBrakes=true;if not am and not Reentry and o5<=a8 and(bb:project_on_plane(bd):normalize():dot(n3:project_on_plane(bd):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aR.cmdThrottle(0)if AltitudeHold then aR.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(nV<0.1 or o5<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<o5)then if not bh then bG("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bs=false end;LastDistanceToTarget=o5 end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local n3=CustomTarget.position-bf;local nf=planet:getAltitude(CustomTarget.position)local o5=y(n3:len()^2-(as-nf)^2)local nU=LastMaxBrakeInAtmo;if nU then a8,a9=aM.computeDistanceAndTime(bc,0,av,0,0,nU/2)StrongBrakes=true;if o5<=a8+bc*n8/2 and bb:project_on_plane(bd):normalize():dot(n3:project_on_plane(bd):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aR.BeginReentry()end end;LastDistanceToTarget=o5 end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not b3 and not IntoOrbit then b2=HoldAltitude;mz=true;if VectorToTarget then b1.VectorToTarget=true end;aR.ToggleIntoOrbit()VectorToTarget=false;mx=true end end;if aX and ar>0.01 and ao==-1 and bc>minRollVelocity and VectorStatus~="Finalizing Approach"then mX(bb)nG=r(bk-na,bk-PitchStallAngle*0.80,bk+PitchStallAngle*0.80)end;U=o1;local mL=-1;if BrakeLanding then nG=0;local oe=false;local of=30;if aN~=nil and aN>0 then local og=r(ar,0.4,2)local nU=LastMaxBrakeInAtmo*r(bc/100,0.1,1)*og;local oh=aN*og+nU-l8;local oi=nU/2-l8;local oj=bc-y(d(oi/2)*20/(0.5*av))*utils.sign(oi)if oj<0 then oj=0 end;local ok;if bc>100 then local ol,_=aM.computeDistanceAndTime(bc,100,av,0,0,nU)local om,_=aM.computeDistanceAndTime(100,0,av,0,0,y(nU))ok=ol+om else ok=aM.computeDistanceAndTime(bc,0,av,0,0,y(nU))end;if ok<20 then BrakeIsOn=false else local on=0;if oj>100 then local oo,_=aM.computeDistanceAndTime(oj,100,av,0,0,oh)local op,_=aM.computeDistanceAndTime(100,0,av,0,0,aN*og+y(nU)-l8)on=oo+op else on,_=aM.computeDistanceAndTime(oj,0,av,0,0,aN*og+y(nU)-l8)end;on=(on+15+bc*n8)*1.1;local oq=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if oq then local nf=planet:getAltitude(CustomTarget.position)local os=as-nf-100;local n3=CustomTarget.position-bf;local ot=y(n3:len()^2-(as-nf)^2)if ot>100 then oq=false elseif os<=on or on==-1 then BrakeIsOn=true;oe=true else BrakeIsOn=false;oe=true end end;if not oq and CalculateBrakeLandingSpeed then if on>=of then BrakeIsOn=true else BrakeIsOn=false end;oe=true end end end;if not bj then aR.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;mL=ao;if mL>-1 then aV=autoRollPreference;if bc<1 or bb:normalize():dot(bd)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bG("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bb:normalize():dot(-gN)<0.999 then BrakeIsOn=true elseif be<-brakeLandingRate and not oe then BrakeIsOn=true elseif not oe then BrakeIsOn=false end end;if AutoTakeoff or am then local iv,dr,dq;if AutopilotTargetCoords~=nil then iv,dr,dq=aL:getPlanetarySystem(0):castIntersections(bf,(AutopilotTargetCoords-bf):normalize(),function(d9)return d9.radius+d9.noAtmosphericDensityAltitude end)end;if bh then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aR.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(nG)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bj and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bc<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aR.cmdThrottle(0)elseif am then aR.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iv==nil or iv.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bj then aR.cmdThrottle(0)end;AutopilotAccelerating=true end end;local ou=ao>-1;local ov=bk;if(VectorToTarget or am or bp)and not ou and bc>minRollVelocity and ar>0.01 then local jz=math.rad(d(bl))ov=bk*d(math.cos(jz))+na*math.sin(jz)end;local ow=r(nG-ov,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then ow=r(nG-ov,-85,MaxPitch)elseif ar<0.01 then ow=r(nG-ov,-MaxPitch,MaxPitch)end;if d(bl)<5 or VectorToTarget or bp or BrakeLanding or ou or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(ow)local nH=pitchPID:get()U=U+nH end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function mk.ToggleIntoOrbit()b3=false;mv=nil;mw=nil;mB=0;if ar==0 then if IntoOrbit then bG("orOff","AP")IntoOrbit=false;mx=false;mA=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mz=false elseif br then bG("orOn","AP")IntoOrbit=true;aV=true;if mA==nil then mA=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;mx=false;mA=nil;aV=autoRollPreference;if AltitudeHold then AltitudeHold=false end;b1.VectorToTarget=false;b1.AutopilotAlign=false;mz=false end end;function mk.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;aV=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aR.cmdCruise(e(aZ))end else b3=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function mk.checkLOS(mY)local iv,dq,dr=aL:getPlanetarySystem(0):castIntersections(bf,mY,function(d9)if d9.noAtmosphericDensityAltitude>0 then return d9.radius+d9.noAtmosphericDensityAltitude else return d9.radius+d9.surfaceMaxAltitude*1.5 end end)local iw=dq;if dr~=nil and dq~=nil then iw=math.min(dr,dq)end;if iw~=nil then return iv,iw else return nil,nil end end;function mk.ToggleAutopilot()local function ox(SpaceTarget)bs=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aR.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-mu<1.5 and ar>0 then if not b6 then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bG("orH","OH")end;mu=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else mu=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aQ.UpdateAutopilotTarget()aR.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bG("apSpc","AP")if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bG("vtt","AP")ox(SpaceTarget)end else bG("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then b3=false;Autopilot=true elseif not aq then if IntoOrbit then aR.ToggleIntoOrbit()end;b2=planet.noAtmosphericDensityAltitude+LowOrbitHeight;mz=true;b1.AutopilotAlign=true;b1.VectorToTarget=true;mx=false;if not IntoOrbit then aR.ToggleIntoOrbit()end end end else bG("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aR.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and br)and not IntoOrbit then WaypointSet=false;b3=false;mx=false;aR.ToggleIntoOrbit()else bG("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bG("apP","AP")am=true;aR.ToggleAltitudeHold()end else bG("apOff","AP")aR.ResetAutopilots(1)end end;function mk.cmdThrottle(cz,oy)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not oy then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cz)K=r(A(cz*100,0)/100,-1,1)bi=nil end;function mk.cmdCruise(cz,oy)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not oy then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cz)bi=cz end;function mk.ToggleLockPitch()if LockPitch==nil then bG("lkPOn","LP")if not a1 then LockPitch=bk else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bG("lkPOff","LP")LockPitch=nil end end;function mk.ToggleAltitudeHold()if E-mt<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bG("11","EP")else if br then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b2=HoldAltitude;mz=true;if not IntoOrbit then aR.ToggleIntoOrbit()end;mx=true end end;mt=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else mt=E end;if br and ar==0 then b2=as;mz=true;mx=true;aR.ToggleIntoOrbit()if IntoOrbit then mt=E else mt=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;aV=true;LockPitch=nil;b3=false;if ao~=-1 and bc<20 then bG("lfs","LS")AutoTakeoff=true;if mt>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bg then aR.ToggleVerticalTakeoff()end else bG("altOn","AH")AutoTakeoff=false;if mt>-1 then if br then HoldAltitude=as end end;if VertTakeOff then aR.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else bG("altOff","AH")if IntoOrbit then aR.ToggleIntoOrbit()end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;aV=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;mt=0 end end;function mk.ResetAutopilots(mk)if mk then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bp=nil;if not bh then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aR.ToggleVerticalTakeoff()end;if IntoOrbit then aR.ToggleIntoOrbit()end;aV=autoRollPreference;al=false;an=false;af=0 end;function mk.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;aV=autoRollPreference end;if BrakeIsOn then bG("bkOn","B",1)aR.ResetAutopilots()else bG("bkOff","B",1)end end;function mk.BeginReentry()if Reentry then a2="Re-Entry cancelled"bG("reOff","RE")Reentry=false;aV=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;aV=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..aZ;bG("par","RE")else Reentry=true;AltitudeHold=true;aV=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local bW=c1(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..aZ.." Target Altitude: "..bW;bG("glide","RE")aR.cmdCruise(e(aZ))end;AutoTakeoff=false end;function mk.ToggleAntigrav()if antigrav and not ExternalAGG then if bh then bG("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bG("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=mG()return mk end;function script.onStart()local oz=false;local function oA()local function oB(oC)local oD=dbHud_1.hasKey;for cd,ce in pairs(oC)do if oD(ce)then local cu=g(dbHud_1.getStringValue(ce))if cu~=nil then _G[ce]=cu;oz=true end end end end;if dbHud_1 then if not useTheseSettings then oB(bM())coroutine.yield()oB(c)else oB(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;oz=false end;coroutine.yield()if oz then a2="Loaded Saved Variables"aD=ResolutionX;aE=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)aV=autoRollPreference;aZ=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function oE()local function oF(oG,oH)if oG>oH then oH=oG end;local oI,oJ=0,0;if ContainerOptimization>0 then oI=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then oJ=FuelTankOptimization*0.05 end;oH=oH*(1-(oI+oJ))return oH end;local oK=core.getElementNameById;local oL=fuelX~=0 and fuelY~=0;for cd in pairs(at)do local type=core.getElementTypeById(at[cd])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')and core.getElementForwardById(at[cd])[3]>0 then bg=true end end;if o(type,'^.*Space Engine$')then b6=true;if o(tostring(core.getElementTagsById(at[cd])),'^.*vertical.*$')then local oM=core.getElementForwardById(at[cd])if oM[3]<0 then b4=true else b5=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local oN=j(at[cd])if oN>10000 then G=110 elseif oN>1000 then G=55 elseif oN>150 then G=27 end end;aI=aI+j(at[cd])if oL and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local oN=j(at[cd])local lg=l(at[cd])local oG=0;local gz=q()if type=="Atmospheric Fuel Tank"then local oH=400;local oO=35.03;if oN>10000 then oH=51200;oO=5480 elseif oN>1300 then oH=6400;oO=988.67 elseif oN>150 then oH=1600;oO=182.67 end;oG=lg-oO;if fuelTankHandlingAtmo>0 then oH=oH+oH*fuelTankHandlingAtmo*0.2 end;oH=oF(oG,oH)aF[#aF+1]={at[cd],oK(at[cd]),oH,oO,oG,gz}end;if type=="Rocket Fuel Tank"then local oH=320;local oO=173.42;if oN>65000 then oH=40000;oO=25740 elseif oN>6000 then oH=5120;oO=4720 elseif oN>700 then oH=640;oO=886.72 end;oG=lg-oO;if fuelTankHandlingRocket>0 then oH=oH+oH*fuelTankHandlingRocket*0.1 end;oH=oF(oG,oH)aH[#aH+1]={at[cd],oK(at[cd]),oH,oO,oG,gz}end;if type=="Space Fuel Tank"then local oH=600;local oO=35.03;if oN>10000 then oH=76800;oO=5480 elseif oN>1300 then oH=9600;oO=988.67 elseif oN>150 then oH=2400;oO=182.67 end;oG=lg-oO;if fuelTankHandlingSpace>0 then oH=oH+oH*fuelTankHandlingSpace*0.2 end;oH=oF(oG,oH)aG[#aG+1]={at[cd],oK(at[cd]),oH,oO,oG,gz}end end end;if not bg then VertTakeOff,VertTakeOffEngine=false,false end end;local function oP()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;if antigrav then bh=antigrav.getState()==1;if bh and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and ba:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(aW)if aq and ao~=-1 then aN=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function oQ()local oR={}local function oS()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local oT={[1]=4480,[6]=4480,[7]=6270}for oU,oV in pairs(b)do b[oU][0]=oS()b[oU][0].systemId=oU;oR[oU]={}for oW,planet in pairs(b[oU])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=oT[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=oU;planet.bodyId=planet.id;oR[oU][oW]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then bB[#bB+1]=planet end end end;aK=cf()aL=aK(oR)aM=dE()aO=e7()aQ=m2()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})oA()coroutine.yield()oE()coroutine.yield()aR=mj()oP()coroutine.yield()oQ()aS=ev()aP=fI()aP.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bu[1]=nil;if radar_1 then bu[1]=radar_1;aS.pickType()end;bG("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(door)do ce.toggle()end end;if switch then for _,ce in pairs(switch)do ce.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,ce in pairs(forcefield)do ce.toggle()end end;c9()if button then button.activate()end;if SetWaypointOnExit then aR.showWayPoint(planet,bf)end;bG("stop","SU")end;function script.onTick(oX)local oY=nil;if oX=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bG("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif oX=="tenthSecond"then local function oZ()local o_=system.createData;local p0=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=p0(panelInterplanetary,"value")interplanetaryHeaderText=o_('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=p0(panelInterplanetary,"value")widgetDistanceText=o_('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=p0(panelInterplanetary,"value")widgetTravelTimeText=o_('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=p0(panelInterplanetary,"value")widgetMaxMassText=o_('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=p0(panelInterplanetary,"value")widgetTargetOrbitText=o_('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=p0(panelInterplanetary,"value")widgetCurBrakeDistanceText=o_('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=p0(panelInterplanetary,"value")widgetCurBrakeTimeText=o_('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=p0(panelInterplanetary,"value")widgetMaxBrakeDistanceText=o_('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=p0(panelInterplanetary,"value")widgetMaxBrakeTimeText=o_('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=p0(panelInterplanetary,"value")widgetTrajectoryAltitudeText=o_('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function p1()t(panelInterplanetary)panelInterplanetary=nil end;local function p2()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bf):len()else AutopilotDistance=(CustomTarget.position-bf):len()end end;local e5=bc;local nJ=unit.getThrottle()/100;if AtmoSpeedAssist then nJ=K end;local p3,p4=aM.computeDistanceAndTime(bc,MaxGameVelocity,av,a:maxForceForward()*nJ,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,p5;if not TurnBurn and e5>0 then _,p5=aR.GetAutopilotBrakeDistanceAndTime(e5)else _,p5=aR.GetAutopilotTBBrakeDistanceAndTime(e5)end;local p6=0;local p7=0;if AutopilotCruising or not Autopilot and e5>5 then p7=aM.computeTravelTime(e5,0,AutopilotDistance)elseif a8+p3<AutopilotDistance then p6=AutopilotDistance-(a8+p3)p7=aM.computeTravelTime(8333.0556,0,p6)else local p8=(AutopilotDistance-a8)/p3;p3=AutopilotDistance-a8;p4=p4*p8 end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return p7 elseif AutopilotBraking then return p5 elseif AutopilotCruising then return p7+p5 else return p4+a9+p7 end end;local function p9(l8,pa)if l8==nil then l8=core.g()end;l8=A(l8,5)if pa~=nil and pa or(oY==nil or oY~=l8)then local e5=ba:len()local pb=g(unit.getData()).maxBrake;if pb~=nil and pb>0 and aq then pb=pb/r(e5/100,0.1,1)pb=pb/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+pb)/2 else LastMaxBrakeInAtmo=pb end end end;if pb~=nil and pb>0 then LastMaxBrake=pb end;oY=l8 end end;p9(nil,true)if bi~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bi then aR.cmdCruise(bi)else bi=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then oZ()end;if AutopilotTargetName~=nil then local pc=CustomTarget~=nil;local pd=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()pd=pd>1000000 and A(pd/1000000,2).." kTons"or A(pd/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=p2()if pc and not Autopilot then aj=(bf-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bf):len()end;if not TurnBurn then a8,a9=aR.GetAutopilotBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aR.GetAutopilotTBBrakeDistanceAndTime(bc)aa,ab=aR.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=c1(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..c4(travelTime)..'", "unit":""}')ik=c1(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..c4(a9)..'", "unit":""}')ik=c1(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..c4(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",pd)..'", "unit":""}')ik=c1(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bj and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aR.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else p1()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aP.TenthTick()elseif oX=="oneSecond"then local function pe(gJ)local pf=0;aB=""local pg=aI;local ph=0;local pi=0;local pj=0;local gD=0;local gE=""local pk=core.getElementHitPointsById;for cd in pairs(at)do local oN=0;local pl=0;pl=j(at[cd])oN=pk(at[cd])ph=ph+oN;if oN<pl then if oN==0 then pj=pj+1 else pi=pi+1 end;if aJ and#aA==0 then position=vec3(core.getElementPositionById(at[cd]))local bU=position.x;local bV=position.y;local e_=position.z;table.insert(aA,core.spawnArrowSticker(bU,bV,e_+1,"down"))table.insert(aA,core.spawnArrowSticker(bU,bV,e_+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(bU+1,bV,e_,"north"))table.insert(aA,core.spawnArrowSticker(bU+1,bV,e_,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(bU-1,bV,e_,"south"))table.insert(aA,core.spawnArrowSticker(bU-1,bV,e_,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(bU,bV-1,e_,"east"))table.insert(aA,core.spawnArrowSticker(bU,bV-1,e_,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(bU,bV+1,e_,"west"))table.insert(aA,core.spawnArrowSticker(bU,bV+1,e_,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cd])end elseif aJ and#aA>0 and aA[11]==at[cd]then for gy in pairs(aA)do core.deleteSticker(aA[gy])end;aA={}end end;pf=e(ph/pg*100)if pf<100 then gJ[#gJ+1]=bT(0,0,"","pbright txt")gD=e(pf*2.55)gE=f("rgb(%d,%d,%d)",255-gD,gD,0)if pf<100 then gJ[#gJ+1]=bT("50%",1035,"Elemental Integrity: "..pf.."%","txtbig txtmid","fill:"..gE)if pj>0 then gJ[#gJ+1]=bT("50%",1055,"Disabled Modules: "..pj.." Damaged Modules: "..pi,"txtbig txtmid","fill:"..gE)elseif pi>0 then gJ[#gJ+1]=bT("50%",1055,"Damaged Modules: "..pi,"txtbig txtmid","fill:"..gE)end end end end;local function pm()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bz=core.getPlayersOnBoard()bA=core.getDockedConstructs()pm()local gJ={}aP.OneSecond(gJ)if ShouldCheckDamage then pe(gJ)end;ak=table.concat(gJ,"")collectgarbage("collect")elseif oX=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cu=g(dbHud_1.getStringValue("SavedLocations"))if cu~=nil then _G["SavedLocations"]=cu;local fi=-1;local mf;for cd,ce in pairs(SavedLocations)do if ce.name and ce.name=="SatNav Location"then fi=cd;break end end;if fi~=-1 then mf=SavedLocations[fi]fi=-1;for cd,ce in pairs(b[0])do if ce.name and ce.name=="SatNav Location"then fi=cd;break end end;if fi>-1 then b[0][fi]=mf end;aQ.UpdateAtlasLocationsList()a2=mf.name.." position updated"end end;for i=1,#bm do if bm[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bm[i].name)aQ.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif oX=="msgTick"then local gJ={}aP.DisplayMessage(gJ,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif oX=="animateTick"then aU=true;aT=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif oX=="hudTick"then aP.hudtick()elseif oX=="apTick"then aR.APTick()elseif oX=="radarTick"then aS.UpdateRadar()elseif oX=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function pn(po,nS)local pp=vec3()local pq=vec3()if po==axisCommandId.longitudinal then pp=vec3(core.getConstructOrientationForward())pq=b8 elseif po==axisCommandId.vertical then pp=vec3(core.getConstructOrientationUp())pq=b7 elseif po==axisCommandId.lateral then pp=vec3(core.getConstructOrientationRight())pq=b9 else return vec3()end;local pr=vec3(core.getWorldGravity())local ps=pr:dot(pq)local pt=vec3(core.getWorldAirFrictionAcceleration())local pu=pt:dot(pq)local pv=ba:dot(pp)local pw=nS*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(pw-pv)local px=targetSpeedPID2:get()local py=(px-pu-ps)*pq;return py end;local function pz(po,nS)local pp=vec3()local pq=vec3()if po==axisCommandId.longitudinal then pp=vec3(core.getConstructOrientationForward())pq=b8 elseif po==axisCommandId.vertical then pp=vec3(core.getConstructOrientationUp())pq=b7 elseif po==axisCommandId.lateral then pp=vec3(core.getConstructOrientationRight())pq=b9 else return vec3()end;local pr=vec3(core.getWorldGravity())local ps=pr:dot(pq)local pt=vec3(core.getWorldAirFrictionAcceleration())local pu=pt:dot(pq)local pv=ba:dot(pp)local pw=nS*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(pw-pv)local px=targetSpeedPID:get()local py=(px-pu-ps)*pq;return py end;local function pA(pB,gM,m7)local pC=pB:cross(m7):normalize_inplace()local hy=math.acos(r(pC:dot(-gM),-1,1))*constants.rad2deg;if pC:cross(-gM):dot(m7)<0 then hy=-hy end;return hy end;if antigrav and not ExternalAGG then if not bh and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bj=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bj and O then aR.cmdThrottle(0)O=false elseif not bj and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local pD=r(T+U+system.getControlDeviceForwardInput(),-1,1)local pE=r(W+Z+system.getControlDeviceYawInput(),-1,1)local pF=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local pG=Y;bd=vec3(core.getWorldVertical())if bd==nil or bd:len()==0 then bd=(planet.center-bf):normalize()end;b7=vec3(core.getConstructWorldOrientationUp())b8=vec3(core.getConstructWorldOrientationForward())b9=vec3(core.getConstructWorldOrientationRight())bb=vec3(core.getWorldVelocity())ba=vec3(core.getVelocity())bf=vec3(core.getConstructWorldPos())av=core.getConstructMass()bc=vec3(bb):len()be=-bd:dot(bb)bl=getRoll(bd,b8,b9)local pH=bl/180*math.pi;local pI=math.cos(pH)local pJ=math.sin(pH)bk=pA(bd,b8,b9*pI+b7*pJ)local pK=bb:normalize()local pL=d(bl)local pM=utils.sign(bl)local pN=vec3(core.getWorldAngularVelocity())local pO=pD*pitchSpeedFactor*b9+pE*rollSpeedFactor*b8+pF*yawSpeedFactor*b7;if aV==true and bd:len()>0.01 then local pP=d(aY-bl)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and pP>0 or ar>0.0 and pP<autoRollRollThreshold and autoRollPreference)and pE==0 and d(bk)<85 then local pQ=aY;local pR=autoRollFactor;if ar==0 then pR=pR/4;aY=0;pQ=0 end;if rollPID==nil then rollPID=pid.new(pR*0.01,0,pR*0.1)end;rollPID:inject(pQ-bl)local pS=rollPID:get()pO=pO+pS*b8 end end;local pT=1;local pU=0;local pV=1;local pW=system.getMouseWheel()if pW>0 then bD()elseif pW<0 then bD(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bj then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(aZ/3.6-bb:dot(b8))local pX=throttlePID:get()N=r(pX,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-aZ/3.6)local pY=r(brakePID:get(),0,1)if ar>0 and be<-80 or ar>0.005 then L=pY end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pZ=''local p_=vec3()local q0=pn(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",q0,pU)local q1='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then q1=q1 ..ExtraLongitudeTags end;local q2=s:getAxisCommandType(axisCommandId.longitudinal)local q3=s:composeAxisAccelerationFromThrottle(q1,axisCommandId.longitudinal)local q4=pz(axisCommandId.lateral,LeftAmount*1000)pZ=pZ..' , '.."lateral airfoil , lateral ground "p_=p_+q4;if p_:len()>constants.epsilon then a:setEngineForceCommand(pZ,p_,pU,'','','',pV)end;a:setEngineForceCommand(q1,q3,pT)local q5='thrust analog vertical fueled 'local q6='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then q6=q6 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then q5=q5 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(q5,q0,pT)else a:setEngineForceCommand(q5,vec3(),pT)end;if LeftAmount~=0 then a:setEngineForceCommand(q6,q4,pT)else a:setEngineForceCommand(q6,vec3(),pT)end;if pG==0 then pG=L end;local q7=-pG*(brakeSpeedFactor*bb+brakeFlatFactor*pK)a:setEngineForceCommand('brake',q7)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local nS=unit.getAxisCommandValue(0)if not bj then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bb:len()-nS/3.6)local pY=r(brakePID:get(),0,1)pG=r(pG+pY,0,1)end;local q7=-pG*(brakeSpeedFactor*bb+brakeFlatFactor*pK)a:setEngineForceCommand('brake',q7)local pZ=''local p_=vec3()local q8=false;local q1='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then q1=q1 ..ExtraLongitudeTags end;local q2=s:getAxisCommandType(axisCommandId.longitudinal)if q2==axisCommandType.byThrottle then local q3=s:composeAxisAccelerationFromThrottle(q1,axisCommandId.longitudinal)a:setEngineForceCommand(q1,q3,pT)elseif q2==axisCommandType.byTargetSpeed then local q3=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pZ=pZ..' , '..q1;p_=p_+q3;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then q8=true end end;local q6='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then q6=q6 ..ExtraLateralTags end;local q9=s:getAxisCommandType(axisCommandId.lateral)if q9==axisCommandType.byThrottle then local qa=s:composeAxisAccelerationFromThrottle(q6,axisCommandId.lateral)a:setEngineForceCommand(q6,qa,pT)elseif q9==axisCommandType.byTargetSpeed then local q4=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pZ=pZ..' , '..q6;p_=p_+q4 end;local q5='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then q5=q5 ..ExtraVerticalTags end;local qb=s:getAxisCommandType(axisCommandId.vertical)if qb==axisCommandType.byThrottle then local q0=s:composeAxisAccelerationFromThrottle(q5,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(q5,q0,pT,'airfoil','ground','',pV)else a:setEngineForceCommand(q5,vec3(),pT)a:setEngineForceCommand('airfoil vertical',q0,pT,'airfoil','','',pV)a:setEngineForceCommand('ground vertical',q0,pT,'ground','','',pV)end elseif qb==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),pT)end;local qc=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pZ=pZ..' , '..q5;p_=p_+qc end;if p_:len()>constants.epsilon then if Y~=0 or q8 or d(pK:dot(b8))<0.5 then pZ=pZ..', brake'end;a:setEngineForceCommand(pZ,p_,pU,'','','',pV)end end;local qd=torqueFactor*(pO-pN)local qe=vec3(core.getWorldAirFrictionAngularAcceleration())qd=qd-qe;a:setEngineTorqueCommand('torque',qd,pT,'airfoil','','',pV)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local e5=ba:len()local qf=0.15;if not bj then local qg=s:getTargetSpeed(axisCommandId.longitudinal)if e5*3.6>qg*(1-qf)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e5*3.6<qg*(1-qf)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local nJ=unit.getThrottle()if AtmoSpeedAssist then nJ=K*100 end;local nS=nJ/100;if k==0 then nS=nS*MaxGameVelocity;if e5>=nS*(1-qf)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e5<nS*(1-qf)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local o2=e(aZ)nS=nS*o2/3.6;if e5>=nS*(1-qf)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif e5<nS*(1-qf)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local fF=coroutine.status(beginSetup)if fF=="suspended"then local cz,fG=coroutine.resume(beginSetup)if fG then system.print("ERROR STARTUP: "..fG)end elseif fF=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aT and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(qh)local function qi(bE)local D=1;local function qj(qk,bE)local ql={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local qm=qk;for _,ce in ipairs(ql)do if bE and qm>ce then qk=ce elseif qk<ce and not bE then qk=ce;break end end;return qk end;if bE then D=-1 end;if not ExternalAGG and bh then if a1 and bE then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then b2=qj(b2,bE)else b2=b2+D*a3 end;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=qj(HoldAltitude,bE)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function qn(qo)if not aq then a2="Flight Assist in Atmo only"return end;local ck=type(qo)if bp==nil then if ck=="table"then if Autopilot or VectorToTarget then aR.ToggleAutopilot()end;bG("180On","BR")elseif qo==1 then bG("bnkLft","BR")else bG("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aR.ToggleAltitudeHold()if ck~="table"then qo=qo+1 end end;bp=qo else bG("180Off","BR")bp=nil end end;if qh=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aR.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then bG("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;aV=true;GearExtended=false else if S then bG("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bG("grOut","LG",1)a.control.extendLandingGears()end else if S then bG("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif qh=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif qh=="forward"then T=T-1 elseif qh=="backward"then if AltIsOn then qn(-bb*5000)else T=T+1 end elseif qh=="left"then if AltIsOn then qn(1)else W=W-1 end elseif qh=="right"then if AltIsOn then qn(3)else W=W+1 end elseif qh=="yawright"then X=X-1 elseif qh=="yawleft"then X=X+1 elseif qh=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif qh=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif qh=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif qh=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif qh=="groundaltitudeup"then qi()elseif qh=="groundaltitudedown"then qi(true)elseif qh=="option1"then toggleView=false;if AltIsOn and a1 then local qp=""for i=1,#bz do qp=qp.."| Name: "..system.getPlayerName(bz[i]).." Mass: "..A(core.getBoardedPlayerMass(bz[i])/1000,1).."t "end;system.print("Onboard: "..qp)return end;aQ.adjustAutopilotTargetIndex()elseif qh=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bz do core.forceDeboard(bz[i])end;a2="Deboarded All Passengers"return end;aQ.adjustAutopilotTargetIndex(1)elseif qh=="option3"then local function qq()aC=not aC;if not aC then bG("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bG("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local qp=""for i=1,#bA do qp=qp.."| ID: "..bA[i].." Mass: "..A(core.getDockedConstructMass(bA[i])/1000,1).."t "end;system.print("Docked Ships: "..qp)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;qq()toggleView=false elseif qh=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bA do core.forceUndock(bA[i])end;a2="Undocked all ships"return end;bp=nil;aR.ToggleAutopilot()elseif qh=="option5"then toggleView=false;aR.ToggleLockPitch()elseif qh=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local qr=shield_1.getVentingCooldown()if qr>0 then a2="Cannot vent again for "..qr.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aR.ToggleAltitudeHold()elseif qh=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif qh=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bG("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bG("gsOn","GS")end;toggleView=false elseif qh=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aR.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bG("gyOn","GA")else bG("gyOff","GA")end end;toggleView=false elseif qh=="lshift"then bw=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;aU=false;aT=false end elseif qh=="brake"then if BrakeToggleStatus or AltIsOn then aR.BrakeToggle()elseif not BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=true end elseif qh=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif qh=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif qh=="stopengines"then local function qs()if E-F<1.5 then bG("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bp=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;aV=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;qs()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aR.cmdThrottle(0)else aR.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aR.cmdCruise(AtmoSpeedLimit)else aR.cmdCruise(MaxGameVelocity*3.6)end end end elseif qh=="speedup"then bD()elseif qh=="speeddown"then bD(true)elseif qh=="antigravity"and not ExternalAGG then if antigrav~=nil then aR.ToggleAntigrav()end end end;function script.onActionStop(qh)local function qt()if not ExternalAGG and bh then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if qh=="forward"then T=0 elseif qh=="backward"then T=0 elseif qh=="left"then if bp then if bp==2 then bp=-2 else bp=-1 end end;W=0 elseif qh=="right"then if bp then if bp==4 then bp=-2 else bp=-1 end end;W=0 elseif qh=="yawright"then X=0 elseif qh=="yawleft"then X=0 elseif qh=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif qh=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif qh=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qh=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif qh=="groundaltitudeup"then qt()toggleView=false elseif qh=="groundaltitudedown"then qt()toggleView=false elseif qh=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then aU=false;aT=false end;a1=false elseif qh=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aR.BrakeToggle()else BrakeIsOn=false end end elseif qh=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(qh)local function qu(bE)local D=1;if bE then D=-1 end;if not ExternalAGG and bh then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then b2=b2+D*a5;if b2<planet.noAtmosphericDensityAltitude then b2=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function qv(bE)local D=1;if bE then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if qh=="groundaltitudeup"then if not a1 then qu()end elseif qh=="groundaltitudedown"then if not a1 then qu(true)end elseif qh=="speedup"then qv()elseif qh=="speeddown"then qv(true)end end;function script.onInputText(bW)local function qw(qx,e9,hu)local function qy(e9)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs='::pos{'..B..','..B..','..B..','..B..','..B..'}'local cG,cH,cN,cO,cP=o(e9,cs)if cG=="0"and cH=="0"then return vec3(z(cN),z(cO),z(cP))end;cO=math.rad(cO)cN=math.rad(cN)local planet=b[z(cG)][z(cH)]local dB=math.cos(cN)local qz=vec3(dB*math.cos(cO),dB*math.sin(cO),math.sin(cN))return planet.center+(planet.radius+cP)*qz end;local position=qy(e9)return aQ.AddNewLocation(qx,position,hu)end;local i;local qA,qB=nil,nil;local qC="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(bW," ")qA=bW;if i~=nil then qA=string.sub(bW,0,i-1)qB=string.sub(bW,i+1)end;if qA=="/help"or qA=="/commands"then for lp in string.gmatch(qC,"([^\n]+)")do system.print(lp)end;return elseif qA=="/setname"then if qB==nil or qB==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aQ.UpdatePosition(qB)else a2="Select a saved target to rename first"end elseif shield_1 and qA=="/resist"then if qB==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cs=B..', '..B..', '..B..', '..B;local qD,qE,qF,qG=o(qB,cs)if qG==nil or qD+qE+qF+qG>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(qD,qE,qF,qG)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif qA=="/addlocation"or string.find(bW,"::pos")~=nil then local hu=false;local qx="0-Temp"if qB==nil or qB==""then qB=qA;hu=true end;i=string.find(qB,"::")if not hu then qx=string.sub(qB,1,i-2)end;local e9=string.sub(qB,i)qw(qx,e9,hu)elseif qA=="/agg"then if qB==nil or qB==""then a2="Usage: /agg targetheight"return end;qB=z(qB)if qB<1000 then qB=1000 end;AntigravTargetAltitude=qB;a2="AGG Target Height set to "..qB elseif qA=="/G"then if qB==nil or qB==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if qB=="dump"then for cd,ce in pairs(bM())do if type(_G[ce])=="boolean"then if _G[ce]==true then system.print(ce.." true")else system.print(ce.." false")end elseif _G[ce]==nil then system.print(ce.." nil")else system.print(ce.." ".._G[ce])end end;return end;i=string.find(qB," ")local qH=string.sub(qB,0,i-1)local qI=string.sub(qB,i+1)for cd,ce in pairs(bM())do if ce==qH then a2="Variable "..qH.." changed to "..qI;local qJ=type(_G[ce])if qJ=="number"then qI=z(qI)if ce=="AtmoSpeedLimit"then aZ=qI end elseif qJ=="boolean"then if string.lower(qI)=="true"then qI=true else qI=false end end;_G[ce]=qI;return end end;a2="No such global variable: "..qH elseif qA=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aQ.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif qA=="/copydatabank"then if dbHud_2 then c9(true)else a2="Spare Databank required to copy databank"end elseif qA=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aR.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(cH)if bu[1]and not aq and not bn then unit.setTimer("contact",0.1)end end;function script.onLeave(cH)if bu[1]and CollisionSystem then if#bq>650 then cH=tostring(cH)bq[cH]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
