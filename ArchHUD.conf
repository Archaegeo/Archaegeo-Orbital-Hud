name: ArchHud - Archaegeo v0.013 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.013;useTheseSettings=false;userControlScheme="virtual joystick"soundFolder="archHUD"privateFile="name"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=false;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;ShouldCheckDamage=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AbandonedRadar=false;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;ECUHud=false;MaintainOrbit=true;saveableVariablesBoolean={userControlScheme={set=function(i)userControlScheme=i end,get=function()return userControlScheme end},soundFolder={set=function(i)soundFolder=i end,get=function()return soundFolder end},privateFile={set=function(i)privateFile=i end,get=function()return privateFile end},freeLookToggle={set=function(i)freeLookToggle=i end,get=function()return freeLookToggle end},BrakeToggleDefault={set=function(i)BrakeToggleDefault=i end,get=function()return BrakeToggleDefault end},RemoteFreeze={set=function(i)RemoteFreeze=i end,get=function()return RemoteFreeze end},brightHud={set=function(i)brightHud=i end,get=function()return brightHud end},RemoteHud={set=function(i)RemoteHud=i end,get=function()return RemoteHud end},VanillaRockets={set=function(i)VanillaRockets=i end,get=function()return VanillaRockets end},InvertMouse={set=function(i)InvertMouse=i end,get=function()return InvertMouse end},autoRollPreference={set=function(i)autoRollPreference=i end,get=function()return autoRollPreference end},ExternalAGG={set=function(i)ExternalAGG=i end,get=function()return ExternalAGG end},ShouldCheckDamage={set=function(i)ShouldCheckDamage=i end,get=function()return ShouldCheckDamage end},AtmoSpeedAssist={set=function(i)AtmoSpeedAssist=i end,get=function()return AtmoSpeedAssist end},ForceAlignment={set=function(i)ForceAlignment=i end,get=function()return ForceAlignment end},DisplayDeadZone={set=function(i)DisplayDeadZone=i end,get=function()return DisplayDeadZone end},showHud={set=function(i)showHud=i end,get=function()return showHud end},hideHudOnToggleWidgets={set=function(i)hideHudOnToggleWidgets=i end,get=function()return hideHudOnToggleWidgets end},ShiftShowsRemoteButtons={set=function(i)ShiftShowsRemoteButtons=i end,get=function()return ShiftShowsRemoteButtons end},SetWaypointOnExit={set=function(i)SetWaypointOnExit=i end,get=function()return SetWaypointOnExit end},AlwaysVSpd={set=function(i)AlwaysVSpd=i end,get=function()return AlwaysVSpd end},BarFuelDisplay={set=function(i)BarFuelDisplay=i end,get=function()return BarFuelDisplay end},voices={set=function(i)voices=i end,get=function()return voices end},alerts={set=function(i)alerts=i end,get=function()return alerts end},CollisionSystem={set=function(i)CollisionSystem=i end,get=function()return CollisionSystem end},AbandonedRadar={set=function(i)AbandonedRadar=i end,get=function()return AbandonedRadar end},AutoShieldToggle={set=function(i)AutoShieldToggle=i end,get=function()return AutoShieldToggle end},PreventPvP={set=function(i)PreventPvP=i end,get=function()return PreventPvP end},DisplayOdometer={set=function(i)DisplayOdometer=i end,get=function()return DisplayOdometer end},ECUHud={set=function(i)ECUHud=i end,get=function()return ECUHud end},MaintainOrbit={set=function(i)MaintainOrbit=i end,get=function()return MaintainOrbit end}}YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;LockPitchTarget=0;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.3;LowOrbitHeight=2000;AtmoSpeedLimit=1175;SpaceSpeedLimit=66000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=-1.00;AutopilotInterplanetaryThrottle=1.0;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;AutoShieldPercent=0;EmergencyWarp=0;DockingMode=1;savableVariablesHandling={YawStallAngle={set=function(i)YawStallAngle=i end,get=function()return YawStallAngle end},PitchStallAngle={set=function(i)PitchStallAngle=i end,get=function()return PitchStallAngle end},brakeLandingRate={set=function(i)brakeLandingRate=i end,get=function()return brakeLandingRate end},MaxPitch={set=function(i)MaxPitch=i end,get=function()return MaxPitch end},ReEntryPitch={set=function(i)ReEntryPitch=i end,get=function()return ReEntryPitch end},LockPitchTarget={set=function(i)LockPitchTarget=i end,get=function()return LockPitchTarget end},AutopilotSpaceDistance={set=function(i)AutopilotSpaceDistance=i end,get=function()return AutopilotSpaceDistance end},TargetOrbitRadius={set=function(i)TargetOrbitRadius=i end,get=function()return TargetOrbitRadius end},LowOrbitHeight={set=function(i)LowOrbitHeight=i end,get=function()return LowOrbitHeight end},AtmoSpeedLimit={set=function(i)AtmoSpeedLimit=i end,get=function()return AtmoSpeedLimit end},SpaceSpeedLimit={set=function(i)SpaceSpeedLimit=i end,get=function()return SpaceSpeedLimit end},AutoTakeoffAltitude={set=function(i)AutoTakeoffAltitude=i end,get=function()return AutoTakeoffAltitude end},TargetHoverHeight={set=function(i)TargetHoverHeight=i end,get=function()return TargetHoverHeight end},LandingGearGroundHeight={set=function(i)LandingGearGroundHeight=i end,get=function()return LandingGearGroundHeight end},ReEntryHeight={set=function(i)ReEntryHeight=i end,get=function()return ReEntryHeight end},MaxGameVelocity={set=function(i)MaxGameVelocity=i end,get=function()return MaxGameVelocity end},AutopilotInterplanetaryThrottle={set=function(i)AutopilotInterplanetaryThrottle=i end,get=function()return AutopilotInterplanetaryThrottle end},warmup={set=function(i)warmup=i end,get=function()return warmup end},fuelTankHandlingAtmo={set=function(i)fuelTankHandlingAtmo=i end,get=function()return fuelTankHandlingAtmo end},fuelTankHandlingSpace={set=function(i)fuelTankHandlingSpace=i end,get=function()return fuelTankHandlingSpace end},fuelTankHandlingRocket={set=function(i)fuelTankHandlingRocket=i end,get=function()return fuelTankHandlingRocket end},ContainerOptimization={set=function(i)ContainerOptimization=i end,get=function()return ContainerOptimization end},FuelTankOptimization={set=function(i)FuelTankOptimization=i end,get=function()return FuelTankOptimization end},AutoShieldPercent={set=function(i)AutoShieldPercent=i end,get=function()return AutoShieldPercent end},EmergencyWarp={set=function(i)EmergencyWarp=i end,get=function()return EmergencyWarp end},DockingMode={set=function(i)DockingMode=i end,get=function()return DockingMode end}}ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;radarX=1750;radarY=350;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=30;savableVariablesHud={ResolutionX={set=function(i)ResolutionX=i end,get=function()return ResolutionX end},ResolutionY={set=function(i)ResolutionY=i end,get=function()return ResolutionY end},circleRad={set=function(i)circleRad=i end,get=function()return circleRad end},SafeR={set=function(i)SafeR=i end,get=function()return SafeR end},SafeG={set=function(i)SafeG=i end,get=function()return SafeG end},SafeB={set=function(i)SafeB=i end,get=function()return SafeB end},PvPR={set=function(i)PvPR=i end,get=function()return PvPR end},PvPG={set=function(i)PvPG=i end,get=function()return PvPG end},PvPB={set=function(i)PvPB=i end,get=function()return PvPB end},centerX={set=function(i)centerX=i end,get=function()return centerX end},centerY={set=function(i)centerY=i end,get=function()return centerY end},throtPosX={set=function(i)throtPosX=i end,get=function()return throtPosX end},throtPosY={set=function(i)throtPosY=i end,get=function()return throtPosY end},vSpdMeterX={set=function(i)vSpdMeterX=i end,get=function()return vSpdMeterX end},vSpdMeterY={set=function(i)vSpdMeterY=i end,get=function()return vSpdMeterY end},altMeterX={set=function(i)altMeterX=i end,get=function()return altMeterX end},altMeterY={set=function(i)altMeterY=i end,get=function()return altMeterY end},fuelX={set=function(i)fuelX=i end,get=function()return fuelX end},fuelY={set=function(i)fuelY=i end,get=function()return fuelY end},shieldX={set=function(i)shieldX=i end,get=function()return shieldX end},shieldY={set=function(i)shieldY=i end,get=function()return shieldY end},radarX={set=function(i)radarX=i end,get=function()return radarX end},radarY={set=function(i)radarY=i end,get=function()return radarY end},DeadZone={set=function(i)DeadZone=i end,get=function()return DeadZone end},OrbitMapSize={set=function(i)OrbitMapSize=i end,get=function()return OrbitMapSize end},OrbitMapX={set=function(i)OrbitMapX=i end,get=function()return OrbitMapX end},OrbitMapY={set=function(i)OrbitMapY=i end,get=function()return OrbitMapY end}}speedChangeLarge=5.0;speedChangeSmall=1.0;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;hudTickRate=0.0666667;ExtraEscapeThrust=1.0;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"allowedHorizontalDrift=0.05;savableVariablesPhysics={speedChangeLarge={set=function(i)speedChangeLarge=i end,get=function()return speedChangeLarge end},speedChangeSmall={set=function(i)speedChangeSmall=i end,get=function()return speedChangeSmall end},MouseXSensitivity={set=function(i)MouseXSensitivity=i end,get=function()return MouseXSensitivity end},MouseYSensitivity={set=function(i)MouseYSensitivity=i end,get=function()return MouseYSensitivity end},autoRollFactor={set=function(i)autoRollFactor=i end,get=function()return autoRollFactor end},rollSpeedFactor={set=function(i)rollSpeedFactor=i end,get=function()return rollSpeedFactor end},autoRollRollThreshold={set=function(i)autoRollRollThreshold=i end,get=function()return autoRollRollThreshold end},minRollVelocity={set=function(i)minRollVelocity=i end,get=function()return minRollVelocity end},TrajectoryAlignmentStrength={set=function(i)TrajectoryAlignmentStrength=i end,get=function()return TrajectoryAlignmentStrength end},torqueFactor={set=function(i)torqueFactor=i end,get=function()return torqueFactor end},pitchSpeedFactor={set=function(i)pitchSpeedFactor=i end,get=function()return pitchSpeedFactor end},yawSpeedFactor={set=function(i)yawSpeedFactor=i end,get=function()return yawSpeedFactor end},brakeSpeedFactor={set=function(i)brakeSpeedFactor=i end,get=function()return brakeSpeedFactor end},brakeFlatFactor={set=function(i)brakeFlatFactor=i end,get=function()return brakeFlatFactor end},DampingMultiplier={set=function(i)DampingMultiplier=i end,get=function()return DampingMultiplier end},hudTickRate={set=function(i)hudTickRate=i end,get=function()return hudTickRate end},ExtraEscapeThrust={set=function(i)ExtraEscapeThrust=i end,get=function()return ExtraEscapeThrust end},ExtraLongitudeTags={set=function(i)ExtraLongitudeTags=i end,get=function()return ExtraLongitudeTags end},ExtraLateralTags={set=function(i)ExtraLateralTags=i end,get=function()return ExtraLateralTags end},ExtraVerticalTags={set=function(i)ExtraVerticalTags=i end,get=function()return ExtraVerticalTags end},allowedHorizontalDrift={set=function(i)allowedHorizontalDrift=i end,get=function()return allowedHorizontalDrift end}}BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;saveRoute={}apRoute={}ecuThrottle={}HoverMode=false;autoVariables={VertTakeOff={set=function(i)VertTakeOff=i end,get=function()return VertTakeOff end},VertTakeOffEngine={set=function(i)VertTakeOffEngine=i end,get=function()return VertTakeOffEngine end},SpaceTarget={set=function(i)SpaceTarget=i end,get=function()return SpaceTarget end},BrakeToggleStatus={set=function(i)BrakeToggleStatus=i end,get=function()return BrakeToggleStatus end},BrakeIsOn={set=function(i)BrakeIsOn=i end,get=function()return BrakeIsOn end},RetrogradeIsOn={set=function(i)RetrogradeIsOn=i end,get=function()return RetrogradeIsOn end},ProgradeIsOn={set=function(i)ProgradeIsOn=i end,get=function()return ProgradeIsOn end},Autopilot={set=function(i)Autopilot=i end,get=function()return Autopilot end},TurnBurn={set=function(i)TurnBurn=i end,get=function()return TurnBurn end},AltitudeHold={set=function(i)AltitudeHold=i end,get=function()return AltitudeHold end},BrakeLanding={set=function(i)BrakeLanding=i end,get=function()return BrakeLanding end},Reentry={set=function(i)Reentry=i end,get=function()return Reentry end},AutoTakeoff={set=function(i)AutoTakeoff=i end,get=function()return AutoTakeoff end},HoldAltitude={set=function(i)HoldAltitude=i end,get=function()return HoldAltitude end},AutopilotAccelerating={set=function(i)AutopilotAccelerating=i end,get=function()return AutopilotAccelerating end},AutopilotBraking={set=function(i)AutopilotBraking=i end,get=function()return AutopilotBraking end},AutopilotCruising={set=function(i)AutopilotCruising=i end,get=function()return AutopilotCruising end},AutopilotRealigned={set=function(i)AutopilotRealigned=i end,get=function()return AutopilotRealigned end},AutopilotEndSpeed={set=function(i)AutopilotEndSpeed=i end,get=function()return AutopilotEndSpeed end},AutopilotStatus={set=function(i)AutopilotStatus=i end,get=function()return AutopilotStatus end},AutopilotPlanetGravity={set=function(i)AutopilotPlanetGravity=i end,get=function()return AutopilotPlanetGravity end},PrevViewLock={set=function(i)PrevViewLock=i end,get=function()return PrevViewLock end},AutopilotTargetName={set=function(i)AutopilotTargetName=i end,get=function()return AutopilotTargetName end},AutopilotTargetCoords={set=function(i)AutopilotTargetCoords=i end,get=function()return AutopilotTargetCoords end},AutopilotTargetIndex={set=function(i)AutopilotTargetIndex=i end,get=function()return AutopilotTargetIndex end},TotalDistanceTravelled={set=function(i)TotalDistanceTravelled=i end,get=function()return TotalDistanceTravelled end},TotalFlightTime={set=function(i)TotalFlightTime=i end,get=function()return TotalFlightTime end},SavedLocations={set=function(i)SavedLocations=i end,get=function()return SavedLocations end},VectorToTarget={set=function(i)VectorToTarget=i end,get=function()return VectorToTarget end},LocationIndex={set=function(i)LocationIndex=i end,get=function()return LocationIndex end},LastMaxBrake={set=function(i)LastMaxBrake=i end,get=function()return LastMaxBrake end},LockPitch={set=function(i)LockPitch=i end,get=function()return LockPitch end},LastMaxBrakeInAtmo={set=function(i)LastMaxBrakeInAtmo=i end,get=function()return LastMaxBrakeInAtmo end},AntigravTargetAltitude={set=function(i)AntigravTargetAltitude=i end,get=function()return AntigravTargetAltitude end},LastStartTime={set=function(i)LastStartTime=i end,get=function()return LastStartTime end},iphCondition={set=function(i)iphCondition=i end,get=function()return iphCondition end},stablized={set=function(i)stablized=i end,get=function()return stablized end},UseExtra={set=function(i)UseExtra=i end,get=function()return UseExtra end},SelectedTab={set=function(i)SelectedTab=i end,get=function()return SelectedTab end},saveRoute={set=function(i)saveRoute=i end,get=function()return saveRoute end},apRoute={set=function(i)apRoute=i end,get=function()return apRoute end},ecuThrottle={set=function(i)ecuThrottle=i end,get=function()return ecuThrottle end},HoverMode={set=function(i)HoverMode=i end,get=function()return HoverMode end}}local function f(b,c,g,h,j)local a=DUSystem;local k=DUConstruct;time=g()PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;hasGear=false;pitchInput=0;rollInput=0;yawInput=0;upAmount=0;followMode=false;holdingShift=false;leftmouseclick=false;msgText="empty"msgTimer=3;isBoosting=false;brakeDistance=0;brakeTime=0;autopilotTargetPlanet=nil;simulatedX=0;simulatedY=0;distance=0;spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;inAtmo=j()>0;atmosDensity=j()coreAltitude=b.getAltitude()coreMass=DUConstruct.getMass()gyroIsOn=nil;atmoTanks={}spaceTanks={}rocketTanks={}galaxyReference=nil;Kinematic=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;CONTROL=nil;SHIELD=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;stalling=false;adjustedAtmoSpeedLimit=AtmoSpeedLimit;orbitMsg=nil;OrbitTargetOrbit=0;OrbitAchieved=false;SpaceEngineVertDn=false;SpaceEngines=false;constructForward=vec3(k.getWorldOrientationForward())constructRight=vec3(k.getWorldOrientationRight())coreVelocity=vec3(k.getVelocity())constructVelocity=vec3(k.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(b.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(k.getWorldPosition())UpVertAtmoEngine=false;antigravOn=false;throttleMode=true;adjustedPitch=0;adjustedRoll=0;AtlasOrdered={}notPvPZone=false;pvpDist=50000;ReversalIsOn=nil;nearPlanet=c.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;apButtonsHovered=false;apScrollIndex=0;passengers={}ships={}planetAtlas={}scopeFOV=90;oldShowHud=showHud;ThrottleValue=nil;radarPanelID=nil;privatelocations={}customlocations={}apBrk=false;alignHeading=nil;mouseDistance=0;sEFC=false;MaxSpeed=k.getMaxSpeed()if shield then shieldPercent=h(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function p(l)a.print(time..": "..l)end;local function m(d,b,c,a,n,o,q,r,s)local function t(u)return type(u)=='number'end;local function v(u)return type(q(u))=='number'end;local function w(x)return type(x)=='table'end;local function y(a)return type(a)=='string'end;local function z(A)return w(A)and t(A.x and A.y and A.z)end;local function B(C)return w(C)and t(C.latitude and C.longitude and C.altitude and C.id and C.systemId)end;local D=math.pi/180;local E=180/math.pi;local epsilon=1e-10;local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G='::pos{'..F..','..F..','..F..','..F..','..F..'}'local utils=utils;local vec3=vec3;local function H(u)local I=string.gsub(string.reverse(n('%.4f',u)),'^0*%.?','')return I==''and'0'or string.reverse(I)end;local function J(K)if z(K)then return n('{x=%.3f,y=%.3f,z=%.3f}',K.x,K.y,K.z)end;if w(K)and not getmetatable(K)then local L={}local M=next(K)if type(M)=='nil'or M==1 then L=K else for N,A in pairs(K)do local O=J(A)if type(N)=='number'then table.insert(L,n('[%s]=%s',N,O))else table.insert(L,n('%s=%s',N,O))end end end;return n('{%s}',table.concat(L,','))end;if y(K)then return n("'%s'",K:gsub("'",[[\']]))end;return tostring(K)end;local P={}P.__index=P;P.__tostring=function(K,Q)local R={}for N in pairs(K)do table.insert(R,N)end;table.sort(R)local L={}for _,N in ipairs(R)do local O=J(K[N])if type(N)=='number'then table.insert(L,n('[%s]=%s',N,O))else table.insert(L,n('%s=%s',N,O))end end;if Q then return n('%s%s',Q,table.concat(L,',\n'..Q))end;return n('{%s}',table.concat(L,','))end;P.__eq=function(S,T)return S.systemId==T.systemId and S.id==T.id and s(S.radius,T.radius)and s(S.center.x,T.center.x)and s(S.center.y,T.center.y)and s(S.center.z,T.center.z)and s(S.GM,T.GM)end;local function U(V,W,X,Y,Z)assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(X),'Argument 3 (radius) must be a number:'..type(X))assert(w(Y),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(Y))assert(v(Z),'Argument 5 (GM) must be a number:'..type(Z))return setmetatable({systemId=q(V),id=q(W),radius=q(X),center=vec3(Y),GM=q(Z)},P)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return n('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,H(p.latitude*E),H(p.longitude*E),H(p.altitude))end;MapPosition.__eq=function(S,T)return S.id==T.id and S.systemId==T.systemId and s(S.latitude,T.latitude)and s(S.altitude,T.altitude)and(s(S.longitude,T.longitude)or s(S.latitude,math.pi/2)or s(S.latitude,-math.pi/2))end;local function a0(a1,W,a2,a3,a4)local V=a1;if y(a1)and not a3 and not a4 and not W and not a2 then V,W,a2,a3,a4=stringmatch(a1,G)assert(V,'Argument 1 (position string) is malformed.')else assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(a2),'Argument 3 (latitude) must be in degrees:'..type(a2))assert(v(a3),'Argument 4 (longitude) must be in degrees:'..type(a3))assert(v(a4),'Argument 5 (altitude) must be in meters:'..type(a4))end;V=q(V)W=q(W)a2=q(a2)a3=q(a3)a4=q(a4)if W==0 then return setmetatable({latitude=a2,longitude=a3,altitude=a4,id=W,systemId=V},MapPosition)end;return setmetatable({latitude=D*o(a2,-90,90),longitude=D*(a3%360),altitude=a4,id=W,systemId=V},MapPosition)end;local a5={}a5.__index=a5;a5.__tostring=function(K,Q)local a6=Q and Q..'  'local a7={}local R={}for N in pairs(K)do table.insert(R,N)end;table.sort(R)for _,a8 in ipairs(R)do bdy=K[a8]local a9=P.__tostring(bdy,a6)if Q then table.insert(a7,n('[%s]={\n%s\n%s}',a8,a9,Q))else table.insert(a7,n('  [%s]=%s',a8,a9))end end;if Q then return n('\n%s%s%s',Q,table.concat(a7,',\n'..Q),Q)end;return n('{\n%s\n}',table.concat(a7,',\n'))end;local function aa(ab)local e={}local pid;for _,A in pairs(ab)do local W=A.planetarySystemId;if type(W)~='number'then error('Invalid planetary s ID: '..tostring(W))elseif pid and W~=pid then error('Mistringmatch planetary s IDs: '..W..' and '..pid)end;local ac=A.bodyId;if type(ac)~='number'then error('Invalid body ID: '..tostring(ac))elseif e[ac]then error('Duplicate body ID: '..tostring(ac))end;setmetatable(A.center,getmetatable(vec3.unit_x))e[ac]=setmetatable(A,P)pid=W end;return setmetatable(e,a5)end;PlanetaryReference={}local function ad(ab)return setmetatable({galaxyAtlas=ab or{}},PlanetaryReference)end;PlanetaryReference.__index=function(x,i)if type(i)=='number'then local a=x.galaxyAtlas[i]return aa(a)end;return rawget(PlanetaryReference,i)end;PlanetaryReference.__pairs=function(K)return function(x,N)local ae,nv=next(x,N)return ae,nv and aa(nv)end,K.galaxyAtlas,nil end;PlanetaryReference.__tostring=function(K)local af={}for _,ag in pairs(K or{})do local ah=ag:getPlanetarySystemId()local ai=a5.__tostring(ag,'    ')table.insert(af,n('  [%s]={%s\n  }',ah,ai))end;return n('{\n%s\n}\n',table.concat(af,',\n'))end;PlanetaryReference.BodyParameters=U;PlanetaryReference.MapPosition=a0;PlanetaryReference.PlanetarySystem=aa;function PlanetaryReference.createBodyParameters(V,W,aj,ak,al,am,an)assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(aj),'Argument 3 (surfaceArea) must be a number:'..type(aj))assert(w(ak),'Argument 4 (aPosition) must be an array or vec3:'..type(ak))assert(w(al),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(al))assert(v(am),'Argument 6 (altitude) must be in meters:'..type(am))assert(v(an),'Argument 7 (gravityAtPosition) must be number:'..type(an))local X=r(aj/4/math.pi)local distance=X+am;local ao=vec3(ak)+distance*vec3(al)local Z=an*distance*distance;return U(V,W,X,ao,Z)end;PlanetaryReference.isMapPosition=B;function PlanetaryReference:getPlanetarySystem(a1)if i==nil then i=0 end;if nv==nil then nv=0 end;local V=a1;if B(a1)then V=a1.systemId end;if type(V)=='number'then local a=self.galaxyAtlas[i]if a then if getmetatable(nv)~=a5 then a=aa(a)end;return a end end end;function a5:sizeCalculator(ap)return 1.05*ap.radius end;function a5:castIntersections(aq,ar,as,at,au,av)local aw={}if au then for _,ap in pairs(au)do table.insert(aw,ap)end else aw=planetAtlas end;if not av then table.sort(aw,function(ax,ay)local az=ax.center;local aA=ay.center;return(az.x-aq.x)^2+(az.y-aq.y)^2+(az.z-aq.z)^2<(aA.x-aq.x)^2+(aA.y-aq.y)^2+(aA.z-aq.z)^2 end)end;local aB=ar:normalize()for _,ap in ipairs(aw)do local aC=ap.center-aq;local X;if as then X=as(ap)else X=self:sizeCalculator(ap)end;local aD=aC:dot(aB)local aE=aD^2-(aC:len2()-X^2)if aE>=0 then local aF=r(aE)local aG=aD+aF;local aH=aD-aF;if aH>0 then return ap,aG,aH elseif aG>0 then return ap,aG,nil end end end;return nil,nil,nil end;function a5:closestBody(aI)assert(type(aI)=='table','Invalid coordinates.')local aJ,ap;local aK=vec3(aI)for _,aL in pairs(self)do local aM=(aL.center-aK):len2()if(not ap or aM<aJ)and aL.name~="Space"then ap=aL;aJ=aM end end;return ap end;function a5:convertToBodyIdAndWorldCoordinates(a1)local aN=a1;if y(a1)then aN=a0(a1)end;if aN.id==0 then return 0,vec3(aN.latitude,aN.longitude,aN.altitude)end;local aL=self:getBodyParameters(aN)if aL then return aN.id,aL:convertToWorldCoordinates(aN)end end;function a5:getBodyParameters(a1)local W=a1;if B(a1)then W=a1.id end;assert(v(W),'Argument 1 (id) must be a number:'..type(W))return self[W]end;function a5:getPlanetarySystemId()local _,A=next(self)return A and A.systemId end;function P:convertToMapPosition(Y)assert(w(Y),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(Y))local aO=vec3(Y)if self.id==0 then return setmetatable({latitude=aO.x,longitude=aO.y,altitude=aO.z,id=0,systemId=self.systemId},MapPosition)end;local aP=aO-self.center;local distance=aP:len()local a4=distance-self.radius;local a2=0;local a3=0;if not s(distance,0)then local aQ=atan(aP.y,aP.x)a3=aQ>=0 and aQ or 2*math.pi+aQ;a2=math.pi/2-math.acos(aP.z/distance)end;return setmetatable({latitude=a2,longitude=a3,altitude=a4,id=self.id,systemId=self.systemId},MapPosition)end;function P:convertToWorldCoordinates(a1)local aN=y(a1)and a0(a1)or a1;if aN.id==0 then return vec3(aN.latitude,aN.longitude,aN.altitude)end;assert(B(aN),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(aN.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(aN.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local aR=math.cos(aN.latitude)return self.center+(self.radius+aN.altitude)*vec3(aR*math.cos(aN.longitude),aR*math.sin(aN.longitude),math.sin(aN.latitude))end;function P:getAltitude(Y)return(vec3(Y)-self.center):len()-self.radius end;function P:getDistance(Y)return(vec3(Y)-self.center):len()end;function P:getGravity(Y)local aS=self.center-vec3(Y)local aT=aS:len2()return self.GM/aT*aS/r(aT)end;return setmetatable(PlanetaryReference,{__call=function(_,...)return ad(...)end})end;local function aU(d,b,c,a,r,aV)local Kinematic={}local aW=100;function Kinematic.computeAccelerationTime(aX,aY,aZ)return(aZ-aX)/aY end;function Kinematic.computeDistanceAndTime(aX,aZ,a_,b0,b1,b2)b1=b1 or 0;b2=b2 or 0;local b3=aX<aZ;local b4=b0/(b3 and a_ or-a_)local b5=-b2/a_;local b6=b4+b5;if aX==aZ then return 0,0 elseif b3 and b6<=0 or not b3 and b6>=0 then return-1,-1 end;local b7,b8=0,0;if b4~=0 and b1>0 then local b9=math.pi/b1/2;local A=function(x)return b4*(x/2-b1*math.sin(b9*x)/math.pi)+b5*x+aX end;local ba=b3 and function(a)return a>=aZ end or function(a)return a<=aZ end;b8=2*b1;if ba(A(b8))then local bb=0;while math.abs(b8-bb)>0.25 do local x=(b8+bb)/2;if ba(A(x))then b8=x else bb=x end end end;local bc=2*b4*b1^2/math.pi^2;b7=bc*(math.cos(b9*b8)-1)+(b4+2*b5)*b8^2/4+aX*b8;if b8<2*b1 then return b7,b8 end;aX=A(b8)end;local az=b4+b5;local x=Kinematic.computeAccelerationTime(aX,az,aZ)local bd=aX*x+az*x*x/2;return b7+bd,b8+x end;function Kinematic.computeTravelTime(aX,aY,distance)if distance==0 then return 0 end;if aY~=0 then return(math.sqrt(2*aY*distance+aX^2)-aX)/aY end;assert(aX>0,'Acceleration and initial speed are both zero.')return distance/aX end;return Kinematic end;local function be(d,b,c,a,n,o,q,r,s)local vec3=vec3;local m=m(d,b,c,a,n,o,q,r,s)local function y(a)return type(a)=='string'end;local function w(x)return type(x)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(a4)assert(self.body)local distance=a4+self.body.radius;if not s(distance,0)then local orbit=r(self.body.GM/distance)return r(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(a1,bf)assert(self.body)assert(w(a1)or y(a1))assert(w(bf))local bg=(y(a1)or m.isMapPosition(a1))and self.body:convertToWorldCoordinates(a1)or vec3(a1)local A=vec3(bf)local bh=bg-self.body.center;local bi=A:len2()local bd=bh:len()local bj=self.body.GM;local bk=((bi-bj/bd)*bh-bh:dot(A)*A)/bj;local az=bj/(2*bj/bd-bi)local bl=bk:len()local aB=bk:normalize()local bm=az*(1-bl)local bn=az*(1+bl)local bo=bm*aB+self.body.center;local bp=bl<=1 and-bn*aB+self.body.center or nil;local bq=r(az*bj*(1-bl*bl))local br=bp and 2*math.pi*r(az^3/bj)local bs=math.acos(bk:dot(bh)/(bl*bd))if bh:dot(A)<0 then bs=-(bs-2*math.pi)end;local bt=math.acos((math.cos(bs)+bl)/(1+bl*math.cos(bs)))local bu=bt;if bu<0 then bu=bu+2*math.pi end;local bv=bu-bl*math.sin(bu)local bw=0;local bx=0;local by=0;if br~=nil then bw=bv/(2*math.pi/br)bx=br-bw;by=bx+br/2;if bs-math.pi>0 then bx=bw;by=bx+br/2 end;if by>br then by=by-br end end;return{periapsis={position=bo,speed=bq/bm,circularOrbitSpeed=r(bj/bm),altitude=bm-self.body.radius},apoapsis=bp and{position=bp,speed=bq/bn,circularOrbitSpeed=r(bj/bn),altitude=bn-self.body.radius},currentVelocity=A,currentPosition=bg,eccentricity=bl,period=br,eccentricAnomaly=bt,meanAnomaly=bv,timeToPeriapsis=bx,timeToApoapsis=by,trueAnomaly=bs}end;local function bz(bA)local aL=m.BodyParameters(bA.systemId,bA.id,bA.radius,bA.center,bA.GM)return setmetatable({body=aL},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return bz(...)end})end;local function bB(d,b,c,a,dbHud_1,e,bC,bD,h,q,r,bE,bF,l)local function bG(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=e[0][0]end;return p end;local function bH()local function bI(bJ,bK)return bJ.name<bK.name end;AtlasOrdered={}for N,A in pairs(e[0])do AtlasOrdered[#AtlasOrdered+1]={name=A.name,index=N}end;table.sort(AtlasOrdered,bI)end;local function bL(bM,bN)if not bN then bN=CustomTarget.name end;for N,A in pairs(bM)do if A.name and A.name==bN then return N end end;return-1 end;local function bO()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local bP=AtlasOrdered[AutopilotTargetIndex].index;local bQ=e[0][bP]if bQ.center then AutopilotTargetName=bQ.name;autopilotTargetPlanet=galaxyReference[0][bP]if CustomTarget~=nil then if atmosDensity==0 then if bC(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if bC(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if bC(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then bD(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if bC(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if bC(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if bC(widgetMaxMassText,widgetMaxMass)~=1 then bD(widgetMaxMassText,widgetMaxMass)end;if bC(widgetTravelTimeText,widgetTravelTime)~=1 then bD(widgetTravelTimeText,widgetTravelTime)end;if bC(widgetTargetOrbitText,widgetTargetOrbit)~=1 then bD(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=bQ;for _,A in pairs(galaxyReference[0])do if A.name==CustomTarget.planetname then autopilotTargetPlanet=A;AutopilotTargetName=CustomTarget.name;break end end;if bC(widgetMaxMassText,widgetMaxMass)~=1 then bD(widgetMaxMassText,widgetMaxMass)end;if bC(widgetTravelTimeText,widgetTravelTime)~=1 then bD(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=h(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=h(LowOrbitHeight+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function bR(bS)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then if bS==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then bO()else local bP=AtlasOrdered[AutopilotTargetIndex].index;local bQ=e[0][bP]if bQ and(bQ~=nil and bQ.name=="Space"or iphCondition=="Custom Only"and bQ.center or iphCondition=="No Moons-Asteroids"and(string.find(bQ.name,"Moon")~=nil or string.find(bQ.name,"Asteroid")~=nil))then if bS==nil then bR()else bR(1)end else bO()end end else l("Disengage autopilot before changing Interplanetary Helper")bE("iph","AP")end end;local function bT()local function bU(bV)local positions;if bV then positions=privatelocations else positions=SavedLocations end;local bW=-1;bW=bL(e[0])if bW>-1 then table.remove(e[0],bW)end;bW=-1;bW=bL(positions)if bW~=-1 then l(CustomTarget.name.." saved location cleared")table.remove(positions,bW)end;bR()bH()return positions end;if string.sub(AutopilotTargetName,1,1)=="*"then privatelocations=bU(true)else SavedLocations=bU(false)end end;local function bX(bY,position,bZ,b_)local function c0(bV)if bV then positions=privatelocations else positions=SavedLocations end;if dbHud_1 or bZ or bV then local p=bG(position)local c1={position=position,name=bY,planetname=p.name,gravity=b.getGravityIntensity(),safe=b_}if not bZ then positions[#positions+1]=c1 else for N,A in pairs(e[0])do if A.name and bY==A.name then table.remove(e[0],N)end end end;table.insert(e[0],c1)bH()bO()l("Location saved as "..bY.."("..p.name..")")return positions else l("Databank must be installed to save permanent locations")end end;if string.sub(bY,1,1)=="*"then privatelocations=c0(true)else SavedLocations=c0(false)end end;local c2={}function c2.UpdateAtlasLocationsList()bH()end;function c2.UpdateAutopilotTarget()bO()end;function c2.adjustAutopilotTargetIndex(bS)bR(bS)end;function c2.findAtlasIndex(bM,bN)return bL(bM,bN)end;function c2.UpdatePosition(c3,c4,c5)local function c6(bV)local positions;if bV then positions=privatelocations else positions=SavedLocations end;local bW=bL(positions)if bW~=-1 then if c3~=nil then if bV then c3="*"..c3 end;positions[bW].name=c3;AutopilotTargetIndex=AutopilotTargetIndex-1;bR()elseif c5~=nil then if c5 then local c7=coreAltitude;if c7<1000 then c7=1000 end;positions[bW].agg=bF(c7,0)l(positions[bW].name.." AGG Altitude:"..positions[bW].agg.." saved ("..positions[bW].planetname..")")return elseif c5==false then positions[bW].agg=nil;l(positions[bW].name.." AGG Altitude cleared ("..positions[bW].planetname..")")return end else local c8=positions[bW]if c4 then c8.heading=constructRight:cross(worldVertical)*5000;l(positions[bW].name.." heading saved ("..positions[bW].planetname..")")return elseif c4==false then c8.heading=nil;l(positions[bW].name.." heading cleared ("..positions[bW].planetname..")")return end;c8.gravity=b.getGravityIntensity()c8.position=worldPos;c8.safe=true end;l(positions[bW].name.." position updated ("..positions[bW].planetname..")")else l("Name Not Found")end end;if string.sub(AutopilotTargetName,1,1)=="*"then c6(true)else c6(false)end end;function c2.AddNewLocation(bY,position,bZ,b_)bX(bY,position,bZ,b_)end;function c2.ClearCurrentPosition()bT()end;for N,A in pairs(customlocations)do table.insert(e[0],A)end;if userAtlas then for N,A in pairs(userAtlas)do c2[N]=A end end;bH()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;c2.UpdateAutopilotTarget()return c2 end;local function c9(b,a,c,radar_1,radar_2,warpdrive,aV,ca,r,cb,q,cc,bE,l)local cd={}local ce={}local cf={XS=13,S=27,M=55,L=110,XL=221}local cg={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local ch={}local ci=0;local cj;local ck;local cl=0;local cm;local cn={cm}local co="Atmo"local cp;local cq;local cr=0;local cs={}local ct;local cu=0;local cv=table.insert;local cw=-4;local cx={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local cy,cz;local cA,cB;local cC;local cD;local cE;local cF;local cG;local cH;local cI;local function cJ()if radarPanelId~=nil and cr==0 then ca(radarPanelId)a.destroyWidget(cy)a.destroyData(cA)cy,cA,radarPanelId=nil,nil,nil;if cq~=nil then ca(cq)a.destroyWidget(cz)a.destroyData(cB)cq,cz,cB=nil,nil,nil end else if cr==1 then cq=a.createWidgetPanel("PeriWinkle")cz=a.createWidget(cq,'periscope')cB=cm.getWidgetDataId()a.addDataToWidget(cB,cz)end;if radarPanelId==nil and ci>0 then radarPanelId=a.createWidgetPanel(co)cy=a.createWidget(radarPanelId,'radar')cA=cm.getWidgetDataId()a.addDataToWidget(cA,cy)end;cr=0 end end;local function cK()local function cL(cM,cN,cO,cP,cQ,cR,cS,cT)cN,cP,cR,cT=vec3(cN),vec3(cP),vec3(cR),vec3(cT)local cU,cV,cW=cM*cM,cO*cO,cQ*cQ;local bi=cP-cN;local cX=bi:normalize()local cY=bi:len()local cZ=cR-cN;local c_=(cZ-cZ:project_on(cX)):normalize()local d0,d1=cZ:dot(cX),cZ:dot(c_)local d2=d0*d0+d1*d1;local d3=cX:cross(c_)local d4=(cU-cV+cY*cY)/(2*cY)local d5=(cU-cW+d2-2*d0*d4)/(2*d1)local C=cU-d4^2-d5^2;local d6=r(C)local d7=cN+cX*d4+c_*d5+d3*d6;local d8=cN+cX*d4+c_*d5-d3*d6;if aV((cT-d7):len()-cS)<aV((cT-d8):len()-cS)then return d7 else return d8 end end;local function d9(da,bd,db)local dc=da.pts;local bW=#dc;local dd=da.ref;if bW>3 then local de,df,dg,dh=dc[bW],dc[bW-1],dc[bW-2],dc[bW-3]da.ref=db;local bg=cL(de[1],de[2],df[1],df[2],dg[1],dg[2],dh[1],dh[2])local d4,d5,d6=bg.x,bg.y,bg.z;if d4==d4 and d5==d5 and d6==d6 then d4=d4+dd[1]d5=d5+dd[2]d6=d6+dd[3]local di=vec3(d4,d5,d6)da.center=di;if da.lastPos then if(da.lastPos-di):len()<2 then local dj=(di-vec3(db)):len()if aV(dj-bd)<10 then da.skipCalc=true end end end;da.lastPos=di end;da.pts={}else local dk={db[1]-dd[1],db[2]-dd[2],db[3]-dd[3]}dc[bW+1]={bd,dk}end end;if radar_1 or radar_2 then RADAR.assignRadar()end;if cm then if#ct>0 then local dl,dm=0,0;local dn=velMag*10;local nearPlanet=nearPlanet;cl,ck=0,0;ce={}for _,A in pairs(ct)do local distance=cG(A)if distance>0.0 then if cC(A)==1 then cv(ce,A)end;if not notPvPZone and warpdrive and distance<EmergencyWarp and warpdrive.getStatus()==15 then l("INITIATING WARP")msgTimer=7;warpdrive.initiate()end;local dp=AbandonedRadar and cE(A)==1;if CollisionSystem or dp then local dq=cH(A)local dr=cf[dq]local ds=cD(A)if dp or distance<dn and(dr>27 or ds==4 or ds==6)then cl=cl+1;local db={worldPos["x"],worldPos["y"],worldPos["z"]}local da=cs[A]if da==nil then dr=dr+cc;cs[A]={pts={},ref=db,name=cF(A),i=0,radius=dr,skipCalc=false}da=cs[A]end;if not da.skipCalc then if dp or ds==4 or ds==6 then da.center=vec3(cI(A))da.skipCalc=true else d9(da,distance,db)dm=dm+1 end;if dp and not da.abandoned then local time=a.getArkTime()if cu+5<time then cu=time;bE("abRdr","RD")end;a.print("Abandoned Construct: "..da.name.." ("..dq.." "..cg[ds]..") at ::pos{0,0,"..da.center.x..","..da.center.y..","..da.center.z.."}")l("Abandoned Radar Contact ("..dq.." "..cg[ds]..") detected")da.abandoned=true end else cv(ch,da)end end;dl=dl+1;if dl>300 or dm>30 then coroutine.yield()dl,dm=0,0 end end end end;ck=#ch;if ck>0 and(velMag>20 or BrakeLanding)then local ap,dt,du,dv;local dw=0;local dx=galaxyReference:getPlanetarySystem(0)dv=constructVelocity:normalize()while dw<ck do coroutine.yield()local dy={table.unpack(ch,dw,math.min(dw+75,ck))}ap,dt,du=dx:castIntersections(worldPos,dv,nil,nil,dy,true)if ap and du then collisionTarget={ap,dt,du}break end;dw=dw+75 end;if not ap then collisionTarget=nil end else collisionTarget=nil end;ch={}cj=cm.getTargetId()end end end;local function dz()if cm then co="Atmo"if string.find(cm.getName(),"Space")then co="Space"end end end;function cd.pickType()dz()end;function cd.assignRadar()if radar_2 and cw~=1 then if cw==-1 then if cm==radar_2 then cm=radar_1 else cm=radar_2 end end;cn={cm}cC=cm.hasMatchingTransponder;cD=cm.getConstructKind;cE=cm.isConstructAbandoned;cF=cm.getConstructName;cG=cm.getConstructDistance;cH=cm.getConstructCoreSize;cI=cm.getConstructWorldPos;ct=cm.getConstructIds()dz()else ct=cm.getConstructIds()end;cw=cm.getOperationalState()end;function cd.UpdateRadar()local dA=coroutine.status(cp)if dA=="suspended"then local O,dB=coroutine.resume(cp)if dB then a.print("ERROR UPDATE RADAR: "..dB)end elseif dA=="dead"then cp=coroutine.create(cK)local O,dB=coroutine.resume(cp)end end;function cd.GetRadarHud(dC,dD,radarX,radarY)local dE,l;local F=ck or 0;ci=#ct;if ci>0 then if CollisionSystem then l=F.."/"..cl.." Known/InRange : "..ci.." Total"else l="Radar Contacts: "..ci end;dE=cb(radarX,radarY,l,"pbright txtbig txtmid")if#ce>0 then dE=dE..cb(dC,dD,"Friendlies In Range","pbright txtbig txtmid")for N,A in pairs(ce)do dD=dD+20;dE=dE..cb(dC,dD,cm.getConstructName(A),"pdim txtmid")end end;local dF=#cm.getIdentifiedConstructIds()if cq==nil and dF>0 then cr=1;RADAR.ToggleRadarPanel()end;if cq~=nil and dF==0 then RADAR.ToggleRadarPanel()end;if radarPanelId==nil then if showHud then RADAR.ToggleRadarPanel()end end else if cw~=1 then dE=cb(radarX,radarY,co.." Radar: "..cx[cw],"pbright txtbig txtmid")else dE=cb(radarX,radarY,"Radar: No "..co.." Contacts","pbright txtbig txtmid")end;if radarPanelId~=nil then cr=0;RADAR.ToggleRadarPanel()end end;return dE end;function cd.GetClosestName(bY)if cm then local dG=cm.getConstructName(cm.getConstructIds()[1])if dG then bY=bY.." "..dG end end;return bY end;function cd.ToggleRadarPanel()cJ()end;function cd.ContactTick()if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then l("Radar Contact")bE("rdrCon","RC")contactTimer=time end;c.stopTimer("contact")end;function cd.onEnter(W)if cm and not inAtmo and not notPvPZone then c.setTimer("contact",0.1)end end;function cd.onLeave(W)if cm and CollisionSystem then if#cs>650 then W=tostring(W)cs[W]=nil end end end;local function dH()cm=nil;if radar_2 and radar_2.getOperationalState()==1 then cm=radar_2 else cm=radar_1 end;cw=cm.getOperationalState()cC=cm.hasMatchingTransponder;cD=cm.getConstructKind;cE=cm.isConstructAbandoned;cF=cm.getConstructName;cG=cm.getConstructDistance;cH=cm.getConstructCoreSize;cI=cm.getConstructWorldPos;cn={cm}ct=cm.getConstructIds()dz()cp=coroutine.create(cK)if userRadar then for N,A in pairs(userRadar)do cd[N]=A end end end;dH()return cd end;local function dI(shield,stringmatch,h,l)local dJ={}local dK=shield.getResistancesCooldown()local function dL()local dM=shield.isActive()if AutoShieldToggle then if not notPvPZone and dM==0 and shield.isVenting()~=1 then shield.toggle()elseif notPvPZone and dM==1 then shield.toggle()end end end;local function dN()local dO=shield.getStressRatioRaw()local dP=0.5999;if dO[1]==0.0 and dO[2]==0.0 and dO[3]==0.0 and dO[4]==0.0 then return end;local dQ=shield.setResistances(dP*dO[1],dP*dO[2],dP*dO[3],dP*dO[4])if dQ==1 then l("Shield Resistances updated")else l("Value Exceeded. Failed to update Shield Resistances")end end;function dJ.shieldTick()shieldPercent=h(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())dL()dK=shield.getResistancesCooldown()if dK==0 and shieldPercent<AutoShieldPercent then dN()end end;function dJ.setResist(dR)if not shield then l("No shield found")return elseif dR==nil or dK>0 then l("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G=F..', '..F..', '..F..', '..F;local dS,dT,dU,dV=stringmatch(dR,G)if dV==nil or dS+dT+dU+dV>0.6 then l("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(dS,dT,dU,dV)==1 then l("Shield Resistances set")else l("Resistance setting failed.")end end;function dJ.ventShield()local dW=shield.getVentingCooldown()if dW>0 then l("Cannot vent again for "..dW.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()l("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else l("Shields already at max hitpoints")end end;if userShield then for N,A in pairs(userShield)do dJ[N]=A end end;return dJ end;local function dX(d,b,c,a,e,antigrav,hover,shield,warpdrive,weapon,aV,h,n,dY,j,dZ,d_,atan,g,o,e0,bD,bC,ca,e1,r,bF,cb,bE,e2,e3,e4,e5,e6,e7,l)local k=DUConstruct;local e8=9.80665;local e9={}local ea={}local eb={}local ec={}local ed=nil;local ee=nil;local ef=nil;local eg=false;local eh="none"local ei=""local ej=55;local ek=0;local el=0;local em=nil;local en=SafeR;local eo=SafeG;local ep=SafeB;local eq=[[rgb(]]..h(en+0.5)..","..h(eo+0.5)..","..h(ep+0.5)..[[)]]local er=[[rgb(]]..h(en*0.9+0.5)..","..h(eo*0.9+0.5)..","..h(ep*0.9+0.5)..[[)]]local es=0;local et=0;local eu=""local ev=g()local ew=false;local ex=false;local cm=false;local function ey(A)if ResolutionX==1920 then return A else return bF(ResolutionX*A/1920,0)end end;local function ez(A)if ResolutionY==1080 then return A else return bF(ResolutionY*A/1080,0)end end;local function eA()return e1()==0 and userControlScheme~="keyboard"and d_()==0 end;local function eB()local eC="TRAVEL"if not throttleMode then eC="CRUISE"end;if Autopilot then eC="AUTOPILOT"end;return eC end;local dE=""local eD=""local eE=""local eF=1;local eG=2;local eH=3;local eI=4;local eJ=5;local eK=6;local eL=7;local eM=""local eN=0;local eO=90.0*hudTickRate;local eP={}local eQ={}local eR={}local eS={}local eT={}local eU={}local eV={}eV["atmofueltank"],eV["spacefueltank"],eV["rocketfueltank"]=0,0,0;local eW=0;local function eX(d4,eY,eZ,e_,f0,f1)local f2=eW;local f3=eW+5;if not BarFuelDisplay then f3=f3+5 end;if d_()==1 and not RemoteHud then f2=f2-50;f3=f3-50 end;if eZ=="ATMO"then eM="atmofueltank"elseif eZ=="SPACE"then eM="spacefueltank"else eM="rocketfueltank"end;eN=_G[eM.."_size"]if#e_>0 then for i=1,#e_ do local bY=e_[i][eG]local f4=e_[i][eL]for f5=1,eN do if e_[i][eG]==dY(c[eM.."_"..f5].getWidgetData()).name then f4=f5;break end end;local f6=g()if f0[i]==nil or f1[i]==nil or f6-e_[i][eK]>eO then local f7;local f8=0;f8=dZ(e_[i][eF])-e_[i][eI]f7=e_[i][eJ]local f9=f7>f8 or false;if f9 then eV[eM]=eV[eM]+f7-f8 end;if f4~=0 then local fa=dY(c[eM.."_"..f4].getWidgetData())f1[i]=fa.percentage;f0[i]=fa.timeLeft;if f0[i]=="n/a"then f0[i]=0 end else f1[i]=h(0.5+f8*100/e_[i][eH])if f9 then f0[i]=h(0.5+f8/((f7-f8)/(f6-e_[i][eK])))else f0[i]=0 end end;e_[i][eK]=f6;e_[i][eJ]=f8 end;if bY==eY then bY=n("%s %d",eZ,i)end;if f4==0 then bY=bY.." *"end;local fb;fb=e5(f0[i])if f0[i]==0 or fb==">1y"then fb=""end;if f1[i]~=nil then local fc=h(f1[i]*2.55)local fd=n("rgb(%d,%d,%d)",255-fc,fc,0)local fe=""if fb~=""and f0[i]<120 or f1[i]<5 then fe="red "end;local ff=n("rgb(%d,%d,%d)",o(h((255-fc)/2.55),50,100),o(h(fc/2.55),0,50),50)local fg="rgb(196,0,255)"if eZ=="ATMO"then fg="rgb(0,188,255)"elseif eZ=="SPACE"then fg="rgb(239,255,0)"end;local fh=false;if previous~=fg then fh=true end;previous=fg;if BarFuelDisplay then if fh then f2=f2-5;f3=f3-5 end;eD=eD..n([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],ff,fg,d4,f3,fd,h(f1[i]*1.7+0.5)-2,d4+1,f3+1,d4+5,f3+14,bY,f1[i],fb)f2=f2-22;f3=f3-22 else eD=eD..cb(d4,f2,bY,fe.."pdim txtfuel")eD=eD..cb(d4,f3,n("%d%% %s",f1[i],fb),"pdim txtfuel","fill:"..fd)f2=f2+30;f3=f3+30 end end end end;eW=f2 end;local function fi(fj,a4)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if a4<200000 and not inAtmo or a4 and inAtmo then local fk=0;if aV(vSpd)>1 then fk=45*math.log(aV(vSpd),10)if vSpd<0 then fk=-fk end end;fj[#fj+1]=n([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,h(vSpd),h(fk))end;return fj end;local function fl(fm)local bS=-worldVertical;fm=fm-fm:project_on(bS)local fn=vec3(0,0,1)fn=fn-fn:project_on(bS)local fo=fn:cross(bS)local fk=fn:angle_between(fm)*constants.rad2deg;if fm:dot(fo)<0 then fk=360-fk end;return fk end;local function fp(fj,centerX,centerY,fq,fr,nearPlanet)if circleRad==0 then return end;local fs=circleRad;local ft=20;local fu=h(fq)if nearPlanet then for i=-45,45,5 do local fv=i;fj[#fj+1]=n([[<g transform="rotate(%f,%d,%d)">]],fv,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fj[#fj+1]=n([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+fs+ft-len,centerX,centerY+fs+ft)end;fj[#fj+1]=cb(centerX,centerY+fs+ft-35,fr,"pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY+fs+ft-25,fu.." deg","pdim txt txtmid")fj[#fj+1]=n([[<g transform="rotate(%f,%d,%d)">]],-fq,centerX,centerY)fj[#fj+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+fs+ft-20,centerX+5,centerY+fs+ft-20,centerX,centerY+fs+ft-15)fj[#fj+1]="</g>"end;fj[#fj+1]=[[<g style="clip-path: url(#headingClip);">]]local fw=fu;if nearPlanet then fw=fl(constructForward)end;local fx=20;local fy=h(fw)local fz=0;local fA=centerY+fs+ft+20;local fB=centerX;if fr~="YAW"then fA=ez(130)fB=ey(960)end;local fC=[[<path class="txttick line" d="]]local fD=h(fy-(fx+10)-fy%5+0.5)for i=fD+70,fD,-5 do local d4=fB-(-i*5+fw*5)if i%10==0 then fz=10;local F=i;if F==360 then F=0 elseif F>360 then F=F-360 elseif F<0 then F=F+360 end;fj[#fj+1]=cb(d4,fA+15,F,"txtmid bright")elseif i%5==0 then fz=5 end;if fz==10 then fC=n([[%s M %f %f v %d]],fC,d4,fA-5,fz)else fC=n([[%s M %f %f v %d]],fC,d4,fA-2.5,fz)end end;fj[#fj+1]=fC..[["/>]]fj[#fj+1]=n([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],fB-5,fA-20,fB+5,fA-20,fB,fA-10)if nearPlanet then fr="HDG"end;fj[#fj+1]=cb(ey(960),ez(100),fy.."","dim txt txtmid size14","")fj[#fj+1]=cb(ey(960),ez(85),fr,"dim txt txtmid size20","")fj[#fj+1]=[[</g>]]end;local function fE(fj,fF,fq,centerX,centerY,nearPlanet,fG,fH)if circleRad==0 then return end;local fs=circleRad;local fI=h(fs*3/5)if fs>0 then local fJ=h(fF)local len=0;local fC=n([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*fq,centerX,centerY)if not inAtmo then fC=n([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fj[#fj+1]=n([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],fs-1,centerX,centerY)fj[#fj+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=h(fJ-30-fJ%5+0.5),h(fJ+30+fJ%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local d5=centerY+-i*5+fF*5;if len==30 then fC=n([[%s M %d %f h %d]],fC,centerX-fI-len,d5,len)if inAtmo then fj[#fj+1]=n([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*fq,centerX,centerY,centerX-fI+10,d5+4,i)fj[#fj+1]=n([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*fq,centerX,centerY,centerX+fI-10,d5+4,i)if i==0 or i==180 or i==-180 then fj[#fj+1]=n([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*fq,centerX,centerY,centerX-fI+20,d5,fI*2-40)end else fj[#fj+1]=cb(centerX-fI+10,d5,i,"pdim txt txtmid")fj[#fj+1]=cb(centerX+fI-10,d5,i,"pdim txt txtmid")end;fC=n([[%s M %d %f h %d]],fC,centerX+fI,d5,len)else fC=n([[%s M %d %f h %d]],fC,centerX-fI-len,d5,len)fC=n([[%s M %d %f h %d]],fC,centerX+fI,d5,len)end end;fj[#fj+1]=fC..[["/>]]local fK="PITCH"if not nearPlanet then fK="REL PITCH"end;if fF>90 and not inAtmo then fF=90-(fF-90)elseif fF<-90 and not inAtmo then fF=-90-(fF+90)end;if fs>200 then if inAtmo then if fH>ej then fj[#fj+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY+20,fG,"pdim txt txtmid")end;fj[#fj+1]=n([[<g transform="rotate(%f,%d,%d)">]],-fq,centerX,centerY)else fj[#fj+1]=n([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fj[#fj+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-fI+25,centerY-5,centerX-fI+20,centerY,centerX-fI+25,centerY+5,centerX-fI+50,centerY+4,fJ)fj[#fj+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+fI-25,centerY-5,centerX+fI-20,centerY,centerX+fI-25,centerY+5,centerX+fI-30,centerY+4,fJ)fj[#fj+1]="</g>"end;local fL=h(fs/3)fj[#fj+1]=n([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-fL,centerY,fs-fL)if not inAtmo and nearPlanet then fj[#fj+1]=n([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*fq,centerX,centerY,centerX-fI+10,centerY,fI*2-20)end;fj[#fj+1]="</g>"if fs<200 then if inAtmo and fH>ej then fj[#fj+1]=cb(centerX,centerY-fs,fK,"pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY-fs+10,fJ,"pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY+20,fG,"pdim txt txtmid")else fj[#fj+1]=cb(centerX,centerY-fs,fK,"pdim txt txtmid")fj[#fj+1]=cb(centerX,centerY-fs+15,fJ,"pdim txt txtmid")end end end end;local function fM(fj,a4,nearPlanet)local fN=altMeterX;local fO=altMeterY;if fN==0 and fO==0 then return end;local fP=78;local fQ=19;local fR=abvGndDet;if abvGndDet~=-1 then fj[#fj+1]=cb(fN+fP,fO+fQ+20,n("AGL: %.1fm",abvGndDet),"pdim altsm txtend")end;if nearPlanet and(a4<200000 and not inAtmo or a4 and inAtmo)then fj[#fj+1]=cb(fN+fP,fO-10,n("%s",planet.name),"pdim altsm txtend")table.insert(fj,n([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],fN-1,fO-4,fP+2,fQ+6,fN+1,fO-1,fP-4,fQ))local bW=0;local fS=1;local fT=0;local fU=a4<0;local fV=a4<planet.surfaceMaxAltitude;local fW=9;if fU then fW=0 end;local a4=aV(a4)while bW<6 do local fX=11;local fY=16;local fZ=9;local f_=14;local fe="altsm"if bW>2 then fY=fY+3;fX=fX+2;f_=f_+2;fZ=fZ-6;fe="altbig"end;if fU then fe=fe.." red"elseif fV then fe=fe.." orange"end;local g0=a4/fS%10;local g1=h(g0)local g2=h((g1+1)%10)local g3=fT;if bW==0 then g3=g0-g1;if fU then g3=1-g3 end end;if fU and(bW==0 or fT~=0)then local bZ=g2;g2=g1;g1=bZ end;local g4=fY*(g3-1)local g5=g4+fY;local d4=fN+fZ+(6-bW)*fX;local d5=fO+f_;fj[#fj+1]=cb(d4,d5+g4,g2,fe)fj[#fj+1]=cb(d4,d5+g5,g1,fe)bW=bW+1;fS=fS*10;if g1==fW then fT=g3 else fT=0 end end;table.insert(fj,[[</g></g>]])end end;local function g6(bf)local g7=-math.deg(atan(bf.y,bf.z))+180;g7=g7-90;if g7<0 then g7=360+g7 end;if g7>180 then g7=-180+g7-180 end;return-g7 end;local function g8(bf)local fw=math.deg(atan(bf.y,bf.x))-90;if fw<-180 then fw=360+fw end;return fw end;local function g9(fj,bf,fH,centerX,centerY)if fH>5 and not inAtmo or fH>ej then local fs=circleRad;local ga=20;local gb=20;local gc=g6(bf)local gd=g8(bf)local ge=14;local gf=ge/2;local gg=-gd/gb*fs;local gh=gc/ga*fs;local d4=centerX+gg;local d5=centerY+gh;local distance=r(gg^2+gh^2)local gi=[[<circle
                            cx="]]..d4 ..[["
                            cy="]]..d5 ..[["
                            r="]]..gf/ge..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..d4 ..[["
                            cy="]]..d5 ..[["
                            r="]]..gf..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..d4-ge..[[,]]..d5 ..[[ h ]]..gf..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..d4+gf..[[,]]..d5 ..[[ h ]]..gf..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..d4 ..[[,]]..d5-ge..[[ v ]]..gf..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if distance<fs then fj[#fj+1]=gi else local fk=atan(gh,gg)local gj=4;local gk=centerX+fs*math.cos(fk)local gl=centerY+fs*math.sin(fk)fj[#fj+1]=n('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',fk*180/math.pi,gk,gl,gk-gj,gl-gj/2,gj*2,gj,gk+gj,gl-gj,gj,gj,-gj,gj)end;if not inAtmo then local gm=vec3(bf)gc=g6(-gm)gd=g8(-gm)gg=-gd/gb*fs;gh=gc/ga*fs;d4=centerX+gg;d5=centerY+gh;distance=r(gg^2+gh^2)if distance<fs then local gn=[[<circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..d4 ..[[,]]..d5-ge..[[ v ]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..d4 ..[[,]]..d5 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..d4 ..[[,]]..d5 ..[[)" />
                                <path
                                    d="M ]]..d4-gf..[[,]]..d5 ..[[ h ]]..ge..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..d4 ..[[,]]..d5 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..d4 ..[[,]]..d5 ..[[)"/>]]fj[#fj+1]=gn end end end end;local function go(fj,eC,gp,gq)if throtPosX==0 and throtPosY==0 then return end;gp=h(gp+0.5)local f2=throtPosY+10;local f3=throtPosY+20;if d_()==1 and not RemoteHud then f2=55;f3=65 end;local gr="CRUISE"local c="km/h"local O=gq;if eC=="TRAVEL"or eC=="AUTOPILOT"then gr="THROT"c="%"O=gp;local gs="dim"if gp<0 then gs="red"end;fj[#fj+1]=n([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],gs,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-aV(gp),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fj[#fj+1]=cb(throtPosX+10,f2,gr,"pbright txtstart")fj[#fj+1]=cb(throtPosX+10,f3,n("%.0f %s",O,c),"pbright txtstart")if inAtmo and AtmoSpeedAssist and throttleMode and ThrottleLimited then gp=h(calculatedThrottle*100+0.5)local gs="red"if gp<0 then gs="red"end;fj[#fj+1]=n([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],gs,1-aV(gp),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fj[#fj+1]=cb(throtPosX+10,f2+40,"LIMIT","pbright txtstart")fj[#fj+1]=cb(throtPosX+10,f3+40,gp.."%","pbright txtstart")end;if inAtmo and AtmoSpeedAssist or Reentry then fj[#fj+1]=cb(throtPosX+10,f2-40,"LIMIT: "..adjustedAtmoSpeedLimit.." km/h","dim txtstart")elseif not inAtmo and Autopilot then fj[#fj+1]=cb(throtPosX+10,f2-40,"LIMIT: "..h(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function gt(fj,gu)if throtPosX==0 and throtPosY==0 then return end;local gv=throtPosY-10;local gw=throtPosX+10;fj[#fj+1]=cb(0,0,"","pdim txt txtend")if d_()==1 and not RemoteHud then gv=75 end;fj[#fj+1]=cb(gw,gv,h(gu).." km/h","pbright txtbig txtstart")end;local gx=40;local function gy(fj)fj[#fj+1]=cb(ey(150),ez(1070),n("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fj[#fj+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then fj[#fj+1]=cb(ey(960),ez(550),"Warning: Invalid Control Scheme Detected","warnings")fj[#fj+1]=cb(ey(960),ez(600),"Keyboard Scheme must be selected","warnings")fj[#fj+1]=cb(ey(960),ez(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local gz=ey(960)local gA=ez(860)local gB=ez(880)local gC=ez(900)local gD=ez(960)local gE=ez(200)local gF=ez(250)local gG=ez(960)if d_()==1 and not RemoteHud then gA=ez(135)gB=ez(155)gC=ez(175)gE=ez(115)gF=ez(95)end;if BrakeIsOn then local gH=""if type(BrakeIsOn)=="string"then gH="-"..BrakeIsOn end;fj[#fj+1]=cb(gz,gA,"Brake Engaged"..gH,"warnings")elseif brakeInput2>0 then fj[#fj+1]=cb(gz,gA,"Auto-Brake Engaged","warnings","opacity:"..brakeInput2)end;if inAtmo and stalling and abvGndDet==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not antigravOn and not VertTakeOff and not AutoTakeoff then fj[#fj+1]=cb(gz,gE+50,"** STALL WARNING **","warnings")bE("stall","SW",2)end end;if ReversalIsOn then fj[#fj+1]=cb(gz,gE+90,"Flight Assist in Progress","warnings")end;if gyroIsOn then fj[#fj+1]=cb(gz,gG,"Gyro Enabled","warnings")end;if ECU then gx=gx-1;if gx>20 then fj[#fj+1]=cb(gz,gG-20,"ECU Enabled","warnings")elseif gx<0 then gx=40 end end;if GearExtended then if hasGear then fj[#fj+1]=cb(gz,gB,"Gear Extended","warn")else fj[#fj+1]=cb(gz,gB,"Landed (G: Takeoff)","warnings")end end;if abvGndDet>-1 and(not antigravOn or coreAltitude<100)then local gI=e4(d:getTargetGroundAltitude())fj[#fj+1]=cb(gz,gC,"Hover Height: "..gI,"warn")end;if isBoosting then fj[#fj+1]=cb(gz,gD+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and antigravOn and AntigravTargetAltitude~=nil then local gJ="warnings"if aV(coreAltitude-antigrav.getBaseAltitude())<501 then gJ="warn"end;fj[#fj+1]=cb(gz,gE+40,n("Target Altitude: %d Singularity Altitude: %d",h(AntigravTargetAltitude),h(antigrav.getBaseAltitude())),gJ)end;if Autopilot and AutopilotTargetName~="None"then fj[#fj+1]=cb(gz,gE,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fj[#fj+1]=cb(gz,gE+20,n("LockedPitch: %d",h(LockPitch)),"warn")elseif followMode then fj[#fj+1]=cb(gz,gE+20,"Follow Mode Engaged","warn")elseif Reentry or finalLand then fj[#fj+1]=cb(gz,gE+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local gI=e4(HoldAltitude,2)if VertTakeOff then if antigravOn then gI=e4(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fj[#fj+1]=cb(gz,gE,"VTO to "..gI,"warn")elseif(AutoTakeoff or spaceLaunch)and not IntoOrbit then if spaceLaunch then fj[#fj+1]=cb(gz,gE,"Takeoff to "..AutopilotTargetName,"warn")else fj[#fj+1]=cb(gz,gE,"Takeoff to "..gI,"warn")end;if BrakeIsOn and not VertTakeOff then fj[#fj+1]=cb(gz,gE+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else fj[#fj+1]=cb(gz,gE,"Altitude Hold: "..n("%.1fm",HoldAltitude),"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if atmosDensity>0.1 then fj[#fj+1]=cb(gz,gE+20,"Beginning ascent","warn")elseif atmosDensity<0.09 and atmosDensity>0.05 then fj[#fj+1]=cb(gz,gE+20,"Aligning trajectory","warn")elseif atmosDensity<0.05 then fj[#fj+1]=cb(gz,gE+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if orbitMsg~=nil then fj[#fj+1]=cb(gz,gE,orbitMsg,"warn")end end;if BrakeLanding then local gK="Brake Landing"if alignHeading then gK=gK.."-Aligning"end;if apBrk then gK=gK.."-Drift Limited"end;fj[#fj+1]=cb(gz,gE,gK,"warnings")end;if ProgradeIsOn then fj[#fj+1]=cb(gz,gE+20,"Prograde Alignment","crit")end;if RetrogradeIsOn then fj[#fj+1]=cb(gz,gE,"Retrograde Alignment","crit")end;if collisionAlertStatus then local type;if string.find(collisionAlertStatus,"COLLISION")then type="warnings"else type="crit"end;fj[#fj+1]=cb(gz,gF+20,collisionAlertStatus,type)elseif atmosDensity==0 then local gL,gM=AP.checkLOS(constructVelocity:normalize())if gM~=nil and velMag>0 then local gI=e4(gM)local travelTime=Kinematic.computeTravelTime(velMag,0,gM)local gN="Collision"if gL.noAtmosphericDensityAltitude>0 then gN="Atmosphere"end;fj[#fj+1]=cb(gz,gF+20,gL.name.." "..gN.." "..e5(travelTime).." In "..gI,"crit")end end;if VectorToTarget and not IntoOrbit then fj[#fj+1]=cb(gz,gE+60,VectorStatus,"warn")end;if passengers and#passengers>1 then end;local gO=ey;local gP=ez;local gQ="topButton"local gR="topButtonActive"local gS=gQ;if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then gS=gR end;local gT=gQ;if ProgradeIsOn then gT=gR end;local gU=gQ;if BrakeLanding or GearExtended then gU=gR end;local gV=gQ;if AltitudeHold or VectorToTarget then gV=gR end;local gW=gQ;if RetrogradeIsOn then gW=gR end;local gX=gQ;if IntoOrbit or OrbitAchieved and Autopilot then gX=gR end;if showHud and DisplayOdometer then local gY=gP(30)fj[#fj+1]=n([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],gS,gO(960),gP(54),gP(-53),gO(-120),gO(25),gP(50))fj[#fj+1]=cb(gO(910),gY,"AUTOPILOT")fj[#fj+1]=n([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],gT,gO(865),gP(51),gO(-25),gP(-50),gO(-110),gO(25),gP(46))fj[#fj+1]=cb(gO(800),gY,"PROGRADE")fj[#fj+1]=n([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],gU,gO(755),gP(47),gO(-25),gP(-46),gO(-98),gO(44),gP(44))fj[#fj+1]=cb(gO(700),gY,"LAND")fj[#fj+1]=n([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],gV,gO(960),gP(54),gP(-53),gO(120),gO(-25),gP(50))fj[#fj+1]=cb(gO(1010),gY,"ALT HOLD")fj[#fj+1]=n([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],gW,gO(1055),gP(51),gO(25),gP(-50),gO(110),gO(-25),gP(46))fj[#fj+1]=cb(gO(1122),gY,"RETROGRADE")fj[#fj+1]=n([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],gX,gO(1165),gP(47),gO(25),gP(-46),gO(98),gO(-44),gP(44))fj[#fj+1]=cb(gO(1220),gY,"ORBIT")fj[#fj+1]=[[
                                    </g>
                                </g>]]fj[#fj+1]="</g>"end;return fj end;local function gZ(fH)return h(bF(fH*3.6,0)+0.5).." km/h"end;local function g_(bW)local bY=AutopilotTargetName;if bW~=nil and type(bW)=="number"then if bW==0 then return"None"end;bY=AtlasOrdered[bW].name end;if bY==nil then bY=CustomTarget.name end;if bY==nil then bY="None"end;return bY end;local function h0(fj)local h1=AP.routeWP(true)if not h1 or#h1==0 then return end;local d4=ey(750)local d5=ez(360)if Autopilot or VectorToTarget then fj[#fj+1]=cb(d4,d5,"REMAINING ROUTE","pdim txtstart size20")else fj[#fj+1]=cb(d4,d5,"LOADED ROUTE","pdim txtstart size20")end;for N,i in pairs(h1)do d5=d5+20;fj[#fj+1]=cb(d4,d5,N..". "..h1[N],"pdim txtstart size20")end end;local function h2(fj)local d4=OrbitMapX+10;local d5=OrbitMapY+20;local h3={}local h4={"Alt-4: AutoTakeoff to Target"}local h5={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local h6={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local h7={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(h3,"--------------DYNAMIC-----------------")if inAtmo then if abvGndDet~=-1 then e2(h3,h4)if autopilotTargetPlanet and planet and autopilotTargetPlanet.name==planet.name then table.insert(h3,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if antigravOn then table.insert(h3,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(h3,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(h3,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(h3,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(h3,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(h3,"G: Takeoff to hover height, raise gear")else table.insert(h3,"G: Lowergear and Land")end else e2(h3,h5)table.insert(h3,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(h3,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else e2(h3,h6)if shield then table.insert(h3,"Alt-Shift-6: Vent shields")if not AutoShieldToggle then table.insert(h3,"Alt-Shift-7: Toggle shield off/on")end end end;if CustomTarget~=nil then table.insert(h3,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(h3,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(h3,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(h3,"Alt-Spacebar/C will raise/lower target height")table.insert(h3,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not inAtmo then table.insert(h3,"LALT+Mousewheel will lower/raise speed limit")end;e2(h3,h7)for i=1,#h3 do d5=d5+12;fj[#fj+1]=cb(d4,d5,h3[i],"pdim txtbig txtstart")end end;local function h8(fj)local h9=OrbitMapX;local ha=OrbitMapY;local hb=OrbitMapSize;local hc=4;local hd=15;local d4=0;local d5=0;local he,hf,hg,hh;local hi;local function hj(type)local c7,time,fH,hk,fe,hl;if type=="Periapsis"then c7=hi.periapsis.altitude;time=hi.timeToPeriapsis;fH=hi.periapsis.speed;fe="txtend"hk=12;hl=math.min(d4,h9+hb-planet.radius/hg-hc*2)else c7=hi.apoapsis.altitude;time=hi.timeToApoapsis;fH=hi.apoapsis.speed;hk=-12;fe="txtstart"hl=d4 end;if velMag<1 then time=0 end;fj[#fj+1]=n([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],hl+hk,d5-5,d4,d5-5)fj[#fj+1]=n([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],hl-hk*4,d5+2,d4,d5+2)fj[#fj+1]=cb(hl,d5,type,fe)d4=hl-hk*2;d5=d5+hd;local gI=e4(c7)fj[#fj+1]=cb(d4,d5,gI,fe)d5=d5+hd;fj[#fj+1]=cb(d4,d5,e5(time),fe)d5=d5+hd;fj[#fj+1]=cb(d4,d5,gZ(fH),fe)end;local hm=hb*1.5;if SelectedTab=="INFO"then hm=25*10 end;if SelectedTab=="ORBIT"and coreAltitude<planet.spaceEngineMinAltitude then return fj end;if SelectedTab~="HIDE"then fj[#fj+1]=[[<g class="pbright txtorb txtmid">]]fj[#fj+1]=n('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',hb*2,hm,h9,ha)fj[#fj+1]=n([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],hb*2,hm,h9,ha)end;local hn=hb*1.5;local ho=hb*2;local hp=hn/2;local hq=hb;local hr=h9+hq;local hs=ha+hp;local ht=h9+ho;local hu=ha+hn;if SelectedTab=="ORBIT"then ha=ha+hc;he=hb/2;hh=0;hi={}hi.periapsis={}hi.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then hi.periapsis.altitude=orbit.periapsis.altitude;hi.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then hi.apoapsis.altitude=orbit.apoapsis.altitude;hi.apoapsis.speed=orbit.apoapsis.speed end;hi.period=orbit.period;hi.eccentricity=orbit.eccentricity;hi.timeToApoapsis=orbit.timeToApoapsis;hi.timeToPeriapsis=orbit.timeToPeriapsis;hi.eccentricAnomaly=orbit.eccentricAnomaly;hi.trueAnomaly=orbit.trueAnomaly end;if hi.periapsis==nil then hi.periapsis={}hi.periapsis.altitude=-planet.radius;hi.periapsis.speed=MaxGameVelocity end;if hi.eccentricity==nil then hi.eccentricity=1 end;if hi.apoapsis==nil then hi.apoapsis={}hi.apoapsis.altitude=coreAltitude;hi.apoapsis.speed=0 end;if velMag<1 then hi.apoapsis.altitude=coreAltitude;hi.apoapsis.speed=0 end;if hi.apoapsis.altitude then hg=(hi.apoapsis.altitude+hi.periapsis.altitude+planet.radius*2)/(he*2)hf=(planet.radius+hi.apoapsis.altitude)/hg*(1-hi.eccentricity)hh=he-hi.periapsis.altitude/hg-planet.radius/hg;local hv=math.pi;if hi.period~=nil and hi.period>0 and hi.timeToApoapsis~=nil then hv=hi.eccentricAnomaly;if hi.timeToPeriapsis<hi.timeToApoapsis then hv=2*math.pi-hv end end;if velMag<1 or hv~=hv then hv=math.pi end;local hw=-he*math.cos(hv)+h9+hq+hc;local hx=hf*math.sin(hv)+ha+hp+hc;local hy=""fj[#fj+1]='<g clip-path="url(#orbitRect)">'fj[#fj+1]=n([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hy,h9+hb+hc,ha+hb*1.5/2+hc,he,hf)if hf<1 then fj[#fj+1]=n([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],h9+hb+hc-hh,ha+hb*1.5/2+hc,hw,hx)end;fj[#fj+1]=n('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',h9+hb+hc-hh,ha+hb*1.5/2+hc,(planet.radius+planet.noAtmosphericDensityAltitude)/hg)fj[#fj+1]=n('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',h9+hb+hc-hh,ha+hb*1.5/2+hc,(planet.radius+planet.noAtmosphericDensityAltitude)/hg)fj[#fj+1]=n([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",h9+hb+hc,ha+hb*1.5/2+hc,he,hf)fj[#fj+1]=n('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',h9+hb+hc-hh,ha+hb*1.5/2+hc,planet.radius/hg)fj[#fj+1]='</g>'local hz=math.floor(planet.radius/hg+0.5)d4=h9+hb+hc*4+he;d5=ha+hb*1.5/2+5+hc;if hi.apoapsis~=nil and hi.apoapsis.speed<MaxGameVelocity then hj("Apoapsis")end;d5=ha+hb*1.5/2+5+hc;d4=h9+hb-hc*2-he;if hi.periapsis~=nil and hi.periapsis.speed<MaxGameVelocity and hi.periapsis.altitude>0 then hj("Periapsis")end;fj[#fj+1]=cb(h9+hb+hc,ha+20+hc,planet.name,"txtorbbig")fj[#fj+1]=n('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',hw,hx)fj[#fj+1]=[[</g>]]return fj else fj[#fj+1]='<g clip-path="url(#orbitRect)">'local hA=""local hB=1.2*(maxAtlasX-minAtlasX)/(hb*2)local hC=1.4*(maxAtlasY-minAtlasY)/(hb*1.5)for N,A in pairs(e[0])do if A.center then local d4=h9+hb+A.center.x/hB;local d5=ha+hb*1.5/2+A.center.y/hC;hA=hA..'<circle cx="'..d4 ..'" cy="'..d5 ..'" r="'..A.radius/hB*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(A.name,"Moon")and not string.match(A.name,"Sanctuary")and not string.match(A.name,"Space")then hA=hA.."<text x='"..d4 .."' y='"..d5+A.radius/hB*30+20 .."' font-size='12' fill="..eq.." text-anchor='middle' font-family='Montserrat'>"..A.name.."</text>"end end end;local bg=vec3(k.getWorldPosition())local d4=h9+hb+bg.x/hB;local d5=ha+hb*1.5/2+bg.y/hC;hA=hA..'<circle cx="'..d4 ..'" cy="'..d5 ..'" r="2" stroke="white" stroke-width="1" fill="red"/>'hA=hA.."<text x='"..d4 .."' y='"..d5-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ed=hB;ee=hC;local hD=bg+constructVelocity*1000000;local hE=h9+hb+hD.x/hB;local f3=ha+hb*1.5/2+hD.y/hC;hA=hA..'<line x1="'..d4 ..'" y1="'..d5 ..'" x2="'..hE..'" y2="'..f3 ..'" stroke="purple" stroke-width="1"/>'fj[#fj+1]=hA;fj[#fj+1]='</g>'end elseif SelectedTab=="INFO"then fj=HUD.DrawOdometer(fj,es,TotalDistanceTravelled,et)elseif SelectedTab=="HELP"then fj=h2(fj)elseif SelectedTab=="SCOPE"then fj[#fj+1]='<g clip-path="url(#orbitRect)">'local hF=scopeFOV;local hG=vec3(DUSystem.getCameraWorldPos())local hH=vec3(DUSystem.getCameraWorldRight())local hI=vec3(DUSystem.getCameraWorldForward())if e1()==1 then hG=worldPos;hH=constructRight;hI=constructForward end;if atmosDensity>0 then table.sort(planetAtlas,function(ax,ay)local az,aA=ax.center,ay.center;return(az.x-hG.x)^2+(az.y-hG.y)^2+(az.z-hG.z)^2<(aA.x-hG.x)^2+(aA.y-hG.y)^2+(aA.z-hG.z)^2 end)end;local hJ={}local hK={}local hL=120;local hM=nil;local hN=nil;for i,A in ipairs(planetAtlas)do local cj=A.center-hG;local hO=cj:len()local hP=cj:normalize()local hQ=cj:cross(hI):normalize()local hR=math.acos(hQ:dot(hH))if hR~=hR then hR=0 end;if hQ:cross(hH):dot(hI)<0 then hR=-hR end;local hS=cj:project_on_plane(hI):len()local hT=math.sin(hR)*math.asin(hS/hO)*constants.rad2deg;local hU=math.cos(hR)*math.asin(hS/hO)*constants.rad2deg;if hP:dot(hI)<0 then hU=90*math.cos(hR)+90*math.cos(hR)-hU;hT=90*math.sin(hR)+90*math.sin(hR)-hT end;local d4=hr+hT/hF*hn;local d5=hs+hU/hF*hn;local hV=(d4-hr)*(d4-hr)+(d5-hs)*(d5-hs)local hW=math.asin((A.radius+A.surfaceMaxAltitude)/hO)*constants.rad2deg;if hW~=hW then hW=hF end;local dq=hW/hF*hn;local hX=math.asin(A.atmosphereRadius/hO)*constants.rad2deg;if hX~=hX then hX=hW end;local hY=hX/hF*hn;local distance=e4(hO,1)local hZ=A.name;local h_=false;if d5>ha then if d5>hu then if d5-hY<=hu then h_=true end else h_=true end else if d5+hY>=ha then h_=true end end;local i0=false;local i1=d4;if A.systemId==0 then i1=d4+hL else i1=d4-hL end;if i1+hL>h9 then if i1+hL>ht then if i1-hY-hL<=ht then i0=true end else i0=true end else if i1+hY+hL>=h9 then i0=true end end;local i2={}i2.x=d4;i2.y=d5;i2.planet=A;i2.atmoSize=hY;if not hM or hV<hM then hM=hV;hN=i2 end;if i0 and h_ then local i3=math.max(hY,5)if hV<i3*i3 then hZ=hZ.." - "..distance end;i2.size=dq;i2.i=i;i2.displayString=hZ;i2.distance=distance;i2.visible=true;hK[#hK+1]=i2 else i2.visible=false end end;local i4=false;table.sort(hK,function(az,aA)return az.y<aA.y end)for N,bd in ipairs(hK)do local A,dq,i,hY,d4,d5,hZ,distance=bd.planet,bd.size,bd.i,bd.atmoSize,bd.x,bd.y,bd.displayString,bd.distance;local hl,i5,i6,i7;local i8=15;local fe="pdim"if A.systemId~=0 then i6=ey(string.len(hZ)*5)i8=-(15+i6)i7=ez(10)fe="pdimfill"else i6=ey(string.len(hZ)*9)i7=ez(15)end;if dq*2>i6 then hl=o(d4,h9+i6/2,ht-i6/2)i5=o(d5,ha+i7,hu-5)hl=o(hl,d4-dq+i6/2,d4+dq-i6/2)i5=o(i5,d5-dq+i7,d5+dq)else hl=d4+i8;i5=d5 end;for i9,bd in pairs(hJ)do local ia=bd.textPositions;local ib=ia.y-i5;if i9~=i and aV(ib)<ia.height and ia.x+ia.width>hl and ia.x<hl+i6 then if dq>i6 then i5=o(i5+i7,ha+15,hu-5)else i5=ia.y+ia.height+1 end end end;local ic=hZ~=A.name or hl<=hr and hl+i6>=hr and i5-i7<=hs and i5>=hs;bd.hovered=ic;local id=1;if ic then id=2;if dq*2<i6 then id=10 end;if hZ==A.name then hZ=hZ.." - "..distance end;fe="pbright"if A.systemId~=0 then i6=ey(string.len(hZ)*5)i8=-(15+i6)else i6=ey(string.len(hZ)*7)end;if dq*2>i6 then hl=o(d4,h9+i6/2,ht-i6/2)hl=o(hl,d4-dq+i6/2,d4+dq-i6/2)else hl=d4+i8 end end;hJ[i]={}hJ[i].textPositions={}hJ[i].textPositions.y=i5;hJ[i].textPositions.x=hl;hJ[i].textPositions.width=i6;hJ[i].textPositions.height=i7;hJ[i].output=""if dq*2>i6 then fe=fe.." txtmid"else fe=fe.." txtstart"end;if hY-dq>2 then hJ[i].output=n('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',d4,d5,hY,er,0.1*id)end;hJ[i].output=hJ[i].output..n('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',d4,d5,dq,er,0.2*id)if A.systemId==0 then hJ[i].output=hJ[i].output..n([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],hl,i5,eq,fe,hZ)if dq*2<=i6 then hJ[i].output=hJ[i].output..n("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",hl+i6,i5+2,hl,i5+2,d4,d5)end else hJ[i].output=hJ[i].output..n([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],hl,i5,er,fe,hZ)if dq*2<=i6 then hJ[i].output=hJ[i].output..n("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",hl,i5+2,hl+i6,i5+2,d4,d5)end end end;for N=#planetAtlas,1,-1 do if hJ[N]then fj[#fj+1]=hJ[N].output end end;if hN~=nil and scopeFOV<90 and not hN.hovered then local ie=hN.planet.atmosphereRadius/hN.atmoSize;local ig=r(hM)*ie;local ih=e4(ig,1)local i6=ey(math.max(string.len(ih)*7,string.len(hN.planet.name)*7))local i7=ez(12)local hl=o(hN.x+(hr-hN.x)/2,h9+i6/2,ht-i6/2)local i5=o(hN.y+(hs-hN.y)/2,ha+i7*2,hu-5)fj[#fj+1]=n("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",hN.x,hN.y,hr,hs)fj[#fj+1]=n([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],hl,i5,"white",ih)if not hN.visible then fj[#fj+1]=n([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],hl,i5-i7,"white",hN.planet.name)end end;if velMag>1 then local cj=constructVelocity;local hP=cj:normalize()local hS=cj:project_on_plane(hI):len()local hQ=cj:cross(hI):normalize()local hR=math.acos(hQ:dot(hH))if hR~=hR then hR=0 end;if hQ:cross(hH):dot(hI)<0 then hR=-hR end;local hT=math.sin(hR)*math.asin(hS/cj:len())*constants.rad2deg;local hU=math.cos(hR)*math.asin(hS/cj:len())*constants.rad2deg;if hP:dot(hI)<0 then hU=90*math.cos(hR)+90*math.cos(hR)-hU;hT=90*math.sin(hR)+90*math.sin(hR)-hT end;local d4=hr+hT/hF*hn;local d5=hs+hU/hF*hn;local ge=14;local gf=ge/2;local gi=[[<circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..gf/ge..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..d4-ge..[[,]]..d5 ..[[ h ]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..d4+gf..[[,]]..d5 ..[[ h ]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..d4 ..[[,]]..d5-ge..[[ v ]]..gf..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]fj[#fj+1]=gi end;fj[#fj+1]=n("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",hr,hs-10,hr,hs+10)fj[#fj+1]=n("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",hr-10,hs,hr+10,hs)fj[#fj+1]='</g>'else return fj end end;local function ii(ij,ik)local il;local im=(ik-ij):normalize()local bh=(worldPos-ij):dot(im)/im:dot(im)if bh<=0.then return(worldPos-ij):len()elseif bh>=(ik-ij):len()then return(worldPos-ik):len()end;local io=ij+bh*im;il=(io-worldPos):len()return il end;local function ip()local il;local iq=nil;local ir=nil;local is=nil;for N,it in pairs(e[0])do if it.hasAtmosphere then local distance=ii(planet.center,it.center)if iq==nil or distance<iq then ir=it;iq=distance;is=planet end;if autopilotTargetPlanet and autopilotTargetPlanet.hasAtmosphere and autopilotTargetPlanet.name~=planet.name then local aM=ii(autopilotTargetPlanet.center,it.center)if aM<iq then ir=it;iq=aM;is=autopilotTargetPlanet end end end end;local iu=ey(1770)local iv=ez(330)if iq then local iw="txttick "local ix=500000;if iq<ir.radius+ix or iq<is.radius+ix then if notPvPZone then iw="txttick red "else iw="txttick orange "end end;il=e4(iq,2)ei=cb(iu,iv,"Pipe ("..is.name.."--"..ir.name.."): "..il,iw.."pbright txtmid")end end;local function iy(d4,d5,iz,iA,gr)local iB={x=d4,y=d5,width=iz,height=iA,label=gr}ec[gr]=iB;return iB end;local function iC(iD,iE,iz,iA,d4,d5,iF,iG,iH,iI,fe)local iB={enableName=iD,disableName=iE,width=iz,height=iA,x=d4,y=d5,toggleVar=iF,toggleFunction=iG,drawCondition=iH,hovered=false,class=fe}if iI then table.insert(eb,iB)else table.insert(ea,iB)end;return iB end;local function iJ(iK)if not eg then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif iK=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif iK=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif iK=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then eh=e3(iK)showHud=false else eh="none"showHud=true end end;local function iL()eg=not eg;if eg then e9=eb;l("Tap LMB to see Settings")oldShowHud=showHud else e9=ea;l("Tap LMB to see Control Buttons")iJ()showHud=oldShowHud end end;local function iM()local function iN(A,N)A.set(not A.get())if A.get()then l(N.." set to true")else l(N.." set to false")end;if N=="showHud"then oldShowHud=A.get()elseif N=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local iO=50;local iP=340;local d4=500;local d5=ResolutionY/2-400;local iQ=0;for N,A in pairs(e3("boolean"))do if type(A.get())=="boolean"then iC(N,N,iP,iO,d4,d5,function()return A.get()end,function()iN(A,N)end,function()return true end,true)d5=d5+iO+20;if iQ==9 then d4=d4+iP+20;d5=ResolutionY/2-400;iQ=0 else iQ=iQ+1 end end end;iC("Control View","Control View",iP,iO,10,ResolutionY/2-500,function()return true end,iL,function()return true end,true)iC("View Handling Settings",'Hide Handling Settings',iP,iO,10,ResolutionY/2-(500-iO),function()return showHandlingVariables end,function()iJ("handling")end,function()return true end,true)iC("View Hud Settings",'Hide Hud Settings',iP,iO,10,ResolutionY/2-(500-iO*2),function()return showHudVariables end,function()iJ("hud")end,function()return true end,true)iC("View Physics Settings",'Hide Physics Settings',iP,iO,10,ResolutionY/2-(500-iO*3),function()return showPhysicsVariables end,function()iJ("physics")end,function()return true end,true)end;local function iR()local function bX()local position=worldPos;local bY=planet.name..". "..#SavedLocations;if RADAR then bY=RADAR.GetClosestName(bY)end;return ATLAS.AddNewLocation(bY,position,false,true)end;local function iS()TurnBurn=not TurnBurn end;local function iT(iU)if iU==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;followMode=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function iV(iW,iX)ATLAS.UpdatePosition(nil,iW,iX)end;local function bT()ATLAS.ClearCurrentPosition()end;local function iY(bW)local h1=AP.routeWP(true)if h1 and#h1>0 then return"Engage Route: "..h1[1]end;return"Engage Autopilot: "..g_(bW)end;local function iZ(bW)local h1=AP.routeWP(true)if h1 and#h1>0 then return"Next Route Point: "..h1[1]end;return"Disable Autopilot: "..g_(bW)end;local function i_()if d_()==1 then followMode=not followMode;if followMode then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;d.control.retractLandingGears()e0:setTargetGroundAltitude(TargetHoverHeight)bE("folOn","F")else bE("folOff","F")BrakeIsOn="Follow Off"autoRoll=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then d.control.deployLandingGears()e0:setTargetGroundAltitude(LandingGearGroundHeight)end end else l("Follow Mode only works with Remote controller")followMode=false end end;local iO=50;local iP=260;local j0=ey(30)local j1=OrbitMapX+OrbitMapSize*2+2;local j2=OrbitMapY+1;iC("+","+",j0,j0,j1,j2+j0+1,function()return false end,function()scopeFOV=scopeFOV/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")iC("-","-",j0,j0,j1,j2,function()return false end,function()scopeFOV=math.min(scopeFOV*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")iC("0","0",j0,j0,j1,j2+j0*2+2,function()return false end,function()scopeFOV=90 end,function()return SelectedTab=="SCOPE"and scopeFOV~=90 end,nil,"ZoomButton")local j3=iC("Enable Brake Toggle","Disable Brake Toggle",iP,iO,ResolutionX/2-iP/2,ResolutionY/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then l("Brakes in Toggle Mode")else l("Brakes in Default Mode")end end)iC("Align Prograde","Disable Prograde",iP,iO,ResolutionX/2-iP/2-50-j3.width,ResolutionY/2-iO+380,function()return ProgradeIsOn end,function()iT(1)end)iC("Align Retrograde","Disable Retrograde",iP,iO,ResolutionX/2-iP/2+j3.width+50,ResolutionY/2-iO+380,function()return RetrogradeIsOn end,iT,function()return atmosDensity==0 end)apbutton=iC(iY,iZ,600,60,ResolutionX/2-600/2,ResolutionY/2-60/2-330,function()return Autopilot or VectorToTarget or spaceLaunch or IntoOrbit end,function()end)local i;local function j4(j5)local bW=apScrollIndex+j5;if bW>#AtlasOrdered then bW=bW-#AtlasOrdered-1 end;if bW<0 then bW=#AtlasOrdered+bW end;return bW end;apExtraButtons={}for i=0,10 do local button=iC(function(aA)local bW=j4(aA.apExtraIndex)if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then return"Redirect: "..g_(bW)end;return iY(bW)end,function(aA)local bW=j4(aA.apExtraIndex)return iZ(bW)end,600,60,ResolutionX/2-600/2,ResolutionY/2-60/2-330+60*i,function(aA)local bW=j4(aA.apExtraIndex)return bW==AutopilotTargetIndex and(Autopilot or VectorToTarget or spaceLaunch or IntoOrbit)end,function(aA)local bW=j4(aA.apExtraIndex)local j6=AutopilotTargetIndex==bW;AutopilotTargetIndex=bW;ATLAS.UpdateAutopilotTarget()AP.ToggleAutopilot()if not j6 and not(Autopilot or VectorToTarget or spaceLaunch or IntoOrbit)then AP.ToggleAutopilot()end end,function()return apButtonsHovered and(#AP.routeWP(true)==0 or i==0)end)button.apExtraIndex=i;apExtraButtons[i]=button end;iC("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,bX,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)iC("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,function()iV(nil)end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)iC("Save Heading","Clear Heading",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height+20,function()return CustomTarget.heading~=nil end,function()if CustomTarget.heading~=nil then iV(false)else iV(true)end end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)iC("Save AGG Alt","Clear AGG Alt",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height*2+40,function()return CustomTarget.agg~=nil end,function()if CustomTarget.agg~=nil then iV(nil,false)else iV(nil,true)end end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil and antigrav end)iC("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,bT,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)iC("Save Route","Save Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height*2+40,function()return false end,function()AP.routeWP(false,false,2)end,function()return#AP.routeWP(true)>0 end)iC("Load Route","Clear Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height+20,function()return#AP.routeWP(true)>0 end,function()if#AP.routeWP(true)>0 then AP.routeWP(false,true)elseif Autopilot or VectorToTarget then l("Disable Autopilot before loading route")return else AP.routeWP(false,false,1)end end,function()return true end)iO=60;iP=300;local d4=0;local d5=ResolutionY/2-150;iC("Enable Check Damage","Disable Check Damage",iP,iO,d4,d5-iO-20,function()return ShouldCheckDamage end,function()ShouldCheckDamage=not ShouldCheckDamage end)iC("View Settings","View Settings",iP,iO,d4,d5,function()return true end,iL)d5=d5+iO+20;iC("Enable Turn and Burn","Disable Turn and Burn",iP,iO,d4,d5,function()return TurnBurn end,iS)d4=10;d5=ResolutionY/2-300;iC("Horizontal Takeoff Mode","Vertical Takeoff Mode",iP,iO,ResolutionX/2-iP/2,d5+20,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then l("Vertical Takeoff Mode")else l("Horizontal Takeoff Mode")end end,function()return UpVertAtmoEngine end)d5=d5+iO+20;iC("Engage Orbiting","Cancel Orbiting",iP,iO,d4+iP+20,d5,function()return IntoOrbit end,AP.ToggleIntoOrbit,function()return atmosDensity==0 and nearPlanet end)d5=ResolutionY/2-150;iC("Glide Re-Entry","Cancel Glide Re-Entry",iP,iO,d4+iP+20,d5,function()return Reentry end,function()spaceLand=1;iT(1)end,function()return planet.hasAtmosphere and not inAtmo end)d5=d5+iO+20;iC("Parachute Re-Entry","Cancel Parachute Re-Entry",iP,iO,d4+iP+20,d5,function()return Reentry end,function()spaceLand=2;iT(1)end,function()return planet.hasAtmosphere and not inAtmo end)d5=d5+iO+20;iC("Engage Follow Mode","Disable Follow Mode",iP,iO,d4,d5,function()return followMode end,i_,function()return d_()==1 end)iC("Enable Repair Arrows","Disable Repair Arrows",iP,iO,d4+iP+20,d5,function()return ew end,function()ew=not ew;if ew then l("Repair Arrows Enabled")else l("Repair Arrows Diabled")end end,function()return d_()==1 end)d5=d5+iO+20;if not ExternalAGG then iC("Enable AGG","Disable AGG",iP,iO,d4,d5,function()return antigravOn end,AP.ToggleAntigrav,function()return antigrav~=nil end)end;iC(function()return n("Switch IPH Mode - Current: %s",iphCondition)end,function()return n("IPH Mode: %s",iphCondition)end,iP*2,iO,d4,d5,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons-Asteroids"else iphCondition="All"end;l("IPH Mode: "..iphCondition)end)d5=d5+iO+20;iC(function()return n("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return n("Control Scheme: %s",userControlScheme)end,iP*2,iO,d4,d5,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;l("New Control Scheme: "..userControlScheme)end)local j7=ez(20)local button=iy(0,0,ey(70),j7,"HELP")button=iy(button.x+button.width,button.y,ey(80),j7,"INFO")button=iy(button.x+button.width,button.y,ey(70),j7,"ORBIT")button=iy(button.x+button.width,button.y,ey(70),j7,"SCOPE")iy(button.x+button.width,button.y,ey(70),j7,"HIDE")end;local j8={}local j9=nil;function j8.HUDPrologue(fj)if not notPvPZone then en=PvPR;eo=PvPG;ep=PvPB else en=SafeR;eo=SafeG;ep=SafeB end;eq=[[rgb(]]..h(en+0.6)..","..h(eo+0.6)..","..h(ep+0.6)..[[)]]er=[[rgb(]]..h(en*0.8+0.5)..","..h(eo*0.8+0.5)..","..h(ep*0.8+0.5)..[[)]]local ja=eq;local jb=er;local jc=[[rgb(]]..h(en*0.4+0.5)..","..h(eo*0.4+0.5)..","..h(ep*0.4+0.5)..[[)]]local jd=eq;local je=er;local jf=jc;if eA()and not brightHud then ja=[[rgb(]]..h(en*0.5+0.5)..","..h(eo*0.5+0.5)..","..h(ep*0.5+0.5)..[[)]]jb=[[rgb(]]..h(en*0.3+0.5)..","..h(eo*0.3+0.5)..","..h(ep*0.2+0.5)..[[)]]jc=[[rgb(]]..h(en*0.2+0.5)..","..h(eo*0.2+0.5)..","..h(ep*0.2+0.5)..[[)]]end;local gO=ey;local gP=ez;fj[#fj+1]=n([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],ja,ja,ja,jd,jd,jb,jb,je,je,jb,ja,jc,je,ja,ja,jc,jc,jf,jc,ResolutionX,ResolutionY,jb,jb,jb,jb,jb,jd,jb,je,jf,je,je,jf)if not j9 then j9=n([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],gO(630),gP(0),gO(675),gP(45),gO(960),gP(55),gO(1245),gP(45),gO(1290),gP(0),gO(1000),gP(105),gO(1040),gP(59),gO(1250),gP(51),gO(1300),gP(0),gO(1920),gP(0),gO(1920),gP(20),gO(1400),gP(20),gO(1300),gP(105),gO(920),gP(105),gO(880),gP(59),gO(670),gP(51),gO(620),gP(0),gO(0),gP(0),gO(0),gP(20),gO(520),gP(20),gO(620),gP(105),gO(890),gP(59),gO(960),gP(62),gO(1030),gP(59),gO(985),gP(112),gO(1150),gP(112),gO(1100),gP(152),gO(820),gP(152),gO(780),gP(112),gO(935),gP(112),gO(890),gP(59),gO(960),gP(62),gO(1030),gP(59),gO(985),gP(112),gO(1150),gP(112),gO(1100),gP(152),gO(820),gP(152),gO(780),gP(112),gO(935),gP(112))end;if showHud and DisplayOdometer then fj[#fj+1]=j9 end;return fj end;function j8.DrawVerticalSpeed(fj,a4)fi(fj,a4)end;function j8.UpdateHud(fj)local g7=adjustedPitch;local jg=adjustedRoll;local fq=jg;local fF=g7;local gp=h(c.getThrottle())local gu=velMag*3.6;local gq=c.getAxisCommandValue(0)local jh=ey(1770)local ji=ez(310)if AtmoSpeedAssist and throttleMode then gq=PlayerThrottle;gp=PlayerThrottle*100 end;local eC=eB()local fr="ROLL"if gp==nil then gp=0 end;if not nearPlanet then if velMag>5 then g7=g6(coreVelocity)jg=g8(coreVelocity)else g7=0;jg=0 end;fr="YAW"end;if pvpDist>50000 and not inAtmo then local jj;jj=e4(pvpDist)fj[#fj+1]=cb(jh,ji,"PvP Boundary: "..jj,"pbright txtbig txtmid")end;fj[#fj+1]=eu;fj[#fj+1]=dE;if ei~=""then fj[#fj+1]=ei end;if eD~=""then fj[#fj+1]=eD end;if eE~=""then fj[#fj+1]=eE end;fi(fj,coreAltitude)if d_()==0 or RemoteHud then if not eA()or brightHud then if nearPlanet then fp(fj,centerX,centerY,fq,fr,nearPlanet)fE(fj,fF,fq,centerX,centerY,nearPlanet,h(g8(coreVelocity)),velMag)else fp(fj,centerX,centerY,jg,fr,nearPlanet)fE(fj,g7,jg,centerX,centerY,nearPlanet,h(jg),velMag)end;fM(fj,coreAltitude,nearPlanet)g9(fj,coreVelocity,velMag,centerX,centerY)end end;go(fj,eC,gp,gq)gt(fj,gu)gy(fj)h8(fj)if not eg and holdingShift then h0(fj)end;return fj end;function j8.HUDEpilogue(fj)fj[#fj+1]="</svg>"return fj end;function j8.ExtraData(fj)local jk=ey(1240)local jl=ez(55)local jm=jl+10;local jn;local gO=ey;local gP=ez;local jo=0;local eC=eB()if VertTakeOffEngine then eC=eC.."-VERTICAL"end;if CollisionSystem and cm and not AutoTakeoff and not BrakeLanding and velMag>20 then eC=eC.."-COLLISION ON"end;if UseExtra~="Off"then eC="("..UseExtra..")-"..eC end;if TurnBurn then eC="TB-"..eC end;if HoverMode then eC="HOVERMODE-"..eC end;if not stablized then eC=eC.."-DeCoupled"end;local jp=gP(99)local jq=gP(80)local jr=gP(85)local js=gP(31)local jt=0;local ju=0;local a_=coreMass>1000000 and bF(coreMass/1000000,2).."kT"or bF(coreMass/1000,2).."T"if inAtmo then jo=LastMaxBrakeInAtmo else jo=LastMaxBrake end;local jv,jw=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,jo)if jv<0 then jv=0 end;jo=bF(jo/(coreMass*e8),2).."g"local jx=d:maxForceForward()jn=b.getGravityIntensity()if jn>0.1 then ju=coreMass*jn;ju=bF(ju/(coreMass*e8),2).."g"jt=0.5*jx/jn;jt=jt>1000000 and bF(jt/1000000,2).."kT"or bF(jt/1000,2).."T"end;jx=bF(jx/(coreMass*e8),2).."g"local jy=vec3(k.getWorldAcceleration()):len()/9.80665;jn=b.getGravityIntensity()fj[#fj+1]=[[<g class="dim txt txtend size14">]]if d_()==1 and not RemoteHud then jk=ey(1120)jl=ez(55)jm=jl+10 elseif inAtmo and DisplayOdometer then local jz=ey(770)fj[#fj+1]=cb(gO(895),jp,"ATMO","")fj[#fj+1]=n([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],gO(895),jr,gO(-80))fj[#fj+1]=cb(gO(815),jq,n("%.1f%%",atmosDensity*100),"txtstart size20")end;if DisplayOdometer then fj[#fj+1]=cb(gO(1025),jp,"GRAVITY","txtstart")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(1025),jr,gO(80))fj[#fj+1]=cb(gO(1105),jq,n("%.2fg",jn/9.80665),"size20")fj[#fj+1]=cb(gO(1125),jp,"ACCEL","txtstart")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(1125),jr,gO(80))fj[#fj+1]=cb(gO(1205),jq,n("%.2fg",jy),"size20")fj[#fj+1]=cb(gO(695),jp,"BRK TIME","")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(695),jr,gO(-80))fj[#fj+1]=cb(gO(615),jq,n("%s",e5(jw)),"txtstart size20")fj[#fj+1]=cb(gO(635),gP(45),"TRIP","")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(635),gP(31),gO(-90))if travelTime then fj[#fj+1]=cb(gO(545),gP(26),n("%s",e5(travelTime)),"txtstart size20")end;fj[#fj+1]=cb(gO(795),jp,"BRK DIST","")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(795),jr,gO(-80))fj[#fj+1]=cb(gO(715),jq,n("%s",e4(jv)),"txtstart size20")fj[#fj+1]=cb(gO(1285),gP(45),"MASS","txtstart")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(1285),gP(31),gO(90))fj[#fj+1]=cb(gO(1375),gP(26),n("%s",a_),"size20")fj[#fj+1]=cb(gO(1220),jp,"THRUST","txtstart")fj[#fj+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],gO(1220),jr,gO(80))fj[#fj+1]=cb(gO(1300),jq,n("%s",jx),"size20")fj[#fj+1]=cb(ey(960),ez(175),eC,"pbright txtbig txtmid size20")end;fj[#fj+1]="</g>"end;local jA=1-(ContainerOptimization*0.05+FuelTankOptimization*0.05)function j8.FuelUsed(jB)local jC;if jB=="atmofueltank"then jC=n("Atmo Fuel Used: %.1f L",eV[jB]/(4*jA))elseif jB=="spacefueltank"then jC=n("Space Fuel Used: %.1f L",eV[jB]/(6*jA))else jC=n("Rocket Fuel Used: %.1f L",eV[jB]/(0.8*jA))end;return jC end;local jD,jE,jF,jG,jH=0,0,0,{},0;local jI=0;local jJ=0;local jK=0;local jL=0;function j8.DrawOdometer(fj,es,TotalDistanceTravelled,et)if SelectedTab~="INFO"then return fj end;local jn;local jo=0;local ju=0;local a_=coreMass>1000000 and bF(coreMass/1000000,2).." kTons"or bF(coreMass/1000,2).." Tons"if inAtmo then jo=LastMaxBrakeInAtmo else jo=LastMaxBrake end;local jv,jw=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,jo)local jx=d:maxForceForward()jn=b.getGravityIntensity()if velMag<5 and abvGndDet~=-1 then local jM=vec3(k.getOrientationForward())local jN=k.getMaxThrustAlongAxis('thrust analog longitudinal ',{jM:unpack()})jI=0.5*jN[1]/jn;jI=jI>1000000 and bF(jI/1000000,1).." kTons"or bF(jI/1000,1).." Tons"jJ=0.5*jN[3]/jn;jJ=jJ>1000000 and bF(jJ/1000000,1).." kTons"or bF(jJ/1000,1).." Tons"jM=vec3(k.getOrientationUp())jN=k.getMaxThrustAlongAxis('hover_engine, booster_engine',{jM:unpack()})jK=0.5*jN[1]/jn;jK=jK>1000000 and bF(jK/1000000,1).." kTons"or bF(jK/1000,1).." Tons"jL=0.5*jo/jn;jL=jL>1000000 and bF(jL/1000000,1).." kTons"or bF(jL/1000,1).." Tons"end;jo=bF(jo/(coreMass*e8),2).." g"if jn>0.1 then ju=coreMass*jn;ju=bF(ju/(coreMass*e8),2).." g"else ju="n/a"end;jx=bF(jx/(coreMass*e8),2).." g"if d_()==0 or RemoteHud then local jO=ey(OrbitMapX+10)local jP=ez(OrbitMapY+20)local jQ=ey(OrbitMapX+10+OrbitMapSize/1.25)local iA=25;local jR=h(1/hudTickRate)if jF<jR then jH=jH+a.getActionUpdateDeltaTime()jF=jF+1 else jD=1/(jH/jR)table.insert(jG,jD)jF,jH=0,0 end;jE=0;for N,A in pairs(jG)do jE=jE+A end;if#jG>0 then jE=h(jE/#jG)end;if#jG>29 then table.remove(jG,1)end;fj[#fj+1]="<g class='txtstart size14 bright'>"fj[#fj+1]=cb(jO,jP,n("BrkTime: %s",e5(jw)))fj[#fj+1]=cb(jQ,jP,n("Trip: %.2f km",es))fj[#fj+1]=cb(jO,jP+iA,n("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))fj[#fj+1]=cb(jQ,jP+iA,n("BrkDist: %s",e4(jv)))fj[#fj+1]=cb(jO,jP+iA*2,"Trip Time: "..e5(et))fj[#fj+1]=cb(jQ,jP+iA*2,"Total Time: "..e5(TotalFlightTime))fj[#fj+1]=cb(jO,jP+iA*3,n("Mass: %s",a_))fj[#fj+1]=cb(jQ,jP+iA*3,n("Safe Brake Mass: %s",jL))fj[#fj+1]=cb(jO,jP+iA*4,n("Max Thrust: %s",jx))fj[#fj+1]=cb(jQ,jP+iA*4,n("Safe Atmo Mass: %s",jI))fj[#fj+1]=cb(jO,jP+iA*5,n("Max Brake: %s",jo))fj[#fj+1]=cb(jQ,jP+iA*5,n("Safe Space Mass: %s",jJ))fj[#fj+1]=cb(jQ,jP+iA*6,n("Safe Hover Mass: %s",jK))fj[#fj+1]=cb(jO,jP+iA*6,n("Influence: %s",planet.name))fj[#fj+1]=cb(jO,jP+iA*7,n("Set Max Speed: %s",h(MaxGameVelocity*3.6+0.5)))fj[#fj+1]=cb(jQ,jP+iA*7,n("Actual Max Speed: %s",h(MaxSpeed*3.6+0.5)))fj[#fj+1]=cb(jO,jP+iA*8,n("Friction Burn Speed: %s",h(k.getFrictionBurnSpeed()*3.6)))fj[#fj+1]=cb(jQ,jP+iA*8,n("FPS (Avg): %s (%s)",h(jD),jE))end;fj[#fj+1]="</g></g>"return fj end;function j8.DrawWarnings(fj)return gy(fj)end;function j8.DisplayOrbitScreen(fj)return h8(fj)end;function j8.DisplayMessage(fj,gI)if gI~="empty"then local d5=310;for gK in string.gmatch(gI,"([^\n]+)")do d5=d5+35;fj[#fj+1]=cb("50%",d5,gK,"msg")end end;if msgTimer~=0 then c.setTimer("msgTick",msgTimer)msgTimer=0 end end;function j8.DrawDeadZone(fj)fj[#fj+1]=n([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function j8.UpdatePipe()if inAtmo then ei=""return end;ip()end;function j8.DrawSettings(fj)local d4=ey(640)local d5=ez(200)fj[#fj+1]=[[<g class="pbright txtvspd txtstart">]]local dl=0;for N,A in pairs(eh)do dl=dl+1;fj[#fj+1]=cb(d4,d5,N..": "..A.get())d5=d5+20;if dl%12==0 then d4=d4+ey(350)d5=ez(200)end end;fj[#fj+1]=cb(ey(640),ez(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fj[#fj+1]="</g>"return fj end;local dD=ez(125)local dC=ey(1225)function j8.DrawRadarInfo()dE=RADAR.GetRadarHud(dC,dD,radarX,radarY)if dE then cm=true end end;function j8.DrawTanks()if fuelX~=0 and fuelY~=0 then eD=cb(fuelX,fuelY,"","txtstart pdim txtfuel")eW=fuelY;eX(fuelX,"Atmospheric ","ATMO",atmoTanks,eT,eU)eX(fuelX,"Space Fuel T","SPACE",spaceTanks,eR,eS)eX(fuelX,"Rocket Fuel ","ROCKET",rocketTanks,eP,eQ)end end;function j8.DrawShield()local dM=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local jS=k.getPvPTimer()local jT=shield.getResistances()local jU="A: "..10+jT[1]*100 .."% / E: "..10+jT[2]*100 .."% / K:"..10+jT[3]*100 .."% / T: "..10+jT[4]*100 .."%"local d4,d5=shieldX-60,shieldY+30;local fc=h(shieldPercent*2.55)local fd=n("rgb(%d,%d,%d)",255-fc,fc,0)local fe=""eE=cb(d4,d5,"","txtmid pdim txtfuel")if shieldPercent<10 and dM~="Shield Disabled"then fe="red "end;jS=jS>0 and"   PvPTime: "..e5(jS)or""eE=eE..n([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],d4,d5,fd,shieldPercent*2,d4,d5,d4+2,d5+10,shieldPercent,jS)eE=eE..cb(d4,d5-5,dM,fe.."txtstart pbright txtbig")eE=eE..cb(d4,d5+30,jU,fe.."txtstart pbright txtsmall")end;function j8.hudtick()if not planet then return end;local function jV(fj)local fg=h(o(mouseDistance/(ResolutionX/4)*255,0,255))fj[#fj+1]=n("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",simulatedX,simulatedY,h(en+0.5)+fg,h(eo+0.5)-fg,h(ep+0.5)-fg)end;local function jW()if leftmouseclick then for _,A in pairs(e9)do if A.hovered then if not A.drawCondition or A.drawCondition(A)then A.toggleFunction(A)end;A.hovered=false end end;for _,A in pairs(ec)do if A.hovered then SelectedTab=A.label;A.hovered=false end end;leftmouseclick=false end end;local function jX()local function jY(jZ,j_,d4,d5,iz,iA)if jZ>=d4 and jZ<=d4+iz and j_>=d5 and j_<=d5+iA then return true else return false end end;local d4=simulatedX+ResolutionX/2;local d5=simulatedY+ResolutionY/2;for _,A in pairs(e9)do A.hovered=jY(d4,d5,A.x,A.y,A.width,A.height)end;for _,A in pairs(ec)do A.hovered=jY(d4,d5,A.x,A.y,A.width,A.height)end;if apButtonsHovered then local ic=false;for _,aA in ipairs(apExtraButtons)do if aA.hovered then ic=true;break end end;if apbutton.hovered then ic=true end;apButtonsHovered=ic else apButtonsHovered=apbutton.hovered;if not apButtonsHovered then apScrollIndex=AutopilotTargetIndex end end end;local function k0(fj)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;if showHud then for N,A in pairs(ec)do local fe="dim brightstroke"local k1=0.2;if SelectedTab==N then fe="pbright dimstroke"k1=0.6 end;local k2=""if A.hovered then k1=0.8;k2=";stroke:white"end;fj[#fj+1]=n([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],A.width,A.height,A.x,A.y,fe,k1,k2)fj[#fj+1]=cb(A.x+A.width/2,A.y+A.height/2+5,A.label,"txt txtmid pdim")end end end;local function k3(fj)local function k4(fj,k5,hover,d4,d5,k6,k7,k8,k9,ka,kb,button)if type(ka)=="function"then ka=ka(button)end;if type(kb)=="function"then kb=kb(button)end;fj[#fj+1]=n("<rect x='%f' y='%f' width='%f' height='%f' fill='",d4,d5,k6,k7)if k5 then fj[#fj+1]=n("%s'",k8)else fj[#fj+1]=k9 end;if hover then fj[#fj+1]=n(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else fj[#fj+1]=n(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",bF(SafeR*0.5,0),bF(SafeG*0.5,0),bF(SafeB*0.5,0))end;fj[#fj+1]=" rx='5'></rect>"fj[#fj+1]=n("<text x='%f' y='%f' font-size='24' fill='",d4+k6/2,d5+k7/2+5)if k5 then fj[#fj+1]="black"else fj[#fj+1]="white"end;fj[#fj+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if k5 then fj[#fj+1]=n("%s</text>",ka)else fj[#fj+1]=n("%s</text>",kb)end end;local kc=n("rgb(%d,%d,%d)'",bF(SafeR*0.1,0),bF(SafeG*0.1,0),bF(SafeB*0.1,0))local kd=n("rgb(%d,%d,%d)",bF(SafeR*0.8,0),bF(SafeG*0.8,0),bF(SafeB*0.8,0))local ke=k4;for _,A in pairs(e9)do local iE=A.disableName;local iD=A.enableName;if type(iE)=="function"then iE=iE(A)end;if type(iD)=="function"then iD=iD(A)end;if not A.drawCondition or A.drawCondition(A)then ke(fj,A.toggleVar(A),A.hovered,A.x,A.y,A.width,A.height,kd,kc,iE,iD,A)end end end;local kf=bF(ResolutionX/2,0)local kg=bF(ResolutionY/2,0)local fj={}if userScreen then fj[#fj+1]=userScreen end;HUD.HUDPrologue(fj)if showHud then HUD.UpdateHud(fj)else if AlwaysVSpd then HUD.DrawVerticalSpeed(fj,coreAltitude)end;HUD.DrawWarnings(fj)end;if eg and eh~="none"then HUD.DrawSettings(fj)end;if RADAR then HUD.DrawRadarInfo()else dE=""end;HUD.HUDEpilogue(fj)fj[#fj+1]=n([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ResolutionX,ResolutionY)if msgText~="empty"then HUD.DisplayMessage(fj,msgText)end;if d_()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then HUD.DrawDeadZone(fj)end end;k0(fj)if e1()==0 then if d_()==1 and holdingShift then if not AltIsOn then jX()k3(fj)end;if not Animating and not Animated then local kh=table.concat(fj,"")fj={}fj[#fj+1]=n("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ResolutionX,ResolutionY)fj[#fj+1]=kh;fj[#fj+1]="</body>"Animating=true;fj[#fj+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif Animated then local kh=table.concat(fj,"")fj={}fj[#fj+1]=n("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ResolutionX,ResolutionY)fj[#fj+1]=kh;fj[#fj+1]="</body>"end;if not Animating then fj[#fj+1]=n([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],kf,kg,simulatedX,simulatedY)end else jW()end else if not holdingShift and d_()==0 then jW()if mouseDistance>DeadZone then if DisplayDeadZone then jV(fj)end end elseif holdingShift and(not AltIsOn or not freeLookToggle)then jX()k3(fj)end;fj[#fj+1]=n([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],kf,kg,simulatedX,simulatedY)end;fj[#fj+1]=[[</svg></body>]]content=table.concat(fj,"")end;function j8.TenthTick()local function ki()local kj=a.createData;local kk=a.createWidget;panelInterplanetary=a.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kk(panelInterplanetary,"value")interplanetaryHeaderText=kj('{"label": "Target Planet", "value": "N/A", "unit":""}')bD(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kk(panelInterplanetary,"value")widgetDistanceText=kj('{"label": "distance", "value": "N/A", "unit":""}')bD(widgetDistanceText,widgetDistance)widgetTravelTime=kk(panelInterplanetary,"value")widgetTravelTimeText=kj('{"label": "Travel Time", "value": "N/A", "unit":""}')bD(widgetTravelTimeText,widgetTravelTime)widgetTargetOrbit=kk(panelInterplanetary,"value")widgetTargetOrbitText=kj('{"label": "Target Altitude", "value": "N/A", "unit":""}')bD(widgetTargetOrbitText,widgetTargetOrbit)widgetStopSpeed=kk(panelInterplanetary,"value")widgetStopSpeedText=kj('{"label": "End Speed", "value": "N/A", "unit":""}')widgetCurBrakeDistance=kk(panelInterplanetary,"value")widgetCurBrakeDistanceText=kj('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kk(panelInterplanetary,"value")widgetCurBrakeTimeText=kj('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kk(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kj('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kk(panelInterplanetary,"value")widgetMaxBrakeTimeText=kj('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kk(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kj('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then bD(widgetStopSpeedText,widgetStopSpeed)bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)bD(widgetCurBrakeTimeText,widgetCurBrakeTime)bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kl()ca(panelInterplanetary)panelInterplanetary=nil end;HUD.DrawTanks()if shield then HUD.DrawShield()end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then ki()end;if AutopilotTargetName~=nil then local hO;local km=CustomTarget~=nil;local kn=Autopilot and AutopilotEndSpeed*3.6 or 0;bC(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')if km and not Autopilot then hO=(worldPos-CustomTarget.position):len()else hO=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)ek,el=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)ek,el=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local gI=e4(hO)bC(widgetDistanceText,'{"label": "distance", "value": "'..gI..'"}')bC(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..e5(travelTime)..'", "unit":""}')gI=e4(brakeDistance)bC(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..gI..'"}')bC(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..e5(brakeTime)..'", "unit":""}')gI=e4(ek)bC(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..gI..'"}')bC(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..e5(el)..'", "unit":""}')bC(widgetStopSpeedText,'{"label": "End Speed", "value": "'..n("%.0fkph",kn)..'", "unit":""}')gI=e4(AutopilotTargetOrbit)bC(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..gI..'"}')if inAtmo and not WasInAtmo then a.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)a.removeDataFromWidget(widgetStopSpeedText,widgetStopSpeed)a.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)a.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)a.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)a.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then AP.cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if not inAtmo and WasInAtmo then if bC(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if bC(widgetMaxBrakeTimeText,widgetStopSpeed)==1 then bD(widgetStopSpeedText,widgetStopSpeed)end;if bC(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if bC(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then bD(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if bC(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if bC(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kl()end;if warpdrive~=nil then local ko=dY(warpdrive.getWidgetData())if ko.destination~="Unknown"and ko.distance>400000 then if not ex then warpdrive.showWidget()ex=true end elseif ex then warpdrive.hideWidget()ex=false end end end;function j8.OneSecondTick()local function kp()local f6=g()local gu=velMag;local kq=f6-ev;if gu>1.38889 then gu=gu/1000;local kr=gu*(f6-ev)TotalDistanceTravelled=TotalDistanceTravelled+kr;es=es+kr end;et=et+kq;TotalFlightTime=TotalFlightTime+kq;ev=f6 end;local function ks(fj)local kt=0;local ku=e7;local kv=0;local kw=0;local kx=0;local fc=0;local fd=""local ky=b.getElementHitPointsById;local kz=b.getElementMaxHitPointsById;local kA={}for N in pairs(e6)do local kB=0;local kC=0;kC=kz(e6[N])kB=ky(e6[N])kv=kv+kB;if kB+1<kC then if kB==0 then kx=kx+1 else kw=kw+1 end;if ew and#kA==0 then position=vec3(b.getElementPositionById(e6[N]))local d4=position.x;local d5=position.y;local d6=position.z;table.insert(kA,b.spawnArrowSticker(d4,d5,d6+1,"down"))table.insert(kA,b.spawnArrowSticker(d4,d5,d6+1,"down"))b.rotateSticker(kA[2],0,0,90)table.insert(kA,b.spawnArrowSticker(d4+1,d5,d6,"north"))table.insert(kA,b.spawnArrowSticker(d4+1,d5,d6,"north"))b.rotateSticker(kA[4],90,90,0)table.insert(kA,b.spawnArrowSticker(d4-1,d5,d6,"south"))table.insert(kA,b.spawnArrowSticker(d4-1,d5,d6,"south"))b.rotateSticker(kA[6],90,-90,0)table.insert(kA,b.spawnArrowSticker(d4,d5-1,d6,"east"))table.insert(kA,b.spawnArrowSticker(d4,d5-1,d6,"east"))b.rotateSticker(kA[8],90,0,90)table.insert(kA,b.spawnArrowSticker(d4,d5+1,d6,"west"))table.insert(kA,b.spawnArrowSticker(d4,d5+1,d6,"west"))b.rotateSticker(kA[10],-90,0,90)table.insert(kA,e6[N])end elseif ew and#kA>0 and kA[11]==e6[N]then for f5 in pairs(kA)do b.deleteSticker(kA[f5])end;kA={}end end;kt=bF(kv/ku*100,2)if kx>0 or kw>0 then fj[#fj+1]=cb(0,0,"","pbright txt")fc=h(kt*2.55)fd=n("rgb(%d,%d,%d)",255-fc,fc,0)fj[#fj+1]=cb("50%",1035,"Elemental Integrity: "..kt.."%","txtbig txtmid","fill:"..fd)if kx>0 then fj[#fj+1]=cb("50%",1055,"Disabled Modules: "..kx.." Damaged Modules: "..kw,"txtbig txtmid","fill:"..fd)elseif kw>0 then fj[#fj+1]=cb("50%",1055,"Damaged Modules: "..kw,"txtbig txtmid","fill:"..fd)end end end;local function kD()if weapon then if em==nil and(radarPanelId~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,"Weapons","weapon",true)em=_autoconf.panels[_autoconf.panels_size]elseif em~=nil and radarPanelId==nil and not GearExtended then ca(em)em=nil end end end;local fj={}kp()if ShouldCheckDamage then ks(fj)end;kD()HUD.UpdatePipe()HUD.ExtraData(fj)eu=table.concat(fj,"")end;function j8.AnimateTick()Animated=true;Animating=false;simulatedX=0;simulatedY=0;c.stopTimer("animateTick")end;function j8.MsgTick()local fj={}HUD.DisplayMessage(fj,"empty")msgText="empty"c.stopTimer("msgTick")msgTimer=3 end;function j8.ButtonSetup()iM()iR()e9=ea end;if userHud then for N,A in pairs(userHud)do j8[N]=A end end;return j8 end;local function kE(d,b,c,e,vBooster,hover,telemeter_1,antigrav,dbHud_1,aV,h,j,d_,atan,g,o,e0,bC,e1,r,bF,bE,e2,s,e4,e5,kF,dY,l)local a=DUSystem;local k=DUConstruct;local kG={}local kH=false;local kI=0;local kJ=0;local kK=0;local kL=g()local kM=0;local kN=0;local kO=0;local kP=0;local kQ=false;local kR=false;local kS=false;local kT=nil;local kU=0;local ej=55;local kV=nil;local kW=false;local kX=false;local kY=false;local kZ=0;local k_=0;local l0=0;local l1=0;local l2=0;local l3={VectorToTarget=false}local l4=vec3(k.getWorldOrientationUp())local l5=nil;local l6=0;local l7=-1;local l8=-1;local l9=false;local la=false;local lb=0;local lc=false;local ld=false;local le=false;local lf=false;local lg=""local lh=false;local li=false;local lj=""local lk=false;local ll=0;local lm=0;local function ln()return k.isInPvPZone()~=1,aV(k.getDistanceToSafeZone())end;local function lo(fH)local lp=AutopilotEndSpeed;if not Autopilot then lp=0 end;local lq=LastMaxBrake;if inAtmo then if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then lq=LastMaxBrakeInAtmo else return 0,0 end end;return Kinematic.computeDistanceAndTime(fH,lp,coreMass,0,0,lq-AutopilotPlanetGravity*coreMass)end;local function lr(fH)local lp=AutopilotEndSpeed;if not Autopilot then lp=0 end;return Kinematic.computeDistanceAndTime(fH,lp,coreMass,d:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*coreMass)end;local function ls(lt,lu,lv)lu=lu:project_on_plane(lt)lv=lv:project_on_plane(lt)return atan(lu:cross(lv):dot(lt),lu:dot(lv))end;local lw=-1;local lx=-1;local function ly()local function lz()local lA=-1;local lB=-1;if vBooster then lA=vBooster.getDistance()if lA>-1 and lA<0.01 then lA=lw else lw=lA end end;if hover then lB=hover.getDistance()if lB>-1 and lB<0.01 then lB=lx else lx=lB end end;if lA~=-1 and lB~=-1 then if lA<lB then return lA else return lB end elseif lA~=-1 then return lA elseif lB~=-1 then return lB else return-1 end end;local lC=lz()local lD=-1;if antigrav and antigrav.isActive()==1 and not ExternalAGG and velMag<ej then local lE=aV(coreAltitude-antigrav.getBaseAltitude())if lE<50 then return lE end end;if telemeter_1 then lD=telemeter_1.raycast().distance;if lD==0 then lD=-1 end end;if lC~=-1 and lD~=-1 then if lC<lD then return lC else return lD end elseif lC~=-1 then return lC else return lD end end;local function lF(planet,aI,lG)local function lH(lI,Y)local aO=vec3(Y)if lI.id==0 then return setmetatable({latitude=aO.x,longitude=aO.y,altitude=aO.z,id=0,systemId=lI.systemId},MapPosition)end;local aP=aO-lI.center;local distance=aP:len()local a4=distance-lI.radius;local a2=0;local a3=0;if not s(distance,0)then local aQ=atan(aP.y,aP.x)a3=aQ>=0 and aQ or 2*math.pi+aQ;a2=math.pi/2-math.acos(aP.z/distance)end;return setmetatable({latitude=math.deg(a2),longitude=math.deg(a3),altitude=a4,id=lI.id,systemId=lI.systemId},MapPosition)end;local lJ=lH(planet,aI)lJ="::pos{"..lJ.systemId..","..lJ.id..","..lJ.latitude..","..lJ.longitude..","..lJ.altitude.."}"if lG then return lJ else le=lJ;return true end end;local function lK(lL,lM,lN)local function lO(lL,ar)lL=vec3(lL)ar=vec3(ar):normalize()local I=lL*ar;return I.x+I.y+I.z end;local lP=0.001;local lQ=1;if not inAtmo or not stalling or abvGndDet~=-1 or velMag<ej then if lN==nil then lN=DampingMultiplier end;if lM==nil then lM=lP end;lL=vec3(lL):normalize()local lR=vec3()-lL;local lS=-lO(lR,k.getWorldOrientationRight())*lQ;local lT=-lO(lR,k.getWorldOrientationUp())*lQ;if kJ==0 then kJ=lS/2 end;if kK==0 then kK=lT/2 end;if aV(lS)<0.1 then k_=k_-lS*2 else k_=k_-(lS+(lS-kJ)*lN)end;if aV(lT)<0.1 then kZ=kZ+lT*2 else kZ=kZ+lT+(lT-kK)*lN end;kJ=lS;kK=lT;if aV(lS)<lM and aV(lT)<lM then return true end;return false elseif stalling and abvGndDet==-1 then lL=constructVelocity;if lN==nil then lN=DampingMultiplier end;if lM==nil then lM=lP end;lL=vec3(lL):normalize()local lR=constructForward-lL;local lS=-lO(lR,k.getWorldOrientationRight())*lQ;local lT=-lO(lR,k.getWorldOrientationUp())*lQ;if kJ==0 then kJ=lS/2 end;if kK==0 then kK=lT/2 end;if aV(lS)<0.1 then k_=k_-lS*5 else k_=k_-(lS+(lS-kJ)*lN)end;if aV(lT)<0.1 then kZ=kZ+lT*5 else kZ=kZ+lT+(lT-kK)*lN end;kJ=lS;kK=lT;if aV(lS)<lM and aV(lT)<lM then return true end;return false end end;function kG.clearAll()AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;kX=false;spaceLand=false;spaceLaunch=false;kY=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false;apBrk=false;alignHeading=nil;finalLand=false end;function kG.GetAutopilotBrakeDistanceAndTime(fH)return lo(fH)end;function kG.GetAutopilotTBBrakeDistanceAndTime(fH)return lr(fH)end;function kG.showWayPoint(planet,aI,lG)return lF(planet,aI,lG)end;function kG.APTick()local lU=a.getMouseWheel()if lU>0 then AP.changeSpd()elseif lU<0 then AP.changeSpd(true)else kW=true end;lb=e1()if le then a.setWaypoint(le)le=false end;if lh then antigrav.setTargetAltitude(lh)lh=false end;if lf then bC(lf,lg)lf=false;lg=""end;if l8~=-1 then AP.cmdCruise(l8,l9)l9=false;l8=-1 end;if l5~=nil then if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or e0:getTargetSpeed(axisCommandId.longitudinal)~=l5 then e0:setTargetSpeedCommand(axisCommandId.longitudinal,l5)else l5=nil end end;if l7~=-1 then AP.cmdThrottle(l7,l9)l9=false;l7=-1 end;if la then CONTROL.landingGear(la)la=false end;if li then AP.ToggleAutopilot()end end;function kG.ToggleIntoOrbit()OrbitAchieved=false;kO=nil;kP=nil;kU=0;if not inAtmo then if IntoOrbit then bE("orOff","AP")IntoOrbit=false;kQ=false;kT=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;l3.VectorToTarget=false;l3.AutopilotAlign=false;kS=false elseif nearPlanet then bE("orOn","AP")IntoOrbit=true;autoRoll=true;if kT==nil then kT=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else l("Unable to engage auto-orbit, not near a planet")end else IntoOrbit=false;kQ=false;kT=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false end;l3.VectorToTarget=false;l3.AutopilotAlign=false;kS=false end end;function kG.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;autoRoll=true;upAmount=0;if inAtmo and abvGndDet==-1 then BrakeLanding=false;AltitudeHold=true;upAmount=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)l8=h(adjustedAtmoSpeedLimit)end else OrbitAchieved=false;GearExtended=false;d.control.retractLandingGears()e0:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn="VTO Takeoff"end;VertTakeOff=not VertTakeOff end;function kG.checkLOS(lL)local gL,aG,aH=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,lL,function(ap)if ap.noAtmosphericDensityAltitude>0 then return ap.radius+ap.noAtmosphericDensityAltitude else return ap.radius+ap.surfaceMaxAltitude*1.5 end end)local gM=aG;if aH~=nil and aG~=nil then gM=math.min(aH,aG)end;if gM~=nil then return gL,gM else return nil,nil end end;local function lV(lW,lX)if lX then upAmount=0;e0:updateCommandFromActionStop(axisCommandId.vertical,lX)if stablized then e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)sEFC=true end else upAmount=upAmount+lW;e0:deactivateGroundEngineAltitudeStabilization()e0:updateCommandFromActionStart(axisCommandId.vertical,lW)end end;function kG.vertical(lW,lX)lV(lW,lX)end;function kG.ToggleAutopilot()local function lY(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then AP.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;local function lZ(bY)if bY then for i,N in pairs(AtlasOrdered)do if N.name and N.name==bY then return i end end else return 0 end end;local l_=false;HoverMode=false;if time-kN<1.5 and inAtmo then if not SpaceEngines then if inAtmo then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bE("11","EP")kN=-1;if Autopilot or VectorToTarget or IntoOrbit then return end else l("No space engines detected, Orbital Hop not supported")return end elseif planet.hasAtmosphere then if inAtmo then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bE("orH","OH")end;kN=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else kN=time end;TargetSet=false;if(AutopilotTargetIndex>0 or#apRoute>0)and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if 0.5*d:maxForceForward()/b.getGravityIntensity()<coreMass then l("WARNING: Heavy Loads may affect autopilot performance.")end;if#apRoute>0 and not finalLand then AutopilotTargetIndex=lZ(apRoute[1])ATLAS.UpdateAutopilotTarget()l("Route Autopilot in Progress")local lR=CustomTarget.position-worldPos;local m0=lR:project_on_plane(worldVertical):len()if m0>50000 and CustomTarget.planetname==planet.name then l_=true end end;ATLAS.UpdateAutopilotTarget()AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)if CustomTarget~=nil then if CustomTarget.agg and not ExternalAGG and antigrav then if not antigravOn then AP.ToggleAntigrav()end;AntigravTargetAltitude=CustomTarget.agg end;LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bE("apSpc","AP")if inAtmo then spaceLaunch=true;AP.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if inAtmo then if not VectorToTarget then bE("vtt","AP")lY(SpaceTarget)if l_ then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end end else bE("apOn","AP")if not(autopilotTargetPlanet.name==planet.name and coreAltitude<AutopilotTargetOrbit*1.5)then OrbitAchieved=false;Autopilot=true elseif not inAtmo then if IntoOrbit then AP.ToggleIntoOrbit()end;OrbitTargetOrbit=(planet.noAtmosphericDensityAltitude>0 and planet.noAtmosphericDensityAltitude or planet.surfaceMaxAltitude)+LowOrbitHeight;kS=true;l3.AutopilotAlign=true;l3.VectorToTarget=true;kQ=false;if not IntoOrbit then AP.ToggleIntoOrbit()end end end else bE("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if inAtmo then spaceLaunch=true;AP.ToggleAltitudeHold()else Autopilot=true end end elseif not inAtmo then if CustomTarget==nil and(autopilotTargetPlanet.name==planet.name and nearPlanet)and not IntoOrbit then WaypointSet=false;OrbitAchieved=false;kQ=false;OrbitTargetOrbit=(planet.noAtmosphericDensityAltitude>0 and planet.noAtmosphericDensityAltitude or planet.surfaceMaxAltitude)+LowOrbitHeight;kS=true;AP.ToggleIntoOrbit()else bE("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;followMode=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;kX=false;LockPitch=nil;WaypointSet=false end else bE("apP","AP")spaceLaunch=true;AP.ToggleAltitudeHold()end;li=false else bE("apOff","AP")AP.ResetAutopilots(1)if li==2 then li=true end end end;function kG.routeWP(m1,m2,m3)if m3 then if m3==1 then apRoute={}apRoute=e2(apRoute,saveRoute)if#apRoute>0 then l("Route Loaded")else l("No Saved Route found on Databank")end;return apRoute else saveRoute={}saveRoute=e2(saveRoute,apRoute)l("Route Saved")kF()return end end;if m1 then return apRoute end;if m2 then apRoute={}l("Current Route Cleared")else apRoute[#apRoute+1]=CustomTarget.name;l("Added "..CustomTarget.name.." to route. ")end;return apRoute end;function kG.cmdThrottle(O,m4)if e0:getAxisCommandType(0)~=axisCommandType.byThrottle and not m4 then d.control.cancelCurrentControlMasterMode()end;e0:setThrottleCommand(axisCommandId.longitudinal,O)PlayerThrottle=o(bF(O*100,0)/100,-1,1)l5=nil end;function kG.cmdCruise(O,m4)if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not m4 then d.control.cancelCurrentControlMasterMode()end;e0:setTargetSpeedCommand(axisCommandId.longitudinal,O)l5=O end;function kG.ToggleLockPitch()if LockPitch==nil then bE("lkPOn","LP")if not holdingShift then LockPitch=adjustedPitch else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bE("lkPOff","LP")LockPitch=nil end end;function kG.ToggleAltitudeHold()if time-kM<1.5 then HoverMode=false;if planet.hasAtmosphere then if inAtmo then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bE("11","EP")else if nearPlanet then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetOrbit=HoldAltitude;kS=true;if not IntoOrbit then AP.ToggleIntoOrbit()end;kQ=true end end;kM=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else kM=time end;if nearPlanet and not inAtmo and abvGndDet==-1 then OrbitTargetOrbit=coreAltitude;kS=true;kQ=true;AP.ToggleIntoOrbit()if IntoOrbit then kM=time else kM=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;followMode=false;autoRoll=true;LockPitch=nil;OrbitAchieved=false;if abvGndDet~=-1 then if not GearExtended and not VectorToTarget and not spaceLaunch then HoldAltitude=coreAltitude;HoverMode=abvGndDet;e0:setTargetGroundAltitude(HoverMode)elseif velMag<20 then if GearExtended then CONTROL.landingGear()end;bE("lfs","LS")AutoTakeoff=true;if inAtmo then HoldAltitude=coreAltitude+AutoTakeoffAltitude else HoldAltitude=planet.surfaceMaxAltitude+100 end;BrakeIsOn="ATO Hold"e0:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and UpVertAtmoEngine then AP.ToggleVerticalTakeoff()end end else bE("altOn","AH")AutoTakeoff=false;if kM>-1 then if nearPlanet then HoldAltitude=coreAltitude end end;if VertTakeOff then AP.ToggleVerticalTakeoff()end end;if antigravOn and not ExternalAGG then local m5=antigrav.getBaseAltitude()if VectorToTarget and CustomTarget.agg and CustomTarget.agg>coreAltitude then HoldAltitude=CustomTarget.agg elseif AutoTakeoff then HoldAltitude=m5 end;if aV(coreAltitude-m5)<100 and velMag<20 then HoldAltitude=m5;BrakeIsOn="AGG Hold"l7=0 end end;if spaceLaunch then HoldAltitude=200000 end else bE("altOff","AH")if IntoOrbit then AP.ToggleIntoOrbit()end;if VertTakeOff then AP.ToggleVerticalTakeoff()end;autoRoll=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;kM=0;HoverMode=false end end;function kG.ResetAutopilots(kG)if kG then spaceLaunch=false;Autopilot=false;AutopilotRealigned=false;kX=false;HoldAltitude=coreAltitude;TargetSet=false;apBrk=false;AutopilotStatus="Aligning"end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;alignHeading=nil;AutoLanding=false;ReversalIsOn=nil;apBrk=false;if not antigravOn then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then AP.ToggleVerticalTakeoff()end;if IntoOrbit then AP.ToggleIntoOrbit()end;autoRoll=autoRollPreference;spaceLand=false;finalLand=false;upAmount=0 end;function kG.BrakeToggle(m6)if not BrakeIsOn then if m6 then BrakeIsOn=m6 else BrakeIsOn=true end else BrakeIsOn=false end;if BrakeLanding then BrakeLanding=false;autoRoll=autoRollPreference;apBrk=false end;if BrakeIsOn then bE("bkOn","B",1)AP.ResetAutopilots()else bE("bkOff","B",1)end end;function kG.BeginReentry()if Reentry then l("Re-Entry cancelled")bE("reOff","RE")Reentry=false;autoRoll=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then l("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")msgTimer=5 elseif not kY then Reentry=true;if e0:getAxisCommandType(0)~=controlMasterModeId.cruise then d.control.cancelCurrentControlMasterMode()end;autoRoll=true;BrakeIsOn=false;l("Beginning Parachute Re-Entry - Strap In.  Target speed: "..adjustedAtmoSpeedLimit)bE("par","RE")else Reentry=true;AltitudeHold=true;autoRoll=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local m7=e4(HoldAltitude)l("Beginning Re-entry.  Target speed: "..adjustedAtmoSpeedLimit.." Target Altitude: "..m7)bE("glide","RE")l8=h(adjustedAtmoSpeedLimit)end;AutoTakeoff=false end;function kG.ToggleAntigrav()if antigrav and not ExternalAGG then if antigravOn then bE("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bE("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function kG.changeSpd(m8)local m9=1;if m8 then m9=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and kW then local ma=PlayerThrottle;PlayerThrottle=bF(o(PlayerThrottle+m9*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and ma<0 then PlayerThrottle=0;kW=false end elseif AltIsOn then if inAtmo or Reentry then adjustedAtmoSpeedLimit=o(adjustedAtmoSpeedLimit+m9*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=o(MaxGameVelocity+m9*speedChangeLarge/3.6*100,0,MaxSpeed-0.2)end else e0:updateCommandFromActionStart(axisCommandId.longitudinal,m9*speedChangeLarge/10)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*m9*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not m8 then m9=1 else m9=nil end;ATLAS.adjustAutopilotTargetIndex(m9)end end end;function kG.TenthTick()local function mb()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local fH=velMag;local mc=c.getThrottle()/100;if AtmoSpeedAssist then mc=PlayerThrottle end;local md,me=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,d:maxForceForward()*mc,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mf;if not TurnBurn and fH>0 then _,mf=AP.GetAutopilotBrakeDistanceAndTime(fH)else _,mf=AP.GetAutopilotTBBrakeDistanceAndTime(fH)end;local mg=0;local mh=0;if AutopilotCruising or not Autopilot and fH>5 then mh=Kinematic.computeTravelTime(fH,0,AutopilotDistance)elseif brakeDistance+md<AutopilotDistance then mg=AutopilotDistance-(brakeDistance+md)mh=Kinematic.computeTravelTime(MaxGameVelocity,0,mg)else local mi=(AutopilotDistance-brakeDistance)/md;md=AutopilotDistance-brakeDistance;me=me*mi end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mh elseif AutopilotBraking then return mf elseif AutopilotCruising then return mh+mf else return me+brakeTime+mh end end;local function mj()local jn=b.getGravityIntensity()jn=bF(jn,5)if kV==nil or kV~=jn then local fH=coreVelocity:len()local mk=k.getMaxBrake()if mk~=nil and mk>0 and inAtmo then mk=mk/o(fH/100,0.1,1)mk=mk/atmosDensity;if atmosDensity>0.10 then LastMaxBrakeInAtmo=mk end end;if mk~=nil and mk>0 then LastMaxBrake=mk end;kV=jn end end;ships=k.getDockedConstructs()passengers=k.getPlayersOnBoard()lm=0;for i=1,#ships do lm=lm+k.getDockedConstructMass(ships[i])end;local ml=0;for i=1,#passengers do ml=ml+k.getBoardedPlayerMass(passengers[i])end;if ml>20000 then lm=lm+ml-20000 end;notPvPZone,pvpDist=ln()MaxSpeed=k.getMaxSpeed()if AutopilotTargetName~="None"and(autopilotTargetPlanet or CustomTarget)then travelTime=mb()end;mj()end;local function mm(mn,mo)local jM=vec3()local mp=vec3()if mn==axisCommandId.longitudinal then jM=vec3(k.getOrientationForward())mp=constructForward elseif mn==axisCommandId.vertical then jM=vec3(k.getOrientationUp())mp=l4 elseif mn==axisCommandId.lateral then jM=vec3(k.getOrientationRight())mp=constructRight else return vec3()end;local mq=vec3(b.getWorldGravity())local mr=mq:dot(mp)local ms=vec3(k.getWorldAirFrictionAcceleration())local mt=ms:dot(mp)local mu=coreVelocity:dot(jM)local mv=mo*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(mv-mu)local mw=targetSpeedPID2:get()local mx=(mw-mt-mr)*mp;return mx end;local function my(mn,mo)local jM=vec3()local mp=vec3()if mn==axisCommandId.longitudinal then jM=vec3(k.getOrientationForward())mp=constructForward elseif mn==axisCommandId.vertical then jM=vec3(k.getOrientationUp())mp=l4 elseif mn==axisCommandId.lateral then jM=vec3(k.getOrientationRight())mp=constructRight else return vec3()end;local mq=vec3(b.getWorldGravity())local mr=mq:dot(mp)local ms=vec3(k.getWorldAirFrictionAcceleration())local mt=ms:dot(mp)local mu=coreVelocity:dot(jM)local mv=mo*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(mv-mu)local mw=targetSpeedPID:get()local mx=(mw-mt-mr)*mp;return mx end;local function mz(mA,fm,bK)local mB=mA:cross(bK):normalize_inplace()local g7=math.acos(o(mB:dot(-fm),-1,1))*constants.rad2deg;if mB:cross(-fm):dot(bK)<0 then g7=-g7 end;return g7 end;local function mC()if collisionTarget and not BrakeLanding then local ap=collisionTarget[1]local dt,du=collisionTarget[2],collisionTarget[3]local mD=math.min(dt,du or dt)local mE=mD/velMag;local mF=AutoTakeoff and(velMag<42 or abvGndDet~=-1)local mG=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mG and not mF and(brakeDistance*1.5>mD or mE<1)then BrakeIsOn="Collision"apRoute={}l7=0;if AltitudeHold then AP.ToggleAltitudeHold()end;if LockPitch then AP.ToggleLockPitch()end;l("Autopilot Cancelled due to possible collision")a.print(ap.name.." COLLISION "..e5(mE).." / "..e4(mD,2))AP.ResetAutopilots(1)StrongBrakes=true;if inAtmo then BrakeLanding=true end;autoRoll=true end;if mE<11 then collisionAlertStatus=ap.name.." COLLISION "..e5(mE).." / "..e4(mD,2)else collisionAlertStatus=ap.name.." collision "..e5(mE)end;if mE<6 then bE("alarm","AL",2)end else collisionAlertStatus=false end end;local mH=1;local mI=0;local mJ=1;local mK=1;local mL=1;local mM=false;function kG.onFlush()if antigrav and not ExternalAGG and not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then lh=AntigravTargetAltitude end;if sEFC then d:setEngineForceCommand('hover',vec3(),1)sEFC=false end;throttleMode=e0:getAxisCommandType(0)==axisCommandType.byThrottle;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local mN=o(pitchInput+kZ+a.getControlDeviceForwardInput(),-1,1)local mO=o(rollInput+l0+a.getControlDeviceYawInput(),-1,1)local mP=o(yawInput+k_-a.getControlDeviceLeftRightInput(),-1,1)local mQ=BrakeIsOn and 1 or 0;if inAtmo then worldVertical=vec3(b.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end else worldVertical=(planet.center-worldPos):normalize()end;l4=vec3(k.getWorldOrientationUp())constructForward=vec3(k.getWorldOrientationForward())constructRight=vec3(k.getWorldOrientationRight())constructVelocity=vec3(k.getWorldVelocity())coreVelocity=vec3(k.getVelocity())worldPos=vec3(k.getWorldPosition())coreMass=k.getMass()+lm;velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local mR=adjustedRoll/180*math.pi;local mS=math.cos(mR)local mT=math.sin(mR)adjustedPitch=mz(worldVertical,constructForward,constructRight*mS+l4*mT)local mU=constructVelocity:normalize()local mV=aV(adjustedRoll)local mW=utils.sign(adjustedRoll)local mX=vec3(k.getWorldAngularVelocity())local mY=mN*pitchSpeedFactor*constructRight+mO*rollSpeedFactor*constructForward+mP*yawSpeedFactor*l4;if autoRoll==true and worldVertical:len()>0.01 then local mZ=aV(l1-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and mZ>0 or inAtmo and mZ<autoRollRollThreshold and autoRollPreference)and mO==0 and aV(adjustedPitch)<85 then local m_=l1;local n0=autoRollFactor;if not inAtmo then n0=n0/4;l1=0;m_=0 end;if rollPID==nil then rollPID=pid.new(n0*0.01,0,n0*0.1)end;rollPID:inject(m_-adjustedRoll)local n1=rollPID:get()mY=mY+n1*constructForward end end;brakeInput2=0;atmosDensity=j()inAtmo=false or coreAltitude<planet.noAtmosphericDensityAltitude and atmosDensity>0.00001;coreAltitude=(worldPos-planet.center):len()-planet.radius;abvGndDet=ly()time=g()kL=time;if GearExtended and abvGndDet>-1 and abvGndDet-3<LandingGearGroundHeight then if e0.targetGroundAltitudeActivated then e0:deactivateGroundEngineAltitudeStabilization()end end;if RADAR then lk=not lk;if lk then RADAR.UpdateRadar()end;if CollisionSystem then mC()end end;if antigrav then antigravOn=antigrav.isActive()==1 end;local n2=time-kL;local n3=-math.deg(ls(l4,constructVelocity,constructForward))local n4=math.deg(ls(constructRight,constructVelocity,constructForward))local bS=worldVertical*-1;stalling=inAtmo and n3<-YawStallAngle or n3>YawStallAngle or n4<-PitchStallAngle or n4>PitchStallAngle;local n5=a.getMouseDeltaX()local n6=a.getMouseDeltaY()if ll then local n7=g()-ll;n5=n5*n7/0.016;n6=n6*n7/0.016 end;ll=g()if InvertMouse and not holdingShift then n6=-n6 end;k_=0;l0=0;kZ=0;local n8=k.getWorldPosition()planet=sys:closestBody(n8)kepPlanet=Kep(planet)orbit=kepPlanet:orbitalParameters(n8,constructVelocity)nearPlanet=c.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;local jn=planet:getGravity(n8):len()*coreMass;l1=0;local n9=k.getMaxThrustAlongAxis("ground",k.getOrientationUp())[1]if lb==0 then if d_()==1 and holdingShift then if not Animating then simulatedX=o(simulatedX+n5/2,-ResolutionX/2,ResolutionX/2)simulatedY=o(simulatedY+n6/2,-ResolutionY/2,ResolutionY/2)end else simulatedX=0;simulatedY=0 end else simulatedX=o(simulatedX+n5/2,-ResolutionX/2,ResolutionX/2)simulatedY=o(simulatedY+n6/2,-ResolutionY/2,ResolutionY/2)mouseDistance=r(simulatedX*simulatedX+simulatedY*simulatedY)if not holdingShift and d_()==0 then local gg,gh=1,1;if SelectedTab=="SCOPE"then gg,gh=scopeFOV/90,scopeFOV/90 end;if userControlScheme=="virtual joystick"then if mouseDistance>DeadZone then k_=k_-o(aV(simulatedX)-DeadZone,0,ResolutionX/2)*utils.sign(simulatedX)*MouseXSensitivity*gg;kZ=kZ-o(aV(simulatedY)-DeadZone,0,ResolutionY/2)*utils.sign(simulatedY)*MouseYSensitivity*gh end else simulatedX=0;simulatedY=0;if userControlScheme=="mouse"then kZ=(-utils.smoothstep(n6,-100,100)+0.5)*2*mK;k_=(-utils.smoothstep(n5,-100,100)+0.5)*2*mL end end end end;local na=velMag>27777;if velMag>SpaceSpeedLimit/3.6 and not inAtmo and not Autopilot and not na then l("Space Speed Engine Shutoff reached")l7=0 end;if not na and LastIsWarping then if not BrakeIsOn then AP.BrakeToggle()end;if Autopilot then AP.ResetAutopilots(1)end;l7=0 end;LastIsWarping=na;if atmosDensity>0.09 then if velMag>adjustedAtmoSpeedLimit/3.6 and not AtmoSpeedAssist and not kH then BrakeIsOn="SpdLmt"kH=true elseif not AtmoSpeedAssist and kH then if velMag<adjustedAtmoSpeedLimit/3.6 then BrakeIsOn=false;kH=false end end end;if ProgradeIsOn then if spaceLand then BrakeIsOn=false;local nb=false;nb=lK(CustomTarget.position-worldPos,0.1)autoRoll=true;if nb then l8=h(adjustedAtmoSpeedLimit)if(aV(adjustedRoll)<2 or aV(adjustedPitch)>85)and velMag>=adjustedAtmoSpeedLimit/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;if spaceLand~=2 then kY=true end;if spaceLand==true then finalLand=true end;spaceLand=false;Autopilot=false;AP.BeginReentry()end elseif inAtmo and AtmoSpeedAssist then l7=1 end elseif velMag>ej then lK(vec3(constructVelocity),0.01)end end;if RetrogradeIsOn then if inAtmo then RetrogradeIsOn=false elseif velMag>ej then lK(-vec3(constructVelocity))end end;if not ProgradeIsOn and spaceLand and not IntoOrbit then if not inAtmo then if spaceLand~=2 then kY=true end;AP.BeginReentry()spaceLand=false;finalLand=true else spaceLand=false;if not li then li=true end end end;if finalLand and CustomTarget and(coreAltitude<HoldAltitude+250 and coreAltitude>HoldAltitude-250)and aV(vSpd)<25 and atmosDensity>=0.1 and(CustomTarget.position-worldPos):len()>2000+coreAltitude then if not li then li=true end;finalLand=false end;if VertTakeOff then autoRoll=true;local nc=HoldAltitude;if vSpd<-30 then l("Unable to achieve lift. Safety Landing.")upAmount=0;autoRoll=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and antigravOn or HoldAltitude<planet.spaceEngineMinAltitude then if antigravOn then nc=antigrav.getBaseAltitude()end;if coreAltitude<nc-100 then l2=0;upAmount=15;BrakeIsOn=false elseif vSpd>0 then BrakeIsOn="VTO Limit"upAmount=0 elseif vSpd<-30 then BrakeIsOn="VTO Fall"upAmount=15 elseif coreAltitude>=nc then if antigravOn then if Autopilot or VectorToTarget then AP.ToggleVerticalTakeoff()else BrakeIsOn="VTO Complete"VertTakeOff=false end;l("Takeoff complete. Singularity engaged")bE("aggLk","AG")else BrakeIsOn=false;l("VTO complete. Engaging Horizontal Flight")bE("vtoc","VT")AP.ToggleVerticalTakeoff()end;upAmount=0 end else if atmosDensity>0.08 then l2=0;BrakeIsOn=false;upAmount=20 elseif atmosDensity<0.08 and inAtmo then BrakeIsOn=false;if SpaceEngineVertDn then l2=0;upAmount=20 else upAmount=0;l2=36;l8=3500 end else autoRoll=autoRollPreference;IntoOrbit=true;OrbitAchieved=false;CancelIntoOrbit=false;kQ=false;kO=nil;kP=nil;if kT==nil then kT=planet end;OrbitTargetOrbit=nc;kS=true;VertTakeOff=false end end;if l2~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local nd=o(l2-adjustedPitch,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(nd)local ne=o(vTpitchPID:get(),-1,1)kZ=ne end end;if IntoOrbit then local function nf()if orbit.periapsis.altitude>=OrbitTargetOrbit*0.99 and orbit.apoapsis.altitude>=OrbitTargetOrbit*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude and aV(OrbitTargetOrbit-coreAltitude)<1000 then return true else return false end end;local lR;local ng=false;local nh=e4(OrbitTargetOrbit,3)if kT==nil then kT=planet;if VectorToTarget then kT=autopilotTargetPlanet end end;if not kS then OrbitTargetOrbit=h(kT.radius+kT.surfaceMaxAltitude+LowOrbitHeight)if kT.hasAtmosphere then OrbitTargetOrbit=h(kT.radius+kT.noAtmosphericDensityAltitude+LowOrbitHeight)end;kS=true end;if l3.VectorToTarget and CustomTarget then lR=CustomTarget.position-worldPos end;local ni,nj=Kep(kT):escapeAndOrbitalSpeed((worldPos-kT.center):len()-kT.radius)local nk=adjustedRoll;if not kQ then local nl=false;local nm=false;l7=0;kP=0;orbitMsg="Aligning to orbital path - OrbitHeight: "..nh;if l3.VectorToTarget then lK(lR:normalize():project_on_plane(worldVertical))ng=constructForward:dot(lR:project_on_plane(l4):normalize())>0.95 else lK(constructVelocity)ng=n3<0.5;if velMag<150 then ng=true end end;kZ=0;kO=0;if adjustedPitch<=kO+2 and adjustedPitch>=kO-2 then nl=true else nl=false end;if nk<=kP+2 and nk>=kP-2 then nm=true else nm=false end;if nl and nm and ng then kO=nil;kP=nil;kQ=true end else if l3.VectorToTarget then lK(lR:normalize():project_on_plane(worldVertical))elseif velMag>150 then lK(constructVelocity)end;kZ=0;if l3.VectorToTarget and CustomTarget then local brakeDistance,_=Kinematic.computeDistanceAndTime(velMag,adjustedAtmoSpeedLimit/3.6,coreMass,0,0,LastMaxBrake)if OrbitAchieved and lR:len()>15000+brakeDistance+coreAltitude then orbitMsg="Orbiting to Target"if coreAltitude-100<=kT.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<kT.noAtmosphericDensityAltitude or not nf()and orbit.eccentricity>0.1 then l("Re-Aligning Orbit")OrbitAchieved=false end elseif OrbitAchieved or lR:len()<15000+brakeDistance+coreAltitude then l("Orbit complete, proceeding with reentry")bE("orCom","OB")AutopilotTargetCoords=CustomTarget.position;kY=true;finalLand=true;l3.VectorToTarget,l3.AutopilotAlign=false,false;AP.ToggleIntoOrbit()AP.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and coreAltitude>OrbitTargetOrbit*0.9 and coreAltitude<OrbitTargetOrbit*1.4 then if orbit.apoapsis~=nil then if(nf()or OrbitAchieved)and not MaintainOrbit then if OrbitAchieved then BrakeIsOn=false;l7=0;kO=0;if not l3.VectorToTarget then l("Orbit complete")bE("orCom","OB")AP.ToggleIntoOrbit()end else kU=kU+1;if kU>=2 then OrbitAchieved=true end end else if nf()then orbitMsg="Maintaining "else orbitMsg="Adjusting "kR=true;l8=nj*3.6+1;local nn=OrbitTargetOrbit-coreAltitude;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(nn-vSpd*o(utils.smoothstep(2000-nn,-2000,2000)^6*10,1,10))kO=o(VSpdPID:get(),-60,60)end;orbitMsg=orbitMsg.." - OrbitHeight: "..nh end end else local no=2.75;local np=aV(bF(ni*no))local jA=np%50;if jA>0 then np=np-jA+50 end;BrakeIsOn=false;if coreAltitude<OrbitTargetOrbit*0.8 then orbitMsg="Escaping planet gravity - OrbitHeight: "..nh;kO=utils.map(vSpd,200,0,-15,80)elseif coreAltitude>=OrbitTargetOrbit*0.8 and coreAltitude<OrbitTargetOrbit*1.15 then orbitMsg="Approaching orbital corridor - OrbitHeight: "..nh;np=np*0.75;kO=utils.map(vSpd,100,-100,-15,65)elseif coreAltitude>=OrbitTargetOrbit*1.15 and coreAltitude<OrbitTargetOrbit*1.5 then orbitMsg="Approaching orbital corridor - OrbitHeight: "..nh;np=np*0.75;if vSpd<0 or kR then kO=utils.map(coreAltitude,OrbitTargetOrbit*1.5,OrbitTargetOrbit*1.01,-30,0)else kO=utils.map(coreAltitude,OrbitTargetOrbit*0.99,OrbitTargetOrbit*1.5,0,30)end elseif coreAltitude>OrbitTargetOrbit*1.5 then orbitMsg="Reentering orbital corridor - OrbitHeight: "..nh;kO=-65;local nq=utils.map(vSpd,-150,-400,1,0.55)np=np*nq end;l8=h(np)end end;if kO~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local nr=kO-adjustedPitch;OrbitPitchPID:inject(nr)local ns=o(OrbitPitchPID:get(),-0.5,0.5)kZ=ns end end;if Autopilot and not inAtmo and not spaceLand then local function nt(nu,orbit)a.print(nu)ProgradeIsOn=false;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"l7=0;kX=false;l(nu)bE("apCom","AP")if orbit or spaceLand then if orbit and AutopilotTargetOrbit~=nil and not spaceLand then if not coreAltitude or coreAltitude==0 then return end;OrbitTargetOrbit=coreAltitude;kS=true end;AP.ToggleIntoOrbit()end end;local nw,nx=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local ny=(CustomTarget.position-autopilotTargetPlanet.center):normalize()local nz=ny:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()local nA=autopilotTargetPlanet.center+nz*(autopilotTargetPlanet.radius+AutopilotTargetOrbit)local nB=CustomTarget.position+(CustomTarget.position-autopilotTargetPlanet.center):normalize()*(AutopilotTargetOrbit-autopilotTargetPlanet:getAltitude(CustomTarget.position))if(worldPos-nA):len()<(worldPos-nB):len()then nw=nA else nw=nB;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nw;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)nx=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;nx=true;AutopilotRealigned=true;TargetSet=true;nw=CustomTarget.position+(worldPos-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nw end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local ny=(worldPos+constructVelocity*100000-autopilotTargetPlanet.center):normalize()local nz=ny:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()if nz:len()<1 then ny=(worldPos+constructForward*100000-autopilotTargetPlanet.center):normalize()nz=ny:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()end;nw=autopilotTargetPlanet.center+nz*(autopilotTargetPlanet.radius+AutopilotTargetOrbit)AutopilotTargetCoords=nw;TargetSet=true;nx=true;AutopilotRealigned=true;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nw)-worldPos):len()local gL,aG,aH=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,constructVelocity:normalize(),function(ap)if ap.noAtmosphericDensityAltitude>0 then return ap.radius+ap.noAtmosphericDensityAltitude else return ap.radius+ap.surfaceMaxAltitude*1.5 end end)local gM=aG;if aH~=nil and aG~=nil then gM=math.min(aH,aG)end;if gM~=nil and gM<AutopilotDistance and gL.name==autopilotTargetPlanet.name then AutopilotDistance=gM end;local nb=true;local nC=(autopilotTargetPlanet.center-(worldPos+vec3(constructVelocity):normalize()*AutopilotDistance)):len()-autopilotTargetPlanet.radius;local gI=e4(nC)lf=widgetTrajectoryAltitudeText;lg='{"label": "Projected Altitude", "value": "'..gI..'"}'if velMag>50 and AutopilotAccelerating then local lR=vec3(nw)-worldPos;local nD=o(math.deg(ls(l4,constructVelocity:normalize(),lR:normalize()))*velMag/500,-90,90)local nE=o(math.deg(ls(constructRight,constructVelocity:normalize(),lR:normalize()))*velMag/500,-90,90)if aV(nD)<20 and aV(nE)<20 then nD=nD*2;nE=nE*2 end;if aV(nD)<2 and aV(nE)<2 then nD=nD*2;nE=nE*2 end;local n3=-math.deg(ls(l4,constructForward,constructVelocity:normalize()))local n4=-math.deg(ls(constructRight,constructForward,constructVelocity:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(nE-n4)local nF=o(apPitchPID:get(),-1,1)kZ=kZ+nF;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(nD-n3)local nG=o(apYawPID:get(),-1,1)k_=k_+nG;nx=true;if aV(nD)>2 or aV(nE)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bE("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end end elseif AutopilotAccelerating and velMag<=50 then lK((nw-worldPos):normalize())end;if nC<AutopilotTargetOrbit*1.5 then AutopilotEndSpeed=adjustedAtmoSpeedLimit/3.6;if CustomTarget==nil then _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(nC)end end;local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=lo(velMag)else brakeDistance,brakeTime=lr(velMag)end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local gL,gM=AP.checkLOS((AutopilotTargetCoords-worldPos):normalize())if autopilotTargetPlanet.name~=planet.name then if gL~=nil and autopilotTargetPlanet.name~=gL.name and gM<AutopilotDistance then collisionAlertStatus="Attempting to clear LOS between "..gL.name.." and waypoint."lc=true else lc=false;collisionAlertStatus=false end end end;if not lc then if not AutopilotCruising and not AutopilotBraking and not nx then nb=lK((nw-worldPos):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then nb=lK(-vec3(constructVelocity):normalize())end end;if AutopilotAccelerating then if not kX then BrakeIsOn=false;l7=AutopilotInterplanetaryThrottle;PlayerThrottle=bF(AutopilotInterplanetaryThrottle,2)kX=true end;local mc=c.getThrottle()if AtmoSpeedAssist then mc=PlayerThrottle end;local nH=99999;local jy=-vec3(k.getWorldAcceleration()):dot(constructVelocity:normalize())local nI=o(constructVelocity:dot((nw-worldPos):normalize()),0,velMag)if nI>0 or jy>0 then nH=Kinematic.computeTravelTime(nI,jy,AutopilotDistance-brakeDistance)end;if MaxGameVelocity>MaxSpeed then MaxGameVelocity=MaxSpeed-0.2 end;if coreVelocity:len()>=MaxGameVelocity or mc==0 and kX or warmup/4>nH then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bE("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;l7=0 end;local nJ=AutopilotDistance;if nJ<=brakeDistance or PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if pvpDist<kI and pvpDist>2000 then AP.ResetAutopilots(1)l("Autopilot cancelled to prevent crossing PvP Line")BrakeIsOn="PvP Prevent"kI=pvpDist else kI=pvpDist;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bE("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;if not TurnBurn then ProgradeIsOn=true;autoRoll=true end;l7=0;kX=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn="AP Brk"end;if TurnBurn then l7=1;l9=true end;local _,nj=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed((worldPos-planet.center):len()-planet.radius)local lR;if CustomTarget then lR=CustomTarget.position-worldPos end;if CustomTarget and CustomTarget.planetname=="Space"and velMag<50 then if#apRoute>0 then if not li then table.remove(apRoute,1)end;if#apRoute>0 then BrakeIsOn=false;if not li then li=2 end;return end end;nt("Autopilot complete, arrived at space location")BrakeIsOn="Space Arrival"elseif CustomTarget and CustomTarget.planetname~="Space"and velMag<=nj and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then nt("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;spaceLand=true;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bE("apCir","AP")AutopilotStatus="Circularizing"end;if velMag<=nj then if CustomTarget then if constructVelocity:normalize():dot(lR:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bE("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;AP.showWayPoint(autopilotTargetPlanet,CustomTarget.position)WaypointSet=true end else nt("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;spaceLand=true;AP.showWayPoint(autopilotTargetPlanet,CustomTarget.position)WaypointSet=false end else nt("Autopilot completed, setting orbit",true)BrakeIsOn=false end end elseif AutopilotStatus=="Circularizing"then nt("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local nJ=AutopilotDistance;if nJ<=brakeDistance or PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if pvpDist<kI and pvpDist>2000 then if not li then li=true end;l("Autopilot cancelled to prevent crossing PvP Line")BrakeIsOn="Prevent PvP"kI=pvpDist else kI=pvpDist;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bE("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;if not TurnBurn then ProgradeIsOn=true;autoRoll=true end end;local mc=c.getThrottle()if AtmoSpeedAssist then mc=PlayerThrottle end;if mc>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end;AutopilotCruising=false end else if nb then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not spaceLand then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)+(AutopilotTargetOrbit+autopilotTargetPlanet.radius)*constructRight;AutopilotShipUp=l4;AutopilotShipRight=constructRight end;AutopilotRealigned=true elseif nb and not lc then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end;if not kX then l7=AutopilotInterplanetaryThrottle;l9=true;PlayerThrottle=bF(AutopilotInterplanetaryThrottle,2)kX=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and inAtmo)then l("Autopilot complete, starting reentry")bE("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"l7=0;kX=false;ProgradeIsOn=true;spaceLand=true;AP.showWayPoint(autopilotTargetPlanet,CustomTarget.position)end;if followMode then autoRoll=true;local nE=0;local bg=vec3(DUPlayer.getWorldPosition())local nK=bg-worldPos;local nL=vec3(nK):project_on(constructForward):len()local nM=vec3(nK):project_on(constructRight):len()local distance=r(nL*nL+nM*nM)lK(nK:normalize())local hO=40;local nN=distance<hO;local nO=100;local mo=o((distance-hO)/2,10,nO)kZ=0;local nb=aV(k_)<0.1;if nb and velMag<mo and not nN then BrakeIsOn=false;nE=-20 else BrakeIsOn="Follow"nE=0 end;local nP=0;if aV(nE-adjustedPitch)>nP then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(nE-adjustedPitch)local nF=pitchPID:get()kZ=nF end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then if HoverMode then if abvGndDet==-1 then HoldAltitude=HoldAltitude-0.2 else HoldAltitude=coreAltitude+HoverMode-abvGndDet end end;local nQ=LastMaxBrakeInAtmo;if nQ then nQ=nQ*o(velMag/100,0.1,1)*atmosDensity else nQ=LastMaxBrake end;if not inAtmo then nQ=LastMaxBrake end;l6=constructForward:project_on_plane(worldVertical):normalize():dot(constructVelocity)if l6>100 then brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(l6,100,coreMass,0,0,nQ)local nR,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,nQ*0.55)brakeDistance=brakeDistance+nR else brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(l6,0,coreMass,0,0,nQ*0.55)end;local nn=HoldAltitude-coreAltitude-vSpd;local nS=200+velMag;if Reentry or spaceLand then minMax=2000+velMag end;local nT=1;if AutoTakeoff then nT=o(velMag/100,0.1,1)end;local nE=(utils.smoothstep(nn,-nS,nS)-0.5)*2*MaxPitch*nT;if not Reentry and not spaceLand and not VectorToTarget and constructForward:dot(constructVelocity:normalize())<0.99 then nE=(utils.smoothstep(nn,-nS*o(20-19*atmosDensity*10,1,20),nS*o(20-19*atmosDensity*10,1,20))-0.5)*2*MaxPitch*o(2-atmosDensity*10,1,2)*nT end;if not AltitudeHold then nE=0 end;if LockPitch~=nil then if nearPlanet and not IntoOrbit then nE=LockPitch else LockPitch=nil end end;autoRoll=true;local nU=kZ;if Reentry then local nV=h(adjustedAtmoSpeedLimit)local nW,nX=Kinematic.computeDistanceAndTime(velMag,nV/3.6,coreMass,0,0,LastMaxBrake-planet.gravity*9.8*coreMass)nW=nW==-1 and 5000 or nW;local m0=coreAltitude-(planet.noAtmosphericDensityAltitude+nW)local nY=coreAltitude>planet.noAtmosphericDensityAltitude+nW*1.35;if nY then nE=ReEntryPitch;if velMag<=nV/3.6 and velMag>nV/3.6-10 and aV(constructVelocity:normalize():dot(constructForward))>0.9 and not throttleMode then WasInCruise=false;l7=1 end elseif(throttleMode or e0:getTargetSpeed(axisCommandId.longitudinal)~=nV)and not nY and not inAtmo then l8=nV;l9=true end;if throttleMode then if velMag>nV/3.6 and not nY then BrakeIsOn="Reentry Limit"if PlayerThrottle>0 then l7=0 end else BrakeIsOn=false end else BrakeIsOn=false end;if vSpd>0 then BrakeIsOn="Reentry vSpd"end;if not kY then nE=-80;if coreAltitude<planet.surfaceMaxAltitude+(planet.atmosphereThickness-planet.surfaceMaxAltitude)*0.25 then l("PARACHUTE DEPLOYED at "..bF(coreAltitude,0))Reentry=false;BrakeLanding=true;StrongBrakes=true;l7=0;nE=0;autoRoll=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and nY then autoRoll=true elseif not nY then if not inAtmo and(throttleMode or e0:getTargetSpeed(axisCommandId.longitudinal)~=nV)then l8=nV end;if velMag<nV/3.6+1 then BrakeIsOn=false;kY=false;Reentry=false;autoRoll=true;l7=1 end end end;if velMag>ej and not spaceLaunch and not VectorToTarget and not BrakeLanding and ForceAlignment then lK(vec3(constructVelocity))end;if ReversalIsOn or(VectorToTarget or spaceLaunch)and AutopilotTargetIndex>0 and inAtmo then local lR;if ReversalIsOn then if type(ReversalIsOn)=="table"then lR=ReversalIsOn elseif ReversalIsOn<3 and ReversalIsOn>0 then lR=-worldVertical:cross(constructVelocity)*5000 elseif ReversalIsOn>=3 then lR=worldVertical:cross(constructVelocity)*5000 elseif ReversalIsOn<0 then lR=constructVelocity*25000 end elseif CustomTarget~=nil then lR=CustomTarget.position-worldPos else lR=autopilotTargetPlanet.center-worldPos end;local nD=math.deg(ls(worldVertical:normalize(),constructVelocity,lR))*2;local hR=math.rad(aV(adjustedRoll))if velMag>minRollVelocity and inAtmo then local nZ=1000+velMag;local n_=(utils.smoothstep(nn-vSpd*10,-nZ,nZ)-0.5)*2*MaxPitch;local o0=o(90-n_,0,180)l1=o(nD*2,-o0,o0)local o1=nD;nD=o(o(nD,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(hR)+4*(adjustedPitch-nE)*math.sin(math.rad(adjustedRoll)),-YawStallAngle*0.80,YawStallAngle*0.80)local o2=1;if l1~=0 then o2=aV(hR/l1)end;o2=(90-o(aV(l1-adjustedRoll),0,90))/90;local o3=nE;if aV(adjustedRoll)>90 then o3=-o3 end;nE=o2*o(o(o3*math.cos(hR),-PitchStallAngle*0.8,PitchStallAngle*0.8)+aV(o(aV(o1)*math.sin(hR),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else l1=0;nD=o(nD,-YawStallAngle*0.80,YawStallAngle*0.80)end;local o4=n3-nD;if ReversalIsOn and aV(o4)<=0.0001 and(type(ReversalIsOn)=="table"or type(ReversalIsOn)~="table"and ReversalIsOn<0 and aV(adjustedRoll)<1)then if ReversalIsOn==-2 then AP.ToggleAltitudeHold()end;ReversalIsOn=nil;bE("180Off","BR")return end;if not stalling and velMag>minRollVelocity and inAtmo then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(o4)local nG=o(yawPID:get(),-1,1)k_=k_+nG elseif inAtmo and abvGndDet>-1 or velMag<minRollVelocity then lK(lR)elseif stalling and inAtmo then if(n3<-YawStallAngle or n3>YawStallAngle)and inAtmo then lK(constructVelocity)end;if(n4<-PitchStallAngle or n4>PitchStallAngle)and inAtmo then nE=o(adjustedPitch-n4,adjustedPitch-PitchStallAngle*0.80,adjustedPitch+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not spaceLaunch then local nc=planet:getAltitude(CustomTarget.position)local m0=lR:project_on_plane(worldVertical):len()StrongBrakes=true;if HoldAltitude<planet.noAtmosphericDensityAltitude and not spaceLaunch and not AutoTakeoff and not Reentry and(m0<=brakeDistance and lR:len()<planet.radius)and(constructVelocity:project_on_plane(worldVertical):normalize():dot(lR:project_on_plane(worldVertical):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"if#apRoute>0 then if not li then table.remove(apRoute,1)end;if#apRoute>0 then if not li then li=2 end;return end end;l7=0;if AltitudeHold then AP.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn="AP Finalizing"elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l6<0.1 or m0<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<m0)then bE("bklOn","BL")BrakeLanding=true;apBrk=true;if CustomTarget.heading then alignHeading=CustomTarget.heading else alignHeading=nil end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"collisionAlertStatus=false end;LastDistanceToTarget=m0 end elseif VectorToTarget and not inAtmo and HoldAltitude>planet.noAtmosphericDensityAltitude and not(spaceLaunch or Reentry)then if CustomTarget~=nil and autopilotTargetPlanet.name==planet.name then local lR=CustomTarget.position-worldPos;local nc=planet:getAltitude(CustomTarget.position)local m0=r(lR:len()^2-(coreAltitude-nc)^2)local nQ=LastMaxBrakeInAtmo;if nQ then brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,nQ/2)StrongBrakes=true;if m0<=brakeDistance+velMag*n2/2 and constructVelocity:project_on_plane(worldVertical):normalize():dot(lR:project_on_plane(worldVertical):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;kY=true;spaceLand=false;finalLand=true;Autopilot=false;AP.BeginReentry()end end;LastDistanceToTarget=m0 end end end;if not inAtmo and abvGndDet==-1 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(spaceLaunch or IntoOrbit or Reentry)then if not OrbitAchieved and not IntoOrbit then OrbitTargetOrbit=HoldAltitude;kS=true;if VectorToTarget then l3.VectorToTarget=true end;AP.ToggleIntoOrbit()VectorToTarget=false;kQ=true end end;if stalling and inAtmo and abvGndDet==-1 and velMag>minRollVelocity and VectorStatus~="Finalizing Approach"then lK(constructVelocity)nE=o(adjustedPitch-n4,adjustedPitch-PitchStallAngle*0.80,adjustedPitch+PitchStallAngle*0.80)end;kZ=nU;local lD=-1;if BrakeLanding then local o5=allowedHorizontalDrift or 0.05;if not ld then mM=false;if not throttleMode then l7=0 end;if abvGndDet==-1 then e0:setTargetGroundAltitude(500)e0:activateGroundEngineAltitudeStabilization(500)end;stablized=true;if not inAtmo then mM=true end;ld=true end;nE=0;local o6=false;local o7=math.abs(l6)if not ExternalAGG and antigravOn then o6=antigrav.getBaseAltitude()if o6<planet.surfaceMaxAltitude and CustomTarget==nil or CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>o6 then o6=false end else o6=false end;if alignHeading then if o7<o5 then if vSpd>-brakeLandingRate then BrakeIsOn=false else BrakeIsOn="BL Align BLR"end;if lK(alignHeading,0.001)then alignHeading=nil;autoRoll=autoRollPreference else kZ=0;autoRoll=true end else BrakeIsOn="BL Align Hzn"end;if o6 and aV(coreAltitude-o6)<250 then BrakeIsOn="AGG Align"end else local o8=false;local o9=30;if o7<10 and n9~=nil and n9>0 then local oa=o(atmosDensity,0.4,2)local nQ=LastMaxBrakeInAtmo*o(velMag/100,0.1,1)*oa;local ob=n9*oa+nQ-jn;local oc=nQ/2-jn;local od=velMag-r(aV(oc/2)*20/(0.5*coreMass))*utils.sign(oc)if od<0 then od=0 end;local oe;if velMag>100 then local of,_=Kinematic.computeDistanceAndTime(velMag,100,coreMass,0,0,nQ)local og,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,r(nQ))oe=of+og else oe=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,r(nQ))end;if oe<20 then BrakeIsOn=false else local oh=0;if od>100 then local oi,_=Kinematic.computeDistanceAndTime(od,100,coreMass,0,0,ob)local oj,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,n9*oa+r(nQ)-jn)oh=oi+oj else oh,_=Kinematic.computeDistanceAndTime(od,0,coreMass,0,0,n9*oa+r(nQ)-jn)end;oh=(oh+15+velMag*n2)*1.1;local ok=apBrk and CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;local nc=nil;if o6 and o6<coreAltitude then nc=o6 elseif ok then nc=planet:getAltitude(CustomTarget.position)+250 elseif coreAltitude>planet.surfaceMaxAltitude then nc=planet.surfaceMaxAltitude end;if collisionTarget then local ol=planet:getAltitude(collisionTarget[1].center)if nc then if ol>nc then nc=ol end else nc=ol end end;if nc~=nil then local om=coreAltitude-nc;o8=true;if om<=oh or oh==-1 or o7>o5 and apBrk then if nc==planet.surfaceMaxAltitude and vSpd<-brakeLandingRate then BrakeIsOn="BL Stop BLR"elseif o7>o5 and apBrk then BrakeIsOn="BL AP Hzn"else BrakeIsOn="BL Stop Dist"end else BrakeIsOn=false end end end end;lD=abvGndDet;if lD>-1 then BrakeIsOn=false;if not o6 and not GearExtended then la=true;e0:setTargetGroundAltitude(LandingGearGroundHeight)end;if(velMag<1 or constructVelocity:normalize():dot(worldVertical)<0)and not alignHeading and lD-3<LandingGearGroundHeight then BrakeLanding=false;AltitudeHold=false;upAmount=0;lV(0,1)BrakeIsOn="BL Complete"autoRoll=autoRollPreference;apBrk=false;ld=false else if vSpd<-5 or o7>o5*10 then lV(0,1)BrakeIsOn="BL Slowing"else BrakeIsOn=false;lV(-1)end end elseif not o8 then if StrongBrakes and constructVelocity:normalize():dot(-bS)<0.999 then BrakeIsOn="BL Strong"lK()elseif o7>10 or o7>o5 and apBrk then BrakeIsOn="BL hSpd"elseif vSpd<-brakeLandingRate then BrakeIsOn="BL BLR"lV(0,1)else lV(-1)BrakeIsOn=false end end end else ld=false end;if AutoTakeoff or spaceLaunch then local gL,aH,aG;if AutopilotTargetCoords~=nil then gL,aH,aG=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,(AutopilotTargetCoords-worldPos):normalize(),function(ap)if ap.noAtmosphericDensityAltitude>0 then return ap.radius+ap.noAtmosphericDensityAltitude else return ap.radius+ap.surfaceMaxAltitude*1.5 end end)end;if gL~=nil then if gL.name~=autopilotTargetPlanet.name and not inAtmo then collisionAlertStatus="Clearing LOS between "..gL.name.." and waypoint."end end;if antigravOn and not spaceLaunch then if coreAltitude>=HoldAltitude-50 and velMag>ej then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn="ATO Agg Arrive"l7=0 end end elseif aV(nE)<15 and coreAltitude/HoldAltitude>0.75 then AutoTakeoff=false;if not spaceLaunch then if throttleMode and not AtmoSpeedAssist then d.control.cancelCurrentControlMasterMode()end elseif spaceLaunch and velMag<ej then Autopilot=true;spaceLaunch=false;AltitudeHold=false;AutoTakeoff=false;l7=0 elseif spaceLaunch then l7=0;BrakeIsOn="ATO Space"end elseif spaceLaunch and not inAtmo and autopilotTargetPlanet~=nil and(gL==nil or gL.name==autopilotTargetPlanet.name)then Autopilot=true;collisionAlertStatus=false;spaceLaunch=false;AltitudeHold=false;AutoTakeoff=false;if not throttleMode then l7=0 end;AutopilotAccelerating=true end end;local on=abvGndDet>-1;local oo=adjustedPitch;if(VectorToTarget or spaceLaunch or ReversalIsOn)and not on and velMag>minRollVelocity and inAtmo then local hR=math.rad(aV(adjustedRoll))oo=adjustedPitch*aV(math.cos(hR))+n4*math.sin(hR)end;local op=o(nE-oo,-PitchStallAngle*0.80,PitchStallAngle*0.80)if not inAtmo and VectorToTarget then op=o(nE-oo,-85,MaxPitch)elseif not inAtmo then op=o(nE-oo,-MaxPitch,MaxPitch)end;if aV(adjustedRoll)<5 or VectorToTarget or ReversalIsOn or BrakeLanding or on or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(op)local nF=pitchPID:get()kZ=kZ+nF end end;if antigrav~=nil and(antigrav and not ExternalAGG and coreAltitude<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;lh=desiredBaseAltitude end end;if(inAtmo or Reentry or finalLand)and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.1,0,1)end;local oq=0;if ExtraEscapeThrust>0 and not Reentry and atmosDensity>0.005 and atmosDensity<0.1 and vSpd>-50 then local os=k.getFrictionBurnSpeed()*ExtraEscapeThrust;local ot=adjustedAtmoSpeedLimit/3.6;if os>ot then oq=os-ot-1 end end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6+oq-constructVelocity:dot(constructForward))local ou=throttlePID:get()calculatedThrottle=o(ou,-1,1)if not ThrottleValue then if calculatedThrottle<PlayerThrottle and(atmosDensity>0.005 or Reentry or finalLand)then ThrottleLimited=true;ThrottleValue=o(calculatedThrottle,0.01,1)else ThrottleLimited=false;ThrottleValue=PlayerThrottle end end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6-oq)local ov=o(brakePID:get(),0,1)if inAtmo and vSpd<-80 or(atmosDensity>0.005 or Reentry or finalLand)then brakeInput2=ov end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 and not ThrottleValue then ThrottleValue=0 end else calculatedThrottle=o(calculatedThrottle,0.01,1)end;local ow=''local ox=vec3()local oy=mm(axisCommandId.vertical,upAmount*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",oy,mI)local oz='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then oz=oz..ExtraLongitudeTags end;local oA=e0:getAxisCommandType(axisCommandId.longitudinal)local oB=e0:composeAxisAccelerationFromThrottle(oz,axisCommandId.longitudinal)local oC=my(axisCommandId.lateral,LeftAmount*1000)ow=ow..' , '.."lateral airfoil , lateral ground "ox=ox+oC;if ox:len()>constants.epsilon then d:setEngineForceCommand(ow,ox,mI,'','','',mJ)end;d:setEngineForceCommand(oz,oB,mH)local oD='thrust analog vertical fueled 'local oE='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then oE=oE..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then oD=oD..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then d:setEngineForceCommand(oD,oy,mH)else d:setEngineForceCommand(oD,vec3(),mH)end;if LeftAmount~=0 then d:setEngineForceCommand(oE,oC,mH)else d:setEngineForceCommand(oE,vec3(),mH)end;if mQ==0 then mQ=brakeInput2 end;local oF=-mQ*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*mU)d:setEngineForceCommand('brake',oF)else if AtmoSpeedAssist then if not ThrottleValue then ThrottleValue=PlayerThrottle end end;local mo=c.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-mo/3.6)local ov=o(brakePID:get(),0,1)mQ=o(mQ+ov,0,1)end;local oF=-mQ*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*mU)d:setEngineForceCommand('brake',oF)local ow=''local ox=vec3()local oG=false;local oz='thrust analog longitudinal 'if ExtraLongitudeTags~="none"and(UseExtra=="All"or UseExtra=="Longitude")then oz=oz..ExtraLongitudeTags end;local oA=e0:getAxisCommandType(axisCommandId.longitudinal)if oA==axisCommandType.byThrottle then local oB=e0:composeAxisAccelerationFromThrottle(oz,axisCommandId.longitudinal)d:setEngineForceCommand(oz,oB,mH)elseif oA==axisCommandType.byTargetSpeed then local oB=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ow=ow..' , '..oz;ox=ox+oB;if e0:getTargetSpeed(axisCommandId.longitudinal)==0 or e0:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-e0:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then oG=true end end;local oE='thrust analog lateral 'if ExtraLateralTags~="none"and(UseExtra=="All"or UseExtra=="Lateral")then oE=oE..ExtraLateralTags end;local oH=e0:getAxisCommandType(axisCommandId.lateral)if oH==axisCommandType.byThrottle then local oI=e0:composeAxisAccelerationFromThrottle(oE,axisCommandId.lateral)d:setEngineForceCommand(oE,oI,mH)elseif oH==axisCommandType.byTargetSpeed then local oC=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ow=ow..' , '..oE;ox=ox+oC end;local oD='thrust analog vertical 'if ExtraVerticalTags~="none"and(UseExtra=="All"or UseExtra=="Vertical")then oD=oD..ExtraVerticalTags end;local oJ=e0:getAxisCommandType(axisCommandId.vertical)if oJ==axisCommandType.byThrottle then local oy=e0:composeAxisAccelerationFromThrottle(oD,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then d:setEngineForceCommand(oD,oy,mH,'airfoil','ground','',mJ)else d:setEngineForceCommand(oD,vec3(),mH)d:setEngineForceCommand('airfoil vertical',oy,mH,'airfoil','','',mJ)d:setEngineForceCommand('ground vertical',oy,mH,'ground','','',mJ)end elseif oJ==axisCommandType.byTargetSpeed then if upAmount<0 then d:setEngineForceCommand('hover',vec3(),mH)end;local oK=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ow=ow..' , '..oD;ox=ox+oK end;if ox:len()>constants.epsilon then if mQ~=0 or oG or aV(mU:dot(constructForward))<0.5 then ow=ow..', brake'end;d:setEngineForceCommand(ow,ox,mI,'','','',mJ)end end;local oL=torqueFactor*(mY-mX)local oM=vec3(k.getWorldAirFrictionAngularAcceleration())oL=oL-oM;d:setEngineTorqueCommand('torque',oL,mH,'airfoil','','',mJ)d:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local fH=coreVelocity:len()local oN=0.15;if not throttleMode then local oO=e0:getTargetSpeed(axisCommandId.longitudinal)if fH*3.6>oO*(1-oN)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif fH*3.6<oO*(1-oN)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local mc=c.getThrottle()if AtmoSpeedAssist then mc=PlayerThrottle*100 end;local mo=mc/100;if not inAtmo then mo=mo*MaxGameVelocity;if fH>=mo*(1-oN)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif fH<mo*(1-oN)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local nV=h(adjustedAtmoSpeedLimit)mo=mo*nV/3.6;if fH>=mo*(1-oN)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif fH<mo*(1-oN)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end end end end end;if userAP then for N,A in pairs(userAP)do kG[N]=A end end;abvGndDet=ly()return kG end;local function oP(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,screenHud_1,d_,e0,e1,oQ,ca,bF,stringmatch,q,o,bE,e3,kF,l)local k=DUConstruct;local oR={}local oS=true;local oT=5;local oU=5;local oV=oT;local oW=oU;local oX=time;function oR.landingGear(la)GearExtended=not GearExtended;if GearExtended then if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then AP.ResetAutopilots(true)end;LockPitch=nil;AP.cmdThrottle(0)if vBooster or hover then if(inAtmo or coreAltitude<20000)and not la and abvGndDet==-1 then bE("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;if BrakeLanding then apBrk=not apBrk end;autoRoll=true;GearExtended=false;BrakeLanding=true else if hasGear then bE("grOut","LG",1)d.control.deployLandingGears()end;apBrk=false;if inAtmo then autoRoll=autoRollPreference;BrakeIsOn="Landing"end end;if la or abvGndDet~=-1 and abvGndDet>LandingGearGroundHeight-3 then BrakeLanding=true end;e0:setTargetGroundAltitude(LandingGearGroundHeight)AltitudeHold=false;HoverMode=false elseif hasGear and not BrakeLanding then bE("grOut","LG",1)d.control.deployLandingGears()end else if BrakeLanding then BrakeLanding=false end;if hasGear then bE("grIn","LG",1)d.control.retractLandingGears()end;e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)if stablized then if LandingGearGroundHeight<e0.targetGroundAltitude then e0:setTargetGroundAltitude(e0.targetGroundAltitude)else e0:setTargetGroundAltitude(TargetHoverHeight)end end end end;function oR.startControl(oY)local function oZ(m8)local m9=1;local function o_(p0,m8)local p1={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local p2=p0;for _,A in ipairs(p1)do if m8 and p2>A then p0=A elseif p0<A and not m8 then p0=A;break end end;return p0 end;if m8 then m9=-1 end;if not ExternalAGG and antigravOn then if holdingShift and m8 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+m9*oU;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+m9*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=o_(OrbitTargetOrbit,m8)else OrbitTargetOrbit=OrbitTargetOrbit+m9*oT end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=o_(HoldAltitude,m8)HoverMode=false else HoldAltitude=HoldAltitude+m9*oT;if HoverMode then if HoldAltitude>100 then HoverMode=false else e0:updateTargetGroundAltitudeFromActionStart(m9*1.0)HoverMode=d:getTargetGroundAltitude()end end end end else e0:updateTargetGroundAltitudeFromActionStart(m9*1.0)end end;local function p3(p4)if not inAtmo then l("Flight Assist in Atmo only")return end;local x=type(p4)if ReversalIsOn==nil then if x=="table"then if Autopilot or VectorToTarget then AP.ToggleAutopilot()end;bE("180On","BR")elseif p4==1 then bE("bnkLft","BR")else bE("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then AP.ToggleAltitudeHold()if x~="table"then p4=p4+1 end end;ReversalIsOn=p4 else bE("180Off","BR")ReversalIsOn=nil end end;local function p5()if e1()==1 then simulatedX=0;simulatedY=0;oQ(PrevViewLock)elseif d_()==1 and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false end;if oY=="gear"then CONTROL.landingGear()elseif oY=="light"then if AltIsOn then if d_()==1 then if DUPlayer.isFrozen()==1 then DUPlayer.freeze(0)l("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(1)l("Player Frozen, pitch/yaw/roll enabled")end else l("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif oY=="forward"then if AltIsOn and not inAtmo and not Autopilot then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else pitchInput=pitchInput-1 end elseif oY=="backward"then if AltIsOn then if not inAtmo then if not Autopilot then RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false else TurnBurn=not TurnBurn end else p3(-constructVelocity*5000)end else pitchInput=pitchInput+1 end elseif oY=="left"then if AltIsOn then p3(1)else rollInput=rollInput-1 end elseif oY=="right"then if AltIsOn then p3(3)else rollInput=rollInput+1 end elseif oY=="yawright"then yawInput=yawInput-1;alignHeading=nil elseif oY=="yawleft"then yawInput=yawInput+1;alignHeading=nil elseif oY=="straferight"then e0:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif oY=="strafeleft"then e0:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif oY=="up"then AP.vertical(1)if abvGndDet-3<LandingGearGroundHeight and coreAltitude>0 and GearExtended then CONTROL.landingGear()end elseif oY=="down"then AP.vertical(-1)elseif oY=="groundaltitudeup"then oZ()elseif oY=="groundaltitudedown"then oZ(true)elseif oY=="option1"then toggleView=false;if AltIsOn and holdingShift then local p6=""for i=1,#passengers do p6=p6 .."| Name: "..a.getPlayerName(passengers[i]).." Mass: "..bF(k.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;a.print("Onboard: "..p6)return end;ATLAS.adjustAutopilotTargetIndex()elseif oY=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do k.forceDeboard(passengers[i])k.forceInterruptVRSession(passengers[i])end;l("Deboarded All Passengers")return end;ATLAS.adjustAutopilotTargetIndex(1)elseif oY=="option3"then toggleView=false;if AltIsOn and holdingShift then local p6=""for i=1,#ships do p6=p6 .."| ID: "..ships[i].." Mass: "..bF(k.getDockedConstructMass(ships[i])/1000,1).."t "end;a.print("Docked Ships: "..p6)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end;if RADAR then RADAR.ToggleRadarPanel()end end elseif oY=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do k.forceUndock(ships[i])end;l("Undocked all ships")return end;ReversalIsOn=nil;AP.ToggleAutopilot()elseif oY=="option5"then toggleView=false;AP.ToggleLockPitch()elseif oY=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield then SHIELD.ventShield()else l("No shield found")end;return end;AP.ToggleAltitudeHold()elseif oY=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield then shield.toggle()return else l("No shield found")return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then l("Collision System Enabled")else l("Collision System Secured")end elseif oY=="option8"then toggleView=false;if AltIsOn and holdingShift then if AutopilotTargetIndex>0 and CustomTarget~=nil then AP.routeWP()else l("Select a saved wp on IPH to add to or remove from route")end;return end;stablized=not stablized;if not stablized then l("DeCoupled Mode - Ground Stabilization off")e0:deactivateGroundEngineAltitudeStabilization()bE("gsOff","GS")else l("Coupled Mode - Ground Stabilization on")e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)sEFC=true;bE("gsOn","GS")end elseif oY=="option9"then toggleView=false;if AltIsOn and holdingShift then e0:resetCommand(axisCommandId.longitudinal)e0:resetCommand(axisCommandId.lateral)e0:resetCommand(axisCommandId.vertical)AP.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.isActive()==1;if gyroIsOn then bE("gyOn","GA")else bE("gyOff","GA")end else l("No gyro found")end elseif oY=="lshift"then if AltIsOn then holdingShift=true end elseif oY=="brake"then if BrakeToggleStatus or AltIsOn then AP.BrakeToggle("Manual")elseif not BrakeIsOn then AP.BrakeToggle("Manual")else BrakeIsOn="Manual"end elseif oY=="lalt"then toggleView=true;AltIsOn=true;if d_()==0 and not freeLookToggle and userControlScheme=="keyboard"then oQ(1)end elseif oY=="booster"then if VanillaRockets then d:toggleBoosters()elseif not isBoosting then if not IsRocketOn then d:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then d:toggleBoosters()IsRocketOn=false end;isBoosting=false end elseif oY=="stopengines"then local function p7()if time-oX<1.5 then bE("clear","CA")AP.clearAll()end end;p7()oX=time;if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if AltIsOn then if adjustedAtmoSpeedLimit>0 then adjustedAtmoSpeedLimit=0 else adjustedAtmoSpeedLimit=AtmoSpeedLimit end elseif PlayerThrottle~=0 then e0:resetCommand(axisCommandId.longitudinal)AP.cmdThrottle(0)else AP.cmdThrottle(100)end else if e0:getTargetSpeed(axisCommandId.longitudinal)~=0 then e0:resetCommand(axisCommandId.longitudinal)else if inAtmo then AP.cmdCruise(adjustedAtmoSpeedLimit)else AP.cmdCruise(MaxGameVelocity*3.6)end end end elseif oY=="speedup"then AP.changeSpd()elseif oY=="speeddown"then AP.changeSpd(true)elseif oY=="antigravity"and not ExternalAGG then if antigrav~=nil then AP.ToggleAntigrav()else l("No antigrav found")end elseif oY=="leftmouse"then leftmouseclick=true;if holdingShift then p5()toggleView=false else holdingShift=true;PrevViewLock=e1()oQ(1)end end end;function oR.stopControl(oY)local function p8()if not ExternalAGG and antigravOn then oW=oU end;if AltitudeHold or VertTakeOff or IntoOrbit then oV=oT end end;if oY=="forward"then pitchInput=0 elseif oY=="backward"then pitchInput=0 elseif oY=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif oY=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif oY=="yawright"then yawInput=0 elseif oY=="yawleft"then yawInput=0 elseif oY=="straferight"then e0:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif oY=="strafeleft"then e0:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif oY=="up"then AP.vertical(0,-1)elseif oY=="down"then AP.vertical(0,1)elseif oY=="groundaltitudeup"then p8()toggleView=false elseif oY=="groundaltitudedown"then p8()toggleView=false elseif oY=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=false end end elseif oY=="lalt"then if holdingShift then holdingShift=false end;if d_()==0 and freeLookToggle then if toggleView then if e1()==1 then oQ(0)else oQ(1)end else toggleView=true end elseif d_()==0 and not freeLookToggle and userControlScheme=="keyboard"then oQ(0)end;AltIsOn=false end end;function oR.loopControl(oY)local function p9(m8)local m9=1;if m8 then m9=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+m9*oW;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;oW=o(oW*1.05,oU,50)else AntigravTargetAltitude=desiredBaseAltitude+m9*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+m9*oV;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+m9*oV end;oV=o(oV*1.05,oT,50)else e0:updateTargetGroundAltitudeFromActionLoop(m9*1.0)end end;local function pa(m8)local m9=1;if m8 then m9=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=o(PlayerThrottle+m9*speedChangeSmall/100,-1,1)else e0:updateCommandFromActionLoop(axisCommandId.longitudinal,m9*speedChangeSmall)end end end;if oY=="groundaltitudeup"then if not holdingShift then p9()end elseif oY=="groundaltitudedown"then if not holdingShift then p9(true)end elseif oY=="speedup"then pa()elseif oY=="speeddown"then pa(true)end end;function oR.inputTextControl(m7)local function pb(pc,bg,bZ)local function pd(bg)local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G='::pos{'..F..','..F..','..F..','..F..','..F..'}'local V,W,a2,a3,a4=stringmatch(bg,G)if V=="0"and W=="0"then return vec3(q(a2),q(a3),q(a4))end;a3=math.rad(a3)a2=math.rad(a2)local planet=e[q(V)][q(W)]local aR=math.cos(a2)local pe=vec3(aR*math.cos(a3),aR*math.sin(a3),math.sin(a2))return planet.center+(planet.radius+a4)*pe end;local position=pd(bg)return ATLAS.AddNewLocation(pc,position,bZ)end;local i;local pf,dR=nil,nil;local pg="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."i=string.find(m7," ")pf=m7;if i~=nil and string.find(m7,"::")~=1 then pf=string.sub(m7,0,i-1)dR=string.sub(m7,i+1)end;if pf=="/help"or pf=="/commands"then for gK in string.gmatch(pg,"([^\n]+)")do a.print(gK)end;return elseif pf=="/setname"then if dR==nil or dR==""then l("Usage: ah-setname Newname")return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(dR)else l("Select a saved target to rename first")end elseif shield and pf=="/resist"then SHIELD.setResist(dR)elseif pf=="/addlocation"or string.find(m7,"::pos")~=nil then local bZ=false;local pc="0-Temp"if dR==nil or dR==""or pf~="/addlocation"then dR=pf;bZ=true end;i=string.find(dR,"::")if not bZ then pc=string.sub(dR,1,i-2)end;local bg=string.sub(dR,i)bg=bg:gsub("%s+","")pb(pc,bg,bZ)elseif pf=="/agg"then if dR==nil or dR==""then l("Usage: /agg targetheight")return end;dR=q(dR)if dR<1000 then dR=1000 end;AntigravTargetAltitude=dR;l("AGG Target Height set to "..dR)elseif pf=="/G"then if dR==nil or dR==""then l("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if dR=="dump"then for N,A in pairs(e3())do if type(A.get())=="boolean"then if A.get()==true then a.print(N.." true")else a.print(N.." false")end elseif A.get()==nil then a.print(N.." nil")else a.print(N.." "..A.get())end end;return end;i=string.find(dR," ")local ph=string.sub(dR,0,i-1)local pi=string.sub(dR,i+1)for N,A in pairs(e3())do if N==ph then local pj=type(A.get())if pj=="number"then pi=q(pi)if N=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=pi end end;l("Variable "..ph.." changed to "..pi)if N=="MaxGameVelocity"then pi=pi/3.6;if pi>MaxSpeed-0.2 then pi=MaxSpeed-0.2;l("Variable "..ph.." changed to "..bF(pi*3.6,1))end end;if pj=="boolean"then if string.lower(pi)=="true"then pi=true else pi=false end end;A.set(pi)return end end;l("No such global variable: "..ph)elseif pf=="/deletewp"then if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else l("Select a custom wp to delete first in IPH")end elseif pf=="/copydatabank"then if dbHud_2 then kF(true)else l("Spare Databank required to copy databank")end elseif pf=="/iphWP"then if AutopilotTargetIndex>0 then a.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))a.print(json.encode(AutopilotTargetCoords))l("::pos waypoint shown in lua chat in local and world format")else l("No target selected in IPH")end elseif pf=="/createPrivate"then local pk="privatelocations = {\n"local pl=""if#privatelocations>0 then for N,A in pairs(privatelocations)do pk=pk.."{position = {x = "..A.position.x..", y = "..A.position.y..", z = "..A.position.z.."},\n ".."name = '"..A.name.."',\n planetname = '"..A.planetname.."',\n gravity = "..A.gravity..",\n"if A.heading then pk=pk.."heading = {x = "..A.heading.x..", y = "..A.heading.y..", z = "..A.heading.z.."},\n"end;if A.safe then pk=pk.."safe = true},\n"else pk=pk.."safe = false},\n"end end end;pl=#privatelocations.."-Private "if dR=="all"then for N,A in pairs(SavedLocations)do pk=pk.."{position = {x = "..A.position.x..", y = "..A.position.y..", z = "..A.position.z.."},\n ".."name = '*"..A.name.."',\n planetname = '"..A.planetname.."',\n gravity = "..A.gravity..",\n"if A.heading then pk=pk.."heading = {x = "..A.heading.x..", y = "..A.heading.y..", z = "..A.heading.z.."},\n"end;if A.safe then pk=pk.." safe = true},\n"else pk=pk.."safe = false},\n"end end;pl=pl..#SavedLocations.."-Public "end;pk=pk.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(pk)end;l(pl.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")msgTimer=7 end end;function oR.tagTick()if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;l("Extra Engine Tags: "..UseExtra)c.stopTimer("tagTick")end;if userControl then for N,A in pairs(userControl)do oR[N]=A end end;return oR end;local function pm(d,b,c,e,vBooster,hover,telemeter_1,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,weapon,screenHud_1)local a=DUSystem;local k=DUConstruct;local pn=DUPlayer;local po=DULibrary;local pp={}local n=string.format;local dY=json.decode;local pq=json.encode;local kz=b.getElementMaxHitPointsById;local dZ=b.getElementMassById;local d_=d.control.isRemoteControlled;local stringmatch=string.match;local ca=a.destroyWidgetPanel;local bC=a.updateData;local bD=a.addDataToWidget;local oQ=a.lockView;local e1=a.isViewLocked;local r=math.sqrt;local q=tonumber;local aV=math.abs;local h=math.floor;local j=c.getAtmosphereDensity;local atan=math.atan;local g=a.getArkTime;local o=utils.clamp;local e0=d.axisCommandManager;local cc=13;local e6=b.getElementIdList()local e7=0;local function s(az,aA)if az==0 then return aV(aA)<1e-09 elseif aA==0 then return aV(az)<1e-09 else return aV(az-aA)<math.max(aV(az),aV(aA))*epsilon end end;local function bF(F,pr)local m9=10^(pr or 0)return h(F*m9+0.5)/m9 end;local function e2(ps,pt)for N,A in pairs(pt)do if type(N)=="string"then ps[N]=A else ps[#ps+1]=pt[N]end end;return ps end;local function e3(pu)local pv={}if not pu then e2(pv,saveableVariablesBoolean)e2(pv,savableVariablesHandling)e2(pv,savableVariablesHud)e2(pv,savableVariablesPhysics)return pv elseif pu=="boolean"then return saveableVariablesBoolean elseif pu=="handling"then return savableVariablesHandling elseif pu=="hud"then return savableVariablesHud elseif pu=="physics"then return savableVariablesPhysics end end;local function l(nu)if not nu then return end;if msgText~="empty"then if msgText~=nu then msgText=msgText.."\n"..nu;msgTimer=7 end else msgText=nu end end;local function kF(pw)local function px(py)for N,A in pairs(py)do dbHud_1.setStringValue(N,pq(A.get()))if pw and dbHud_2 then dbHud_2.setStringValue(N,pq(A.get()))end end end;if dbHud_1 then px(autoVariables)px(e3())a.print("Saved Variables to Datacore")if pw and dbHud_2 then l("Databank copied.  Remove copy when ready.")end end end;local function bE(pz,pA,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;a.playSound(soundFolder.."/"..pz..".mp3")end;local function cb(d4,d5,m7,fe,pB)return n([[<text class="%s" x=%s y=%s style="%s">%s</text>]],fe or"",d4,d5,pB or"",m7)end;local function e4(distance,pC)pC=pC or 1;local unit="m"if distance>100000 then distance=distance/200000;unit="su"elseif distance>1000 then distance=distance/1000;unit="km"end;return bF(distance,pC)..unit end;local function e5(pD)local pE=0;local pF=0;local pG=0;if pD<60 then pD=h(pD)elseif pD<3600 then pE=h(pD/60)pD=h(pD%60)elseif pD<86400 then pF=h(pD/3600)pE=h(pD%3600/60)else pG=h(pD/86400)pF=h(pD%86400/3600)end;if pG>365 then return">1y"elseif pG>0 then return pG.."d "..pF.."h "elseif pF>0 then return pF.."h "..pE.."m "elseif pE>0 then return pE.."m "..pD.."s"elseif pD>0 then return pD.."s"else return"0s"end end;local function pH()if radar_1 then RADAR=c9(b,a,c,radar_1,radar_2,warpdrive,aV,ca,r,cb,q,cc,bE,l)end end;function pp.radarSetup()pH()end;function pp.onStart()local pI=false;local function pJ()local function pK(pL)local pM=dbHud_1.hasKey;for N,A in pairs(pL)do if pM(N)then local I=dY(dbHud_1.getStringValue(N))if I~=nil then A.set(I)pI=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not useTheseSettings then pK(e3())coroutine.yield()pK(autoVariables)else pK(autoVariables)l("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")msgTimer=5;pI=false end;coroutine.yield()if pI then l("Loaded Saved Variables")elseif not useTheseSettings then l("No Databank Saved Variables Found\nVariables will save to Databank on standing")msgTimer=5 end;if#SavedLocations>0 then customlocations=e2(customlocations,SavedLocations)end else l("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then l("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setTargetAltitude(AntigravTargetAltitude)end;if pcall(require,"autoconf/custom/archhud/"..privateFile)then if#privatelocations>0 then customlocations=e2(customlocations,privatelocations)end end;VectorStatus="Proceeding to Waypoint"if not MaxGameVelocity or MaxGameVelocity<0 then MaxGameVelocity=k.getMaxSpeed()-0.1 end end;local function pN()local function pO(pP,pQ)if pP>pQ then pQ=pP end;local pR,pS=0,0;if ContainerOptimization>0 then pR=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then pS=FuelTankOptimization*0.05 end;pQ=pQ*(1-(pR+pS))return pQ end;local pT=b.getElementNameById;local pU=fuelX~=0 and fuelY~=0;local pV=_G["atmofueltank_size"]local pW=_G["spacefueltank_size"]local pX=_G["rocketfueltank_size"]for N in pairs(e6)do local type=b.getElementDisplayNameById(e6[N])if stringmatch(type,'^.*Atmospheric Engine$')then if stringmatch(tostring(b.getElementTagsById(e6[N])),'^.*vertical.*$')and b.getElementForwardById(e6[N])[3]>0 then UpVertAtmoEngine=true end end;if stringmatch(type,'^.*Space Engine$')then SpaceEngines=true;if stringmatch(tostring(b.getElementTagsById(e6[N])),'^.*vertical.*$')then local pY=b.getElementForwardById(e6[N])if pY[3]<0 then SpaceEngineVertUp=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local kB=kz(e6[N])if kB>10000 then cc=110 elseif kB>1000 then cc=55 elseif kB>150 then cc=27 end end;e7=e7+kz(e6[N])if pU and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local kB=kz(e6[N])local a_=dZ(e6[N])local pP=0;local f6=g()if type=="Atmospheric Fuel Tank"then local pQ=400;local pZ=35.03;if kB>10000 then pQ=51200;pZ=5480 elseif kB>1300 then pQ=6400;pZ=988.67 elseif kB>150 then pQ=1600;pZ=182.67 end;pP=a_-pZ;if fuelTankHandlingAtmo>0 then pQ=pQ+pQ*fuelTankHandlingAtmo*0.2 end;pQ=pO(pP,pQ)local bY=pT(e6[N])local f4=0;for f5=1,pV do if bY==dY(c["atmofueltank_"..f5].getWidgetData()).name then f4=f5;break end end;local p_={e6[N],string.sub(bY,1,12),pQ,pZ,pP,f6,f4}atmoTanks[#atmoTanks+1]=p_ end;if type=="Rocket Fuel Tank"then local pQ=320;local pZ=173.42;if kB>65000 then pQ=40000;pZ=25740 elseif kB>6000 then pQ=5120;pZ=4720 elseif kB>700 then pQ=640;pZ=886.72 end;pP=a_-pZ;if fuelTankHandlingRocket>0 then pQ=pQ+pQ*fuelTankHandlingRocket*0.1 end;pQ=pO(pP,pQ)local bY=pT(e6[N])local f4=0;for f5=1,pX do if bY==dY(c["rocketfueltank_"..f5].getWidgetData()).name then f4=f5;break end end;local p_={e6[N],string.sub(bY,1,12),pQ,pZ,pP,f6,f4}rocketTanks[#rocketTanks+1]=p_ end;if type=="Space Fuel Tank"then local pQ=600;local pZ=35.03;if kB>10000 then pQ=76800;pZ=5480 elseif kB>1300 then pQ=9600;pZ=988.67 elseif kB>150 then pQ=2400;pZ=182.67 end;pP=a_-pZ;if fuelTankHandlingSpace>0 then pQ=pQ+pQ*fuelTankHandlingSpace*0.2 end;pQ=pO(pP,pQ)local bY=pT(e6[N])local f4=0;for f5=1,pW do if bY==dY(c["spacefueltank_"..f5].getWidgetData()).name then f4=f5;break end end;local p_={e6[N],string.sub(bY,1,12),pQ,pZ,pP,f6,f4}spaceTanks[#spaceTanks+1]=p_ end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function q0()if gyro~=nil then gyroIsOn=gyro.isActive()==1 end;if not stablized then e0:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then oQ(1)else oQ(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,A in pairs(door)do A.toggle()end end;if switch then for _,A in pairs(switch)do A.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,A in pairs(forcefield)do A.toggle()end end;if antigrav then antigravOn=antigrav.isActive()==1;if antigravOn and not ExternalAGG then antigrav.showWidget()end end;if d_()==1 and RemoteFreeze then pn.freeze(1)else pn.freeze(0)end;if hasGear then if abvGndDet~=-1 and not antigravOn then d.control.deployLandingGears()else d.control.retractLandingGears()end end;GearExtended=d.control.isAnyLandingGearDeployed()==1 or abvGndDet~=-1 and abvGndDet-3<LandingGearGroundHeight;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<30 then BrakeIsOn="Startup"else BrakeIsOn=false end;e0:setTargetGroundAltitude(LandingGearGroundHeight)WasInAtmo=inAtmo end;local function q1()local q2={}local function q3()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local q4={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for q5,q6 in pairs(e)do e[q5][0]=q3()e[q5][0].systemId=q5;q2[q5]={}for q7,planet in pairs(e[q5])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness;planet.spaceEngineMinAltitude=q4[planet.id]or 0.5353125*planet.atmosphereThickness;planet.planetarySystemId=q5;planet.bodyId=planet.id;q2[q5][q7]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then planetAtlas[#planetAtlas+1]=planet end end end;PlanetaryReference=m(d,b,c,a,n,o,q,r,s)galaxyReference=PlanetaryReference(q2)sys=galaxyReference[0]Kinematic=aU(d,b,c,a,r,aV)Kep=be(d,b,c,a,n,o,q,r,s)ATLAS=bB(d,b,c,a,dbHud_1,e,bC,bD,h,q,r,bE,bF,l)planet=galaxyReference[0]:closestBody(k.getWorldPosition())end;SetupComplete=false;beginSetup=coroutine.create(function()e0:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})pJ()coroutine.yield()pN()coroutine.yield()AP=kE(d,b,c,e,vBooster,hover,telemeter_1,antigrav,dbHud_1,aV,h,j,d_,atan,g,o,e0,bC,e1,r,bF,bE,e2,s,e4,e5,kF,dY,l)q0()coroutine.yield()q1()pH()if dX then HUD=dX(d,b,c,a,e,antigrav,hover,shield,warpdrive,weapon,aV,h,n,dY,j,dZ,d_,atan,g,o,e0,bD,bC,ca,e1,r,bF,cb,bE,e2,e3,e4,e5,e6,e7,l)end;if HUD then HUD.ButtonSetup()end;CONTROL=oP(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,screenHud_1,d_,e0,e1,oQ,ca,bF,stringmatch,q,o,bE,e3,kF,l)if shield then SHIELD=dI(shield,stringmatch,h,l)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if screenHud_1 then screenHud_1.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",hudTickRate)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)k.setDockingMode(DockingMode)if shield then c.setTimer("shieldTick",0.0166667)end;if userBase then PROGRAM.ExtraOnStart()end;bE("start","SU")local function q8()if ecuThrottle[1]==0 then AP.cmdThrottle(ecuThrottle[2])else if atmosDensity>0 then adjustedAtmoSpeedLimit=ecuThrottle[2]AP.cmdThrottle(1)end end end;ECU=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if ECU then if abvGndDet>-1 and velMag<1 and abvGndDet-3<LandingGearGroundHeight then c.exit()else if ECUHud then q8()else if atmosDensity==0 then BrakeIsOn="ECU Braking"elseif abvGndDet==-1 then CONTROL.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif ECUHud and ecuThrottle[3]+3>g()then q8()end;ships=k.getDockedConstructs()passengers=k.getPlayersOnBoard()local q9;q9=#passengers>1 and"Passengers: "..#passengers-1 .." "or""q9=q9 ..(#ships>0 and"Ships: "..#ships or"")if q9~=""then l("NOTICE: Docked "..q9)end end)coroutine.resume(beginSetup)end;function pp.onUpdate()if SetupComplete then d:update()if inAtmo and AtmoSpeedAssist and throttleMode then if throttleMode and WasInCruise then AP.cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end end;if ThrottleValue then e0:setThrottleCommand(axisCommandId.longitudinal,ThrottleValue)ThrottleValue=nil end;if not Animating and content~=LastContent then a.setScreen(content)end;LastContent=content;if ECU and not ECUHud and atmosDensity>0 and abvGndDet==-1 then CONTROL.landingGear()end;if ECU and abvGndDet>-1 and velMag<1 and abvGndDet-3<LandingGearGroundHeight then c.exit()end;if userBase then PROGRAM.ExtraOnUpdate()end else local dA=coroutine.status(beginSetup)if dA=="suspended"then local O,dB=coroutine.resume(beginSetup)if dB then a.print("ERROR STARTUP: "..dB)end elseif dA=="dead"then SetupComplete=true end end end;function pp.onFlush()if SetupComplete then AP.onFlush()if userBase then PROGRAM.ExtraOnFlush()end end end;function pp.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,A in pairs(door)do A.toggle()end end;if switch then for _,A in pairs(switch)do A.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,A in pairs(forcefield)do A.toggle()end end;showHud=oldShowHud;local qa=0;if ECU then qa=g()end;if e0:getAxisCommandType(0)==0 then ecuThrottle={0,PlayerThrottle,qa}else ecuThrottle={1,e0:getTargetSpeed(axisCommandId.longitudinal),qa}end;kF()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;if HUD then a.print(HUD.FuelUsed("atmofueltank")..", "..HUD.FuelUsed("spacefueltank")..", "..HUD.FuelUsed("rocketfueltank"))end;if userBase then PROGRAM.ExtraOnStop()end;bE("stop","SU")end;function pp.controlStart(oY)if SetupComplete then CONTROL.startControl(oY)end end;function pp.controlStop(oY)if SetupComplete then CONTROL.stopControl(oY)end end;function pp.controlLoop(oY)if SetupComplete then CONTROL.loopControl(oY)end end;function pp.controlInput(m7)if SetupComplete then CONTROL.inputTextControl(m7)end end;function pp.radarEnter(W)if RADAR then RADAR.onEnter(W)end end;function pp.radarLeave(W)if RADAR then RADAR.onLeave(W)end end;function pp.onTick(qb)if qb=="tenthSecond"then if AP then AP.TenthTick()end;if HUD then HUD.TenthTick()end elseif qb=="oneSecond"then if HUD then HUD.OneSecondTick()end elseif qb=="msgTick"then if HUD then HUD.MsgTick()end elseif qb=="animateTick"then if HUD then HUD.AnimateTick()end elseif qb=="hudTick"then if HUD then HUD.hudtick()end elseif qb=="apTick"then if AP then AP.APTick()end elseif qb=="shieldTick"then SHIELD.shieldTick()elseif qb=="tagTick"then CONTROL.tagTick()elseif qb=="contact"then RADAR.ContactTick()end end;if userBase then for N,A in pairs(userBase)do pp[N]=A end end;return pp end;function script.onStart()PROGRAM.onStart()end;function script.onOnStop()PROGRAM.onStop()end;function script.onTick(qb)PROGRAM.onTick(qb)end;function script.onOnFlush()PROGRAM.onFlush()end;function script.onOnUpdate()PROGRAM.onUpdate()end;function script.onActionStart(oY)PROGRAM.controlStart(oY)end;function script.onActionStop(oY)PROGRAM.controlStop(oY)end;function script.onActionLoop(oY)PROGRAM.controlLoop(oY)end;function script.onInputText(m7)PROGRAM.controlInput(m7)end;function script.onEnter(W)PROGRAM.radarEnter(W)end;function script.onLeave(W)PROGRAM.radarLeave(W)end;f(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)PROGRAM=pm(d,core,unit,e,vBooster,hover,telemeter_1,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,weapon,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
