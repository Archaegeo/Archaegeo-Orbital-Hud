name: ArchHud - Archaegeo v0.004 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.004;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}aZ=k;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={}bH=false;bI={VertTakeOff={set=function(M)b9=M end,get=function()return b9 end},VertTakeOffEngine={set=function(M)a_=M end,get=function()return a_ end},SpaceTarget={set=function(M)bx=M end,get=function()return bx end},BrakeToggleStatus={set=function(M)aZ=M end,get=function()return aZ end},BrakeIsOn={set=function(M)b0=M end,get=function()return b0 end},RetrogradeIsOn={set=function(M)b1=M end,get=function()return b1 end},ProgradeIsOn={set=function(M)b2=M end,get=function()return b2 end},Autopilot={set=function(M)b3=M end,get=function()return b3 end},TurnBurn={set=function(M)b4=M end,get=function()return b4 end},AltitudeHold={set=function(M)b5=M end,get=function()return b5 end},BrakeLanding={set=function(M)b6=M end,get=function()return b6 end},Reentry={set=function(M)b8=M end,get=function()return b8 end},AutoTakeoff={set=function(M)b7=M end,get=function()return b7 end},HoldAltitude={set=function(M)ba=M end,get=function()return ba end},AutopilotAccelerating={set=function(M)bb=M end,get=function()return bb end},AutopilotBraking={set=function(M)bd=M end,get=function()return bd end},AutopilotCruising={set=function(M)be=M end,get=function()return be end},AutopilotRealigned={set=function(M)bc=M end,get=function()return bc end},AutopilotEndSpeed={set=function(M)bf=M end,get=function()return bf end},AutopilotStatus={set=function(M)bg=M end,get=function()return bg end},AutopilotPlanetGravity={set=function(M)bh=M end,get=function()return bh end},PrevViewLock={set=function(M)bi=M end,get=function()return bi end},AutopilotTargetName={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetCoords={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetIndex={set=function(M)bl=M end,get=function()return bl end},TotalDistanceTravelled={set=function(M)bn=M end,get=function()return bn end},TotalFlightTime={set=function(M)bo=M end,get=function()return bo end},SavedLocations={set=function(M)bp=M end,get=function()return bp end},VectorToTarget={set=function(M)bq=M end,get=function()return bq end},LocationIndex={set=function(M)br=M end,get=function()return br end},LastMaxBrake={set=function(M)bs=M end,get=function()return bs end},LockPitch={set=function(M)bt=M end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(M)bu=M end,get=function()return bu end},AntigravTargetAltitude={set=function(M)bv=M end,get=function()return bv end},LastStartTime={set=function(M)bw=M end,get=function()return bw end},iphCondition={set=function(M)bA=M end,get=function()return bA end},stablized={set=function(M)bB=M end,get=function()return bB end},UseExtra={set=function(M)bC=M end,get=function()return bC end},SelectedTab={set=function(M)bJ=M end,get=function()return bJ end},saveRoute={set=function(M)bE=M end,get=function()return bE end},apRoute={set=function(M)bF=M end,get=function()return bF end},ecuThrottle={set=function(M)bG=M end,get=function()return bG end},HoverMode={set=function(M)bH=M end,get=function()return bH end}}local function bK(b,c,bL,bM,bN)local a=DUSystem;local bO=DUConstruct;bP=bL()bQ=0;bR=0;bS=false;bT=0;bU=false;bV=false;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;c1=false;c2="empty"c3=3;c4=false;c5=0;c6=0;c7=nil;c8=0;c9=0;ca=0;cb=false;cc=false;cd=false;ce=-1;cf=bN()>0;cg=bN()ch=b.getAltitude()ci=DUConstruct.getMass()cj=nil;ck={}cl={}cm={}cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=false;cx=false;cy=q;cz=false;cA=W;cB=nil;cC=0;cD=false;cE=false;cF=false;cG=vec3(bO.getWorldOrientationForward())cH=vec3(bO.getWorldOrientationRight())cI=vec3(bO.getVelocity())cJ=vec3(bO.getWorldVelocity())cK=vec3(cJ):len()cL=vec3(b.getWorldVertical())cM=-cL:dot(cJ)cN=vec3(bO.getWorldPosition())cO=false;cP=false;cQ=true;cR=0;cS=0;cT={}cU=false;cV=50000;cW=nil;cX=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;cY=false;cZ=nil;c_=false;d0=0;d1=nil;d2=nil;d3={}d4=90;d5=w;d6=nil;d7=nil;d8={}d9={}da=false;db=nil;dc=0;dd=false;de=bO.getMaxSpeed()if shield then df=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dg(dh)a.print(bP..": "..dh)end;local function di(d,b,c,a,dj,dk,dl,dm,dn)local function dp(dq)return type(dq)=='number'end;local function dr(dq)return type(dl(dq))=='number'end;local function ds(dt)return type(dt)=='table'end;local function du(a)return type(a)=='string'end;local function dv(dw)return ds(dw)and dp(dw.x and dw.y and dw.z)end;local function dx(dy)return ds(dy)and dp(dy.latitude and dy.longitude and dy.altitude and dy.id and dy.systemId)end;local dz=math.pi/180;local dA=180/math.pi;local dB=1e-10;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local utils=utils;local vec3=vec3;local function dE(dq)local dF=string.gsub(string.reverse(dj('%.4f',dq)),'^0*%.?','')return dF==''and'0'or string.reverse(dF)end;local function dG(dH)if dv(dH)then return dj('{x=%.3f,y=%.3f,z=%.3f}',dH.x,dH.y,dH.z)end;if ds(dH)and not getmetatable(dH)then local dI={}local dJ=next(dH)if type(dJ)=='nil'or dJ==1 then dI=dH else for dK,dw in pairs(dH)do local dL=dG(dw)if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end end;return dj('{%s}',table.concat(dI,','))end;if du(dH)then return dj("'%s'",dH:gsub("'",[[\']]))end;return tostring(dH)end;local dM={}dM.__index=dM;dM.__tostring=function(dH,dN)local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)local dI={}for dP,dK in ipairs(dO)do local dL=dG(dH[dK])if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end;if dN then return dj('%s%s',dN,table.concat(dI,',\n'..dN))end;return dj('{%s}',table.concat(dI,','))end;dM.__eq=function(dQ,dR)return dQ.systemId==dR.systemId and dQ.id==dR.id and dn(dQ.radius,dR.radius)and dn(dQ.center.x,dR.center.x)and dn(dQ.center.y,dR.center.y)and dn(dQ.center.z,dR.center.z)and dn(dQ.GM,dR.GM)end;local function dS(dT,dU,dV,dW,dX)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(dV),'Argument 3 (radius) must be a number:'..type(dV))assert(ds(dW),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dW))assert(dr(dX),'Argument 5 (GM) must be a number:'..type(dX))return setmetatable({systemId=dl(dT),id=dl(dU),radius=dl(dV),center=vec3(dW),GM=dl(dX)},dM)end;local dY={}dY.__index=dY;dY.__tostring=function(dg)return dj('::pos{%d,%d,%s,%s,%s}',dg.systemId,dg.id,dE(dg.latitude*dA),dE(dg.longitude*dA),dE(dg.altitude))end;dY.__eq=function(dQ,dR)return dQ.id==dR.id and dQ.systemId==dR.systemId and dn(dQ.latitude,dR.latitude)and dn(dQ.altitude,dR.altitude)and(dn(dQ.longitude,dR.longitude)or dn(dQ.latitude,math.pi/2)or dn(dQ.latitude,-math.pi/2))end;local function dZ(d_,dU,e0,e1,e2)local dT=d_;if du(d_)and not e1 and not e2 and not dU and not e0 then dT,dU,e0,e1,e2=e3(d_,dD)assert(dT,'Argument 1 (position string) is malformed.')else assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(e0),'Argument 3 (latitude) must be in degrees:'..type(e0))assert(dr(e1),'Argument 4 (longitude) must be in degrees:'..type(e1))assert(dr(e2),'Argument 5 (altitude) must be in meters:'..type(e2))end;dT=dl(dT)dU=dl(dU)e0=dl(e0)e1=dl(e1)e2=dl(e2)if dU==0 then return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=dU,systemId=dT},dY)end;return setmetatable({latitude=dz*dk(e0,-90,90),longitude=dz*(e1%360),altitude=e2,id=dU,systemId=dT},dY)end;local e4={}e4.__index=e4;e4.__tostring=function(dH,dN)local e5=dN and dN..'  'local e6={}local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)for dP,e7 in ipairs(dO)do e8=dH[e7]local e9=dM.__tostring(e8,e5)if dN then table.insert(e6,dj('[%s]={\n%s\n%s}',e7,e9,dN))else table.insert(e6,dj('  [%s]=%s',e7,e9))end end;if dN then return dj('\n%s%s%s',dN,table.concat(e6,',\n'..dN),dN)end;return dj('{\n%s\n}',table.concat(e6,',\n'))end;local function ea(eb)local e={}local pid;for dP,dw in pairs(eb)do local dU=dw.planetarySystemId;if type(dU)~='number'then error('Invalid planetary s ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary s IDs: '..dU..' and '..pid)end;local ec=dw.bodyId;if type(ec)~='number'then error('Invalid body ID: '..tostring(ec))elseif e[ec]then error('Duplicate body ID: '..tostring(ec))end;setmetatable(dw.center,getmetatable(vec3.unit_x))e[ec]=setmetatable(dw,dM)pid=dU end;return setmetatable(e,e4)end;ed={}local function ee(eb)return setmetatable({galaxyAtlas=eb or{}},ed)end;ed.__index=function(dt,M)if type(M)=='number'then local a=dt.galaxyAtlas[M]return ea(a)end;return rawget(ed,M)end;ed.__pairs=function(dH)return function(dt,dK)local ef,eg=next(dt,dK)return ef,eg and ea(eg)end,dH.galaxyAtlas,nil end;ed.__tostring=function(dH)local eh={}for dP,ei in pairs(dH or{})do local ej=ei:getPlanetarySystemId()local ek=e4.__tostring(ei,'    ')table.insert(eh,dj('  [%s]={%s\n  }',ej,ek))end;return dj('{\n%s\n}\n',table.concat(eh,',\n'))end;ed.BodyParameters=dS;ed.MapPosition=dZ;ed.PlanetarySystem=ea;function ed.createBodyParameters(dT,dU,el,em,en,eo,ep)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(el),'Argument 3 (surfaceArea) must be a number:'..type(el))assert(ds(em),'Argument 4 (aPosition) must be an array or vec3:'..type(em))assert(ds(en),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(en))assert(dr(eo),'Argument 6 (altitude) must be in meters:'..type(eo))assert(dr(ep),'Argument 7 (gravityAtPosition) must be number:'..type(ep))local dV=dm(el/4/math.pi)local ca=dV+eo;local eq=vec3(em)+ca*vec3(en)local dX=ep*ca*ca;return dS(dT,dU,dV,eq,dX)end;ed.isMapPosition=dx;function ed:getPlanetarySystem(d_)if M==nil then M=0 end;if eg==nil then eg=0 end;local dT=d_;if dx(d_)then dT=d_.systemId end;if type(dT)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eg)~=e4 then a=ea(a)end;return a end end end;function e4:sizeCalculator(er)return 1.05*er.radius end;function e4:castIntersections(es,et,eu,ev,ew,ex)local ey={}if ew then for dP,er in pairs(ew)do table.insert(ey,er)end else ey=d3 end;if not ex then table.sort(ey,function(ez,eA)local eB=ez.center;local eC=eA.center;return(eB.x-es.x)^2+(eB.y-es.y)^2+(eB.z-es.z)^2<(eC.x-es.x)^2+(eC.y-es.y)^2+(eC.z-es.z)^2 end)end;local eD=et:normalize()for dP,er in ipairs(ey)do local eE=er.center-es;local dV;if eu then dV=eu(er)else dV=self:sizeCalculator(er)end;local eF=eE:dot(eD)local eG=eF^2-(eE:len2()-dV^2)if eG>=0 then local eH=dm(eG)local eI=eF+eH;local eJ=eF-eH;if eJ>0 then return er,eI,eJ elseif eI>0 then return er,eI,nil end end end;return nil,nil,nil end;function e4:closestBody(eK)assert(type(eK)=='table','Invalid coordinates.')local eL,er;local eM=vec3(eK)for dP,eN in pairs(self)do local eO=(eN.center-eM):len2()if(not er or eO<eL)and eN.name~="Space"then er=eN;eL=eO end end;return er end;function e4:convertToBodyIdAndWorldCoordinates(d_)local eP=d_;if du(d_)then eP=dZ(d_)end;if eP.id==0 then return 0,vec3(eP.latitude,eP.longitude,eP.altitude)end;local eN=self:getBodyParameters(eP)if eN then return eP.id,eN:convertToWorldCoordinates(eP)end end;function e4:getBodyParameters(d_)local dU=d_;if dx(d_)then dU=d_.id end;assert(dr(dU),'Argument 1 (id) must be a number:'..type(dU))return self[dU]end;function e4:getPlanetarySystemId()local dP,dw=next(self)return dw and dw.systemId end;function dM:convertToMapPosition(dW)assert(ds(dW),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dW))local eQ=vec3(dW)if self.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=self.systemId},dY)end;local eR=eQ-self.center;local ca=eR:len()local e2=ca-self.radius;local e0=0;local e1=0;if not dn(ca,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/ca)end;return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=self.id,systemId=self.systemId},dY)end;function dM:convertToWorldCoordinates(d_)local eP=du(d_)and dZ(d_)or d_;if eP.id==0 then return vec3(eP.latitude,eP.longitude,eP.altitude)end;assert(dx(eP),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eP.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eP.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eU=math.cos(eP.latitude)return self.center+(self.radius+eP.altitude)*vec3(eU*math.cos(eP.longitude),eU*math.sin(eP.longitude),math.sin(eP.latitude))end;function dM:getAltitude(dW)return(vec3(dW)-self.center):len()-self.radius end;function dM:getDistance(dW)return(vec3(dW)-self.center):len()end;function dM:getGravity(dW)local eV=self.center-vec3(dW)local eW=eV:len2()return self.GM/eW*eV/dm(eW)end;return setmetatable(ed,{__call=function(dP,...)return ee(...)end})end;local function eX(d,b,c,a,dm,eY)local co={}local bO=100000000/3600;local eZ=bO*bO;local e_=100;function co.computeAccelerationTime(f0,f1,f2)local f3=bO*math.asin(f0/bO)return(bO*math.asin(f2/bO)-f3)/f1 end;function co.computeDistanceAndTime(f0,f2,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f0<=f2;local f9=f5*(f8 and 1 or-1)/f4;local fa=-f7/f4;local fb=f9+fa;if f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local f3=math.asin(f0/bO)local fe=math.pi*(f9/2+fa)local ff=f9*f6;local fg=bO*math.pi;local dw=function(dt)local fh=(fe*dt-ff*math.sin(math.pi*dt/2/f6)+fg*f3)/fg;local fi=math.tan(fh)return bO*fi/dm(fi*fi+1)end;local fj=f8 and function(a)return a>=f2 end or function(a)return a<=f2 end;fd=2*f6;if fj(dw(fd))then local fk=0;while eY(fd-fk)>0.5 do local dt=(fd+fk)/2;if fj(dw(dt))then fd=dt else fk=dt end end end;local fl=f0;local fm=fd/e_;for fn=1,e_ do local fo=dw(fn*fm)fc=fc+(fo+fl)*fm/2;fl=fo end;if fd<2*f6 then return fc,fd end;f0=fl end;local f3=bO*math.asin(f0/bO)local bP=(bO*math.asin(f2/bO)-f3)/fb;local fp=eZ*math.cos(f3/bO)/fb;local ca=fp-eZ*math.cos((fb*bP+f3)/bO)/fb;return ca+fc,bP+fd end;function co.computeTravelTime(f0,f1,ca)if ca==0 then return 0 end;if f1>0 then local f3=bO*math.asin(f0/bO)local fp=eZ*math.cos(f3/bO)/f1;return(bO*math.acos(f1*(fp-ca)/eZ)-f3)/f1 end;if f0==0 then return-1 end;assert(f0>0,'Acceleration and initial speed are both zero.')return ca/f0 end;return co end;local function fq(d,b,c,a,dj,dk,dl,dm,dn)local vec3=vec3;local di=di(d,b,c,a,dj,dk,dl,dm,dn)local function du(a)return type(a)=='string'end;local function ds(dt)return type(dt)=='table'end;fr={}fr.__index=fr;function fr:escapeAndOrbitalSpeed(e2)assert(self.body)local ca=e2+self.body.radius;if not dn(ca,0)then local fs=dm(self.body.GM/ca)return dm(2)*fs,fs end;return nil,nil end;function fr:orbitalParameters(d_,ft)assert(self.body)assert(ds(d_)or du(d_))assert(ds(ft))local fu=(du(d_)or di.isMapPosition(d_))and self.body:convertToWorldCoordinates(d_)or vec3(d_)local dw=vec3(ft)local fv=fu-self.body.center;local fw=dw:len2()local fx=fv:len()local fy=self.body.GM;local fz=((fw-fy/fx)*fv-fv:dot(dw)*dw)/fy;local eB=fy/(2*fy/fx-fw)local fA=fz:len()local eD=fz:normalize()local fB=eB*(1-fA)local fC=eB*(1+fA)local fD=fB*eD+self.body.center;local fE=fA<=1 and-fC*eD+self.body.center or nil;local fF=dm(eB*fy*(1-fA*fA))local fG=fE and 2*math.pi*dm(eB^3/fy)local fH=math.acos(fz:dot(fv)/(fA*fx))if fv:dot(dw)<0 then fH=-(fH-2*math.pi)end;local fI=math.acos((math.cos(fH)+fA)/(1+fA*math.cos(fH)))local fJ=fI;if fJ<0 then fJ=fJ+2*math.pi end;local fK=fJ-fA*math.sin(fJ)local fL=0;local fM=0;local fN=0;if fG~=nil then fL=fK/(2*math.pi/fG)fM=fG-fL;fN=fM+fG/2;if fH-math.pi>0 then fM=fL;fN=fM+fG/2 end;if fN>fG then fN=fN-fG end end;return{periapsis={position=fD,speed=fF/fB,circularOrbitSpeed=dm(fy/fB),altitude=fB-self.body.radius},apoapsis=fE and{position=fE,speed=fF/fC,circularOrbitSpeed=dm(fy/fC),altitude=fC-self.body.radius},currentVelocity=dw,currentPosition=fu,eccentricity=fA,period=fG,eccentricAnomaly=fI,meanAnomaly=fK,timeToPeriapsis=fM,timeToApoapsis=fN,trueAnomaly=fH}end;local function fO(fP)local eN=di.BodyParameters(fP.systemId,fP.id,fP.radius,fP.center,fP.GM)return setmetatable({body=eN},fr)end;return setmetatable(fr,{__call=function(dP,...)return fO(...)end})end;local function fQ(d,b,c,a,dbHud_1,e,fR,fS,bM,dl,dm,fT,fU)local function fV(fW)local dg=fX:closestBody(fW)if(fW-dg.center):len()>dg.radius+dg.noAtmosphericDensityAltitude then dg=e[0][0]end;return dg end;local function fY()local function fZ(f_,g0)return f_.name<g0.name end;cT={}for dK,dw in pairs(e[0])do cT[#cT+1]={name=dw.name,index=dK}end;table.sort(cT,fZ)end;local function g1(g2,g3)if not g3 then g3=g4.name end;for dK,dw in pairs(g2)do if dw.name and dw.name==g3 then return dK end end;return-1 end;local function g5()d0=bl;if bl==0 then bj="None"c7=nil;g4=nil;return true end;local g6=cT[bl].index;local g7=e[0][g6]if g7.center then bj=g7.name;c7=cn[0][g6]if g4~=nil then if cg==0 then if fR(g8,g9)~=1 then fS(g8,g9)end;if fR(ga,gb)~=1 then fS(ga,gb)end;if fR(gc,gd)~=1 then fS(gc,gd)end;if fR(ge,gf)~=1 then fS(ge,gf)end;if fR(gg,gh)~=1 then fS(gg,gh)end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end;if fR(gm,gn)~=1 then fS(gm,gn)end end;g4=nil else g4=g7;for dP,dw in pairs(cn[0])do if dw.name==g4.planetname then c7=dw;bj=g4.name;break end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end end;if g4==nil then bk=vec3(c7.center)else bk=g4.position end;if c7.planetname~="Space"then if c7.hasAtmosphere then go=bM(c7.radius*(U-1)+c7.noAtmosphericDensityAltitude)else go=bM(c7.radius*(U-1)+c7.surfaceMaxAltitude)end else go=T end;if g4~=nil and g4.planetname=="Space"then bf=0 else dP,bf=cp(c7):escapeAndOrbitalSpeed(go)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gp(gq)if not b3 and not bq and not cc and not bz and not b8 and not cd then if gq==nil then bl=bl+1;if bl>#cT then bl=0 end else bl=bl-1;if bl<0 then bl=#cT end end;if bl==0 then g5()else local g6=cT[bl].index;local g7=e[0][g6]if g7 and(g7~=nil and g7.name=="Space"or bA=="Custom Only"and g7.center or bA=="No Moons-Asteroids"and(string.find(g7.name,"Moon")~=nil or string.find(g7.name,"Asteroid")~=nil))then if gq==nil then gp()else gp(1)end else g5()end end else c2="Disengage autopilot before changing Interplanetary Helper"fT("iph","AP")end end;local function gr()local function gs(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=-1;gv=g1(e[0])if gv>-1 then table.remove(e[0],gv)end;gv=-1;gv=g1(gu)if gv~=-1 then c2=g4.name.." saved location cleared"table.remove(gu,gv)end;gp()fY()return gu end;if string.sub(bj,1,1)=="*"then d8=gs(true)else bp=gs(false)end end;local function gw(gx,fW,gy,gz)local function gA(gt)if gt then gu=d8 else gu=bp end;if dbHud_1 or gy or gt then local dg=fV(fW)local gB={position=fW,name=gx,planetname=dg.name,gravity=b.getGravityIntensity(),safe=gz}if not gy then gu[#gu+1]=gB else for dK,dw in pairs(e[0])do if dw.name and gx==dw.name then table.remove(e[0],dK)end end end;table.insert(e[0],gB)fY()g5()c2="Location saved as "..gx.."("..dg.name..")"return gu else c2="Databank must be installed to save permanent locations"end end;if string.sub(gx,1,1)=="*"then d8=gA(true)else bp=gA(false)end end;local gC={}function gC.UpdateAtlasLocationsList()fY()end;function gC.UpdateAutopilotTarget()g5()end;function gC.adjustAutopilotTargetIndex(gq)gp(gq)end;function gC.findAtlasIndex(g2,g3)return g1(g2,g3)end;function gC.UpdatePosition(gD,gE,gF)local function gG(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=g1(gu)if gv~=-1 then if gD~=nil then if gt then gD="*"..gD end;gu[gv].name=gD;bl=bl-1;gp()elseif gF~=nil then if gF then local gH=ch;if gH<1000 then gH=1000 end;gu[gv].agg=fU(gH,0)c2=gu[gv].name.." AGG Altitude:"..gu[gv].agg.." saved ("..gu[gv].planetname..")"return elseif gF==false then gu[gv].agg=nil;c2=gu[gv].name.." AGG Altitude cleared ("..gu[gv].planetname..")"return end else local gI=gu[gv]if gE then gI.heading=cH:cross(cL)*5000;c2=gu[gv].name.." heading saved ("..gu[gv].planetname..")"return elseif gE==false then gI.heading=nil;c2=gu[gv].name.." heading cleared ("..gu[gv].planetname..")"return end;gI.gravity=b.getGravityIntensity()gI.position=cN;gI.safe=true end;c2=gu[gv].name.." position updated ("..gu[gv].planetname..")"else c2="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gG(true)else gG(false)end end;function gC.AddNewLocation(gx,fW,gy,gz)gw(gx,fW,gy,gz)end;function gC.ClearCurrentPosition()gr()end;for dK,dw in pairs(d9)do table.insert(e[0],dw)end;if gJ then for dK,dw in pairs(gJ)do gC[dK]=dw end end;fY()if bl>#cT then bl=0 end;gC.UpdateAutopilotTarget()return gC end;local function gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)local gO={}local gP={}local gQ={XS=13,S=27,M=55,L=110,XL=221}local gR={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gS={}local gT=0;local gU;local gV;local gW=0;local gX;local gY={gX}local gZ="Atmo"local g_;local h0;local h1=0;local h2={}local h3;local h4=0;local h5=table.insert;local h6=-4;local h7={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h8,h9;local ha,hb;local hc;local hd;local he;local hf;local hg;local hh;local hi;local function hj()if hk~=nil and h1==0 then gL(hk)a.destroyWidget(h8)a.destroyData(ha)h8,ha,hk=nil,nil,nil;if h0~=nil then gL(h0)a.destroyWidget(h9)a.destroyData(hb)h0,h9,hb=nil,nil,nil end else if h1==1 then h0=a.createWidgetPanel("PeriWinkle")h9=a.createWidget(h0,'periscope')hb=gX.getWidgetDataId()a.addDataToWidget(hb,h9)end;if hk==nil and gT>0 then hk=a.createWidgetPanel(gZ)h8=a.createWidget(hk,'radar')ha=gX.getWidgetDataId()a.addDataToWidget(ha,h8)end;h1=0 end end;local function hl()local function hm(hn,ho,hp,hq,hr,hs,ht,hu)ho,hq,hs,hu=vec3(ho),vec3(hq),vec3(hs),vec3(hu)local hv,hw,hx=hn*hn,hp*hp,hr*hr;local fw=hq-ho;local hy=fw:normalize()local hz=fw:len()local hA=hs-ho;local hB=(hA-hA:project_on(hy)):normalize()local hC,hD=hA:dot(hy),hA:dot(hB)local hE=hC*hC+hD*hD;local hF=hy:cross(hB)local hG=(hv-hw+hz*hz)/(2*hz)local hH=(hv-hx+hE-2*hC*hG)/(2*hD)local dy=hv-hG^2-hH^2;local hI=dm(dy)local hJ=ho+hy*hG+hB*hH+hF*hI;local hK=ho+hy*hG+hB*hH-hF*hI;if eY((hu-hJ):len()-ht)<eY((hu-hK):len()-ht)then return hJ else return hK end end;local function hL(hM,fx,hN)local hO=hM.pts;local gv=#hO;local hP=hM.ref;if gv>3 then local hQ,hR,hS,hT=hO[gv],hO[gv-1],hO[gv-2],hO[gv-3]hM.ref=hN;local fu=hm(hQ[1],hQ[2],hR[1],hR[2],hS[1],hS[2],hT[1],hT[2])local hG,hH,hI=fu.x,fu.y,fu.z;if hG==hG and hH==hH and hI==hI then hG=hG+hP[1]hH=hH+hP[2]hI=hI+hP[3]local hU=vec3(hG,hH,hI)hM.center=hU;if hM.lastPos then if(hM.lastPos-hU):len()<2 then local hV=(hU-vec3(hN)):len()if eY(hV-fx)<10 then hM.skipCalc=true end end end;hM.lastPos=hU end;hM.pts={}else local hW={hN[1]-hP[1],hN[2]-hP[2],hN[3]-hP[3]}hO[gv+1]={fx,hW}end end;if radar_1 or radar_2 then ct.assignRadar()end;if gX then if#h3>0 then local hX,hY=0,0;local hZ=cK*10;local cX=cX;gW,gV=0,0;gP={}for dP,dw in pairs(h3)do local ca=hg(dw)if ca>0.0 then if hc(dw)==1 then h5(gP,dw)end;if not cU and warpdrive and ca<aa and warpdrive.getStatus()==15 then c2="INITIATING WARP"c3=7;warpdrive.initiate()end;local h_=F and he(dw)==1;if E or h_ then local i0=hh(dw)local i1=gQ[i0]local i2=hd(dw)if h_ or ca<hZ and(i1>27 or i2==4 or i2==6)then gW=gW+1;local hN={cN["x"],cN["y"],cN["z"]}local hM=h2[dw]if hM==nil then i1=i1+gN;h2[dw]={pts={},ref=hN,name=hf(dw),i=0,radius=i1,skipCalc=false}hM=h2[dw]end;if not hM.skipCalc then if h_ or i2==4 or i2==6 then hM.center=vec3(hi(dw))hM.skipCalc=true else hL(hM,ca,hN)hY=hY+1 end;if h_ and not hM.abandoned then local bP=a.getArkTime()if h4+5<bP then h4=bP;fT("abRdr","RD")end;a.print("Abandoned Construct: "..hM.name.." ("..i0 .." "..gR[i2]..") at ::pos{0,0,"..hM.center.x..","..hM.center.y..","..hM.center.z.."}")c2="Abandoned Radar Contact ("..i0 .." "..gR[i2]..") detected"hM.abandoned=true end else h5(gS,hM)end end;hX=hX+1;if hX>300 or hY>30 then coroutine.yield()hX,hY=0,0 end end end end;gV=#gS;if gV>0 and(cK>20 or b6)then local er,i3,i4,i5;local i6=0;local i7=cn:getPlanetarySystem(0)i5=cJ:normalize()while i6<gV do coroutine.yield()local i8={table.unpack(gS,i6,math.min(i6+75,gV))}er,i3,i4=i7:castIntersections(cN,i5,nil,nil,i8,true)if er and i4 then cZ={er,i3,i4}break end;i6=i6+75 end;if not er then cZ=nil end else cZ=nil end;gS={}gU=gX.getTargetId()end end end;local function i9()if gX then gZ="Atmo"if string.find(gX.getName(),"Space")then gZ="Space"end end end;function gO.pickType()i9()end;function gO.assignRadar()if radar_2 and h6~=1 then if h6==-1 then if gX==radar_2 then gX=radar_1 else gX=radar_2 end end;gY={gX}hc=gX.hasMatchingTransponder;hd=gX.getConstructKind;he=gX.isConstructAbandoned;hf=gX.getConstructName;hg=gX.getConstructDistance;hh=gX.getConstructCoreSize;hi=gX.getConstructWorldPos;h3=gX.getConstructIds()i9()else h3=gX.getConstructIds()end;h6=gX.getOperationalState()end;function gO.UpdateRadar()local ia=coroutine.status(g_)if ia=="suspended"then local dL,ib=coroutine.resume(g_)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then g_=coroutine.create(hl)local dL,ib=coroutine.resume(g_)end end;function gO.GetRadarHud(ic,id,ax,ay)local ie,dh;local dC=gV or 0;gT=#h3;if gT>0 then if E then dh=dC.."/"..gW.." Known/InRange : "..gT.." Total"else dh="Radar Contacts: "..gT end;ie=gM(ax,ay,dh,"pbright txtbig txtmid")if#gP>0 then ie=ie..gM(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dK,dw in pairs(gP)do id=id+20;ie=ie..gM(ic,id,gX.getConstructName(dw),"pdim txtmid")end end;local ig=#gX.getIdentifiedConstructIds()if h0==nil and ig>0 then h1=1;ct.ToggleRadarPanel()end;if h0~=nil and ig==0 then ct.ToggleRadarPanel()end;if hk==nil then if w then ct.ToggleRadarPanel()end end else if h6~=1 then ie=gM(ax,ay,gZ.." Radar: "..h7[h6],"pbright txtbig txtmid")else ie=gM(ax,ay,"Radar: No "..gZ.." Contacts","pbright txtbig txtmid")end;if hk~=nil then h1=0;ct.ToggleRadarPanel()end end;return ie end;function gO.GetClosestName(gx)if gX then local ih=gX.getConstructName(gX.getConstructIds()[1])if ih then gx=gx.." "..ih end end;return gx end;function gO.ToggleRadarPanel()hj()end;function gO.ContactTick()if not ii then ii=0 end;if bP>ii+10 then c2="Radar Contact"fT("rdrCon","RC")ii=bP end;c.stopTimer("contact")end;function gO.onEnter(dU)if gX and not cf and not cU then c.setTimer("contact",0.1)end end;function gO.onLeave(dU)if gX and E then if#h2>650 then dU=tostring(dU)h2[dU]=nil end end end;local function ij()gX=nil;if radar_2 and radar_2.getOperationalState()==1 then gX=radar_2 else gX=radar_1 end;h6=gX.getOperationalState()hc=gX.hasMatchingTransponder;hd=gX.getConstructKind;he=gX.isConstructAbandoned;hf=gX.getConstructName;hg=gX.getConstructDistance;hh=gX.getConstructCoreSize;hi=gX.getConstructWorldPos;gY={gX}h3=gX.getConstructIds()i9()g_=coroutine.create(hl)if ik then for dK,dw in pairs(ik)do gO[dK]=dw end end end;ij()return gO end;local function il(shield,e3,bM)local im={}local io=shield.getResistancesCooldown()local function ip()local iq=shield.isActive()if G then if not cU and iq==0 and shield.isVenting()~=1 then shield.toggle()elseif cU and iq==1 then shield.toggle()end end end;local function ir()local is=shield.getStressRatioRaw()local it=0.5999;if is[1]==0.0 and is[2]==0.0 and is[3]==0.0 and is[4]==0.0 then return end;local iu=shield.setResistances(it*is[1],it*is[2],it*is[3],it*is[4])if iu==1 then c2="Shield Resistances updated"else c2="Value Exceeded. Failed to update Shield Resistances"end end;function im.shieldTick()df=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ip()io=shield.getResistancesCooldown()if io==0 and df<a9 then ir()end end;function im.setResist(iv)if not shield then c2="No shield found"return elseif iv==nil or io>0 then c2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD=dC..', '..dC..', '..dC..', '..dC;local iw,ix,iy,iz=e3(iv,dD)if iz==nil or iw+ix+iy+iz>0.6 then c2="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iw,ix,iy,iz)==1 then c2="Shield Resistances set"else c2="Resistance setting failed."end end;function im.ventShield()local iA=shield.getVentingCooldown()if iA>0 then c2="Cannot vent again for "..iA.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c2="Shields already at max hitpoints"end end;if iB then for dK,dw in pairs(iB)do im[dK]=dw end end;return im end;local function iC(d,b,c,a,e,antigrav,hover,shield,warpdrive,iD,eY,bM,dj,iE,bN,iF,iG,eT,bL,dk,iH,fS,fR,gL,iI,dm,fU,gM,fT,iJ,iK,iL,iM,iN,iO)local bO=DUConstruct;local iP=9.80665;local iQ={}local iR={}local iS={}local iT={}local iU=nil;local iV=nil;local iW=nil;local iX=false;local iY="none"local iZ=""local i_=55;local j0=0;local j1=0;local j2=nil;local j3=af;local j4=ag;local j5=ah;local j6=[[rgb(]]..bM(j3+0.5)..","..bM(j4+0.5)..","..bM(j5+0.5)..[[)]]local j7=[[rgb(]]..bM(j3*0.9+0.5)..","..bM(j4*0.9+0.5)..","..bM(j5*0.9+0.5)..[[)]]local j8=0;local j9=0;local ja=""local jb=bL()local jc=false;local jd=false;local gX=false;local function je(dw)if ac==1920 then return dw else return fU(ac*dw/1920,0)end end;local function jf(dw)if ad==1080 then return dw else return fU(ad*dw/1080,0)end end;local function jg()return iI()==0 and g~="keyboard"and iG()==0 end;local function jh()local ji="TRAVEL"if not cQ then ji="CRUISE"end;if b3 then ji="AUTOPILOT"end;return ji end;local ie=""local jj=""local jk=""local jl=1;local jm=2;local jn=3;local jo=4;local jp=5;local jq=6;local jr=7;local js=""local jt=0;local ju=15.0*aT;local jv={}local jw={}local jx={}local jy={}local jz={}local jA={}local jB={}jB["atmofueltank"],jB["spacefueltank"],jB["rocketfueltank"]=0,0,0;local jC=0;local function jD(hG,jE,jF,jG,jH,jI)local jJ=jC;local jK=jC+5;if not B then jK=jK+5 end;if iG()==1 and not m then jJ=jJ-50;jK=jK-50 end;if jF=="ATMO"then js="atmofueltank"elseif jF=="SPACE"then js="spacefueltank"else js="rocketfueltank"end;jt=_G[js.."_size"]if#jG>0 then for M=1,#jG do local gx=jG[M][jm]local jL=jG[M][jr]for jM=1,jt do if jG[M][jm]==iE(c[js.."_"..jM].getWidgetData()).name then jL=jM;break end end;local jN=bL()if jH[M]==nil or jI[M]==nil or jN-jG[M][jq]>ju then local jO;local jP=0;jP=iF(jG[M][jl])-jG[M][jo]jO=jG[M][jp]local jQ=jO>jP or false;if jQ then jB[js]=jB[js]+jO-jP end;if jL~=0 then local jR=iE(c[js.."_"..jL].getWidgetData())jI[M]=jR.percentage;jH[M]=jR.timeLeft;if jH[M]=="n/a"then jH[M]=0 end else jI[M]=bM(0.5+jP*100/jG[M][jn])if jQ then jH[M]=bM(0.5+jP/((jO-jP)/(jN-jG[M][jq])))else jH[M]=0 end end;jG[M][jq]=jN;jG[M][jp]=jP end;if gx==jE then gx=dj("%s %d",jF,M)end;if jL==0 then gx=gx.." *"end;local jS;jS=iM(jH[M])if jH[M]==0 or jS==">1y"then jS=""end;if jI[M]~=nil then local jT=bM(jI[M]*2.55)local jU=dj("rgb(%d,%d,%d)",255-jT,jT,0)local jV=""if jS~=""and jH[M]<120 or jI[M]<5 then jV="red "end;local jW=dj("rgb(%d,%d,%d)",dk(bM((255-jT)/2.55),50,100),dk(bM(jT/2.55),0,50),50)local jX="rgb(196,0,255)"if jF=="ATMO"then jX="rgb(0,188,255)"elseif jF=="SPACE"then jX="rgb(239,255,0)"end;local jY=false;if jZ~=jX then jY=true end;jZ=jX;if B then if jY then jJ=jJ-5;jK=jK-5 end;jj=jj..dj([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jW,jX,hG,jK,jU,bM(jI[M]*1.7+0.5)-2,hG+1,jK+1,hG+5,jK+14,gx,jI[M],jS)jJ=jJ-22;jK=jK-22 else jj=jj..gM(hG,jJ,gx,jV.."pdim txtfuel")jj=jj..gM(hG,jK,dj("%d%% %s",jI[M],jS),"pdim txtfuel","fill:"..jU)jJ=jJ+30;jK=jK+30 end end end end;jC=jJ end;local function j_(k0,e2)if ap==0 and aq==0 then return end;if e2<200000 and not cf or e2 and cf then local k1=0;if eY(cM)>1 then k1=45*math.log(eY(cM),10)if cM<0 then k1=-k1 end end;k0[#k0+1]=dj([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bM(cM),bM(k1))end;return k0 end;local function k2(k3)local gq=-cL;k3=k3-k3:project_on(gq)local k4=vec3(0,0,1)k4=k4-k4:project_on(gq)local k5=k4:cross(gq)local k1=k4:angle_between(k3)*constants.rad2deg;if k3:dot(k5)<0 then k1=360-k1 end;return k1 end;local function k6(k0,al,am,k7,k8,cX)if ae==0 then return end;local k9=ae;local ka=20;local kb=bM(k7)if cX then for M=-45,45,5 do local kc=M;k0[#k0+1]=dj([[<g transform="rotate(%f,%d,%d)">]],kc,al,am)kd=5;if M%15==0 then kd=15 elseif M%10==0 then kd=10 end;k0[#k0+1]=dj([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k9+ka-kd,al,am+k9+ka)end;k0[#k0+1]=gM(al,am+k9+ka-35,k8,"pdim txt txtmid")k0[#k0+1]=gM(al,am+k9+ka-25,kb.." deg","pdim txt txtmid")k0[#k0+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k7,al,am)k0[#k0+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k9+ka-20,al+5,am+k9+ka-20,al,am+k9+ka-15)k0[#k0+1]="</g>"end;k0[#k0+1]=[[<g style="clip-path: url(#headingClip);">]]local ke=kb;if cX then ke=k2(cG)end;local kf=20;local kg=bM(ke)local kh=0;local ki=am+k9+ka+20;local kj=al;if k8~="YAW"then ki=jf(130)kj=je(960)end;local kk=[[<path class="txttick line" d="]]local kl=bM(kg-(kf+10)-kg%5+0.5)for M=kl+70,kl,-5 do local hG=kj-(-M*5+ke*5)if M%10==0 then kh=10;local dC=M;if dC==360 then dC=0 elseif dC>360 then dC=dC-360 elseif dC<0 then dC=dC+360 end;k0[#k0+1]=gM(hG,ki+15,dC,"txtmid bright")elseif M%5==0 then kh=5 end;if kh==10 then kk=dj([[%s M %f %f v %d]],kk,hG,ki-5,kh)else kk=dj([[%s M %f %f v %d]],kk,hG,ki-2.5,kh)end end;k0[#k0+1]=kk..[["/>]]k0[#k0+1]=dj([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kj-5,ki-20,kj+5,ki-20,kj,ki-10)if cX then k8="HDG"end;k0[#k0+1]=gM(je(960),jf(100),kg.."°","dim txt txtmid size14","")k0[#k0+1]=gM(je(960),jf(85),k8,"dim txt txtmid size20","")k0[#k0+1]=[[</g>]]end;local function km(k0,kn,k7,al,am,cX,ko,fo)if ae==0 then return end;local k9=ae;local kp=bM(k9*3/5)if k9>0 then local kq=bM(kn)local kd=0;local kk=dj([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k7,al,am)if not cf then kk=dj([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;k0[#k0+1]=dj([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k9-1,al,am)k0[#k0+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bM(kq-30-kq%5+0.5),bM(kq+30+kq%5+0.5),5 do if M%10==0 then kd=30 elseif M%5==0 then kd=20 end;local hH=am+-M*5+kn*5;if kd==30 then kk=dj([[%s M %d %f h %d]],kk,al-kp-kd,hH,kd)if cf then k0[#k0+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k7,al,am,al-kp+10,hH+4,M)k0[#k0+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k7,al,am,al+kp-10,hH+4,M)if M==0 or M==180 or M==-180 then k0[#k0+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k7,al,am,al-kp+20,hH,kp*2-40)end else k0[#k0+1]=gM(al-kp+10,hH,M,"pdim txt txtmid")k0[#k0+1]=gM(al+kp-10,hH,M,"pdim txt txtmid")end;kk=dj([[%s M %d %f h %d]],kk,al+kp,hH,kd)else kk=dj([[%s M %d %f h %d]],kk,al-kp-kd,hH,kd)kk=dj([[%s M %d %f h %d]],kk,al+kp,hH,kd)end end;k0[#k0+1]=kk..[["/>]]local kr="PITCH"if not cX then kr="REL PITCH"end;if kn>90 and not cf then kn=90-(kn-90)elseif kn<-90 and not cf then kn=-90-(kn+90)end;if k9>200 then if cf then if fo>i_ then k0[#k0+1]=gM(al,am-15,"Yaw","pdim txt txtmid")k0[#k0+1]=gM(al,am+20,ko,"pdim txt txtmid")end;k0[#k0+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k7,al,am)else k0[#k0+1]=dj([[<g transform="rotate(0,%d,%d)">]],al,am)end;k0[#k0+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kp+25,am-5,al-kp+20,am,al-kp+25,am+5,al-kp+50,am+4,kq)k0[#k0+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kp-25,am-5,al+kp-20,am,al+kp-25,am+5,al+kp-30,am+4,kq)k0[#k0+1]="</g>"end;local ks=bM(k9/3)k0[#k0+1]=dj([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-ks,am,k9-ks)if not cf and cX then k0[#k0+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k7,al,am,al-kp+10,am,kp*2-20)end;k0[#k0+1]="</g>"if k9<200 then if cf and fo>i_ then k0[#k0+1]=gM(al,am-k9,kr,"pdim txt txtmid")k0[#k0+1]=gM(al,am-k9+10,kq,"pdim txt txtmid")k0[#k0+1]=gM(al,am-15,"Yaw","pdim txt txtmid")k0[#k0+1]=gM(al,am+20,ko,"pdim txt txtmid")else k0[#k0+1]=gM(al,am-k9,kr,"pdim txt txtmid")k0[#k0+1]=gM(al,am-k9+15,kq,"pdim txt txtmid")end end end end;local function kt(k0,e2,cX)local ku=ar;local kv=as;if ku==0 and kv==0 then return end;local kw=78;local kx=19;local ky=ce;if ce~=-1 then k0[#k0+1]=gM(ku+kw,kv+kx+20,dj("AGL: %.1fm",ce),"pdim altsm txtend")end;if cX and(e2<200000 and not cf or e2 and cf)then table.insert(k0,dj([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ku-1,kv-4,kw+2,kx+6,ku+1,kv-1,kw-4,kx))local gv=0;local kz=1;local kA=0;local kB=e2<0;local kC=e2<kD.surfaceMaxAltitude;local kE=9;if kB then kE=0 end;local e2=eY(e2)while gv<6 do local kF=11;local kG=16;local kH=9;local kI=14;local jV="altsm"if gv>2 then kG=kG+3;kF=kF+2;kI=kI+2;kH=kH-6;jV="altbig"end;if kB then jV=jV.." red"elseif kC then jV=jV.." orange"end;local kJ=e2/kz%10;local kK=bM(kJ)local kL=bM((kK+1)%10)local kM=kA;if gv==0 then kM=kJ-kK;if kB then kM=1-kM end end;if kB and(gv==0 or kA~=0)then local gy=kL;kL=kK;kK=gy end;local kN=kG*(kM-1)local kO=kN+kG;local hG=ku+kH+(6-gv)*kF;local hH=kv+kI;k0[#k0+1]=gM(hG,hH+kN,kL,jV)k0[#k0+1]=gM(hG,hH+kO,kK,jV)gv=gv+1;kz=kz*10;if kK==kE then kA=kM else kA=0 end end;table.insert(k0,[[</g></g>]])end end;local function kP(ft)local kQ=-math.deg(eT(ft.y,ft.z))+180;kQ=kQ-90;if kQ<0 then kQ=360+kQ end;if kQ>180 then kQ=-180+kQ-180 end;return-kQ end;local function kR(ft)local ke=math.deg(eT(ft.y,ft.x))-90;if ke<-180 then ke=360+ke end;return ke end;local function kS(k0,ft,fo,al,am)if fo>5 and not cf or fo>i_ then local k9=ae;local kT=20;local kU=20;local kV=kP(ft)local kW=kR(ft)local kX=14;local kY=kX/2;local kZ=-kW/kU*k9;local k_=kV/kT*k9;local hG=al+kZ;local hH=am+k_;local ca=dm(kZ^2+k_^2)local l0=[[<circle
                            cx="]]..hG..[["
                            cy="]]..hH..[["
                            r="]]..kY/kX..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hG..[["
                            cy="]]..hH..[["
                            r="]]..kY..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hG-kX..[[,]]..hH..[[ h ]]..kY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hG+kY..[[,]]..hH..[[ h ]]..kY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hG..[[,]]..hH-kX..[[ v ]]..kY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ca<k9 then k0[#k0+1]=l0 else local k1=eT(k_,kZ)local l1=4;local l2=al+k9*math.cos(k1)local l3=am+k9*math.sin(k1)k0[#k0+1]=dj('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',k1*180/math.pi,l2,l3,l2-l1,l3-l1/2,l1*2,l1,l2+l1,l3-l1,l1,l1,-l1,l1)end;if not cf then local l4=vec3(ft)kV=kP(-l4)kW=kR(-l4)kZ=-kW/kU*k9;k_=kV/kT*k9;hG=al+kZ;hH=am+k_;ca=dm(kZ^2+k_^2)if ca<k9 then local l5=[[<circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hG..[[,]]..hH-kX..[[ v ]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hG..[[,]]..hH..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hG..[[,]]..hH..[[)" />
                                <path
                                    d="M ]]..hG-kY..[[,]]..hH..[[ h ]]..kX..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hG..[[,]]..hH..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hG..[[,]]..hH..[[)"/>]]k0[#k0+1]=l5 end end end end;local function l6(k0,ji,l7,l8)if an==0 and ao==0 then return end;l7=bM(l7+0.5)local jJ=ao+10;local jK=ao+20;if iG()==1 and not m then jJ=55;jK=65 end;local l9="CRUISE"local c="km/h"local dL=l8;if ji=="TRAVEL"or ji=="AUTOPILOT"then l9="THROT"c="%"dL=l7;local la="dim"if l7<0 then la="red"end;k0[#k0+1]=dj([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],la,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-eY(l7),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;k0[#k0+1]=gM(an+10,jJ,l9,"pbright txtstart")k0[#k0+1]=gM(an+10,jK,dj("%.0f %s",dL,c),"pbright txtstart")if cf and t and cQ and bS then l7=bM(bT*100+0.5)local la="red"if l7<0 then la="red"end;k0[#k0+1]=dj([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],la,1-eY(l7),an-10,ao+50,an-15,ao+53,an-15,ao+47)k0[#k0+1]=gM(an+10,jJ+40,"LIMIT","pbright txtstart")k0[#k0+1]=gM(an+10,jK+40,l7 .."%","pbright txtstart")end;if cf and t or b8 then k0[#k0+1]=gM(an+10,jJ-40,"LIMIT: "..cA.." km/h","dim txtstart")elseif not cf and b3 then k0[#k0+1]=gM(an+10,jJ-40,"LIMIT: "..bM(a1*3.6+0.5).." km/h","dim txtstart")end end;local function lb(k0,lc)if an==0 and ao==0 then return end;local ld=ao-10;local le=an+10;k0[#k0+1]=gM(0,0,"","pdim txt txtend")if iG()==1 and not m then ld=75 end;k0[#k0+1]=gM(le,ld,bM(lc).." km/h","pbright txtbig txtstart")end;local lf=40;local function lg(k0)k0[#k0+1]=gM(je(150),jf(1070),dj("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")k0[#k0+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then k0[#k0+1]=gM(je(960),jf(550),"Warning: Invalid Control Scheme Detected","warnings")k0[#k0+1]=gM(je(960),jf(600),"Keyboard Scheme must be selected","warnings")k0[#k0+1]=gM(je(960),jf(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lh=je(960)local li=jf(860)local lj=jf(880)local lk=jf(900)local ll=jf(960)local lm=jf(200)local ln=jf(250)local lo=jf(960)if iG()==1 and not m then li=jf(135)lj=jf(155)lk=jf(175)lm=jf(115)ln=jf(95)end;if b0 then local lp=""if type(b0)=="string"then lp="-"..b0 end;k0[#k0+1]=gM(lh,li,"Brake Engaged"..lp,"warnings")elseif bR>0 then k0[#k0+1]=gM(lh,li,"Auto-Brake Engaged","warnings","opacity:"..bR)end;if cf and cz and ce==-1 then if not b3 and not bq and not b6 and not cP and not b9 and not b7 then k0[#k0+1]=gM(lh,lm+50,"** STALL WARNING **","warnings")fT("stall","SW",2)end end;if cW then k0[#k0+1]=gM(lh,lm+90,"Flight Assist in Progress","warnings")end;if cj then k0[#k0+1]=gM(lh,lo,"Gyro Enabled","warnings")end;if lq then lf=lf-1;if lf>20 then k0[#k0+1]=gM(lh,lo-20,"ECU Enabled","warnings")elseif lf<0 then lf=40 end end;if bm then if bV then k0[#k0+1]=gM(lh,lj,"Gear Extended","warn")else k0[#k0+1]=gM(lh,lj,"Landed (G: Takeoff)","warnings")end end;if ce>-1 and(not cP or ch<100)then local lr=iL(d:getTargetGroundAltitude())k0[#k0+1]=gM(lh,lk,"Hover Height: "..lr,"warn")end;if c4 then k0[#k0+1]=gM(lh,ll+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cP and bv~=nil then local ls="warnings"if eY(ch-antigrav.getBaseAltitude())<501 then ls="warn"end;k0[#k0+1]=gM(lh,lm+40,dj("Target Altitude: %d Singularity Altitude: %d",bM(bv),bM(antigrav.getBaseAltitude())),ls)end;if b3 and bj~="None"then k0[#k0+1]=gM(lh,lm,"Autopilot "..bg,"warn")elseif bt~=nil then k0[#k0+1]=gM(lh,lm+20,dj("LockedPitch: %d",bM(bt)),"warn")elseif b_ then k0[#k0+1]=gM(lh,lm+20,"Follow Mode Engaged","warn")elseif b8 or cd then k0[#k0+1]=gM(lh,lm+20,"Re-entry in Progress","warn")end;if b5 or b9 then local lr=iL(ba,2)if b9 then if cP then lr=iL(antigrav.getBaseAltitude(),2).." AGG singularity height"end;k0[#k0+1]=gM(lh,lm,"VTO to "..lr,"warn")elseif b7 and not bz then if cc then k0[#k0+1]=gM(lh,lm,"Takeoff to "..bj,"warn")else k0[#k0+1]=gM(lh,lm,"Takeoff to "..lr,"warn")end;if b0 and not b9 then k0[#k0+1]=gM(lh,lm+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else k0[#k0+1]=gM(lh,lm,"Altitude Hold: "..dj("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if cg>0.1 then k0[#k0+1]=gM(lh,lm+20,"Beginning ascent","warn")elseif cg<0.09 and cg>0.05 then k0[#k0+1]=gM(lh,lm+20,"Aligning trajectory","warn")elseif cg<0.05 then k0[#k0+1]=gM(lh,lm+20,"Leaving atmosphere","warn")end end;if bz then if cB~=nil then k0[#k0+1]=gM(lh,lm,cB,"warn")end end;if b6 then if lt then local lu="Brake Landing"if db then lu=lu.."-Aligning"end;if da then lu=lu.."-Drift Limited"end;k0[#k0+1]=gM(lh,lm,lu,"warnings")else k0[#k0+1]=gM(lh,lm,"Coast-Landing","warnings")end end;if b2 then k0[#k0+1]=gM(lh,lm+20,"Prograde Alignment","crit")end;if b1 then k0[#k0+1]=gM(lh,lm,"Retrograde Alignment","crit")end;if cY then local type;if string.find(cY,"COLLISION")then type="warnings"else type="crit"end;k0[#k0+1]=gM(lh,ln+20,cY,type)elseif cg==0 then local lv,lw=cs.checkLOS(cJ:normalize())if lw~=nil then local lr=iL(lw)local lx=co.computeTravelTime(cK,0,lw)local ly="Collision"if lv.noAtmosphericDensityAltitude>0 then ly="Atmosphere"end;k0[#k0+1]=gM(lh,ln+20,lv.name.." "..ly.." "..iM(lx).." In "..lr,"crit")end end;if bq and not bz then k0[#k0+1]=gM(lh,lm+60,lz,"warn")end;if d1 and#d1>1 then end;local lA=je;local lB=jf;local lC="topButton"local lD="topButtonActive"local lE=lC;if b3 or bq or cc or bz then lE=lD end;local lF=lC;if b2 then lF=lD end;local lG=lC;if b6 or bm then lG=lD end;local lH=lC;if b5 or bq then lH=lD end;local lI=lC;if b1 then lI=lD end;local lJ=lC;if bz or cD and b3 then lJ=lD end;if w and I then local lK=lB(30)k0[#k0+1]=dj([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lE,lA(960),lB(54),lB(-53),lA(-120),lA(25),lB(50))k0[#k0+1]=gM(lA(910),lK,"AUTOPILOT")k0[#k0+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lF,lA(865),lB(51),lA(-25),lB(-50),lA(-110),lA(25),lB(46))k0[#k0+1]=gM(lA(800),lK,"PROGRADE")k0[#k0+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,lA(755),lB(47),lA(-25),lB(-46),lA(-98),lA(44),lB(44))k0[#k0+1]=gM(lA(700),lK,"LAND")k0[#k0+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lH,lA(960),lB(54),lB(-53),lA(120),lA(-25),lB(50))k0[#k0+1]=gM(lA(1010),lK,"ALT HOLD")k0[#k0+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lI,lA(1055),lB(51),lA(25),lB(-50),lA(110),lA(-25),lB(46))k0[#k0+1]=gM(lA(1122),lK,"RETROGRADE")k0[#k0+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lJ,lA(1165),lB(47),lA(25),lB(-46),lA(98),lA(-44),lB(44))k0[#k0+1]=gM(lA(1220),lK,"ORBIT")k0[#k0+1]=[[
                                    </g>
                                </g>]]k0[#k0+1]="</g>"end;return k0 end;local function lL(fo)return bM(fU(fo*3.6,0)+0.5).." km/h"end;local function lM(gv)local gx=bj;if gv~=nil and type(gv)=="number"then if gv==0 then return"None"end;gx=cT[gv].name end;if gx==nil then gx=g4.name end;if gx==nil then gx="None"end;return gx end;local function lN(k0)local lO=cs.routeWP(true)if not lO or#lO==0 then return end;local hG=je(750)local hH=jf(360)if b3 or bq then k0[#k0+1]=gM(hG,hH,"REMAINING ROUTE","pdim txtstart size20")else k0[#k0+1]=gM(hG,hH,"LOADED ROUTE","pdim txtstart size20")end;for dK,M in pairs(lO)do hH=hH+20;k0[#k0+1]=gM(hG,hH,dK..". "..lO[dK],"pdim txtstart size20")end end;local function lP(k0)local hG=aB+10;local hH=aC+20;local lQ={}local lR={"Alt-4: AutoTakeoff to Target"}local lS={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lT={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lU={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lQ,"--------------DYNAMIC-----------------")if cf then if ce~=-1 then iJ(lQ,lR)if c7 and kD and c7.name==kD.name then table.insert(lQ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cP then table.insert(lQ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lQ,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(lQ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lQ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lQ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(lQ,"G: Takeoff to hover height, raise gear")else table.insert(lQ,"G: Lowergear and Land")end else iJ(lQ,lS)table.insert(lQ,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(lQ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iJ(lQ,lT)if shield then table.insert(lQ,"Alt-Shift-6: Vent shields")if not G then table.insert(lQ,"Alt-Shift-7: Toggle shield off/on")end end end;if g4~=nil then table.insert(lQ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lQ,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lQ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(lQ,"Alt-Spacebar/C will raise/lower target height")table.insert(lQ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cf then table.insert(lQ,"LALT+Mousewheel will lower/raise speed limit")end;iJ(lQ,lU)for M=1,#lQ do hH=hH+12;k0[#k0+1]=gM(hG,hH,lQ[M],"pdim txtbig txtstart")end end;local function lV(k0)local lW=aB;local lX=aC;local lY=aA;local lZ=4;local l_=15;local hG=0;local hH=0;local m0,m1,m2,m3;local m4;local function m5(type)local gH,bP,fo,m6,jV,m7;if type=="Periapsis"then gH=m4.periapsis.altitude;bP=m4.timeToPeriapsis;fo=m4.periapsis.speed;jV="txtend"m6=12;m7=math.min(hG,lW+lY-kD.radius/m2-lZ*2)else gH=m4.apoapsis.altitude;bP=m4.timeToApoapsis;fo=m4.apoapsis.speed;m6=-12;jV="txtstart"m7=hG end;if cK<1 then bP=0 end;k0[#k0+1]=dj([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7+m6,hH-5,hG,hH-5)k0[#k0+1]=dj([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m7-m6*4,hH+2,hG,hH+2)k0[#k0+1]=gM(m7,hH,type,jV)hG=m7-m6*2;hH=hH+l_;local lr=iL(gH)k0[#k0+1]=gM(hG,hH,lr,jV)hH=hH+l_;k0[#k0+1]=gM(hG,hH,iM(bP),jV)hH=hH+l_;k0[#k0+1]=gM(hG,hH,lL(fo),jV)end;local m8=lY*1.5;if bJ=="INFO"then m8=25*10 end;if bJ=="ORBIT"and ch<kD.spaceEngineMinAltitude then return k0 end;if bJ~="HIDE"then k0[#k0+1]=[[<g class="pbright txtorb txtmid">]]k0[#k0+1]=dj('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lY*2,m8,lW,lX)k0[#k0+1]=dj([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lY*2,m8,lW,lX)end;local m9=lY*1.5;local ma=lY*2;local mb=m9/2;local mc=lY;local md=lW+mc;local me=lX+mb;local mf=lW+ma;local mg=lX+m9;if bJ=="ORBIT"then lX=lX+lZ;m0=lY/2;m3=0;m4={}m4.periapsis={}m4.apoapsis={}if fs~=nil then if fs.periapsis~=nil then m4.periapsis.altitude=fs.periapsis.altitude;m4.periapsis.speed=fs.periapsis.speed end;if fs.apoapsis~=nil then m4.apoapsis.altitude=fs.apoapsis.altitude;m4.apoapsis.speed=fs.apoapsis.speed end;m4.period=fs.period;m4.eccentricity=fs.eccentricity;m4.timeToApoapsis=fs.timeToApoapsis;m4.timeToPeriapsis=fs.timeToPeriapsis;m4.eccentricAnomaly=fs.eccentricAnomaly;m4.trueAnomaly=fs.trueAnomaly end;if m4.periapsis==nil then m4.periapsis={}m4.periapsis.altitude=-kD.radius;m4.periapsis.speed=a1 end;if m4.eccentricity==nil then m4.eccentricity=1 end;if m4.apoapsis==nil then m4.apoapsis={}m4.apoapsis.altitude=ch;m4.apoapsis.speed=0 end;if cK<1 then m4.apoapsis.altitude=ch;m4.apoapsis.speed=0 end;if m4.apoapsis.altitude then m2=(m4.apoapsis.altitude+m4.periapsis.altitude+kD.radius*2)/(m0*2)m1=(kD.radius+m4.apoapsis.altitude)/m2*(1-m4.eccentricity)m3=m0-m4.periapsis.altitude/m2-kD.radius/m2;local mh=math.pi;if m4.period~=nil and m4.period>0 and m4.timeToApoapsis~=nil then mh=m4.eccentricAnomaly;if m4.timeToPeriapsis<m4.timeToApoapsis then mh=2*math.pi-mh end end;if cK<1 or mh~=mh then mh=math.pi end;local mi=-m0*math.cos(mh)+lW+mc+lZ;local mj=m1*math.sin(mh)+lX+mb+lZ;local mk=""k0[#k0+1]='<g clip-path="url(#orbitRect)">'k0[#k0+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mk,lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)if m1<1 then k0[#k0+1]=dj([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lW+lY+lZ-m3,lX+lY*1.5/2+lZ,mi,mj)end;k0[#k0+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kD.radius+kD.noAtmosphericDensityAltitude)/m2)k0[#k0+1]=dj('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,(kD.radius+kD.noAtmosphericDensityAltitude)/m2)k0[#k0+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lW+lY+lZ,lX+lY*1.5/2+lZ,m0,m1)k0[#k0+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lW+lY+lZ-m3,lX+lY*1.5/2+lZ,kD.radius/m2)k0[#k0+1]='</g>'local ml=math.floor(kD.radius/m2+0.5)hG=lW+lY+lZ*4+m0;hH=lX+lY*1.5/2+5+lZ;if m4.apoapsis~=nil and m4.apoapsis.speed<a1 then m5("Apoapsis")end;hH=lX+lY*1.5/2+5+lZ;hG=lW+lY-lZ*2-m0;if m4.periapsis~=nil and m4.periapsis.speed<a1 and m4.periapsis.altitude>0 then m5("Periapsis")end;k0[#k0+1]=gM(lW+lY+lZ,lX+20+lZ,kD.name,"txtorbbig")k0[#k0+1]=dj('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mi,mj)k0[#k0+1]=[[</g>]]return k0 else k0[#k0+1]='<g clip-path="url(#orbitRect)">'local mm=""local mn=1.2*(mo-mp)/(lY*2)local mq=1.4*(mr-ms)/(lY*1.5)for dK,dw in pairs(e[0])do if dw.center then local hG=lW+lY+dw.center.x/mn;local hH=lX+lY*1.5/2+dw.center.y/mq;mm=mm..'<circle cx="'..hG..'" cy="'..hH..'" r="'..dw.radius/mn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dw.name,"Moon")and not string.match(dw.name,"Sanctuary")and not string.match(dw.name,"Space")then mm=mm.."<text x='"..hG.."' y='"..hH+dw.radius/mn*30+20 .."' font-size='12' fill="..j6 .." text-anchor='middle' font-family='Montserrat'>"..dw.name.."</text>"end end end;local fu=vec3(bO.getWorldPosition())local hG=lW+lY+fu.x/mn;local hH=lX+lY*1.5/2+fu.y/mq;mm=mm..'<circle cx="'..hG..'" cy="'..hH..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mm=mm.."<text x='"..hG.."' y='"..hH-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iU=mn;iV=mq;local mt=fu+cJ*1000000;local mu=lW+lY+mt.x/mn;local jK=lX+lY*1.5/2+mt.y/mq;mm=mm..'<line x1="'..hG..'" y1="'..hH..'" x2="'..mu..'" y2="'..jK..'" stroke="purple" stroke-width="1"/>'k0[#k0+1]=mm;k0[#k0+1]='</g>'end elseif bJ=="INFO"then k0=cq.DrawOdometer(k0,j8,bn,j9)elseif bJ=="HELP"then k0=lP(k0)elseif bJ=="SCOPE"then k0[#k0+1]='<g clip-path="url(#orbitRect)">'local mv=d4;if cg>0 then table.sort(d3,function(ez,eA)local eB,eC=ez.center,eA.center;return(eB.x-cN.x)^2+(eB.y-cN.y)^2+(eB.z-cN.z)^2<(eC.x-cN.x)^2+(eC.y-cN.y)^2+(eC.z-cN.z)^2 end)end;local mw={}local mx={}local my=120;local mz=nil;local mA=nil;for M,dw in ipairs(d3)do local gU=dw.center-cN;local mB=gU:len()local mC=gU:normalize()local mD=gU:cross(cG):normalize()local mE=math.acos(mD:dot(cH))if mE~=mE then mE=0 end;if mD:cross(cH):dot(cG)<0 then mE=-mE end;local mF=gU:project_on_plane(cG):len()local mG=math.sin(mE)*math.asin(mF/mB)*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/mB)*constants.rad2deg;if mC:dot(cG)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hG=md+mG/mv*m9;local hH=me+mH/mv*m9;local mI=(hG-md)*(hG-md)+(hH-me)*(hH-me)local mJ=math.asin((dw.radius+dw.surfaceMaxAltitude)/mB)*constants.rad2deg;if mJ~=mJ then mJ=mv end;local i0=mJ/mv*m9;local mK=math.asin(dw.atmosphereRadius/mB)*constants.rad2deg;if mK~=mK then mK=mJ end;local mL=mK/mv*m9;local ca=iL(mB,1)local mM=dw.name;local mN=false;if hH>lX then if hH>mg then if hH-mL<=mg then mN=true end else mN=true end else if hH+mL>=lX then mN=true end end;local mO=false;local mP=hG;if dw.systemId==0 then mP=hG+my else mP=hG-my end;if mP+my>lW then if mP+my>mf then if mP-mL-my<=mf then mO=true end else mO=true end else if mP+mL+my>=lW then mO=true end end;local mQ={}mQ.x=hG;mQ.y=hH;mQ.planet=dw;mQ.atmoSize=mL;if not mz or mI<mz then mz=mI;mA=mQ end;if mO and mN then local mR=math.max(mL,5)if mI<mR*mR then mM=mM.." - "..ca end;mQ.size=i0;mQ.i=M;mQ.displayString=mM;mQ.distance=ca;mQ.visible=true;mx[#mx+1]=mQ else mQ.visible=false end end;local mS=false;table.sort(mx,function(eB,eC)return eB.y<eC.y end)for dK,fx in ipairs(mx)do local dw,i0,M,mL,hG,hH,mM,ca=fx.planet,fx.size,fx.i,fx.atmoSize,fx.x,fx.y,fx.displayString,fx.distance;local m7,mT,mU,mV;local mW=15;local jV="pdim"if dw.systemId~=0 then mU=je(string.len(mM)*5)mW=-(15+mU)mV=jf(10)jV="pdimfill"else mU=je(string.len(mM)*9)mV=jf(15)end;if i0*2>mU then m7=dk(hG,lW+mU/2,mf-mU/2)mT=dk(hH,lX+mV,mg-5)m7=dk(m7,hG-i0+mU/2,hG+i0-mU/2)mT=dk(mT,hH-i0+mV,hH+i0)else m7=hG+mW;mT=hH end;for mX,fx in pairs(mw)do local mY=fx.textPositions;local mZ=mY.y-mT;if mX~=M and eY(mZ)<mY.height and mY.x+mY.width>m7 and mY.x<m7+mU then if i0>mU then mT=dk(mT+mV,lX+15,mg-5)else mT=mY.y+mY.height+1 end end end;local m_=mM~=dw.name or m7<=md and m7+mU>=md and mT-mV<=me and mT>=me;fx.hovered=m_;local n0=1;if m_ then n0=2;if i0*2<mU then n0=10 end;if mM==dw.name then mM=mM.." - "..ca end;jV="pbright"if dw.systemId~=0 then mU=je(string.len(mM)*5)mW=-(15+mU)else mU=je(string.len(mM)*7)end;if i0*2>mU then m7=dk(hG,lW+mU/2,mf-mU/2)m7=dk(m7,hG-i0+mU/2,hG+i0-mU/2)else m7=hG+mW end end;mw[M]={}mw[M].textPositions={}mw[M].textPositions.y=mT;mw[M].textPositions.x=m7;mw[M].textPositions.width=mU;mw[M].textPositions.height=mV;mw[M].output=""if i0*2>mU then jV=jV.." txtmid"else jV=jV.." txtstart"end;if mL-i0>2 then mw[M].output=dj('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hG,hH,mL,j7,0.1*n0)end;mw[M].output=mw[M].output..dj('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hG,hH,i0,j7,0.2*n0)if dw.systemId==0 then mw[M].output=mw[M].output..dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mT,j6,jV,mM)if i0*2<=mU then mw[M].output=mw[M].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7+mU,mT+2,m7,mT+2,hG,hH)end else mw[M].output=mw[M].output..dj([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m7,mT,j7,jV,mM)if i0*2<=mU then mw[M].output=mw[M].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m7,mT+2,m7+mU,mT+2,hG,hH)end end end;for dK=#d3,1,-1 do if mw[dK]then k0[#k0+1]=mw[dK].output end end;if mA~=nil and d4<90 and not mA.hovered then local n1=mA.planet.atmosphereRadius/mA.atmoSize;local n2=dm(mz)*n1;local n3=iL(n2,1)local mU=je(math.max(string.len(n3)*7,string.len(mA.planet.name)*7))local mV=jf(12)local m7=dk(mA.x+(md-mA.x)/2,lW+mU/2,mf-mU/2)local mT=dk(mA.y+(me-mA.y)/2,lX+mV*2,mg-5)k0[#k0+1]=dj("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mA.x,mA.y,md,me)k0[#k0+1]=dj([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mT,"white",n3)if not mA.visible then k0[#k0+1]=dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m7,mT-mV,"white",mA.planet.name)end end;if cK>1 then local gU=cJ;local mC=gU:normalize()local mF=gU:project_on_plane(cG):len()local mD=gU:cross(cG):normalize()local mE=math.acos(mD:dot(cH))if mE~=mE then mE=0 end;if mD:cross(cH):dot(cG)<0 then mE=-mE end;local mG=math.sin(mE)*math.asin(mF/gU:len())*constants.rad2deg;local mH=math.cos(mE)*math.asin(mF/gU:len())*constants.rad2deg;if mC:dot(cG)<0 then mH=90*math.cos(mE)+90*math.cos(mE)-mH;mG=90*math.sin(mE)+90*math.sin(mE)-mG end;local hG=md+mG/mv*m9;local hH=me+mH/mv*m9;local kX=14;local kY=kX/2;local l0=[[<circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kY/kX..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hG-kX..[[,]]..hH..[[ h ]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hG+kY..[[,]]..hH..[[ h ]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hG..[[,]]..hH-kX..[[ v ]]..kY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]k0[#k0+1]=l0 end;k0[#k0+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md,me-10,md,me+10)k0[#k0+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",md-10,me,md+10,me)k0[#k0+1]='</g>'else return k0 end end;local function n4(n5,n6)local n7;local n8=(n6-n5):normalize()local fv=(cN-n5):dot(n8)/n8:dot(n8)if fv<=0. then return(cN-n5):len()elseif fv>=(n6-n5):len()then return(cN-n6):len()end;local n9=n5+fv*n8;n7=(n9-cN):len()return n7 end;local function na()local n7;local nb=nil;local nc=nil;local nd=nil;for dK,ne in pairs(e[0])do if ne.hasAtmosphere then local ca=n4(kD.center,ne.center)if nb==nil or ca<nb then nc=ne;nb=ca;nd=kD end;if c7 and c7.hasAtmosphere and c7.name~=kD.name then local eO=n4(c7.center,ne.center)if eO<nb then nc=ne;nb=eO;nd=c7 end end end end;local nf=je(1770)local ng=jf(330)if nb then local nh="txttick "local ni=500000;if nb<nc.radius+ni or nb<nd.radius+ni then if cU then nh="txttick red "else nh="txttick orange "end end;n7=iL(nb,2)iZ=gM(nf,ng,"Pipe ("..nd.name.."--"..nc.name.."): "..n7,nh.."pbright txtmid")end end;local function nj(hG,hH,nk,nl,l9)local nm={x=hG,y=hH,width=nk,height=nl,label=l9}iT[l9]=nm;return nm end;local function nn(no,np,nk,nl,hG,hH,nq,nr,ns,nt,jV)local nm={enableName=no,disableName=np,width=nk,height=nl,x=hG,y=hH,toggleVar=nq,toggleFunction=nr,drawCondition=ns,hovered=false,class=jV}if nt then table.insert(iS,nm)else table.insert(iR,nm)end;return nm end;local function nu(nv)if not iX then nw=false;nx=false;ny=false;w=true;return elseif nv=="handling"then nw=not nw;nx=false;ny=false elseif nv=="hud"then nx=not nx;nw=false;ny=false elseif nv=="physics"then ny=not ny;nw=false;nx=false end;if ny or nx or nw then iY=iK(nv)w=false else iY="none"w=true end end;local function nz()iX=not iX;if iX then iQ=iS;c2="Tap LMB to see Settings"d5=w else iQ=iR;c2="Tap LMB to see Control Buttons"nu()w=d5 end end;local function nA()local function nB(dw,dK)dw.set(not dw.get())if dw.get()then c2=dK.." set to true"else c2=dK.." set to false"end;if dK=="showHud"then d5=dw.get()elseif dK=="BrakeToggleDefault"then aZ=k end end;local nC=50;local nD=340;local hG=500;local hH=ad/2-400;local nE=0;for dK,dw in pairs(iK("boolean"))do if type(dw.get())=="boolean"then nn(dK,dK,nD,nC,hG,hH,function()return dw.get()end,function()nB(dw,dK)end,function()return true end,true)hH=hH+nC+20;if nE==9 then hG=hG+nD+20;hH=ad/2-400;nE=0 else nE=nE+1 end end end;nn("Control View","Control View",nD,nC,10,ad/2-500,function()return true end,nz,function()return true end,true)nn("View Handling Settings",'Hide Handling Settings',nD,nC,10,ad/2-(500-nC),function()return nw end,function()nu("handling")end,function()return true end,true)nn("View Hud Settings",'Hide Hud Settings',nD,nC,10,ad/2-(500-nC*2),function()return nx end,function()nu("hud")end,function()return true end,true)nn("View Physics Settings",'Hide Physics Settings',nD,nC,10,ad/2-(500-nC*3),function()return ny end,function()nu("physics")end,function()return true end,true)end;local function nF()local function gw()local fW=cN;local gx=kD.name..". "..#bp;if ct then gx=ct.GetClosestName(gx)end;return cr.AddNewLocation(gx,fW,false,true)end;local function nG()b4=not b4 end;local function nH(nI)if nI==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;b_=false;b6=false;bt=nil;b8=false;b7=false end;local function nJ(nK,nL)cr.UpdatePosition(nil,nK,nL)end;local function gr()cr.ClearCurrentPosition()end;local function nM(gv)local lO=cs.routeWP(true)if lO and#lO>0 then return"Engage Route: "..lO[1]end;return"Engage Autopilot: "..lM(gv)end;local function nN(gv)local lO=cs.routeWP(true)if lO and#lO>0 then return"Next Route Point: "..lO[1]end;return"Disable Autopilot: "..lM(gv)end;local function nO()if iG()==1 then b_=not b_;if b_ then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;nP=bm;bm=false;d.control.retractLandingGears()iH:setTargetGroundAltitude(Z)fT("folOn","F")else fT("folOff","F")b0="Follow Off"cy=q;bm=nP;if bm then d.control.deployLandingGears()iH:setTargetGroundAltitude(_)end end else c2="Follow Mode only works with Remote controller"b_=false end end;local nC=50;local nD=260;local nQ=je(30)local nR=aB+aA*2+2;local nS=aC+1;nn("+","+",nQ,nQ,nR,nS+nQ+1,function()return false end,function()d4=d4/8 end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nn("-","-",nQ,nQ,nR,nS,function()return false end,function()d4=math.min(d4*8,90)end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nn("0","0",nQ,nQ,nR,nS+nQ*2+2,function()return false end,function()d4=90 end,function()return bJ=="SCOPE"and d4~=90 end,nil,"ZoomButton")local nT=nn("Enable Brake Toggle","Disable Brake Toggle",nD,nC,ac/2-nD/2,ad/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c2="Brakes in Toggle Mode"else c2="Brakes in Default Mode"end end)nn("Align Prograde","Disable Prograde",nD,nC,ac/2-nD/2-50-nT.width,ad/2-nC+380,function()return b2 end,function()nH(1)end)nn("Align Retrograde","Disable Retrograde",nD,nC,ac/2-nD/2+nT.width+50,ad/2-nC+380,function()return b1 end,nH,function()return cg==0 end)nU=nn(nM,nN,600,60,ac/2-600/2,ad/2-60/2-330,function()return b3 or bq or cc or bz end,function()end)local M;local function nV(nW)local gv=d0+nW;if gv>#cT then gv=gv-#cT-1 end;if gv<0 then gv=#cT+gv end;return gv end;nX={}for M=0,10 do local nY=nn(function(eC)local gv=nV(eC.apExtraIndex)if b3 or bq or cc or bz then return"Redirect: "..lM(gv)end;return nM(gv)end,function(eC)local gv=nV(eC.apExtraIndex)return nN(gv)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eC)local gv=nV(eC.apExtraIndex)return gv==bl and(b3 or bq or cc or bz)end,function(eC)local gv=nV(eC.apExtraIndex)local nZ=bl==gv;bl=gv;cr.UpdateAutopilotTarget()cs.ToggleAutopilot()if not nZ and not(b3 or bq or cc or bz)then cs.ToggleAutopilot()end end,function()return c_ and(#cs.routeWP(true)==0 or M==0)end)nY.apExtraIndex=M;nX[M]=nY end;nn("Save Position","Save Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,gw,function()return bl==0 or g4==nil end)nn("Update Position","Update Position",200,nU.height,nU.x+nU.width+30,nU.y,function()return false end,function()nJ(nil)end,function()return bl>0 and g4~=nil end)nn("Save Heading","Clear Heading",200,nU.height,nU.x+nU.width+30,nU.y+nU.height+20,function()return g4.heading~=nil end,function()if g4.heading~=nil then nJ(false)else nJ(true)end end,function()return bl>0 and g4~=nil end)nn("Save AGG Alt","Clear AGG Alt",200,nU.height,nU.x+nU.width+30,nU.y+nU.height*2+40,function()return g4.agg~=nil end,function()if g4.agg~=nil then nJ(nil,false)else nJ(nil,true)end end,function()return bl>0 and g4~=nil and antigrav end)nn("Clear Position","Clear Position",200,nU.height,nU.x-200-30,nU.y,function()return true end,gr,function()return bl>0 and g4~=nil end)nn("Save Route","Save Route",200,nU.height,nU.x-200-30,nU.y+nU.height*2+40,function()return false end,function()cs.routeWP(false,false,2)end,function()return#cs.routeWP(true)>0 end)nn("Load Route","Clear Route",200,nU.height,nU.x-200-30,nU.y+nU.height+20,function()return#cs.routeWP(true)>0 end,function()if#cs.routeWP(true)>0 then cs.routeWP(false,true)elseif b3 or bq then c2="Disable Autopilot before loading route"return else cs.routeWP(false,false,1)end end,function()return true end)nC=60;nD=300;local hG=0;local hH=ad/2-150;nn("Enable Check Damage","Disable Check Damage",nD,nC,hG,hH-nC-20,function()return s end,function()s=not s end)nn("View Settings","View Settings",nD,nC,hG,hH,function()return true end,nz)hH=hH+nC+20;nn("Enable Turn and Burn","Disable Turn and Burn",nD,nC,hG,hH,function()return b4 end,nG)hG=10;hH=ad/2-300;nn("Horizontal Takeoff Mode","Vertical Takeoff Mode",nD,nC,ac/2-nD/2,hH+20,function()return a_ end,function()a_=not a_;if a_ then c2="Vertical Takeoff Mode"else c2="Horizontal Takeoff Mode"end end,function()return cO end)hH=hH+nC+20;nn("Engage Orbiting","Cancel Orbiting",nD,nC,hG+nD+20,hH,function()return bz end,cs.ToggleIntoOrbit,function()return cg==0 and cX end)hH=ad/2-150;nn("Glide Re-Entry","Cancel Glide Re-Entry",nD,nC,hG+nD+20,hH,function()return b8 end,function()cb=1;nH(1)end,function()return kD.hasAtmosphere and not cf end)hH=hH+nC+20;nn("Parachute Re-Entry","Cancel Parachute Re-Entry",nD,nC,hG+nD+20,hH,function()return b8 end,function()cb=2;nH(1)end,function()return kD.hasAtmosphere and not cf end)hH=hH+nC+20;nn("Engage Follow Mode","Disable Follow Mode",nD,nC,hG,hH,function()return b_ end,nO,function()return iG()==1 end)nn("Enable Repair Arrows","Disable Repair Arrows",nD,nC,hG+nD+20,hH,function()return jc end,function()jc=not jc;if jc then c2="Repair Arrows Enabled"else c2="Repair Arrows Diabled"end end,function()return iG()==1 end)hH=hH+nC+20;if not r then nn("Enable AGG","Disable AGG",nD,nC,hG,hH,function()return cP end,cs.ToggleAntigrav,function()return antigrav~=nil end)end;nn(function()return dj("Switch IPH Mode - Current: %s",bA)end,function()return dj("IPH Mode: %s",bA)end,nD*2,nC,hG,hH,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons-Asteroids"else bA="All"end;c2="IPH Mode: "..bA end)hH=hH+nC+20;nn(function()return dj("Toggle Control Scheme - Current: %s",g)end,function()return dj("Control Scheme: %s",g)end,nD*2,nC,hG,hH,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c2="New Control Scheme: "..g end)local n_=jf(20)local nY=nj(0,0,je(70),n_,"HELP")nY=nj(nY.x+nY.width,nY.y,je(80),n_,"INFO")nY=nj(nY.x+nY.width,nY.y,je(70),n_,"ORBIT")nY=nj(nY.x+nY.width,nY.y,je(70),n_,"SCOPE")nj(nY.x+nY.width,nY.y,je(70),n_,"HIDE")end;local o0={}local o1=nil;function o0.HUDPrologue(k0)if not cU then j3=ai;j4=aj;j5=ak else j3=af;j4=ag;j5=ah end;j6=[[rgb(]]..bM(j3+0.6)..","..bM(j4+0.6)..","..bM(j5+0.6)..[[)]]j7=[[rgb(]]..bM(j3*0.8+0.5)..","..bM(j4*0.8+0.5)..","..bM(j5*0.8+0.5)..[[)]]local o2=j6;local o3=j7;local o4=[[rgb(]]..bM(j3*0.4+0.5)..","..bM(j4*0.4+0.5)..","..bM(j5*0.4+0.5)..[[)]]local o5=j6;local o6=j7;local o7=o4;if jg()and not n then o2=[[rgb(]]..bM(j3*0.5+0.5)..","..bM(j4*0.5+0.5)..","..bM(j5*0.5+0.5)..[[)]]o3=[[rgb(]]..bM(j3*0.3+0.5)..","..bM(j4*0.3+0.5)..","..bM(j5*0.2+0.5)..[[)]]o4=[[rgb(]]..bM(j3*0.2+0.5)..","..bM(j4*0.2+0.5)..","..bM(j5*0.2+0.5)..[[)]]end;local lA=je;local lB=jf;k0[#k0+1]=dj([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o2,o2,o2,o5,o5,o3,o3,o6,o6,o3,o2,o4,o6,o2,o2,o4,o4,o7,o4,ac,ad,o3,o3,o3,o3,o3,o5,o3,o6,o7,o6,o6,o7)if not o1 then o1=dj([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lA(630),lB(0),lA(675),lB(45),lA(960),lB(55),lA(1245),lB(45),lA(1290),lB(0),lA(1000),lB(105),lA(1040),lB(59),lA(1250),lB(51),lA(1300),lB(0),lA(1920),lB(0),lA(1920),lB(20),lA(1400),lB(20),lA(1300),lB(105),lA(920),lB(105),lA(880),lB(59),lA(670),lB(51),lA(620),lB(0),lA(0),lB(0),lA(0),lB(20),lA(520),lB(20),lA(620),lB(105),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112),lA(890),lB(59),lA(960),lB(62),lA(1030),lB(59),lA(985),lB(112),lA(1150),lB(112),lA(1100),lB(152),lA(820),lB(152),lA(780),lB(112),lA(935),lB(112))end;if w and I then k0[#k0+1]=o1 end;return k0 end;function o0.DrawVerticalSpeed(k0,e2)j_(k0,e2)end;function o0.UpdateHud(k0)local kQ=cR;local o8=cS;local k7=o8;local kn=kQ;local l7=bM(c.getThrottle())local lc=cK*3.6;local l8=c.getAxisCommandValue(0)local o9=je(1770)local oa=jf(310)if t and cQ then l8=bQ;l7=bQ*100 end;local ji=jh()local k8="ROLL"if l7==nil then l7=0 end;if not cX then if cK>5 then kQ=kP(cI)o8=kR(cI)else kQ=0;o8=0 end;k8="YAW"end;if cV>50000 and not cf then local ob;ob=iL(cV)k0[#k0+1]=gM(o9,oa,"PvP Boundary: "..ob,"pbright txtbig txtmid")end;k0[#k0+1]=ja;k0[#k0+1]=ie;if iZ~=""then k0[#k0+1]=iZ end;if jj~=""then k0[#k0+1]=jj end;if jk~=""then k0[#k0+1]=jk end;j_(k0,ch)if iG()==0 or m then if not jg()or n then if cX then k6(k0,al,am,k7,k8,cX)km(k0,kn,k7,al,am,cX,bM(kR(cI)),cK)else k6(k0,al,am,o8,k8,cX)km(k0,kQ,o8,al,am,cX,bM(o8),cK)end;kt(k0,ch,cX)kS(k0,cI,cK,al,am)end end;l6(k0,ji,l7,l8)lb(k0,lc)lg(k0)lV(k0)if not iX and c0 then lN(k0)end;return k0 end;function o0.HUDEpilogue(k0)k0[#k0+1]="</svg>"return k0 end;function o0.ExtraData(k0)local oc=je(1240)local od=jf(55)local oe=od+10;local of;local lA=je;local lB=jf;local og=0;local ji=jh()if a_ then ji=ji.."-VERTICAL"end;if E and gX and not b7 and not b6 and cK>20 then ji=ji.."-COLLISION ON"end;if bC~="Off"then ji="("..bC..")-"..ji end;if b4 then ji="TB-"..ji end;if bH then ji="HOVERMODE-"..ji end;if not bB then ji=ji.."-DeCoupled"end;local oh=lB(99)local oi=lB(80)local oj=lB(85)local ok=lB(31)local ol=0;local om=0;local on=ci>1000000 and fU(ci/1000000,2).."kT"or fU(ci/1000,2).."T"if cf then og=bu else og=bs end;local oo,op=co.computeDistanceAndTime(cK,0,ci,0,0,og)if oo<0 then oo=0 end;og=fU(og/(ci*iP),2).."g"local oq=d:maxForceForward()of=b.getGravityIntensity()if of>0.1 then om=ci*of;om=fU(om/(ci*iP),2).."g"ol=0.5*oq/of;ol=ol>1000000 and fU(ol/1000000,2).."kT"or fU(ol/1000,2).."T"end;oq=fU(oq/(ci*iP),2).."g"local os=vec3(bO.getWorldAcceleration()):len()/9.80665;of=b.getGravityIntensity()k0[#k0+1]=[[<g class="dim txt txtend size14">]]if iG()==1 and not m then oc=je(1120)od=jf(55)oe=od+10 elseif cf and I then local ot=je(770)k0[#k0+1]=gM(lA(895),oh,"ATMO","")k0[#k0+1]=dj([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lA(895),oj,lA(-80))k0[#k0+1]=gM(lA(815),oi,dj("%.1f%%",cg*100),"txtstart size20")end;if I then k0[#k0+1]=gM(lA(1025),oh,"GRAVITY","txtstart")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1025),oj,lA(80))k0[#k0+1]=gM(lA(1105),oi,dj("%.2fg",of/9.80665),"size20")k0[#k0+1]=gM(lA(1125),oh,"ACCEL","txtstart")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1125),oj,lA(80))k0[#k0+1]=gM(lA(1205),oi,dj("%.2fg",os),"size20")k0[#k0+1]=gM(lA(695),oh,"BRK TIME","")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(695),oj,lA(-80))k0[#k0+1]=gM(lA(615),oi,dj("%s",iM(op)),"txtstart size20")k0[#k0+1]=gM(lA(635),lB(45),"TRIP","")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(635),lB(31),lA(-90))if lx then k0[#k0+1]=gM(lA(545),lB(26),dj("%s",iM(lx)),"txtstart size20")end;k0[#k0+1]=gM(lA(795),oh,"BRK DIST","")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(795),oj,lA(-80))k0[#k0+1]=gM(lA(715),oi,dj("%s",iL(oo)),"txtstart size20")k0[#k0+1]=gM(lA(1285),lB(45),"MASS","txtstart")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1285),lB(31),lA(90))k0[#k0+1]=gM(lA(1375),lB(26),dj("%s",on),"size20")k0[#k0+1]=gM(lA(1220),oh,"THRUST","txtstart")k0[#k0+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lA(1220),oj,lA(80))k0[#k0+1]=gM(lA(1300),oi,dj("%s",oq),"size20")k0[#k0+1]=gM(je(960),jf(175),ji,"pbright txtbig txtmid size20")end;k0[#k0+1]="</g>"end;local ou=1-(a7*0.05+a8*0.05)function o0.FuelUsed(ov)local ow;if ov=="atmofueltank"then ow=dj("Atmo Fuel Used: %.1f L",jB[ov]/(4*ou))elseif ov=="spacefueltank"then ow=dj("Space Fuel Used: %.1f L",jB[ov]/(6*ou))else ow=dj("Rocket Fuel Used: %.1f L",jB[ov]/(0.8*ou))end;return ow end;local ox,oy,oz,oA,oB=0,0,0,{},0;function o0.DrawOdometer(k0,j8,bn,j9)if bJ~="INFO"then return k0 end;local of;local ol=0;local om=0;local og=0;local on=ci>1000000 and fU(ci/1000000,2).." kTons"or fU(ci/1000,2).." Tons"if cf then og=bu else og=bs end;local oo,op=co.computeDistanceAndTime(cK,0,ci,0,0,og)og=fU(og/(ci*iP),2).." g"local oq=d:maxForceForward()of=b.getGravityIntensity()if of>0.1 then om=ci*of;om=fU(om/(ci*iP),2).." g"ol=0.5*oq/of;ol=ol>1000000 and fU(ol/1000000,2).." kTons"or fU(ol/1000,2).." Tons"end;oq=fU(oq/(ci*iP),2).." g"if iG()==0 or m then local oC=je(aB+10)local oD=jf(aC+20)local oE=je(aB+10+aA/1.25)local nl=25;local oF=bM(1/aT)if oz<oF then oB=oB+a.getActionUpdateDeltaTime()oz=oz+1 else ox=1/(oB/oF)table.insert(oA,ox)oz,oB=0,0 end;oy=0;for dK,dw in pairs(oA)do oy=oy+dw end;if#oA>0 then oy=bM(oy/#oA)end;if#oA>29 then table.remove(oA,1)end;k0[#k0+1]="<g class='txtstart size14 bright'>"k0[#k0+1]=gM(oC,oD,dj("BrkTime: %s",iM(op)))k0[#k0+1]=gM(oE,oD,dj("Trip: %.2f km",j8))k0[#k0+1]=gM(oC,oD+nl,dj("Lifetime: %.2f kSU",bn/200000))k0[#k0+1]=gM(oE,oD+nl,dj("BrkDist: %s",iL(oo)))k0[#k0+1]=gM(oC,oD+nl*2,"Trip Time: "..iM(j9))k0[#k0+1]=gM(oE,oD+nl*2,"Total Time: "..iM(bo))k0[#k0+1]=gM(oC,oD+nl*3,dj("Mass: %s",on))k0[#k0+1]=gM(oE,oD+nl*3,dj("Max Brake: %s",og))k0[#k0+1]=gM(oC,oD+nl*4,dj("Max Thrust: %s",oq))if of>0.1 then k0[#k0+1]=gM(oE,oD+nl*4,dj("Max Thrust Mass: %s",ol))k0[#k0+1]=gM(oC,oD+nl*5,dj("Req Thrust: %s",om))else k0[#k0+1]=gM(oE,oD+nl*4,"Max Mass: n/a")k0[#k0+1]=gM(oC,oD+nl*5,"Req Thrust: n/a")end;k0[#k0+1]=gM(oE,oD+nl*5,cq.FuelUsed("atmofueltank"))k0[#k0+1]=gM(oC,oD+nl*6,cq.FuelUsed("spacefueltank"))k0[#k0+1]=gM(oE,oD+nl*6,cq.FuelUsed("rocketfueltank"))k0[#k0+1]=gM(oC,oD+nl*7,dj("Set Max Speed: %s",bM(a1*3.6+0.5)))k0[#k0+1]=gM(oE,oD+nl*7,dj("Actual Max Speed: %s",bM(de*3.6+0.5)))k0[#k0+1]=gM(oC,oD+nl*8,dj("Friction Burn Speed: %s",bM(bO.getFrictionBurnSpeed()*3.6)))k0[#k0+1]=gM(oE,oD+nl*8,dj("FPS (Avg): %s (%s)",bM(ox),oy))end;k0[#k0+1]="</g></g>"return k0 end;function o0.DrawWarnings(k0)return lg(k0)end;function o0.DisplayOrbitScreen(k0)return lV(k0)end;function o0.DisplayMessage(k0,lr)if lr~="empty"then local hH=310;for lu in string.gmatch(lr,"([^\n]+)")do hH=hH+35;k0[#k0+1]=gM("50%",hH,lu,"msg")end end;if c3~=0 then c.setTimer("msgTick",c3)c3=0 end end;function o0.DrawDeadZone(k0)k0[#k0+1]=dj([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function o0.UpdatePipe()if cf then iZ=""return end;na()end;function o0.DrawSettings(k0)local hG=je(640)local hH=jf(200)k0[#k0+1]=[[<g class="pbright txtvspd txtstart">]]local hX=0;for dK,dw in pairs(iY)do hX=hX+1;k0[#k0+1]=gM(hG,hH,dK..": "..dw.get())hH=hH+20;if hX%12==0 then hG=hG+je(350)hH=jf(200)end end;k0[#k0+1]=gM(je(640),jf(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")k0[#k0+1]="</g>"return k0 end;local id=jf(125)local ic=je(1225)function o0.DrawRadarInfo()ie=ct.GetRadarHud(ic,id,ax,ay)if ie then gX=true end end;function o0.DrawTanks()if at~=0 and au~=0 then jj=gM(at,au,"","txtstart pdim txtfuel")jC=au;jD(at,"Atmospheric ","ATMO",ck,jz,jA)jD(at,"Space Fuel T","SPACE",cl,jx,jy)jD(at,"Rocket Fuel ","ROCKET",cm,jv,jw)end end;function o0.DrawShield()local iq=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oG=bO.getPvPTimer()local oH=shield.getResistances()local oI="A: "..10+oH[1]*100 .."% / E: "..10+oH[2]*100 .."% / K:"..10+oH[3]*100 .."% / T: "..10+oH[4]*100 .."%"local hG,hH=av-60,aw+30;local jT=bM(df*2.55)local jU=dj("rgb(%d,%d,%d)",255-jT,jT,0)local jV=""jk=gM(hG,hH,"","txtmid pdim txtfuel")if df<10 and iq~="Shield Disabled"then jV="red "end;oG=oG>0 and"   PvPTime: "..iM(oG)or""jk=jk..dj([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hG,hH,jU,df*2,hG,hH,hG+2,hH+10,df,oG)jk=jk..gM(hG,hH-5,iq,jV.."txtstart pbright txtbig")jk=jk..gM(hG,hH+30,oI,jV.."txtstart pbright txtsmall")end;function o0.hudtick()if not kD then return end;local function oJ(k0)local jX=bM(dk(dc/(ac/4)*255,0,255))k0[#k0+1]=dj("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bM(j3+0.5)+jX,bM(j4+0.5)-jX,bM(j5+0.5)-jX)end;local function oK()if c1 then for dP,dw in pairs(iQ)do if dw.hovered then if not dw.drawCondition or dw.drawCondition(dw)then dw.toggleFunction(dw)end;dw.hovered=false end end;for dP,dw in pairs(iT)do if dw.hovered then bJ=dw.label;dw.hovered=false end end;c1=false end end;local function oL()local function oM(oN,oO,hG,hH,nk,nl)if oN>=hG and oN<=hG+nk and oO>=hH and oO<=hH+nl then return true else return false end end;local hG=c8+ac/2;local hH=c9+ad/2;for dP,dw in pairs(iQ)do dw.hovered=oM(hG,hH,dw.x,dw.y,dw.width,dw.height)end;for dP,dw in pairs(iT)do dw.hovered=oM(hG,hH,dw.x,dw.y,dw.width,dw.height)end;if c_ then local m_=false;for dP,eC in ipairs(nX)do if eC.hovered then m_=true;break end end;if nU.hovered then m_=true end;c_=m_ else c_=nU.hovered;if not c_ then d0=bl end end end;local function oP(k0)if not bJ or bJ==""then bJ="HELP"end;if w then for dK,dw in pairs(iT)do local jV="dim brightstroke"local oQ=0.2;if bJ==dK then jV="pbright dimstroke"oQ=0.6 end;local oR=""if dw.hovered then oQ=0.8;oR=";stroke:white"end;k0[#k0+1]=dj([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dw.width,dw.height,dw.x,dw.y,jV,oQ,oR)k0[#k0+1]=gM(dw.x+dw.width/2,dw.y+dw.height/2+5,dw.label,"txt txtmid pdim")end end end;local function oS(k0)local function oT(k0,oU,hover,hG,hH,fh,oV,oW,oX,oY,oZ,nY)if type(oY)=="function"then oY=oY(nY)end;if type(oZ)=="function"then oZ=oZ(nY)end;k0[#k0+1]=dj("<rect x='%f' y='%f' width='%f' height='%f' fill='",hG,hH,fh,oV)if oU then k0[#k0+1]=dj("%s'",oW)else k0[#k0+1]=oX end;if hover then k0[#k0+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else k0[#k0+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fU(af*0.5,0),fU(ag*0.5,0),fU(ah*0.5,0))end;k0[#k0+1]=" rx='5'></rect>"k0[#k0+1]=dj("<text x='%f' y='%f' font-size='24' fill='",hG+fh/2,hH+oV/2+5)if oU then k0[#k0+1]="black"else k0[#k0+1]="white"end;k0[#k0+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oU then k0[#k0+1]=dj("%s</text>",oY)else k0[#k0+1]=dj("%s</text>",oZ)end end;local o_=dj("rgb(%d,%d,%d)'",fU(af*0.1,0),fU(ag*0.1,0),fU(ah*0.1,0))local p0=dj("rgb(%d,%d,%d)",fU(af*0.8,0),fU(ag*0.8,0),fU(ah*0.8,0))local p1=oT;for dP,dw in pairs(iQ)do local np=dw.disableName;local no=dw.enableName;if type(np)=="function"then np=np(dw)end;if type(no)=="function"then no=no(dw)end;if not dw.drawCondition or dw.drawCondition(dw)then p1(k0,dw.toggleVar(dw),dw.hovered,dw.x,dw.y,dw.width,dw.height,p0,o_,np,no,dw)end end end;local p2=fU(ac/2,0)local p3=fU(ad/2,0)local k0={}if p4 then k0[#k0+1]=p4 end;cq.HUDPrologue(k0)if w then cq.UpdateHud(k0)else if A then cq.DrawVerticalSpeed(k0,ch)end;cq.DrawWarnings(k0)end;if iX and iY~="none"then cq.DrawSettings(k0)end;if ct then cq.DrawRadarInfo()else ie=""end;cq.HUDEpilogue(k0)k0[#k0+1]=dj([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c2~="empty"then cq.DisplayMessage(k0,c2)end;if iG()==0 and g=="virtual joystick"then if v then cq.DrawDeadZone(k0)end end;oP(k0)if iI()==0 then if iG()==1 and c0 then if not p5 then oL()oS(k0)end;if not cw and not cx then local p6=table.concat(k0,"")k0={}k0[#k0+1]=dj("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)k0[#k0+1]=p6;k0[#k0+1]="</body>"cw=true;k0[#k0+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cx then local p6=table.concat(k0,"")k0={}k0[#k0+1]=dj("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)k0[#k0+1]=p6;k0[#k0+1]="</body>"end;if not cw then k0[#k0+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c8,c9)end else oK()end else if not c0 and iG()==0 then oK()if dc>az then if v then oJ(k0)end end elseif c0 and(not p5 or not j)then oL()oS(k0)end;k0[#k0+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p2,p3,c8,c9)end;k0[#k0+1]=[[</svg></body>]]p7=table.concat(k0,"")end;function o0.TenthTick()local function p8()local p9=a.createData;local pa=a.createWidget;pb=a.createWidgetPanel("Interplanetary Helper")pc=pa(pb,"value")pd=p9('{"label": "Target Planet", "value": "N/A", "unit":""}')fS(pd,pc)pe=pa(pb,"value")pf=p9('{"label": "distance", "value": "N/A", "unit":""}')fS(pf,pe)gl=pa(pb,"value")gk=p9('{"label": "Travel Time", "value": "N/A", "unit":""}')fS(gk,gl)gj=pa(pb,"value")gi=p9('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fS(gi,gj)gn=pa(pb,"value")gm=p9('{"label": "Target Altitude", "value": "N/A", "unit":""}')fS(gm,gn)gf=pa(pb,"value")ge=p9('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gd=pa(pb,"value")gc=p9('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gb=pa(pb,"value")ga=p9('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g9=pa(pb,"value")g8=p9('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gh=pa(pb,"value")gg=p9('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cf then fS(ge,gf)fS(gc,gd)fS(ga,gb)fS(g8,g9)fS(gg,gh)end end;local function pg()gL(pb)pb=nil end;cq.DrawTanks()if shield then cq.DrawShield()end;if bj~="None"then if pb==nil then p8()end;if bj~=nil then local mB;local ph=g4~=nil;local pi=0.5*bu/c7:getGravity(c7.center+vec3(0,0,1)*c7.radius):len()pi=pi>1000000 and fU(pi/1000000,2).." kTons"or fU(pi/1000,2).." Tons"fR(pd,'{"label": "Target", "value": "'..bj..'", "unit":""}')if ph and not b3 then mB=(cN-g4.position):len()else mB=(bk-cN):len()end;if not b4 then c5,c6=cs.GetAutopilotBrakeDistanceAndTime(cK)j0,j1=cs.GetAutopilotBrakeDistanceAndTime(a1)else c5,c6=cs.GetAutopilotTBBrakeDistanceAndTime(cK)j0,j1=cs.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lr=iL(mB)fR(pf,'{"label": "distance", "value": "'..lr..'"}')fR(gk,'{"label": "Travel Time", "value": "'..iM(lx)..'", "unit":""}')lr=iL(c5)fR(ge,'{"label": "Cur Brake distance", "value": "'..lr..'"}')fR(gc,'{"label": "Cur Brake Time", "value": "'..iM(c6)..'", "unit":""}')lr=iL(j0)fR(ga,'{"label": "Max Brake distance", "value": "'..lr..'"}')fR(g8,'{"label": "Max Brake Time", "value": "'..iM(j1)..'", "unit":""}')fR(gi,'{"label": "Max Brake Mass", "value": "'..dj("%s",pi)..'", "unit":""}')lr=iL(go)fR(gm,'{"label": "Target Orbit", "value": "'..lr..'"}')if cf and not pj then a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)pj=true;if not cQ and t and(b5 or b8 or cd)then cs.cmdThrottle(1)b0=false;bU=false end end;if not cf and pj then if fR(g8,g9)==1 then fS(g8,g9)end;if fR(ga,gb)==1 then fS(ga,gb)end;if fR(gc,gd)==1 then fS(gc,gd)end;if fR(ge,gf)==1 then fS(ge,gf)end;if fR(gg,gh)==1 then fS(gg,gh)end;pj=false end end else pg()end;if warpdrive~=nil then local pk=iE(warpdrive.getWidgetData())if pk.destination~="Unknown"and pk.distance>400000 then if not jd then warpdrive.showWidget()jd=true end elseif jd then warpdrive.hideWidget()jd=false end end end;function o0.OneSecondTick()local function pl()local jN=bL()local lc=cK;local pm=jN-jb;if lc>1.38889 then lc=lc/1000;local pn=lc*(jN-jb)bn=bn+pn;j8=j8+pn end;j9=j9+pm;bo=bo+pm;jb=jN end;local function po(k0)local pp=0;local pq=iO;local pr=0;local ps=0;local pt=0;local jT=0;local jU=""local pu=b.getElementHitPointsById;local pv=b.getElementMaxHitPointsById;local pw={}for dK in pairs(iN)do local px=0;local py=0;py=pv(iN[dK])px=pu(iN[dK])pr=pr+px;if px+1<py then if px==0 then pt=pt+1 else ps=ps+1 end;if jc and#pw==0 then fW=vec3(b.getElementPositionById(iN[dK]))local hG=fW.x;local hH=fW.y;local hI=fW.z;table.insert(pw,b.spawnArrowSticker(hG,hH,hI+1,"down"))table.insert(pw,b.spawnArrowSticker(hG,hH,hI+1,"down"))b.rotateSticker(pw[2],0,0,90)table.insert(pw,b.spawnArrowSticker(hG+1,hH,hI,"north"))table.insert(pw,b.spawnArrowSticker(hG+1,hH,hI,"north"))b.rotateSticker(pw[4],90,90,0)table.insert(pw,b.spawnArrowSticker(hG-1,hH,hI,"south"))table.insert(pw,b.spawnArrowSticker(hG-1,hH,hI,"south"))b.rotateSticker(pw[6],90,-90,0)table.insert(pw,b.spawnArrowSticker(hG,hH-1,hI,"east"))table.insert(pw,b.spawnArrowSticker(hG,hH-1,hI,"east"))b.rotateSticker(pw[8],90,0,90)table.insert(pw,b.spawnArrowSticker(hG,hH+1,hI,"west"))table.insert(pw,b.spawnArrowSticker(hG,hH+1,hI,"west"))b.rotateSticker(pw[10],-90,0,90)table.insert(pw,iN[dK])end elseif jc and#pw>0 and pw[11]==iN[dK]then for jM in pairs(pw)do b.deleteSticker(pw[jM])end;pw={}end end;pp=fU(pr/pq*100,2)if pt>0 or ps>0 then k0[#k0+1]=gM(0,0,"","pbright txt")jT=bM(pp*2.55)jU=dj("rgb(%d,%d,%d)",255-jT,jT,0)k0[#k0+1]=gM("50%",1035,"Elemental Integrity: "..pp.."%","txtbig txtmid","fill:"..jU)if pt>0 then k0[#k0+1]=gM("50%",1055,"Disabled Modules: "..pt.." Damaged Modules: "..ps,"txtbig txtmid","fill:"..jU)elseif ps>0 then k0[#k0+1]=gM("50%",1055,"Damaged Modules: "..ps,"txtbig txtmid","fill:"..jU)end end end;local function pz()if iD then if j2==nil and(hk~=nil or bm)then _autoconf.displayCategoryPanel(iD,weapon_size,"Weapons","weapon",true)j2=_autoconf.panels[_autoconf.panels_size]elseif j2~=nil and hk==nil and not bm then gL(j2)j2=nil end end end;d1=bO.getPlayersOnBoard()d2=bO.getDockedConstructs()local k0={}pl()if s then po(k0)end;pz()cq.UpdatePipe()cq.ExtraData(k0)ja=table.concat(k0,"")end;function o0.AnimateTick()cx=true;cw=false;c8=0;c9=0;c.stopTimer("animateTick")end;function o0.MsgTick()local k0={}cq.DisplayMessage(k0,"empty")c2="empty"c.stopTimer("msgTick")c3=3 end;function o0.ButtonSetup()nA()nF()iQ=iR end;if pA then for dK,dw in pairs(pA)do o0[dK]=dw end end;return o0 end;local function pB(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,eY,bM,bN,iG,eT,bL,dk,iH,fR,iI,dm,fU,fT,iJ,dn,iL,iM,pD,iE)local a=DUSystem;local bO=DUConstruct;local pE={}local pF=false;local pG=0;local pH=0;local pI=0;local pJ=bL()local pK=0;local pL=0;local pM=0;local pN=0;local pO=false;local pP=false;local pQ=false;local pR=nil;local pS=0;local i_=55;local pT=nil;local pU=false;local pV=false;local pW=false;local pX=0;local pY=0;local pZ=0;local p_=0;local q0=0;local q1={VectorToTarget=false}local q2=vec3(bO.getWorldOrientationUp())local q3=nil;local q4=0;local q5=-1;local q6=-1;local q7=false;local q8=false;local q9=0;local qa=false;local qb=false;local qc=false;local qd=false;local qe=""local qf=false;local qg=false;local qh=""local qi=false;local qj=0;local function qk()return bO.isInPvPZone()~=1,eY(bO.getDistanceToSafeZone())end;local function ql(fo)local qm=bf;if not b3 then qm=0 end;local qn=bs;if cf then if bu and bu>0 then qn=bu else return 0,0 end end;return co.computeDistanceAndTime(fo,qm,ci,0,0,qn-bh*ci)end;local function qo(fo)local qm=bf;if not b3 then qm=0 end;return co.computeDistanceAndTime(fo,qm,ci,d:maxForceForward(),a3,bs-bh*ci)end;local function qp(qq,qr,qs)qr=qr:project_on_plane(qq)qs=qs:project_on_plane(qq)return eT(qr:cross(qs):dot(qq),qr:dot(qs))end;local qt;local qu;if hover then qu=hover.getMaxDistance()*2 end;if vBooster then qt=vBooster.getMaxDistance()*2 end;local function qv()local function qw()local qx=-1;local qy=-1;if vBooster then qx=vBooster.getDistance()if qx>qt then qx=-1 end end;if hover then qy=hover.getDistance()if qy>qu then qy=-1 end end;if qx~=-1 and qy~=-1 then if qx<qy then return qx else return qy end elseif qx~=-1 then return qx elseif qy~=-1 then return qy else return-1 end end;local qz=qw()local qA=-1;if antigrav and antigrav.isActive()==1 and not r and cK<i_ then local qB=eY(ch-antigrav.getBaseAltitude())if qB<50 then return qB end end;if pC then qA=pC.raycast().distance;if qA==0 then qA=-1 end end;if qz~=-1 and qA~=-1 then if qz<qA then return qz else return qA end elseif qz~=-1 then return qz else return qA end end;local function qC(kD,eK,qD)local function qE(qF,dW)local eQ=vec3(dW)if qF.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=qF.systemId},dY)end;local eR=eQ-qF.center;local ca=eR:len()local e2=ca-qF.radius;local e0=0;local e1=0;if not dn(ca,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/ca)end;return setmetatable({latitude=math.deg(e0),longitude=math.deg(e1),altitude=e2,id=qF.id,systemId=qF.systemId},dY)end;local qG=qE(kD,eK)qG="::pos{"..qG.systemId..","..qG.id..","..qG.latitude..","..qG.longitude..","..qG.altitude.."}"if qD then return qG else qc=qG;return true end end;local function qH(qI,qJ,qK)local function qL(qI,et)qI=vec3(qI)et=vec3(et):normalize()local dF=qI*et;return dF.x+dF.y+dF.z end;local qM=0.001;local qN=1;if not cf or not cz or ce~=-1 or cK<i_ then if qK==nil then qK=aS end;if qJ==nil then qJ=qM end;qI=vec3(qI):normalize()local qO=vec3()-qI;local qP=-qL(qO,bO.getWorldOrientationRight())*qN;local qQ=-qL(qO,bO.getWorldOrientationUp())*qN;if pH==0 then pH=qP/2 end;if pI==0 then pI=qQ/2 end;if eY(qP)<0.1 then pY=pY-qP*2 else pY=pY-(qP+(qP-pH)*qK)end;if eY(qQ)<0.1 then pX=pX+qQ*2 else pX=pX+qQ+(qQ-pI)*qK end;pH=qP;pI=qQ;if eY(qP)<qJ and eY(qQ)<qJ then return true end;return false elseif cz and ce==-1 then qI=cJ;if qK==nil then qK=aS end;if qJ==nil then qJ=qM end;qI=vec3(qI):normalize()local qO=cG-qI;local qP=-qL(qO,bO.getWorldOrientationRight())*qN;local qQ=-qL(qO,bO.getWorldOrientationUp())*qN;if pH==0 then pH=qP/2 end;if pI==0 then pI=qQ/2 end;if eY(qP)<0.1 then pY=pY-qP*5 else pY=pY-(qP+(qP-pH)*qK)end;if eY(qQ)<0.1 then pX=pX+qQ*5 else pX=pX+qQ+(qQ-pI)*qK end;pH=qP;pI=qQ;if eY(qP)<qJ and eY(qQ)<qJ then return true end;return false end end;function pE.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cW=nil;b5=false;b8=false;b6=false;b7=false;b9=false;b_=false;pV=false;cb=false;cc=false;pW=false;cy=q;bq=false;b4=false;cj=false;bt=nil;bz=false;da=false;db=nil end;function pE.GetAutopilotBrakeDistanceAndTime(fo)return ql(fo)end;function pE.GetAutopilotTBBrakeDistanceAndTime(fo)return qo(fo)end;function pE.showWayPoint(kD,eK,qD)return qC(kD,eK,qD)end;function pE.APTick()local qR=a.getMouseWheel()if qR>0 then cs.changeSpd()elseif qR<0 then cs.changeSpd(true)else pU=true end;q9=iI()if qc then a.setWaypoint(qc)qc=false end;if qf then antigrav.setTargetAltitude(qf)qf=false end;if qd then fR(qd,qe)qd=false;qe=""end;if q6~=-1 then cs.cmdCruise(q6,q7)q7=false;q6=-1 end;if q3~=nil then if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iH:getTargetSpeed(axisCommandId.longitudinal)~=q3 then iH:setTargetSpeedCommand(axisCommandId.longitudinal,q3)else q3=nil end end;if q5~=-1 then cs.cmdThrottle(q5,q7)q7=false;q5=-1 end;if q8 then cu.landingGear(q8)q8=false end;if qg then cs.ToggleAutopilot()end end;function pE.ToggleIntoOrbit()cD=false;pM=nil;pN=nil;pS=0;if not cf then if bz then fT("orOff","AP")bz=false;pO=false;pR=nil;cy=q;if b5 then b5=false;b7=false end;q1.VectorToTarget=false;q1.AutopilotAlign=false;pQ=false elseif cX then fT("orOn","AP")bz=true;cy=true;if pR==nil then pR=kD end;if b5 then b5=false;b7=false end else c2="Unable to engage auto-orbit, not near a planet"end else bz=false;pO=false;pR=nil;cy=q;if b5 then b5=false end;q1.VectorToTarget=false;q1.AutopilotAlign=false;pQ=false end end;function pE.ToggleVerticalTakeoff()b5=false;if b9 then lt=true;b8=false;b7=false;b6=true;cy=true;bZ=0;if cf and ce==-1 then b6=false;b5=true;bZ=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q6=bM(cA)end else cD=false;bm=false;d.control.retractLandingGears()iH:setTargetGroundAltitude(Z)b0="VTO Takeoff"end;b9=not b9 end;function pE.checkLOS(qI)local lv,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,qI,function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lw=eI;if eJ~=nil and eI~=nil then lw=math.min(eJ,eI)end;if lw~=nil then return lv,lw else return nil,nil end end;local function qS(qT,qU)if qU then bZ=0;iH:updateCommandFromActionStop(axisCommandId.vertical,qU)if bB then iH:activateGroundEngineAltitudeStabilization(qV)dd=true end else bZ=bZ+qT;iH:deactivateGroundEngineAltitudeStabilization()iH:updateCommandFromActionStart(axisCommandId.vertical,qT)end end;function pE.vertical(qT,qU)qS(qT,qU)end;function pE.ToggleAutopilot()local function qW(bx)cY=false;bq=not bq;if bq then b4=false;if not b5 and not bx then cs.ToggleAltitudeHold()end end;lz="Proceeding to Waypoint"end;local function qX(gx)if gx then for M,dK in pairs(cT)do if dK.name and dK.name==gx then return M end end else return 0 end end;local qY=false;bH=false;if bP-pL<1.5 and cf then if not cF then if cf then ba=kD.spaceEngineMinAltitude-0.01*kD.noAtmosphericDensityAltitude;fT("11","EP")pL=-1;if b3 or bq or bz then return end else c2="No space engines detected, Orbital Hop not supported"return end elseif kD.hasAtmosphere then if cf then ba=kD.noAtmosphericDensityAltitude+V;fT("orH","OH")end;pL=-1;if b3 or bq or bz then return end end else pL=bP end;qZ=false;if(bl>0 or#bF>0)and not b3 and not bq and not cc and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ci then c2="WARNING: Heavy Loads may affect autopilot performance."c3=5 end;if#bF>0 and not cd then bl=qX(bF[1])cr.UpdateAutopilotTarget()c2="Route Autopilot in Progress"local qO=g4.position-cN;local q_=qO:project_on_plane(cL):len()if q_>50000 and g4.planetname==kD.name then qY=true end end;cr.UpdateAutopilotTarget()cs.showWayPoint(c7,bk)if g4~=nil then if g4.agg and not r and antigrav then if not cP then cs.ToggleAntigrav()end;bv=g4.agg end;bt=nil;bx=g4.planetname=="Space"if bx then fT("apSpc","AP")if cf then cc=true;cs.ToggleAltitudeHold()else b3=true end elseif kD.name==g4.planetname then lt=true;if cf then if not bq then fT("vtt","AP")qW(bx)if qY then ba=kD.noAtmosphericDensityAltitude+V end end else fT("apOn","AP")if not(c7.name==kD.name and ch<go*1.5)then cD=false;b3=true elseif not cf then if bz then cs.ToggleIntoOrbit()end;cC=kD.noAtmosphericDensityAltitude+V;pQ=true;q1.AutopilotAlign=true;q1.VectorToTarget=true;pO=false;if not bz then cs.ToggleIntoOrbit()end end end else fT("apP","AP")b1=false;b2=false;if cf then cc=true;cs.ToggleAltitudeHold()else b3=true end end elseif not cf then if g4==nil and(c7.name==kD.name and cX)and not bz then r0=false;cD=false;pO=false;cs.ToggleIntoOrbit()else fT("apP","AP")b3=true;b1=false;b2=false;bc=false;b_=false;b5=false;b6=false;b8=false;b7=false;pV=false;bt=nil;r0=false end else fT("apP","AP")cc=true;cs.ToggleAltitudeHold()end;qg=false else fT("apOff","AP")cs.ResetAutopilots(1)if qg==2 then qg=true end end end;function pE.routeWP(r1,r2,r3)if r3 then if r3==1 then bF={}bF=iJ(bF,bE)if#bF>0 then c2="Route Loaded"else c2="No Saved Route found on Databank"end;return bF else bE={}bE=iJ(bE,bF)c2="Route Saved"pD()return end end;if r1 then return bF end;if r2 then bF={}c2="Current Route Cleared"else bF[#bF+1]=g4.name;c2="Added "..g4.name.." to route. "end;return bF end;function pE.cmdThrottle(dL,r4)if iH:getAxisCommandType(0)~=axisCommandType.byThrottle and not r4 then d.control.cancelCurrentControlMasterMode()end;iH:setThrottleCommand(axisCommandId.longitudinal,dL)bQ=dk(fU(dL*100,0)/100,-1,1)q3=nil end;function pE.cmdCruise(dL,r4)if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r4 then d.control.cancelCurrentControlMasterMode()end;iH:setTargetSpeedCommand(axisCommandId.longitudinal,dL)q3=dL end;function pE.ToggleLockPitch()if bt==nil then fT("lkPOn","LP")if not c0 then bt=cR else bt=S end;b7=false;b5=false;b6=false else fT("lkPOff","LP")bt=nil end end;function pE.ToggleAltitudeHold()if bP-pK<1.5 then bH=false;if kD.hasAtmosphere then if cf then ba=kD.spaceEngineMinAltitude-0.01*kD.noAtmosphericDensityAltitude;fT("11","EP")else if cX then ba=kD.noAtmosphericDensityAltitude+V;cC=ba;pQ=true;if not bz then cs.ToggleIntoOrbit()end;pO=true end end;pK=-1;if b5 or bz or b9 then return end end else pK=bP end;if cX and not cf and ce==-1 then cC=ch;pQ=true;pO=true;cs.ToggleIntoOrbit()if bz then pK=bP else pK=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;b_=false;cy=true;bt=nil;cD=false;if ce~=-1 then if not bm and not bq then ba=ch;bH=ce;iH:setTargetGroundAltitude(bH)elseif cK<20 then if bm then cu.landingGear()end;fT("lfs","LS")b7=true;if cf then ba=ch+Y else ba=kD.surfaceMaxAltitude+100 end;b0="ATO Hold"iH:setTargetGroundAltitude(Z)if a_ and cO then cs.ToggleVerticalTakeoff()end end else fT("altOn","AH")b7=false;if pK>-1 then if cX then ba=ch end end;if b9 then cs.ToggleVerticalTakeoff()end end;if cP and not r then local r5=antigrav.getBaseAltitude()if bq and g4.agg and g4.agg>ch then ba=g4.agg elseif b7 then ba=r5 end;if eY(ch-r5)<100 and cK<20 then ba=r5;b0="AGG Hold"q5=0 end end;if cc then ba=200000 end else fT("altOff","AH")if bz then cs.ToggleIntoOrbit()end;if b9 then cs.ToggleVerticalTakeoff()end;cy=q;b7=false;bq=false;pK=0;bH=false end end;function pE.ResetAutopilots(pE)if pE then cc=false;b3=false;bc=false;pV=false;ba=ch;qZ=false;da=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;db=nil;r6=false;cW=nil;da=false;if not cP then b5=false;bt=nil end;if b9 then cs.ToggleVerticalTakeoff()end;if bz then cs.ToggleIntoOrbit()end;cy=q;cb=false;cd=false;bZ=0 end;function pE.BrakeToggle(r7)if not b0 then if r7 then b0=r7 else b0=true end else b0=false end;if b6 then b6=false;cy=q;da=false end;if b0 then fT("bkOn","B",1)cs.ResetAutopilots()else fT("bkOff","B",1)end end;function pE.BeginReentry()if b8 then c2="Re-Entry cancelled"fT("reOff","RE")b8=false;cy=q;b5=false elseif not kD.hasAtmosphere then c2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c3=5 elseif not pW then b8=true;if iH:getAxisCommandType(0)~=r8.cruise then d.control.cancelCurrentControlMasterMode()end;cy=true;b0=false;c2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cA;fT("par","RE")else b8=true;b5=true;cy=true;b0=false;ba=kD.surfaceMaxAltitude+a0;if ba>kD.spaceEngineMinAltitude then ba=kD.spaceEngineMinAltitude-0.01*kD.noAtmosphericDensityAltitude end;local r9=iL(ba)c2="Beginning Re-entry.  Target speed: "..cA.." Target Altitude: "..r9;fT("glide","RE")q6=bM(cA)end;b7=false end;function pE.ToggleAntigrav()if antigrav and not r then if cP then fT("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=ch end;if bv<1000 then bv=1000 end;fT("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pE.changeSpd(ra)local rb=1;if ra then rb=-1 end;if not c0 then if t and not p5 and pU then local rc=bQ;bQ=fU(dk(bQ+rb*aE/100,-1,1),2)if bQ>=0 and rc<0 then bQ=0;pU=false end elseif p5 then if cf or b8 then cA=dk(cA+rb*aE,0,W)elseif b3 then a1=dk(a1+rb*aE/3.6*100,0,de-0.2)end else iH:updateCommandFromActionStart(axisCommandId.longitudinal,rb*aE/10)end else if b3 or bq or cc or bz then d0=d0+1*rb*-1;if d0>#cT then d0=1 end;if d0<1 then d0=#cT end else if not ra then rb=1 else rb=nil end;cr.adjustAutopilotTargetIndex(rb)end end end;function pE.TenthTick()local function rd()if not b3 then if g4==nil or g4.planetname~=kD.name then re=(c7.center-cN):len()else re=(g4.position-cN):len()end end;local fo=cK;local rf=c.getThrottle()/100;if t then rf=bQ end;local rg,rh=co.computeDistanceAndTime(cK,a1,ci,d:maxForceForward()*rf,a3,0)local c5,c6;if not b4 then c5,c6=cs.GetAutopilotBrakeDistanceAndTime(a1)else c5,c6=cs.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dP,ri;if not b4 and fo>0 then dP,ri=cs.GetAutopilotBrakeDistanceAndTime(fo)else dP,ri=cs.GetAutopilotTBBrakeDistanceAndTime(fo)end;local rj=0;local rk=0;if be or not b3 and fo>5 then rk=co.computeTravelTime(fo,0,re)elseif c5+rg<re then rj=re-(c5+rg)rk=co.computeTravelTime(8333.0556,0,rj)else local rl=(re-c5)/rg;rg=re-c5;rh=rh*rl end;if g4~=nil and g4.planetname==kD.name and not b3 then return rk elseif bd then return ri elseif be then return rk+ri else return rh+c6+rk end end;local function rm(of,rn)if of==nil then of=b.getGravityIntensity()end;of=fU(of,5)if rn~=nil and rn or(pT==nil or pT~=of)then local fo=cI:len()local ro=iE(c.getWidgetData()).maxBrake;if ro~=nil and ro>0 and cf then ro=ro/dk(fo/100,0.1,1)ro=ro/cg;if cg>0.10 then if bu then bu=(bu+ro)/2 else bu=ro end end end;if ro~=nil and ro>0 then bs=ro end;pT=of end end;cU,cV=qk()de=bO.getMaxSpeed()if bj~="None"and(c7 or g4)then lx=rd()end;rm(nil,true)end;local function rp(rq,rr)local rs=vec3()local rt=vec3()if rq==axisCommandId.longitudinal then rs=vec3(bO.getOrientationForward())rt=cG elseif rq==axisCommandId.vertical then rs=vec3(bO.getOrientationUp())rt=q2 elseif rq==axisCommandId.lateral then rs=vec3(bO.getOrientationRight())rt=cH else return vec3()end;local ru=vec3(b.getWorldGravity())local rv=ru:dot(rt)local rw=vec3(bO.getWorldAirFrictionAcceleration())local rx=rw:dot(rt)local ry=cI:dot(rs)local rz=rr*constants.kph2m;if rA==nil then rA=pid.new(10,0,10.0)end;rA:inject(rz-ry)local rB=rA:get()local rC=(rB-rx-rv)*rt;return rC end;local function rD(rq,rr)local rs=vec3()local rt=vec3()if rq==axisCommandId.longitudinal then rs=vec3(bO.getOrientationForward())rt=cG elseif rq==axisCommandId.vertical then rs=vec3(bO.getOrientationUp())rt=q2 elseif rq==axisCommandId.lateral then rs=vec3(bO.getOrientationRight())rt=cH else return vec3()end;local ru=vec3(b.getWorldGravity())local rv=ru:dot(rt)local rw=vec3(bO.getWorldAirFrictionAcceleration())local rx=rw:dot(rt)local ry=cI:dot(rs)local rz=rr*constants.kph2m;if rE==nil then rE=pid.new(10,0,10.0)end;rE:inject(rz-ry)local rB=rE:get()local rC=(rB-rx-rv)*rt;return rC end;local function rF(rG,k3,g0)local rH=rG:cross(g0):normalize_inplace()local kQ=math.acos(dk(rH:dot(-k3),-1,1))*constants.rad2deg;if rH:cross(-k3):dot(g0)<0 then kQ=-kQ end;return kQ end;local function rI()if cZ and not b6 then local er=cZ[1]local i3,i4=cZ[2],cZ[3]local rJ=math.min(i3,i4 or i3)local rK=rJ/cK;local rL=b7 and(cK<42 or ce~=-1)local rM=b5 or bq or bt or b3;if rM and not rL and(c5*1.5>rJ or rK<1)then b0="Collision"bF={}q5=0;if b5 then cs.ToggleAltitudeHold()end;if bt then cs.ToggleLockPitch()end;c2="Autopilot Cancelled due to possible collision"a.print(er.name.." COLLISION "..iM(rK).." / "..iL(rJ,2))cs.ResetAutopilots(1)lt=true;if cf then b6=true end;cy=true end;if rK<11 then cY=er.name.." COLLISION "..iM(rK).." / "..iL(rJ,2)else cY=er.name.." collision "..iM(rK)end;if rK<6 then fT("alarm","AL",2)end else cY=false end end;local rN=1;local rO=0;local rP=1;local rQ=1;local rR=1;local rS=false;function pE.onFlush()if antigrav and not r and not cP and antigrav.getBaseAltitude()~=bv then qf=bv end;if dd then d:setEngineForceCommand('hover',vec3(),1)dd=false end;cQ=iH:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rT=dk(bW+pX+a.getControlDeviceForwardInput(),-1,1)local rU=dk(bX+pZ+a.getControlDeviceYawInput(),-1,1)local rV=dk(bY+pY-a.getControlDeviceLeftRightInput(),-1,1)local rW=b0 and 1 or 0;cL=vec3(b.getWorldVertical())if cL==nil or cL:len()==0 then cL=(kD.center-cN):normalize()end;q2=vec3(bO.getWorldOrientationUp())cG=vec3(bO.getWorldOrientationForward())cH=vec3(bO.getWorldOrientationRight())cJ=vec3(bO.getWorldVelocity())cI=vec3(bO.getVelocity())cN=vec3(bO.getWorldPosition())ci=bO.getMass()cK=vec3(cJ):len()cM=-cL:dot(cJ)cS=getRoll(cL,cG,cH)local rX=cS/180*math.pi;local rY=math.cos(rX)local rZ=math.sin(rX)cR=rF(cL,cG,cH*rY+q2*rZ)local r_=cJ:normalize()local s0=eY(cS)local s1=utils.sign(cS)local s2=vec3(bO.getWorldAngularVelocity())local s3=rT*aO*cH+rU*aJ*cG+rV*aP*q2;if cy==true and cL:len()>0.01 then local s4=eY(p_-cS)if((b2 or b8 or b6 or cb or b5 or bz)and s4>0 or cf and s4<aK and q)and rU==0 and eY(cR)<85 then local s5=p_;local s6=aI;if not cf then s6=s6/4;p_=0;s5=0 end;if s7==nil then s7=pid.new(s6*0.01,0,s6*0.1)end;s7:inject(s5-cS)local s8=s7:get()s3=s3+s8*cG end end;bR=0;cg=bN()cf=false or ch<kD.noAtmosphericDensityAltitude and cg>0.00001;ch=b.getAltitude()ce=qv()bP=bL()pJ=bP;if bm and ce>-1 and ce-3<_ then if iH.targetGroundAltitudeActivated then iH:deactivateGroundEngineAltitudeStabilization()end end;if ct then qi=not qi;if qi then ct.UpdateRadar()end;if E then rI()end end;if antigrav then cP=antigrav.isActive()==1 end;local s9=bP-pJ;local sa=-math.deg(qp(q2,cJ,cG))local sb=math.deg(qp(cH,cJ,cG))local gq=cL*-1;cz=cf and sa<-N or sa>N or sb<-O or sb>O;local sc=a.getMouseDeltaX()local sd=a.getMouseDeltaY()if qj then local se=bL()-qj;sc=sc*se/0.016;sd=sd*se/0.016 end;qj=bL()if p and not c0 then sd=-sd end;pY=0;pZ=0;pX=0;local sf=bO.getWorldPosition()kD=fX:closestBody(sf)sg=cp(kD)fs=sg:orbitalParameters(sf,cJ)if ch==0 then ch=(cN-kD.center):len()-kD.radius end;cX=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;local of=kD:getGravity(sf):len()*ci;p_=0;local sh=bO.getMaxThrustAlongAxis("ground",bO.getOrientationUp())[1]if q9==0 then if iG()==1 and c0 then if not cw then c8=dk(c8+sc/2,-ac/2,ac/2)c9=dk(c9+sd/2,-ad/2,ad/2)end else c8=0;c9=0 end else c8=dk(c8+sc/2,-ac/2,ac/2)c9=dk(c9+sd/2,-ad/2,ad/2)dc=dm(c8*c8+c9*c9)if not c0 and iG()==0 then local kZ,k_=1,1;if bJ=="SCOPE"then kZ,k_=d4/90,d4/90 end;if g=="virtual joystick"then if dc>az then pY=pY-dk(eY(c8)-az,0,ac/2)*utils.sign(c8)*aG*kZ;pX=pX-dk(eY(c9)-az,0,ad/2)*utils.sign(c9)*aH*k_ end else c8=0;c9=0;if g=="mouse"then pX=(-utils.smoothstep(sd,-100,100)+0.5)*2*rQ;pY=(-utils.smoothstep(sc,-100,100)+0.5)*2*rR end end end end;local si=cK>27777;if cK>X/3.6 and not cf and not b3 and not si then c2="Space Speed Engine Shutoff reached"q5=0 end;if not si and sj then if not b0 then cs.BrakeToggle()end;if b3 then cs.ResetAutopilots(1)end;q5=0 end;sj=si;if cg>0.09 then if cK>cA/3.6 and not t and not pF then b0="SpdLmt"pF=true elseif not t and pF then if cK<cA/3.6 then b0=false;pF=false end end end;if b2 then if cb then b0=false;local sk=false;sk=qH(g4.position-cN,0.1)cy=true;if sk then q6=bM(cA)if(eY(cS)<2 or eY(cR)>85)and cK>=cA/3.6-1 then b0=false;b2=false;if cb~=2 then pW=true end;if cb==true then cd=true end;cb=false;b3=false;cs.BeginReentry()end elseif cf and t then q5=1 end elseif cK>i_ then qH(vec3(cJ),0.01)end end;if b1 then if cf then b1=false elseif cK>i_ then qH(-vec3(cJ))end end;if not b2 and cb and not bz then if not cf then if cb~=2 then pW=true end;cs.BeginReentry()cb=false;cd=true else cb=false;if not qg then qg=true end end end;if cd and g4 and(ch<ba+250 and ch>ba-250)and cK*3.6>cA-250 and eY(cM)<25 and cg>=0.1 and(g4.position-cN):len()>2000+ch then if not qg then qg=true end;cd=false end;if b9 then cy=true;local sl=ba;if cM<-30 then c2="Unable to achieve lift. Safety Landing."bZ=0;cy=q;b9=false;b6=true elseif not r and cP or ba<kD.spaceEngineMinAltitude then if cP then sl=antigrav.getBaseAltitude()end;if ch<sl-100 then q0=0;bZ=15;b0=false elseif cM>0 then b0="VTO Limit"bZ=0 elseif cM<-30 then b0="VTO Fall"bZ=15 elseif ch>=sl then if cP then if b3 or bq then cs.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c2="Takeoff complete. Singularity engaged"fT("aggLk","AG")else b0=false;c2="VTO complete. Engaging Horizontal Flight"fT("vtoc","VT")cs.ToggleVerticalTakeoff()end;bZ=0 end else if cg>0.08 then q0=0;b0=false;bZ=20 elseif cg<0.08 and cf then b0=false;if cE then q0=0;bZ=20 else bZ=0;q0=36;q6=3500 end else cy=q;bz=true;cD=false;sm=false;pO=false;pM=nil;pN=nil;if pR==nil then pR=kD end;cC=sl;pQ=true;b9=false end end;if q0~=nil then if sn==nil then sn=pid.new(2*0.01,0,2*0.1)end;local so=dk(q0-cR,-O*0.80,O*0.80)sn:inject(so)local sp=dk(sn:get(),-1,1)pX=sp end end;if bz then local function sq()if fs.periapsis.altitude>=cC*0.99 and fs.apoapsis.altitude>=cC*0.99 and fs.periapsis.altitude<fs.apoapsis.altitude and fs.periapsis.altitude*1.05>=fs.apoapsis.altitude and eY(cC-ch)<1000 then return true else return false end end;local qO;local sr=false;local ss=iL(cC,3)if pR==nil then pR=kD;if bq then pR=c7 end end;if not pQ then cC=bM(pR.radius+pR.surfaceMaxAltitude+V)if pR.hasAtmosphere then cC=bM(pR.radius+pR.noAtmosphericDensityAltitude+V)end;pQ=true end;if q1.VectorToTarget and g4 then qO=g4.position-cN end;local st,su=cp(pR):escapeAndOrbitalSpeed((cN-pR.center):len()-pR.radius)local sv=cS;if not pO then local sw=false;local sx=false;q5=0;pN=0;cB="Aligning to orbital path - OrbitHeight: "..ss;if q1.VectorToTarget then qH(qO:normalize():project_on_plane(cL))sr=cG:dot(qO:project_on_plane(q2):normalize())>0.95 else qH(cJ)sr=sa<0.5;if cK<150 then sr=true end end;pX=0;pM=0;if cR<=pM+2 and cR>=pM-2 then sw=true else sw=false end;if sv<=pN+2 and sv>=pN-2 then sx=true else sx=false end;if sw and sx and sr then pM=nil;pN=nil;pO=true end else if q1.VectorToTarget then qH(qO:normalize():project_on_plane(cL))elseif cK>150 then qH(cJ)end;pX=0;if q1.VectorToTarget and g4 then local c5,dP=co.computeDistanceAndTime(cK,cA/3.6,ci,0,0,bs)if cD and qO:len()>15000+c5+ch then cB="Orbiting to Target"if ch-100<=pR.noAtmosphericDensityAltitude or lx>fs.timeToPeriapsis and fs.periapsis.altitude<pR.noAtmosphericDensityAltitude or not sq()and fs.eccentricity>0.1 then c2="Re-Aligning Orbit"cD=false end elseif cD or qO:len()<15000+c5+ch then c2="Orbit complete, proceeding with reentry"fT("orCom","OB")bk=g4.position;pW=true;cd=true;q1.VectorToTarget,q1.AutopilotAlign=false,false;cs.ToggleIntoOrbit()cs.BeginReentry()return end end;if fs.periapsis~=nil and fs.apoapsis~=nil and fs.eccentricity<1 and ch>cC*0.9 and ch<cC*1.4 then if fs.apoapsis~=nil then if(sq()or cD)and not K then if cD then b0=false;q5=0;pM=0;if not q1.VectorToTarget then c2="Orbit complete"fT("orCom","OB")cs.ToggleIntoOrbit()end else pS=pS+1;if pS>=2 then cD=true end end else if sq()then cB="Maintaining "else cB="Adjusting "pP=true;q6=su*3.6+1;local sy=cC-ch;if sz==nil then sz=pid.new(0.1,0,1*0.1)end;sz:inject(sy-cM*dk(utils.smoothstep(2000-sy,-2000,2000)^6*10,1,10))pM=dk(sz:get(),-60,60)end;cB=cB.." - OrbitHeight: "..ss end end else local sA=2.75;local sB=eY(fU(st*sA))local ou=sB%50;if ou>0 then sB=sB-ou+50 end;b0=false;if ch<cC*0.8 then cB="Escaping planet gravity - OrbitHeight: "..ss;pM=utils.map(cM,200,0,-15,80)elseif ch>=cC*0.8 and ch<cC*1.15 then cB="Approaching orbital corridor - OrbitHeight: "..ss;sB=sB*0.75;pM=utils.map(cM,100,-100,-15,65)elseif ch>=cC*1.15 and ch<cC*1.5 then cB="Approaching orbital corridor - OrbitHeight: "..ss;sB=sB*0.75;if cM<0 or pP then pM=utils.map(ch,cC*1.5,cC*1.01,-30,0)else pM=utils.map(ch,cC*0.99,cC*1.5,0,30)end elseif ch>cC*1.5 then cB="Reentering orbital corridor - OrbitHeight: "..ss;pM=-65;local sC=utils.map(cM,-150,-400,1,0.55)sB=sB*sC end;q6=bM(sB)end end;if pM~=nil then if sD==nil then sD=pid.new(1*0.01,0,5*0.1)end;local sE=pM-cR;sD:inject(sE)local sF=dk(sD:get(),-0.5,0.5)pX=sF end end;if b3 and not cf and not cb then local function sG(dh,fs)a.print(dh)b2=false;b0=false;bd=false;b3=false;qZ=false;bg="Aligning"q5=0;pV=false;c2=dh;fT("apCom","AP")if fs or cb then if fs and go~=nil and not cb then if not ch or ch==0 then return end;cC=ch;pQ=true end;cs.ToggleIntoOrbit()end end;local sH,sI=bk,false;if g4 and g4.planetname~="Space"then bc=true;if not qZ then local sJ=(g4.position-c7.center):normalize()local sK=sJ:project_on_plane((c7.center-cN):normalize()):normalize()local sL=c7.center+sK*(c7.radius+go)local sM=g4.position+(g4.position-c7.center):normalize()*(go-c7:getAltitude(g4.position))if(cN-sL):len()<(cN-sM):len()then sH=sL else sH=sM;bf=0 end;bk=sH;cs.showWayPoint(c7,bk)sI=true;qZ=true end;bh=0 elseif g4 and g4.planetname=="Space"then if not qZ then bh=0;sI=true;bc=true;qZ=true;sH=g4.position+(cN-g4.position):normalize()*T;bk=sH end elseif g4==nil then bh=0;if not qZ then local sJ=(cN+cJ*100000-c7.center):normalize()local sK=sJ:project_on_plane((c7.center-cN):normalize()):normalize()if sK:len()<1 then sJ=(cN+cG*100000-c7.center):normalize()sK=sJ:project_on_plane((c7.center-cN):normalize()):normalize()end;sH=c7.center+sK*(c7.radius+go)bk=sH;qZ=true;sI=true;bc=true;cs.showWayPoint(c7,bk)end end;re=(vec3(sH)-cN):len()local lv,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,cJ:normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lw=eI;if eJ~=nil and eI~=nil then lw=math.min(eJ,eI)end;if lw~=nil and lw<re and lv.name==c7.name then re=lw end;local sk=true;local sN=(c7.center-(cN+vec3(cJ):normalize()*re)):len()-c7.radius;local lr=iL(sN)qd=gg;qe='{"label": "Projected Altitude", "value": "'..lr..'"}'if cK>50 and bb then local qO=vec3(sH)-cN;local sO=dk(math.deg(qp(q2,cJ:normalize(),qO:normalize()))*cK/500,-90,90)local sP=dk(math.deg(qp(cH,cJ:normalize(),qO:normalize()))*cK/500,-90,90)if eY(sO)<20 and eY(sP)<20 then sO=sO*2;sP=sP*2 end;if eY(sO)<2 and eY(sP)<2 then sO=sO*2;sP=sP*2 end;local sa=-math.deg(qp(q2,cG,cJ:normalize()))local sb=-math.deg(qp(cH,cG,cJ:normalize()))if sQ==nil then sQ=pid.new(2*0.01,0,2*0.1)end;sQ:inject(sP-sb)local sR=dk(sQ:get(),-1,1)pX=pX+sR;if sS==nil then sS=pid.new(2*0.01,0,2*0.1)end;sS:inject(sO-sa)local sT=dk(sS:get(),-1,1)pY=pY+sT;sI=true;if eY(sO)>2 or eY(sP)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fT("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end end elseif bb and cK<=50 then qH((sH-cN):normalize())end;if sN<go*1.5 then bf=cA/3.6;if g4==nil then dP,bf=cp(c7):escapeAndOrbitalSpeed(sN)end end;local c5,c6;if not b4 then c5,c6=ql(cK)else c5,c6=qo(cK)end;if b3 and not bb and not be and not bd then local lv,lw=cs.checkLOS((bk-cN):normalize())if c7.name~=kD.name then if lv~=nil and c7.name~=lv.name and lw<re then c2="Collision with "..lv.name.." in "..iL(lw).."\nClear LOS to continue."c3=5;qa=true else qa=false;c2=""end end end;if not qa then if not be and not bd and not sI then sk=qH((sH-cN):normalize())elseif b4 and(bd or be)then sk=qH(-vec3(cJ):normalize())end end;if bb then if not pV then b0=false;q5=a2;bQ=fU(a2,2)pV=true end;local rf=c.getThrottle()if t then rf=bQ end;local sU=99999;local os=-vec3(bO.getWorldAcceleration()):dot(cJ:normalize())local sV=dk(cJ:dot((sH-cN):normalize()),0,cK)if sV>0 or os>0 then sU=co.computeTravelTime(sV,os,re-c5)end;if a1>de then a1=de-0.2 end;if cI:len()>=a1 or rf==0 and pV or a3/4>sU then bb=false;if bg~="Cruising"then fT("apCru","AP")bg="Cruising"end;be=true;q5=0 end;local sW=re;if sW<=c5 or H and cV<=c5+10000 and cU then if H and cV<=c5+10000 and cU then if cV<pG and cV>2000 then cs.ResetAutopilots(1)c2="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pG=cV else pG=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;if not b4 then b2=true;cy=true end;q5=0;pV=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then q5=1;q7=true end;local dP,su=cp(c7):escapeAndOrbitalSpeed((cN-kD.center):len()-kD.radius)local qO;if g4 then qO=g4.position-cN end;if g4 and g4.planetname=="Space"and cK<50 then if#bF>0 then if not qg then table.remove(bF,1)end;if#bF>0 then b0=false;if not qg then qg=2 end;return end end;sG("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g4 and g4.planetname~="Space"and cK<=su and(fs.apoapsis==nil or fs.periapsis==nil or fs.apoapsis.altitude<=0 or fs.periapsis.altitude<=0)then sG("Autopilot complete, commencing reentry")bk=g4.position;cb=true;cs.showWayPoint(c7,bk)elseif(g4 and g4.planetname~="Space"or g4==nil)and fs.periapsis~=nil and fs.periapsis.altitude>0 and fs.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fT("apCir","AP")bg="Circularizing"end;if cK<=su then if g4 then if cJ:normalize():dot(qO:normalize())>0.4 then if bg~="Orbiting to Target"then fT("apOrb","OB")bg="Orbiting to Target"end;if not r0 then b0=false;cs.showWayPoint(c7,g4.position)r0=true end else sG("Autopilot complete, proceeding with reentry")bk=g4.position;cb=true;cs.showWayPoint(c7,g4.position)r0=false end else sG("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sG("Autopilot complete, fixing Orbit",true)end elseif be then local sW=re;if sW<=c5 or H and cV<=c5+10000 and cU then if H and cV<=c5+10000 and cU then if cV<pG and cV>2000 then if not qg then qg=true end;c2="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pG=cV else pG=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;if not b4 then b2=true;cy=true end end;local rf=c.getThrottle()if t then rf=bQ end;if rf>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;be=false end else if sk then if not bc and g4==nil or not bc and g4 and g4.planetname~="Space"then if not cb then bk=vec3(c7.center)+(go+c7.radius)*cH;sX=q2;sY=cH end;bc=true elseif sk and not qa then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;if not pV then q5=a2;q7=true;bQ=fU(a2,2)pV=true;b0=false end end end end elseif b3 and(g4~=nil and g4.planetname~="Space"and cf)then c2="Autopilot complete, starting reentry"fT("apCom","AP")bk=g4.position;b0=false;bd=false;b3=false;qZ=false;bg="Aligning"q5=0;pV=false;b2=true;cb=true;cs.showWayPoint(c7,g4.position)end;if b_ then cy=true;local sP=0;local fu=vec3(DUPlayer.getWorldPosition())local sZ=fu-cN;local s_=vec3(sZ):project_on(cG):len()local t0=vec3(sZ):project_on(cH):len()local ca=dm(s_*s_+t0*t0)qH(sZ:normalize())local mB=40;local t1=ca<mB;local t2=100;local rr=dk((ca-mB)/2,10,t2)pX=0;local sk=eY(pY)<0.1;if sk and cK<rr and not t1 then b0=false;sP=-20 else b0="Follow"sP=0 end;local t3=0;if eY(sP-cR)>t3 then if t4==nil then t4=pid.new(2*0.01,0,2*0.1)end;t4:inject(sP-cR)local sR=t4:get()pX=sR end end;if b5 or b6 or b8 or bq or bt~=nil then if bH then if ce==-1 then ba=ba-0.2 else ba=ch+bH-ce end end;local t5=bu;if t5 then t5=t5*dk(cK/100,0.1,1)*cg else t5=bs end;if not cf then t5=bs end;q4=cG:project_on_plane(cL):normalize():dot(cJ)if q4>100 then c5,c6=co.computeDistanceAndTime(q4,100,ci,0,0,t5)local t6,t7=co.computeDistanceAndTime(100,0,ci,0,0,t5*0.55)c5=c5+t6 else c5,c6=co.computeDistanceAndTime(q4,0,ci,0,0,t5*0.55)end;local sy=ba-ch-cM;local t8=200+cK;if b8 or cb then t9=2000+cK end;local ta=1;if b7 then ta=dk(cK/100,0.1,1)end;local sP=(utils.smoothstep(sy,-t8,t8)-0.5)*2*Q*ta;if not b8 and not cb and not bq and cG:dot(cJ:normalize())<0.99 then sP=(utils.smoothstep(sy,-t8*dk(20-19*cg*10,1,20),t8*dk(20-19*cg*10,1,20))-0.5)*2*Q*dk(2-cg*10,1,2)*ta end;if not b5 then sP=0 end;if bt~=nil then if cX and not bz then sP=bt else bt=nil end end;cy=true;local tb=pX;if b8 then local tc=bM(cA)local td,te=co.computeDistanceAndTime(cK,tc/3.6,ci,0,0,bs-kD.gravity*9.8*ci)td=td==-1 and 5000 or td;local q_=ch-(kD.noAtmosphericDensityAltitude+td)local tf=ch>kD.noAtmosphericDensityAltitude+td*1.35;if tf then sP=R;if cK<=tc/3.6 and cK>tc/3.6-10 and eY(cJ:normalize():dot(cG))>0.9 and not cQ then bU=false;q5=1 end elseif(cQ or iH:getTargetSpeed(axisCommandId.longitudinal)~=tc)and not tf and not cf then q6=tc;q7=true end;if cQ then if cK>tc/3.6 and not tf then b0="Reentry Limit"if bQ>0 then q5=0 end else b0=false end else b0=false end;if cM>0 then b0="Reentry vSpd"end;if not pW then sP=-80;if ch<kD.surfaceMaxAltitude+(kD.atmosphereThickness-kD.surfaceMaxAltitude)*0.25 then c2="PARACHUTE DEPLOYED at "..fU(ch,0)b8=false;b6=true;lt=true;q5=0;sP=0;cy=q end elseif kD.noAtmosphericDensityAltitude>0 and tf then cy=true elseif not tf then if not cf and(cQ or iH:getTargetSpeed(axisCommandId.longitudinal)~=tc)then q6=tc end;if cK<tc/3.6+1 then b0=false;pW=false;b8=false;cy=true;q5=1 end end end;if cK>i_ and not cc and not bq and not b6 and u then qH(vec3(cJ))end;if cW or(bq or cc)and bl>0 and cf then local qO;if cW then if type(cW)=="table"then qO=cW elseif cW<3 and cW>0 then qO=-cL:cross(cJ)*5000 elseif cW>=3 then qO=cL:cross(cJ)*5000 elseif cW<0 then qO=cJ*25000 end elseif g4~=nil then qO=g4.position-cN else qO=c7.center-cN end;local sO=math.deg(qp(cL:normalize(),cJ,qO))*2;local mE=math.rad(eY(cS))if cK>aL and cf then local tg=1000+cK;local th=(utils.smoothstep(sy-cM*10,-tg,tg)-0.5)*2*Q;local ti=dk(90-th,0,180)p_=dk(sO*2,-ti,ti)local tj=sO;sO=dk(dk(sO,-N*0.80,N*0.80)*math.cos(mE)+4*(cR-sP)*math.sin(math.rad(cS)),-N*0.80,N*0.80)local tk=1;if p_~=0 then tk=eY(mE/p_)end;tk=(90-dk(eY(p_-cS),0,90))/90;local tl=sP;if eY(cS)>90 then tl=-tl end;sP=tk*dk(dk(tl*math.cos(mE),-O*0.8,O*0.8)+eY(dk(eY(tj)*math.sin(mE),-O*0.80,O*0.80)),-O*0.80,O*0.80)else p_=0;sO=dk(sO,-N*0.80,N*0.80)end;local tm=sa-sO;if cW and eY(tm)<=0.0001 and(type(cW)=="table"or type(cW)~="table"and cW<0 and eY(cS)<1)then if cW==-2 then cs.ToggleAltitudeHold()end;cW=nil;fT("180Off","BR")return end;if not cz and cK>aL and cf then if tn==nil then tn=pid.new(2*0.01,0,2*0.1)end;tn:inject(tm)local sT=dk(tn:get(),-1,1)pY=pY+sT elseif cf and ce>-1 or cK<aL then qH(qO)elseif cz and cf then if(sa<-N or sa>N)and cf then qH(cJ)end;if(sb<-O or sb>O)and cf then sP=dk(cR-sb,cR-O*0.80,cR+O*0.80)end end;if g4~=nil and not cc then local sl=kD:getAltitude(g4.position)local q_=qO:project_on_plane(cL):len()lt=true;if ba<kD.noAtmosphericDensityAltitude and not cc and not b7 and not b8 and(q_<=c5 and qO:len()<kD.radius)and(cJ:project_on_plane(cL):normalize():dot(qO:project_on_plane(cL):normalize())>0.99 or lz=="Finalizing Approach")then lz="Finalizing Approach"if#bF>0 then if not qg then table.remove(bF,1)end;if#bF>0 then if not qg then qg=2 end;return end end;q5=0;if b5 then cs.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lz=="Finalizing Approach"and(q4<0.1 or q_<0.1 or to~=nil and to<q_)then fT("bklOn","BL")b6=true;da=true;if g4.heading then db=g4.heading else db=nil end;bq=false;lz="Proceeding to Waypoint"cY=false end;to=q_ end elseif bq and not cf and ba>kD.noAtmosphericDensityAltitude and not(cc or b8)then if g4~=nil and c7.name==kD.name then local qO=g4.position-cN;local sl=kD:getAltitude(g4.position)local q_=dm(qO:len()^2-(ch-sl)^2)local t5=bu;if t5 then c5,c6=co.computeDistanceAndTime(cK,0,ci,0,0,t5/2)lt=true;if q_<=c5+cK*s9/2 and cJ:project_on_plane(cL):normalize():dot(qO:project_on_plane(cL):normalize())>0.99 then if kD.hasAtmosphere then b0=false;b2=false;pW=true;cb=false;cd=true;b3=false;cs.BeginReentry()end end;to=q_ end end end;if not cf and ce==-1 and(b5 and ba>kD.noAtmosphericDensityAltitude)and not(cc or bz or b8)then if not cD and not bz then cC=ba;pQ=true;if bq then q1.VectorToTarget=true end;cs.ToggleIntoOrbit()bq=false;pO=true end end;if cz and cf and ce==-1 and cK>aL and lz~="Finalizing Approach"then qH(cJ)sP=dk(cR-sb,cR-O*0.80,cR+O*0.80)end;pX=tb;local qA=-1;if b6 then if not qb then rS=false;if not cQ then q5=0 end;iH:setTargetGroundAltitude(500)iH:activateGroundEngineAltitudeStabilization(500)bB=true;if not cf then rS=true end;qb=true end;sP=0;local tp=false;local tq=math.abs(q4)if not r and cP then tp=antigrav.getBaseAltitude()if tp<kD.surfaceMaxAltitude and g4==nil or g4~=nil and kD:getAltitude(g4.position)>tp then tp=false end else tp=false end;if db then if tq<0.05 then if cM>-P then b0=false else b0="BL Align BLR"end;if qH(db,0.001)then db=nil;cy=q else pX=0;cy=true end else b0="BL Align Hzn"end;if tp and eY(ch-tp)<250 then b0="AGG Align"end else local tr=false;local ts=30;if tq<10 and sh~=nil and sh>0 then local tt=dk(cg,0.4,2)local t5=bu*dk(cK/100,0.1,1)*tt;local tu=sh*tt+t5-of;local tv=t5/2-of;local tw=cK-dm(eY(tv/2)*20/(0.5*ci))*utils.sign(tv)if tw<0 then tw=0 end;local tx;if cK>100 then local ty,dP=co.computeDistanceAndTime(cK,100,ci,0,0,t5)local tz,dP=co.computeDistanceAndTime(100,0,ci,0,0,dm(t5))tx=ty+tz else tx=co.computeDistanceAndTime(cK,0,ci,0,0,dm(t5))end;if tx<20 then b0=false else local tA=0;if tw>100 then local tB,dP=co.computeDistanceAndTime(tw,100,ci,0,0,tu)local tC,dP=co.computeDistanceAndTime(100,0,ci,0,0,sh*tt+dm(t5)-of)tA=tB+tC else tA,dP=co.computeDistanceAndTime(tw,0,ci,0,0,sh*tt+dm(t5)-of)end;tA=(tA+15+cK*s9)*1.1;local tD=da and g4~=nil and kD:getAltitude(g4.position)>0 and g4.safe;local sl=nil;if tp and tp<ch then sl=tp elseif tD then sl=kD:getAltitude(g4.position)+250 elseif ch>kD.surfaceMaxAltitude then sl=kD.surfaceMaxAltitude end;if cZ then local tE=kD:getAltitude(cZ[1].center)if sl then if tE>sl then sl=tE end else sl=tE end end;if sl~=nil then local tF=ch-sl;tr=true;if tF<=tA or tA==-1 or tq>0.05 and da then if tq>0.05 and da then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qA=ce;if qA>-1 then if not tp and not bm then q8=true;iH:setTargetGroundAltitude(_)end;if(cK<1 or cJ:normalize():dot(cL)<0)and not db and qA-5<_ then b6=false;b5=false;bZ=0;if rS then qS(0,1)end;b0="BL Complete"cy=q;da=false;qb=false else if cM<-5 or tq>0.05 then b0="BL Slowing"else b0=false end end elseif not tr then if lt and cJ:normalize():dot(-gq)<0.999 then b0="BL Strong"qH()elseif tq>10 or tq>0.05 and da then b0="BL hSpd"elseif cM<-P then b0="BL BLR"if rS then qS(0,1)end else if rS then qS(-1)end;b0=false end end end else qb=false end;if b7 or cc then local lv,eJ,eI;if bk~=nil then lv,eJ,eI=cn:getPlanetarySystem(0):castIntersections(cN,(bk-cN):normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)end;if cP and not cc then if ch>=ba-50 and cK>i_ then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"q5=0 end end elseif eY(sP)<15 and ch/ba>0.75 then b7=false;if not cc then if cQ and not t then d.control.cancelCurrentControlMasterMode()end elseif cc and cK<i_ then b3=true;cc=false;b5=false;b7=false;q5=0 elseif cc then q5=0;b0="ATO Space"end elseif cc and not cf and c7~=nil and(lv==nil or lv.name==c7.name)then b3=true;cc=false;b5=false;b7=false;if not cQ then q5=0 end;bb=true end end;local tG=ce>-1;local tH=cR;if(bq or cc or cW)and not tG and cK>aL and cf then local mE=math.rad(eY(cS))tH=cR*eY(math.cos(mE))+sb*math.sin(mE)end;local tI=dk(sP-tH,-O*0.80,O*0.80)if not cf and bq then tI=dk(sP-tH,-85,Q)elseif not cf then tI=dk(sP-tH,-Q,Q)end;if eY(cS)<5 or bq or cW or b6 or tG or b5 then if t4==nil then t4=pid.new(5*0.01,0,5*0.1)end;t4:inject(tI)local sR=t4:get()pX=pX+sR end end;if antigrav~=nil and(antigrav and not r and ch<200000)then if bv==nil or bv<1000 then bv=1000 end;if tJ~=bv then tJ=bv;qf=tJ end end;if(cf or b8 or cd)and t and cQ then if tK==nil then tK=pid.new(0.1,0,1)end;local tL=0;if aU>0 and not b8 and cg>0.005 and cg<0.1 and cM>-10 then local tM=bO.getFrictionBurnSpeed()*aU;local tN=cA/3.6;if tM>tN then tL=tM-tN-1 end end;tK:inject(cA/3.6+tL-cJ:dot(cG))local tO=tK:get()bT=dk(tO,-1,1)if not d6 then if bT<bQ and(cg>0.005 or b8 or cd)then bS=true;d6=dk(bT,0.01,1)else bS=false;d6=bQ end end;if tP==nil then tP=pid.new(1*0.01,0,1*0.1)end;tP:inject(cJ:len()-cA/3.6-tL)local tQ=dk(tP:get(),0,1)if cf and cM<-80 or(cg>0.005 or b8 or cd)then bR=tQ end;if bR>0 then if bS and bT==0.01 and not d6 then d6=0 end else bT=dk(bT,0.01,1)end;local tR=''local tS=vec3()local tT=rp(axisCommandId.vertical,bZ*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tT,rO)local tU='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tU=tU..aV end;local tV=iH:getAxisCommandType(axisCommandId.longitudinal)local tW=iH:composeAxisAccelerationFromThrottle(tU,axisCommandId.longitudinal)local tX=rD(axisCommandId.lateral,by*1000)tR=tR..' , '.."lateral airfoil , lateral ground "tS=tS+tX;if tS:len()>constants.epsilon then d:setEngineForceCommand(tR,tS,rO,'','','',rP)end;d:setEngineForceCommand(tU,tW,rN)local tY='thrust analog vertical fueled 'local tZ='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then tZ=tZ..aW end;if bC=="All"or bC=="Vertical"then tY=tY..aX end;if bZ~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(tY,tT,rN)else d:setEngineForceCommand(tY,vec3(),rN)end;if by~=0 then d:setEngineForceCommand(tZ,tX,rN)else d:setEngineForceCommand(tZ,vec3(),rN)end;if rW==0 then rW=bR end;local t_=-rW*(aQ*cJ+aR*r_)d:setEngineForceCommand('brake',t_)else if t then if not d6 then d6=bQ end end;local rr=c.getAxisCommandValue(0)if not cQ then if tP==nil then tP=pid.new(1*0.01,0,1*0.1)end;tP:inject(cJ:len()-rr/3.6)local tQ=dk(tP:get(),0,1)rW=dk(rW+tQ,0,1)end;local t_=-rW*(aQ*cJ+aR*r_)d:setEngineForceCommand('brake',t_)local tR=''local tS=vec3()local u0=false;local tU='thrust analog longitudinal 'if aV~="none"and(bC=="All"or bC=="Longitude")then tU=tU..aV end;local tV=iH:getAxisCommandType(axisCommandId.longitudinal)if tV==axisCommandType.byThrottle then local tW=iH:composeAxisAccelerationFromThrottle(tU,axisCommandId.longitudinal)d:setEngineForceCommand(tU,tW,rN)elseif tV==axisCommandType.byTargetSpeed then local tW=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tR=tR..' , '..tU;tS=tS+tW;if iH:getTargetSpeed(axisCommandId.longitudinal)==0 or iH:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iH:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u0=true end end;local tZ='thrust analog lateral 'if aW~="none"and(bC=="All"or bC=="Lateral")then tZ=tZ..aW end;local u1=iH:getAxisCommandType(axisCommandId.lateral)if u1==axisCommandType.byThrottle then local u2=iH:composeAxisAccelerationFromThrottle(tZ,axisCommandId.lateral)d:setEngineForceCommand(tZ,u2,rN)elseif u1==axisCommandType.byTargetSpeed then local tX=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tR=tR..' , '..tZ;tS=tS+tX end;local tY='thrust analog vertical 'if aX~="none"and(bC=="All"or bC=="Vertical")then tY=tY..aX end;local u3=iH:getAxisCommandType(axisCommandId.vertical)if u3==axisCommandType.byThrottle then local tT=iH:composeAxisAccelerationFromThrottle(tY,axisCommandId.vertical)if bZ~=0 or b6 and b0 then d:setEngineForceCommand(tY,tT,rN,'airfoil','ground','',rP)else d:setEngineForceCommand(tY,vec3(),rN)d:setEngineForceCommand('airfoil vertical',tT,rN,'airfoil','','',rP)d:setEngineForceCommand('ground vertical',tT,rN,'ground','','',rP)end elseif u3==axisCommandType.byTargetSpeed then if bZ<0 then d:setEngineForceCommand('hover',vec3(),rN)end;local u4=iH:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tR=tR..' , '..tY;tS=tS+u4 end;if tS:len()>constants.epsilon then if rW~=0 or u0 or eY(r_:dot(cG))<0.5 then tR=tR..', brake'end;d:setEngineForceCommand(tR,tS,rO,'','','',rP)end end;local u5=aN*(s3-s2)local u6=vec3(bO.getWorldAirFrictionAngularAcceleration())u5=u5-u6;d:setEngineTorqueCommand('torque',u5,rN,'airfoil','','',rP)d:setBoosterCommand('rocket_engine')if c4 and not o then local fo=cI:len()local u7=0.15;if not cQ then local u8=iH:getTargetSpeed(axisCommandId.longitudinal)if fo*3.6>u8*(1-u7)and u9 then u9=false;d:toggleBoosters()elseif fo*3.6<u8*(1-u7)and not u9 then u9=true;d:toggleBoosters()end else local rf=c.getThrottle()if t then rf=bQ*100 end;local rr=rf/100;if not cf then rr=rr*a1;if fo>=rr*(1-u7)and u9 then u9=false;d:toggleBoosters()elseif fo<rr*(1-u7)and not u9 then u9=true;d:toggleBoosters()end else local tc=bM(cA)rr=rr*tc/3.6;if fo>=rr*(1-u7)and u9 then u9=false;d:toggleBoosters()elseif fo<rr*(1-u7)and not u9 then u9=true;d:toggleBoosters()end end end end end;if ua then for dK,dw in pairs(ua)do pE[dK]=dw end end;ce=qv()return pE end;local function ub(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uc,iG,iH,iI,ud,gL,fU,e3,dl,dk,fT,iK,pD)local bO=DUConstruct;local ue={}local uf=true;local ug=5;local uh=5;local ui=ug;local uj=uh;local uk=bP;function ue.landingGear(q8)bm=not bm;if bm then bq=false;bt=nil;cs.cmdThrottle(0)if vBooster or hover then if(cf or ch<20000)and not q8 then fT("bklOn","BL")lt=true;b8=false;b7=false;b9=false;if bz then cs.ToggleIntoOrbit()end;if b6 then da=not da end;b6=true;cy=true;bm=false else if bV then fT("grOut","LG",1)d.control.deployLandingGears()end;da=false;iH:setTargetGroundAltitude(_)if cf then b0="Landing"end end;b5=false;bH=false elseif bV and not b6 then fT("grOut","LG",1)d.control.deployLandingGears()end else if bV then fT("grIn","LG",1)d.control.retractLandingGears()end;iH:activateGroundEngineAltitudeStabilization(qV)if bB then if _<iH.targetGroundAltitude then iH:setTargetGroundAltitude(iH.targetGroundAltitude)else iH:setTargetGroundAltitude(Z)end end end end;function ue.startControl(ul)local function um(ra)local rb=1;local function un(uo,ra)local up={kD.surfaceMaxAltitude+100,kD.spaceEngineMinAltitude-0.01*kD.noAtmosphericDensityAltitude,kD.noAtmosphericDensityAltitude+V,kD.radius*(U-1)+kD.noAtmosphericDensityAltitude}local uq=uo;for dP,dw in ipairs(up)do if ra and uq>dw then uo=dw elseif uo<dw and not ra then uo=dw;break end end;return uo end;if ra then rb=-1 end;if not r and cP then if c0 and ra then bv=1000 elseif bv~=nil then bv=bv+rb*uh;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tJ+rb*100 end elseif b5 or b9 or bz then if bz then if c0 then cC=un(cC,ra)else cC=cC+rb*ug end;if cC<kD.noAtmosphericDensityAltitude then cC=kD.noAtmosphericDensityAltitude end else if c0 and cf then ba=un(ba,ra)bH=false else ba=ba+rb*ug;if bH then if ba>100 then bH=false else iH:updateTargetGroundAltitudeFromActionStart(rb*1.0)bH=d:getTargetGroundAltitude()end end end end else iH:updateTargetGroundAltitudeFromActionStart(rb*1.0)end end;local function ur(us)if not cf then c2="Flight Assist in Atmo only"return end;local dt=type(us)if cW==nil then if dt=="table"then if b3 or bq then cs.ToggleAutopilot()end;fT("180On","BR")elseif us==1 then fT("bnkLft","BR")else fT("bnkRht","BR")end;if not b5 and not b3 and not bq then cs.ToggleAltitudeHold()if dt~="table"then us=us+1 end end;cW=us else fT("180Off","BR")cW=nil end end;local function ut()if iI()==1 then c8=0;c9=0;ud(bi)elseif iG()==1 and y then cx=false;cw=false end;c0=false end;if ul=="gear"then cu.landingGear()elseif ul=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ul=="forward"then if p5 and not cf and not b3 then b2=not b2;b1=false else bW=bW-1 end elseif ul=="backward"then if p5 then if not cf then if not b3 then b1=not b1;b2=false else b4=not b4 end else ur(-cJ*5000)end else bW=bW+1 end elseif ul=="left"then if p5 then ur(1)else bX=bX-1 end elseif ul=="right"then if p5 then ur(3)else bX=bX+1 end elseif ul=="yawright"then bY=bY-1;db=nil elseif ul=="yawleft"then bY=bY+1;db=nil elseif ul=="straferight"then iH:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif ul=="strafeleft"then iH:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif ul=="up"then cs.vertical(1)if ce-3<_ and ch>0 and bm then cu.landingGear()end elseif ul=="down"then cs.vertical(-1)elseif ul=="groundaltitudeup"then um()elseif ul=="groundaltitudedown"then um(true)elseif ul=="option1"then uu=false;if p5 and c0 then local uv=""for M=1,#d1 do uv=uv.."| Name: "..a.getPlayerName(d1[M]).." Mass: "..fU(bO.getBoardedPlayerMass(d1[M])/1000,1).."t "end;a.print("Onboard: "..uv)return end;cr.adjustAutopilotTargetIndex()elseif ul=="option2"then uu=false;if p5 and c0 then for M=1,#d1 do bO.forceDeboard(d1[M])bO.forceInterruptVRSession(d1[M])end;c2="Deboarded All Passengers"return end;cr.adjustAutopilotTargetIndex(1)elseif ul=="option3"then uu=false;if p5 and c0 then local uv=""for M=1,#d2 do uv=uv.."| ID: "..d2[M].." Mass: "..fU(b.getDockedConstructMass(d2[M])/1000,1).."t "end;a.print("Docked Ships: "..uv)return end;if x then if w then w=false else w=true end;if ct then ct.ToggleRadarPanel()end end elseif ul=="option4"then uu=false;if p5 and c0 then for M=1,#d2 do b.forceUndock(d2[M])end;c2="Undocked all ships"return end;cW=nil;cs.ToggleAutopilot()elseif ul=="option5"then uu=false;cs.ToggleLockPitch()elseif ul=="option6"then uu=false;if p5 and c0 then if shield then cv.ventShield()else c2="No shield found"end;return end;cs.ToggleAltitudeHold()elseif ul=="option7"then uu=false;if p5 and c0 then if shield then shield.toggle()return else c2="No shield found"return end end;E=not E;if E then c2="Collision System Enabled"else c2="Collision System Secured"end elseif ul=="option8"then uu=false;if p5 and c0 then if bl>0 and g4~=nil then cs.routeWP()else c2="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c2="DeCoupled Mode - Ground Stabilization off"iH:deactivateGroundEngineAltitudeStabilization()fT("gsOff","GS")else c2="Coupled Mode - Ground Stabilization on"iH:activateGroundEngineAltitudeStabilization(qV)dd=true;fT("gsOn","GS")end elseif ul=="option9"then uu=false;if p5 and c0 then iH:resetCommand(axisCommandId.longitudinal)iH:resetCommand(axisCommandId.lateral)iH:resetCommand(axisCommandId.vertical)cs.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cj=gyro.isActive()==1;if cj then fT("gyOn","GA")else fT("gyOff","GA")end else c2="No gyro found"end elseif ul=="lshift"then if p5 then c0=true end elseif ul=="brake"then if aZ or p5 then cs.BrakeToggle("Manual")elseif not b0 then cs.BrakeToggle("Manual")else b0="Manual"end elseif ul=="lalt"then uu=true;p5=true;if iG()==0 and not j and g=="keyboard"then ud(1)end elseif ul=="booster"then if o then d:toggleBoosters()elseif not c4 then if not u9 then d:toggleBoosters()u9=true end;c4=true else if u9 then d:toggleBoosters()u9=false end;c4=false end elseif ul=="stopengines"then local function uw()if bP-uk<1.5 then fT("clear","CA")cs.clearAll()end end;uw()uk=bP;if iH:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p5 then if cA>0 then cA=0 else cA=W end elseif bQ~=0 then iH:resetCommand(axisCommandId.longitudinal)cs.cmdThrottle(0)else cs.cmdThrottle(100)end else if iH:getTargetSpeed(axisCommandId.longitudinal)~=0 then iH:resetCommand(axisCommandId.longitudinal)else if cf then cs.cmdCruise(cA)else cs.cmdCruise(a1*3.6)end end end elseif ul=="speedup"then cs.changeSpd()elseif ul=="speeddown"then cs.changeSpd(true)elseif ul=="antigravity"and not r then if antigrav~=nil then cs.ToggleAntigrav()else c2="No antigrav found"end elseif ul=="leftmouse"then c1=true;if c0 then ut()uu=false else c0=true;bi=iI()ud(1)end end end;function ue.stopControl(ul)local function ux()if not r and cP then uj=uh end;if b5 or b9 or bz then ui=ug end end;if ul=="forward"then bW=0 elseif ul=="backward"then bW=0 elseif ul=="left"then if cW then if cW==2 then cW=-2 else cW=-1 end end;bX=0 elseif ul=="right"then if cW then if cW==4 then cW=-2 else cW=-1 end end;bX=0 elseif ul=="yawright"then bY=0 elseif ul=="yawleft"then bY=0 elseif ul=="straferight"then iH:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif ul=="strafeleft"then iH:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif ul=="up"then cs.vertical(0,-1)elseif ul=="down"then cs.vertical(0,1)elseif ul=="groundaltitudeup"then ux()uu=false elseif ul=="groundaltitudedown"then ux()uu=false elseif ul=="brake"then if not aZ and not p5 then if b0 then cs.BrakeToggle()else b0=false end end elseif ul=="lalt"then if c0 then c0=false end;if iG()==0 and j then if uu then if iI()==1 then ud(0)else ud(1)end else uu=true end elseif iG()==0 and not j and g=="keyboard"then ud(0)end;p5=false end end;function ue.loopControl(ul)local function uy(ra)local rb=1;if ra then rb=-1 end;if not r and cP then if bv~=nil then bv=bv+rb*uj;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;uj=dk(uj*1.05,uh,50)else bv=tJ+rb*100 end elseif b5 or b9 or bz then if bz then cC=cC+rb*ui;if cC<kD.noAtmosphericDensityAltitude then cC=kD.noAtmosphericDensityAltitude end else ba=ba+rb*ui end;ui=dk(ui*1.05,ug,50)else iH:updateTargetGroundAltitudeFromActionLoop(rb*1.0)end end;local function uz(ra)local rb=1;if ra then rb=-1 end;if not c0 then if t and not p5 then bQ=dk(bQ+rb*aF/100,-1,1)else iH:updateCommandFromActionLoop(axisCommandId.longitudinal,rb*aF)end end end;if ul=="groundaltitudeup"then if not c0 then uy()end elseif ul=="groundaltitudedown"then if not c0 then uy(true)end elseif ul=="speedup"then uz()elseif ul=="speeddown"then uz(true)end end;function ue.inputTextControl(r9)local function uA(uB,fu,gy)local function uC(fu)local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local dT,dU,e0,e1,e2=e3(fu,dD)if dT=="0"and dU=="0"then return vec3(dl(e0),dl(e1),dl(e2))end;e1=math.rad(e1)e0=math.rad(e0)local kD=e[dl(dT)][dl(dU)]local eU=math.cos(e0)local uD=vec3(eU*math.cos(e1),eU*math.sin(e1),math.sin(e0))return kD.center+(kD.radius+e2)*uD end;local fW=uC(fu)return cr.AddNewLocation(uB,fW,gy)end;local M;local uE,iv=nil,nil;local uF="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r9," ")uE=r9;if M~=nil then uE=string.sub(r9,0,M-1)iv=string.sub(r9,M+1)end;if uE=="/help"or uE=="/commands"then for lu in string.gmatch(uF,"([^\n]+)")do a.print(lu)end;return elseif uE=="/setname"then if iv==nil or iv==""then c2="Usage: ah-setname Newname"return end;if bl>0 and g4~=nil then cr.UpdatePosition(iv)else c2="Select a saved target to rename first"end elseif shield and uE=="/resist"then cv.setResist(iv)elseif uE=="/addlocation"or string.find(r9,"::pos")~=nil then local gy=false;local uB="0-Temp"if iv==nil or iv==""or uE~="/addlocation"then iv=uE;gy=true end;M=string.find(iv,"::")if not gy then uB=string.sub(iv,1,M-2)end;local fu=string.sub(iv,M)uA(uB,fu,gy)elseif uE=="/agg"then if iv==nil or iv==""then c2="Usage: /agg targetheight"return end;iv=dl(iv)if iv<1000 then iv=1000 end;bv=iv;c2="AGG Target Height set to "..iv elseif uE=="/G"then if iv==nil or iv==""then c2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if iv=="dump"then for dK,dw in pairs(iK())do if type(dw.get())=="boolean"then if dw.get()==true then a.print(dK.." true")else a.print(dK.." false")end elseif dw.get()==nil then a.print(dK.." nil")else a.print(dK.." "..dw.get())end end;return end;M=string.find(iv," ")local uG=string.sub(iv,0,M-1)local uH=string.sub(iv,M+1)for dK,dw in pairs(iK())do if dK==uG then local uI=type(dw.get())if uI=="number"then uH=dl(uH)if dK=="AtmoSpeedLimit"then cA=uH end end;c2="Variable "..uG.." changed to "..uH;if dK=="MaxGameVelocity"then uH=uH/3.6;if uH>de-0.2 then uH=de-0.2;c2="Variable "..uG.." changed to "..fU(uH*3.6,1)end end;if uI=="boolean"then if string.lower(uH)=="true"then uH=true else uH=false end end;dw.set(uH)return end end;c2="No such global variable: "..uG elseif uE=="/deletewp"then if bl>0 and g4~=nil then cr.ClearCurrentPosition()else c2="Select a custom wp to delete first in IPH"end elseif uE=="/copydatabank"then if dbHud_2 then pD(true)else c2="Spare Databank required to copy databank"end elseif uE=="/iphWP"then if bl>0 then a.print(cs.showWayPoint(c7,bk,true))a.print(json.encode(bk))c2="::pos waypoint shown in lua chat in local and world format"else c2="No target selected in IPH"end elseif uE=="/createPrivate"then local uJ="privatelocations = {\n"local uK=""if#d8>0 then for dK,dw in pairs(d8)do uJ=uJ.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uJ=uJ.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uJ=uJ.."safe = true},\n"else uJ=uJ.."safe = false},\n"end end end;uK=#d8 .."-Private "if iv=="all"then for dK,dw in pairs(bp)do uJ=uJ.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '*"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uJ=uJ.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uJ=uJ.." safe = true},\n"else uJ=uJ.."safe = false},\n"end end;uK=uK..#bp.."-Public "end;uJ=uJ.."}\n return privatelocations"if uc then uc.setHTML(uJ)end;c2=uK.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c3=7 end end;function ue.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c2="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if uL then for dK,dw in pairs(uL)do ue[dK]=dw end end;return ue end;local function uM(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iD,uc)local a=DUSystem;local bO=DUConstruct;local uN=DUPlayer;local uO=DULibrary;local uP={}local dj=string.format;local iE=json.decode;local uQ=json.encode;local pv=b.getElementMaxHitPointsById;local iF=b.getElementMassById;local iG=d.control.isRemoteControlled;local e3=string.match;local gL=a.destroyWidgetPanel;local fR=a.updateData;local fS=a.addDataToWidget;local ud=a.lockView;local iI=a.isViewLocked;local dm=math.sqrt;local dl=tonumber;local eY=math.abs;local bM=math.floor;local bN=c.getAtmosphereDensity;local eT=math.atan;local bL=a.getArkTime;local dk=utils.clamp;local iH=d.axisCommandManager;local gN=13;local iN=b.getElementIdList()local iO=0;local function dn(eB,eC)if eB==0 then return eY(eC)<1e-09 elseif eC==0 then return eY(eB)<1e-09 else return eY(eB-eC)<math.max(eY(eB),eY(eC))*dB end end;local function fU(dC,uR)local rb=10^(uR or 0)return bM(dC*rb+0.5)/rb end;local function iJ(uS,uT)for dK,dw in pairs(uT)do if type(dK)=="string"then uS[dK]=dw else uS[#uS+1]=uT[dK]end end;return uS end;local function iK(uU)local uV={}if not uU then iJ(uV,L)iJ(uV,ab)iJ(uV,aD)iJ(uV,aY)return uV elseif uU=="boolean"then return L elseif uU=="handling"then return ab elseif uU=="hud"then return aD elseif uU=="physics"then return aY end end;local function pD(uW)local function uX(uY)for dK,dw in pairs(uY)do dbHud_1.setStringValue(dK,uQ(dw.get()))if uW and dbHud_2 then dbHud_2.setStringValue(dK,uQ(dw.get()))end end end;if dbHud_1 then uX(bI)uX(iK())a.print("Saved Variables to Datacore")if uW and dbHud_2 then c2="Databank copied.  Remove copy when ready."end end end;local function fT(uZ,u_,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uZ..".mp3")end;local function gM(hG,hH,r9,jV,v0)return dj([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jV or"",hG,hH,v0 or"",r9)end;local function iL(ca,v1)v1=v1 or 1;local unit="m"if ca>100000 then ca=ca/200000;unit="su"elseif ca>1000 then ca=ca/1000;unit="km"end;return fU(ca,v1)..unit end;local function iM(v2)local v3=0;local v4=0;local v5=0;if v2<60 then v2=bM(v2)elseif v2<3600 then v3=bM(v2/60)v2=bM(v2%60)elseif v2<86400 then v4=bM(v2/3600)v3=bM(v2%3600/60)else v5=bM(v2/86400)v4=bM(v2%86400/3600)end;if v5>365 then return">1y"elseif v5>0 then return v5 .."d "..v4 .."h "elseif v4>0 then return v4 .."h "..v3 .."m "elseif v3>0 then return v3 .."m "..v2 .."s"elseif v2>0 then return v2 .."s"else return"0s"end end;local function v6()if radar_1 then ct=gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)end end;function uP.radarSetup()v6()end;function uP.onStart()local v7=false;local function v8()local function v9(va)local vb=dbHud_1.hasKey;for dK,dw in pairs(va)do if vb(dK)then local dF=iE(dbHud_1.getStringValue(dK))if dF~=nil then dw.set(dF)v7=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then v9(iK())coroutine.yield()v9(bI)else v9(bI)c2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values"c3=5;v7=false end;coroutine.yield()if v7 then c2="Loaded Saved Variables"elseif not f then c2="No Databank Saved Variables Found\nVariables will save to Databank on standing"c3=5 end;if#bp>0 then d9=iJ(d9,bp)end else c2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;aZ=k;g=string.lower(g)cy=q;cA=W;if bw+180<bP then bu=0 end;bw=bP;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c3=7 end;if antigrav and not r then if bv==nil then bv=ch end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d8>0 then d9=iJ(d9,d8)end end;lz="Proceeding to Waypoint"if not a1 or a1<0 then a1=bO.getMaxSpeed()-0.1 end end;local function vc()local function vd(ve,vf)if ve>vf then vf=ve end;local vg,vh=0,0;if a7>0 then vg=a7*0.05 end;if a8>0 then vh=a8*0.05 end;vf=vf*(1-(vg+vh))return vf end;local vi=b.getElementNameById;local vj=at~=0 and au~=0;local vk=_G["atmofueltank_size"]local vl=_G["spacefueltank_size"]local vm=_G["rocketfueltank_size"]for dK in pairs(iN)do local type=b.getElementDisplayNameById(iN[dK])if e3(type,'^.*Atmospheric Engine$')then if e3(tostring(b.getElementTagsById(iN[dK])),'^.*vertical.*$')and b.getElementForwardById(iN[dK])[3]>0 then cO=true end end;if e3(type,'^.*Space Engine$')then cF=true;if e3(tostring(b.getElementTagsById(iN[dK])),'^.*vertical.*$')then local vn=b.getElementForwardById(iN[dK])if vn[3]<0 then vo=true else cE=true end end end;if type=="Landing Gear"then bV=true end;if type=="Dynamic Core Unit"then local px=pv(iN[dK])if px>10000 then gN=110 elseif px>1000 then gN=55 elseif px>150 then gN=27 end end;iO=iO+pv(iN[dK])if vj and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local px=pv(iN[dK])local on=iF(iN[dK])local ve=0;local jN=bL()if type=="Atmospheric Fuel Tank"then local vf=400;local vp=35.03;if px>10000 then vf=51200;vp=5480 elseif px>1300 then vf=6400;vp=988.67 elseif px>150 then vf=1600;vp=182.67 end;ve=on-vp;if a4>0 then vf=vf+vf*a4*0.2 end;vf=vd(ve,vf)local gx=vi(iN[dK])local jL=0;for jM=1,vk do if gx==iE(c["atmofueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vq={iN[dK],string.sub(gx,1,12),vf,vp,ve,jN,jL}ck[#ck+1]=vq end;if type=="Rocket Fuel Tank"then local vf=320;local vp=173.42;if px>65000 then vf=40000;vp=25740 elseif px>6000 then vf=5120;vp=4720 elseif px>700 then vf=640;vp=886.72 end;ve=on-vp;if a6>0 then vf=vf+vf*a6*0.1 end;vf=vd(ve,vf)local gx=vi(iN[dK])local jL=0;for jM=1,vm do if gx==iE(c["rocketfueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vq={iN[dK],string.sub(gx,1,12),vf,vp,ve,jN,jL}cm[#cm+1]=vq end;if type=="Space Fuel Tank"then local vf=600;local vp=35.03;if px>10000 then vf=76800;vp=5480 elseif px>1300 then vf=9600;vp=988.67 elseif px>150 then vf=2400;vp=182.67 end;ve=on-vp;if a5>0 then vf=vf+vf*a5*0.2 end;vf=vd(ve,vf)local gx=vi(iN[dK])local jL=0;for jM=1,vl do if gx==iE(c["spacefueltank_"..jM].getWidgetData()).name then jL=jM;break end end;local vq={iN[dK],string.sub(gx,1,12),vf,vp,ve,jN,jL}cl[#cl+1]=vq end end end;if not cO then b9,a_=false,false end end;local function vr()if gyro~=nil then cj=gyro.isActive()==1 end;if not bB then iH:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ud(1)else ud(0)end;if door and(cf or not cf and ch<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cf or not cf==0 and ch<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;if antigrav then cP=antigrav.isActive()==1;if cP and not r then antigrav.showWidget()end end;if iG()==1 and l then uN.freeze(1)else uN.freeze(0)end;if bV then if ce~=-1 and not cP then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or ce~=-1 and ce-3<_;if ce~=-1 or not cf and cI:len()<50 then b0="Startup"else b0=false end;iH:setTargetGroundAltitude(_)pj=cf end;local function vs()local vt={}local function vu()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vv={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vw,vx in pairs(e)do e[vw][0]=vu()e[vw][0].systemId=vw;vt[vw]={}for vy,kD in pairs(e[vw])do kD.gravity=kD.gravity/9.8;kD.center=vec3(kD.center)kD.name=kD.name[1]kD.noAtmosphericDensityAltitude=kD.atmosphereThickness;kD.spaceEngineMinAltitude=vv[kD.id]or 0.5353125*kD.atmosphereThickness;kD.planetarySystemId=vw;kD.bodyId=kD.id;vt[vw][vy]=kD;if mp==nil or kD.center.x<mp then mp=kD.center.x end;if mo==nil or kD.center.x>mo then mo=kD.center.x end;if ms==nil or kD.center.y<ms then ms=kD.center.y end;if mr==nil or kD.center.y>mr then mr=kD.center.y end;if kD.center and kD.name~="Space"then d3[#d3+1]=kD end end end;ed=di(d,b,c,a,dj,dk,dl,dm,dn)cn=ed(vt)fX=cn[0]co=eX(d,b,c,a,dm,eY)cp=fq(d,b,c,a,dj,dk,dl,dm,dn)cr=fQ(d,b,c,a,dbHud_1,e,fR,fS,bM,dl,dm,fT,fU)kD=cn[0]:closestBody(bO.getWorldPosition())end;vz=false;vA=coroutine.create(function()iH:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v8()coroutine.yield()vc()coroutine.yield()cs=pB(d,b,c,e,vBooster,hover,pC,antigrav,dbHud_1,eY,bM,bN,iG,eT,bL,dk,iH,fR,iI,dm,fU,fT,iJ,dn,iL,iM,pD,iE)vr()coroutine.yield()vs()v6()if iC then cq=iC(d,b,c,a,e,antigrav,hover,shield,warpdrive,iD,eY,bM,dj,iE,bN,iF,iG,eT,bL,dk,iH,fS,fR,gL,iI,dm,fU,gM,fT,iJ,iK,iL,iM,iN,iO)end;if cq then cq.ButtonSetup()end;cu=ub(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,uc,iG,iH,iI,ud,gL,fU,e3,dl,dk,fT,iK,pD)if shield then cv=il(shield,e3,bM)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if uc then uc.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)if shield then c.setTimer("shieldTick",0.0166667)end;if vB then vC.ExtraOnStart()end;fT("start","SU")local function vD()if bG[1]==0 then cs.cmdThrottle(bG[2])else if cg>0 then cA=bG[2]cs.cmdThrottle(1)end end end;lq=string.find(c.getName(),"Emergency")or false;if lq then if ce>-1 and cK<1 and ce-3<_ then c.exit()else if J then vD()else if cg==0 then b0="ECU Braking"elseif ce==-1 then cu.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bG[3]+3>bL()then vD()end end)coroutine.resume(vA)end;function uP.onUpdate()if vz then d:update()if cf and t and cQ then if cQ and bU then cs.cmdThrottle(0)bU=false elseif not cQ and not bU then bQ=0;bU=true end end;if d6 then iH:setThrottleCommand(axisCommandId.longitudinal,d6)d6=nil end;if not cw and p7~=vE then a.setScreen(p7)end;vE=p7;if lq and not J and cg>0 and ce==-1 then cu.landingGear()end;if lq and ce>-1 and cK<1 and ce-3<_ then c.exit()end;if vB then vC.ExtraOnUpdate()end else local ia=coroutine.status(vA)if ia=="suspended"then local dL,ib=coroutine.resume(vA)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then vz=true end end end;function uP.onFlush()if vz then cs.onFlush()if vB then vC.ExtraOnFlush()end end end;function uP.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cg>0 or cg==0 and ch<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cg>0 or cg==0 and ch<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;w=d5;local vF=0;if lq then vF=bL()end;if iH:getAxisCommandType(0)==0 then bG={0,bQ,vF}else bG={1,iH:getTargetSpeed(axisCommandId.longitudinal),vF}end;pD()if nY then nY.activate()end;if z then cs.showWayPoint(kD,cN)end;if cq then a.print(cq.FuelUsed("atmofueltank")..", "..cq.FuelUsed("spacefueltank")..", "..cq.FuelUsed("rocketfueltank"))end;if vB then vC.ExtraOnStop()end;fT("stop","SU")end;function uP.controlStart(ul)if vz then cu.startControl(ul)end end;function uP.controlStop(ul)if vz then cu.stopControl(ul)end end;function uP.controlLoop(ul)if vz then cu.loopControl(ul)end end;function uP.controlInput(r9)if vz then cu.inputTextControl(r9)end end;function uP.radarEnter(dU)if ct then ct.onEnter(dU)end end;function uP.radarLeave(dU)if ct then ct.onLeave(dU)end end;function uP.onTick(vG)if vG=="tenthSecond"then if cs then cs.TenthTick()end;if cq then cq.TenthTick()end elseif vG=="oneSecond"then if cq then cq.OneSecondTick()end elseif vG=="msgTick"then if cq then cq.MsgTick()end elseif vG=="animateTick"then if cq then cq.AnimateTick()end elseif vG=="hudTick"then if cq then cq.hudtick()end elseif vG=="apTick"then if cs then cs.APTick()end elseif vG=="shieldTick"then cv.shieldTick()elseif vG=="tagTick"then cu.tagTick()elseif vG=="contact"then ct.ContactTick()end end;if vB then for dK,dw in pairs(vB)do uP[dK]=dw end end;return uP end;function script.onStart()vC.onStart()end;function script.onOnStop()vC.onStop()end;function script.onTick(vG)vC.onTick(vG)end;function script.onOnFlush()vC.onFlush()end;function script.onOnUpdate()vC.onUpdate()end;function script.onActionStart(ul)vC.controlStart(ul)end;function script.onActionStop(ul)vC.controlStop(ul)end;function script.onActionLoop(ul)vC.controlLoop(ul)end;function script.onInputText(r9)vC.controlInput(r9)end;function script.onEnter(dU)vC.radarEnter(dU)end;function script.onLeave(dU)vC.radarLeave(dU)end;bK(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vC=uM(d,core,unit,e,vBooster,hover,pC,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iD,uc)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
