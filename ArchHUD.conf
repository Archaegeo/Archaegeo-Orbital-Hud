name: ArchHud - Archaegeo v0.003 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.003;f=false;g="virtual joystick"h="archHUD"i="name"j=true;k=true;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J=false;K=true;L={userControlScheme={set=function(M)g=M end,get=function()return g end},soundFolder={set=function(M)h=M end,get=function()return h end},privateFile={set=function(M)i=M end,get=function()return i end},freeLookToggle={set=function(M)j=M end,get=function()return j end},BrakeToggleDefault={set=function(M)k=M end,get=function()return k end},RemoteFreeze={set=function(M)l=M end,get=function()return l end},brightHud={set=function(M)n=M end,get=function()return n end},RemoteHud={set=function(M)m=M end,get=function()return m end},VanillaRockets={set=function(M)o=M end,get=function()return o end},InvertMouse={set=function(M)p=M end,get=function()return p end},autoRollPreference={set=function(M)q=M end,get=function()return q end},ExternalAGG={set=function(M)r=M end,get=function()return r end},ShouldCheckDamage={set=function(M)s=M end,get=function()return s end},AtmoSpeedAssist={set=function(M)t=M end,get=function()return t end},ForceAlignment={set=function(M)u=M end,get=function()return u end},DisplayDeadZone={set=function(M)v=M end,get=function()return v end},showHud={set=function(M)w=M end,get=function()return w end},hideHudOnToggleWidgets={set=function(M)x=M end,get=function()return x end},ShiftShowsRemoteButtons={set=function(M)y=M end,get=function()return y end},SetWaypointOnExit={set=function(M)z=M end,get=function()return z end},AlwaysVSpd={set=function(M)A=M end,get=function()return A end},BarFuelDisplay={set=function(M)B=M end,get=function()return B end},voices={set=function(M)C=M end,get=function()return C end},alerts={set=function(M)D=M end,get=function()return D end},CollisionSystem={set=function(M)E=M end,get=function()return E end},AbandonedRadar={set=function(M)F=M end,get=function()return F end},AutoShieldToggle={set=function(M)G=M end,get=function()return G end},PreventPvP={set=function(M)H=M end,get=function()return H end},DisplayOdometer={set=function(M)I=M end,get=function()return I end},ECUHud={set=function(M)J=M end,get=function()return J end},MaintainOrbit={set=function(M)K=M end,get=function()return K end}}N=35;O=35;P=30;Q=30;R=-30;S=0;T=5000;U=1.2;V=2000;W=1175;X=66000;Y=1000;Z=50;_=0;a0=100000;a1=-1.00;a2=1.0;a3=32;a4=0;a5=0;a6=0;a7=0;a8=0;a9=0;aa=0;ab={YawStallAngle={set=function(M)N=M end,get=function()return N end},PitchStallAngle={set=function(M)O=M end,get=function()return O end},brakeLandingRate={set=function(M)P=M end,get=function()return P end},MaxPitch={set=function(M)Q=M end,get=function()return Q end},ReEntryPitch={set=function(M)R=M end,get=function()return R end},LockPitchTarget={set=function(M)S=M end,get=function()return S end},AutopilotSpaceDistance={set=function(M)T=M end,get=function()return T end},TargetOrbitRadius={set=function(M)U=M end,get=function()return U end},LowOrbitHeight={set=function(M)V=M end,get=function()return V end},AtmoSpeedLimit={set=function(M)W=M end,get=function()return W end},SpaceSpeedLimit={set=function(M)X=M end,get=function()return X end},AutoTakeoffAltitude={set=function(M)Y=M end,get=function()return Y end},TargetHoverHeight={set=function(M)Z=M end,get=function()return Z end},LandingGearGroundHeight={set=function(M)_=M end,get=function()return _ end},ReEntryHeight={set=function(M)a0=M end,get=function()return a0 end},MaxGameVelocity={set=function(M)a1=M end,get=function()return a1 end},AutopilotInterplanetaryThrottle={set=function(M)a2=M end,get=function()return a2 end},warmup={set=function(M)a3=M end,get=function()return a3 end},fuelTankHandlingAtmo={set=function(M)a4=M end,get=function()return a4 end},fuelTankHandlingSpace={set=function(M)a5=M end,get=function()return a5 end},fuelTankHandlingRocket={set=function(M)a6=M end,get=function()return a6 end},ContainerOptimization={set=function(M)a7=M end,get=function()return a7 end},FuelTankOptimization={set=function(M)a8=M end,get=function()return a8 end},AutoShieldPercent={set=function(M)a9=M end,get=function()return a9 end},EmergencyWarp={set=function(M)aa=M end,get=function()return aa end}}ac=1920;ad=1080;ae=400;af=130;ag=224;ah=255;ai=255;aj=0;ak=0;al=960;am=540;an=1300;ao=540;ap=1525;aq=325;ar=550;as=540;at=30;au=700;av=1750;aw=250;ax=1750;ay=350;az=50;aA=250;aB=0;aC=30;aD={ResolutionX={set=function(M)ac=M end,get=function()return ac end},ResolutionY={set=function(M)ad=M end,get=function()return ad end},circleRad={set=function(M)ae=M end,get=function()return ae end},SafeR={set=function(M)af=M end,get=function()return af end},SafeG={set=function(M)ag=M end,get=function()return ag end},SafeB={set=function(M)ah=M end,get=function()return ah end},PvPR={set=function(M)ai=M end,get=function()return ai end},PvPG={set=function(M)aj=M end,get=function()return aj end},PvPB={set=function(M)ak=M end,get=function()return ak end},centerX={set=function(M)al=M end,get=function()return al end},centerY={set=function(M)am=M end,get=function()return am end},throtPosX={set=function(M)an=M end,get=function()return an end},throtPosY={set=function(M)ao=M end,get=function()return ao end},vSpdMeterX={set=function(M)ap=M end,get=function()return ap end},vSpdMeterY={set=function(M)aq=M end,get=function()return aq end},altMeterX={set=function(M)ar=M end,get=function()return ar end},altMeterY={set=function(M)as=M end,get=function()return as end},fuelX={set=function(M)at=M end,get=function()return at end},fuelY={set=function(M)au=M end,get=function()return au end},shieldX={set=function(M)av=M end,get=function()return av end},shieldY={set=function(M)aw=M end,get=function()return aw end},radarX={set=function(M)ax=M end,get=function()return ax end},radarY={set=function(M)ay=M end,get=function()return ay end},DeadZone={set=function(M)az=M end,get=function()return az end},OrbitMapSize={set=function(M)aA=M end,get=function()return aA end},OrbitMapX={set=function(M)aB=M end,get=function()return aB end},OrbitMapY={set=function(M)aC=M end,get=function()return aC end}}aE=5.0;aF=1.0;aG=0.003;aH=0.003;aI=2;aJ=1.5;aK=180;aL=150;aM=0.002;aN=2;aO=0.8;aP=1;aQ=3;aR=1;aS=40;aT=0.0666667;aU=1.0;aV="none"aW="none"aX="none"aY={speedChangeLarge={set=function(M)aE=M end,get=function()return aE end},speedChangeSmall={set=function(M)aF=M end,get=function()return aF end},MouseXSensitivity={set=function(M)aG=M end,get=function()return aG end},MouseYSensitivity={set=function(M)aH=M end,get=function()return aH end},autoRollFactor={set=function(M)aI=M end,get=function()return aI end},rollSpeedFactor={set=function(M)aJ=M end,get=function()return aJ end},autoRollRollThreshold={set=function(M)aK=M end,get=function()return aK end},minRollVelocity={set=function(M)aL=M end,get=function()return aL end},TrajectoryAlignmentStrength={set=function(M)aM=M end,get=function()return aM end},torqueFactor={set=function(M)aN=M end,get=function()return aN end},pitchSpeedFactor={set=function(M)aO=M end,get=function()return aO end},yawSpeedFactor={set=function(M)aP=M end,get=function()return aP end},brakeSpeedFactor={set=function(M)aQ=M end,get=function()return aQ end},brakeFlatFactor={set=function(M)aR=M end,get=function()return aR end},DampingMultiplier={set=function(M)aS=M end,get=function()return aS end},hudTickRate={set=function(M)aT=M end,get=function()return aT end},ExtraEscapeThrust={set=function(M)aU=M end,get=function()return aU end},ExtraLongitudeTags={set=function(M)aV=M end,get=function()return aV end},ExtraLateralTags={set=function(M)aW=M end,get=function()return aW end},ExtraVerticalTags={set=function(M)aX=M end,get=function()return aX end}}aZ=k;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=false;ba=1000;bb=false;bc=false;bd=false;be=false;bf=0;bg="Aligning"bh=0;bi=1;bj="None"bk=nil;bl=0;bm=nil;bn=0.0;bo=0;bp={}bq=false;br=0;bs=0;bt=nil;bu=0;bv=1000;bw=0;bx=false;by=0;bz=false;bA="All"bB=true;bC="Off"bD=0.000;bE={}bF={}bG={}bH=false;bI={VertTakeOff={set=function(M)b9=M end,get=function()return b9 end},VertTakeOffEngine={set=function(M)a_=M end,get=function()return a_ end},SpaceTarget={set=function(M)bx=M end,get=function()return bx end},BrakeToggleStatus={set=function(M)aZ=M end,get=function()return aZ end},BrakeIsOn={set=function(M)b0=M end,get=function()return b0 end},RetrogradeIsOn={set=function(M)b1=M end,get=function()return b1 end},ProgradeIsOn={set=function(M)b2=M end,get=function()return b2 end},Autopilot={set=function(M)b3=M end,get=function()return b3 end},TurnBurn={set=function(M)b4=M end,get=function()return b4 end},AltitudeHold={set=function(M)b5=M end,get=function()return b5 end},BrakeLanding={set=function(M)b6=M end,get=function()return b6 end},Reentry={set=function(M)b8=M end,get=function()return b8 end},AutoTakeoff={set=function(M)b7=M end,get=function()return b7 end},HoldAltitude={set=function(M)ba=M end,get=function()return ba end},AutopilotAccelerating={set=function(M)bb=M end,get=function()return bb end},AutopilotBraking={set=function(M)bd=M end,get=function()return bd end},AutopilotCruising={set=function(M)be=M end,get=function()return be end},AutopilotRealigned={set=function(M)bc=M end,get=function()return bc end},AutopilotEndSpeed={set=function(M)bf=M end,get=function()return bf end},AutopilotStatus={set=function(M)bg=M end,get=function()return bg end},AutopilotPlanetGravity={set=function(M)bh=M end,get=function()return bh end},PrevViewLock={set=function(M)bi=M end,get=function()return bi end},AutopilotTargetName={set=function(M)bj=M end,get=function()return bj end},AutopilotTargetCoords={set=function(M)bk=M end,get=function()return bk end},AutopilotTargetIndex={set=function(M)bl=M end,get=function()return bl end},TotalDistanceTravelled={set=function(M)bn=M end,get=function()return bn end},TotalFlightTime={set=function(M)bo=M end,get=function()return bo end},SavedLocations={set=function(M)bp=M end,get=function()return bp end},VectorToTarget={set=function(M)bq=M end,get=function()return bq end},LocationIndex={set=function(M)br=M end,get=function()return br end},LastMaxBrake={set=function(M)bs=M end,get=function()return bs end},LockPitch={set=function(M)bt=M end,get=function()return bt end},LastMaxBrakeInAtmo={set=function(M)bu=M end,get=function()return bu end},AntigravTargetAltitude={set=function(M)bv=M end,get=function()return bv end},LastStartTime={set=function(M)bw=M end,get=function()return bw end},iphCondition={set=function(M)bA=M end,get=function()return bA end},stablized={set=function(M)bB=M end,get=function()return bB end},UseExtra={set=function(M)bC=M end,get=function()return bC end},SelectedTab={set=function(M)bJ=M end,get=function()return bJ end},saveRoute={set=function(M)bE=M end,get=function()return bE end},apRoute={set=function(M)bF=M end,get=function()return bF end},ecuThrottle={set=function(M)bG=M end,get=function()return bG end},HoverMode={set=function(M)bH=M end,get=function()return bH end}}local function bK(b,c,bL,bM,bN)local a=DUSystem;local bO=DUConstruct;bP=bL()bQ=0;bR=0;bS=false;bT=0;bU=false;bV=false;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;c1=false;c2="empty"c3=3;c4=false;c5=0;c6=0;c7=nil;c8=0;c9=0;ca=0;cb=false;cc=false;cd=false;ce=-1;cf=bN()>0;cg=bN()ch=b.getAltitude()ci=DUConstruct.getMass()cj=nil;ck={}cl={}cm={}cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=nil;cv=nil;cw=false;cx=false;cy=q;cz=false;cA=W;cB=nil;cC=0;cD=false;cE=false;cF=false;cG=vec3(bO.getWorldOrientationForward())cH=vec3(bO.getWorldOrientationRight())cI=vec3(bO.getVelocity())cJ=vec3(bO.getWorldVelocity())cK=vec3(cJ):len()cL=vec3(b.getWorldVertical())cM=-cL:dot(cJ)cN=vec3(bO.getWorldPosition())cO=false;cP=false;cQ=true;cR=0;cS=0;cT={}cU=false;cV=50000;cW=nil;cX=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;cY=false;cZ=nil;c_=false;d0=0;d1=nil;d2=nil;d3={}d4=90;d5=w;d6=nil;d7=nil;d8={}d9={}da=false;db=nil;dc=0;dd=false;de=bO.getMaxSpeed()if shield then df=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dg(dh)a.print(bP..": "..dh)end;local function di(d,b,c,a,dj,dk,dl,dm,dn)local function dp(dq)return type(dq)=='number'end;local function dr(dq)return type(dl(dq))=='number'end;local function ds(dt)return type(dt)=='table'end;local function du(a)return type(a)=='string'end;local function dv(dw)return ds(dw)and dp(dw.x and dw.y and dw.z)end;local function dx(dy)return ds(dy)and dp(dy.latitude and dy.longitude and dy.altitude and dy.id and dy.systemId)end;local dz=math.pi/180;local dA=180/math.pi;local dB=1e-10;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local utils=utils;local vec3=vec3;local function dE(dq)local dF=string.gsub(string.reverse(dj('%.4f',dq)),'^0*%.?','')return dF==''and'0'or string.reverse(dF)end;local function dG(dH)if dv(dH)then return dj('{x=%.3f,y=%.3f,z=%.3f}',dH.x,dH.y,dH.z)end;if ds(dH)and not getmetatable(dH)then local dI={}local dJ=next(dH)if type(dJ)=='nil'or dJ==1 then dI=dH else for dK,dw in pairs(dH)do local dL=dG(dw)if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end end;return dj('{%s}',table.concat(dI,','))end;if du(dH)then return dj("'%s'",dH:gsub("'",[[\']]))end;return tostring(dH)end;local dM={}dM.__index=dM;dM.__tostring=function(dH,dN)local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)local dI={}for dP,dK in ipairs(dO)do local dL=dG(dH[dK])if type(dK)=='number'then table.insert(dI,dj('[%s]=%s',dK,dL))else table.insert(dI,dj('%s=%s',dK,dL))end end;if dN then return dj('%s%s',dN,table.concat(dI,',\n'..dN))end;return dj('{%s}',table.concat(dI,','))end;dM.__eq=function(dQ,dR)return dQ.systemId==dR.systemId and dQ.id==dR.id and dn(dQ.radius,dR.radius)and dn(dQ.center.x,dR.center.x)and dn(dQ.center.y,dR.center.y)and dn(dQ.center.z,dR.center.z)and dn(dQ.GM,dR.GM)end;local function dS(dT,dU,dV,dW,dX)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(dV),'Argument 3 (radius) must be a number:'..type(dV))assert(ds(dW),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dW))assert(dr(dX),'Argument 5 (GM) must be a number:'..type(dX))return setmetatable({systemId=dl(dT),id=dl(dU),radius=dl(dV),center=vec3(dW),GM=dl(dX)},dM)end;local dY={}dY.__index=dY;dY.__tostring=function(dg)return dj('::pos{%d,%d,%s,%s,%s}',dg.systemId,dg.id,dE(dg.latitude*dA),dE(dg.longitude*dA),dE(dg.altitude))end;dY.__eq=function(dQ,dR)return dQ.id==dR.id and dQ.systemId==dR.systemId and dn(dQ.latitude,dR.latitude)and dn(dQ.altitude,dR.altitude)and(dn(dQ.longitude,dR.longitude)or dn(dQ.latitude,math.pi/2)or dn(dQ.latitude,-math.pi/2))end;local function dZ(d_,dU,e0,e1,e2)local dT=d_;if du(d_)and not e1 and not e2 and not dU and not e0 then dT,dU,e0,e1,e2=e3(d_,dD)assert(dT,'Argument 1 (position string) is malformed.')else assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(e0),'Argument 3 (latitude) must be in degrees:'..type(e0))assert(dr(e1),'Argument 4 (longitude) must be in degrees:'..type(e1))assert(dr(e2),'Argument 5 (altitude) must be in meters:'..type(e2))end;dT=dl(dT)dU=dl(dU)e0=dl(e0)e1=dl(e1)e2=dl(e2)if dU==0 then return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=dU,systemId=dT},dY)end;return setmetatable({latitude=dz*dk(e0,-90,90),longitude=dz*(e1%360),altitude=e2,id=dU,systemId=dT},dY)end;local e4={}e4.__index=e4;e4.__tostring=function(dH,dN)local e5=dN and dN..'  'local e6={}local dO={}for dK in pairs(dH)do table.insert(dO,dK)end;table.sort(dO)for dP,e7 in ipairs(dO)do e8=dH[e7]local e9=dM.__tostring(e8,e5)if dN then table.insert(e6,dj('[%s]={\n%s\n%s}',e7,e9,dN))else table.insert(e6,dj('  [%s]=%s',e7,e9))end end;if dN then return dj('\n%s%s%s',dN,table.concat(e6,',\n'..dN),dN)end;return dj('{\n%s\n}',table.concat(e6,',\n'))end;local function ea(eb)local e={}local pid;for dP,dw in pairs(eb)do local dU=dw.planetarySystemId;if type(dU)~='number'then error('Invalid planetary s ID: '..tostring(dU))elseif pid and dU~=pid then error('Mistringmatch planetary s IDs: '..dU..' and '..pid)end;local ec=dw.bodyId;if type(ec)~='number'then error('Invalid body ID: '..tostring(ec))elseif e[ec]then error('Duplicate body ID: '..tostring(ec))end;setmetatable(dw.center,getmetatable(vec3.unit_x))e[ec]=setmetatable(dw,dM)pid=dU end;return setmetatable(e,e4)end;ed={}local function ee(eb)return setmetatable({galaxyAtlas=eb or{}},ed)end;ed.__index=function(dt,M)if type(M)=='number'then local a=dt.galaxyAtlas[M]return ea(a)end;return rawget(ed,M)end;ed.__pairs=function(dH)return function(dt,dK)local ef,eg=next(dt,dK)return ef,eg and ea(eg)end,dH.galaxyAtlas,nil end;ed.__tostring=function(dH)local eh={}for dP,ei in pairs(dH or{})do local ej=ei:getPlanetarySystemId()local ek=e4.__tostring(ei,'    ')table.insert(eh,dj('  [%s]={%s\n  }',ej,ek))end;return dj('{\n%s\n}\n',table.concat(eh,',\n'))end;ed.BodyParameters=dS;ed.MapPosition=dZ;ed.PlanetarySystem=ea;function ed.createBodyParameters(dT,dU,el,em,en,eo,ep)assert(dr(dT),'Argument 1 (systemId) must be a number:'..type(dT))assert(dr(dU),'Argument 2 (id) must be a number:'..type(dU))assert(dr(el),'Argument 3 (surfaceArea) must be a number:'..type(el))assert(ds(em),'Argument 4 (aPosition) must be an array or vec3:'..type(em))assert(ds(en),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(en))assert(dr(eo),'Argument 6 (altitude) must be in meters:'..type(eo))assert(dr(ep),'Argument 7 (gravityAtPosition) must be number:'..type(ep))local dV=dm(el/4/math.pi)local ca=dV+eo;local eq=vec3(em)+ca*vec3(en)local dX=ep*ca*ca;return dS(dT,dU,dV,eq,dX)end;ed.isMapPosition=dx;function ed:getPlanetarySystem(d_)if M==nil then M=0 end;if eg==nil then eg=0 end;local dT=d_;if dx(d_)then dT=d_.systemId end;if type(dT)=='number'then local a=self.galaxyAtlas[M]if a then if getmetatable(eg)~=e4 then a=ea(a)end;return a end end end;function e4:sizeCalculator(er)return 1.05*er.radius end;function e4:castIntersections(es,et,eu,ev,ew,ex)local ey={}if ew then for dP,er in pairs(ew)do table.insert(ey,er)end else ey=d3 end;if not ex then table.sort(ey,function(ez,eA)local eB=ez.center;local eC=eA.center;return(eB.x-es.x)^2+(eB.y-es.y)^2+(eB.z-es.z)^2<(eC.x-es.x)^2+(eC.y-es.y)^2+(eC.z-es.z)^2 end)end;local eD=et:normalize()for dP,er in ipairs(ey)do local eE=er.center-es;local dV;if eu then dV=eu(er)else dV=self:sizeCalculator(er)end;local eF=eE:dot(eD)local eG=eF^2-(eE:len2()-dV^2)if eG>=0 then local eH=dm(eG)local eI=eF+eH;local eJ=eF-eH;if eJ>0 then return er,eI,eJ elseif eI>0 then return er,eI,nil end end end;return nil,nil,nil end;function e4:closestBody(eK)assert(type(eK)=='table','Invalid coordinates.')local eL,er;local eM=vec3(eK)for dP,eN in pairs(self)do local eO=(eN.center-eM):len2()if(not er or eO<eL)and eN.name~="Space"then er=eN;eL=eO end end;return er end;function e4:convertToBodyIdAndWorldCoordinates(d_)local eP=d_;if du(d_)then eP=dZ(d_)end;if eP.id==0 then return 0,vec3(eP.latitude,eP.longitude,eP.altitude)end;local eN=self:getBodyParameters(eP)if eN then return eP.id,eN:convertToWorldCoordinates(eP)end end;function e4:getBodyParameters(d_)local dU=d_;if dx(d_)then dU=d_.id end;assert(dr(dU),'Argument 1 (id) must be a number:'..type(dU))return self[dU]end;function e4:getPlanetarySystemId()local dP,dw=next(self)return dw and dw.systemId end;function dM:convertToMapPosition(dW)assert(ds(dW),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dW))local eQ=vec3(dW)if self.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=self.systemId},dY)end;local eR=eQ-self.center;local ca=eR:len()local e2=ca-self.radius;local e0=0;local e1=0;if not dn(ca,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/ca)end;return setmetatable({latitude=e0,longitude=e1,altitude=e2,id=self.id,systemId=self.systemId},dY)end;function dM:convertToWorldCoordinates(d_)local eP=du(d_)and dZ(d_)or d_;if eP.id==0 then return vec3(eP.latitude,eP.longitude,eP.altitude)end;assert(dx(eP),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eP.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eP.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eU=math.cos(eP.latitude)return self.center+(self.radius+eP.altitude)*vec3(eU*math.cos(eP.longitude),eU*math.sin(eP.longitude),math.sin(eP.latitude))end;function dM:getAltitude(dW)return(vec3(dW)-self.center):len()-self.radius end;function dM:getDistance(dW)return(vec3(dW)-self.center):len()end;function dM:getGravity(dW)local eV=self.center-vec3(dW)local eW=eV:len2()return self.GM/eW*eV/dm(eW)end;return setmetatable(ed,{__call=function(dP,...)return ee(...)end})end;local function eX(d,b,c,a,dm,eY)local co={}local bO=100000000/3600;local eZ=bO*bO;local e_=100;function co.computeAccelerationTime(f0,f1,f2)local f3=bO*math.asin(f0/bO)return(bO*math.asin(f2/bO)-f3)/f1 end;function co.computeDistanceAndTime(f0,f2,f4,f5,f6,f7)f6=f6 or 0;f7=f7 or 0;local f8=f0<=f2;local f9=f5*(f8 and 1 or-1)/f4;local fa=-f7/f4;local fb=f9+fa;if f8 and fb<=0 or not f8 and fb>=0 then return-1,-1 end;local fc,fd=0,0;if f9~=0 and f6>0 then local f3=math.asin(f0/bO)local fe=math.pi*(f9/2+fa)local ff=f9*f6;local fg=bO*math.pi;local dw=function(dt)local fh=(fe*dt-ff*math.sin(math.pi*dt/2/f6)+fg*f3)/fg;local fi=math.tan(fh)return bO*fi/dm(fi*fi+1)end;local fj=f8 and function(a)return a>=f2 end or function(a)return a<=f2 end;fd=2*f6;if fj(dw(fd))then local fk=0;while eY(fd-fk)>0.5 do local dt=(fd+fk)/2;if fj(dw(dt))then fd=dt else fk=dt end end end;local fl=f0;local fm=fd/e_;for fn=1,e_ do local fo=dw(fn*fm)fc=fc+(fo+fl)*fm/2;fl=fo end;if fd<2*f6 then return fc,fd end;f0=fl end;local f3=bO*math.asin(f0/bO)local bP=(bO*math.asin(f2/bO)-f3)/fb;local fp=eZ*math.cos(f3/bO)/fb;local ca=fp-eZ*math.cos((fb*bP+f3)/bO)/fb;return ca+fc,bP+fd end;function co.computeTravelTime(f0,f1,ca)if ca==0 then return 0 end;if f1>0 then local f3=bO*math.asin(f0/bO)local fp=eZ*math.cos(f3/bO)/f1;return(bO*math.acos(f1*(fp-ca)/eZ)-f3)/f1 end;if f0==0 then return-1 end;assert(f0>0,'Acceleration and initial speed are both zero.')return ca/f0 end;return co end;local function fq(d,b,c,a,dj,dk,dl,dm,dn)local vec3=vec3;local di=di(d,b,c,a,dj,dk,dl,dm,dn)local function du(a)return type(a)=='string'end;local function ds(dt)return type(dt)=='table'end;fr={}fr.__index=fr;function fr:escapeAndOrbitalSpeed(e2)assert(self.body)local ca=e2+self.body.radius;if not dn(ca,0)then local fs=dm(self.body.GM/ca)return dm(2)*fs,fs end;return nil,nil end;function fr:orbitalParameters(d_,ft)assert(self.body)assert(ds(d_)or du(d_))assert(ds(ft))local fu=(du(d_)or di.isMapPosition(d_))and self.body:convertToWorldCoordinates(d_)or vec3(d_)local dw=vec3(ft)local fv=fu-self.body.center;local fw=dw:len2()local fx=fv:len()local fy=self.body.GM;local fz=((fw-fy/fx)*fv-fv:dot(dw)*dw)/fy;local eB=fy/(2*fy/fx-fw)local fA=fz:len()local eD=fz:normalize()local fB=eB*(1-fA)local fC=eB*(1+fA)local fD=fB*eD+self.body.center;local fE=fA<=1 and-fC*eD+self.body.center or nil;local fF=dm(eB*fy*(1-fA*fA))local fG=fE and 2*math.pi*dm(eB^3/fy)local fH=math.acos(fz:dot(fv)/(fA*fx))if fv:dot(dw)<0 then fH=-(fH-2*math.pi)end;local fI=math.acos((math.cos(fH)+fA)/(1+fA*math.cos(fH)))local fJ=fI;if fJ<0 then fJ=fJ+2*math.pi end;local fK=fJ-fA*math.sin(fJ)local fL=0;local fM=0;local fN=0;if fG~=nil then fL=fK/(2*math.pi/fG)fM=fG-fL;fN=fM+fG/2;if fH-math.pi>0 then fM=fL;fN=fM+fG/2 end;if fN>fG then fN=fN-fG end end;return{periapsis={position=fD,speed=fF/fB,circularOrbitSpeed=dm(fy/fB),altitude=fB-self.body.radius},apoapsis=fE and{position=fE,speed=fF/fC,circularOrbitSpeed=dm(fy/fC),altitude=fC-self.body.radius},currentVelocity=dw,currentPosition=fu,eccentricity=fA,period=fG,eccentricAnomaly=fI,meanAnomaly=fK,timeToPeriapsis=fM,timeToApoapsis=fN,trueAnomaly=fH}end;local function fO(fP)local eN=di.BodyParameters(fP.systemId,fP.id,fP.radius,fP.center,fP.GM)return setmetatable({body=eN},fr)end;return setmetatable(fr,{__call=function(dP,...)return fO(...)end})end;local function fQ(d,b,c,a,dbHud_1,e,fR,fS,bM,dl,dm,fT,fU)local function fV(fW)local dg=fX:closestBody(fW)if(fW-dg.center):len()>dg.radius+dg.noAtmosphericDensityAltitude then dg=e[0][0]end;return dg end;local function fY()local function fZ(f_,g0)return f_.name<g0.name end;cT={}for dK,dw in pairs(e[0])do cT[#cT+1]={name=dw.name,index=dK}end;table.sort(cT,fZ)end;local function g1(g2,g3)if not g3 then g3=g4.name end;for dK,dw in pairs(g2)do if dw.name and dw.name==g3 then return dK end end;return-1 end;local function g5()d0=bl;if bl==0 then bj="None"c7=nil;g4=nil;return true end;local g6=cT[bl].index;local g7=e[0][g6]if g7.center then bj=g7.name;c7=cn[0][g6]if g4~=nil then if cg==0 then if fR(g8,g9)~=1 then fS(g8,g9)end;if fR(ga,gb)~=1 then fS(ga,gb)end;if fR(gc,gd)~=1 then fS(gc,gd)end;if fR(ge,gf)~=1 then fS(ge,gf)end;if fR(gg,gh)~=1 then fS(gg,gh)end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end;if fR(gm,gn)~=1 then fS(gm,gn)end end;g4=nil else g4=g7;for dP,dw in pairs(cn[0])do if dw.name==g4.planetname then c7=dw;bj=g4.name;break end end;if fR(gi,gj)~=1 then fS(gi,gj)end;if fR(gk,gl)~=1 then fS(gk,gl)end end;if g4==nil then bk=vec3(c7.center)else bk=g4.position end;if c7.planetname~="Space"then if c7.hasAtmosphere then go=bM(c7.radius*(U-1)+c7.noAtmosphericDensityAltitude)else go=bM(c7.radius*(U-1)+c7.surfaceMaxAltitude)end else go=T end;if g4~=nil and g4.planetname=="Space"then bf=0 else dP,bf=cp(c7):escapeAndOrbitalSpeed(go)end;bh=0;bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"return true end;local function gp(gq)if not b3 and not bq and not cc and not bz and not b8 and not cd then if gq==nil then bl=bl+1;if bl>#cT then bl=0 end else bl=bl-1;if bl<0 then bl=#cT end end;if bl==0 then g5()else local g6=cT[bl].index;local g7=e[0][g6]if g7 and(g7~=nil and g7.name=="Space"or bA=="Custom Only"and g7.center or bA=="No Moons-Asteroids"and(string.find(g7.name,"Moon")~=nil or string.find(g7.name,"Asteroid")~=nil))then if gq==nil then gp()else gp(1)end else g5()end end else c2="Disengage autopilot before changing Interplanetary Helper"fT("iph","AP")end end;local function gr()local function gs(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=-1;gv=g1(e[0])if gv>-1 then table.remove(e[0],gv)end;gv=-1;gv=g1(gu)if gv~=-1 then c2=g4.name.." saved location cleared"table.remove(gu,gv)end;gp()fY()return gu end;if string.sub(bj,1,1)=="*"then d8=gs(true)else bp=gs(false)end end;local function gw(gx,fW,gy,gz)local function gA(gt)if gt then gu=d8 else gu=bp end;if dbHud_1 or gy or gt then local dg=fV(fW)local gB={position=fW,name=gx,planetname=dg.name,gravity=b.getGravityIntensity(),safe=gz}if not gy then gu[#gu+1]=gB else for dK,dw in pairs(e[0])do if dw.name and gx==dw.name then table.remove(e[0],dK)end end end;table.insert(e[0],gB)fY()g5()c2="Location saved as "..gx.."("..dg.name..")"return gu else c2="Databank must be installed to save permanent locations"end end;if string.sub(gx,1,1)=="*"then d8=gA(true)else bp=gA(false)end end;local gC={}function gC.UpdateAtlasLocationsList()fY()end;function gC.UpdateAutopilotTarget()g5()end;function gC.adjustAutopilotTargetIndex(gq)gp(gq)end;function gC.findAtlasIndex(g2,g3)return g1(g2,g3)end;function gC.UpdatePosition(gD,gE,gF)local function gG(gt)local gu;if gt then gu=d8 else gu=bp end;local gv=g1(gu)if gv~=-1 then if gD~=nil then if gt then gD="*"..gD end;gu[gv].name=gD;bl=bl-1;gp()elseif gF~=nil then if gF then local gH=ch;if gH<1000 then gH=1000 end;gu[gv].agg=fU(gH,0)c2=gu[gv].name.." AGG Altitude:"..gu[gv].agg.." saved ("..gu[gv].planetname..")"return elseif gF==false then gu[gv].agg=nil;c2=gu[gv].name.." AGG Altitude cleared ("..gu[gv].planetname..")"return end else local gI=gu[gv]if gE then gI.heading=cH:cross(cL)*5000;c2=gu[gv].name.." heading saved ("..gu[gv].planetname..")"return elseif gE==false then gI.heading=nil;c2=gu[gv].name.." heading cleared ("..gu[gv].planetname..")"return end;gI.gravity=b.getGravityIntensity()gI.position=cN;gI.safe=true end;c2=gu[gv].name.." position updated ("..gu[gv].planetname..")"else c2="Name Not Found"end end;if string.sub(bj,1,1)=="*"then gG(true)else gG(false)end end;function gC.AddNewLocation(gx,fW,gy,gz)gw(gx,fW,gy,gz)end;function gC.ClearCurrentPosition()gr()end;for dK,dw in pairs(d9)do table.insert(e[0],dw)end;if gJ then for dK,dw in pairs(gJ)do gC[dK]=dw end end;fY()if bl>#cT then bl=0 end;gC.UpdateAutopilotTarget()return gC end;local function gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)local gO={}local gP={}local gQ={XS=13,S=27,M=55,L=110,XL=221}local gR={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gS={}local gT=0;local gU;local gV;local gW=0;local gX;local gY={gX}local gZ="Atmo"local g_;local h0;local h1=0;local h2={}local h3;local h4=0;local h5=table.insert;local h6=-4;local h7={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local h8,h9;local ha,hb;local hc;local hd;local he;local hf;local hg;local hh;local hi;local function hj()if hk~=nil and h1==0 then gL(hk)a.destroyWidget(h8)a.destroyData(ha)h8,ha,hk=nil,nil,nil;if h0~=nil then gL(h0)a.destroyWidget(h9)a.destroyData(hb)h0,h9,hb=nil,nil,nil end else if h1==1 then gL(hk)hk=nil;h0=a.createWidgetPanel("PeriWinkle")h9=a.createWidget(h0,'periscope')hb=gX.getWidgetDataId()a.addDataToWidget(hb,h9)end;if hk==nil and gT>0 then hk=a.createWidgetPanel(gZ)h8=a.createWidget(hk,'radar')ha=gX.getWidgetDataId()a.addDataToWidget(ha,h8)end;h1=0 end end;local function hl()local function hm(hn,ho,hp,hq,hr,hs,ht,hu)ho,hq,hs,hu=vec3(ho),vec3(hq),vec3(hs),vec3(hu)local hv,hw,hx=hn*hn,hp*hp,hr*hr;local fw=hq-ho;local hy=fw:normalize()local hz=fw:len()local hA=hs-ho;local hB=(hA-hA:project_on(hy)):normalize()local hC,hD=hA:dot(hy),hA:dot(hB)local hE=hC*hC+hD*hD;local hF=hy:cross(hB)local hG=(hv-hw+hz*hz)/(2*hz)local hH=(hv-hx+hE-2*hC*hG)/(2*hD)local dy=hv-hG^2-hH^2;local hI=dm(dy)local hJ=ho+hy*hG+hB*hH+hF*hI;local hK=ho+hy*hG+hB*hH-hF*hI;if eY((hu-hJ):len()-ht)<eY((hu-hK):len()-ht)then return hJ else return hK end end;local function hL(hM,fx,hN)local hO=hM.pts;local gv=#hO;local hP=hM.ref;if gv>3 then local hQ,hR,hS,hT=hO[gv],hO[gv-1],hO[gv-2],hO[gv-3]hM.ref=hN;local fu=hm(hQ[1],hQ[2],hR[1],hR[2],hS[1],hS[2],hT[1],hT[2])local hG,hH,hI=fu.x,fu.y,fu.z;if hG==hG and hH==hH and hI==hI then hG=hG+hP[1]hH=hH+hP[2]hI=hI+hP[3]local hU=vec3(hG,hH,hI)hM.center=hU;if hM.lastPos then if(hM.lastPos-hU):len()<2 then local hV=(hU-vec3(hN)):len()if eY(hV-fx)<10 then hM.skipCalc=true end end end;hM.lastPos=hU end;hM.pts={}else local hW={hN[1]-hP[1],hN[2]-hP[2],hN[3]-hP[3]}hO[gv+1]={fx,hW}end end;if radar_1 or radar_2 then ct.assignRadar()end;if gX then if#h3>0 then local hX,hY=0,0;local hZ=cK*10;local cX=cX;gW,gV=0,0;gP={}for dP,dw in pairs(h3)do local ca=hg(dw)if ca>0.0 then if hc(dw)==1 then h5(gP,dw)end;if not cU and warpdrive and ca<aa and warpdrive.getStatus()==15 then c2="INITIATING WARP"c3=7;warpdrive.initiate()end;local h_=F and he(dw)==1;if E or h_ then local i0=hh(dw)local i1=gQ[i0]local i2=hd(dw)if h_ or ca<hZ and(i1>27 or i2==4 or i2==6)then gW=gW+1;local hN={cN["x"],cN["y"],cN["z"]}local hM=h2[dw]if hM==nil then i1=i1+gN;h2[dw]={pts={},ref=hN,name=hf(dw),i=0,radius=i1,skipCalc=false}hM=h2[dw]end;if not hM.skipCalc then if h_ or i2==4 or i2==6 then hM.center=vec3(hi(dw))hM.skipCalc=true else hL(hM,ca,hN)hY=hY+1 end;if h_ and not hM.abandoned then local bP=a.getArkTime()if h4+5<bP then h4=bP;fT("abRdr","RD")end;a.print("Abandoned Construct: "..hM.name.." ("..i0 .." "..gR[i2]..") at ::pos{0,0,"..hM.center.x..","..hM.center.y..","..hM.center.z.."}")c2="Abandoned Radar Contact ("..i0 .." "..gR[i2]..") detected"hM.abandoned=true end else h5(gS,hM)end end;hX=hX+1;if hX>300 or hY>30 then coroutine.yield()hX,hY=0,0 end end end end;gV=#gS;if gV>0 and(cK>20 or b6)then local er,i3,i4,i5;local i6=0;local i7=cn:getPlanetarySystem(0)i5=cJ:normalize()while i6<gV do coroutine.yield()local i8={table.unpack(gS,i6,math.min(i6+75,gV))}er,i3,i4=i7:castIntersections(cN,i5,nil,nil,i8,true)if er and i4 then cZ={er,i3,i4}break end;i6=i6+75 end;if not er then cZ=nil end else cZ=nil end;gS={}gU=gX.getTargetId()end end end;local function i9()if gX then gZ="Atmo"if string.find(gX.getName(),"Space")then gZ="Space"end end end;function gO.pickType()i9()end;function gO.assignRadar()if radar_2 and h6~=1 then if h6==-1 then if gX==radar_2 then gX=radar_1 else gX=radar_2 end end;gY={gX}hc=gX.hasMatchingTransponder;hd=gX.getConstructKind;he=gX.isConstructAbandoned;hf=gX.getConstructName;hg=gX.getConstructDistance;hh=gX.getConstructCoreSize;hi=gX.getConstructWorldPos;h3=gX.getConstructIds()i9()else h3=gX.getConstructIds()end;h6=gX.getOperationalState()end;function gO.UpdateRadar()local ia=coroutine.status(g_)if ia=="suspended"then local dL,ib=coroutine.resume(g_)if ib then a.print("ERROR UPDATE RADAR: "..ib)end elseif ia=="dead"then g_=coroutine.create(hl)local dL,ib=coroutine.resume(g_)end end;function gO.GetRadarHud(ic,id,ax,ay)local ie,dh;local dC=gV or 0;gT=#h3;if gT>0 then if E then dh=dC.."/"..gW.." Known/InRange : "..gT.." Total"else dh="Radar Contacts: "..gT end;ie=gM(ax,ay,dh,"pbright txtbig txtmid")if#gP>0 then ie=ie..gM(ic,id,"Friendlies In Range","pbright txtbig txtmid")for dK,dw in pairs(gP)do id=id+20;ie=ie..gM(ic,id,gX.getConstructName(dw),"pdim txtmid")end end;if gU==nil and h0==nil then h1=1;ct.ToggleRadarPanel()end;if gU~=nil and h0~=nil then ct.ToggleRadarPanel()end;if hk==nil then if w then ct.ToggleRadarPanel()end end else if h6~=1 then ie=gM(ax,ay,gZ.." Radar: "..h7[h6],"pbright txtbig txtmid")else ie=gM(ax,ay,"Radar: No "..gZ.." Contacts","pbright txtbig txtmid")end;if hk~=nil then h1=0;ct.ToggleRadarPanel()end end;return ie end;function gO.GetClosestName(gx)if gX then local ig=gX.getConstructName(gX.getConstructIds()[1])if ig then gx=gx.." "..ig end end;return gx end;function gO.ToggleRadarPanel()hj()end;function gO.ContactTick()if not ih then ih=0 end;if bP>ih+10 then c2="Radar Contact"fT("rdrCon","RC")ih=bP end;c.stopTimer("contact")end;function gO.onEnter(dU)if gX and not cf and not cU then c.setTimer("contact",0.1)end end;function gO.onLeave(dU)if gX and E then if#h2>650 then dU=tostring(dU)h2[dU]=nil end end end;local function ii()gX=nil;if radar_2 and radar_2.getOperationalState()==1 then gX=radar_2 else gX=radar_1 end;h6=gX.getOperationalState()hc=gX.hasMatchingTransponder;hd=gX.getConstructKind;he=gX.isConstructAbandoned;hf=gX.getConstructName;hg=gX.getConstructDistance;hh=gX.getConstructCoreSize;hi=gX.getConstructWorldPos;gY={gX}h3=gX.getConstructIds()i9()g_=coroutine.create(hl)if ij then for dK,dw in pairs(ij)do gO[dK]=dw end end end;ii()return gO end;local function ik(shield,e3,bM)local il={}local im=shield.getResistancesCooldown()local function io()local ip=shield.isActive()if G then if not cU and ip==0 and shield.isVenting()~=1 then shield.toggle()elseif cU and ip==1 then shield.toggle()end end end;local function iq()local ir=shield.getStressRatioRaw()local is=0.5999;if ir[1]==0.0 and ir[2]==0.0 and ir[3]==0.0 and ir[4]==0.0 then return end;local it=shield.setResistances(is*ir[1],is*ir[2],is*ir[3],is*ir[4])if it==1 then c2="Shield Resistances updated"else c2="Value Exceeded. Failed to update Shield Resistances"end end;function il.shieldTick()df=bM(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())io()im=shield.getResistancesCooldown()if im==0 and df<a9 then iq()end end;function il.setResist(iu)if not shield then c2="No shield found"return elseif iu==nil or im>0 then c2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD=dC..', '..dC..', '..dC..', '..dC;local iv,iw,ix,iy=e3(iu,dD)if iy==nil or iv+iw+ix+iy>0.6 then c2="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(iv,iw,ix,iy)==1 then c2="Shield Resistances set"else c2="Resistance setting failed."end end;function il.ventShield()local iz=shield.getVentingCooldown()if iz>0 then c2="Cannot vent again for "..iz.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()c2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c2="Shields already at max hitpoints"end end;if iA then for dK,dw in pairs(iA)do il[dK]=dw end end;return il end;local function iB(d,b,c,a,e,antigrav,hover,shield,warpdrive,iC,eY,bM,dj,iD,bN,iE,iF,eT,bL,dk,iG,fS,fR,gL,iH,dm,fU,gM,fT,iI,iJ,iK,iL,iM,iN)local bO=DUConstruct;local iO=9.80665;local iP={}local iQ={}local iR={}local iS={}local iT=nil;local iU=nil;local iV=nil;local iW=false;local iX="none"local iY=""local iZ=55;local i_=0;local j0=0;local j1=nil;local j2=af;local j3=ag;local j4=ah;local j5=[[rgb(]]..bM(j2+0.5)..","..bM(j3+0.5)..","..bM(j4+0.5)..[[)]]local j6=[[rgb(]]..bM(j2*0.9+0.5)..","..bM(j3*0.9+0.5)..","..bM(j4*0.9+0.5)..[[)]]local j7=0;local j8=0;local j9=""local ja=bL()local jb=false;local jc=false;local gX=false;local function jd(dw)if ac==1920 then return dw else return fU(ac*dw/1920,0)end end;local function je(dw)if ad==1080 then return dw else return fU(ad*dw/1080,0)end end;local function jf()return iH()==0 and g~="keyboard"and iF()==0 end;local function jg()local jh="TRAVEL"if not cQ then jh="CRUISE"end;if b3 then jh="AUTOPILOT"end;return jh end;local ie=""local ji=""local jj=""local jk=1;local jl=2;local jm=3;local jn=4;local jo=5;local jp=6;local jq=7;local jr=""local js=0;local jt=15.0*aT;local ju={}local jv={}local jw={}local jx={}local jy={}local jz={}local jA={}jA["atmofueltank"],jA["spacefueltank"],jA["rocketfueltank"]=0,0,0;local jB=0;local function jC(hG,jD,jE,jF,jG,jH)local jI=jB;local jJ=jB+5;if not B then jJ=jJ+5 end;if iF()==1 and not m then jI=jI-50;jJ=jJ-50 end;if jE=="ATMO"then jr="atmofueltank"elseif jE=="SPACE"then jr="spacefueltank"else jr="rocketfueltank"end;js=_G[jr.."_size"]if#jF>0 then for M=1,#jF do local gx=jF[M][jl]local jK=jF[M][jq]for jL=1,js do if jF[M][jl]==iD(c[jr.."_"..jL].getWidgetData()).name then jK=jL;break end end;local jM=bL()if jG[M]==nil or jH[M]==nil or jM-jF[M][jp]>jt then local jN;local jO=0;jO=iE(jF[M][jk])-jF[M][jn]jN=jF[M][jo]if jN>jO then jA[jr]=jA[jr]+jN-jO end;if jK~=0 then local jP=iD(c[jr.."_"..jK].getWidgetData())jH[M]=jP.percentage;jG[M]=jP.timeLeft;if jG[M]=="n/a"then jG[M]=0 end else jH[M]=bM(0.5+jO*100/jF[M][jm])if not jG[M]then jG[M]=0 end;if jN>jO then jG[M]=bM(0.5+jO/((jN-jO)/(jM-jF[M][jp])))end end;jF[M][jp]=jM;jF[M][jo]=jO end;if gx==jD then gx=dj("%s %d",jE,M)end;if jK==0 then gx=gx.." *"end;local jQ;jQ=iL(jG[M])if jG[M]==0 or jQ==">1y"then jQ=""end;if jH[M]~=nil then local jR=bM(jH[M]*2.55)local jS=dj("rgb(%d,%d,%d)",255-jR,jR,0)local jT=""if jQ~=""and jG[M]<120 or jH[M]<5 then jT="red "end;local jU=dj("rgb(%d,%d,%d)",dk(bM((255-jR)/2.55),50,100),dk(bM(jR/2.55),0,50),50)local jV="rgb(196,0,255)"if jE=="ATMO"then jV="rgb(0,188,255)"elseif jE=="SPACE"then jV="rgb(239,255,0)"end;local jW=false;if jX~=jV then jW=true end;jX=jV;if B then if jW then jI=jI-5;jJ=jJ-5 end;ji=ji..dj([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jU,jV,hG,jJ,jS,bM(jH[M]*1.7+0.5)-2,hG+1,jJ+1,hG+5,jJ+14,gx,jH[M],jQ)jI=jI-22;jJ=jJ-22 else ji=ji..gM(hG,jI,gx,jT.."pdim txtfuel")ji=ji..gM(hG,jJ,dj("%d%% %s",jH[M],jQ),"pdim txtfuel","fill:"..jS)jI=jI+30;jJ=jJ+30 end end end end;jB=jI end;local function jY(jZ,e2)if ap==0 and aq==0 then return end;if e2<200000 and not cf or e2 and cf then local j_=0;if eY(cM)>1 then j_=45*math.log(eY(cM),10)if cM<0 then j_=-j_ end end;jZ[#jZ+1]=dj([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],ap,aq,bM(cM),bM(j_))end;return jZ end;local function k0(k1)local gq=-cL;k1=k1-k1:project_on(gq)local k2=vec3(0,0,1)k2=k2-k2:project_on(gq)local k3=k2:cross(gq)local j_=k2:angle_between(k1)*constants.rad2deg;if k1:dot(k3)<0 then j_=360-j_ end;return j_ end;local function k4(jZ,al,am,k5,k6,cX)if ae==0 then return end;local k7=ae;local k8=20;local k9=bM(k5)if cX then for M=-45,45,5 do local ka=M;jZ[#jZ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],ka,al,am)kb=5;if M%15==0 then kb=15 elseif M%10==0 then kb=10 end;jZ[#jZ+1]=dj([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],al,am+k7+k8-kb,al,am+k7+k8)end;jZ[#jZ+1]=gM(al,am+k7+k8-35,k6,"pdim txt txtmid")jZ[#jZ+1]=gM(al,am+k7+k8-25,k9 .." deg","pdim txt txtmid")jZ[#jZ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k5,al,am)jZ[#jZ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/>]],al-5,am+k7+k8-20,al+5,am+k7+k8-20,al,am+k7+k8-15)jZ[#jZ+1]="</g>"end;jZ[#jZ+1]=[[<g style="clip-path: url(#headingClip);">]]local kc=k9;if cX then kc=k0(cG)end;local kd=20;local ke=bM(kc)local kf=0;local kg=am+k7+k8+20;local kh=al;if k6~="YAW"then kg=je(130)kh=jd(960)end;local ki=[[<path class="txttick line" d="]]local kj=bM(ke-(kd+10)-ke%5+0.5)for M=kj+70,kj,-5 do local hG=kh-(-M*5+kc*5)if M%10==0 then kf=10;local dC=M;if dC==360 then dC=0 elseif dC>360 then dC=dC-360 elseif dC<0 then dC=dC+360 end;jZ[#jZ+1]=gM(hG,kg+15,dC,"txtmid bright")elseif M%5==0 then kf=5 end;if kf==10 then ki=dj([[%s M %f %f v %d]],ki,hG,kg-5,kf)else ki=dj([[%s M %f %f v %d]],ki,hG,kg-2.5,kf)end end;jZ[#jZ+1]=ki..[["/>]]jZ[#jZ+1]=dj([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],kh-5,kg-20,kh+5,kg-20,kh,kg-10)if cX then k6="HDG"end;jZ[#jZ+1]=gM(jd(960),je(100),ke.."°","dim txt txtmid size14","")jZ[#jZ+1]=gM(jd(960),je(85),k6,"dim txt txtmid size20","")jZ[#jZ+1]=[[</g>]]end;local function kk(jZ,kl,k5,al,am,cX,km,fo)if ae==0 then return end;local k7=ae;local kn=bM(k7*3/5)if k7>0 then local ko=bM(kl)local kb=0;local ki=dj([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*k5,al,am)if not cf then ki=dj([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],al,am)end;jZ[#jZ+1]=dj([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],k7-1,al,am)jZ[#jZ+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for M=bM(ko-30-ko%5+0.5),bM(ko+30+ko%5+0.5),5 do if M%10==0 then kb=30 elseif M%5==0 then kb=20 end;local hH=am+-M*5+kl*5;if kb==30 then ki=dj([[%s M %d %f h %d]],ki,al-kn-kb,hH,kb)if cf then jZ[#jZ+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k5,al,am,al-kn+10,hH+4,M)jZ[#jZ+1]=dj([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*k5,al,am,al+kn-10,hH+4,M)if M==0 or M==180 or M==-180 then jZ[#jZ+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k5,al,am,al-kn+20,hH,kn*2-40)end else jZ[#jZ+1]=gM(al-kn+10,hH,M,"pdim txt txtmid")jZ[#jZ+1]=gM(al+kn-10,hH,M,"pdim txt txtmid")end;ki=dj([[%s M %d %f h %d]],ki,al+kn,hH,kb)else ki=dj([[%s M %d %f h %d]],ki,al-kn-kb,hH,kb)ki=dj([[%s M %d %f h %d]],ki,al+kn,hH,kb)end end;jZ[#jZ+1]=ki..[["/>]]local kp="PITCH"if not cX then kp="REL PITCH"end;if kl>90 and not cf then kl=90-(kl-90)elseif kl<-90 and not cf then kl=-90-(kl+90)end;if k7>200 then if cf then if fo>iZ then jZ[#jZ+1]=gM(al,am-15,"Yaw","pdim txt txtmid")jZ[#jZ+1]=gM(al,am+20,km,"pdim txt txtmid")end;jZ[#jZ+1]=dj([[<g transform="rotate(%f,%d,%d)">]],-k5,al,am)else jZ[#jZ+1]=dj([[<g transform="rotate(0,%d,%d)">]],al,am)end;jZ[#jZ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al-kn+25,am-5,al-kn+20,am,al-kn+25,am+5,al-kn+50,am+4,ko)jZ[#jZ+1]=dj([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],al+kn-25,am-5,al+kn-20,am,al+kn-25,am+5,al+kn-30,am+4,ko)jZ[#jZ+1]="</g>"end;local kq=bM(k7/3)jZ[#jZ+1]=dj([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],al-kq,am,k7-kq)if not cf and cX then jZ[#jZ+1]=dj([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*k5,al,am,al-kn+10,am,kn*2-20)end;jZ[#jZ+1]="</g>"if k7<200 then if cf and fo>iZ then jZ[#jZ+1]=gM(al,am-k7,kp,"pdim txt txtmid")jZ[#jZ+1]=gM(al,am-k7+10,ko,"pdim txt txtmid")jZ[#jZ+1]=gM(al,am-15,"Yaw","pdim txt txtmid")jZ[#jZ+1]=gM(al,am+20,km,"pdim txt txtmid")else jZ[#jZ+1]=gM(al,am-k7,kp,"pdim txt txtmid")jZ[#jZ+1]=gM(al,am-k7+15,ko,"pdim txt txtmid")end end end end;local function kr(jZ,e2,cX)local ks=ar;local kt=as;if ks==0 and kt==0 then return end;local ku=78;local kv=19;local kw=ce;if ce~=-1 then jZ[#jZ+1]=gM(ks+ku,kt+kv+20,dj("AGL: %.1fm",ce),"pdim altsm txtend")end;if cX and(e2<200000 and not cf or e2 and cf)then table.insert(jZ,dj([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ks-1,kt-4,ku+2,kv+6,ks+1,kt-1,ku-4,kv))local gv=0;local kx=1;local ky=0;local kz=e2<0;local kA=e2<kB.surfaceMaxAltitude;local kC=9;if kz then kC=0 end;local e2=eY(e2)while gv<6 do local kD=11;local kE=16;local kF=9;local kG=14;local jT="altsm"if gv>2 then kE=kE+3;kD=kD+2;kG=kG+2;kF=kF-6;jT="altbig"end;if kz then jT=jT.." red"elseif kA then jT=jT.." orange"end;local kH=e2/kx%10;local kI=bM(kH)local kJ=bM((kI+1)%10)local kK=ky;if gv==0 then kK=kH-kI;if kz then kK=1-kK end end;if kz and(gv==0 or ky~=0)then local gy=kJ;kJ=kI;kI=gy end;local kL=kE*(kK-1)local kM=kL+kE;local hG=ks+kF+(6-gv)*kD;local hH=kt+kG;jZ[#jZ+1]=gM(hG,hH+kL,kJ,jT)jZ[#jZ+1]=gM(hG,hH+kM,kI,jT)gv=gv+1;kx=kx*10;if kI==kC then ky=kK else ky=0 end end;table.insert(jZ,[[</g></g>]])end end;local function kN(ft)local kO=-math.deg(eT(ft.y,ft.z))+180;kO=kO-90;if kO<0 then kO=360+kO end;if kO>180 then kO=-180+kO-180 end;return-kO end;local function kP(ft)local kc=math.deg(eT(ft.y,ft.x))-90;if kc<-180 then kc=360+kc end;return kc end;local function kQ(jZ,ft,fo,al,am)if fo>5 and not cf or fo>iZ then local k7=ae;local kR=20;local kS=20;local kT=kN(ft)local kU=kP(ft)local kV=14;local kW=kV/2;local kX=-kU/kS*k7;local kY=kT/kR*k7;local hG=al+kX;local hH=am+kY;local ca=dm(kX^2+kY^2)local kZ=[[<circle
                            cx="]]..hG..[["
                            cy="]]..hH..[["
                            r="]]..kW/kV..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hG..[["
                            cy="]]..hH..[["
                            r="]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hG-kV..[[,]]..hH..[[ h ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hG+kW..[[,]]..hH..[[ h ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hG..[[,]]..hH-kV..[[ v ]]..kW..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ca<k7 then jZ[#jZ+1]=kZ else local j_=eT(kY,kX)local k_=4;local l0=al+k7*math.cos(j_)local l1=am+k7*math.sin(j_)jZ[#jZ+1]=dj('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',j_*180/math.pi,l0,l1,l0-k_,l1-k_/2,k_*2,k_,l0+k_,l1-k_,k_,k_,-k_,k_)end;if not cf then local l2=vec3(ft)kT=kN(-l2)kU=kP(-l2)kX=-kU/kS*k7;kY=kT/kR*k7;hG=al+kX;hH=am+kY;ca=dm(kX^2+kY^2)if ca<k7 then local l3=[[<circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hG..[[,]]..hH-kV..[[ v ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hG..[[,]]..hH..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hG..[[,]]..hH..[[)" />
                                <path
                                    d="M ]]..hG-kW..[[,]]..hH..[[ h ]]..kV..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hG..[[,]]..hH..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hG..[[,]]..hH..[[)"/>]]jZ[#jZ+1]=l3 end end end end;local function l4(jZ,jh,l5,l6)if an==0 and ao==0 then return end;l5=bM(l5+0.5)local jI=ao+10;local jJ=ao+20;if iF()==1 and not m then jI=55;jJ=65 end;local l7="CRUISE"local c="km/h"local dL=l6;if jh=="TRAVEL"or jh=="AUTOPILOT"then l7="THROT"c="%"dL=l5;local l8="dim"if l5<0 then l8="red"end;jZ[#jZ+1]=dj([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],l8,an-7,ao-50,an,ao-50,an,ao+50,an-7,ao+50,1-eY(l5),an-10,ao+50,an-15,ao+53,an-15,ao+47)end;jZ[#jZ+1]=gM(an+10,jI,l7,"pbright txtstart")jZ[#jZ+1]=gM(an+10,jJ,dj("%.0f %s",dL,c),"pbright txtstart")if cf and t and cQ and bS then l5=bM(bT*100+0.5)local l8="red"if l5<0 then l8="red"end;jZ[#jZ+1]=dj([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],l8,1-eY(l5),an-10,ao+50,an-15,ao+53,an-15,ao+47)jZ[#jZ+1]=gM(an+10,jI+40,"LIMIT","pbright txtstart")jZ[#jZ+1]=gM(an+10,jJ+40,l5 .."%","pbright txtstart")end;if cf and t or b8 then jZ[#jZ+1]=gM(an+10,jI-40,"LIMIT: "..cA.." km/h","dim txtstart")elseif not cf and b3 then jZ[#jZ+1]=gM(an+10,jI-40,"LIMIT: "..bM(a1*3.6+0.5).." km/h","dim txtstart")end end;local function l9(jZ,la)if an==0 and ao==0 then return end;local lb=ao-10;local lc=an+10;jZ[#jZ+1]=gM(0,0,"","pdim txt txtend")if iF()==1 and not m then lb=75 end;jZ[#jZ+1]=gM(lc,lb,bM(la).." km/h","pbright txtbig txtstart")end;local ld=40;local function le(jZ)jZ[#jZ+1]=gM(jd(150),je(1070),dj("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jZ[#jZ+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jZ[#jZ+1]=gM(jd(960),je(550),"Warning: Invalid Control Scheme Detected","warnings")jZ[#jZ+1]=gM(jd(960),je(600),"Keyboard Scheme must be selected","warnings")jZ[#jZ+1]=gM(jd(960),je(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local lf=jd(960)local lg=je(860)local lh=je(880)local li=je(900)local lj=je(960)local lk=je(200)local ll=je(250)local lm=je(960)if iF()==1 and not m then lg=je(135)lh=je(155)li=je(175)lk=je(115)ll=je(95)end;if b0 then local ln=""if type(b0)=="string"then ln="-"..b0 end;jZ[#jZ+1]=gM(lf,lg,"Brake Engaged"..ln,"warnings")elseif bR>0 then jZ[#jZ+1]=gM(lf,lg,"Auto-Brake Engaged","warnings","opacity:"..bR)end;if cf and cz and ce==-1 then if not b3 and not bq and not b6 and not cP and not b9 and not b7 then jZ[#jZ+1]=gM(lf,lk+50,"** STALL WARNING **","warnings")fT("stall","SW",2)end end;if cW then jZ[#jZ+1]=gM(lf,lk+90,"Flight Assist in Progress","warnings")end;if cj then jZ[#jZ+1]=gM(lf,lm,"Gyro Enabled","warnings")end;if lo then ld=ld-1;if ld>20 then jZ[#jZ+1]=gM(lf,lm-20,"ECU Enabled","warnings")elseif ld<0 then ld=40 end end;if bm then if bV then jZ[#jZ+1]=gM(lf,lh,"Gear Extended","warn")else jZ[#jZ+1]=gM(lf,lh,"Landed (G: Takeoff)","warnings")end end;if ce>-1 and(not cP or ch<100)then local lp=iK(d:getTargetGroundAltitude())jZ[#jZ+1]=gM(lf,li,"Hover Height: "..lp,"warn")end;if c4 then jZ[#jZ+1]=gM(lf,lj+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not r and cP and bv~=nil then local lq="warnings"if eY(ch-antigrav.getBaseAltitude())<501 then lq="warn"end;jZ[#jZ+1]=gM(lf,lk+40,dj("Target Altitude: %d Singularity Altitude: %d",bM(bv),bM(antigrav.getBaseAltitude())),lq)end;if b3 and bj~="None"then jZ[#jZ+1]=gM(lf,lk,"Autopilot "..bg,"warn")elseif bt~=nil then jZ[#jZ+1]=gM(lf,lk+20,dj("LockedPitch: %d",bM(bt)),"warn")elseif b_ then jZ[#jZ+1]=gM(lf,lk+20,"Follow Mode Engaged","warn")elseif b8 or cd then jZ[#jZ+1]=gM(lf,lk+20,"Re-entry in Progress","warn")end;if b5 or b9 then local lp=iK(ba,2)if b9 then if cP then lp=iK(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jZ[#jZ+1]=gM(lf,lk,"VTO to "..lp,"warn")elseif b7 and not bz then if cc then jZ[#jZ+1]=gM(lf,lk,"Takeoff to "..bj,"warn")else jZ[#jZ+1]=gM(lf,lk,"Takeoff to "..lp,"warn")end;if b0 and not b9 then jZ[#jZ+1]=gM(lf,lk+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jZ[#jZ+1]=gM(lf,lk,"Altitude Hold: "..dj("%.1fm",ba),"warn")end end;if b9 and(antigrav~=nil and antigrav)then if cg>0.1 then jZ[#jZ+1]=gM(lf,lk+20,"Beginning ascent","warn")elseif cg<0.09 and cg>0.05 then jZ[#jZ+1]=gM(lf,lk+20,"Aligning trajectory","warn")elseif cg<0.05 then jZ[#jZ+1]=gM(lf,lk+20,"Leaving atmosphere","warn")end end;if bz then if cB~=nil then jZ[#jZ+1]=gM(lf,lk,cB,"warn")end end;if b6 then if lr then local ls="Brake Landing"if db then ls=ls.."-Aligning"end;if da then ls=ls.."-Drift Limited"end;jZ[#jZ+1]=gM(lf,lk,ls,"warnings")else jZ[#jZ+1]=gM(lf,lk,"Coast-Landing","warnings")end end;if b2 then jZ[#jZ+1]=gM(lf,lk+20,"Prograde Alignment","crit")end;if b1 then jZ[#jZ+1]=gM(lf,lk,"Retrograde Alignment","crit")end;if cY then local type;if string.find(cY,"COLLISION")then type="warnings"else type="crit"end;jZ[#jZ+1]=gM(lf,ll+20,cY,type)elseif cg==0 then local lt,lu=cs.checkLOS(cJ:normalize())if lu~=nil then local lp=iK(lu)local lv=co.computeTravelTime(cK,0,lu)local lw="Collision"if lt.noAtmosphericDensityAltitude>0 then lw="Atmosphere"end;jZ[#jZ+1]=gM(lf,ll+20,lt.name.." "..lw.." "..iL(lv).." In "..lp,"crit")end end;if bq and not bz then jZ[#jZ+1]=gM(lf,lk+60,lx,"warn")end;if d1 and#d1>1 then end;local ly=jd;local lz=je;local lA="topButton"local lB="topButtonActive"local lC=lA;if b3 or bq or cc or bz then lC=lB end;local lD=lA;if b2 then lD=lB end;local lE=lA;if b6 or bm then lE=lB end;local lF=lA;if b5 or bq then lF=lB end;local lG=lA;if b1 then lG=lB end;local lH=lA;if bz or cD and b3 then lH=lB end;if w and I then local lI=lz(30)jZ[#jZ+1]=dj([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lC,ly(960),lz(54),lz(-53),ly(-120),ly(25),lz(50))jZ[#jZ+1]=gM(ly(910),lI,"AUTOPILOT")jZ[#jZ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lD,ly(865),lz(51),ly(-25),lz(-50),ly(-110),ly(25),lz(46))jZ[#jZ+1]=gM(ly(800),lI,"PROGRADE")jZ[#jZ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lE,ly(755),lz(47),ly(-25),lz(-46),ly(-98),ly(44),lz(44))jZ[#jZ+1]=gM(ly(700),lI,"LAND")jZ[#jZ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lF,ly(960),lz(54),lz(-53),ly(120),ly(-25),lz(50))jZ[#jZ+1]=gM(ly(1010),lI,"ALT HOLD")jZ[#jZ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lG,ly(1055),lz(51),ly(25),lz(-50),ly(110),ly(-25),lz(46))jZ[#jZ+1]=gM(ly(1122),lI,"RETROGRADE")jZ[#jZ+1]=dj([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lH,ly(1165),lz(47),ly(25),lz(-46),ly(98),ly(-44),lz(44))jZ[#jZ+1]=gM(ly(1220),lI,"ORBIT")jZ[#jZ+1]=[[
                                    </g>
                                </g>]]jZ[#jZ+1]="</g>"end;return jZ end;local function lJ(fo)return bM(fU(fo*3.6,0)+0.5).." km/h"end;local function lK(gv)local gx=bj;if gv~=nil and type(gv)=="number"then if gv==0 then return"None"end;gx=cT[gv].name end;if gx==nil then gx=g4.name end;if gx==nil then gx="None"end;return gx end;local function lL(jZ)local lM=cs.routeWP(true)if not lM or#lM==0 then return end;local hG=jd(750)local hH=je(360)if b3 or bq then jZ[#jZ+1]=gM(hG,hH,"REMAINING ROUTE","pdim txtstart size20")else jZ[#jZ+1]=gM(hG,hH,"LOADED ROUTE","pdim txtstart size20")end;for dK,M in pairs(lM)do hH=hH+20;jZ[#jZ+1]=gM(hG,hH,dK..". "..lM[dK],"pdim txtstart size20")end end;local function lN(jZ)local hG=aB+10;local hH=aC+20;local lO={}local lP={"Alt-4: AutoTakeoff to Target"}local lQ={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lR={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local lS={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lO,"--------------DYNAMIC-----------------")if cf then if ce~=-1 then iI(lO,lP)if c7 and kB and c7.name==kB.name then table.insert(lO,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or a_ then if antigrav then if cP then table.insert(lO,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lO,"Turn on AGG to takeoff to AGG Height")end end;if a_ then table.insert(lO,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lO,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lO,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bm then table.insert(lO,"G: Takeoff to hover height, raise gear")else table.insert(lO,"G: Lowergear and Land")end else iI(lO,lQ)table.insert(lO,"G: Begin BrakeLanding or Land")end;if b9 then table.insert(lO,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else iI(lO,lR)if shield then table.insert(lO,"Alt-Shift-6: Vent shields")if not G then table.insert(lO,"Alt-Shift-7: Toggle shield off/on")end end end;if g4~=nil then table.insert(lO,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lO,"Alt-9: Activate Gyroscope")end;if aW~="none"or aV~="none"or aX~="none"then table.insert(lO,"Alt-Shift-9: Cycles engines with Extra tags")end;if b5 then table.insert(lO,"Alt-Spacebar/C will raise/lower target height")table.insert(lO,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cf then table.insert(lO,"LALT+Mousewheel will lower/raise speed limit")end;iI(lO,lS)for M=1,#lO do hH=hH+12;jZ[#jZ+1]=gM(hG,hH,lO[M],"pdim txtbig txtstart")end end;local function lT(jZ)local lU=aB;local lV=aC;local lW=aA;local lX=4;local lY=15;local hG=0;local hH=0;local lZ,l_,m0,m1;local m2;local function m3(type)local gH,bP,fo,m4,jT,m5;if type=="Periapsis"then gH=m2.periapsis.altitude;bP=m2.timeToPeriapsis;fo=m2.periapsis.speed;jT="txtend"m4=12;m5=math.min(hG,lU+lW-kB.radius/m0-lX*2)else gH=m2.apoapsis.altitude;bP=m2.timeToApoapsis;fo=m2.apoapsis.speed;m4=-12;jT="txtstart"m5=hG end;if cK<1 then bP=0 end;jZ[#jZ+1]=dj([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5+m4,hH-5,hG,hH-5)jZ[#jZ+1]=dj([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],m5-m4*4,hH+2,hG,hH+2)jZ[#jZ+1]=gM(m5,hH,type,jT)hG=m5-m4*2;hH=hH+lY;local lp=iK(gH)jZ[#jZ+1]=gM(hG,hH,lp,jT)hH=hH+lY;jZ[#jZ+1]=gM(hG,hH,iL(bP),jT)hH=hH+lY;jZ[#jZ+1]=gM(hG,hH,lJ(fo),jT)end;local m6=lW*1.5;if bJ=="INFO"then m6=25*10 end;if bJ=="ORBIT"and ch<kB.spaceEngineMinAltitude then return jZ end;if bJ~="HIDE"then jZ[#jZ+1]=[[<g class="pbright txtorb txtmid">]]jZ[#jZ+1]=dj('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lW*2,m6,lU,lV)jZ[#jZ+1]=dj([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],lW*2,m6,lU,lV)end;local m7=lW*1.5;local m8=lW*2;local m9=m7/2;local ma=lW;local mb=lU+ma;local mc=lV+m9;local md=lU+m8;local me=lV+m7;if bJ=="ORBIT"then lV=lV+lX;lZ=lW/2;m1=0;m2={}m2.periapsis={}m2.apoapsis={}if fs~=nil then if fs.periapsis~=nil then m2.periapsis.altitude=fs.periapsis.altitude;m2.periapsis.speed=fs.periapsis.speed end;if fs.apoapsis~=nil then m2.apoapsis.altitude=fs.apoapsis.altitude;m2.apoapsis.speed=fs.apoapsis.speed end;m2.period=fs.period;m2.eccentricity=fs.eccentricity;m2.timeToApoapsis=fs.timeToApoapsis;m2.timeToPeriapsis=fs.timeToPeriapsis;m2.eccentricAnomaly=fs.eccentricAnomaly;m2.trueAnomaly=fs.trueAnomaly end;if m2.periapsis==nil then m2.periapsis={}m2.periapsis.altitude=-kB.radius;m2.periapsis.speed=a1 end;if m2.eccentricity==nil then m2.eccentricity=1 end;if m2.apoapsis==nil then m2.apoapsis={}m2.apoapsis.altitude=ch;m2.apoapsis.speed=0 end;if cK<1 then m2.apoapsis.altitude=ch;m2.apoapsis.speed=0 end;if m2.apoapsis.altitude then m0=(m2.apoapsis.altitude+m2.periapsis.altitude+kB.radius*2)/(lZ*2)l_=(kB.radius+m2.apoapsis.altitude)/m0*(1-m2.eccentricity)m1=lZ-m2.periapsis.altitude/m0-kB.radius/m0;local mf=math.pi;if m2.period~=nil and m2.period>0 and m2.timeToApoapsis~=nil then mf=m2.eccentricAnomaly;if m2.timeToPeriapsis<m2.timeToApoapsis then mf=2*math.pi-mf end end;if cK<1 or mf~=mf then mf=math.pi end;local mg=-lZ*math.cos(mf)+lU+ma+lX;local mh=l_*math.sin(mf)+lV+m9+lX;local mi=""jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'jZ[#jZ+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mi,lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)if l_<1 then jZ[#jZ+1]=dj([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lU+lW+lX-m1,lV+lW*1.5/2+lX,mg,mh)end;jZ[#jZ+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kB.radius+kB.noAtmosphericDensityAltitude)/m0)jZ[#jZ+1]=dj('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lU+lW+lX-m1,lV+lW*1.5/2+lX,(kB.radius+kB.noAtmosphericDensityAltitude)/m0)jZ[#jZ+1]=dj([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lU+lW+lX,lV+lW*1.5/2+lX,lZ,l_)jZ[#jZ+1]=dj('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lU+lW+lX-m1,lV+lW*1.5/2+lX,kB.radius/m0)jZ[#jZ+1]='</g>'local mj=math.floor(kB.radius/m0+0.5)hG=lU+lW+lX*4+lZ;hH=lV+lW*1.5/2+5+lX;if m2.apoapsis~=nil and m2.apoapsis.speed<a1 then m3("Apoapsis")end;hH=lV+lW*1.5/2+5+lX;hG=lU+lW-lX*2-lZ;if m2.periapsis~=nil and m2.periapsis.speed<a1 and m2.periapsis.altitude>0 then m3("Periapsis")end;jZ[#jZ+1]=gM(lU+lW+lX,lV+20+lX,kB.name,"txtorbbig")jZ[#jZ+1]=dj('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mg,mh)jZ[#jZ+1]=[[</g>]]return jZ else jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'local mk=""local ml=1.2*(mm-mn)/(lW*2)local mo=1.4*(mp-mq)/(lW*1.5)for dK,dw in pairs(e[0])do if dw.center then local hG=lU+lW+dw.center.x/ml;local hH=lV+lW*1.5/2+dw.center.y/mo;mk=mk..'<circle cx="'..hG..'" cy="'..hH..'" r="'..dw.radius/ml*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dw.name,"Moon")and not string.match(dw.name,"Sanctuary")and not string.match(dw.name,"Space")then mk=mk.."<text x='"..hG.."' y='"..hH+dw.radius/ml*30+20 .."' font-size='12' fill="..j5 .." text-anchor='middle' font-family='Montserrat'>"..dw.name.."</text>"end end end;local fu=vec3(bO.getWorldPosition())local hG=lU+lW+fu.x/ml;local hH=lV+lW*1.5/2+fu.y/mo;mk=mk..'<circle cx="'..hG..'" cy="'..hH..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mk=mk.."<text x='"..hG.."' y='"..hH-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iT=ml;iU=mo;local mr=fu+cJ*1000000;local ms=lU+lW+mr.x/ml;local jJ=lV+lW*1.5/2+mr.y/mo;mk=mk..'<line x1="'..hG..'" y1="'..hH..'" x2="'..ms..'" y2="'..jJ..'" stroke="purple" stroke-width="1"/>'jZ[#jZ+1]=mk;jZ[#jZ+1]='</g>'end elseif bJ=="INFO"then jZ=cq.DrawOdometer(jZ,j7,bn,j8)elseif bJ=="HELP"then jZ=lN(jZ)elseif bJ=="SCOPE"then jZ[#jZ+1]='<g clip-path="url(#orbitRect)">'local mt=d4;if cg>0 then table.sort(d3,function(ez,eA)local eB,eC=ez.center,eA.center;return(eB.x-cN.x)^2+(eB.y-cN.y)^2+(eB.z-cN.z)^2<(eC.x-cN.x)^2+(eC.y-cN.y)^2+(eC.z-cN.z)^2 end)end;local mu={}local mv={}local mw=120;local mx=nil;local my=nil;for M,dw in ipairs(d3)do local gU=dw.center-cN;local mz=gU:len()local mA=gU:normalize()local mB=gU:cross(cG):normalize()local mC=math.acos(mB:dot(cH))if mC~=mC then mC=0 end;if mB:cross(cH):dot(cG)<0 then mC=-mC end;local mD=gU:project_on_plane(cG):len()local mE=math.sin(mC)*math.asin(mD/mz)*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/mz)*constants.rad2deg;if mA:dot(cG)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hG=mb+mE/mt*m7;local hH=mc+mF/mt*m7;local mG=(hG-mb)*(hG-mb)+(hH-mc)*(hH-mc)local mH=math.asin((dw.radius+dw.surfaceMaxAltitude)/mz)*constants.rad2deg;if mH~=mH then mH=mt end;local i0=mH/mt*m7;local mI=math.asin(dw.atmosphereRadius/mz)*constants.rad2deg;if mI~=mI then mI=mH end;local mJ=mI/mt*m7;local ca=iK(mz,1)local mK=dw.name;local mL=false;if hH>lV then if hH>me then if hH-mJ<=me then mL=true end else mL=true end else if hH+mJ>=lV then mL=true end end;local mM=false;local mN=hG;if dw.systemId==0 then mN=hG+mw else mN=hG-mw end;if mN+mw>lU then if mN+mw>md then if mN-mJ-mw<=md then mM=true end else mM=true end else if mN+mJ+mw>=lU then mM=true end end;local mO={}mO.x=hG;mO.y=hH;mO.planet=dw;mO.atmoSize=mJ;if not mx or mG<mx then mx=mG;my=mO end;if mM and mL then local mP=math.max(mJ,5)if mG<mP*mP then mK=mK.." - "..ca end;mO.size=i0;mO.i=M;mO.displayString=mK;mO.distance=ca;mO.visible=true;mv[#mv+1]=mO else mO.visible=false end end;local mQ=false;table.sort(mv,function(eB,eC)return eB.y<eC.y end)for dK,fx in ipairs(mv)do local dw,i0,M,mJ,hG,hH,mK,ca=fx.planet,fx.size,fx.i,fx.atmoSize,fx.x,fx.y,fx.displayString,fx.distance;local m5,mR,mS,mT;local mU=15;local jT="pdim"if dw.systemId~=0 then mS=jd(string.len(mK)*5)mU=-(15+mS)mT=je(10)jT="pdimfill"else mS=jd(string.len(mK)*9)mT=je(15)end;if i0*2>mS then m5=dk(hG,lU+mS/2,md-mS/2)mR=dk(hH,lV+mT,me-5)m5=dk(m5,hG-i0+mS/2,hG+i0-mS/2)mR=dk(mR,hH-i0+mT,hH+i0)else m5=hG+mU;mR=hH end;for mV,fx in pairs(mu)do local mW=fx.textPositions;local mX=mW.y-mR;if mV~=M and eY(mX)<mW.height and mW.x+mW.width>m5 and mW.x<m5+mS then if i0>mS then mR=dk(mR+mT,lV+15,me-5)else mR=mW.y+mW.height+1 end end end;local mY=mK~=dw.name or m5<=mb and m5+mS>=mb and mR-mT<=mc and mR>=mc;fx.hovered=mY;local mZ=1;if mY then mZ=2;if i0*2<mS then mZ=10 end;if mK==dw.name then mK=mK.." - "..ca end;jT="pbright"if dw.systemId~=0 then mS=jd(string.len(mK)*5)mU=-(15+mS)else mS=jd(string.len(mK)*7)end;if i0*2>mS then m5=dk(hG,lU+mS/2,md-mS/2)m5=dk(m5,hG-i0+mS/2,hG+i0-mS/2)else m5=hG+mU end end;mu[M]={}mu[M].textPositions={}mu[M].textPositions.y=mR;mu[M].textPositions.x=m5;mu[M].textPositions.width=mS;mu[M].textPositions.height=mT;mu[M].output=""if i0*2>mS then jT=jT.." txtmid"else jT=jT.." txtstart"end;if mJ-i0>2 then mu[M].output=dj('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hG,hH,mJ,j6,0.1*mZ)end;mu[M].output=mu[M].output..dj('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hG,hH,i0,j6,0.2*mZ)if dw.systemId==0 then mu[M].output=mu[M].output..dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mR,j5,jT,mK)if i0*2<=mS then mu[M].output=mu[M].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5+mS,mR+2,m5,mR+2,hG,hH)end else mu[M].output=mu[M].output..dj([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],m5,mR,j6,jT,mK)if i0*2<=mS then mu[M].output=mu[M].output..dj("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",m5,mR+2,m5+mS,mR+2,hG,hH)end end end;for dK=#d3,1,-1 do if mu[dK]then jZ[#jZ+1]=mu[dK].output end end;if my~=nil and d4<90 and not my.hovered then local m_=my.planet.atmosphereRadius/my.atmoSize;local n0=dm(mx)*m_;local n1=iK(n0,1)local mS=jd(math.max(string.len(n1)*7,string.len(my.planet.name)*7))local mT=je(12)local m5=dk(my.x+(mb-my.x)/2,lU+mS/2,md-mS/2)local mR=dk(my.y+(mc-my.y)/2,lV+mT*2,me-5)jZ[#jZ+1]=dj("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",my.x,my.y,mb,mc)jZ[#jZ+1]=dj([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mR,"white",n1)if not my.visible then jZ[#jZ+1]=dj([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],m5,mR-mT,"white",my.planet.name)end end;if cK>1 then local gU=cJ;local mA=gU:normalize()local mD=gU:project_on_plane(cG):len()local mB=gU:cross(cG):normalize()local mC=math.acos(mB:dot(cH))if mC~=mC then mC=0 end;if mB:cross(cH):dot(cG)<0 then mC=-mC end;local mE=math.sin(mC)*math.asin(mD/gU:len())*constants.rad2deg;local mF=math.cos(mC)*math.asin(mD/gU:len())*constants.rad2deg;if mA:dot(cG)<0 then mF=90*math.cos(mC)+90*math.cos(mC)-mF;mE=90*math.sin(mC)+90*math.sin(mC)-mE end;local hG=mb+mE/mt*m7;local hH=mc+mF/mt*m7;local kV=14;local kW=kV/2;local kZ=[[<circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kW/kV..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hG..[["
                                    cy="]]..hH..[["
                                    r="]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hG-kV..[[,]]..hH..[[ h ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hG+kW..[[,]]..hH..[[ h ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hG..[[,]]..hH-kV..[[ v ]]..kW..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jZ[#jZ+1]=kZ end;jZ[#jZ+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb,mc-10,mb,mc+10)jZ[#jZ+1]=dj("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mb-10,mc,mb+10,mc)jZ[#jZ+1]='</g>'else return jZ end end;local function n2(n3,n4)local n5;local n6=(n4-n3):normalize()local fv=(cN-n3):dot(n6)/n6:dot(n6)if fv<=0. then return(cN-n3):len()elseif fv>=(n4-n3):len()then return(cN-n4):len()end;local n7=n3+fv*n6;n5=(n7-cN):len()return n5 end;local function n8()local n5;local n9=nil;local na=nil;local nb=nil;for dK,nc in pairs(e[0])do if nc.hasAtmosphere then local ca=n2(kB.center,nc.center)if n9==nil or ca<n9 then na=nc;n9=ca;nb=kB end;if c7 and c7.hasAtmosphere and c7.name~=kB.name then local eO=n2(c7.center,nc.center)if eO<n9 then na=nc;n9=eO;nb=c7 end end end end;local nd=jd(1770)local ne=je(330)if n9 then local nf="txttick "local ng=500000;if n9<na.radius+ng or n9<nb.radius+ng then if cU then nf="txttick red "else nf="txttick orange "end end;n5=iK(n9,2)iY=gM(nd,ne,"Pipe ("..nb.name.."--"..na.name.."): "..n5,nf.."pbright txtmid")end end;local function nh(hG,hH,ni,nj,l7)local nk={x=hG,y=hH,width=ni,height=nj,label=l7}iS[l7]=nk;return nk end;local function nl(nm,nn,ni,nj,hG,hH,no,np,nq,nr,jT)local nk={enableName=nm,disableName=nn,width=ni,height=nj,x=hG,y=hH,toggleVar=no,toggleFunction=np,drawCondition=nq,hovered=false,class=jT}if nr then table.insert(iR,nk)else table.insert(iQ,nk)end;return nk end;local function ns(nt)if not iW then nu=false;nv=false;nw=false;w=true;return elseif nt=="handling"then nu=not nu;nv=false;nw=false elseif nt=="hud"then nv=not nv;nu=false;nw=false elseif nt=="physics"then nw=not nw;nu=false;nv=false end;if nw or nv or nu then iX=iJ(nt)w=false else iX="none"w=true end end;local function nx()iW=not iW;if iW then iP=iR;c2="Tap LMB to see Settings"d5=w else iP=iQ;c2="Tap LMB to see Control Buttons"ns()w=d5 end end;local function ny()local function nz(dw,dK)dw.set(not dw.get())if dw.get()then c2=dK.." set to true"else c2=dK.." set to false"end;if dK=="showHud"then d5=dw.get()elseif dK=="BrakeToggleDefault"then aZ=k end end;local nA=50;local nB=340;local hG=500;local hH=ad/2-400;local nC=0;for dK,dw in pairs(iJ("boolean"))do if type(dw.get())=="boolean"then nl(dK,dK,nB,nA,hG,hH,function()return dw.get()end,function()nz(dw,dK)end,function()return true end,true)hH=hH+nA+20;if nC==9 then hG=hG+nB+20;hH=ad/2-400;nC=0 else nC=nC+1 end end end;nl("Control View","Control View",nB,nA,10,ad/2-500,function()return true end,nx,function()return true end,true)nl("View Handling Settings",'Hide Handling Settings',nB,nA,10,ad/2-(500-nA),function()return nu end,function()ns("handling")end,function()return true end,true)nl("View Hud Settings",'Hide Hud Settings',nB,nA,10,ad/2-(500-nA*2),function()return nv end,function()ns("hud")end,function()return true end,true)nl("View Physics Settings",'Hide Physics Settings',nB,nA,10,ad/2-(500-nA*3),function()return nw end,function()ns("physics")end,function()return true end,true)end;local function nD()local function gw()local fW=cN;local gx=kB.name..". "..#bp;if ct then gx=ct.GetClosestName(gx)end;return cr.AddNewLocation(gx,fW,false,true)end;local function nE()b4=not b4 end;local function nF(nG)if nG==1 then b2=not b2;b1=false else b1=not b1;b2=false end;b3=false;b5=false;b_=false;b6=false;bt=nil;b8=false;b7=false end;local function nH(nI,nJ)cr.UpdatePosition(nil,nI,nJ)end;local function gr()cr.ClearCurrentPosition()end;local function nK(gv)local lM=cs.routeWP(true)if lM and#lM>0 then return"Engage Route: "..lM[1]end;return"Engage Autopilot: "..lK(gv)end;local function nL(gv)local lM=cs.routeWP(true)if lM and#lM>0 then return"Next Route Point: "..lM[1]end;return"Disable Autopilot: "..lK(gv)end;local function nM()if iF()==1 then b_=not b_;if b_ then b3=false;b1=false;b2=false;b5=false;b8=false;b6=false;b7=false;nN=bm;bm=false;d.control.retractLandingGears()iG:setTargetGroundAltitude(Z)fT("folOn","F")else fT("folOff","F")b0="Follow Off"cy=q;bm=nN;if bm then d.control.deployLandingGears()iG:setTargetGroundAltitude(_)end end else c2="Follow Mode only works with Remote controller"b_=false end end;local nA=50;local nB=260;local nO=jd(30)local nP=aB+aA*2+2;local nQ=aC+1;nl("+","+",nO,nO,nP,nQ+nO+1,function()return false end,function()d4=d4/8 end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nl("-","-",nO,nO,nP,nQ,function()return false end,function()d4=math.min(d4*8,90)end,function()return bJ=="SCOPE"end,nil,"ZoomButton")nl("0","0",nO,nO,nP,nQ+nO*2+2,function()return false end,function()d4=90 end,function()return bJ=="SCOPE"and d4~=90 end,nil,"ZoomButton")local nR=nl("Enable Brake Toggle","Disable Brake Toggle",nB,nA,ac/2-nB/2,ad/2+350,function()return aZ end,function()aZ=not aZ;if aZ then c2="Brakes in Toggle Mode"else c2="Brakes in Default Mode"end end)nl("Align Prograde","Disable Prograde",nB,nA,ac/2-nB/2-50-nR.width,ad/2-nA+380,function()return b2 end,function()nF(1)end)nl("Align Retrograde","Disable Retrograde",nB,nA,ac/2-nB/2+nR.width+50,ad/2-nA+380,function()return b1 end,nF,function()return cg==0 end)nS=nl(nK,nL,600,60,ac/2-600/2,ad/2-60/2-330,function()return b3 or bq or cc or bz end,function()end)local M;local function nT(nU)local gv=d0+nU;if gv>#cT then gv=gv-#cT-1 end;if gv<0 then gv=#cT+gv end;return gv end;nV={}for M=0,10 do local nW=nl(function(eC)local gv=nT(eC.apExtraIndex)if b3 or bq or cc or bz then return"Redirect: "..lK(gv)end;return nK(gv)end,function(eC)local gv=nT(eC.apExtraIndex)return nL(gv)end,600,60,ac/2-600/2,ad/2-60/2-330+60*M,function(eC)local gv=nT(eC.apExtraIndex)return gv==bl and(b3 or bq or cc or bz)end,function(eC)local gv=nT(eC.apExtraIndex)local nX=bl==gv;bl=gv;cr.UpdateAutopilotTarget()cs.ToggleAutopilot()if not nX and not(b3 or bq or cc or bz)then cs.ToggleAutopilot()end end,function()return c_ and(#cs.routeWP(true)==0 or M==0)end)nW.apExtraIndex=M;nV[M]=nW end;nl("Save Position","Save Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,gw,function()return bl==0 or g4==nil end)nl("Update Position","Update Position",200,nS.height,nS.x+nS.width+30,nS.y,function()return false end,function()nH(nil)end,function()return bl>0 and g4~=nil end)nl("Save Heading","Clear Heading",200,nS.height,nS.x+nS.width+30,nS.y+nS.height+20,function()return g4.heading~=nil end,function()if g4.heading~=nil then nH(false)else nH(true)end end,function()return bl>0 and g4~=nil end)nl("Save AGG Alt","Clear AGG Alt",200,nS.height,nS.x+nS.width+30,nS.y+nS.height*2+40,function()return g4.agg~=nil end,function()if g4.agg~=nil then nH(nil,false)else nH(nil,true)end end,function()return bl>0 and g4~=nil and antigrav end)nl("Clear Position","Clear Position",200,nS.height,nS.x-200-30,nS.y,function()return true end,gr,function()return bl>0 and g4~=nil end)nl("Save Route","Save Route",200,nS.height,nS.x-200-30,nS.y+nS.height*2+40,function()return false end,function()cs.routeWP(false,false,2)end,function()return#cs.routeWP(true)>0 end)nl("Load Route","Clear Route",200,nS.height,nS.x-200-30,nS.y+nS.height+20,function()return#cs.routeWP(true)>0 end,function()if#cs.routeWP(true)>0 then cs.routeWP(false,true)elseif b3 or bq then c2="Disable Autopilot before loading route"return else cs.routeWP(false,false,1)end end,function()return true end)nA=60;nB=300;local hG=0;local hH=ad/2-150;nl("Enable Check Damage","Disable Check Damage",nB,nA,hG,hH-nA-20,function()return s end,function()s=not s end)nl("View Settings","View Settings",nB,nA,hG,hH,function()return true end,nx)hH=hH+nA+20;nl("Enable Turn and Burn","Disable Turn and Burn",nB,nA,hG,hH,function()return b4 end,nE)hG=10;hH=ad/2-300;nl("Horizontal Takeoff Mode","Vertical Takeoff Mode",nB,nA,ac/2-nB/2,hH+20,function()return a_ end,function()a_=not a_;if a_ then c2="Vertical Takeoff Mode"else c2="Horizontal Takeoff Mode"end end,function()return cO end)hH=hH+nA+20;nl("Engage Orbiting","Cancel Orbiting",nB,nA,hG+nB+20,hH,function()return bz end,cs.ToggleIntoOrbit,function()return cg==0 and cX end)hH=ad/2-150;nl("Glide Re-Entry","Cancel Glide Re-Entry",nB,nA,hG+nB+20,hH,function()return b8 end,function()cb=1;nF(1)end,function()return kB.hasAtmosphere and not cf end)hH=hH+nA+20;nl("Parachute Re-Entry","Cancel Parachute Re-Entry",nB,nA,hG+nB+20,hH,function()return b8 end,function()cb=2;nF(1)end,function()return kB.hasAtmosphere and not cf end)hH=hH+nA+20;nl("Engage Follow Mode","Disable Follow Mode",nB,nA,hG,hH,function()return b_ end,nM,function()return iF()==1 end)nl("Enable Repair Arrows","Disable Repair Arrows",nB,nA,hG+nB+20,hH,function()return jb end,function()jb=not jb;if jb then c2="Repair Arrows Enabled"else c2="Repair Arrows Diabled"end end,function()return iF()==1 end)hH=hH+nA+20;if not r then nl("Enable AGG","Disable AGG",nB,nA,hG,hH,function()return cP end,cs.ToggleAntigrav,function()return antigrav~=nil end)end;nl(function()return dj("Switch IPH Mode - Current: %s",bA)end,function()return dj("IPH Mode: %s",bA)end,nB*2,nA,hG,hH,function()return false end,function()if bA=="All"then bA="Custom Only"elseif bA=="Custom Only"then bA="No Moons-Asteroids"else bA="All"end;c2="IPH Mode: "..bA end)hH=hH+nA+20;nl(function()return dj("Toggle Control Scheme - Current: %s",g)end,function()return dj("Control Scheme: %s",g)end,nB*2,nA,hG,hH,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c2="New Control Scheme: "..g end)local nY=je(20)local nW=nh(0,0,jd(70),nY,"HELP")nW=nh(nW.x+nW.width,nW.y,jd(80),nY,"INFO")nW=nh(nW.x+nW.width,nW.y,jd(70),nY,"ORBIT")nW=nh(nW.x+nW.width,nW.y,jd(70),nY,"SCOPE")nh(nW.x+nW.width,nW.y,jd(70),nY,"HIDE")end;local nZ={}local n_=nil;function nZ.HUDPrologue(jZ)if not cU then j2=ai;j3=aj;j4=ak else j2=af;j3=ag;j4=ah end;j5=[[rgb(]]..bM(j2+0.6)..","..bM(j3+0.6)..","..bM(j4+0.6)..[[)]]j6=[[rgb(]]..bM(j2*0.8+0.5)..","..bM(j3*0.8+0.5)..","..bM(j4*0.8+0.5)..[[)]]local o0=j5;local o1=j6;local o2=[[rgb(]]..bM(j2*0.4+0.5)..","..bM(j3*0.4+0.5)..","..bM(j4*0.4+0.5)..[[)]]local o3=j5;local o4=j6;local o5=o2;if jf()and not n then o0=[[rgb(]]..bM(j2*0.5+0.5)..","..bM(j3*0.5+0.5)..","..bM(j4*0.5+0.5)..[[)]]o1=[[rgb(]]..bM(j2*0.3+0.5)..","..bM(j3*0.3+0.5)..","..bM(j4*0.2+0.5)..[[)]]o2=[[rgb(]]..bM(j2*0.2+0.5)..","..bM(j3*0.2+0.5)..","..bM(j4*0.2+0.5)..[[)]]end;local ly=jd;local lz=je;jZ[#jZ+1]=dj([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o0,o0,o0,o3,o3,o1,o1,o4,o4,o1,o0,o2,o4,o0,o0,o2,o2,o5,o2,ac,ad,o1,o1,o1,o1,o1,o3,o1,o4,o5,o4,o4,o5)if not n_ then n_=dj([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],ly(630),lz(0),ly(675),lz(45),ly(960),lz(55),ly(1245),lz(45),ly(1290),lz(0),ly(1000),lz(105),ly(1040),lz(59),ly(1250),lz(51),ly(1300),lz(0),ly(1920),lz(0),ly(1920),lz(20),ly(1400),lz(20),ly(1300),lz(105),ly(920),lz(105),ly(880),lz(59),ly(670),lz(51),ly(620),lz(0),ly(0),lz(0),ly(0),lz(20),ly(520),lz(20),ly(620),lz(105),ly(890),lz(59),ly(960),lz(62),ly(1030),lz(59),ly(985),lz(112),ly(1150),lz(112),ly(1100),lz(152),ly(820),lz(152),ly(780),lz(112),ly(935),lz(112),ly(890),lz(59),ly(960),lz(62),ly(1030),lz(59),ly(985),lz(112),ly(1150),lz(112),ly(1100),lz(152),ly(820),lz(152),ly(780),lz(112),ly(935),lz(112))end;if w and I then jZ[#jZ+1]=n_ end;return jZ end;function nZ.DrawVerticalSpeed(jZ,e2)jY(jZ,e2)end;function nZ.UpdateHud(jZ)local kO=cR;local o6=cS;local k5=o6;local kl=kO;local l5=bM(c.getThrottle())local la=cK*3.6;local l6=c.getAxisCommandValue(0)local o7=jd(1770)local o8=je(310)if t and cQ then l6=bQ;l5=bQ*100 end;local jh=jg()local k6="ROLL"if l5==nil then l5=0 end;if not cX then if cK>5 then kO=kN(cI)o6=kP(cI)else kO=0;o6=0 end;k6="YAW"end;if cV>50000 and not cf then local o9;o9=iK(cV)jZ[#jZ+1]=gM(o7,o8,"PvP Boundary: "..o9,"pbright txtbig txtmid")end;jZ[#jZ+1]=j9;jZ[#jZ+1]=ie;if iY~=""then jZ[#jZ+1]=iY end;if ji~=""then jZ[#jZ+1]=ji end;if jj~=""then jZ[#jZ+1]=jj end;jY(jZ,ch)if iF()==0 or m then if not jf()or n then if cX then k4(jZ,al,am,k5,k6,cX)kk(jZ,kl,k5,al,am,cX,bM(kP(cI)),cK)else k4(jZ,al,am,o6,k6,cX)kk(jZ,kO,o6,al,am,cX,bM(o6),cK)end;kr(jZ,ch,cX)kQ(jZ,cI,cK,al,am)end end;l4(jZ,jh,l5,l6)l9(jZ,la)le(jZ)lT(jZ)if not iW and c0 then lL(jZ)end;return jZ end;function nZ.HUDEpilogue(jZ)jZ[#jZ+1]="</svg>"return jZ end;function nZ.ExtraData(jZ)local oa=jd(1240)local ob=je(55)local oc=ob+10;local od;local ly=jd;local lz=je;local oe=0;local jh=jg()if a_ then jh=jh.."-VERTICAL"end;if E and gX and not b7 and not b6 and cK>20 then jh=jh.."-COLLISION ON"end;if bC~="Off"then jh="("..bC..")-"..jh end;if b4 then jh="TB-"..jh end;if bH then jh="HOVERMODE-"..jh end;if not bB then jh=jh.."-DeCoupled"end;local of=lz(99)local og=lz(80)local oh=lz(85)local oi=lz(31)local oj=0;local ok=0;local ol=ci>1000000 and fU(ci/1000000,2).."kT"or fU(ci/1000,2).."T"if cf then oe=bu else oe=bs end;local om,on=co.computeDistanceAndTime(cK,0,ci,0,0,oe)if om<0 then om=0 end;oe=fU(oe/(ci*iO),2).."g"local oo=d:maxForceForward()od=b.getGravityIntensity()if od>0.1 then ok=ci*od;ok=fU(ok/(ci*iO),2).."g"oj=0.5*oo/od;oj=oj>1000000 and fU(oj/1000000,2).."kT"or fU(oj/1000,2).."T"end;oo=fU(oo/(ci*iO),2).."g"local op=vec3(bO.getWorldAcceleration()):len()/9.80665;od=b.getGravityIntensity()jZ[#jZ+1]=[[<g class="dim txt txtend size14">]]if iF()==1 and not m then oa=jd(1120)ob=je(55)oc=ob+10 elseif cf and I then local oq=jd(770)jZ[#jZ+1]=gM(ly(895),of,"ATMO","")jZ[#jZ+1]=dj([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],ly(895),oh,ly(-80))jZ[#jZ+1]=gM(ly(815),og,dj("%.1f%%",cg*100),"txtstart size20")end;if I then jZ[#jZ+1]=gM(ly(1025),of,"GRAVITY","txtstart")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1025),oh,ly(80))jZ[#jZ+1]=gM(ly(1105),og,dj("%.2fg",od/9.80665),"size20")jZ[#jZ+1]=gM(ly(1125),of,"ACCEL","txtstart")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1125),oh,ly(80))jZ[#jZ+1]=gM(ly(1205),og,dj("%.2fg",op),"size20")jZ[#jZ+1]=gM(ly(695),of,"BRK TIME","")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(695),oh,ly(-80))jZ[#jZ+1]=gM(ly(615),og,dj("%s",iL(on)),"txtstart size20")jZ[#jZ+1]=gM(ly(635),lz(45),"TRIP","")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(635),lz(31),ly(-90))if lv then jZ[#jZ+1]=gM(ly(545),lz(26),dj("%s",iL(lv)),"txtstart size20")end;jZ[#jZ+1]=gM(ly(795),of,"BRK DIST","")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(795),oh,ly(-80))jZ[#jZ+1]=gM(ly(715),og,dj("%s",iK(om)),"txtstart size20")jZ[#jZ+1]=gM(ly(1285),lz(45),"MASS","txtstart")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1285),lz(31),ly(90))jZ[#jZ+1]=gM(ly(1375),lz(26),dj("%s",ol),"size20")jZ[#jZ+1]=gM(ly(1220),of,"THRUST","txtstart")jZ[#jZ+1]=dj([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ly(1220),oh,ly(80))jZ[#jZ+1]=gM(ly(1300),og,dj("%s",oo),"size20")jZ[#jZ+1]=gM(jd(960),je(175),jh,"pbright txtbig txtmid size20")end;jZ[#jZ+1]="</g>"end;local os=1-(a7*0.05+a8*0.05)function nZ.FuelUsed(ot)local ou;if ot=="atmofueltank"then ou=dj("Atmo Fuel Used: %.1f L",jA[ot]/(4*os))elseif ot=="spacefueltank"then ou=dj("Space Fuel Used: %.1f L",jA[ot]/(6*os))else ou=dj("Rocket Fuel Used: %.1f L",jA[ot]/(0.8*os))end;return ou end;local ov,ow,ox,oy,oz=0,0,0,{},0;function nZ.DrawOdometer(jZ,j7,bn,j8)if bJ~="INFO"then return jZ end;local od;local oj=0;local ok=0;local oe=0;local ol=ci>1000000 and fU(ci/1000000,2).." kTons"or fU(ci/1000,2).." Tons"if cf then oe=bu else oe=bs end;local om,on=co.computeDistanceAndTime(cK,0,ci,0,0,oe)oe=fU(oe/(ci*iO),2).." g"local oo=d:maxForceForward()od=b.getGravityIntensity()if od>0.1 then ok=ci*od;ok=fU(ok/(ci*iO),2).." g"oj=0.5*oo/od;oj=oj>1000000 and fU(oj/1000000,2).." kTons"or fU(oj/1000,2).." Tons"end;oo=fU(oo/(ci*iO),2).." g"if iF()==0 or m then local oA=jd(aB+10)local oB=je(aC+20)local oC=jd(aB+10+aA/1.25)local nj=25;local oD=bM(1/aT)if ox<oD then oz=oz+a.getActionUpdateDeltaTime()ox=ox+1 else ov=1/(oz/oD)table.insert(oy,ov)ox,oz=0,0 end;ow=0;for dK,dw in pairs(oy)do ow=ow+dw end;if#oy>0 then ow=bM(ow/#oy)end;if#oy>29 then table.remove(oy,1)end;jZ[#jZ+1]="<g class='txtstart size14 bright'>"jZ[#jZ+1]=gM(oA,oB,dj("BrkTime: %s",iL(on)))jZ[#jZ+1]=gM(oC,oB,dj("Trip: %.2f km",j7))jZ[#jZ+1]=gM(oA,oB+nj,dj("Lifetime: %.2f kSU",bn/200000))jZ[#jZ+1]=gM(oC,oB+nj,dj("BrkDist: %s",iK(om)))jZ[#jZ+1]=gM(oA,oB+nj*2,"Trip Time: "..iL(j8))jZ[#jZ+1]=gM(oC,oB+nj*2,"Total Time: "..iL(bo))jZ[#jZ+1]=gM(oA,oB+nj*3,dj("Mass: %s",ol))jZ[#jZ+1]=gM(oC,oB+nj*3,dj("Max Brake: %s",oe))jZ[#jZ+1]=gM(oA,oB+nj*4,dj("Max Thrust: %s",oo))if od>0.1 then jZ[#jZ+1]=gM(oC,oB+nj*4,dj("Max Thrust Mass: %s",oj))jZ[#jZ+1]=gM(oA,oB+nj*5,dj("Req Thrust: %s",ok))else jZ[#jZ+1]=gM(oC,oB+nj*4,"Max Mass: n/a")jZ[#jZ+1]=gM(oA,oB+nj*5,"Req Thrust: n/a")end;jZ[#jZ+1]=gM(oC,oB+nj*5,cq.FuelUsed("atmofueltank"))jZ[#jZ+1]=gM(oA,oB+nj*6,cq.FuelUsed("spacefueltank"))jZ[#jZ+1]=gM(oC,oB+nj*6,cq.FuelUsed("rocketfueltank"))jZ[#jZ+1]=gM(oA,oB+nj*7,dj("Set Max Speed: %s",bM(a1*3.6+0.5)))jZ[#jZ+1]=gM(oC,oB+nj*7,dj("Actual Max Speed: %s",bM(de*3.6+0.5)))jZ[#jZ+1]=gM(oA,oB+nj*8,dj("Friction Burn Speed: %s",bM(bO.getFrictionBurnSpeed()*3.6)))jZ[#jZ+1]=gM(oC,oB+nj*8,dj("FPS (Avg): %s (%s)",bM(ov),ow))end;jZ[#jZ+1]="</g></g>"return jZ end;function nZ.DrawWarnings(jZ)return le(jZ)end;function nZ.DisplayOrbitScreen(jZ)return lT(jZ)end;function nZ.DisplayMessage(jZ,lp)if lp~="empty"then local hH=310;for ls in string.gmatch(lp,"([^\n]+)")do hH=hH+35;jZ[#jZ+1]=gM("50%",hH,ls,"msg")end end;if c3~=0 then c.setTimer("msgTick",c3)c3=0 end end;function nZ.DrawDeadZone(jZ)jZ[#jZ+1]=dj([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],az)end;function nZ.UpdatePipe()if cf then iY=""return end;n8()end;function nZ.DrawSettings(jZ)local hG=jd(640)local hH=je(200)jZ[#jZ+1]=[[<g class="pbright txtvspd txtstart">]]local hX=0;for dK,dw in pairs(iX)do hX=hX+1;jZ[#jZ+1]=gM(hG,hH,dK..": "..dw.get())hH=hH+20;if hX%12==0 then hG=hG+jd(350)hH=je(200)end end;jZ[#jZ+1]=gM(jd(640),je(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jZ[#jZ+1]="</g>"return jZ end;local id=je(125)local ic=jd(1225)function nZ.DrawRadarInfo()ie=ct.GetRadarHud(ic,id,ax,ay)if ie then gX=true end end;function nZ.DrawTanks()if at~=0 and au~=0 then ji=gM(at,au,"","txtstart pdim txtfuel")jB=au;jC(at,"Atmospheric ","ATMO",ck,jy,jz)jC(at,"Space Fuel T","SPACE",cl,jw,jx)jC(at,"Rocket Fuel ","ROCKET",cm,ju,jv)end end;function nZ.DrawShield()local ip=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oE=bO.getPvPTimer()local oF=shield.getResistances()local oG="A: "..10+oF[1]*100 .."% / E: "..10+oF[2]*100 .."% / K:"..10+oF[3]*100 .."% / T: "..10+oF[4]*100 .."%"local hG,hH=av-60,aw+30;local jR=bM(df*2.55)local jS=dj("rgb(%d,%d,%d)",255-jR,jR,0)local jT=""jj=gM(hG,hH,"","txtmid pdim txtfuel")if df<10 and ip~="Shield Disabled"then jT="red "end;oE=oE>0 and"   PvPTime: "..iL(oE)or""jj=jj..dj([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hG,hH,jS,df*2,hG,hH,hG+2,hH+10,df,oE)jj=jj..gM(hG,hH-5,ip,jT.."txtstart pbright txtbig")jj=jj..gM(hG,hH+30,oG,jT.."txtstart pbright txtsmall")end;function nZ.hudtick()if not kB then return end;local function oH(jZ)local jV=bM(dk(dc/(ac/4)*255,0,255))jZ[#jZ+1]=dj("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bM(j2+0.5)+jV,bM(j3+0.5)-jV,bM(j4+0.5)-jV)end;local function oI()if c1 then for dP,dw in pairs(iP)do if dw.hovered then if not dw.drawCondition or dw.drawCondition(dw)then dw.toggleFunction(dw)end;dw.hovered=false end end;for dP,dw in pairs(iS)do if dw.hovered then bJ=dw.label;dw.hovered=false end end;c1=false end end;local function oJ()local function oK(oL,oM,hG,hH,ni,nj)if oL>=hG and oL<=hG+ni and oM>=hH and oM<=hH+nj then return true else return false end end;local hG=c8+ac/2;local hH=c9+ad/2;for dP,dw in pairs(iP)do dw.hovered=oK(hG,hH,dw.x,dw.y,dw.width,dw.height)end;for dP,dw in pairs(iS)do dw.hovered=oK(hG,hH,dw.x,dw.y,dw.width,dw.height)end;if c_ then local mY=false;for dP,eC in ipairs(nV)do if eC.hovered then mY=true;break end end;if nS.hovered then mY=true end;c_=mY else c_=nS.hovered;if not c_ then d0=bl end end end;local function oN(jZ)if not bJ or bJ==""then bJ="HELP"end;if w then for dK,dw in pairs(iS)do local jT="dim brightstroke"local oO=0.2;if bJ==dK then jT="pbright dimstroke"oO=0.6 end;local oP=""if dw.hovered then oO=0.8;oP=";stroke:white"end;jZ[#jZ+1]=dj([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dw.width,dw.height,dw.x,dw.y,jT,oO,oP)jZ[#jZ+1]=gM(dw.x+dw.width/2,dw.y+dw.height/2+5,dw.label,"txt txtmid pdim")end end end;local function oQ(jZ)local function oR(jZ,oS,hover,hG,hH,fh,oT,oU,oV,oW,oX,nW)if type(oW)=="function"then oW=oW(nW)end;if type(oX)=="function"then oX=oX(nW)end;jZ[#jZ+1]=dj("<rect x='%f' y='%f' width='%f' height='%f' fill='",hG,hH,fh,oT)if oS then jZ[#jZ+1]=dj("%s'",oU)else jZ[#jZ+1]=oV end;if hover then jZ[#jZ+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",af,ag,ah)else jZ[#jZ+1]=dj(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fU(af*0.5,0),fU(ag*0.5,0),fU(ah*0.5,0))end;jZ[#jZ+1]=" rx='5'></rect>"jZ[#jZ+1]=dj("<text x='%f' y='%f' font-size='24' fill='",hG+fh/2,hH+oT/2+5)if oS then jZ[#jZ+1]="black"else jZ[#jZ+1]="white"end;jZ[#jZ+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oS then jZ[#jZ+1]=dj("%s</text>",oW)else jZ[#jZ+1]=dj("%s</text>",oX)end end;local oY=dj("rgb(%d,%d,%d)'",fU(af*0.1,0),fU(ag*0.1,0),fU(ah*0.1,0))local oZ=dj("rgb(%d,%d,%d)",fU(af*0.8,0),fU(ag*0.8,0),fU(ah*0.8,0))local o_=oR;for dP,dw in pairs(iP)do local nn=dw.disableName;local nm=dw.enableName;if type(nn)=="function"then nn=nn(dw)end;if type(nm)=="function"then nm=nm(dw)end;if not dw.drawCondition or dw.drawCondition(dw)then o_(jZ,dw.toggleVar(dw),dw.hovered,dw.x,dw.y,dw.width,dw.height,oZ,oY,nn,nm,dw)end end end;local p0=fU(ac/2,0)local p1=fU(ad/2,0)local jZ={}if p2 then jZ[#jZ+1]=p2 end;cq.HUDPrologue(jZ)if w then cq.UpdateHud(jZ)else if A then cq.DrawVerticalSpeed(jZ,ch)end;cq.DrawWarnings(jZ)end;if iW and iX~="none"then cq.DrawSettings(jZ)end;if ct then cq.DrawRadarInfo()else ie=""end;cq.HUDEpilogue(jZ)jZ[#jZ+1]=dj([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ac,ad)if c2~="empty"then cq.DisplayMessage(jZ,c2)end;if iF()==0 and g=="virtual joystick"then if v then cq.DrawDeadZone(jZ)end end;oN(jZ)if iH()==0 then if iF()==1 and c0 then if not p3 then oJ()oQ(jZ)end;if not cw and not cx then local p4=table.concat(jZ,"")jZ={}jZ[#jZ+1]=dj("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jZ[#jZ+1]=p4;jZ[#jZ+1]="</body>"cw=true;jZ[#jZ+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cx then local p4=table.concat(jZ,"")jZ={}jZ[#jZ+1]=dj("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ac,ad)jZ[#jZ+1]=p4;jZ[#jZ+1]="</body>"end;if not cw then jZ[#jZ+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,c8,c9)end else oI()end else if not c0 and iF()==0 then oI()if dc>az then if v then oH(jZ)end end elseif c0 and(not p3 or not j)then oJ()oQ(jZ)end;jZ[#jZ+1]=dj([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p0,p1,c8,c9)end;jZ[#jZ+1]=[[</svg></body>]]p5=table.concat(jZ,"")end;function nZ.TenthTick()local function p6()local p7=a.createData;local p8=a.createWidget;p9=a.createWidgetPanel("Interplanetary Helper")pa=p8(p9,"value")pb=p7('{"label": "Target Planet", "value": "N/A", "unit":""}')fS(pb,pa)pc=p8(p9,"value")pd=p7('{"label": "distance", "value": "N/A", "unit":""}')fS(pd,pc)gl=p8(p9,"value")gk=p7('{"label": "Travel Time", "value": "N/A", "unit":""}')fS(gk,gl)gj=p8(p9,"value")gi=p7('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fS(gi,gj)gn=p8(p9,"value")gm=p7('{"label": "Target Altitude", "value": "N/A", "unit":""}')fS(gm,gn)gf=p8(p9,"value")ge=p7('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gd=p8(p9,"value")gc=p7('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gb=p8(p9,"value")ga=p7('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g9=p8(p9,"value")g8=p7('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gh=p8(p9,"value")gg=p7('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cf then fS(ge,gf)fS(gc,gd)fS(ga,gb)fS(g8,g9)fS(gg,gh)end end;local function pe()gL(p9)p9=nil end;cq.DrawTanks()if shield then cq.DrawShield()end;if bj~="None"then if p9==nil then p6()end;if bj~=nil then local mz;local pf=g4~=nil;local pg=0.5*bu/c7:getGravity(c7.center+vec3(0,0,1)*c7.radius):len()pg=pg>1000000 and fU(pg/1000000,2).." kTons"or fU(pg/1000,2).." Tons"fR(pb,'{"label": "Target", "value": "'..bj..'", "unit":""}')if pf and not b3 then mz=(cN-g4.position):len()else mz=(bk-cN):len()end;if not b4 then c5,c6=cs.GetAutopilotBrakeDistanceAndTime(cK)i_,j0=cs.GetAutopilotBrakeDistanceAndTime(a1)else c5,c6=cs.GetAutopilotTBBrakeDistanceAndTime(cK)i_,j0=cs.GetAutopilotTBBrakeDistanceAndTime(a1)end;local lp=iK(mz)fR(pd,'{"label": "distance", "value": "'..lp..'"}')fR(gk,'{"label": "Travel Time", "value": "'..iL(lv)..'", "unit":""}')lp=iK(c5)fR(ge,'{"label": "Cur Brake distance", "value": "'..lp..'"}')fR(gc,'{"label": "Cur Brake Time", "value": "'..iL(c6)..'", "unit":""}')lp=iK(i_)fR(ga,'{"label": "Max Brake distance", "value": "'..lp..'"}')fR(g8,'{"label": "Max Brake Time", "value": "'..iL(j0)..'", "unit":""}')fR(gi,'{"label": "Max Brake Mass", "value": "'..dj("%s",pg)..'", "unit":""}')lp=iK(go)fR(gm,'{"label": "Target Orbit", "value": "'..lp..'"}')if cf and not ph then a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)ph=true;if not cQ and t and(b5 or b8 or cd)then cs.cmdThrottle(1)b0=false;bU=false end end;if not cf and ph then if fR(g8,g9)==1 then fS(g8,g9)end;if fR(ga,gb)==1 then fS(ga,gb)end;if fR(gc,gd)==1 then fS(gc,gd)end;if fR(ge,gf)==1 then fS(ge,gf)end;if fR(gg,gh)==1 then fS(gg,gh)end;ph=false end end else pe()end;if warpdrive~=nil then local pi=iD(warpdrive.getWidgetData())if pi.destination~="Unknown"and pi.distance>400000 then if not jc then warpdrive.showWidget()jc=true end elseif jc then warpdrive.hideWidget()jc=false end end end;function nZ.OneSecondTick()local function pj()local jM=bL()local la=cK;local pk=jM-ja;if la>1.38889 then la=la/1000;local pl=la*(jM-ja)bn=bn+pl;j7=j7+pl end;j8=j8+pk;bo=bo+pk;ja=jM end;local function pm(jZ)local pn=0;local po=iN;local pp=0;local pq=0;local pr=0;local jR=0;local jS=""local ps=b.getElementHitPointsById;local pt=b.getElementMaxHitPointsById;local pu={}for dK in pairs(iM)do local pv=0;local pw=0;pw=pt(iM[dK])pv=ps(iM[dK])pp=pp+pv;if pv+1<pw then if pv==0 then pr=pr+1 else pq=pq+1 end;if jb and#pu==0 then fW=vec3(b.getElementPositionById(iM[dK]))local hG=fW.x;local hH=fW.y;local hI=fW.z;table.insert(pu,b.spawnArrowSticker(hG,hH,hI+1,"down"))table.insert(pu,b.spawnArrowSticker(hG,hH,hI+1,"down"))b.rotateSticker(pu[2],0,0,90)table.insert(pu,b.spawnArrowSticker(hG+1,hH,hI,"north"))table.insert(pu,b.spawnArrowSticker(hG+1,hH,hI,"north"))b.rotateSticker(pu[4],90,90,0)table.insert(pu,b.spawnArrowSticker(hG-1,hH,hI,"south"))table.insert(pu,b.spawnArrowSticker(hG-1,hH,hI,"south"))b.rotateSticker(pu[6],90,-90,0)table.insert(pu,b.spawnArrowSticker(hG,hH-1,hI,"east"))table.insert(pu,b.spawnArrowSticker(hG,hH-1,hI,"east"))b.rotateSticker(pu[8],90,0,90)table.insert(pu,b.spawnArrowSticker(hG,hH+1,hI,"west"))table.insert(pu,b.spawnArrowSticker(hG,hH+1,hI,"west"))b.rotateSticker(pu[10],-90,0,90)table.insert(pu,iM[dK])end elseif jb and#pu>0 and pu[11]==iM[dK]then for jL in pairs(pu)do b.deleteSticker(pu[jL])end;pu={}end end;pn=fU(pp/po*100,2)if pr>0 or pq>0 then jZ[#jZ+1]=gM(0,0,"","pbright txt")jR=bM(pn*2.55)jS=dj("rgb(%d,%d,%d)",255-jR,jR,0)jZ[#jZ+1]=gM("50%",1035,"Elemental Integrity: "..pn.."%","txtbig txtmid","fill:"..jS)if pr>0 then jZ[#jZ+1]=gM("50%",1055,"Disabled Modules: "..pr.." Damaged Modules: "..pq,"txtbig txtmid","fill:"..jS)elseif pq>0 then jZ[#jZ+1]=gM("50%",1055,"Damaged Modules: "..pq,"txtbig txtmid","fill:"..jS)end end end;local function px()if iC then if j1==nil and(hk~=nil or bm)then _autoconf.displayCategoryPanel(iC,weapon_size,"Weapons","weapon",true)j1=_autoconf.panels[_autoconf.panels_size]elseif j1~=nil and hk==nil and not bm then gL(j1)j1=nil end end end;d1=bO.getPlayersOnBoard()d2=bO.getDockedConstructs()local jZ={}pj()if s then pm(jZ)end;px()cq.UpdatePipe()cq.ExtraData(jZ)j9=table.concat(jZ,"")end;function nZ.AnimateTick()cx=true;cw=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nZ.MsgTick()local jZ={}cq.DisplayMessage(jZ,"empty")c2="empty"c.stopTimer("msgTick")c3=3 end;function nZ.ButtonSetup()ny()nD()iP=iQ end;if py then for dK,dw in pairs(py)do nZ[dK]=dw end end;return nZ end;local function pz(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,eY,bM,bN,iF,eT,bL,dk,iG,fR,iH,dm,fU,fT,iI,dn,iK,iL,pB,iD)local a=DUSystem;local bO=DUConstruct;local pC={}local pD=false;local pE=0;local pF=0;local pG=0;local pH=bL()local pI=0;local pJ=0;local pK=0;local pL=0;local pM=false;local pN=false;local pO=false;local pP=nil;local pQ=0;local iZ=55;local pR=nil;local pS=false;local pT=false;local pU=false;local pV=0;local pW=0;local pX=0;local pY=0;local pZ=0;local p_={VectorToTarget=false}local q0=vec3(bO.getWorldOrientationUp())local q1=nil;local q2=0;local q3=-1;local q4=-1;local q5=false;local q6=false;local q7=0;local q8=false;local q9=false;local qa=false;local qb=false;local qc=""local qd=false;local qe=false;local qf=""local qg=false;local qh=0;local function qi()return bO.isInPvPZone()~=1,eY(bO.getDistanceToSafeZone())end;local function qj(fo)local qk=bf;if not b3 then qk=0 end;local ql=bs;if cf then if bu and bu>0 then ql=bu else return 0,0 end end;return co.computeDistanceAndTime(fo,qk,ci,0,0,ql-bh*ci)end;local function qm(fo)local qk=bf;if not b3 then qk=0 end;return co.computeDistanceAndTime(fo,qk,ci,d:maxForceForward(),a3,bs-bh*ci)end;local function qn(qo,qp,qq)qp=qp:project_on_plane(qo)qq=qq:project_on_plane(qo)return eT(qp:cross(qq):dot(qo),qp:dot(qq))end;local qr;local qs;if hover then qs=hover.getMaxDistance()*2 end;if vBooster then qr=vBooster.getMaxDistance()*2 end;local function qt()local function qu()local qv=-1;local qw=-1;if vBooster then qv=vBooster.getDistance()if qv>qr then qv=-1 end end;if hover then qw=hover.getDistance()if qw>qs then qw=-1 end end;if qv~=-1 and qw~=-1 then if qv<qw then return qv else return qw end elseif qv~=-1 then return qv elseif qw~=-1 then return qw else return-1 end end;local qx=qu()local qy=-1;if antigrav and antigrav.isActive()==1 and not r and cK<iZ then local qz=eY(ch-antigrav.getBaseAltitude())if qz<50 then return qz end end;if pA then qy=pA.raycast().distance;if qy==0 then qy=-1 end end;if qx~=-1 and qy~=-1 then if qx<qy then return qx else return qy end elseif qx~=-1 then return qx else return qy end end;local function qA(kB,eK,qB)local function qC(qD,dW)local eQ=vec3(dW)if qD.id==0 then return setmetatable({latitude=eQ.x,longitude=eQ.y,altitude=eQ.z,id=0,systemId=qD.systemId},dY)end;local eR=eQ-qD.center;local ca=eR:len()local e2=ca-qD.radius;local e0=0;local e1=0;if not dn(ca,0)then local eS=eT(eR.y,eR.x)e1=eS>=0 and eS or 2*math.pi+eS;e0=math.pi/2-math.acos(eR.z/ca)end;return setmetatable({latitude=math.deg(e0),longitude=math.deg(e1),altitude=e2,id=qD.id,systemId=qD.systemId},dY)end;local qE=qC(kB,eK)qE="::pos{"..qE.systemId..","..qE.id..","..qE.latitude..","..qE.longitude..","..qE.altitude.."}"if qB then return qE else qa=qE;return true end end;local function qF(qG,qH,qI)local function qJ(qG,et)qG=vec3(qG)et=vec3(et):normalize()local dF=qG*et;return dF.x+dF.y+dF.z end;local qK=0.001;local qL=1;if not cf or not cz or ce~=-1 or cK<iZ then if qI==nil then qI=aS end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=vec3()-qG;local qN=-qJ(qM,bO.getWorldOrientationRight())*qL;local qO=-qJ(qM,bO.getWorldOrientationUp())*qL;if pF==0 then pF=qN/2 end;if pG==0 then pG=qO/2 end;if eY(qN)<0.1 then pW=pW-qN*2 else pW=pW-(qN+(qN-pF)*qI)end;if eY(qO)<0.1 then pV=pV+qO*2 else pV=pV+qO+(qO-pG)*qI end;pF=qN;pG=qO;if eY(qN)<qH and eY(qO)<qH then return true end;return false elseif cz and ce==-1 then qG=cJ;if qI==nil then qI=aS end;if qH==nil then qH=qK end;qG=vec3(qG):normalize()local qM=cG-qG;local qN=-qJ(qM,bO.getWorldOrientationRight())*qL;local qO=-qJ(qM,bO.getWorldOrientationUp())*qL;if pF==0 then pF=qN/2 end;if pG==0 then pG=qO/2 end;if eY(qN)<0.1 then pW=pW-qN*5 else pW=pW-(qN+(qN-pF)*qI)end;if eY(qO)<0.1 then pV=pV+qO*5 else pV=pV+qO+(qO-pG)*qI end;pF=qN;pG=qO;if eY(qN)<qH and eY(qO)<qH then return true end;return false end end;function pC.clearAll()bb=false;bd=false;be=false;b3=false;bc=false;bg="Aligning"b1=false;b2=false;cW=nil;b5=false;b8=false;b6=false;b7=false;b9=false;b_=false;pT=false;cb=false;cc=false;pU=false;cy=q;bq=false;b4=false;cj=false;bt=nil;bz=false;da=false;db=nil end;function pC.GetAutopilotBrakeDistanceAndTime(fo)return qj(fo)end;function pC.GetAutopilotTBBrakeDistanceAndTime(fo)return qm(fo)end;function pC.showWayPoint(kB,eK,qB)return qA(kB,eK,qB)end;function pC.APTick()local qP=a.getMouseWheel()if qP>0 then cs.changeSpd()elseif qP<0 then cs.changeSpd(true)else pS=true end;q7=iH()if qa then a.setWaypoint(qa)qa=false end;if qd then antigrav.setTargetAltitude(qd)qd=false end;if qb then fR(qb,qc)qb=false;qc=""end;if q4~=-1 then cs.cmdCruise(q4,q5)q5=false;q4=-1 end;if q1~=nil then if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iG:getTargetSpeed(axisCommandId.longitudinal)~=q1 then iG:setTargetSpeedCommand(axisCommandId.longitudinal,q1)else q1=nil end end;if q3~=-1 then cs.cmdThrottle(q3,q5)q5=false;q3=-1 end;if q6 then cu.landingGear(q6)q6=false end;if qe then cs.ToggleAutopilot()end end;function pC.ToggleIntoOrbit()cD=false;pK=nil;pL=nil;pQ=0;if not cf then if bz then fT("orOff","AP")bz=false;pM=false;pP=nil;cy=q;if b5 then b5=false;b7=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pO=false elseif cX then fT("orOn","AP")bz=true;cy=true;if pP==nil then pP=kB end;if b5 then b5=false;b7=false end else c2="Unable to engage auto-orbit, not near a planet"end else bz=false;pM=false;pP=nil;cy=q;if b5 then b5=false end;p_.VectorToTarget=false;p_.AutopilotAlign=false;pO=false end end;function pC.ToggleVerticalTakeoff()b5=false;if b9 then lr=true;b8=false;b7=false;b6=true;cy=true;bZ=0;if cf and ce==-1 then b6=false;b5=true;bZ=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q4=bM(cA)end else cD=false;bm=false;d.control.retractLandingGears()iG:setTargetGroundAltitude(Z)b0="VTO Takeoff"end;b9=not b9 end;function pC.checkLOS(qG)local lt,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,qG,function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lu=eI;if eJ~=nil and eI~=nil then lu=math.min(eJ,eI)end;if lu~=nil then return lt,lu else return nil,nil end end;local function qQ(qR,qS)if qS then bZ=0;iG:updateCommandFromActionStop(axisCommandId.vertical,qS)if bB then iG:activateGroundEngineAltitudeStabilization(qT)dd=true end else bZ=bZ+qR;iG:deactivateGroundEngineAltitudeStabilization()iG:updateCommandFromActionStart(axisCommandId.vertical,qR)end end;function pC.vertical(qR,qS)qQ(qR,qS)end;function pC.ToggleAutopilot()local function qU(bx)cY=false;bq=not bq;if bq then b4=false;if not b5 and not bx then cs.ToggleAltitudeHold()end end;lx="Proceeding to Waypoint"end;local function qV(gx)if gx then for M,dK in pairs(cT)do if dK.name and dK.name==gx then return M end end else return 0 end end;local qW=false;bH=false;if bP-pJ<1.5 and cf then if not cF then if cf then ba=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude;fT("11","EP")pJ=-1;if b3 or bq or bz then return end else c2="No space engines detected, Orbital Hop not supported"return end elseif kB.hasAtmosphere then if cf then ba=kB.noAtmosphericDensityAltitude+V;fT("orH","OH")end;pJ=-1;if b3 or bq or bz then return end end else pJ=bP end;qX=false;if(bl>0 or#bF>0)and not b3 and not bq and not cc and not bz then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ci then c2="WARNING: Heavy Loads may affect autopilot performance."c3=5 end;if#bF>0 and not cd then bl=qV(bF[1])cr.UpdateAutopilotTarget()c2="Route Autopilot in Progress"local qM=g4.position-cN;local qY=qM:project_on_plane(cL):len()if qY>50000 and g4.planetname==kB.name then qW=true end end;cr.UpdateAutopilotTarget()cs.showWayPoint(c7,bk)if g4~=nil then if g4.agg and not r and antigrav then if not cP then cs.ToggleAntigrav()end;bv=g4.agg end;bt=nil;bx=g4.planetname=="Space"if bx then fT("apSpc","AP")if cf then cc=true;cs.ToggleAltitudeHold()else b3=true end elseif kB.name==g4.planetname then lr=true;if cf then if not bq then fT("vtt","AP")qU(bx)if qW then ba=kB.noAtmosphericDensityAltitude+V end end else fT("apOn","AP")if not(c7.name==kB.name and ch<go*1.5)then cD=false;b3=true elseif not cf then if bz then cs.ToggleIntoOrbit()end;cC=kB.noAtmosphericDensityAltitude+V;pO=true;p_.AutopilotAlign=true;p_.VectorToTarget=true;pM=false;if not bz then cs.ToggleIntoOrbit()end end end else fT("apP","AP")b1=false;b2=false;if cf then cc=true;cs.ToggleAltitudeHold()else b3=true end end elseif not cf then if g4==nil and(c7.name==kB.name and cX)and not bz then qZ=false;cD=false;pM=false;cs.ToggleIntoOrbit()else fT("apP","AP")b3=true;b1=false;b2=false;bc=false;b_=false;b5=false;b6=false;b8=false;b7=false;pT=false;bt=nil;qZ=false end else fT("apP","AP")cc=true;cs.ToggleAltitudeHold()end;qe=false else fT("apOff","AP")cs.ResetAutopilots(1)if qe==2 then qe=true end end end;function pC.routeWP(q_,r0,r1)if r1 then if r1==1 then bF={}bF=iI(bF,bE)if#bF>0 then c2="Route Loaded"else c2="No Saved Route found on Databank"end;return bF else bE={}bE=iI(bE,bF)c2="Route Saved"pB()return end end;if q_ then return bF end;if r0 then bF={}c2="Current Route Cleared"else bF[#bF+1]=g4.name;c2="Added "..g4.name.." to route. "end;return bF end;function pC.cmdThrottle(dL,r2)if iG:getAxisCommandType(0)~=axisCommandType.byThrottle and not r2 then d.control.cancelCurrentControlMasterMode()end;iG:setThrottleCommand(axisCommandId.longitudinal,dL)bQ=dk(fU(dL*100,0)/100,-1,1)q1=nil end;function pC.cmdCruise(dL,r2)if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r2 then d.control.cancelCurrentControlMasterMode()end;iG:setTargetSpeedCommand(axisCommandId.longitudinal,dL)q1=dL end;function pC.ToggleLockPitch()if bt==nil then fT("lkPOn","LP")if not c0 then bt=cR else bt=S end;b7=false;b5=false;b6=false else fT("lkPOff","LP")bt=nil end end;function pC.ToggleAltitudeHold()if bP-pI<1.5 then bH=false;if kB.hasAtmosphere then if cf then ba=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude;fT("11","EP")else if cX then ba=kB.noAtmosphericDensityAltitude+V;cC=ba;pO=true;if not bz then cs.ToggleIntoOrbit()end;pM=true end end;pI=-1;if b5 or bz or b9 then return end end else pI=bP end;if cX and not cf and ce==-1 then cC=ch;pO=true;pM=true;cs.ToggleIntoOrbit()if bz then pI=bP else pI=0 end;return end;b5=not b5;b6=false;b8=false;if b5 then b3=false;b2=false;b1=false;b_=false;cy=true;bt=nil;cD=false;if ce~=-1 then if not bm and not bq then ba=ch;bH=ce;iG:setTargetGroundAltitude(bH)elseif cK<20 then if bm then cu.landingGear()end;fT("lfs","LS")b7=true;if cf then ba=ch+Y else ba=kB.surfaceMaxAltitude+100 end;b0="ATO Hold"iG:setTargetGroundAltitude(Z)if a_ and cO then cs.ToggleVerticalTakeoff()end end else fT("altOn","AH")b7=false;if pI>-1 then if cX then ba=ch end end;if b9 then cs.ToggleVerticalTakeoff()end end;if cP and not r then local r3=antigrav.getBaseAltitude()if bq and g4.agg and g4.agg>ch then ba=g4.agg elseif b7 then ba=r3 end;if eY(ch-r3)<100 and cK<20 then ba=r3;b0="AGG Hold"q3=0 end end;if cc then ba=200000 end else fT("altOff","AH")if bz then cs.ToggleIntoOrbit()end;if b9 then cs.ToggleVerticalTakeoff()end;cy=q;b7=false;bq=false;pI=0;bH=false end end;function pC.ResetAutopilots(pC)if pC then cc=false;b3=false;bc=false;pT=false;ba=ch;qX=false;da=false;bg="Aligning"end;bq=false;b7=false;b8=false;b2=false;b6=false;db=nil;r4=false;cW=nil;da=false;if not cP then b5=false;bt=nil end;if b9 then cs.ToggleVerticalTakeoff()end;if bz then cs.ToggleIntoOrbit()end;cy=q;cb=false;cd=false;bZ=0 end;function pC.BrakeToggle(r5)if not b0 then if r5 then b0=r5 else b0=true end else b0=false end;if b6 then b6=false;cy=q;da=false end;if b0 then fT("bkOn","B",1)cs.ResetAutopilots()else fT("bkOff","B",1)end end;function pC.BeginReentry()if b8 then c2="Re-Entry cancelled"fT("reOff","RE")b8=false;cy=q;b5=false elseif not kB.hasAtmosphere then c2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"c3=5 elseif not pU then b8=true;if iG:getAxisCommandType(0)~=r6.cruise then d.control.cancelCurrentControlMasterMode()end;cy=true;b0=false;c2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cA;fT("par","RE")else b8=true;b5=true;cy=true;b0=false;ba=kB.surfaceMaxAltitude+a0;if ba>kB.spaceEngineMinAltitude then ba=kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude end;local r7=iK(ba)c2="Beginning Re-entry.  Target speed: "..cA.." Target Altitude: "..r7;fT("glide","RE")q4=bM(cA)end;b7=false end;function pC.ToggleAntigrav()if antigrav and not r then if cP then fT("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bv==nil then bv=ch end;if bv<1000 then bv=1000 end;fT("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pC.changeSpd(r8)local r9=1;if r8 then r9=-1 end;if not c0 then if t and not p3 and pS then local ra=bQ;bQ=fU(dk(bQ+r9*aE/100,-1,1),2)if bQ>=0 and ra<0 then bQ=0;pS=false end elseif p3 then if cf or b8 then cA=dk(cA+r9*aE,0,W)elseif b3 then a1=dk(a1+r9*aE/3.6*100,0,de-0.2)end else iG:updateCommandFromActionStart(axisCommandId.longitudinal,r9*aE/10)end else if b3 or bq or cc or bz then d0=d0+1*r9*-1;if d0>#cT then d0=1 end;if d0<1 then d0=#cT end else if not r8 then r9=1 else r9=nil end;cr.adjustAutopilotTargetIndex(r9)end end end;function pC.TenthTick()local function rb()if not b3 then if g4==nil or g4.planetname~=kB.name then rc=(c7.center-cN):len()else rc=(g4.position-cN):len()end end;local fo=cK;local rd=c.getThrottle()/100;if t then rd=bQ end;local re,rf=co.computeDistanceAndTime(cK,a1,ci,d:maxForceForward()*rd,a3,0)local c5,c6;if not b4 then c5,c6=cs.GetAutopilotBrakeDistanceAndTime(a1)else c5,c6=cs.GetAutopilotTBBrakeDistanceAndTime(a1)end;local dP,rg;if not b4 and fo>0 then dP,rg=cs.GetAutopilotBrakeDistanceAndTime(fo)else dP,rg=cs.GetAutopilotTBBrakeDistanceAndTime(fo)end;local rh=0;local ri=0;if be or not b3 and fo>5 then ri=co.computeTravelTime(fo,0,rc)elseif c5+re<rc then rh=rc-(c5+re)ri=co.computeTravelTime(8333.0556,0,rh)else local rj=(rc-c5)/re;re=rc-c5;rf=rf*rj end;if g4~=nil and g4.planetname==kB.name and not b3 then return ri elseif bd then return rg elseif be then return ri+rg else return rf+c6+ri end end;local function rk(od,rl)if od==nil then od=b.getGravityIntensity()end;od=fU(od,5)if rl~=nil and rl or(pR==nil or pR~=od)then local fo=cI:len()local rm=iD(c.getWidgetData()).maxBrake;if rm~=nil and rm>0 and cf then rm=rm/dk(fo/100,0.1,1)rm=rm/cg;if cg>0.10 then if bu then bu=(bu+rm)/2 else bu=rm end end end;if rm~=nil and rm>0 then bs=rm end;pR=od end end;cU,cV=qi()de=bO.getMaxSpeed()if bj~="None"and(c7 or g4)then lv=rb()end;rk(nil,true)end;local function rn(ro,rp)local rq=vec3()local rr=vec3()if ro==axisCommandId.longitudinal then rq=vec3(bO.getOrientationForward())rr=cG elseif ro==axisCommandId.vertical then rq=vec3(bO.getOrientationUp())rr=q0 elseif ro==axisCommandId.lateral then rq=vec3(bO.getOrientationRight())rr=cH else return vec3()end;local rs=vec3(b.getWorldGravity())local rt=rs:dot(rr)local ru=vec3(bO.getWorldAirFrictionAcceleration())local rv=ru:dot(rr)local rw=cI:dot(rq)local rx=rp*constants.kph2m;if ry==nil then ry=pid.new(10,0,10.0)end;ry:inject(rx-rw)local rz=ry:get()local rA=(rz-rv-rt)*rr;return rA end;local function rB(ro,rp)local rq=vec3()local rr=vec3()if ro==axisCommandId.longitudinal then rq=vec3(bO.getOrientationForward())rr=cG elseif ro==axisCommandId.vertical then rq=vec3(bO.getOrientationUp())rr=q0 elseif ro==axisCommandId.lateral then rq=vec3(bO.getOrientationRight())rr=cH else return vec3()end;local rs=vec3(b.getWorldGravity())local rt=rs:dot(rr)local ru=vec3(bO.getWorldAirFrictionAcceleration())local rv=ru:dot(rr)local rw=cI:dot(rq)local rx=rp*constants.kph2m;if rC==nil then rC=pid.new(10,0,10.0)end;rC:inject(rx-rw)local rz=rC:get()local rA=(rz-rv-rt)*rr;return rA end;local function rD(rE,k1,g0)local rF=rE:cross(g0):normalize_inplace()local kO=math.acos(dk(rF:dot(-k1),-1,1))*constants.rad2deg;if rF:cross(-k1):dot(g0)<0 then kO=-kO end;return kO end;local function rG()if cZ and not b6 then local er=cZ[1]local i3,i4=cZ[2],cZ[3]local rH=math.min(i3,i4 or i3)local rI=rH/cK;local rJ=b7 and(cK<42 or ce~=-1)local rK=b5 or bq or bt or b3;if rK and not rJ and(c5*1.5>rH or rI<1)then b0="Collision"bF={}q3=0;if b5 then cs.ToggleAltitudeHold()end;if bt then cs.ToggleLockPitch()end;c2="Autopilot Cancelled due to possible collision"a.print(er.name.." COLLISION "..iL(rI).." / "..iK(rH,2))cs.ResetAutopilots(1)lr=true;if cf then b6=true end;cy=true end;if rI<11 then cY=er.name.." COLLISION "..iL(rI).." / "..iK(rH,2)else cY=er.name.." collision "..iL(rI)end;if rI<6 then fT("alarm","AL",2)end else cY=false end end;local rL=1;local rM=0;local rN=1;local rO=1;local rP=1;local rQ=false;function pC.onFlush()if antigrav and not r and not cP and antigrav.getBaseAltitude()~=bv then qd=bv end;if dd then d:setEngineForceCommand('hover',vec3(),1)dd=false end;cQ=iG:getAxisCommandType(0)==axisCommandType.byThrottle;aO=math.max(aO,0.01)aP=math.max(aP,0.01)aJ=math.max(aJ,0.01)aN=math.max(aN,0.01)aQ=math.max(aQ,0.01)aR=math.max(aR,0.01)aI=math.max(aI,0.01)local rR=dk(bW+pV+a.getControlDeviceForwardInput(),-1,1)local rS=dk(bX+pX+a.getControlDeviceYawInput(),-1,1)local rT=dk(bY+pW-a.getControlDeviceLeftRightInput(),-1,1)local rU=b0 and 1 or 0;cL=vec3(b.getWorldVertical())if cL==nil or cL:len()==0 then cL=(kB.center-cN):normalize()end;q0=vec3(bO.getWorldOrientationUp())cG=vec3(bO.getWorldOrientationForward())cH=vec3(bO.getWorldOrientationRight())cJ=vec3(bO.getWorldVelocity())cI=vec3(bO.getVelocity())cN=vec3(bO.getWorldPosition())ci=bO.getMass()cK=vec3(cJ):len()cM=-cL:dot(cJ)cS=getRoll(cL,cG,cH)local rV=cS/180*math.pi;local rW=math.cos(rV)local rX=math.sin(rV)cR=rD(cL,cG,cH*rW+q0*rX)local rY=cJ:normalize()local rZ=eY(cS)local r_=utils.sign(cS)local s0=vec3(bO.getWorldAngularVelocity())local s1=rR*aO*cH+rS*aJ*cG+rT*aP*q0;if cy==true and cL:len()>0.01 then local s2=eY(pY-cS)if((b2 or b8 or b6 or cb or b5 or bz)and s2>0 or cf and s2<aK and q)and rS==0 and eY(cR)<85 then local s3=pY;local s4=aI;if not cf then s4=s4/4;pY=0;s3=0 end;if s5==nil then s5=pid.new(s4*0.01,0,s4*0.1)end;s5:inject(s3-cS)local s6=s5:get()s1=s1+s6*cG end end;bR=0;cg=bN()cf=false or ch<kB.noAtmosphericDensityAltitude and cg>0.00001;ch=b.getAltitude()ce=qt()bP=bL()pH=bP;if bm and ce>-1 and ce-3<_ then if iG.targetGroundAltitudeActivated then iG:deactivateGroundEngineAltitudeStabilization()end end;if ct then qg=not qg;if qg then ct.UpdateRadar()end;if E then rG()end end;if antigrav then cP=antigrav.isActive()==1 end;local s7=bP-pH;local s8=-math.deg(qn(q0,cJ,cG))local s9=math.deg(qn(cH,cJ,cG))local gq=cL*-1;cz=cf and s8<-N or s8>N or s9<-O or s9>O;local sa=a.getMouseDeltaX()local sb=a.getMouseDeltaY()if qh then local sc=bL()-qh;sa=sa*sc/0.016;sb=sb*sc/0.016 end;qh=bL()if p and not c0 then sb=-sb end;pW=0;pX=0;pV=0;local sd=bO.getWorldPosition()kB=fX:closestBody(sd)se=cp(kB)fs=se:orbitalParameters(sd,cJ)if ch==0 then ch=(cN-kB.center):len()-kB.radius end;cX=c.getClosestPlanetInfluence()>0 or ch>0 and ch<200000;local od=kB:getGravity(sd):len()*ci;pY=0;local sf=bO.getMaxThrustAlongAxis("ground",bO.getOrientationUp())[1]if q7==0 then if iF()==1 and c0 then if not cw then c8=dk(c8+sa/2,-ac/2,ac/2)c9=dk(c9+sb/2,-ad/2,ad/2)end else c8=0;c9=0 end else c8=dk(c8+sa/2,-ac/2,ac/2)c9=dk(c9+sb/2,-ad/2,ad/2)dc=dm(c8*c8+c9*c9)if not c0 and iF()==0 then local kX,kY=1,1;if bJ=="SCOPE"then kX,kY=d4/90,d4/90 end;if g=="virtual joystick"then if dc>az then pW=pW-dk(eY(c8)-az,0,ac/2)*utils.sign(c8)*aG*kX;pV=pV-dk(eY(c9)-az,0,ad/2)*utils.sign(c9)*aH*kY end else c8=0;c9=0;if g=="mouse"then pV=(-utils.smoothstep(sb,-100,100)+0.5)*2*rO;pW=(-utils.smoothstep(sa,-100,100)+0.5)*2*rP end end end end;local sg=cK>27777;if cK>X/3.6 and not cf and not b3 and not sg then c2="Space Speed Engine Shutoff reached"q3=0 end;if not sg and sh then if not b0 then cs.BrakeToggle()end;if b3 then cs.ResetAutopilots(1)end;q3=0 end;sh=sg;if cg>0.09 then if cK>cA/3.6 and not t and not pD then b0="SpdLmt"pD=true elseif not t and pD then if cK<cA/3.6 then b0=false;pD=false end end end;if b2 then if cb then b0=false;local si=false;si=qF(g4.position-cN,0.1)cy=true;if si then q4=bM(cA)if(eY(cS)<2 or eY(cR)>85)and cK>=cA/3.6-1 then b0=false;b2=false;if cb~=2 then pU=true end;if cb==true then cd=true end;cb=false;b3=false;cs.BeginReentry()end elseif cf and t then q3=1 end elseif cK>iZ then qF(vec3(cJ),0.01)end end;if b1 then if cf then b1=false elseif cK>iZ then qF(-vec3(cJ))end end;if not b2 and cb and not bz then if not cf then if cb~=2 then pU=true end;cs.BeginReentry()cb=false;cd=true else cb=false;if not qe then qe=true end end end;if cd and g4 and(ch<ba+250 and ch>ba-250)and cK*3.6>cA-250 and eY(cM)<25 and cg>=0.1 and(g4.position-cN):len()>2000+ch then if not qe then qe=true end;cd=false end;if b9 then cy=true;local sj=ba;if cM<-30 then c2="Unable to achieve lift. Safety Landing."bZ=0;cy=q;b9=false;b6=true elseif not r and cP or ba<kB.spaceEngineMinAltitude then if cP then sj=antigrav.getBaseAltitude()end;if ch<sj-100 then pZ=0;bZ=15;b0=false elseif cM>0 then b0="VTO Limit"bZ=0 elseif cM<-30 then b0="VTO Fall"bZ=15 elseif ch>=sj then if cP then if b3 or bq then cs.ToggleVerticalTakeoff()else b0="VTO Complete"b9=false end;c2="Takeoff complete. Singularity engaged"fT("aggLk","AG")else b0=false;c2="VTO complete. Engaging Horizontal Flight"fT("vtoc","VT")cs.ToggleVerticalTakeoff()end;bZ=0 end else if cg>0.08 then pZ=0;b0=false;bZ=20 elseif cg<0.08 and cf then b0=false;if cE then pZ=0;bZ=20 else bZ=0;pZ=36;q4=3500 end else cy=q;bz=true;cD=false;sk=false;pM=false;pK=nil;pL=nil;if pP==nil then pP=kB end;cC=sj;pO=true;b9=false end end;if pZ~=nil then if sl==nil then sl=pid.new(2*0.01,0,2*0.1)end;local sm=dk(pZ-cR,-O*0.80,O*0.80)sl:inject(sm)local sn=dk(sl:get(),-1,1)pV=sn end end;if bz then local function so()if fs.periapsis.altitude>=cC*0.99 and fs.apoapsis.altitude>=cC*0.99 and fs.periapsis.altitude<fs.apoapsis.altitude and fs.periapsis.altitude*1.05>=fs.apoapsis.altitude and eY(cC-ch)<1000 then return true else return false end end;local qM;local sp=false;local sq=iK(cC,3)if pP==nil then pP=kB;if bq then pP=c7 end end;if not pO then cC=bM(pP.radius+pP.surfaceMaxAltitude+V)if pP.hasAtmosphere then cC=bM(pP.radius+pP.noAtmosphericDensityAltitude+V)end;pO=true end;if p_.VectorToTarget and g4 then qM=g4.position-cN end;local sr,ss=cp(pP):escapeAndOrbitalSpeed((cN-pP.center):len()-pP.radius)local st=cS;if not pM then local su=false;local sv=false;q3=0;pL=0;cB="Aligning to orbital path - OrbitHeight: "..sq;if p_.VectorToTarget then qF(qM:normalize():project_on_plane(cL))sp=cG:dot(qM:project_on_plane(q0):normalize())>0.95 else qF(cJ)sp=s8<0.5;if cK<150 then sp=true end end;pV=0;pK=0;if cR<=pK+2 and cR>=pK-2 then su=true else su=false end;if st<=pL+2 and st>=pL-2 then sv=true else sv=false end;if su and sv and sp then pK=nil;pL=nil;pM=true end else if p_.VectorToTarget then qF(qM:normalize():project_on_plane(cL))elseif cK>150 then qF(cJ)end;pV=0;if p_.VectorToTarget and g4 then local c5,dP=co.computeDistanceAndTime(cK,cA/3.6,ci,0,0,bs)if cD and qM:len()>15000+c5+ch then cB="Orbiting to Target"if ch-100<=pP.noAtmosphericDensityAltitude or lv>fs.timeToPeriapsis and fs.periapsis.altitude<pP.noAtmosphericDensityAltitude or not so()and fs.eccentricity>0.1 then c2="Re-Aligning Orbit"cD=false end elseif cD or qM:len()<15000+c5+ch then c2="Orbit complete, proceeding with reentry"fT("orCom","OB")bk=g4.position;pU=true;cd=true;p_.VectorToTarget,p_.AutopilotAlign=false,false;cs.ToggleIntoOrbit()cs.BeginReentry()return end end;if fs.periapsis~=nil and fs.apoapsis~=nil and fs.eccentricity<1 and ch>cC*0.9 and ch<cC*1.4 then if fs.apoapsis~=nil then if(so()or cD)and not K then if cD then b0=false;q3=0;pK=0;if not p_.VectorToTarget then c2="Orbit complete"fT("orCom","OB")cs.ToggleIntoOrbit()end else pQ=pQ+1;if pQ>=2 then cD=true end end else if so()then cB="Maintaining "else cB="Adjusting "pN=true;q4=ss*3.6+1;local sw=cC-ch;if sx==nil then sx=pid.new(0.1,0,1*0.1)end;sx:inject(sw-cM*dk(utils.smoothstep(2000-sw,-2000,2000)^6*10,1,10))pK=dk(sx:get(),-60,60)end;cB=cB.." - OrbitHeight: "..sq end end else local sy=2.75;local sz=eY(fU(sr*sy))local os=sz%50;if os>0 then sz=sz-os+50 end;b0=false;if ch<cC*0.8 then cB="Escaping planet gravity - OrbitHeight: "..sq;pK=utils.map(cM,200,0,-15,80)elseif ch>=cC*0.8 and ch<cC*1.15 then cB="Approaching orbital corridor - OrbitHeight: "..sq;sz=sz*0.75;pK=utils.map(cM,100,-100,-15,65)elseif ch>=cC*1.15 and ch<cC*1.5 then cB="Approaching orbital corridor - OrbitHeight: "..sq;sz=sz*0.75;if cM<0 or pN then pK=utils.map(ch,cC*1.5,cC*1.01,-30,0)else pK=utils.map(ch,cC*0.99,cC*1.5,0,30)end elseif ch>cC*1.5 then cB="Reentering orbital corridor - OrbitHeight: "..sq;pK=-65;local sA=utils.map(cM,-150,-400,1,0.55)sz=sz*sA end;q4=bM(sz)end end;if pK~=nil then if sB==nil then sB=pid.new(1*0.01,0,5*0.1)end;local sC=pK-cR;sB:inject(sC)local sD=dk(sB:get(),-0.5,0.5)pV=sD end end;if b3 and not cf and not cb then local function sE(dh,fs)a.print(dh)b2=false;b0=false;bd=false;b3=false;qX=false;bg="Aligning"q3=0;pT=false;c2=dh;fT("apCom","AP")if fs or cb then if fs and go~=nil and not cb then if not ch or ch==0 then return end;cC=ch;pO=true end;cs.ToggleIntoOrbit()end end;local sF,sG=bk,false;if g4 and g4.planetname~="Space"then bc=true;if not qX then local sH=(g4.position-c7.center):normalize()local sI=sH:project_on_plane((c7.center-cN):normalize()):normalize()local sJ=c7.center+sI*(c7.radius+go)local sK=g4.position+(g4.position-c7.center):normalize()*(go-c7:getAltitude(g4.position))if(cN-sJ):len()<(cN-sK):len()then sF=sJ else sF=sK;bf=0 end;bk=sF;cs.showWayPoint(c7,bk)sG=true;qX=true end;bh=0 elseif g4 and g4.planetname=="Space"then if not qX then bh=0;sG=true;bc=true;qX=true;sF=g4.position+(cN-g4.position):normalize()*T;bk=sF end elseif g4==nil then bh=0;if not qX then local sH=(cN+cJ*100000-c7.center):normalize()local sI=sH:project_on_plane((c7.center-cN):normalize()):normalize()if sI:len()<1 then sH=(cN+cG*100000-c7.center):normalize()sI=sH:project_on_plane((c7.center-cN):normalize()):normalize()end;sF=c7.center+sI*(c7.radius+go)bk=sF;qX=true;sG=true;bc=true;cs.showWayPoint(c7,bk)end end;rc=(vec3(sF)-cN):len()local lt,eI,eJ=cn:getPlanetarySystem(0):castIntersections(cN,cJ:normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)local lu=eI;if eJ~=nil and eI~=nil then lu=math.min(eJ,eI)end;if lu~=nil and lu<rc and lt.name==c7.name then rc=lu end;local si=true;local sL=(c7.center-(cN+vec3(cJ):normalize()*rc)):len()-c7.radius;local lp=iK(sL)qb=gg;qc='{"label": "Projected Altitude", "value": "'..lp..'"}'if cK>50 and bb then local qM=vec3(sF)-cN;local sM=dk(math.deg(qn(q0,cJ:normalize(),qM:normalize()))*cK/500,-90,90)local sN=dk(math.deg(qn(cH,cJ:normalize(),qM:normalize()))*cK/500,-90,90)if eY(sM)<20 and eY(sN)<20 then sM=sM*2;sN=sN*2 end;if eY(sM)<2 and eY(sN)<2 then sM=sM*2;sN=sN*2 end;local s8=-math.deg(qn(q0,cG,cJ:normalize()))local s9=-math.deg(qn(cH,cG,cJ:normalize()))if sO==nil then sO=pid.new(2*0.01,0,2*0.1)end;sO:inject(sN-s9)local sP=dk(sO:get(),-1,1)pV=pV+sP;if sQ==nil then sQ=pid.new(2*0.01,0,2*0.1)end;sQ:inject(sM-s8)local sR=dk(sQ:get(),-1,1)pW=pW+sR;sG=true;if eY(sM)>2 or eY(sN)>2 then if bg~="Adjusting Trajectory"then bg="Adjusting Trajectory"fT("apAdj","AP")end else if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end end elseif bb and cK<=50 then qF((sF-cN):normalize())end;if sL<go*1.5 then bf=cA/3.6;if g4==nil then dP,bf=cp(c7):escapeAndOrbitalSpeed(sL)end end;local c5,c6;if not b4 then c5,c6=qj(cK)else c5,c6=qm(cK)end;if b3 and not bb and not be and not bd then local lt,lu=cs.checkLOS((bk-cN):normalize())if c7.name~=kB.name then if lt~=nil and c7.name~=lt.name and lu<rc then c2="Collision with "..lt.name.." in "..iK(lu).."\nClear LOS to continue."c3=5;q8=true else q8=false;c2=""end end end;if not q8 then if not be and not bd and not sG then si=qF((sF-cN):normalize())elseif b4 and(bd or be)then si=qF(-vec3(cJ):normalize())end end;if bb then if not pT then b0=false;q3=a2;bQ=fU(a2,2)pT=true end;local rd=c.getThrottle()if t then rd=bQ end;local sS=99999;local op=-vec3(bO.getWorldAcceleration()):dot(cJ:normalize())local sT=dk(cJ:dot((sF-cN):normalize()),0,cK)if sT>0 or op>0 then sS=co.computeTravelTime(sT,op,rc-c5)end;if a1>de then a1=de-0.2 end;if cI:len()>=a1 or rd==0 and pT or a3/4>sS then bb=false;if bg~="Cruising"then fT("apCru","AP")bg="Cruising"end;be=true;q3=0 end;local sU=rc;if sU<=c5 or H and cV<=c5+10000 and cU then if H and cV<=c5+10000 and cU then if cV<pE and cV>2000 then cs.ResetAutopilots(1)c2="Autopilot cancelled to prevent crossing PvP Line"b0="PvP Prevent"pE=cV else pE=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;if not b4 then b2=true;cy=true end;q3=0;pT=false end elseif bd then if bg~="Orbiting to Target"then b0="AP Brk"end;if b4 then q3=1;q5=true end;local dP,ss=cp(c7):escapeAndOrbitalSpeed((cN-kB.center):len()-kB.radius)local qM;if g4 then qM=g4.position-cN end;if g4 and g4.planetname=="Space"and cK<50 then if#bF>0 then if not qe then table.remove(bF,1)end;if#bF>0 then b0=false;if not qe then qe=2 end;return end end;sE("Autopilot complete, arrived at space location")b0="Space Arrival"elseif g4 and g4.planetname~="Space"and cK<=ss and(fs.apoapsis==nil or fs.periapsis==nil or fs.apoapsis.altitude<=0 or fs.periapsis.altitude<=0)then sE("Autopilot complete, commencing reentry")bk=g4.position;cb=true;cs.showWayPoint(c7,bk)elseif(g4 and g4.planetname~="Space"or g4==nil)and fs.periapsis~=nil and fs.periapsis.altitude>0 and fs.eccentricity<1 or bg=="Circularizing"then if bg~="Circularizing"then fT("apCir","AP")bg="Circularizing"end;if cK<=ss then if g4 then if cJ:normalize():dot(qM:normalize())>0.4 then if bg~="Orbiting to Target"then fT("apOrb","OB")bg="Orbiting to Target"end;if not qZ then b0=false;cs.showWayPoint(c7,g4.position)qZ=true end else sE("Autopilot complete, proceeding with reentry")bk=g4.position;cb=true;cs.showWayPoint(c7,g4.position)qZ=false end else sE("Autopilot completed, setting orbit",true)b0=false end end elseif bg=="Circularizing"then sE("Autopilot complete, fixing Orbit",true)end elseif be then local sU=rc;if sU<=c5 or H and cV<=c5+10000 and cU then if H and cV<=c5+10000 and cU then if cV<pE and cV>2000 then if not qe then qe=true end;c2="Autopilot cancelled to prevent crossing PvP Line"b0="Prevent PvP"pE=cV else pE=cV;return end end;bb=false;if bg~="Braking"then fT("apBrk","AP")bg="Braking"end;bd=true;if not b4 then b2=true;cy=true end end;local rd=c.getThrottle()if t then rd=bQ end;if rd>0 then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;be=false end else if si then if not bc and g4==nil or not bc and g4 and g4.planetname~="Space"then if not cb then bk=vec3(c7.center)+(go+c7.radius)*cH;sV=q0;sW=cH end;bc=true elseif si and not q8 then bb=true;if bg~="Accelerating"then bg="Accelerating"fT("apAcc","AP")end;if not pT then q3=a2;q5=true;bQ=fU(a2,2)pT=true;b0=false end end end end elseif b3 and(g4~=nil and g4.planetname~="Space"and cf)then c2="Autopilot complete, starting reentry"fT("apCom","AP")bk=g4.position;b0=false;bd=false;b3=false;qX=false;bg="Aligning"q3=0;pT=false;b2=true;cb=true;cs.showWayPoint(c7,g4.position)end;if b_ then cy=true;local sN=0;local fu=vec3(DUPlayer.getWorldPosition())local sX=fu-cN;local sY=vec3(sX):project_on(cG):len()local sZ=vec3(sX):project_on(cH):len()local ca=dm(sY*sY+sZ*sZ)qF(sX:normalize())local mz=40;local s_=ca<mz;local t0=100;local rp=dk((ca-mz)/2,10,t0)pV=0;local si=eY(pW)<0.1;if si and cK<rp and not s_ then b0=false;sN=-20 else b0="Follow"sN=0 end;local t1=0;if eY(sN-cR)>t1 then if t2==nil then t2=pid.new(2*0.01,0,2*0.1)end;t2:inject(sN-cR)local sP=t2:get()pV=sP end end;if b5 or b6 or b8 or bq or bt~=nil then if bH then if ce==-1 then ba=ba-0.2 else ba=ch+bH-ce end end;local t3=bu;if t3 then t3=t3*dk(cK/100,0.1,1)*cg else t3=bs end;if not cf then t3=bs end;q2=cG:project_on_plane(cL):normalize():dot(cJ)if q2>100 then c5,c6=co.computeDistanceAndTime(q2,100,ci,0,0,t3)local t4,t5=co.computeDistanceAndTime(100,0,ci,0,0,t3*0.55)c5=c5+t4 else c5,c6=co.computeDistanceAndTime(q2,0,ci,0,0,t3*0.55)end;local sw=ba-ch-cM;local t6=200+cK;if b8 or cb then t7=2000+cK end;local t8=1;if b7 then t8=dk(cK/100,0.1,1)end;local sN=(utils.smoothstep(sw,-t6,t6)-0.5)*2*Q*t8;if not b8 and not cb and not bq and cG:dot(cJ:normalize())<0.99 then sN=(utils.smoothstep(sw,-t6*dk(20-19*cg*10,1,20),t6*dk(20-19*cg*10,1,20))-0.5)*2*Q*dk(2-cg*10,1,2)*t8 end;if not b5 then sN=0 end;if bt~=nil then if cX and not bz then sN=bt else bt=nil end end;cy=true;local t9=pV;if b8 then local ta=bM(cA)local tb,tc=co.computeDistanceAndTime(cK,ta/3.6,ci,0,0,bs-kB.gravity*9.8*ci)tb=tb==-1 and 5000 or tb;local qY=ch-(kB.noAtmosphericDensityAltitude+tb)local td=ch>kB.noAtmosphericDensityAltitude+tb*1.35;if td then sN=R;if cK<=ta/3.6 and cK>ta/3.6-10 and eY(cJ:normalize():dot(cG))>0.9 and not cQ then bU=false;q3=1 end elseif(cQ or iG:getTargetSpeed(axisCommandId.longitudinal)~=ta)and not td and not cf then q4=ta;q5=true end;if cQ then if cK>ta/3.6 and not td then b0="Reentry Limit"if bQ>0 then q3=0 end else b0=false end else b0=false end;if cM>0 then b0="Reentry vSpd"end;if not pU then sN=-80;if ch<kB.surfaceMaxAltitude+(kB.atmosphereThickness-kB.surfaceMaxAltitude)*0.25 then c2="PARACHUTE DEPLOYED at "..fU(ch,0)b8=false;b6=true;lr=true;q3=0;sN=0;cy=q end elseif kB.noAtmosphericDensityAltitude>0 and td then cy=true elseif not td then if not cf and(cQ or iG:getTargetSpeed(axisCommandId.longitudinal)~=ta)then q4=ta end;if cK<ta/3.6+1 then b0=false;pU=false;b8=false;cy=true;q3=1 end end end;if cK>iZ and not cc and not bq and not b6 and u then qF(vec3(cJ))end;if cW or(bq or cc)and bl>0 and cf then local qM;if cW then if type(cW)=="table"then qM=cW elseif cW<3 and cW>0 then qM=-cL:cross(cJ)*5000 elseif cW>=3 then qM=cL:cross(cJ)*5000 elseif cW<0 then qM=cJ*25000 end elseif g4~=nil then qM=g4.position-cN else qM=c7.center-cN end;local sM=math.deg(qn(cL:normalize(),cJ,qM))*2;local mC=math.rad(eY(cS))if cK>aL and cf then local te=1000+cK;local tf=(utils.smoothstep(sw-cM*10,-te,te)-0.5)*2*Q;local tg=dk(90-tf,0,180)pY=dk(sM*2,-tg,tg)local th=sM;sM=dk(dk(sM,-N*0.80,N*0.80)*math.cos(mC)+4*(cR-sN)*math.sin(math.rad(cS)),-N*0.80,N*0.80)local ti=1;if pY~=0 then ti=eY(mC/pY)end;ti=(90-dk(eY(pY-cS),0,90))/90;local tj=sN;if eY(cS)>90 then tj=-tj end;sN=ti*dk(dk(tj*math.cos(mC),-O*0.8,O*0.8)+eY(dk(eY(th)*math.sin(mC),-O*0.80,O*0.80)),-O*0.80,O*0.80)else pY=0;sM=dk(sM,-N*0.80,N*0.80)end;local tk=s8-sM;if cW and eY(tk)<=0.0001 and(type(cW)=="table"or type(cW)~="table"and cW<0 and eY(cS)<1)then if cW==-2 then cs.ToggleAltitudeHold()end;cW=nil;fT("180Off","BR")return end;if not cz and cK>aL and cf then if tl==nil then tl=pid.new(2*0.01,0,2*0.1)end;tl:inject(tk)local sR=dk(tl:get(),-1,1)pW=pW+sR elseif cf and ce>-1 or cK<aL then qF(qM)elseif cz and cf then if(s8<-N or s8>N)and cf then qF(cJ)end;if(s9<-O or s9>O)and cf then sN=dk(cR-s9,cR-O*0.80,cR+O*0.80)end end;if g4~=nil and not cc then local sj=kB:getAltitude(g4.position)local qY=qM:project_on_plane(cL):len()lr=true;if ba<kB.noAtmosphericDensityAltitude and not cc and not b7 and not b8 and(qY<=c5 and qM:len()<kB.radius)and(cJ:project_on_plane(cL):normalize():dot(qM:project_on_plane(cL):normalize())>0.99 or lx=="Finalizing Approach")then lx="Finalizing Approach"if#bF>0 then if not qe then table.remove(bF,1)end;if#bF>0 then if not qe then qe=2 end;return end end;q3=0;if b5 then cs.ToggleAltitudeHold()bq=true end;b0="AP Finalizing"elseif not b7 then b0=false end;if lx=="Finalizing Approach"and(q2<0.1 or qY<0.1 or tm~=nil and tm<qY)then fT("bklOn","BL")b6=true;da=true;if g4.heading then db=g4.heading else db=nil end;bq=false;lx="Proceeding to Waypoint"cY=false end;tm=qY end elseif bq and not cf and ba>kB.noAtmosphericDensityAltitude and not(cc or b8)then if g4~=nil and c7.name==kB.name then local qM=g4.position-cN;local sj=kB:getAltitude(g4.position)local qY=dm(qM:len()^2-(ch-sj)^2)local t3=bu;if t3 then c5,c6=co.computeDistanceAndTime(cK,0,ci,0,0,t3/2)lr=true;if qY<=c5+cK*s7/2 and cJ:project_on_plane(cL):normalize():dot(qM:project_on_plane(cL):normalize())>0.99 then if kB.hasAtmosphere then b0=false;b2=false;pU=true;cb=false;cd=true;b3=false;cs.BeginReentry()end end;tm=qY end end end;if not cf and ce==-1 and(b5 and ba>kB.noAtmosphericDensityAltitude)and not(cc or bz or b8)then if not cD and not bz then cC=ba;pO=true;if bq then p_.VectorToTarget=true end;cs.ToggleIntoOrbit()bq=false;pM=true end end;if cz and cf and ce==-1 and cK>aL and lx~="Finalizing Approach"then qF(cJ)sN=dk(cR-s9,cR-O*0.80,cR+O*0.80)end;pV=t9;local qy=-1;if b6 then if not q9 then rQ=false;if not cQ then q3=0 end;iG:setTargetGroundAltitude(500)iG:activateGroundEngineAltitudeStabilization(500)bB=true;if not cf then rQ=true end;q9=true end;sN=0;local tn=false;local to=math.abs(q2)if not r and cP then tn=antigrav.getBaseAltitude()if tn<kB.surfaceMaxAltitude and g4==nil or g4~=nil and kB:getAltitude(g4.position)>tn then tn=false end else tn=false end;if db then if to<0.05 then if cM>-P then b0=false else b0="BL Align BLR"end;if qF(db,0.001)then db=nil;cy=q else pV=0;cy=true end else b0="BL Align Hzn"end;if tn and eY(ch-tn)<250 then b0="AGG Align"end else local tp=false;local tq=30;if to<10 and sf~=nil and sf>0 then local tr=dk(cg,0.4,2)local t3=bu*dk(cK/100,0.1,1)*tr;local ts=sf*tr+t3-od;local tt=t3/2-od;local tu=cK-dm(eY(tt/2)*20/(0.5*ci))*utils.sign(tt)if tu<0 then tu=0 end;local tv;if cK>100 then local tw,dP=co.computeDistanceAndTime(cK,100,ci,0,0,t3)local tx,dP=co.computeDistanceAndTime(100,0,ci,0,0,dm(t3))tv=tw+tx else tv=co.computeDistanceAndTime(cK,0,ci,0,0,dm(t3))end;if tv<20 then b0=false else local ty=0;if tu>100 then local tz,dP=co.computeDistanceAndTime(tu,100,ci,0,0,ts)local tA,dP=co.computeDistanceAndTime(100,0,ci,0,0,sf*tr+dm(t3)-od)ty=tz+tA else ty,dP=co.computeDistanceAndTime(tu,0,ci,0,0,sf*tr+dm(t3)-od)end;ty=(ty+15+cK*s7)*1.1;local tB=da and g4~=nil and kB:getAltitude(g4.position)>0 and g4.safe;local sj=nil;if tn and tn<ch then sj=tn elseif tB then sj=kB:getAltitude(g4.position)+250 elseif ch>kB.surfaceMaxAltitude then sj=kB.surfaceMaxAltitude end;if cZ then local tC=kB:getAltitude(cZ[1].center)if sj then if tC>sj then sj=tC end else sj=tC end end;if sj~=nil then local tD=ch-sj;tp=true;if tD<=ty or ty==-1 or to>0.05 and da then if to>0.05 and da then b0="BL AP Hzn"else b0="BL Stop Dist"end else b0=false end end end end;qy=ce;if qy>-1 then if not tn and not bm then q6=true;iG:setTargetGroundAltitude(_)end;if(cK<1 or cJ:normalize():dot(cL)<0)and not db and qy-5<_ then b6=false;b5=false;bZ=0;if rQ then qQ(0,1)end;b0="BL Complete"cy=q;da=false;q9=false else if cM<-5 or to>0.05 then b0="BL Slowing"else b0=false end end elseif not tp then if lr and cJ:normalize():dot(-gq)<0.999 then b0="BL Strong"qF()elseif to>10 or to>0.05 and da then b0="BL hSpd"elseif cM<-P then b0="BL BLR"if rQ then qQ(0,1)end else if rQ then qQ(-1)end;b0=false end end end else q9=false end;if b7 or cc then local lt,eJ,eI;if bk~=nil then lt,eJ,eI=cn:getPlanetarySystem(0):castIntersections(cN,(bk-cN):normalize(),function(er)if er.noAtmosphericDensityAltitude>0 then return er.radius+er.noAtmosphericDensityAltitude else return er.radius+er.surfaceMaxAltitude*1.5 end end)end;if cP and not cc then if ch>=ba-50 and cK>iZ then b7=false;if not b3 and not bq then b0="ATO Agg Arrive"q3=0 end end elseif eY(sN)<15 and ch/ba>0.75 then b7=false;if not cc then if cQ and not t then d.control.cancelCurrentControlMasterMode()end elseif cc and cK<iZ then b3=true;cc=false;b5=false;b7=false;q3=0 elseif cc then q3=0;b0="ATO Space"end elseif cc and not cf and c7~=nil and(lt==nil or lt.name==c7.name)then b3=true;cc=false;b5=false;b7=false;if not cQ then q3=0 end;bb=true end end;local tE=ce>-1;local tF=cR;if(bq or cc or cW)and not tE and cK>aL and cf then local mC=math.rad(eY(cS))tF=cR*eY(math.cos(mC))+s9*math.sin(mC)end;local tG=dk(sN-tF,-O*0.80,O*0.80)if not cf and bq then tG=dk(sN-tF,-85,Q)elseif not cf then tG=dk(sN-tF,-Q,Q)end;if eY(cS)<5 or bq or cW or b6 or tE or b5 then if t2==nil then t2=pid.new(5*0.01,0,5*0.1)end;t2:inject(tG)local sP=t2:get()pV=pV+sP end end;if antigrav~=nil and(antigrav and not r and ch<200000)then if bv==nil or bv<1000 then bv=1000 end;if tH~=bv then tH=bv;qd=tH end end;if(cf or b8 or cd)and t and cQ then if tI==nil then tI=pid.new(0.1,0,1)end;local tJ=0;if aU>0 and not b8 and cg>0.005 and cg<0.1 and cM>-10 then local tK=bO.getFrictionBurnSpeed()*aU;local tL=cA/3.6;if tK>tL then tJ=tK-tL-1 end end;tI:inject(cA/3.6+tJ-cJ:dot(cG))local tM=tI:get()bT=dk(tM,-1,1)if not d6 then if bT<bQ and(cg>0.005 or b8 or cd)then bS=true;d6=dk(bT,0.01,1)else bS=false;d6=bQ end end;if tN==nil then tN=pid.new(1*0.01,0,1*0.1)end;tN:inject(cJ:len()-cA/3.6-tJ)local tO=dk(tN:get(),0,1)if cf and cM<-80 or(cg>0.005 or b8 or cd)then bR=tO end;if bR>0 then if bS and bT==0.01 and not d6 then d6=0 end else bT=dk(bT,0.01,1)end;local tP=''local tQ=vec3()local tR=rn(axisCommandId.vertical,bZ*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tR,rM)local tS='thrust analog longitudinal 'if bC=="All"or bC=="Longitude"then tS=tS..aV end;local tT=iG:getAxisCommandType(axisCommandId.longitudinal)local tU=iG:composeAxisAccelerationFromThrottle(tS,axisCommandId.longitudinal)local tV=rB(axisCommandId.lateral,by*1000)tP=tP..' , '.."lateral airfoil , lateral ground "tQ=tQ+tV;if tQ:len()>constants.epsilon then d:setEngineForceCommand(tP,tQ,rM,'','','',rN)end;d:setEngineForceCommand(tS,tU,rL)local tW='thrust analog vertical fueled 'local tX='thrust analog lateral fueled 'if bC=="All"or bC=="Lateral"then tX=tX..aW end;if bC=="All"or bC=="Vertical"then tW=tW..aX end;if bZ~=0 or b6 and b0 or not bm and not bB then d:setEngineForceCommand(tW,tR,rL)else d:setEngineForceCommand(tW,vec3(),rL)end;if by~=0 then d:setEngineForceCommand(tX,tV,rL)else d:setEngineForceCommand(tX,vec3(),rL)end;if rU==0 then rU=bR end;local tY=-rU*(aQ*cJ+aR*rY)d:setEngineForceCommand('brake',tY)else if t then if not d6 then d6=bQ end end;local rp=c.getAxisCommandValue(0)if not cQ then if tN==nil then tN=pid.new(1*0.01,0,1*0.1)end;tN:inject(cJ:len()-rp/3.6)local tO=dk(tN:get(),0,1)rU=dk(rU+tO,0,1)end;local tY=-rU*(aQ*cJ+aR*rY)d:setEngineForceCommand('brake',tY)local tP=''local tQ=vec3()local tZ=false;local tS='thrust analog longitudinal 'if aV~="none"and(bC=="All"or bC=="Longitude")then tS=tS..aV end;local tT=iG:getAxisCommandType(axisCommandId.longitudinal)if tT==axisCommandType.byThrottle then local tU=iG:composeAxisAccelerationFromThrottle(tS,axisCommandId.longitudinal)d:setEngineForceCommand(tS,tU,rL)elseif tT==axisCommandType.byTargetSpeed then local tU=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tP=tP..' , '..tS;tQ=tQ+tU;if iG:getTargetSpeed(axisCommandId.longitudinal)==0 or iG:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iG:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tZ=true end end;local tX='thrust analog lateral 'if aW~="none"and(bC=="All"or bC=="Lateral")then tX=tX..aW end;local t_=iG:getAxisCommandType(axisCommandId.lateral)if t_==axisCommandType.byThrottle then local u0=iG:composeAxisAccelerationFromThrottle(tX,axisCommandId.lateral)d:setEngineForceCommand(tX,u0,rL)elseif t_==axisCommandType.byTargetSpeed then local tV=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tP=tP..' , '..tX;tQ=tQ+tV end;local tW='thrust analog vertical 'if aX~="none"and(bC=="All"or bC=="Vertical")then tW=tW..aX end;local u1=iG:getAxisCommandType(axisCommandId.vertical)if u1==axisCommandType.byThrottle then local tR=iG:composeAxisAccelerationFromThrottle(tW,axisCommandId.vertical)if bZ~=0 or b6 and b0 then d:setEngineForceCommand(tW,tR,rL,'airfoil','ground','',rN)else d:setEngineForceCommand(tW,vec3(),rL)d:setEngineForceCommand('airfoil vertical',tR,rL,'airfoil','','',rN)d:setEngineForceCommand('ground vertical',tR,rL,'ground','','',rN)end elseif u1==axisCommandType.byTargetSpeed then if bZ<0 then d:setEngineForceCommand('hover',vec3(),rL)end;local u2=iG:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tP=tP..' , '..tW;tQ=tQ+u2 end;if tQ:len()>constants.epsilon then if rU~=0 or tZ or eY(rY:dot(cG))<0.5 then tP=tP..', brake'end;d:setEngineForceCommand(tP,tQ,rM,'','','',rN)end end;local u3=aN*(s1-s0)local u4=vec3(bO.getWorldAirFrictionAngularAcceleration())u3=u3-u4;d:setEngineTorqueCommand('torque',u3,rL,'airfoil','','',rN)d:setBoosterCommand('rocket_engine')if c4 and not o then local fo=cI:len()local u5=0.15;if not cQ then local u6=iG:getTargetSpeed(axisCommandId.longitudinal)if fo*3.6>u6*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fo*3.6<u6*(1-u5)and not u7 then u7=true;d:toggleBoosters()end else local rd=c.getThrottle()if t then rd=bQ*100 end;local rp=rd/100;if not cf then rp=rp*a1;if fo>=rp*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fo<rp*(1-u5)and not u7 then u7=true;d:toggleBoosters()end else local ta=bM(cA)rp=rp*ta/3.6;if fo>=rp*(1-u5)and u7 then u7=false;d:toggleBoosters()elseif fo<rp*(1-u5)and not u7 then u7=true;d:toggleBoosters()end end end end end;if u8 then for dK,dw in pairs(u8)do pC[dK]=dw end end;ce=qt()return pC end;local function u9(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ua,iF,iG,iH,ub,gL,fU,e3,dl,dk,fT,iJ,pB)local bO=DUConstruct;local uc={}local ud=true;local ue=5;local uf=5;local ug=ue;local uh=uf;local ui=bP;function uc.landingGear(q6)bm=not bm;if bm then bq=false;bt=nil;cs.cmdThrottle(0)if vBooster or hover then if(cf or ch<20000)and not q6 then fT("bklOn","BL")lr=true;b8=false;b7=false;b9=false;if bz then cs.ToggleIntoOrbit()end;if b6 then da=not da end;b6=true;cy=true;bm=false else if bV then fT("grOut","LG",1)d.control.deployLandingGears()end;da=false;iG:setTargetGroundAltitude(_)if cf then b0="Landing"end end;b5=false;bH=false elseif bV and not b6 then fT("grOut","LG",1)d.control.deployLandingGears()end else if bV then fT("grIn","LG",1)d.control.retractLandingGears()end;iG:activateGroundEngineAltitudeStabilization(qT)if bB then if _<iG.targetGroundAltitude then iG:setTargetGroundAltitude(iG.targetGroundAltitude)else iG:setTargetGroundAltitude(Z)end end end end;function uc.startControl(uj)local function uk(r8)local r9=1;local function ul(um,r8)local un={kB.surfaceMaxAltitude+100,kB.spaceEngineMinAltitude-0.01*kB.noAtmosphericDensityAltitude,kB.noAtmosphericDensityAltitude+V,kB.radius*(U-1)+kB.noAtmosphericDensityAltitude}local uo=um;for dP,dw in ipairs(un)do if r8 and uo>dw then um=dw elseif um<dw and not r8 then um=dw;break end end;return um end;if r8 then r9=-1 end;if not r and cP then if c0 and r8 then bv=1000 elseif bv~=nil then bv=bv+r9*uf;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end else bv=tH+r9*100 end elseif b5 or b9 or bz then if bz then if c0 then cC=ul(cC,r8)else cC=cC+r9*ue end;if cC<kB.noAtmosphericDensityAltitude then cC=kB.noAtmosphericDensityAltitude end else if c0 and cf then ba=ul(ba,r8)bH=false else ba=ba+r9*ue;if bH then if ba>100 then bH=false else iG:updateTargetGroundAltitudeFromActionStart(r9*1.0)bH=d:getTargetGroundAltitude()end end end end else iG:updateTargetGroundAltitudeFromActionStart(r9*1.0)end end;local function up(uq)if not cf then c2="Flight Assist in Atmo only"return end;local dt=type(uq)if cW==nil then if dt=="table"then if b3 or bq then cs.ToggleAutopilot()end;fT("180On","BR")elseif uq==1 then fT("bnkLft","BR")else fT("bnkRht","BR")end;if not b5 and not b3 and not bq then cs.ToggleAltitudeHold()if dt~="table"then uq=uq+1 end end;cW=uq else fT("180Off","BR")cW=nil end end;local function ur()if iH()==1 then c8=0;c9=0;ub(bi)elseif iF()==1 and y then cx=false;cw=false end;c0=false end;if uj=="gear"then cu.landingGear()elseif uj=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uj=="forward"then if p3 and not cf and not b3 then b2=not b2;b1=false else bW=bW-1 end elseif uj=="backward"then if p3 then if not cf then if not b3 then b1=not b1;b2=false else b4=not b4 end else up(-cJ*5000)end else bW=bW+1 end elseif uj=="left"then if p3 then up(1)else bX=bX-1 end elseif uj=="right"then if p3 then up(3)else bX=bX+1 end elseif uj=="yawright"then bY=bY-1;db=nil elseif uj=="yawleft"then bY=bY+1;db=nil elseif uj=="straferight"then iG:updateCommandFromActionStart(axisCommandId.lateral,1.0)by=1 elseif uj=="strafeleft"then iG:updateCommandFromActionStart(axisCommandId.lateral,-1.0)by=-1 elseif uj=="up"then cs.vertical(1)if ce-3<_ and ch>0 and bm then cu.landingGear()end elseif uj=="down"then cs.vertical(-1)elseif uj=="groundaltitudeup"then uk()elseif uj=="groundaltitudedown"then uk(true)elseif uj=="option1"then us=false;if p3 and c0 then local ut=""for M=1,#d1 do ut=ut.."| Name: "..a.getPlayerName(d1[M]).." Mass: "..fU(bO.getBoardedPlayerMass(d1[M])/1000,1).."t "end;a.print("Onboard: "..ut)return end;cr.adjustAutopilotTargetIndex()elseif uj=="option2"then us=false;if p3 and c0 then for M=1,#d1 do bO.forceDeboard(d1[M])bO.forceInterruptVRSession(d1[M])end;c2="Deboarded All Passengers"return end;cr.adjustAutopilotTargetIndex(1)elseif uj=="option3"then us=false;if p3 and c0 then local ut=""for M=1,#d2 do ut=ut.."| ID: "..d2[M].." Mass: "..fU(b.getDockedConstructMass(d2[M])/1000,1).."t "end;a.print("Docked Ships: "..ut)return end;if x then if w then w=false else w=true end;if ct then ct.ToggleRadarPanel()end end elseif uj=="option4"then us=false;if p3 and c0 then for M=1,#d2 do b.forceUndock(d2[M])end;c2="Undocked all ships"return end;cW=nil;cs.ToggleAutopilot()elseif uj=="option5"then us=false;cs.ToggleLockPitch()elseif uj=="option6"then us=false;if p3 and c0 then if shield then cv.ventShield()else c2="No shield found"end;return end;cs.ToggleAltitudeHold()elseif uj=="option7"then us=false;if p3 and c0 then if shield then shield.toggle()return else c2="No shield found"return end end;E=not E;if E then c2="Collision System Enabled"else c2="Collision System Secured"end elseif uj=="option8"then us=false;if p3 and c0 then if bl>0 and g4~=nil then cs.routeWP()else c2="Select a saved wp on IPH to add to or remove from route"end;return end;bB=not bB;if not bB then c2="DeCoupled Mode - Ground Stabilization off"iG:deactivateGroundEngineAltitudeStabilization()fT("gsOff","GS")else c2="Coupled Mode - Ground Stabilization on"iG:activateGroundEngineAltitudeStabilization(qT)dd=true;fT("gsOn","GS")end elseif uj=="option9"then us=false;if p3 and c0 then iG:resetCommand(axisCommandId.longitudinal)iG:resetCommand(axisCommandId.lateral)iG:resetCommand(axisCommandId.vertical)cs.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cj=gyro.isActive()==1;if cj then fT("gyOn","GA")else fT("gyOff","GA")end else c2="No gyro found"end elseif uj=="lshift"then if p3 then c0=true end elseif uj=="brake"then if aZ or p3 then cs.BrakeToggle("Manual")elseif not b0 then cs.BrakeToggle("Manual")else b0="Manual"end elseif uj=="lalt"then us=true;p3=true;if iF()==0 and not j and g=="keyboard"then ub(1)end elseif uj=="booster"then if o then d:toggleBoosters()elseif not c4 then if not u7 then d:toggleBoosters()u7=true end;c4=true else if u7 then d:toggleBoosters()u7=false end;c4=false end elseif uj=="stopengines"then local function uu()if bP-ui<1.5 then fT("clear","CA")cs.clearAll()end end;uu()ui=bP;if iG:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if p3 then if cA>0 then cA=0 else cA=W end elseif bQ~=0 then iG:resetCommand(axisCommandId.longitudinal)cs.cmdThrottle(0)else cs.cmdThrottle(100)end else if iG:getTargetSpeed(axisCommandId.longitudinal)~=0 then iG:resetCommand(axisCommandId.longitudinal)else if cf then cs.cmdCruise(cA)else cs.cmdCruise(a1*3.6)end end end elseif uj=="speedup"then cs.changeSpd()elseif uj=="speeddown"then cs.changeSpd(true)elseif uj=="antigravity"and not r then if antigrav~=nil then cs.ToggleAntigrav()else c2="No antigrav found"end elseif uj=="leftmouse"then c1=true;if c0 then ur()us=false else c0=true;bi=iH()ub(1)end end end;function uc.stopControl(uj)local function uv()if not r and cP then uh=uf end;if b5 or b9 or bz then ug=ue end end;if uj=="forward"then bW=0 elseif uj=="backward"then bW=0 elseif uj=="left"then if cW then if cW==2 then cW=-2 else cW=-1 end end;bX=0 elseif uj=="right"then if cW then if cW==4 then cW=-2 else cW=-1 end end;bX=0 elseif uj=="yawright"then bY=0 elseif uj=="yawleft"then bY=0 elseif uj=="straferight"then iG:updateCommandFromActionStop(axisCommandId.lateral,-1.0)by=0 elseif uj=="strafeleft"then iG:updateCommandFromActionStop(axisCommandId.lateral,1.0)by=0 elseif uj=="up"then cs.vertical(0,-1)elseif uj=="down"then cs.vertical(0,1)elseif uj=="groundaltitudeup"then uv()us=false elseif uj=="groundaltitudedown"then uv()us=false elseif uj=="brake"then if not aZ and not p3 then if b0 then cs.BrakeToggle()else b0=false end end elseif uj=="lalt"then if c0 then c0=false end;if iF()==0 and j then if us then if iH()==1 then ub(0)else ub(1)end else us=true end elseif iF()==0 and not j and g=="keyboard"then ub(0)end;p3=false end end;function uc.loopControl(uj)local function uw(r8)local r9=1;if r8 then r9=-1 end;if not r and cP then if bv~=nil then bv=bv+r9*uh;if bv<1000 then bv=1000 end;if b5 and bv<ba+10 and bv>ba-10 then ba=bv end;uh=dk(uh*1.05,uf,50)else bv=tH+r9*100 end elseif b5 or b9 or bz then if bz then cC=cC+r9*ug;if cC<kB.noAtmosphericDensityAltitude then cC=kB.noAtmosphericDensityAltitude end else ba=ba+r9*ug end;ug=dk(ug*1.05,ue,50)else iG:updateTargetGroundAltitudeFromActionLoop(r9*1.0)end end;local function ux(r8)local r9=1;if r8 then r9=-1 end;if not c0 then if t and not p3 then bQ=dk(bQ+r9*aF/100,-1,1)else iG:updateCommandFromActionLoop(axisCommandId.longitudinal,r9*aF)end end end;if uj=="groundaltitudeup"then if not c0 then uw()end elseif uj=="groundaltitudedown"then if not c0 then uw(true)end elseif uj=="speedup"then ux()elseif uj=="speeddown"then ux(true)end end;function uc.inputTextControl(r7)local function uy(uz,fu,gy)local function uA(fu)local dC=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dD='::pos{'..dC..','..dC..','..dC..','..dC..','..dC..'}'local dT,dU,e0,e1,e2=e3(fu,dD)if dT=="0"and dU=="0"then return vec3(dl(e0),dl(e1),dl(e2))end;e1=math.rad(e1)e0=math.rad(e0)local kB=e[dl(dT)][dl(dU)]local eU=math.cos(e0)local uB=vec3(eU*math.cos(e1),eU*math.sin(e1),math.sin(e0))return kB.center+(kB.radius+e2)*uB end;local fW=uA(fu)return cr.AddNewLocation(uz,fW,gy)end;local M;local uC,iu=nil,nil;local uD="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."M=string.find(r7," ")uC=r7;if M~=nil then uC=string.sub(r7,0,M-1)iu=string.sub(r7,M+1)end;if uC=="/help"or uC=="/commands"then for ls in string.gmatch(uD,"([^\n]+)")do a.print(ls)end;return elseif uC=="/setname"then if iu==nil or iu==""then c2="Usage: ah-setname Newname"return end;if bl>0 and g4~=nil then cr.UpdatePosition(iu)else c2="Select a saved target to rename first"end elseif shield and uC=="/resist"then cv.setResist(iu)elseif uC=="/addlocation"or string.find(r7,"::pos")~=nil then local gy=false;local uz="0-Temp"if iu==nil or iu==""or uC~="/addlocation"then iu=uC;gy=true end;M=string.find(iu,"::")if not gy then uz=string.sub(iu,1,M-2)end;local fu=string.sub(iu,M)uy(uz,fu,gy)elseif uC=="/agg"then if iu==nil or iu==""then c2="Usage: /agg targetheight"return end;iu=dl(iu)if iu<1000 then iu=1000 end;bv=iu;c2="AGG Target Height set to "..iu elseif uC=="/G"then if iu==nil or iu==""then c2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if iu=="dump"then for dK,dw in pairs(iJ())do if type(dw.get())=="boolean"then if dw.get()==true then a.print(dK.." true")else a.print(dK.." false")end elseif dw.get()==nil then a.print(dK.." nil")else a.print(dK.." "..dw.get())end end;return end;M=string.find(iu," ")local uE=string.sub(iu,0,M-1)local uF=string.sub(iu,M+1)for dK,dw in pairs(iJ())do if dK==uE then local uG=type(dw.get())if uG=="number"then uF=dl(uF)if dK=="AtmoSpeedLimit"then cA=uF end end;c2="Variable "..uE.." changed to "..uF;if dK=="MaxGameVelocity"then uF=uF/3.6;if uF>de-0.2 then uF=de-0.2;c2="Variable "..uE.." changed to "..fU(uF*3.6,1)end end;if uG=="boolean"then if string.lower(uF)=="true"then uF=true else uF=false end end;dw.set(uF)return end end;c2="No such global variable: "..uE elseif uC=="/deletewp"then if bl>0 and g4~=nil then cr.ClearCurrentPosition()else c2="Select a custom wp to delete first in IPH"end elseif uC=="/copydatabank"then if dbHud_2 then pB(true)else c2="Spare Databank required to copy databank"end elseif uC=="/iphWP"then if bl>0 then a.print(cs.showWayPoint(c7,bk,true))a.print(json.encode(bk))c2="::pos waypoint shown in lua chat in local and world format"else c2="No target selected in IPH"end elseif uC=="/createPrivate"then local uH="privatelocations = {\n"local uI=""if#d8>0 then for dK,dw in pairs(d8)do uH=uH.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uH=uH.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uH=uH.."safe = true},\n"else uH=uH.."safe = false},\n"end end end;uI=#d8 .."-Private "if iu=="all"then for dK,dw in pairs(bp)do uH=uH.."{position = {x = "..dw.position.x..", y = "..dw.position.y..", z = "..dw.position.z.."},\n ".."name = '*"..dw.name.."',\n planetname = '"..dw.planetname.."',\n gravity = "..dw.gravity..",\n"if dw.heading then uH=uH.."heading = {x = "..dw.heading.x..", y = "..dw.heading.y..", z = "..dw.heading.z.."},\n"end;if dw.safe then uH=uH.." safe = true},\n"else uH=uH.."safe = false},\n"end end;uI=uI..#bp.."-Public "end;uH=uH.."}\n return privatelocations"if ua then ua.setHTML(uH)end;c2=uI.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"c3=7 end end;function uc.tagTick()if bC=="Off"then bC="All"elseif bC=="All"then bC="Longitude"elseif bC=="Longitude"then bC="Lateral"elseif bC=="Lateral"then bC="Vertical"else bC="Off"end;c2="Extra Engine Tags: "..bC;c.stopTimer("tagTick")end;if uJ then for dK,dw in pairs(uJ)do uc[dK]=dw end end;return uc end;local function uK(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iC,ua)local a=DUSystem;local bO=DUConstruct;local uL=DUPlayer;local uM=DULibrary;local uN={}local dj=string.format;local iD=json.decode;local uO=json.encode;local pt=b.getElementMaxHitPointsById;local iE=b.getElementMassById;local iF=d.control.isRemoteControlled;local e3=string.match;local gL=a.destroyWidgetPanel;local fR=a.updateData;local fS=a.addDataToWidget;local ub=a.lockView;local iH=a.isViewLocked;local dm=math.sqrt;local dl=tonumber;local eY=math.abs;local bM=math.floor;local bN=c.getAtmosphereDensity;local eT=math.atan;local bL=a.getArkTime;local dk=utils.clamp;local iG=d.axisCommandManager;local gN=13;local iM=b.getElementIdList()local iN=0;local function dn(eB,eC)if eB==0 then return eY(eC)<1e-09 elseif eC==0 then return eY(eB)<1e-09 else return eY(eB-eC)<math.max(eY(eB),eY(eC))*dB end end;local function fU(dC,uP)local r9=10^(uP or 0)return bM(dC*r9+0.5)/r9 end;local function iI(uQ,uR)for dK,dw in pairs(uR)do if type(dK)=="string"then uQ[dK]=dw else uQ[#uQ+1]=uR[dK]end end;return uQ end;local function iJ(uS)local uT={}if not uS then iI(uT,L)iI(uT,ab)iI(uT,aD)iI(uT,aY)return uT elseif uS=="boolean"then return L elseif uS=="handling"then return ab elseif uS=="hud"then return aD elseif uS=="physics"then return aY end end;local function pB(uU)local function uV(uW)for dK,dw in pairs(uW)do dbHud_1.setStringValue(dK,uO(dw.get()))if uU and dbHud_2 then dbHud_2.setStringValue(dK,uO(dw.get()))end end end;if dbHud_1 then uV(bI)uV(iJ())a.print("Saved Variables to Datacore")if uU and dbHud_2 then c2="Databank copied.  Remove copy when ready."end end end;local function fT(uX,uY,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..uX..".mp3")end;local function gM(hG,hH,r7,jT,uZ)return dj([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jT or"",hG,hH,uZ or"",r7)end;local function iK(ca,u_)u_=u_ or 1;local unit="m"if ca>100000 then ca=ca/200000;unit="su"elseif ca>1000 then ca=ca/1000;unit="km"end;return fU(ca,u_)..unit end;local function iL(v0)local v1=0;local v2=0;local v3=0;if v0<60 then v0=bM(v0)elseif v0<3600 then v1=bM(v0/60)v0=bM(v0%60)elseif v0<86400 then v2=bM(v0/3600)v1=bM(v0%3600/60)else v3=bM(v0/86400)v2=bM(v0%86400/3600)end;if v3>365 then return">1y"elseif v3>0 then return v3 .."d "..v2 .."h "elseif v2>0 then return v2 .."h "..v1 .."m "elseif v1>0 then return v1 .."m "..v0 .."s"elseif v0>0 then return v0 .."s"else return"0s"end end;local function v4()if radar_1 then ct=gK(b,a,c,radar_1,radar_2,warpdrive,eY,gL,dm,gM,dl,gN,fT)end end;function uN.radarSetup()v4()end;function uN.onStart()local v5=false;local function v6()local function v7(v8)local v9=dbHud_1.hasKey;for dK,dw in pairs(v8)do if v9(dK)then local dF=iD(dbHud_1.getStringValue(dK))if dF~=nil then dw.set(dF)v5=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then v7(iJ())coroutine.yield()v7(bI)else v7(bI)c2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values"c3=5;v5=false end;coroutine.yield()if v5 then c2="Loaded Saved Variables"elseif not f then c2="No Databank Saved Variables Found\nVariables will save to Databank on standing"c3=5 end;if#bp>0 then d9=iI(d9,bp)end else c2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;aZ=k;g=string.lower(g)cy=q;cA=W;if bw+180<bP then bu=0 end;bw=bP;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"c3=7 end;if antigrav and not r then if bv==nil then bv=ch end;antigrav.setTargetAltitude(bv)end;if pcall(require,"autoconf/custom/archhud/"..i)then if#d8>0 then d9=iI(d9,d8)end end;lx="Proceeding to Waypoint"if not a1 or a1<0 then a1=bO.getMaxSpeed()-0.1 end end;local function va()local function vb(vc,vd)if vc>vd then vd=vc end;local ve,vf=0,0;if a7>0 then ve=a7*0.05 end;if a8>0 then vf=a8*0.05 end;vd=vd*(1-(ve+vf))return vd end;local vg=b.getElementNameById;local vh=at~=0 and au~=0;local vi=_G["atmofueltank_size"]local vj=_G["spacefueltank_size"]local vk=_G["rocketfueltank_size"]for dK in pairs(iM)do local type=b.getElementDisplayNameById(iM[dK])if e3(type,'^.*Atmospheric Engine$')then if e3(tostring(b.getElementTagsById(iM[dK])),'^.*vertical.*$')and b.getElementForwardById(iM[dK])[3]>0 then cO=true end end;if e3(type,'^.*Space Engine$')then cF=true;if e3(tostring(b.getElementTagsById(iM[dK])),'^.*vertical.*$')then local vl=b.getElementForwardById(iM[dK])if vl[3]<0 then vm=true else cE=true end end end;if type=="Landing Gear"then bV=true end;if type=="Dynamic Core Unit"then local pv=pt(iM[dK])if pv>10000 then gN=110 elseif pv>1000 then gN=55 elseif pv>150 then gN=27 end end;iN=iN+pt(iM[dK])if vh and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pv=pt(iM[dK])local ol=iE(iM[dK])local vc=0;local jM=bL()if type=="Atmospheric Fuel Tank"then local vd=400;local vn=35.03;if pv>10000 then vd=51200;vn=5480 elseif pv>1300 then vd=6400;vn=988.67 elseif pv>150 then vd=1600;vn=182.67 end;vc=ol-vn;if a4>0 then vd=vd+vd*a4*0.2 end;vd=vb(vc,vd)local gx=vg(iM[dK])local jK=0;for jL=1,vi do if gx==iD(c["atmofueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vo={iM[dK],string.sub(gx,1,12),vd,vn,vc,jM,jK}ck[#ck+1]=vo end;if type=="Rocket Fuel Tank"then local vd=320;local vn=173.42;if pv>65000 then vd=40000;vn=25740 elseif pv>6000 then vd=5120;vn=4720 elseif pv>700 then vd=640;vn=886.72 end;vc=ol-vn;if a6>0 then vd=vd+vd*a6*0.1 end;vd=vb(vc,vd)local gx=vg(iM[dK])local jK=0;for jL=1,vk do if gx==iD(c["rocketfueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vo={iM[dK],string.sub(gx,1,12),vd,vn,vc,jM,jK}cm[#cm+1]=vo end;if type=="Space Fuel Tank"then local vd=600;local vn=35.03;if pv>10000 then vd=76800;vn=5480 elseif pv>1300 then vd=9600;vn=988.67 elseif pv>150 then vd=2400;vn=182.67 end;vc=ol-vn;if a5>0 then vd=vd+vd*a5*0.2 end;vd=vb(vc,vd)local gx=vg(iM[dK])local jK=0;for jL=1,vj do if gx==iD(c["spacefueltank_"..jL].getWidgetData()).name then jK=jL;break end end;local vo={iM[dK],string.sub(gx,1,12),vd,vn,vc,jM,jK}cl[#cl+1]=vo end end end;if not cO then b9,a_=false,false end end;local function vp()if gyro~=nil then cj=gyro.isActive()==1 end;if not bB then iG:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then ub(1)else ub(0)end;if door and(cf or not cf and ch<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cf or not cf==0 and ch<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;if antigrav then cP=antigrav.isActive()==1;if cP and not r then antigrav.showWidget()end end;if iF()==1 and l then uL.freeze(1)else uL.freeze(0)end;if bV then if ce~=-1 and not cP then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bm=d.control.isAnyLandingGearDeployed()==1 or ce~=-1 and ce-3<_;if ce~=-1 or not cf and cI:len()<50 then b0="Startup"else b0=false end;iG:setTargetGroundAltitude(_)ph=cf end;local function vq()local vr={}local function vs()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vt={[1]=6637,[2]=3426,[26]=4242,[27]=4150,[3]=21452,[8]=3434,[9]=5916}for vu,vv in pairs(e)do e[vu][0]=vs()e[vu][0].systemId=vu;vr[vu]={}for vw,kB in pairs(e[vu])do kB.gravity=kB.gravity/9.8;kB.center=vec3(kB.center)kB.name=kB.name[1]kB.noAtmosphericDensityAltitude=kB.atmosphereThickness;kB.spaceEngineMinAltitude=vt[kB.id]or 0.5353125*kB.atmosphereThickness;kB.planetarySystemId=vu;kB.bodyId=kB.id;vr[vu][vw]=kB;if mn==nil or kB.center.x<mn then mn=kB.center.x end;if mm==nil or kB.center.x>mm then mm=kB.center.x end;if mq==nil or kB.center.y<mq then mq=kB.center.y end;if mp==nil or kB.center.y>mp then mp=kB.center.y end;if kB.center and kB.name~="Space"then d3[#d3+1]=kB end end end;ed=di(d,b,c,a,dj,dk,dl,dm,dn)cn=ed(vr)fX=cn[0]co=eX(d,b,c,a,dm,eY)cp=fq(d,b,c,a,dj,dk,dl,dm,dn)cr=fQ(d,b,c,a,dbHud_1,e,fR,fS,bM,dl,dm,fT,fU)kB=cn[0]:closestBody(bO.getWorldPosition())end;vx=false;vy=coroutine.create(function()iG:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v6()coroutine.yield()va()coroutine.yield()cs=pz(d,b,c,e,vBooster,hover,pA,antigrav,dbHud_1,eY,bM,bN,iF,eT,bL,dk,iG,fR,iH,dm,fU,fT,iI,dn,iK,iL,pB,iD)vp()coroutine.yield()vq()v4()if iB then cq=iB(d,b,c,a,e,antigrav,hover,shield,warpdrive,iC,eY,bM,dj,iD,bN,iE,iF,eT,bL,dk,iG,fS,fR,gL,iH,dm,fU,gM,fT,iI,iJ,iK,iL,iM,iN)end;if cq then cq.ButtonSetup()end;cu=u9(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ua,iF,iG,iH,ub,gL,fU,e3,dl,dk,fT,iJ,pB)if shield then cv=ik(shield,e3,bM)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ua then ua.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",aT)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)if shield then c.setTimer("shieldTick",0.0166667)end;if vz then vA.ExtraOnStart()end;fT("start","SU")local function vB()if bG[1]==0 then cs.cmdThrottle(bG[2])else if cg>0 then cA=bG[2]cs.cmdThrottle(1)end end end;lo=string.find(c.getName(),"Emergency")or false;if lo then if ce>-1 and cK<1 and ce-3<_ then c.exit()else if J then vB()else if cg==0 then b0="ECU Braking"elseif ce==-1 then cu.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif J and bG[3]+3>bL()then vB()end end)coroutine.resume(vy)end;function uN.onUpdate()if vx then d:update()if cf and t and cQ then if cQ and bU then cs.cmdThrottle(0)bU=false elseif not cQ and not bU then bQ=0;bU=true end end;if d6 then iG:setThrottleCommand(axisCommandId.longitudinal,d6)d6=nil end;if not cw and p5~=vC then a.setScreen(p5)end;vC=p5;if lo and not J and cg>0 and ce==-1 then cu.landingGear()end;if lo and ce>-1 and cK<1 and ce-3<_ then c.exit()end;if vz then vA.ExtraOnUpdate()end else local ia=coroutine.status(vy)if ia=="suspended"then local dL,ib=coroutine.resume(vy)if ib then a.print("ERROR STARTUP: "..ib)end elseif ia=="dead"then vx=true end end end;function uN.onFlush()if vx then cs.onFlush()if vz then vA.ExtraOnFlush()end end end;function uN.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not r then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cg>0 or cg==0 and ch<10000)then for dP,dw in pairs(door)do dw.toggle()end end;if switch then for dP,dw in pairs(switch)do dw.toggle()end end;if forcefield and(cg>0 or cg==0 and ch<10000)then for dP,dw in pairs(forcefield)do dw.toggle()end end;w=d5;local vD=0;if lo then vD=bL()end;if iG:getAxisCommandType(0)==0 then bG={0,bQ,vD}else bG={1,iG:getTargetSpeed(axisCommandId.longitudinal),vD}end;pB()if nW then nW.activate()end;if z then cs.showWayPoint(kB,cN)end;if cq then a.print(cq.FuelUsed("atmofueltank")..", "..cq.FuelUsed("spacefueltank")..", "..cq.FuelUsed("rocketfueltank"))end;if vz then vA.ExtraOnStop()end;fT("stop","SU")end;function uN.controlStart(uj)if vx then cu.startControl(uj)end end;function uN.controlStop(uj)if vx then cu.stopControl(uj)end end;function uN.controlLoop(uj)if vx then cu.loopControl(uj)end end;function uN.controlInput(r7)if vx then cu.inputTextControl(r7)end end;function uN.radarEnter(dU)if ct then ct.onEnter(dU)end end;function uN.radarLeave(dU)if ct then ct.onLeave(dU)end end;function uN.onTick(vE)if vE=="tenthSecond"then if cs then cs.TenthTick()end;if cq then cq.TenthTick()end elseif vE=="oneSecond"then if cq then cq.OneSecondTick()end elseif vE=="msgTick"then if cq then cq.MsgTick()end elseif vE=="animateTick"then if cq then cq.AnimateTick()end elseif vE=="hudTick"then if cq then cq.hudtick()end elseif vE=="apTick"then if cs then cs.APTick()end elseif vE=="shieldTick"then cv.shieldTick()elseif vE=="tagTick"then cu.tagTick()elseif vE=="contact"then ct.ContactTick()end end;if vz then for dK,dw in pairs(vz)do uN[dK]=dw end end;return uN end;function script.onStart()vA.onStart()end;function script.onOnStop()vA.onStop()end;function script.onTick(vE)vA.onTick(vE)end;function script.onOnFlush()vA.onFlush()end;function script.onOnUpdate()vA.onUpdate()end;function script.onActionStart(uj)vA.controlStart(uj)end;function script.onActionStop(uj)vA.controlStop(uj)end;function script.onActionLoop(uj)vA.controlLoop(uj)end;function script.onInputText(r7)vA.controlInput(r7)end;function script.onEnter(dU)vA.radarEnter(dU)end;function script.onLeave(dU)vA.radarLeave(dU)end;bK(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vA=uK(d,core,unit,e,vBooster,hover,pA,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,iC,ua)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
