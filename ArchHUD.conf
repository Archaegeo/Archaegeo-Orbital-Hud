name: ArchHud - Archaegeo v1.512 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.512;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"function p(bR)system.print(E..": "..bR)end;local function bS(bT)local bU,bV,bW=aR:getPlanetarySystem(0):castIntersections(bv,bT,function(bX)if bX.noAtmosphericDensityAltitude>0 then return bX.radius+bX.noAtmosphericDensityAltitude else return bX.radius+bX.surfaceMaxAltitude*1.5 end end)local bY=bV;if bW~=nil and bV~=nil then bY=math.min(bW,bV)end;if bY~=nil then return bU,bY else return nil,nil end end;local function bZ(b_,c0,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..b_.."|"..c0 .."|"..soundVolume)end end;local function c1(c2,c3)for i=1,#c3 do c2[#c2+1]=c3[i]end;return c2 end;local function c4(c5)local c6={}local c7={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local c8={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c9={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local ca={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c5 then c1(c6,c7)c1(c6,c8)c1(c6,c9)c1(c6,ca)return c6 elseif c5=="boolean"then return c7 elseif c5=="handling"then return c8 elseif c5=="hud"then return c9 elseif c5=="physics"then return ca end end;local function cb(cc,cd,ce,cf,cg)if cf==nil then cf=""end;if cg==nil then cg=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cf,cc,cd,cg,ce)end;local function ch(ci,cj)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cj then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,ci)K=r(A(ci*100,0)/100,-1,1)end;local function ck(ci,cj)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cj then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,ci)bz=ci end;local function cl(cm,cn)if cm==0 then return d(cn)<1e-09 end;if cn==0 then return d(cm)<1e-09 end;return d(cm-cn)<math.max(d(cm),d(cn))*epsilon end;local function co(aj,cp)local cq=aj>100000;if cp==nil then cp=1 end;if cq then return A(aj/1000/200,cp).."SU"elseif aj<1000 then return A(aj,cp).."M"else return A(aj/1000,cp).."KM"end end;local function cr()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ck(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cs()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then bZ("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then bZ("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function ct()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bZ("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cs()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cs()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then bZ("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cr()end else bZ("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cr()end end;if am then HoldAltitude=100000 end else bZ("altOff","AH")if IntoOrbit then cs()end;if VertTakeOff then cr()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cu()local function cv(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then ct()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bZ("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bZ("apSpc","AP")if ar~=0 then am=true;ct()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bZ("vtt","AP")cv(SpaceTarget)end else bZ("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*2)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cs()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cs()end end end else bZ("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;ct()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cs()else bZ("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bZ("apP","AP")am=true;ct()end else bZ("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cs()end end end;local function cw()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then bZ("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cr()end;if IntoOrbit then cs()end;b0=autoRollPreference;al=false;an=false;af=0 else bZ("bkOff","B",1)end end;local function cx()if Reentry then a2="Re-Entry cancelled"bZ("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;bZ("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local ce=co(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..ce;bZ("glide","RE")ck(e(b7))end;AutoTakeoff=false end;local function cy()if antigrav and not ExternalAGG then if by then bZ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bZ("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cz(cA)local cB=0;local cC=0;local cD=0;if cA<60 then cA=e(cA)elseif cA<3600 then cB=e(cA/60)cA=e(cA%60)elseif cA<86400 then cC=e(cA/3600)cB=e(cA%3600/60)else cD=e(cA/86400)cC=e(cA%86400/3600)end;if cD>0 then return cD.."d "..cC.."h "elseif cC>0 then return cC.."h "..cB.."m "elseif cB>0 then return cB.."m "..cA.."s"elseif cA>0 then return cA.."s"else return"0s"end end;local function cE(cF)local function cG(cH)for cI,cJ in pairs(cH)do dbHud_1.setStringValue(cJ,h(_G[cJ]))if cF and dbHud_2 then dbHud_2.setStringValue(cJ,h(_G[cJ]))end end end;if dbHud_1 then cG(c)cG(c4())system.print("Saved Variables to Datacore")if cF and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cK()local function cL(cM)return type(cM)=='number'end;local function cN(cM)return type(z(cM))=='number'end;local function cO(cP)return type(cP)=='table'end;local function cQ(cR)return type(cR)=='string'end;local function cS(cJ)return cO(cJ)and cL(cJ.x and cJ.y and cJ.z)end;local function cT(cU)return cO(cU)and cL(cU.latitude and cU.longitude and cU.altitude and cU.id and cU.systemId)end;local cV=math.pi/180;local cW=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cX='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cY(cM)local cZ=string.gsub(string.reverse(f('%.4f',cM)),'^0*%.?','')return cZ==''and'0'or string.reverse(cZ)end;local function c_(d0)if cS(d0)then return f('{x=%.3f,y=%.3f,z=%.3f}',d0.x,d0.y,d0.z)end;if cO(d0)and not getmetatable(d0)then local d1={}local d2=next(d0)if type(d2)=='nil'or d2==1 then d1=d0 else for cI,cJ in pairs(d0)do local ci=c_(cJ)if type(cI)=='number'then table.insert(d1,f('[%s]=%s',cI,ci))else table.insert(d1,f('%s=%s',cI,ci))end end end;return f('{%s}',table.concat(d1,','))end;if cQ(d0)then return f("'%s'",d0:gsub("'",[[\']]))end;return tostring(d0)end;local d3={}d3.__index=d3;d3.__tostring=function(d0,d4)local d5={}for cI in pairs(d0)do table.insert(d5,cI)end;table.sort(d5)local d1={}for _,cI in ipairs(d5)do local ci=c_(d0[cI])if type(cI)=='number'then table.insert(d1,f('[%s]=%s',cI,ci))else table.insert(d1,f('%s=%s',cI,ci))end end;if d4 then return f('%s%s',d4,table.concat(d1,',\n'..d4))end;return f('{%s}',table.concat(d1,','))end;d3.__eq=function(d6,d7)return d6.systemId==d7.systemId and d6.id==d7.id and cl(d6.radius,d7.radius)and cl(d6.center.x,d7.center.x)and cl(d6.center.y,d7.center.y)and cl(d6.center.z,d7.center.z)and cl(d6.GM,d7.GM)end;local function d8(d9,da,db,dc,dd)assert(cN(d9),'Argument 1 (systemId) must be a number:'..type(d9))assert(cN(da),'Argument 2 (id) must be a number:'..type(da))assert(cN(db),'Argument 3 (radius) must be a number:'..type(db))assert(cO(dc),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dc))assert(cN(dd),'Argument 5 (GM) must be a number:'..type(dd))return setmetatable({systemId=z(d9),id=z(da),radius=z(db),center=vec3(dc),GM=z(dd)},d3)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cY(p.latitude*cW),cY(p.longitude*cW),cY(p.altitude))end;MapPosition.__eq=function(d6,d7)return d6.id==d7.id and d6.systemId==d7.systemId and cl(d6.latitude,d7.latitude)and cl(d6.altitude,d7.altitude)and(cl(d6.longitude,d7.longitude)or cl(d6.latitude,math.pi/2)or cl(d6.latitude,-math.pi/2))end;local function de(df,da,dg,dh,di)local d9=df;if cQ(df)and not dh and not di and not da and not dg then d9,da,dg,dh,di=o(df,cX)assert(d9,'Argument 1 (position string) is malformed.')else assert(cN(d9),'Argument 1 (systemId) must be a number:'..type(d9))assert(cN(da),'Argument 2 (id) must be a number:'..type(da))assert(cN(dg),'Argument 3 (latitude) must be in degrees:'..type(dg))assert(cN(dh),'Argument 4 (longitude) must be in degrees:'..type(dh))assert(cN(di),'Argument 5 (altitude) must be in meters:'..type(di))end;d9=z(d9)da=z(da)dg=z(dg)dh=z(dh)di=z(di)if da==0 then return setmetatable({latitude=dg,longitude=dh,altitude=di,id=da,systemId=d9},MapPosition)end;return setmetatable({latitude=cV*r(dg,-90,90),longitude=cV*(dh%360),altitude=di,id=da,systemId=d9},MapPosition)end;local dj={}dj.__index=dj;dj.__tostring=function(d0,d4)local dk=d4 and d4 ..'  'local dl={}local d5={}for cI in pairs(d0)do table.insert(d5,cI)end;table.sort(d5)for _,dm in ipairs(d5)do bdy=d0[dm]local dn=d3.__tostring(bdy,dk)if d4 then table.insert(dl,f('[%s]={\n%s\n%s}',dm,dn,d4))else table.insert(dl,f('  [%s]=%s',dm,dn))end end;if d4 then return f('\n%s%s%s',d4,table.concat(dl,',\n'..d4),d4)end;return f('{\n%s\n}',table.concat(dl,',\n'))end;local function dp(dq)local b={}local pid;for _,cJ in pairs(dq)do local da=cJ.planetarySystemId;if type(da)~='number'then error('Invalid planetary system ID: '..tostring(da))elseif pid and da~=pid then error('Mistringmatch planetary system IDs: '..da..' and '..pid)end;local dr=cJ.bodyId;if type(dr)~='number'then error('Invalid body ID: '..tostring(dr))elseif b[dr]then error('Duplicate body ID: '..tostring(dr))end;setmetatable(cJ.center,getmetatable(vec3.unit_x))b[dr]=setmetatable(cJ,d3)pid=da end;return setmetatable(b,dj)end;aQ={}local function ds(dq)return setmetatable({galaxyAtlas=dq or{}},aQ)end;aQ.__index=function(cP,i)if type(i)=='number'then local system=cP.galaxyAtlas[i]return dp(system)end;return rawget(aQ,i)end;aQ.__pairs=function(d0)return function(cP,cI)local dt,nv=next(cP,cI)return dt,nv and dp(nv)end,d0.galaxyAtlas,nil end;aQ.__tostring=function(d0)local du={}for _,dv in pairs(d0 or{})do local dw=dv:getPlanetarySystemId()local dx=dj.__tostring(dv,'    ')table.insert(du,f('  [%s]={%s\n  }',dw,dx))end;return f('{\n%s\n}\n',table.concat(du,',\n'))end;aQ.BodyParameters=d8;aQ.MapPosition=de;aQ.PlanetarySystem=dp;function aQ.createBodyParameters(d9,da,dy,dz,dA,dB,dC)assert(cN(d9),'Argument 1 (systemId) must be a number:'..type(d9))assert(cN(da),'Argument 2 (id) must be a number:'..type(da))assert(cN(dy),'Argument 3 (surfaceArea) must be a number:'..type(dy))assert(cO(dz),'Argument 4 (aPosition) must be an array or vec3:'..type(dz))assert(cO(dA),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dA))assert(cN(dB),'Argument 6 (altitude) must be in meters:'..type(dB))assert(cN(dC),'Argument 7 (gravityAtPosition) must be number:'..type(dC))local db=y(dy/4/math.pi)local aj=db+dB;local dD=vec3(dz)+aj*vec3(dA)local dd=dC*aj*aj;return d8(d9,da,db,dD,dd)end;aQ.isMapPosition=cT;function aQ:getPlanetarySystem(df)if i==nil then i=0 end;if nv==nil then nv=0 end;local d9=df;if cT(df)then d9=df.systemId end;if type(d9)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dj then system=dp(system)end;return system end end end;function dj:sizeCalculator(bX)return 1.05*bX.radius end;function dj:castIntersections(dE,dF,dG,dH,dI,dJ)local dK={}local dL=dI or self;for _,bX in pairs(dL)do table.insert(dK,bX)end;if not dJ then table.sort(dK,function(dM,dN)return(dM.center-dE):len()<(dN.center-dE):len()end)end;local dO=dF:normalize()for _,bX in ipairs(dK)do local dP=bX.center-dE;local db=self:sizeCalculator(bX)local dQ=dP:dot(dO)local dR=dQ^2-(dP:len2()-db^2)if dR>=0 then local dS=y(dR)local bV=dQ+dS;local bW=dQ-dS;if bW>0 then return bX,bV,bW elseif bV>0 then return bX,bV,nil end end end;return nil,nil,nil end;function dj:closestBody(dT)assert(type(dT)=='table','Invalid coordinates.')local dU,bX;local dV=vec3(dT)for _,dW in pairs(self)do local dX=(dW.center-dV):len2()if(not bX or dX<dU)and dW.name~="Space"then bX=dW;dU=dX end end;return bX end;function dj:convertToBodyIdAndWorldCoordinates(df)local dY=df;if cQ(df)then dY=de(df)end;if dY.id==0 then return 0,vec3(dY.latitude,dY.longitude,dY.altitude)end;local dW=self:getBodyParameters(dY)if dW then return dY.id,dW:convertToWorldCoordinates(dY)end end;function dj:getBodyParameters(df)local da=df;if cT(df)then da=df.id end;assert(cN(da),'Argument 1 (id) must be a number:'..type(da))return self[da]end;function dj:getPlanetarySystemId()local _,cJ=next(self)return cJ and cJ.systemId end;function d3:convertToMapPosition(dc)assert(cO(dc),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dc))local dZ=vec3(dc)if self.id==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,id=0,systemId=self.systemId},MapPosition)end;local d_=dZ-self.center;local aj=d_:len()local di=aj-self.radius;local dg=0;local dh=0;if not cl(aj,0)then local e0=n(d_.y,d_.x)dh=e0>=0 and e0 or 2*math.pi+e0;dg=math.pi/2-math.acos(d_.z/aj)end;return setmetatable({latitude=dg,longitude=dh,altitude=di,id=self.id,systemId=self.systemId},MapPosition)end;function d3:convertToWorldCoordinates(df)local dY=cQ(df)and de(df)or df;if dY.id==0 then return vec3(dY.latitude,dY.longitude,dY.altitude)end;assert(cT(dY),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dY.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dY.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e1=math.cos(dY.latitude)return self.center+(self.radius+dY.altitude)*vec3(e1*math.cos(dY.longitude),e1*math.sin(dY.longitude),math.sin(dY.latitude))end;function d3:getAltitude(dc)return(vec3(dc)-self.center):len()-self.radius end;function d3:getDistance(dc)return(vec3(dc)-self.center):len()end;function d3:getGravity(dc)local e2=self.center-vec3(dc)local e3=e2:len2()return self.GM/e3*e2/y(e3)end;return setmetatable(aQ,{__call=function(_,...)return ds(...)end})end;local function e4()local aS={}local e5=30000000/3600;local e6=e5*e5;local e7=100;function aS.computeAccelerationTime(e8,e9,ea)local eb=e5*math.asin(e8/e5)return(e5*math.asin(ea/e5)-eb)/e9 end;function aS.computeDistanceAndTime(e8,ea,ec,ed,ee,ef)ee=ee or 0;ef=ef or 0;local eg=e8<=ea;local eh=ed*(eg and 1 or-1)/ec;local ei=-ef/ec;local ej=eh+ei;if eg and ej<=0 or not eg and ej>=0 then return-1,-1 end;local ek,el=0,0;if eh~=0 and ee>0 then local eb=math.asin(e8/e5)local em=math.pi*(eh/2+ei)local en=eh*ee;local eo=e5*math.pi;local cJ=function(cP)local ep=(em*cP-en*math.sin(math.pi*cP/2/ee)+eo*eb)/eo;local eq=math.tan(ep)return e5*eq/y(eq*eq+1)end;local er=eg and function(cR)return cR>=ea end or function(cR)return cR<=ea end;el=2*ee;if er(cJ(el))then local es=0;while d(el-es)>0.5 do local cP=(el+es)/2;if er(cJ(cP))then el=cP else es=cP end end end;local et=e8;local eu=el/e7;for ev=1,e7 do local ew=cJ(ev*eu)ek=ek+(ew+et)*eu/2;et=ew end;if el<2*ee then return ek,el end;e8=et end;local eb=e5*math.asin(e8/e5)local E=(e5*math.asin(ea/e5)-eb)/ej;local ex=e6*math.cos(eb/e5)/ej;local aj=ex-e6*math.cos((ej*E+eb)/e5)/ej;return aj+ek,E+el end;function aS.computeTravelTime(e8,e9,aj)if aj==0 then return 0 end;if e9>0 then local eb=e5*math.asin(e8/e5)local ex=e6*math.cos(eb/e5)/e9;return(e5*math.acos(e9*(ex-aj)/e6)-eb)/e9 end;if e8==0 then return-1 end;assert(e8>0,'Acceleration and initial speed are both zero.')return aj/e8 end;return aS end;local function ey()local vec3=require('cpml.vec3')local cK=cK()local function cQ(cR)return type(cR)=='string'end;local function cO(cP)return type(cP)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(di)assert(self.body)local aj=di+self.body.radius;if not cl(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(df,ez)assert(self.body)assert(cO(df)or cQ(df))assert(cO(ez))local eA=(cQ(df)or cK.isMapPosition(df))and self.body:convertToWorldCoordinates(df)or vec3(df)local cJ=vec3(ez)local eB=eA-self.body.center;local eC=cJ:len2()local eD=eB:len()local eE=self.body.GM;local eF=((eC-eE/eD)*eB-eB:dot(cJ)*cJ)/eE;local cm=eE/(2*eE/eD-eC)local eG=eF:len()local dO=eF:normalize()local eH=cm*(1-eG)local eI=cm*(1+eG)local eJ=eH*dO+self.body.center;local eK=eG<=1 and-eI*dO+self.body.center or nil;local eL=y(cm*eE*(1-eG*eG))local eM=eK and 2*math.pi*y(cm^3/eE)local eN=math.acos(eF:dot(eB)/(eG*eD))if eB:dot(cJ)<0 then eN=-(eN-2*math.pi)end;local eO=math.acos((math.cos(eN)+eG)/(1+eG*math.cos(eN)))local eP=eO;if eP<0 then eP=eP+2*math.pi end;local eQ=eP-eG*math.sin(eP)local eR=0;local eS=0;local eT=0;if eM~=nil then eR=eQ/(2*math.pi/eM)eS=eM-eR;eT=eS+eM/2;if eN-math.pi>0 then eS=eR;eT=eS+eM/2 end;if eT>eM then eT=eT-eM end end;return{periapsis={position=eJ,speed=eL/eH,circularOrbitSpeed=y(eE/eH),altitude=eH-self.body.radius},apoapsis=eK and{position=eK,speed=eL/eI,circularOrbitSpeed=y(eE/eI),altitude=eI-self.body.radius},currentVelocity=cJ,currentPosition=eA,eccentricity=eG,period=eM,eccentricAnomaly=eO,meanAnomaly=eQ,timeToPeriapsis=eS,timeToApoapsis=eT}end;local function eU(eV)local dW=cK.BodyParameters(eV.systemId,eV.id,eV.radius,eV.center,eV.GM)return setmetatable({body=dW},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eU(...)end})end;local function eW()local eX={}local eY={}local eZ={XS=13,S=27,M=55,L=110,XL=221}local e_={}local f0;local f1;local f2;local f3;local f4;local function f5()local function f6(f7,f8,f9,fa,fb,fc,fd,fe)f8,fa,fc,fe=vec3(f8),vec3(fa),vec3(fc),vec3(fe)local ff,fg,fh=f7*f7,f9*f9,fb*fb;local eC=fa-f8;local fi=eC:normalize()local fj=eC:len()local fk=fc-f8;local fl=(fk-fk:project_on(fi)):normalize()local fm,fn=fk:dot(fi),fk:dot(fl)local fo=fm*fm+fn*fn;local fp=fi:cross(fl)local cc=(ff-fg+fj*fj)/(2*fj)local cd=(ff-fh+fo-2*fm*cc)/(2*fn)local cU=ff-cc^2-cd^2;local fq=y(cU)local fr=f8+fi*cc+fl*cd+fp*fq;local fs=f8+fi*cc+fl*cd-fp*fq;if d((fe-fr):len()-fd)<d((fe-fs):len()-fd)then return fr else return fs end end;local function ft()local function fu()local fv=core.getConstructWorldOrientationRight()local eC=core.getConstructWorldOrientationForward()local fk=core.getConstructWorldOrientationUp()local fw=library.systemResolution3(fv,eC,fk,{1,0,0})local fx=library.systemResolution3(fv,eC,fk,{0,1,0})local fy=library.systemResolution3(fv,eC,fk,{0,0,1})return function(fz)return library.systemResolution3(fw,fx,fy,fz)end end;local fA=fu()local fB=core.getConstructWorldPos()local eA=core.getElementPositionById(1)local fC={eA[1],eA[2],eA[3]}local fD=fA(fC)local fE={fB[1]-fD[1],fB[2]-fD[2],fB[3]-fD[3]}return fE end;local function fF(fG,eD,fH)local fI=fG.pts;local fJ=#fI;local fK=fG.ref;if fJ>3 then local fL,fM,fN,fO=fI[fJ],fI[fJ-1],fI[fJ-2],fI[fJ-3]fG.ref=fH;local eA=f6(fL[1],fL[2],fM[1],fM[2],fN[1],fN[2],fO[1],fO[2])local cc,cd,fq=eA.x,eA.y,eA.z;if cc==cc and cd==cd and fq==fq then cc=cc+fK[1]cd=cd+fK[2]fq=fq+fK[3]local fP=vec3(cc,cd,fq)if not fG.lastPos then fG.center=fP elseif(fG.lastPos-fP):len()<2 then fG.center=fP;fG.skipCalc=true end;fG.lastPos=fP end;fG.pts={}else local fQ={fH[1]-fK[1],fH[2]-fK[2],fH[3]-fK[3]}fI[fJ+1]={eD,fQ}end end;if bP[1]then f0=#bP[1].getConstructIds()local fR=bP[1].getData()local fS=fR:gmatch('{"constructId[^}]*}[^}]*}')if f0>0 then local fH=ft()local fT,fU=0,0;f4,f3=0,0;for cJ in fS do local da,aj,fV=cJ:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fW=eZ[fV]aj=z(aj)if bP[1].hasMatchingTransponder(da)==1 then table.insert(eY,da)end;local fX=bP[1].getConstructType(da)if CollisionSystem then if fW>27 or fX=="static"or fX=="space"then f4=f4+1;local fY=bP[1].getConstructName(da)local fG=bL[da]if fG==nil then fW=fW+G;bL[da]={pts={},ref=fH,name=fY,i=0,radius=fW,skipCalc=false}fG=bL[da]end;if not fG.skipCalc then fF(fG,aj,fH)fU=fU+1 end;if fG.center then table.insert(e_,fG)end end;fT=fT+1;if bM and fT>700 or fU>70 or(not bM and fT>300 or fU>30)then coroutine.yield()fT,fU=0,0 end end end;f3=#e_;if f3>0 and bs>20 then local bX,fZ,f_,g0;local g1=0;local g2=aR:getPlanetarySystem(0)g0=br:normalize()while g1<f3 do coroutine.yield()local g3={table.unpack(e_,g1,math.min(g1+75,f3))}bX,fZ,f_=g2:castIntersections(bv,g0,nil,nil,g3,true)if bX and f_ then bO={bX,fZ,f_}break end;g1=g1+75 end;if not bX then bO=nil end else bO=nil end;e_={}f1=fR:find('identifiedConstructs":%[%]')else f2=fR:find('worksInEnvironment":false')end end end;local function g4()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function eX.pickType()g4()end;function eX.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then g4()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then g4()end end end;function eX.UpdateRadar()local g5=coroutine.status(UpdateRadarCoroutine)if g5=="suspended"then local ci,g6=coroutine.resume(UpdateRadarCoroutine)if g6 then system.print("ERROR UPDATE RADAR: "..g6)end elseif g5=="dead"then UpdateRadarCoroutine=coroutine.create(f5)local ci,g6=coroutine.resume(UpdateRadarCoroutine)end end;function eX.GetRadarHud()local g7=eY;eY={}return f1,f2,f0,f3,f4,g7 end;UpdateRadarCoroutine=coroutine.create(f5)return eX end;local function g8()local g9=9.80665;local ga=vec3({13771471,7435803,-128971})local gb=18000000;local gc=500000;local gd,ge=math.huge;local gf;local function gg(gh)gd=vec3(gh):dist(ga)if gd<gb then return true,d(gd-gb)end;ge=vec3(gh):dist(vec3(planet.center))if ge<gc then gf=true else gf=false end;if d(ge-gc)<d(gd-gb)then return gf,d(ge-gc)else return gf,d(gd-gb)end end;local function gi(cJ)if aG==1920 then return cJ else return A(aG*cJ/1920,0)end end;local function gj(cJ)if aH==1080 then return cJ else return A(aH*cJ/1080,0)end end;local function gk()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gl()local gm="TRAVEL"if not bA then gm="CRUISE"end;if Autopilot then gm="AUTOPILOT"end;return gm end;local gn=""local go=""local gp=""local gq=1;local gr=2;local gs=3;local gt=4;local gu=5;local gv=6;local gw=""local gx=0;local gy=e(1/apTickRate)*2*hudTickRate;local gz={}local gA={}local gB={}local gC={}local gD={}local gE={}local function gF(cc,gG,gH,gI,gJ,gK)local gL=fuelY;local gM=fuelY+5;if not BarFuelDisplay then gM=gM+5 end;if m()==1 and not RemoteHud then gL=gL-50;gM=gM-50 end;if gH=="ATMO"then gw="atmofueltank"elseif gH=="SPACE"then gw="spacefueltank"else gw="rocketfueltank"end;gx=_G[gw.."_size"]if#gI>0 then for i=1,#gI do local fY=string.sub(gI[i][gr],1,12)local gN=0;for gO=1,gx do if gI[i][gr]==g(unit[gw.."_"..gO].getData()).name then gN=gO;break end end;local gP=q()if gJ[i]==nil or gK[i]==nil or gP-gI[i][gv]>gy then local gQ;local gR=0;if gN~=0 then gK[i]=g(unit[gw.."_"..gN].getData()).percentage;gJ[i]=g(unit[gw.."_"..gN].getData()).timeLeft;if gJ[i]=="n/a"then gJ[i]=0 end else gR=l(gI[i][gq])-gI[i][gt]gK[i]=e(0.5+gR*100/gI[i][gs])gQ=gI[i][gu]if gQ<=gR then gJ[i]=0 else gJ[i]=e(0.5+gR/((gQ-gR)/(gP-gI[i][gv])))end;gI[i][gu]=gR;gI[i][gv]=gP end end;if fY==gG then fY=f("%s %d",gH,i)end;if gN==0 then fY=fY.." *"end;local gS;if gJ[i]==0 then gS=""else gS=cz(gJ[i])end;if gK[i]~=nil then local gT=e(gK[i]*2.55)local gU=f("rgb(%d,%d,%d)",255-gT,gT,0)local cf=""if gS~=""and gJ[i]<120 or gK[i]<5 then cf="red "end;if BarFuelDisplay then go=go..f([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cc,gM,gU,gK[i],cc,gM,cc+2,gM+10,gK[i],gS)go=go..cb(cc,gL,fY,cf.."txtstart pdim txtfuel")gL=gL-30;gM=gM-30 else go=go..cb(cc,gL,fY,cf.."pdim txtfuel")go=go..cb(cc,gM,f("%d%% %s",gK[i],gS),"pdim txtfuel","fill:"..gU)gL=gL+30;gM=gM+30 end end end end end;local function gV(gW,di)if di<200000 and not aq or di and aq then local gX=0;if d(bu)>1 then gX=45*math.log(d(bu),10)if bu<0 then gX=-gX end end;gW[#gW+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(gX))end;return gW end;local function gY(gZ)local g_=-bt;gZ=gZ-gZ:project_on(g_)local h0=vec3(0,0,1)h0=h0-h0:project_on(g_)local h1=h0:cross(g_)local gX=h0:angle_between(gZ)*constants.rad2deg;if gZ:dot(h1)<0 then gX=360-gX end;return gX end;local function h2(gW,centerX,centerY,h3,h4,bM)local h5=circleRad;local h6=20;local h7=e(h3)if bM then for i=-45,45,5 do local h8=i;gW[#gW+1]=f([[<g transform="rotate(%f,%d,%d)">]],h8,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gW[#gW+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h5+h6-len,centerX,centerY+h5+h6)end;gW[#gW+1]=cb(centerX,centerY+h5+h6-35,h4,"pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY+h5+h6-25,h7 .." deg","pdim txt txtmid")gW[#gW+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)gW[#gW+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h5+h6-20,centerX+5,centerY+h5+h6-20,centerX,centerY+h5+h6-15)gW[#gW+1]="</g>"end;local h9=h7;if bM then h9=gY(bo)end;local ha=20;local hb=e(h9)local hc=0;local hd=centerY+h5+h6+20;local he=centerX;if h4~="YAW"then hd=gj(130)he=gi(960)end;local hf=[[<path class="txttick line" d="]]local hg=e(hb-(ha+10)-hb%5+0.5)for i=hg+60,hg,-5 do local cc=he-(-i*5+h9*5)if i%10==0 then hc=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gW[#gW+1]=cb(cc+5,hd-12,B)elseif i%5==0 then hc=5 end;if hc==10 then hf=f([[%s M %f %f v %d]],hf,cc,hd-5,hc)else hf=f([[%s M %f %f v %d]],hf,cc,hd-2.5,hc)end end;gW[#gW+1]=hf..[["/>]]gW[#gW+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],he-5,hd+10,he+5,hd+10,he,hd+5)if bM then h4="HDG"end;gW[#gW+1]=cb(he,hd+25,hb.."deg","pdim txt txtmid","")gW[#gW+1]=cb(he,hd+35,h4,"pdim txt txtmid","")end;local function hh(gW,hi,h3,centerX,centerY,bM,hj,ew)local h5=circleRad;local hk=e(h5*3/5)if h5>0 then local hl=e(hi)local len=0;local hf=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h3,centerX,centerY)if not aq then hf=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gW[#gW+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h5-1,centerX,centerY)gW[#gW+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hl-30-hl%5+0.5),e(hl+30+hl%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cd=centerY+-i*5+hi*5;if len==30 then hf=f([[%s M %d %f h %d]],hf,centerX-hk-len,cd,len)if aq then gW[#gW+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX-hk+10,cd,i)gW[#gW+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h3,centerX,centerY,centerX+hk-10,cd,i)if i==0 or i==180 or i==-180 then gW[#gW+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+20,cd,hk*2-40)end else gW[#gW+1]=cb(centerX-hk+10,cd,i,"pdim txt txtmid")gW[#gW+1]=cb(centerX+hk-10,cd,i,"pdim txt txtmid")end;hf=f([[%s M %d %f h %d]],hf,centerX+hk,cd,len)else hf=f([[%s M %d %f h %d]],hf,centerX-hk-len,cd,len)hf=f([[%s M %d %f h %d]],hf,centerX+hk,cd,len)end end;gW[#gW+1]=hf..[["/>]]local hm="PITCH"if not bM then hm="REL PITCH"end;if hi>90 and not aq then hi=90-(hi-90)elseif hi<-90 and not aq then hi=-90-(hi+90)end;if h5>200 then if aq then if ew>Q then gW[#gW+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY+20,hj,"pdim txt txtmid")end;gW[#gW+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h3,centerX,centerY)else gW[#gW+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gW[#gW+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hk+25,centerY-5,centerX-hk+20,centerY,centerX-hk+25,centerY+5,centerX-hk+50,centerY+4,hl)gW[#gW+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hk-25,centerY-5,centerX+hk-20,centerY,centerX+hk-25,centerY+5,centerX+hk-30,centerY+4,hl)gW[#gW+1]="</g>"end;local hn=e(h5/3)gW[#gW+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hn,centerY,h5-hn)if not aq and bM then gW[#gW+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h3,centerX,centerY,centerX-hk+10,centerY,hk*2-20)end;gW[#gW+1]="</g>"if h5<200 then if aq and ew>Q then gW[#gW+1]=cb(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY-h5+10,hl,"pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY+20,hj,"pdim txt txtmid")else gW[#gW+1]=cb(centerX,centerY-h5,hm,"pdim txt txtmid")gW[#gW+1]=cb(centerX,centerY-h5+15,hl,"pdim txt txtmid")end end end end;local function ho(gW,di,bM)local hp=altMeterX;local hq=altMeterY;local hr=78;local hs=19;local ht=ao;if ao~=-1 then gW[#gW+1]=cb(hp+hr,hq+hs+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(di<200000 and not aq or di and aq)then table.insert(gW,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hp-1,hq-4,hr+2,hs+6,hp+1,hq-1,hr-4,hs))local fJ=0;local hu=1;local hv=0;local hw=di<0;local hx=di<planet.surfaceMaxAltitude;local hy=9;if hw then hy=0 end;local di=d(di)while fJ<6 do local hz=11;local hA=16;local hB=9;local hC=14;local cf="altsm"if fJ>2 then hA=hA+3;hz=hz+2;hC=hC+2;hB=hB-6;cf="altbig"end;if hw then cf=cf.." red"elseif hx then cf=cf.." orange"end;local hD=di/hu%10;local hE=e(hD)local hF=e((hE+1)%10)local hG=hv;if fJ==0 then hG=hD-hE;if hw then hG=1-hG end end;if hw and(fJ==0 or hv~=0)then local hH=hF;hF=hE;hE=hH end;local hI=hA*(hG-1)local hJ=hI+hA;local cc=hp+hB+(6-fJ)*hz;local cd=hq+hC;gW[#gW+1]=cb(cc,cd+hI,hF,cf)gW[#gW+1]=cb(cc,cd+hJ,hE,cf)fJ=fJ+1;hu=hu*10;if hE==hy then hv=hG else hv=0 end end;table.insert(gW,[[</g></g>]])end end;local function hK(ez)local hL=-math.deg(n(ez.y,ez.z))+180;hL=hL-90;if hL<0 then hL=360+hL end;if hL>180 then hL=-180+hL-180 end;return-hL end;local function hM(ez)local h9=math.deg(n(ez.y,ez.x))-90;if h9<-180 then h9=360+h9 end;return h9 end;local function hN(gW,ez,ew,centerX,centerY)if ew>5 and not aq or ew>Q then local h5=circleRad;local hO=20;local hP=20;local hQ=hK(ez)local hR=hM(ez)local hS=14;local hT=hS/2;local hU=-hR/hP*h5;local hV=hQ/hO*h5;local cc=centerX+hU;local cd=centerY+hV;local aj=y(hU^2+hV^2)local hW=[[<circle
                            cx="]]..cc..[["
                            cy="]]..cd..[["
                            r="]]..hT/hS..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cc..[["
                            cy="]]..cd..[["
                            r="]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cc-hS..[[,]]..cd..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cc+hT..[[,]]..cd..[[ h ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cc..[[,]]..cd-hS..[[ v ]]..hT..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h5 then gW[#gW+1]=hW else local gX=n(hV,hU)local hX=4;local hY=centerX+h5*math.cos(gX)local hZ=centerY+h5*math.sin(gX)gW[#gW+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gX*180/math.pi,hY,hZ,hY-hX,hZ-hX/2,hX*2,hX,hY+hX,hZ-hX,hX,hX,-hX,hX)end;if not aq then local h_=vec3(ez)hQ=hK(-h_)hR=hM(-h_)hU=-hR/hP*h5;hV=hQ/hO*h5;cc=centerX+hU;cd=centerY+hV;aj=y(hU^2+hV^2)if aj<h5 then local i0=[[<circle
                                    cx="]]..cc..[["
                                    cy="]]..cd..[["
                                    r="]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cc..[[,]]..cd-hS..[[ v ]]..hT..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cc..[[,]]..cd..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cc..[[,]]..cd..[[)" />
                                <path
                                    d="M ]]..cc-hT..[[,]]..cd..[[ h ]]..hS..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cc..[[,]]..cd..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cc..[[,]]..cd..[[)"/>]]gW[#gW+1]=i0 end end end end;local function i1(gW,gm,i2,i3)i2=e(i2+0.5)local gL=throtPosY+10;local gM=throtPosY+20;if m()==1 and not RemoteHud then gL=55;gM=65 end;local i4="CRUISE"local unit="km/h"local ci=i3;if gm=="TRAVEL"or gm=="AUTOPILOT"then i4="THROT"unit="%"ci=i2;local i5="dim"if i2<0 then i5="red"end;gW[#gW+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i5,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gW[#gW+1]=cb(throtPosX+10,gL,i4,"pbright txtstart")gW[#gW+1]=cb(throtPosX+10,gM,f("%.0f %s",ci,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then i2=e(N*100+0.5)local i5="red"if i2<0 then i5="red"end;gW[#gW+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i5,1-d(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gW[#gW+1]=cb(throtPosX+10,gL+40,"LIMIT","pbright txtstart")gW[#gW+1]=cb(throtPosX+10,gM+40,i2 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gW[#gW+1]=cb(throtPosX+10,gL-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then gW[#gW+1]=cb(throtPosX+10,gL-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i6(gW,i7)local i8=throtPosY-10;local i9=throtPosX+10;gW[#gW+1]=cb(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then i8=75 end;gW[#gW+1]=cb(i9,i8,e(i7).." km/h","pbright txtbig txtstart")end;local function ia(gW)gW[#gW+1]=cb(gi(1900),gj(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gW[#gW+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gW[#gW+1]=cb(gi(960),gj(550),"Warning: Invalid Control Scheme Detected","warnings")gW[#gW+1]=cb(gi(960),gj(600),"Keyboard Scheme must be selected","warnings")gW[#gW+1]=cb(gi(960),gj(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ib=gi(960)local ic=gj(860)local id=gj(880)local ie=gj(900)local ig=gj(960)local ih=gj(200)local ii=gj(250)local ij=gj(960)if m()==1 and not RemoteHud then ic=gj(135)id=gj(155)ie=gj(175)ih=gj(115)ii=gj(95)end;if BrakeIsOn then gW[#gW+1]=cb(ib,ic,"Brake Engaged","warnings")elseif L>0 then gW[#gW+1]=cb(ib,ic,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gW[#gW+1]=cb(ib,ih+50,"** STALL WARNING **","warnings")bZ("stall","SW",2)end end;if bK then gW[#gW+1]=cb(ib,ih+90,"Flight Assist in Progress","warnings")end;if ax then gW[#gW+1]=cb(ib,ij,"Gyro Enabled","warnings")end;if GearExtended then if S then gW[#gW+1]=cb(ib,id,"Gear Extended","warn")else gW[#gW+1]=cb(ib,id,"Landed (G: Takeoff)","warnings")end;local ik=co(a:getTargetGroundAltitude())gW[#gW+1]=cb(ib,ie,"Hover Height: "..ik,"warn")end;if a7 then gW[#gW+1]=cb(ib,ig+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if d(as-antigrav.getBaseAltitude())<501 then gW[#gW+1]=cb(ib,ih+15,f("AGG On - Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gW[#gW+1]=cb(ib,ih+15,f("AGG On - Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gW[#gW+1]=cb(ib,ih+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gW[#gW+1]=cb(ib,ih+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gW[#gW+1]=cb(ib,ih+20,"Follow Mode Engaged","warn")elseif Reentry or an then gW[#gW+1]=cb(ib,ih+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=co(HoldAltitude,2)if VertTakeOff then if by then ik=co(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gW[#gW+1]=cb(ib,ih,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gW[#gW+1]=cb(ib,ih,"Takeoff to "..AutopilotTargetName,"warn")else gW[#gW+1]=cb(ib,ih,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gW[#gW+1]=cb(ib,ih+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gW[#gW+1]=cb(ib,ih,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gW[#gW+1]=cb(ib,ih+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gW[#gW+1]=cb(ib,ih+20,"Aligning trajectory","warn")elseif ar<0.05 then gW[#gW+1]=cb(ib,ih+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gW[#gW+1]=cb(ib,ih,b9,"warn")end end;if BrakeLanding then if StrongBrakes then gW[#gW+1]=cb(ib,ih,"Brake-Landing","warnings")else gW[#gW+1]=cb(ib,ih,"Coast-Landing","warnings")end end;if ProgradeIsOn then gW[#gW+1]=cb(ib,ih,"Prograde Alignment","crit")end;if RetrogradeIsOn then gW[#gW+1]=cb(ib,ih,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gW[#gW+1]=cb(ib,ii+20,bN,type)elseif ar==0 then local bU,bY=bS(br:normalize())if bY~=nil then local ik=co(bY)local travelTime=aS.computeTravelTime(bs,0,bY)local il="Collision"if bU.noAtmosphericDensityAltitude>0 then il="Atmosphere"end;gW[#gW+1]=cb(ib,ii+20,bU.name.." "..il.." "..cz(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gW[#gW+1]=cb(ib,ih+35,VectorStatus,"warn")end;gW[#gW+1]="</g>"return gW end;local function im(ew)return e(A(ew*3.6,0)+0.5).." km/h"end;local function io(gW)local ip=OrbitMapX;local iq=OrbitMapY;local ir=OrbitMapSize;local is=4;local it=15;local cc=0;local cd=0;local iu,iv,iw,ix;local function iy(type)local iz,E,ew,iA;if type=="Periapsis"then iz=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;ew=orbit.periapsis.speed;iA=35 else iz=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;ew=orbit.apoapsis.speed;iA=-35 end;gW[#gW+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cc+iA,cd-5,ip+ir/2-iu+ix,cd-5)gW[#gW+1]=cb(cc,cd,type)cd=cd+it;local ik=co(iz)gW[#gW+1]=cb(cc,cd,ik)cd=cd+it;gW[#gW+1]=cb(cc,cd,cz(E))cd=cd+it;gW[#gW+1]=cb(cc,cd,im(ew))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then iq=iq+is;cc=ip+ir+ip/2+is;cd=iq+ir/2+5+is;iu=ir/4;ix=0;gW[#gW+1]=[[<g class="pbright txtorb txtmid">]]gW[#gW+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ir+ip*2,ir+iq,is,is)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iw=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iu*2)iv=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iw*(1-orbit.eccentricity)ix=iu-orbit.periapsis.altitude/iw-planet.radius/iw;local iB=""if orbit.periapsis.altitude<=0 then iB='redout'end;gW[#gW+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iB,ip+ir/2+ix+is,iq+ir/2+is,iu,iv)gW[#gW+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ip+ir/2+is,iq+ir/2+is,planet.radius/iw)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iy("Apoapsis")end;cd=iq+ir/2+5+is;cc=ip-ip/2+10+is;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iy("Periapsis")end;gW[#gW+1]=cb(ip+ir/2+is,planet.name,20+is,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iC=orbit.timeToApoapsis/orbit.period*2*math.pi;local iD=iu*math.cos(iC)local iE=iv*math.sin(iC)gW[#gW+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ip+ir/2+iD+ix+is,iq+ir/2+iE+is)end;gW[#gW+1]=[[</g>]]return gW else return gW end end;local function iF(gW)local cc=30;local cd=275;local iG={}local iH={"Alt-4: AutoTakeoff to Target"}local iI={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iJ={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iK={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iG,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then c1(iG,iH)if ac and planet and ac.name==planet.name then table.insert(iG,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(iG,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iG,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iG,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iG,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iG,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iG,"G: Takeoff to hover height, raise gear")else table.insert(iG,"G: Lowergear and Land")end else c1(iG,iI)table.insert(iG,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iG,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c1(iG,iJ)if shield_1 then table.insert(iG,"Alt-Shift-5: Toggle shield off and on")table.insert(iG,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iG,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iG,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iG,"Alt-Spacebar/C will raise/lower target height")table.insert(iG,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iG,"LALT+Mousewheel will lower/raise speed limit")end;c1(iG,iK)for i=1,#iG do cd=cd+12;gW[#gW+1]=cb(cc,cd,iG[i],"pdim txttick txtstart")end end;local function iL(iM,iN)local iO;local iP=(iN-iM):normalize()local eB=(bv-iM):dot(iP)/iP:dot(iP)if eB<=0.then return(bv-iM):len()elseif eB>=(iN-iM):len()then return(bv-iN):len()end;local iQ=iM+eB*iP;iO=(iQ-bv):len()return iO end;local function iR()local iO;local iS=nil;local iT=nil;local iU=nil;for cI,iV in pairs(b[0])do if iV.hasAtmosphere then local aj=iL(planet.center,iV.center)if iS==nil or aj<iS then iT=iV;iS=aj;iU=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dX=iL(ac.center,iV.center)if dX<iS then iT=iV;iS=dX;iU=ac end end end end;local iW=gi(1770)local iX=gj(330)if iS then local iY="txttick "local iZ=500000;if iS<iT.radius+iZ or iS<iU.radius+iZ then if bH then iY="txttick red "else iY="txttick orange "end end;iO=co(iS,2)bJ=cb(iW,iX,"Pipe ("..iU.name.."--"..iT.name.."): "..iO,iY.."pbright txtmid")end end;local i_={}function i_.HUDPrologue(gW)bH,bI=gg(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local j0=ay;local j1=az;local j2=ay;local j3=az;if gk()and not brightHud then j0=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.3+0.5)..[[)]]j1=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;gW[#gW+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],j0,j0,j2,j2,j1,j1,j3,j3,aG,aH)return gW end;function i_.DrawVerticalSpeed(gW,di)gV(gW,di)end;function i_.UpdateHud(gW)local hL=bB;local j4=bC;local h3=j4;local hi=hL;local i2=e(unit.getThrottle())local i7=bs*3.6;local i3=unit.getAxisCommandValue(0)local j5=gi(1770)local j6=gj(310)if AtmoSpeedAssist and bA then i3=K;i2=K*100 end;local gm=gl()local h4="ROLL"if i2==nil then i2=0 end;if not bM then if bs>5 then hL=hK(bq)j4=hM(bq)else hL=0;j4=0 end;h4="YAW"end;if bI>50000 and not aq then local j7;j7=co(bI)gW[#gW+1]=cb(j5,j6,"PvP Boundary: "..j7,"pbright txtbig txtmid")end;gW[#gW+1]=ak;gW[#gW+1]=aD;gW[#gW+1]=gn;if bJ~=""then gW[#gW+1]=bJ end;if go~=""then gW[#gW+1]=go end;if gp~=""then gW[#gW+1]=gp end;gV(gW,as)if m()==0 or RemoteHud then if not gk()or brightHud then if bM then h2(gW,centerX,centerY,h3,h4,bM)hh(gW,hi,h3,centerX,centerY,bM,e(hM(bq)),bs)else h2(gW,centerX,centerY,j4,h4,bM)hh(gW,hL,j4,centerX,centerY,bM,e(j4),bs)end;ho(gW,as,bM)hN(gW,bq,bs,centerX,centerY)end end;i1(gW,gm,i2,i3)i6(gW,i7)ia(gW)io(gW)if showHelp then iF(gW)end;return gW end;function i_.HUDEpilogue(gW)gW[#gW+1]="</svg>"return gW end;function i_.ExtraData(gW)local j8=gi(1240)local j9=gj(55)local ja=j9+10;local jb;local jc=0;local gm=gl()if VertTakeOffEngine then gm=gm.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then gm=gm.."-COLLISION ON"end;if UseExtra~="Off"then gm="("..UseExtra..")-"..gm end;if TurnBurn then gm="TB-"..gm end;if not stablized then gm=gm.."-DeCoupled"end;local jd=vec3(core.getWorldAcceleration()):len()/9.80665;jb=core.g()gW[#gW+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then j8=gi(1120)j9=gj(55)ja=j9+10 elseif aq then local je=gi(770)gW[#gW+1]=cb(je,j9,"ATMOSPHERE","pdim txt txtend")gW[#gW+1]=cb(je,ja,f("%.2f",ar),"pdim txt txtend","")end;gW[#gW+1]=cb(j8,j9,"GRAVITY","pdim txt txtend")gW[#gW+1]=cb(j8,ja,f("%.2f",jb/9.80665),"pdim txt txtend")gW[#gW+1]=cb(j8,j9+20,"ACCEL","pdim txt txtend")gW[#gW+1]=cb(j8,ja+20,f("%.2f",jd),"pdim txt txtend")gW[#gW+1]=cb(gi(960),gj(180),gm,"txtbig txtmid")end;function i_.DrawOdometer(gW,ad,TotalDistanceTravelled,ae)local jb;local jf=0;local jg=0;local jc=0;local jh=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then jc=LastMaxBrakeInAtmo else jc=LastMaxBrake end;local ji,jj=aS.computeDistanceAndTime(bs,0,av,0,0,jc)jc=A(jc/(av*g9),2).." g"local jk=a:maxForceForward()jb=core.g()if jb>0.1 then jg=av*jb;jg=A(jg/(av*g9),2).." g"jf=0.5*jk/jb;jf=jf>1000000 and A(jf/1000000,2).." kTons"or A(jf/1000,2).." Tons"end;jk=A(jk/(av*g9),2).." g"gW[#gW+1]=f([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gi(660),gi(700),gj(35),gi(960),gj(55),gi(1240),gj(35),gi(1280))if m()==0 or RemoteHud then gW[#gW+1]=cb(gi(700),gj(10),f("BrkTime: %s",cz(jj)),"txtstart")gW[#gW+1]=cb(gi(700),gj(20),f("Trip: %.2f km",ad),"txtstart")gW[#gW+1]=cb(gi(700),gj(30),f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gW[#gW+1]=cb(gi(830),gj(10),f("BrkDist: %s",co(ji)),"txtstart")gW[#gW+1]=cb(gi(830),gj(20),"Trip Time: "..cz(ae),"txtstart")gW[#gW+1]=cb(gi(830),gj(30),"Total Time: "..cz(TotalFlightTime),"txtstart")gW[#gW+1]=cb(gi(970),gj(20),f("Mass: %s",jh),"txtstart")gW[#gW+1]=cb(gi(1240),gj(10),f("Max Brake: %s",jc),"txtend")gW[#gW+1]=cb(gi(1240),gj(30),f("Max Thrust: %s",jk),"txtend")if jb>0.1 then gW[#gW+1]=cb(gi(970),gj(30),f("Max Thrust Mass: %s",jf),"txtstart")gW[#gW+1]=cb(gi(1240),gj(20),f("Req Thrust: %s",jg),"txtend")else gW[#gW+1]=cb(gi(970),gj(30),"Max Mass: n/a","txtstart")gW[#gW+1]=cb(gi(1240),gj(20),"Req Thrust: n/a","txtend")end end;gW[#gW+1]="</g>"return gW end;function i_.DrawWarnings(gW)return ia(gW)end;function i_.DisplayOrbitScreen(gW)return io(gW)end;function i_.DisplayMessage(gW,ik)if ik~="empty"then local cd=310;for jl in string.gmatch(ik,"([^\n]+)")do cd=cd+35;gW[#gW+1]=cb("50%",cd,jl,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function i_.DrawDeadZone(gW)gW[#gW+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function i_.UpdatePipe()if aq then bJ=""return end;iR()end;function i_.DrawSettings(gW)if#bE>0 then local cc=gi(640)local cd=gj(200)gW[#gW+1]=[[<g class="pbright txtvspd txtstart">]]for cI,cJ in pairs(bE)do gW[#gW+1]=cb(cc,cd,cJ..": ".._G[cJ])cd=cd+20;if cI%12==0 then cc=cc+gi(350)cd=gj(200)end end;gW[#gW+1]=cb(gi(640),gj(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gW[#gW+1]="</g>"end;return gW end;local jm;local jn=gi(1770)local jo=gj(350)local jp=gj(15)local jq=gi(1370)local bR,jr;local js=0;function i_.DrawRadarInfo()local function jt()if radarPanelID~=nil and js==0 then t(radarPanelID)radarPanelID=nil;if jm~=nil then t(jm)jm=nil end else if js==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jm=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;js=0 end end;local f1,f2,f0,f3,f4,eY=aY.GetRadarHud()local B=f3 or 0;if f0>0 then if CollisionSystem then bR=B.."/"..f4 .." Plotted : "..f0-f4 .." Ignored"else bR="Radar Contacts: "..f0 end;gn=cb(jn,jo,bR,"pbright txtbig txtmid")if#eY>0 then gn=gn..cb(jq,jp,"Friendlies In Range","pbright txtbig txtmid")for cI,cJ in pairs(eY)do jp=jp+20;gn=gn..cb(jq,jp,bP[1].getConstructName(cJ),"pdim txtmid")end end;if f1==nil and jm==nil then js=1;jt()end;if f1~=nil and jm~=nil then jt()end;if radarPanelID==nil then jt()end else if f2 then gn=cb(jn,jo,bQ.." Radar: Jammed","pbright txtbig txtmid")else gn=cb(jn,jo,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then js=0;jt()end end end;function i_.DrawTanks()if fuelX~=0 and fuelY~=0 then go=cb(fuelX,fuelY,"","txtstart pdim txtfuel")gF(fuelX,"Atmospheric ","ATMO",aI,gD,gE)gF(fuelX+120,"Space fuel t","SPACE",aJ,gB,gC)gF(fuelX+240,"Rocket fuel ","ROCKET",aK,gz,gA)end end;function i_.DrawShield()local ju=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jv=core.getPvPTimer()local jw=shield_1.getResistances()local jx="A: "..10+jw[1]*100 .."% / E: "..10+jw[2]*100 .."% / K:"..10+jw[3]*100 .."% / T: "..10+jw[4]*100 .."%"local cc,cd=shieldX-60,shieldY+30;local jy=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gT=e(jy*2.55)local gU=f("rgb(%d,%d,%d)",255-gT,gT,0)local cf=""gp=cb(cc,cd,"","txtmid pdim txtfuel")if jy<10 and ju~="Shield Disabled"then cf="red "end;jv=jv>0 and"   PvPTime: "..cz(jv)or""gp=gp..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cc,cd,gU,jy*2,cc,cd,cc+2,cd+10,jy,jv)gp=gp..cb(cc,cd-5,ju,cf.."txtstart pbright txtbig")gp=gp..cb(cc,cd+30,jx,cf.."txtstart pbright txtsmall")end;return i_ end;local function jz()local function jA(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function jB()local function jC(jD,jE)return jD.name<jE.name end;bG={}for cI,cJ in pairs(b[0])do bG[#bG+1]={name=cJ.name,index=cI}end;table.sort(bG,jC)end;local function jF(jG)for cI,cJ in pairs(jG)do if cJ.name and cJ.name==CustomTarget.name then return cI end end;return-1 end;local function jH()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jI=bG[AutopilotTargetIndex].index;local jJ=b[0][jI]if jJ.center then AutopilotTargetName=jJ.name;ac=aR[0][jI]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jJ;for _,cJ in pairs(aR[0])do if cJ.name==CustomTarget.planetname then ac=cJ;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jK(g_)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if g_==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jH()else local jI=bG[AutopilotTargetIndex].index;local jJ=b[0][jI]if jJ~=nil and jJ.name=="Space"or iphCondition=="Custom Only"and jJ.center or iphCondition=="No Moons"and string.find(jJ.name,"Moon")~=nil then if g_==nil then jK()else jK(1)end else jH()end end else a2="Disengage autopilot before changing Interplanetary Helper"bZ("iph","AP")end end;local function jL()local fJ=-1;fJ=jF(b[0])if fJ>-1 then table.remove(b[0],fJ)end;fJ=-1;fJ=jF(SavedLocations)if fJ~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fJ)end;jK()jB()end;local function jM(fY,position,hH,jN)if dbHud_1 or hH then local p=jA(position)local jb=p.gravity;if jN then jb=unit.getClosestPlanetInfluence()end;local jO={position=position,name=fY,planetname=p.name,gravity=jb,safe=jN}if not hH then SavedLocations[#SavedLocations+1]=jO else for cI,cJ in pairs(b[0])do if cJ.name and fY==cJ.name then table.remove(b[0],cI)end end end;table.insert(b[0],jO)jB()jH()a2="Location saved as "..fY.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local jP={}function jP.UpdateAtlasLocationsList()jB()end;function jP.UpdateAutopilotTarget()jH()end;function jP.adjustAutopilotTargetIndex(g_)jK(g_)end;function jP.findAtlasIndex(jG)jF(jG)end;function jP.UpdatePosition(jQ)local fJ=jF(SavedLocations)if fJ~=-1 then if jQ~=nil then SavedLocations[fJ].name=jQ;AutopilotTargetIndex=AutopilotTargetIndex-1;jK()else local jR=SavedLocations[fJ]jR.gravity=unit.getClosestPlanetInfluence()jR.position=bv;jR.safe=true end;a2=SavedLocations[fJ].name.." position updated ("..SavedLocations[fJ].planetname..")"else a2="Name Not Found"end end;function jP.AddNewLocation(fY,position,hH,jN)jM(fY,position,hH,jN)end;function jP.ClearCurrentPosition()jL()end;for cI,cJ in pairs(SavedLocations)do table.insert(b[0],cJ)end;jB()jP.UpdateAutopilotTarget()return jP end;local function jS()local jT={}local function jU(ew)local jV=AutopilotEndSpeed;if not Autopilot then jV=0 end;if not aq then return aS.computeDistanceAndTime(ew,jV,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(ew,jV,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jW(ew)local jV=AutopilotEndSpeed;if not Autopilot then jV=0 end;return aS.computeDistanceAndTime(ew,jV,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jX=false;local jY=0;function jT.GetAutopilotBrakeDistanceAndTime(ew)return jU(ew)end;function jT.GetAutopilotTBBrakeDistanceAndTime(ew)return jW(ew)end;local function jZ(j_,k0,k1)k0=k0:project_on_plane(j_)k1=k1:project_on_plane(j_)return n(k0:cross(k1):dot(j_),k0:dot(k1))end;local function k2()local function k3()local k4=-1;local k5=-1;if vBooster then k4=vBooster.getDistance()end;if hover then k5=hover.getDistance()end;if k4~=-1 and k5~=-1 then if k4<k5 then return k4 else return k5 end elseif k4~=-1 then return k4 elseif k5~=-1 then return k5 else return-1 end end;local k6=k3()local k7=-1;if telemeter_1 then k7=telemeter_1.getDistance()end;if k6~=-1 and k7~=-1 then if k6<k7 then return k6 else return k7 end elseif k6~=-1 then return k6 else return k7 end end;local function k8(planet,dT,k9)local function ka(kb,dc)local dZ=vec3(dc)if kb.id==0 then return setmetatable({latitude=dZ.x,longitude=dZ.y,altitude=dZ.z,id=0,systemId=kb.systemId},MapPosition)end;local d_=dZ-kb.center;local aj=d_:len()local di=aj-kb.radius;local dg=0;local dh=0;if not cl(aj,0)then local e0=n(d_.y,d_.x)dh=e0>=0 and e0 or 2*math.pi+e0;dg=math.pi/2-math.acos(d_.z/aj)end;return setmetatable({latitude=math.deg(dg),longitude=math.deg(dh),altitude=di,id=kb.id,systemId=kb.systemId},MapPosition)end;local kc=ka(planet,dT)kc="::pos{"..kc.systemId..","..kc.id..","..kc.latitude..","..kc.longitude..","..kc.altitude.."}"if k9 then return kc else system.setWaypoint(kc)return true end end;local kd=false;function jT.showWayPoint(planet,dT,k9)return k8(planet,dT,k9)end;function jT.APTick()local function ke()if bO and not BrakeLanding then local bX=bO[1]local fZ,f_=bO[2],bO[3]local kf=math.min(fZ,f_ or fZ)local kg=kf/bs;local kh=AutoTakeoff and(bs<42 or ao~=-1)local ki=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if ki and not kh and(a8*1.5>kf or kg<1)then BrakeIsOn=true;ch(0)if AltitudeHold then ct()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cu()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if kg<11 then bN=bX.name.." COLLISION "..cz(kg).." / "..co(kf,2)else bN=bX.name.." collision "..cz(kg)end;if kg<6 then bZ("alarm","AL",2)end else bN=false end end;local function kj(bT,kk,kl)local function km(bT,dF)bT=vec3(bT)dF=vec3(dF):normalize()local cZ=bT*dF;return cZ.x+cZ.y+cZ.z end;local kn=0.001;local ko=1;if not aq or not b2 or ao~=-1 or bs<Q then if kl==nil then kl=DampingMultiplier end;if kk==nil then kk=kn end;bT=vec3(bT):normalize()local kp=vec3()-bT;local kq=-km(kp,core.getConstructWorldOrientationRight())*ko;local kr=-km(kp,core.getConstructWorldOrientationUp())*ko;if aB==0 then aB=kq/2 end;if aC==0 then aC=kr/2 end;if d(kq)<0.1 then V=V-kq*2 else V=V-(kq+(kq-aB)*kl)end;if d(kr)<0.1 then U=U+kr*2 else U=U+kr+(kr-aC)*kl end;aB=kq;aC=kr;if d(kq)<kk and d(kr)<kk then return true end;return false elseif b2 and ao==-1 then bT=br;if kl==nil then kl=DampingMultiplier end;if kk==nil then kk=kn end;bT=vec3(bT):normalize()local kp=bo-bT;local kq=-km(kp,core.getConstructWorldOrientationRight())*ko;local kr=-km(kp,core.getConstructWorldOrientationUp())*ko;if aB==0 then aB=kq/2 end;if aC==0 then aC=kr/2 end;if d(kq)<0.1 then V=V-kq*5 else V=V-(kq+(kq-aB)*kl)end;if d(kr)<0.1 then U=U+kr*5 else U=U+kr+(kr-aC)*kl end;aB=kq;aC=kr;if d(kq)<kk and d(kr)<kk then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=k2()E=q()b3=E;if CollisionSystem then ke()end;if antigrav then by=antigrav.getState()==1 end;local ks=1;local kt=1;local ku=E-b3;local kv=-math.deg(jZ(bn,br,bo))local kw=math.deg(jZ(bp,br,bo))local g_=bt*-1;b2=aq and kv<-YawStallAngle or kv>YawStallAngle or kw<-PitchStallAngle or kw>PitchStallAngle;local kx=system.getMouseDeltaX()local ky=system.getMouseDeltaY()if InvertMouse and not a1 then ky=-ky end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local jb=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+kx;ah=ah+ky end else ag=0;ah=0 end else ag=ag+kx;ah=ah+ky;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(ky,-100,100)+0.5)*2*ks;V=(-utils.smoothstep(kx,-100,100)+0.5)*2*kt end end end end;local kz=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kz then a2="Space Speed Engine Shutoff reached"ch(0)end;if not kz and LastIsWarping then if not BrakeIsOn then cw()end;if Autopilot then cu()end end;LastIsWarping=kz;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jX then BrakeIsOn=true;jX=true elseif not AtmoSpeedAssist and jX then if bs<b7/3.6 then BrakeIsOn=false;jX=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local kA=false;if CustomTarget~=nil and al~=1 then kA=kj(CustomTarget.position-bv,0.1)else kA=kj(vec3(br),0.01)end;b0=true;if kA then ck(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cx()end elseif aq and AtmoSpeedAssist then ch(1)end elseif bs>Q then kj(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then kj(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cx()al=false;an=true else al=false;cu()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cu()an=false end;if VertTakeOff then b0=true;local kB=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then kB=antigrav.getBaseAltitude()end;if as<kB-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=kB then if by then if Autopilot or VectorToTarget then cr()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bZ("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bZ("vtoc","VT")cr()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;ck(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=kB;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local kC=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(kC)local kD=r(vTpitchPID:get(),-1,1)U=kD end end;if IntoOrbit then local kp;local kE=false;local kF=co(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kp=CustomTarget.position-bv end;local kG,kH=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local kI=bC;if not bc then local kJ=false;local kK=false;ch(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kF;if be.VectorToTarget then kj(kp:normalize():project_on_plane(bt))kE=bo:dot(kp:project_on_plane(bn):normalize())>0.95 else kj(br)kE=kv<0.5;if bs<150 then kE=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kJ=true else kJ=false end;if kI<=bb+1 and kI>=bb-1 then kK=true else kK=false end;if kJ and kK and kE then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then kj(kp:normalize():project_on_plane(bt))elseif bs>150 then kj(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and kp:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kp:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bZ("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cs()cx()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;ch(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"bZ("orCom","OB")cs()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kF;bd=true;ck(kH*3.6+1)local kL=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(kL-bu*r(utils.smoothstep(2000-kL,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local kM=2.75;local kN=d(A(kG*kM))local kO=kN%50;if kO>0 then kN=kN-kO+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..kF;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..kF;kN=kN*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..kF;kN=kN*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..kF;ba=-65;local kP=utils.map(bu,-150,-400,1,0.55)kN=kN*kP end;ck(e(kN))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kQ=ba-bB;OrbitPitchPID:inject(kQ)local kR=r(OrbitPitchPID:get(),-0.5,0.5)U=kR end end;if Autopilot and ar==0 and not al then local function kS(bR,orbit)system.print(bR)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"ch(0)P=false;a2=bR;bZ("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cs()end end;local kT,kU=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kV=(CustomTarget.position-ac.center):normalize()local kW=kV:project_on_plane((ac.center-bv):normalize()):normalize()local kX=ac.center+kW*(ac.radius+AutopilotTargetOrbit)local kY=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-kX):len()<(bv-kY):len()then kT=kX else kT=kY;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kT;aX.showWayPoint(ac,AutopilotTargetCoords)kU=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;kU=true;AutopilotRealigned=true;TargetSet=true;kT=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=kT end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kV=(bv+br*100000-ac.center):normalize()local kW=kV:project_on_plane((ac.center-bv):normalize()):normalize()if kW:len()<1 then kV=(bv+bo*100000-ac.center):normalize()kW=kV:project_on_plane((ac.center-bv):normalize()):normalize()end;kT=ac.center+kW*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kT;TargetSet=true;kU=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kT)-bv):len()local bU,bV,bW=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(bX)if bX.noAtmosphericDensityAltitude>0 then return bX.radius+bX.noAtmosphericDensityAltitude else return bX.radius+bX.surfaceMaxAltitude*1.5 end end)local bY=bV;if bW~=nil and bV~=nil then bY=math.min(bW,bV)end;if bY~=nil and bY<AutopilotDistance and bU.name==ac.name then AutopilotDistance=bY end;local kA=true;local kZ=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local ik=co(kZ)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a8,a9;if not TurnBurn then a8,a9=jU(bs)else a8,a9=jW(bs)end;if bs>50 and AutopilotAccelerating then local kp=vec3(kT)-bv;local k_=r(math.deg(jZ(bn,br:normalize(),kp:normalize()))*bs/500,-90,90)local l0=r(math.deg(jZ(bp,br:normalize(),kp:normalize()))*bs/500,-90,90)if d(k_)<20 and d(l0)<20 then k_=k_*2;l0=l0*2 end;if d(k_)<2 and d(l0)<2 then k_=k_*2;l0=l0*2 end;local kv=-math.deg(jZ(bn,bo,br:normalize()))local kw=-math.deg(jZ(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(l0-kw)local l1=r(apPitchPID:get(),-1,1)U=U+l1;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(k_-kv)local l2=r(apYawPID:get(),-1,1)V=V+l2;kU=true;if d(k_)>2 or d(l0)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bZ("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then kj((kT-bv):normalize())end;if kZ<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(kZ)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bU,bY=bS((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if bU~=nil and ac.name~=bU.name and bY<AutopilotDistance then a2="Collision with "..bU.name.." in "..co(bY).."\nClear LOS to continue."ai=5;kd=true else kd=false;a2=""end end end;if not kd then if not AutopilotCruising and not AutopilotBraking and not kU then kA=kj((kT-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kA=kj(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;ch(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local l3=unit.getThrottle()if AtmoSpeedAssist then l3=K end;local l4=99999;local jd=-vec3(core.getWorldAcceleration()):dot(br:normalize())local l5=r(br:dot((kT-bv):normalize()),0,bs)if l5>0 or jd>0 then l4=aS.computeTravelTime(l5,jd,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or l3==0 and P or warmup/4>l4 then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bZ("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;ch(0)end;local l6=AutopilotDistance;if l6<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<jY and bI>2000 then cu()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;jY=bI else jY=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;ch(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then ch(1,true)end;local _,kH=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kp;if CustomTarget~=nil then kp=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kS("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=kH and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kS("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif CustomTarget.planetname~="Space"and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bZ("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=kH then if CustomTarget~=nil then if br:normalize():dot(kp:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bZ("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kS("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kS("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kS("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local l6=AutopilotDistance;if l6<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<jY and bI>2000 then cu()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;jY=bI else jY=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bZ("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local l3=unit.getThrottle()if AtmoSpeedAssist then l3=K end;if l3>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;AutopilotCruising=false end else if kA then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif kA and not kd then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bZ("apAcc","AP")end;if not P then ch(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bZ("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;ch(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local l0=0;local eA=bv+vec3(unit.getMasterPlayerRelativePosition())local l7=eA-bv;local l8=vec3(l7):project_on(bo):len()local l9=vec3(l7):project_on(bp):len()local aj=y(l8*l8+l9*l9)kj(l7:normalize())local la=40;local lb=aj<la;local lc=100;local ld=r((aj-la)/2,10,lc)U=0;local kA=d(V)<0.1;if kA and bs<ld and not lb then BrakeIsOn=false;l0=-20 else BrakeIsOn=true;l0=0 end;local le=0;if d(l0-bB)>le then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(l0-bB)local l1=pitchPID:get()U=l1 end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local lf=LastMaxBrakeInAtmo;if lf then lf=lf*r(bs/100,0.1,1)*ar else lf=LastMaxBrake end;if ar<0.01 then lf=LastMaxBrake end;local lg=bo:project_on_plane(bt):normalize():dot(br)local lh=vec3(core.getWorldAirFrictionAcceleration())local li=lh:len()*av;if lg>100 then a8,a9=aS.computeDistanceAndTime(lg,100,av,0,0,lf)local lj,lk=aS.computeDistanceAndTime(100,0,av,0,0,lf*0.55)a8=a8+lj else a8,a9=aS.computeDistanceAndTime(lg,0,av,0,0,lf*0.55)end;local kL=HoldAltitude-as-bu;local ll=200+bs;if Reentry or al then minMax=2000+bs end;local lm=1;if AutoTakeoff then lm=r(bs/100,0.1,1)end;local l0=(utils.smoothstep(kL,-ll,ll)-0.5)*2*MaxPitch*lm;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then l0=(utils.smoothstep(kL,-ll*r(20-19*ar*10,1,20),ll*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*lm end;if not AltitudeHold then l0=0 end;if LockPitch~=nil then if bM and not IntoOrbit then l0=LockPitch else LockPitch=nil end end;b0=true;local ln=U;if Reentry then local lo=e(b7)local lp,lq=aS.computeDistanceAndTime(bs,lo/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)lp=lp==-1 and 5000 or lp;local lr=as-(planet.noAtmosphericDensityAltitude+lp)local ls=as>planet.noAtmosphericDensityAltitude+lp*1.35;if ls then l0=ReEntryPitch;if bs<=lo/3.6 and bs>lo/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;ch(1)end elseif bA and not ls and not aq then ck(lo,true)end;if bA then if bs>lo/3.6 and not ls then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then l0=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;l0=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and ls then b0=true elseif not ls then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=lo)then ck(lo)end;if bs<lo/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then kj(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kp;if bK then if type(bK)=="table"then kp=bK elseif bK<3 and bK>0 then kp=-bt:cross(br)*5000 elseif bK>=3 then kp=bt:cross(br)*5000 elseif bK<0 then kp=br*25000 end elseif CustomTarget~=nil then kp=CustomTarget.position-bv else kp=ac.center-bv end;local k_=math.deg(jZ(bt:normalize(),br,kp))*2;local lt=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local lu=1000+bs;local lv=(utils.smoothstep(kL-bu*10,-lu,lu)-0.5)*2*MaxPitch;local lw=r(90-lv,0,180)b4=r(k_*2,-lw,lw)local lx=k_;k_=r(r(k_,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lt)+4*(bB-l0)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local ly=1;if b4~=0 then ly=d(lt/b4)end;ly=(90-r(d(b4-bC),0,90))/90;local lz=l0;if d(bC)>90 then lz=-lz end;l0=ly*r(r(lz*math.cos(lt),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(lx)*math.sin(lt),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;k_=r(k_,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lA=kv-k_;if bK and d(lA)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then ct()end;bK=nil;bZ("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lA)local l2=r(yawPID:get(),-1,1)V=V+l2 elseif aq and ao>-1 or bs<minRollVelocity then kj(kp)elseif b2 and ar>0.01 then if(kv<-YawStallAngle or kv>YawStallAngle)and ar>0.01 then kj(br)end;if(kw<-PitchStallAngle or kw>PitchStallAngle)and ar>0.01 then l0=r(bB-kw,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kB=planet:getAltitude(CustomTarget.position)local lr=kp:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and lr<=a8 and(br:project_on_plane(bt):normalize():dot(kp:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"ch(0)if AltitudeHold then ct()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(lg<0.1 or lr<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<lr)then if not by then bZ("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=lr end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kp=CustomTarget.position-bv;local kB=planet:getAltitude(CustomTarget.position)local lr=y(kp:len()^2-(as-kB)^2)local lf=LastMaxBrakeInAtmo;if lf then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,lf/2)StrongBrakes=true;if lr<=a8+bs*ku/2 and br:project_on_plane(bt):normalize():dot(kp:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cx()end end;LastDistanceToTarget=lr end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cs()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then kj(br)l0=r(bB-kw,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=ln;local k7=-1;if BrakeLanding then l0=0;local lB=false;local lC=30;if aT~=nil and aT>0 then local lD=r(ar,0.4,2)local lf=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*lD;local lE=aT*lD+lf-jb;local lF=lf/2-jb;local lG=bs-y(d(lF/2)*20/(0.5*av))*utils.sign(lF)if lG<0 then lG=0 end;local lH;if bs>100 then local lI,_=aS.computeDistanceAndTime(bs,100,av,0,0,lf)local lJ,_=aS.computeDistanceAndTime(100,0,av,0,0,y(lf))lH=lI+lJ else lH=aS.computeDistanceAndTime(bs,0,av,0,0,y(lf))end;if lH<20 then BrakeIsOn=false else local lK=0;if lG>100 then local lL,_=aS.computeDistanceAndTime(lG,100,av,0,0,lE)local lM,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*lD+y(lf)-jb)lK=lL+lM else lK,_=aS.computeDistanceAndTime(lG,0,av,0,0,aT*lD+y(lf)-jb)end;lK=(lK+15+bs*ku)*1.1;local lN=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lN then local kB=planet:getAltitude(CustomTarget.position)local lO=as-kB-100;local kp=CustomTarget.position-bv;local lP=y(kp:len()^2-(as-kB)^2)if lP>100 then lN=false elseif lO<=lK or lK==-1 then BrakeIsOn=true;lB=true else BrakeIsOn=false;lB=true end end;if not lN and CalculateBrakeLandingSpeed then if lK>=lC then BrakeIsOn=true else BrakeIsOn=false end;lB=true end end end;if not bA then ch(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;k7=ao;if k7>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bZ("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-g_)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not lB then BrakeIsOn=true elseif not lB then BrakeIsOn=false end end;if AutoTakeoff or am then local bU,bW,bV;if AutopilotTargetCoords~=nil then bU,bW,bV=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(bX)return bX.radius+bX.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;ch(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(l0)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;ch(0)elseif am then ch(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bU==nil or bU.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then ch(0)end;AutopilotAccelerating=true end end;local lQ=ao>-1;local lR=bB;if(VectorToTarget or am or bK)and not lQ and bs>minRollVelocity and ar>0.01 then local lt=math.rad(d(bC))lR=bB*d(math.cos(lt))+kw*math.sin(lt)end;local lS=r(l0-lR,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lS=r(l0-lR,-85,MaxPitch)elseif ar<0.01 then lS=r(l0-lR,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or lQ or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lS)local l1=pitchPID:get()U=U+l1 end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=k2()return jT end;function script.onStart()local lT={}local lU={}local lV=false;local function lW()local function lX(lY)local lZ=dbHud_1.hasKey;for cI,cJ in pairs(lY)do if lZ(cJ)then local cZ=g(dbHud_1.getStringValue(cJ))if cZ~=nil then _G[cJ]=cZ;lV=true end end end end;if dbHud_1 then if not useTheseSettings then lX(c4())coroutine.yield()lX(c)else lX(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lV=false end;coroutine.yield()if lV then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function l_()local function m0(m1,m2)if m1>m2 then m2=m1 end;local m3,m4=0,0;if ContainerOptimization>0 then m3=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then m4=FuelTankOptimization*0.05 end;m2=m2*(1-(m3+m4))return m2 end;local m5=core.getElementNameById;local m6=fuelX~=0 and fuelY~=0;for cI in pairs(at)do local type=core.getElementTypeById(at[cI])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cI])),'^.*vertical.*$')and core.getElementForwardById(at[cI])[3]>0 then bx=true;p("UpEngine")end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cI])),'^.*vertical.*$')then local m7=core.getElementForwardById(at[cI])if m7[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local m8=j(at[cI])if m8>10000 then G=110 elseif m8>1000 then G=55 elseif m8>150 then G=27 end end;aL=aL+j(at[cI])if m6 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local m8=j(at[cI])local jh=l(at[cI])local m1=0;local gP=q()if type=="Atmospheric Fuel Tank"then local m2=400;local m9=35.03;if m8>10000 then m2=51200;m9=5480 elseif m8>1300 then m2=6400;m9=988.67 elseif m8>150 then m2=1600;m9=182.67 end;m1=jh-m9;if fuelTankHandlingAtmo>0 then m2=m2+m2*fuelTankHandlingAtmo*0.2 end;m2=m0(m1,m2)aI[#aI+1]={at[cI],m5(at[cI]),m2,m9,m1,gP}end;if type=="Rocket Fuel Tank"then local m2=320;local m9=173.42;if m8>65000 then m2=40000;m9=25740 elseif m8>6000 then m2=5120;m9=4720 elseif m8>700 then m2=640;m9=886.72 end;m1=jh-m9;if fuelTankHandlingRocket>0 then m2=m2+m2*fuelTankHandlingRocket*0.1 end;m2=m0(m1,m2)aK[#aK+1]={at[cI],m5(at[cI]),m2,m9,m1,gP}end;if type=="Space Fuel Tank"then local m2=600;local m9=35.03;if m8>10000 then m2=76800;m9=5480 elseif m8>1300 then m2=9600;m9=988.67 elseif m8>150 then m2=2400;m9=182.67 end;m1=jh-m9;if fuelTankHandlingSpace>0 then m2=m2+m2*fuelTankHandlingSpace*0.2 end;m2=m0(m1,m2)aJ[#aJ+1]={at[cI],m5(at[cI]),m2,m9,m1,gP}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function ma()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cJ in pairs(door)do cJ.toggle()end end;if switch then for _,cJ in pairs(switch)do cJ.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cJ in pairs(forcefield)do cJ.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function mb(mc,md,me,mf,cc,cd,mg,mh,mi,mj)local mk={enableName=mc,disableName=md,width=me,height=mf,x=cc,y=cd,toggleVar=mg,toggleFunction=mh,drawCondition=mi,hovered=false}if mj then table.insert(lU,mk)else table.insert(lT,mk)end;return mk end;local function ml(mm)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif mm=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif mm=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif mm=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c4(mm)showHud=false else bE={}showHud=true end end;local function mn()bD=not bD;if bD then aF=lU;a2="Hold SHIFT to see Settings"bF=showHud else aF=lT;a2="Hold SHIFT to see Control Buttons"ml()showHud=bF end end;local function mo(cJ)_G[cJ]=not _G[cJ]if _G[cJ]then a2=cJ.." set to true"else a2=cJ.." set to false"end;if cJ=="showHud"then bF=_G[cJ]elseif cJ=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function mp()local mq=50;local mr=340;local cc=500;local cd=aH/2-400;local ms=0;for cI,cJ in pairs(c4("boolean"))do if type(_G[cJ])=="boolean"then mb(cJ,cJ,mr,mq,cc,cd,function()return _G[cJ]end,function()mo(cJ)end,function()return true end,true)cd=cd+mq+20;if ms==9 then cc=cc+mr+20;cd=aH/2-400;ms=0 else ms=ms+1 end end end;mb("Control View","Control View",mr,mq,10,aH/2-500,function()return true end,mn,function()return true end,true)mb("View Handling Settings",'Hide Handling Settings',mr,mq,10,aH/2-(500-mq),function()return showHandlingVariables end,function()ml("handling")end,function()return true end,true)mb("View Hud Settings",'Hide Hud Settings',mr,mq,10,aH/2-(500-mq*2),function()return showHudVariables end,function()ml("hud")end,function()return true end,true)mb("View Physics Settings",'Hide Physics Settings',mr,mq,10,aH/2-(500-mq*3),function()return showPhysicsVariables end,function()ml("physics")end,function()return true end,true)end;local function mt()local function jM()local position=bv;local fY=planet.name..". "..#SavedLocations;if bP[1]then local da,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if da~=nil and da~=""then fY=fY.." "..bP[1].getConstructName(da)end end;return aW.AddNewLocation(fY,position,false,true)end;local function mu()TurnBurn=not TurnBurn end;local function mv(mw)if mw==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mx()aW.UpdatePosition()end;local function jL()aW.ClearCurrentPosition()end;local function my()local fY=AutopilotTargetName;if fY==nil then local ik=co((bv-CustomTarget.position):len())fY=CustomTarget.name.." "..ik end;if fY==nil then fY="None"end;return"Engage Autopilot: "..fY end;local function mz()local fY=AutopilotTargetName;if fY==nil then fY=CustomTarget.name end;if fY==nil then fY="None"end;return"Disable Autopilot: "..fY end;local function mA()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bZ("folOn","F")else bZ("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mq=50;local mr=260;local mB=mb("Enable Brake Toggle","Disable Brake Toggle",mr,mq,aG/2-mr/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)mb("Align Prograde","Disable Prograde",mr,mq,aG/2-mr/2-50-mB.width,aH/2-mq+380,function()return ProgradeIsOn end,function()mv(1)end)mb("Align Retrograde","Disable Retrograde",mr,mq,aG/2-mr/2+mB.width+50,aH/2-mq+380,function()return RetrogradeIsOn end,mv,function()return ar==0 end)local mC=mb(my,mz,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cu)mb("Save Position","Save Position",200,mC.height,mC.x+mC.width+30,mC.y,function()return false end,jM,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)mb("Update Position","Update Position",200,mC.height,mC.x+mC.width+30,mC.y,function()return false end,mx,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mb("Clear Position","Clear Position",200,mC.height,mC.x-200-30,mC.y,function()return true end,jL,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mq=60;mr=300;local cc=10;local cd=aH/2-500;mb("Show Help","Hide Help",mr,mq,cc,cd,function()return showHelp end,function()showHelp=not showHelp end)cd=cd+mq+20;mb("View Settings","View Settings",mr,mq,cc,cd,function()return true end,mn)local cd=aH/2-300;mb("Enable Turn and Burn","Disable Turn and Burn",mr,mq,cc,cd,function()return TurnBurn end,mu)mb("Horizontal Takeoff Mode","Vertical Takeoff Mode",mr,mq,cc+mr+20,cd,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cd=cd+mq+20;mb("Show Orbit Display","Hide Orbit Display",mr,mq,cc,cd,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)mb("Engage Orbiting","Cancel Orbiting",mr,mq,cc+mr+20,cd,function()return IntoOrbit end,cs,function()return ar==0 and bM end)cd=cd+mq+20;mb("Glide Re-Entry","Cancel Glide Re-Entry",mr,mq,cc,cd,function()return Reentry end,function()al=1;mv(1)end,function()return planet.hasAtmosphere and not aq end)mb("Parachute Re-Entry","Cancel Parachute Re-Entry",mr,mq,cc+mr+20,cd,function()return Reentry end,cx,function()return planet.hasAtmosphere and not aq end)cd=cd+mq+20;mb("Engage Follow Mode","Disable Follow Mode",mr,mq,cc,cd,function()return a0 end,mA,function()return m()==1 end)mb("Enable Repair Arrows","Disable Repair Arrows",mr,mq,cc+mr+20,cd,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cd=cd+mq+20;if not ExternalAGG then mb("Enable AGG","Disable AGG",mr,mq,cc,cd,function()return by end,cy,function()return antigrav~=nil end)end;mb(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,mr*2,mq,cc,cd,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cd=cd+mq+20;mb(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,mr*2,mq,cc,cd,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;local function mD()local mE={}local function mF()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local mG={[1]=4480,[6]=4480,[7]=6270}for mH,mI in pairs(b)do b[mH][0]=mF()b[mH][0].systemId=mH;mE[mH]={}for mJ,planet in pairs(b[mH])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=mG[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=mH;planet.bodyId=planet.id;mE[mH][mJ]=planet end end;aQ=cK()aR=aQ(mE)aS=e4()aU=ey()aY=eW()aV=g8()aW=jz()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lW()coroutine.yield()l_()coroutine.yield()aX=jS()ma()mp()mt()aF=lT;coroutine.yield()mD()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;bZ("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cJ in pairs(door)do cJ.toggle()end end;if switch then for _,cJ in pairs(switch)do cJ.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cJ in pairs(forcefield)do cJ.toggle()end end;cE()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;bZ("stop","SU")end;function script.onTick(mK)local mL=nil;if mK=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bZ("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif mK=="tenthSecond"then local function mM()local mN=system.createData;local mO=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mO(panelInterplanetary,"value")interplanetaryHeaderText=mN('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mO(panelInterplanetary,"value")widgetDistanceText=mN('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=mO(panelInterplanetary,"value")widgetTravelTimeText=mN('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mO(panelInterplanetary,"value")widgetMaxMassText=mN('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mO(panelInterplanetary,"value")widgetTargetOrbitText=mN('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mO(panelInterplanetary,"value")widgetCurBrakeDistanceText=mN('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mO(panelInterplanetary,"value")widgetCurBrakeTimeText=mN('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mO(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mN('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mO(panelInterplanetary,"value")widgetMaxBrakeTimeText=mN('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mO(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mN('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mP()t(panelInterplanetary)panelInterplanetary=nil end;local function mQ()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local ew=bs;local l3=unit.getThrottle()/100;if AtmoSpeedAssist then l3=K end;local mR,mS=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*l3,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mT;if not TurnBurn and ew>0 then _,mT=aX.GetAutopilotBrakeDistanceAndTime(ew)else _,mT=aX.GetAutopilotTBBrakeDistanceAndTime(ew)end;local mU=0;local mV=0;if AutopilotCruising or not Autopilot and ew>5 then mV=aS.computeTravelTime(ew,0,AutopilotDistance)elseif a8+mR<AutopilotDistance then mU=AutopilotDistance-(a8+mR)mV=aS.computeTravelTime(8333.0556,0,mU)else local mW=(AutopilotDistance-a8)/mR;mR=AutopilotDistance-a8;mS=mS*mW end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mV elseif AutopilotBraking then return mT elseif AutopilotCruising then return mV+mT else return mS+a9+mV end end;local function mX(jb,mY)if jb==nil then jb=core.g()end;jb=A(jb,5)if mY~=nil and mY or(mL==nil or mL~=jb)then local ew=bq:len()local mZ=g(unit.getData()).maxBrake;if mZ~=nil and mZ>0 and aq then mZ=mZ/r(ew/100,0.1,1)mZ=mZ/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mZ)/2 else LastMaxBrakeInAtmo=mZ end end end;if mZ~=nil and mZ>0 then LastMaxBrake=mZ end;mL=jb end end;mX(nil,true)if bz~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bz then ck(bz,TRUE)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mM()end;if AutopilotTargetName~=nil then local m_=CustomTarget~=nil;local n0=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()n0=n0>1000000 and A(n0/1000000,2).." kTons"or A(n0/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mQ()if m_ and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=co(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cz(travelTime)..'", "unit":""}')ik=co(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cz(a9)..'", "unit":""}')ik=co(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cz(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",n0)..'", "unit":""}')ik=co(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then ch(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mP()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif mK=="oneSecond"then local function n1(gW)local n2=0;aD=""local n3=aL;local n4=0;local n5=0;local n6=0;local gT=0;local gU=""local n7=core.getElementHitPointsById;for cI in pairs(at)do local m8=0;local n8=0;n8=j(at[cI])m8=n7(at[cI])n4=n4+m8;if m8<n8 then if m8==0 then n6=n6+1 else n5=n5+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cI]))local cc=position.x;local cd=position.y;local fq=position.z;table.insert(aA,core.spawnArrowSticker(cc,cd,fq+1,"down"))table.insert(aA,core.spawnArrowSticker(cc,cd,fq+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cc+1,cd,fq,"north"))table.insert(aA,core.spawnArrowSticker(cc+1,cd,fq,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cc-1,cd,fq,"south"))table.insert(aA,core.spawnArrowSticker(cc-1,cd,fq,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cc,cd-1,fq,"east"))table.insert(aA,core.spawnArrowSticker(cc,cd-1,fq,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cc,cd+1,fq,"west"))table.insert(aA,core.spawnArrowSticker(cc,cd+1,fq,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cI])end elseif aM and#aA>0 and aA[11]==at[cI]then for gO in pairs(aA)do core.deleteSticker(aA[gO])end;aA={}end end;n2=e(n4/n3*100)if n2<100 then gW[#gW+1]=cb(0,0,"","pbright txt")gT=e(n2*2.55)gU=f("rgb(%d,%d,%d)",255-gT,gT,0)if n2<100 then gW[#gW+1]=cb("50%",1035,"Elemental Integrity: "..n2 .."%","txtbig txtmid","fill:"..gU)if n6>0 then gW[#gW+1]=cb("50%",1055,"Disabled Modules: "..n6 .." Damaged Modules: "..n5,"txtbig txtmid","fill:"..gU)elseif n5>0 then gW[#gW+1]=cb("50%",1055,"Damaged Modules: "..n5,"txtbig txtmid","fill:"..gU)end end end end;local function n9()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function na()local gP=q()local i7=bs;local nb=gP-au;if i7>1.38889 then i7=i7/1000;local nc=i7*(gP-au)TotalDistanceTravelled=TotalDistanceTravelled+nc;ad=ad+nc end;ae=ae+nb;TotalFlightTime=TotalFlightTime+nb;au=gP end;na()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()n9()local gW={}aV.ExtraData(gW)if ShowOdometer then gW=aV.DrawOdometer(gW,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then n1(gW)end;ak=table.concat(gW,"")collectgarbage("collect")elseif mK=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cZ=g(dbHud_1.getStringValue("SavedLocations"))if cZ~=nil then _G["SavedLocations"]=cZ;local fJ=-1;local jO;for cI,cJ in pairs(SavedLocations)do if cJ.name and cJ.name=="SatNav Location"then fJ=cI;break end end;if fJ~=-1 then jO=SavedLocations[fJ]fJ=-1;for cI,cJ in pairs(b[0])do if cJ.name and cJ.name=="SatNav Location"then fJ=cI;break end end;if fJ>-1 then b[0][fJ]=jO end;aW.UpdateAtlasLocationsList()a2=jO.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mK=="msgTick"then local gW={}aV.DisplayMessage(gW,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mK=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mK=="hudTick"then if not planet then return end;local function nd(gW)local ne=e(r(aj/(aG/4)*255,0,255))gW[#gW+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+ne,e(J+0.5)-ne,e(I+0.5)-ne)end;local function nf()for _,cJ in pairs(aF)do if cJ.hovered then if not cJ.drawCondition or cJ.drawCondition()then cJ.toggleFunction()end;cJ.hovered=false end end end;local function ng()local function nh(ni,nj,cc,cd,me,mf)if ni>cc and ni<cc+me and nj>cd and nj<cd+mf then return true else return false end end;local cc=ag+aG/2;local cd=ah+aH/2;for _,cJ in pairs(aF)do cJ.hovered=nh(cc,cd,cJ.x,cJ.y,cJ.width,cJ.height)end end;local function nk(gW)local function nl(gW,nm,hover,cc,cd,ep,nn,no,np,nq,nr)if type(nq)=="function"then nq=nq()end;if type(nr)=="function"then nr=nr()end;gW[#gW+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cc,cd,ep,nn)if nm then gW[#gW+1]=f("%s'",no)else gW[#gW+1]=np end;if hover then gW[#gW+1]=" style='stroke:white; stroke-width:2'"else gW[#gW+1]=" style='stroke:black; stroke-width:1'"end;gW[#gW+1]="></rect>"gW[#gW+1]=f("<text x='%f' y='%f' font-size='24' fill='",cc+ep/2,cd+nn/2+5)if nm then gW[#gW+1]="black"else gW[#gW+1]="white"end;gW[#gW+1]="' text-anchor='middle' font-family='Montserrat'>"if nm then gW[#gW+1]=f("%s</text>",nq)else gW[#gW+1]=f("%s</text>",nr)end end;local ns="rgb(50,50,50)'"local nt="rgb(210,200,200)"local nu=nl;for _,cJ in pairs(aF)do local md=cJ.disableName;local mc=cJ.enableName;if type(md)=="function"then md=md()end;if type(mc)=="function"then mc=mc()end;if not cJ.drawCondition or cJ.drawCondition()then nu(gW,cJ.toggleVar(),cJ.hovered,cJ.x,cJ.y,cJ.width,cJ.height,nt,ns,md,mc)end end end;local nw=A(ResolutionX/2,0)local nx=A(ResolutionY/2,0)local gW={}aV.HUDPrologue(gW)if showHud then aV.UpdateHud(gW)else if AlwaysVSpd then aV.DrawVerticalSpeed(gW,as)end;aV.DisplayOrbitScreen(gW)aV.DrawWarnings(gW)end;if bD and bE~={}then aV.DrawSettings(gW)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(gW)gW[#gW+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(gW,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gW)end end;if x()==0 then if m()==1 and a1 then if not AltIsOn then ng()nk(gW)end;if not aZ and not a_ then local ny=table.concat(gW,"")gW={}gW[#gW+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gW[#gW+1]=ny;gW[#gW+1]="</body>"aZ=true;gW[#gW+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gW,"")system.setScreen(content)elseif a_ then local ny=table.concat(gW,"")gW={}gW[#gW+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gW[#gW+1]=ny;gW[#gW+1]="</body>"end;if not aZ then gW[#gW+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nw,nx,ag,ah)end else nf()end else if not a1 and m()==0 then nf()if aj>DeadZone then if DisplayDeadZone then nd(gW)end end elseif not AltIsOn or AltIsOn and a1 then ng()nk(gW)end;gW[#gW+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nw,nx,ag,ah)end;gW[#gW+1]=[[</svg></body>]]content=table.concat(gW,"")elseif mK=="apTick"then aX.APTick()elseif mK=="radarTick"then aY.UpdateRadar()elseif mK=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function nz(nA,ld)local nB=vec3()local nC=vec3()if nA==axisCommandId.longitudinal then nB=vec3(core.getConstructOrientationForward())nC=bo elseif nA==axisCommandId.vertical then nB=vec3(core.getConstructOrientationUp())nC=bn elseif nA==axisCommandId.lateral then nB=vec3(core.getConstructOrientationRight())nC=bp else return vec3()end;local nD=vec3(core.getWorldGravity())local nE=nD:dot(nC)local nF=vec3(core.getWorldAirFrictionAcceleration())local nG=nF:dot(nC)local nH=bq:dot(nB)local nI=ld*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nI-nH)local nJ=targetSpeedPID2:get()local nK=(nJ-nG-nE)*nC;return nK end;local function nL(nA,ld)local nB=vec3()local nC=vec3()if nA==axisCommandId.longitudinal then nB=vec3(core.getConstructOrientationForward())nC=bo elseif nA==axisCommandId.vertical then nB=vec3(core.getConstructOrientationUp())nC=bn elseif nA==axisCommandId.lateral then nB=vec3(core.getConstructOrientationRight())nC=bp else return vec3()end;local nD=vec3(core.getWorldGravity())local nE=nD:dot(nC)local nF=vec3(core.getWorldAirFrictionAcceleration())local nG=nF:dot(nC)local nH=bq:dot(nB)local nI=ld*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nI-nH)local nJ=targetSpeedPID:get()local nK=(nJ-nG-nE)*nC;return nK end;local function nM(nN,gZ,jE)local nO=nN:cross(jE):normalize_inplace()local hL=math.acos(r(nO:dot(-gZ),-1,1))*constants.rad2deg;if nO:cross(-gZ):dot(jE)<0 then hL=-hL end;return hL end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then ch(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nP=r(T+U+system.getControlDeviceForwardInput(),-1,1)local nQ=r(W+Z+system.getControlDeviceYawInput(),-1,1)local nR=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nS=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local nT=bC/180*math.pi;local nU=math.cos(nT)local nV=math.sin(nT)bB=nM(bt,bo,bp*nU+bn*nV)local nW=br:normalize()local nX=d(bC)local nY=utils.sign(bC)local nZ=vec3(core.getWorldAngularVelocity())local n_=nP*pitchSpeedFactor*bp+nQ*rollSpeedFactor*bo+nR*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local o0=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and o0>0 or ar>0.0 and o0<autoRollRollThreshold and autoRollPreference)and nQ==0 and d(bB)<85 then local o1=b4;local o2=autoRollFactor;if ar==0 then o2=o2/4;b4=0;o1=0 end;if rollPID==nil then rollPID=pid.new(o2*0.01,0,o2*0.1)end;rollPID:inject(o1-bC)local o3=rollPID:get()n_=n_+o3*bo end end;local o4=1;local o5=0;local o6=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local o7=K;K=A(r(K+speedChangeLarge/100,-1,1),2)if K>=0 and o7<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local o7=K;K=A(r(K-speedChangeLarge/100,-1,1),2)if K<=0 and o7>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local o8=throttlePID:get()N=r(o8,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local o9=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=o9 end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local oa=''local ob=vec3()local oc=nz(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",oc,o5)local od='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then od=od..ExtraLongitudeTags end;local oe=s:getAxisCommandType(axisCommandId.longitudinal)local of=s:composeAxisAccelerationFromThrottle(od,axisCommandId.longitudinal)local og=nL(axisCommandId.lateral,LeftAmount*1000)oa=oa..' , '.."lateral airfoil , lateral ground "ob=ob+og;if ob:len()>constants.epsilon then a:setEngineForceCommand(oa,ob,o5,'','','',o6)end;a:setEngineForceCommand(od,of,o4)local oh='thrust analog vertical fueled 'local oi='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then oi=oi..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then oh=oh..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(oh,oc,o4)else a:setEngineForceCommand(oh,vec3(),o4)end;if LeftAmount~=0 then a:setEngineForceCommand(oi,og,o4)else a:setEngineForceCommand(oi,vec3(),o4)end;if nS==0 then nS=L end;local oj=-nS*(brakeSpeedFactor*br+brakeFlatFactor*nW)a:setEngineForceCommand('brake',oj)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local ld=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-ld/3.6)local o9=r(brakePID:get(),0,1)nS=r(nS+o9,0,1)end;local oj=-nS*(brakeSpeedFactor*br+brakeFlatFactor*nW)a:setEngineForceCommand('brake',oj)local oa=''local ob=vec3()local ok=false;local od='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then od=od..ExtraLongitudeTags end;local oe=s:getAxisCommandType(axisCommandId.longitudinal)if oe==axisCommandType.byThrottle then local of=s:composeAxisAccelerationFromThrottle(od,axisCommandId.longitudinal)a:setEngineForceCommand(od,of,o4)elseif oe==axisCommandType.byTargetSpeed then local of=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)oa=oa..' , '..od;ob=ob+of;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ok=true end end;local oi='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then oi=oi..ExtraLateralTags end;local ol=s:getAxisCommandType(axisCommandId.lateral)if ol==axisCommandType.byThrottle then local om=s:composeAxisAccelerationFromThrottle(oi,axisCommandId.lateral)a:setEngineForceCommand(oi,om,o4)elseif ol==axisCommandType.byTargetSpeed then local og=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)oa=oa..' , '..oi;ob=ob+og end;local oh='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then oh=oh..ExtraVerticalTags end;local on=s:getAxisCommandType(axisCommandId.vertical)if on==axisCommandType.byThrottle then local oc=s:composeAxisAccelerationFromThrottle(oh,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(oh,oc,o4,'airfoil','ground','',o6)else a:setEngineForceCommand(oh,vec3(),o4)a:setEngineForceCommand('airfoil vertical',oc,o4,'airfoil','','',o6)a:setEngineForceCommand('ground vertical',oc,o4,'ground','','',o6)end elseif on==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),o4)end;local oo=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)oa=oa..' , '..oh;ob=ob+oo end;if ob:len()>constants.epsilon then if Y~=0 or ok or d(nW:dot(bo))<0.5 then oa=oa..', brake'end;a:setEngineForceCommand(oa,ob,o5,'','','',o6)end end;local op=torqueFactor*(n_-nZ)local oq=vec3(core.getWorldAirFrictionAngularAcceleration())op=op-oq;a:setEngineTorqueCommand('torque',op,o4,'airfoil','','',o6)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local ew=bq:len()local os=0.15;if not bA then local ot=s:getTargetSpeed(axisCommandId.longitudinal)if ew*3.6>ot*(1-os)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew*3.6<ot*(1-os)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local l3=unit.getThrottle()if AtmoSpeedAssist then l3=K*100 end;local ld=l3/100;if k==0 then ld=ld*MaxGameVelocity;if ew>=ld*(1-os)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<ld*(1-os)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lo=e(b7)ld=ld*lo/3.6;if ew>=ld*(1-os)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif ew<ld*(1-os)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g5=coroutine.status(beginSetup)if g5=="suspended"then local ci,g6=coroutine.resume(beginSetup)if g6 then system.print("ERROR STARTUP: "..g6)end elseif g5=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(ou)local function ov(ow)local D=1;local function ox(oy,ow)local oz={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oA=oy;for _,cJ in ipairs(oz)do if ow and oA>cJ then oy=cJ elseif oy<cJ and not ow then oy=cJ;break end end;return oy end;if ow then D=-1 end;if not ExternalAGG and by then if a1 and ow then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=ox(bg,ow)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=ox(HoldAltitude,ow)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function oB(ow)local D=1;if ow then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if ow then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end;local function oC(oD)if not aq then a2="Flight Assist in Atmo only"return end;local cP=type(oD)if bK==nil then if cP=="table"then if Autopilot or VectorToTarget then cu()end;bZ("180On","BR")elseif oD==1 then bZ("bnkLft","BR")else bZ("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then ct()if cP~="table"then oD=oD+1 end end;bK=oD else bZ("180Off","BR")bK=nil end end;if ou=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;ch(0)if vBooster or hover then if aq and ao==-1 then bZ("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then bZ("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bZ("grOut","LG",1)a.control.extendLandingGears()end else if S then bZ("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif ou=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ou=="forward"then T=T-1 elseif ou=="backward"then if AltIsOn then oC(-br*5000)else T=T+1 end elseif ou=="left"then if AltIsOn then oC(1)else W=W-1 end elseif ou=="right"then if AltIsOn then oC(3)else W=W+1 end elseif ou=="yawright"then X=X-1 elseif ou=="yawleft"then X=X+1 elseif ou=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ou=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ou=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ou=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ou=="groundaltitudeup"then ov()elseif ou=="groundaltitudedown"then ov(true)elseif ou=="option1"then toggleView=false;if AltIsOn and a1 then local oE=""for i=1,#passengers do oE=oE.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..oE)return end;aW.adjustAutopilotTargetIndex()elseif ou=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif ou=="option3"then local function oF()aE=not aE;if not aE then bZ("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bZ("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local oE=""for i=1,#ships do oE=oE.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..oE)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oF()toggleView=false elseif ou=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cu()elseif ou=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then bZ("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bZ("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif ou=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local oG=shield_1.getVentingCooldown()if oG>0 then a2="Cannot vent again for "..oG.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;ct()elseif ou=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif ou=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bZ("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bZ("gsOn","GS")end;toggleView=false elseif ou=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)ch(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bZ("gyOn","GA")else bZ("gyOff","GA")end end;toggleView=false elseif ou=="lshift"then if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif ou=="brake"then if BrakeToggleStatus then cw()elseif not BrakeIsOn then cw()else BrakeIsOn=true end elseif ou=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif ou=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif ou=="stopengines"then local function oH()if E-F<1.5 then bZ("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;oH()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)ch(0)else ch(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then ck(AtmoSpeedLimit)else ck(MaxGameVelocity*3.6)end end end elseif ou=="speedup"then oB()elseif ou=="speeddown"then oB(true)elseif ou=="antigravity"and not ExternalAGG then if antigrav~=nil then cy()end end end;function script.onActionStop(ou)local function oI()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if ou=="forward"then T=0 elseif ou=="backward"then T=0 elseif ou=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif ou=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif ou=="yawright"then X=0 elseif ou=="yawleft"then X=0 elseif ou=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ou=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ou=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ou=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ou=="groundaltitudeup"then oI()toggleView=false elseif ou=="groundaltitudedown"then oI()toggleView=false elseif ou=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif ou=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cw()else BrakeIsOn=false end end elseif ou=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(ou)local function oJ(ow)local D=1;if ow then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function oK(ow)local D=1;if ow then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if ou=="groundaltitudeup"then if not a1 then oJ()end elseif ou=="groundaltitudedown"then if not a1 then oJ(true)end elseif ou=="speedup"then oK()elseif ou=="speeddown"then oK(true)end end;function script.onInputText(ce)local function oL()for cI,cJ in pairs(c4())do dbHud_1.setStringValue(cJ,h(nil))end;for cI,cJ in pairs(c)do if cJ~="SavedLocations"then dbHud_1.setStringValue(cJ,h(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local function oM(oN,eA,hH)local function oO(eA)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cX='::pos{'..B..','..B..','..B..','..B..','..B..'}'local d9,da,dg,dh,di=o(eA,cX)if d9=="0"and da=="0"then return vec3(z(dg),z(dh),z(di))end;dh=math.rad(dh)dg=math.rad(dg)local planet=b[z(d9)][z(da)]local e1=math.cos(dg)local oP=vec3(e1*math.cos(dh),e1*math.sin(dh),math.sin(dg))return planet.center+(planet.radius+di)*oP end;local position=oO(eA)return aW.AddNewLocation(oN,position,hH)end;local i;local oQ,oR=nil,nil;local oS="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(ce," ")oQ=ce;if i~=nil then oQ=string.sub(ce,0,i-1)oR=string.sub(ce,i+1)end;if oQ=="/help"or oQ=="/commands"then for jl in string.gmatch(oS,"([^\n]+)")do system.print(jl)end;return elseif oQ=="/setname"then if oR==nil or oR==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(oR)else a2="Select a saved target to rename first"end elseif shield_1 and oQ=="/resist"then if oR==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cX=B..', '..B..', '..B..', '..B;local oT,oU,oV,oW=o(oR,cX)if oW==nil or oT+oU+oV+oW>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oT,oU,oV,oW)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oQ=="/addlocation"or string.find(ce,"::pos")~=nil then local hH=false;local oN="0-Temp"if oR==nil or oR==""then oR=oQ;hH=true end;i=string.find(oR,"::")if not hH then oN=string.sub(oR,1,i-2)end;local eA=string.sub(oR,i)oM(oN,eA,hH)elseif oQ=="/agg"then if oR==nil or oR==""then a2="Usage: /agg targetheight"return end;oR=z(oR)if oR<1000 then oR=1000 end;AntigravTargetAltitude=oR;a2="AGG Target Height set to "..oR elseif oQ=="/G"then if oR==nil or oR==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oR=="dump"then for cI,cJ in pairs(c4())do if type(_G[cJ])=="boolean"then if _G[cJ]==true then system.print(cJ.." true")else system.print(cJ.." false")end elseif _G[cJ]==nil then system.print(cJ.." nil")else system.print(cJ.." ".._G[cJ])end end;return end;i=string.find(oR," ")local oX=string.sub(oR,0,i-1)local oY=string.sub(oR,i+1)for cI,cJ in pairs(c4())do if cJ==oX then a2="Variable "..oX.." changed to "..oY;local oZ=type(_G[cJ])if oZ=="number"then oY=z(oY)elseif oZ=="boolean"then if string.lower(oY)=="true"then oY=true else oY=false end end;_G[cJ]=oY;return end end;a2="No such global variable: "..oX elseif oQ=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif oQ=="/copydatabank"then if dbHud_2 then cE(true)else a2="Spare Databank required to copy databank"end elseif oQ=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(da)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(da)if bP[1]and CollisionSystem then if#bL>650 then da=tostring(da)bL[da]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
