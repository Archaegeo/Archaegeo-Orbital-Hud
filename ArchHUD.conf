name: ArchHud - Archaegeo v0.741 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.741;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1175;V=66000;W=1000;X=50;Y=0;Z=100000;_=1.0;a0=32;a1=0;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)a9=K end,get=function()return a9 end},AutopilotInterplanetaryThrottle={set=function(K)_=K end,get=function()return _ end},warmup={set=function(K)a0=K end,get=function()return a0 end},fuelTankHandlingAtmo={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingSpace={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingRocket={set=function(K)a3=K end,get=function()return a3 end},ContainerOptimization={set=function(K)a4=K end,get=function()return a4 end},FuelTankOptimization={set=function(K)a5=K end,get=function()return a5 end},AutoShieldPercent={set=function(K)a6=K end,get=function()return a6 end},EmergencyWarp={set=function(K)a7=K end,get=function()return a7 end}}aa=1920;ab=1080;ac=400;ad=130;ae=224;af=255;ag=255;ah=0;ai=0;aj=960;ak=540;al=1300;am=540;an=1525;ao=325;ap=550;aq=540;ar=30;as=700;at=1750;au=250;av=1750;aw=350;ax=50;ay=250;az=0;aA=30;aB=100;aC={ResolutionX={set=function(K)aa=K end,get=function()return aa end},ResolutionY={set=function(K)ab=K end,get=function()return ab end},circleRad={set=function(K)ac=K end,get=function()return ac end},SafeR={set=function(K)ad=K end,get=function()return ad end},SafeG={set=function(K)ae=K end,get=function()return ae end},SafeB={set=function(K)af=K end,get=function()return af end},PvPR={set=function(K)ag=K end,get=function()return ag end},PvPG={set=function(K)ah=K end,get=function()return ah end},PvPB={set=function(K)ai=K end,get=function()return ai end},centerX={set=function(K)aj=K end,get=function()return aj end},centerY={set=function(K)ak=K end,get=function()return ak end},throtPosX={set=function(K)al=K end,get=function()return al end},throtPosY={set=function(K)am=K end,get=function()return am end},vSpdMeterX={set=function(K)an=K end,get=function()return an end},vSpdMeterY={set=function(K)ao=K end,get=function()return ao end},altMeterX={set=function(K)ap=K end,get=function()return ap end},altMeterY={set=function(K)aq=K end,get=function()return aq end},fuelX={set=function(K)ar=K end,get=function()return ar end},fuelY={set=function(K)as=K end,get=function()return as end},shieldX={set=function(K)at=K end,get=function()return at end},shieldY={set=function(K)au=K end,get=function()return au end},radarX={set=function(K)av=K end,get=function()return av end},radarY={set=function(K)aw=K end,get=function()return aw end},DeadZone={set=function(K)ax=K end,get=function()return ax end},OrbitMapSize={set=function(K)ay=K end,get=function()return ay end},OrbitMapX={set=function(K)az=K end,get=function()return az end},OrbitMapY={set=function(K)aA=K end,get=function()return aA end},soundVolume={set=function(K)aB=K end,get=function()return aB end}}aD=5.0;aE=1.0;aF=0.003;aG=0.003;aH=2;aI=1.5;aJ=180;aK=150;aL=0.002;aM=2;aN=0.8;aO=1;aP=3;aQ=1;aR=40;aS=0.0666667;aT=0.0;aU="none"aV="none"aW="none"aX={speedChangeLarge={set=function(K)aD=K end,get=function()return aD end},speedChangeSmall={set=function(K)aE=K end,get=function()return aE end},MouseXSensitivity={set=function(K)aF=K end,get=function()return aF end},MouseYSensitivity={set=function(K)aG=K end,get=function()return aG end},autoRollFactor={set=function(K)aH=K end,get=function()return aH end},rollSpeedFactor={set=function(K)aI=K end,get=function()return aI end},autoRollRollThreshold={set=function(K)aJ=K end,get=function()return aJ end},minRollVelocity={set=function(K)aK=K end,get=function()return aK end},TrajectoryAlignmentStrength={set=function(K)aL=K end,get=function()return aL end},torqueFactor={set=function(K)aM=K end,get=function()return aM end},pitchSpeedFactor={set=function(K)aN=K end,get=function()return aN end},yawSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeSpeedFactor={set=function(K)aP=K end,get=function()return aP end},brakeFlatFactor={set=function(K)aQ=K end,get=function()return aQ end},DampingMultiplier={set=function(K)aR=K end,get=function()return aR end},hudTickRate={set=function(K)aS=K end,get=function()return aS end},ExtraEscapeThrust={set=function(K)aT=K end,get=function()return aT end},ExtraLongitudeTags={set=function(K)aU=K end,get=function()return aU end},ExtraLateralTags={set=function(K)aV=K end,get=function()return aV end},ExtraVerticalTags={set=function(K)aW=K end,get=function()return aW end}}aY=j;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=false;b9=1000;ba=false;bb=false;bc=false;bd=false;be=0;bf="Aligning"bg=0;bh=1;bi="None"bj=nil;bk=0;bl=nil;bm=0.0;bn=0;bo={}bp=false;bq=0;br=0;bs=nil;bt=0;bu=1000;bv=0;bw=false;bx=0;by=false;bz="All"bA=true;bB="Off"bC=0.000;bD={}bE={}bF={VertTakeOff={set=function(K)b8=K end,get=function()return b8 end},VertTakeOffEngine={set=function(K)aZ=K end,get=function()return aZ end},SpaceTarget={set=function(K)bw=K end,get=function()return bw end},BrakeToggleStatus={set=function(K)aY=K end,get=function()return aY end},BrakeIsOn={set=function(K)a_=K end,get=function()return a_ end},RetrogradeIsOn={set=function(K)b0=K end,get=function()return b0 end},ProgradeIsOn={set=function(K)b1=K end,get=function()return b1 end},Autopilot={set=function(K)b2=K end,get=function()return b2 end},TurnBurn={set=function(K)b3=K end,get=function()return b3 end},AltitudeHold={set=function(K)b4=K end,get=function()return b4 end},BrakeLanding={set=function(K)b5=K end,get=function()return b5 end},Reentry={set=function(K)b7=K end,get=function()return b7 end},AutoTakeoff={set=function(K)b6=K end,get=function()return b6 end},HoldAltitude={set=function(K)b9=K end,get=function()return b9 end},AutopilotAccelerating={set=function(K)ba=K end,get=function()return ba end},AutopilotBraking={set=function(K)bc=K end,get=function()return bc end},AutopilotCruising={set=function(K)bd=K end,get=function()return bd end},AutopilotRealigned={set=function(K)bb=K end,get=function()return bb end},AutopilotEndSpeed={set=function(K)be=K end,get=function()return be end},AutopilotStatus={set=function(K)bf=K end,get=function()return bf end},AutopilotPlanetGravity={set=function(K)bg=K end,get=function()return bg end},PrevViewLock={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetName={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetCoords={set=function(K)bj=K end,get=function()return bj end},AutopilotTargetIndex={set=function(K)bk=K end,get=function()return bk end},TotalDistanceTravelled={set=function(K)bm=K end,get=function()return bm end},TotalFlightTime={set=function(K)bn=K end,get=function()return bn end},SavedLocations={set=function(K)bo=K end,get=function()return bo end},VectorToTarget={set=function(K)bp=K end,get=function()return bp end},LocationIndex={set=function(K)bq=K end,get=function()return bq end},LastMaxBrake={set=function(K)br=K end,get=function()return br end},LockPitch={set=function(K)bs=K end,get=function()return bs end},LastMaxBrakeInAtmo={set=function(K)bt=K end,get=function()return bt end},AntigravTargetAltitude={set=function(K)bu=K end,get=function()return bu end},LastStartTime={set=function(K)bv=K end,get=function()return bv end},iphCondition={set=function(K)bz=K end,get=function()return bz end},stablized={set=function(K)bA=K end,get=function()return bA end},UseExtra={set=function(K)bB=K end,get=function()return bB end},SelectedTab={set=function(K)bG=K end,get=function()return bG end},saveRoute={set=function(K)bD=K end,get=function()return bD end},apRoute={set=function(K)bE=K end,get=function()return bE end}}local function bH(b,c,bI,bJ,bK)local a=DUSystem;local bL=DUConstruct;bM=bI()bN=0;bO=0;bP=false;bQ=0;bR=false;bS=false;bT=0;bU=0;bV=0;bW=0;bX=false;bY=false;bZ="empty"b_=3;c0=false;c1=0;c2=0;c3=nil;c4=0;c5=0;c6=0;c7=false;c8=false;c9=false;ca=-1;cb=bK()>0;cc=bK()cd=b.getAltitude()ce=DUConstruct.getMass()cf=nil;cg=aa;ch=ab;ci={}cj={}ck={}cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=nil;cu=false;cv=false;cw=p;cx=false;cy=U;cz=nil;cA=0;cB=false;cC=false;cD=false;cE=vec3(bL.getWorldOrientationForward())cF=vec3(bL.getWorldOrientationRight())cG=vec3(bL.getVelocity())cH=vec3(bL.getWorldVelocity())cI=vec3(cH):len()cJ=vec3(b.getWorldVertical())cK=-cJ:dot(cH)cL=vec3(bL.getWorldPosition())cM=false;cN=false;cO=true;cP=0;cQ=0;cR={}cS=false;cT=50000;cU=nil;cV=c.getClosestPlanetInfluence()>0 or cd>0 and cd<200000;cW=false;cX=nil;cY=false;cZ=0;c_=nil;d0=nil;d1={}d2=90;d3=w;d4=nil;d5=nil;d6={}d7={}d8=false;d9=nil;da=0;db=false;dc=bL.getMaxSpeed()if shield then dd=bJ(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function de(df)a.print(bM..": "..df)end;local function dg(d,b,c,a,dh,di,dj,dk,dl)local function dm(dn)return type(dn)=='number'end;local function dp(dn)return type(dj(dn))=='number'end;local function dq(dr)return type(dr)=='table'end;local function ds(a)return type(a)=='string'end;local function dt(du)return dq(du)and dm(du.x and du.y and du.z)end;local function dv(dw)return dq(dw)and dm(dw.latitude and dw.longitude and dw.altitude and dw.id and dw.systemId)end;local dx=math.pi/180;local dy=180/math.pi;local dz=1e-10;local dA=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dB='::pos{'..dA..','..dA..','..dA..','..dA..','..dA..'}'local utils=utils;local vec3=vec3;local function dC(dn)local dD=string.gsub(string.reverse(dh('%.4f',dn)),'^0*%.?','')return dD==''and'0'or string.reverse(dD)end;local function dE(dF)if dt(dF)then return dh('{x=%.3f,y=%.3f,z=%.3f}',dF.x,dF.y,dF.z)end;if dq(dF)and not getmetatable(dF)then local dG={}local dH=next(dF)if type(dH)=='nil'or dH==1 then dG=dF else for dI,du in pairs(dF)do local dJ=dE(du)if type(dI)=='number'then table.insert(dG,dh('[%s]=%s',dI,dJ))else table.insert(dG,dh('%s=%s',dI,dJ))end end end;return dh('{%s}',table.concat(dG,','))end;if ds(dF)then return dh("'%s'",dF:gsub("'",[[\']]))end;return tostring(dF)end;local dK={}dK.__index=dK;dK.__tostring=function(dF,dL)local dM={}for dI in pairs(dF)do table.insert(dM,dI)end;table.sort(dM)local dG={}for dN,dI in ipairs(dM)do local dJ=dE(dF[dI])if type(dI)=='number'then table.insert(dG,dh('[%s]=%s',dI,dJ))else table.insert(dG,dh('%s=%s',dI,dJ))end end;if dL then return dh('%s%s',dL,table.concat(dG,',\n'..dL))end;return dh('{%s}',table.concat(dG,','))end;dK.__eq=function(dO,dP)return dO.systemId==dP.systemId and dO.id==dP.id and dl(dO.radius,dP.radius)and dl(dO.center.x,dP.center.x)and dl(dO.center.y,dP.center.y)and dl(dO.center.z,dP.center.z)and dl(dO.GM,dP.GM)end;local function dQ(dR,dS,dT,dU,dV)assert(dp(dR),'Argument 1 (systemId) must be a number:'..type(dR))assert(dp(dS),'Argument 2 (id) must be a number:'..type(dS))assert(dp(dT),'Argument 3 (radius) must be a number:'..type(dT))assert(dq(dU),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dU))assert(dp(dV),'Argument 5 (GM) must be a number:'..type(dV))return setmetatable({systemId=dj(dR),id=dj(dS),radius=dj(dT),center=vec3(dU),GM=dj(dV)},dK)end;local dW={}dW.__index=dW;dW.__tostring=function(de)return dh('::pos{%d,%d,%s,%s,%s}',de.systemId,de.id,dC(de.latitude*dy),dC(de.longitude*dy),dC(de.altitude))end;dW.__eq=function(dO,dP)return dO.id==dP.id and dO.systemId==dP.systemId and dl(dO.latitude,dP.latitude)and dl(dO.altitude,dP.altitude)and(dl(dO.longitude,dP.longitude)or dl(dO.latitude,math.pi/2)or dl(dO.latitude,-math.pi/2))end;local function dX(dY,dS,dZ,d_,e0)local dR=dY;if ds(dY)and not d_ and not e0 and not dS and not dZ then dR,dS,dZ,d_,e0=e1(dY,dB)assert(dR,'Argument 1 (position string) is malformed.')else assert(dp(dR),'Argument 1 (systemId) must be a number:'..type(dR))assert(dp(dS),'Argument 2 (id) must be a number:'..type(dS))assert(dp(dZ),'Argument 3 (latitude) must be in degrees:'..type(dZ))assert(dp(d_),'Argument 4 (longitude) must be in degrees:'..type(d_))assert(dp(e0),'Argument 5 (altitude) must be in meters:'..type(e0))end;dR=dj(dR)dS=dj(dS)dZ=dj(dZ)d_=dj(d_)e0=dj(e0)if dS==0 then return setmetatable({latitude=dZ,longitude=d_,altitude=e0,id=dS,systemId=dR},dW)end;return setmetatable({latitude=dx*di(dZ,-90,90),longitude=dx*(d_%360),altitude=e0,id=dS,systemId=dR},dW)end;local e2={}e2.__index=e2;e2.__tostring=function(dF,dL)local e3=dL and dL..'  'local e4={}local dM={}for dI in pairs(dF)do table.insert(dM,dI)end;table.sort(dM)for dN,e5 in ipairs(dM)do e6=dF[e5]local e7=dK.__tostring(e6,e3)if dL then table.insert(e4,dh('[%s]={\n%s\n%s}',e5,e7,dL))else table.insert(e4,dh('  [%s]=%s',e5,e7))end end;if dL then return dh('\n%s%s%s',dL,table.concat(e4,',\n'..dL),dL)end;return dh('{\n%s\n}',table.concat(e4,',\n'))end;local function e8(e9)local e={}local pid;for dN,du in pairs(e9)do local dS=du.planetarySystemId;if type(dS)~='number'then error('Invalid planetary s ID: '..tostring(dS))elseif pid and dS~=pid then error('Mistringmatch planetary s IDs: '..dS..' and '..pid)end;local ea=du.bodyId;if type(ea)~='number'then error('Invalid body ID: '..tostring(ea))elseif e[ea]then error('Duplicate body ID: '..tostring(ea))end;setmetatable(du.center,getmetatable(vec3.unit_x))e[ea]=setmetatable(du,dK)pid=dS end;return setmetatable(e,e2)end;eb={}local function ec(e9)return setmetatable({galaxyAtlas=e9 or{}},eb)end;eb.__index=function(dr,K)if type(K)=='number'then local a=dr.galaxyAtlas[K]return e8(a)end;return rawget(eb,K)end;eb.__pairs=function(dF)return function(dr,dI)local ed,ee=next(dr,dI)return ed,ee and e8(ee)end,dF.galaxyAtlas,nil end;eb.__tostring=function(dF)local ef={}for dN,eg in pairs(dF or{})do local eh=eg:getPlanetarySystemId()local ei=e2.__tostring(eg,'    ')table.insert(ef,dh('  [%s]={%s\n  }',eh,ei))end;return dh('{\n%s\n}\n',table.concat(ef,',\n'))end;eb.BodyParameters=dQ;eb.MapPosition=dX;eb.PlanetarySystem=e8;function eb.createBodyParameters(dR,dS,ej,ek,el,em,en)assert(dp(dR),'Argument 1 (systemId) must be a number:'..type(dR))assert(dp(dS),'Argument 2 (id) must be a number:'..type(dS))assert(dp(ej),'Argument 3 (surfaceArea) must be a number:'..type(ej))assert(dq(ek),'Argument 4 (aPosition) must be an array or vec3:'..type(ek))assert(dq(el),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(el))assert(dp(em),'Argument 6 (altitude) must be in meters:'..type(em))assert(dp(en),'Argument 7 (gravityAtPosition) must be number:'..type(en))local dT=dk(ej/4/math.pi)local c6=dT+em;local eo=vec3(ek)+c6*vec3(el)local dV=en*c6*c6;return dQ(dR,dS,dT,eo,dV)end;eb.isMapPosition=dv;function eb:getPlanetarySystem(dY)if K==nil then K=0 end;if ee==nil then ee=0 end;local dR=dY;if dv(dY)then dR=dY.systemId end;if type(dR)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ee)~=e2 then a=e8(a)end;return a end end end;function e2:sizeCalculator(ep)return 1.05*ep.radius end;function e2:castIntersections(eq,er,es,et,eu,ev)local ew={}if eu then for dN,ep in pairs(eu)do table.insert(ew,ep)end else ew=d1 end;if not ev then table.sort(ew,function(ex,ey)local ez=ex.center;local eA=ey.center;return(ez.x-eq.x)^2+(ez.y-eq.y)^2+(ez.z-eq.z)^2<(eA.x-eq.x)^2+(eA.y-eq.y)^2+(eA.z-eq.z)^2 end)end;local eB=er:normalize()for dN,ep in ipairs(ew)do local eC=ep.center-eq;local dT;if es then dT=es(ep)else dT=self:sizeCalculator(ep)end;local eD=eC:dot(eB)local eE=eD^2-(eC:len2()-dT^2)if eE>=0 then local eF=dk(eE)local eG=eD+eF;local eH=eD-eF;if eH>0 then return ep,eG,eH elseif eG>0 then return ep,eG,nil end end end;return nil,nil,nil end;function e2:closestBody(eI)assert(type(eI)=='table','Invalid coordinates.')local eJ,ep;local eK=vec3(eI)for dN,eL in pairs(self)do local eM=(eL.center-eK):len2()if(not ep or eM<eJ)and eL.name~="Space"then ep=eL;eJ=eM end end;return ep end;function e2:convertToBodyIdAndWorldCoordinates(dY)local eN=dY;if ds(dY)then eN=dX(dY)end;if eN.id==0 then return 0,vec3(eN.latitude,eN.longitude,eN.altitude)end;local eL=self:getBodyParameters(eN)if eL then return eN.id,eL:convertToWorldCoordinates(eN)end end;function e2:getBodyParameters(dY)local dS=dY;if dv(dY)then dS=dY.id end;assert(dp(dS),'Argument 1 (id) must be a number:'..type(dS))return self[dS]end;function e2:getPlanetarySystemId()local dN,du=next(self)return du and du.systemId end;function dK:convertToMapPosition(dU)assert(dq(dU),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dU))local eO=vec3(dU)if self.id==0 then return setmetatable({latitude=eO.x,longitude=eO.y,altitude=eO.z,id=0,systemId=self.systemId},dW)end;local eP=eO-self.center;local c6=eP:len()local e0=c6-self.radius;local dZ=0;local d_=0;if not dl(c6,0)then local eQ=eR(eP.y,eP.x)d_=eQ>=0 and eQ or 2*math.pi+eQ;dZ=math.pi/2-math.acos(eP.z/c6)end;return setmetatable({latitude=dZ,longitude=d_,altitude=e0,id=self.id,systemId=self.systemId},dW)end;function dK:convertToWorldCoordinates(dY)local eN=ds(dY)and dX(dY)or dY;if eN.id==0 then return vec3(eN.latitude,eN.longitude,eN.altitude)end;assert(dv(eN),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eN.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eN.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eS=math.cos(eN.latitude)return self.center+(self.radius+eN.altitude)*vec3(eS*math.cos(eN.longitude),eS*math.sin(eN.longitude),math.sin(eN.latitude))end;function dK:getAltitude(dU)return(vec3(dU)-self.center):len()-self.radius end;function dK:getDistance(dU)return(vec3(dU)-self.center):len()end;function dK:getGravity(dU)local eT=self.center-vec3(dU)local eU=eT:len2()return self.GM/eU*eT/dk(eU)end;return setmetatable(eb,{__call=function(dN,...)return ec(...)end})end;local function eV(d,b,c,a,dk,eW)local cm={}local bL=100000000/3600;local eX=bL*bL;local eY=100;function cm.computeAccelerationTime(eZ,e_,f0)local f1=bL*math.asin(eZ/bL)return(bL*math.asin(f0/bL)-f1)/e_ end;function cm.computeDistanceAndTime(eZ,f0,f2,f3,f4,f5)f4=f4 or 0;f5=f5 or 0;local f6=eZ<=f0;local f7=f3*(f6 and 1 or-1)/f2;local f8=-f5/f2;local f9=f7+f8;if f6 and f9<=0 or not f6 and f9>=0 then return-1,-1 end;local fa,fb=0,0;if f7~=0 and f4>0 then local f1=math.asin(eZ/bL)local fc=math.pi*(f7/2+f8)local fd=f7*f4;local fe=bL*math.pi;local du=function(dr)local ff=(fc*dr-fd*math.sin(math.pi*dr/2/f4)+fe*f1)/fe;local fg=math.tan(ff)return bL*fg/dk(fg*fg+1)end;local fh=f6 and function(a)return a>=f0 end or function(a)return a<=f0 end;fb=2*f4;if fh(du(fb))then local fi=0;while eW(fb-fi)>0.5 do local dr=(fb+fi)/2;if fh(du(dr))then fb=dr else fi=dr end end end;local fj=eZ;local fk=fb/eY;for fl=1,eY do local fm=du(fl*fk)fa=fa+(fm+fj)*fk/2;fj=fm end;if fb<2*f4 then return fa,fb end;eZ=fj end;local f1=bL*math.asin(eZ/bL)local bM=(bL*math.asin(f0/bL)-f1)/f9;local fn=eX*math.cos(f1/bL)/f9;local c6=fn-eX*math.cos((f9*bM+f1)/bL)/f9;return c6+fa,bM+fb end;function cm.computeTravelTime(eZ,e_,c6)if c6==0 then return 0 end;if e_>0 then local f1=bL*math.asin(eZ/bL)local fn=eX*math.cos(f1/bL)/e_;return(bL*math.acos(e_*(fn-c6)/eX)-f1)/e_ end;if eZ==0 then return-1 end;assert(eZ>0,'Acceleration and initial speed are both zero.')return c6/eZ end;return cm end;local function fo(d,b,c,a,dh,di,dj,dk,dl)local vec3=vec3;local dg=dg(d,b,c,a,dh,di,dj,dk,dl)local function ds(a)return type(a)=='string'end;local function dq(dr)return type(dr)=='table'end;fp={}fp.__index=fp;function fp:escapeAndOrbitalSpeed(e0)assert(self.body)local c6=e0+self.body.radius;if not dl(c6,0)then local fq=dk(self.body.GM/c6)return dk(2)*fq,fq end;return nil,nil end;function fp:orbitalParameters(dY,fr)assert(self.body)assert(dq(dY)or ds(dY))assert(dq(fr))local fs=(ds(dY)or dg.isMapPosition(dY))and self.body:convertToWorldCoordinates(dY)or vec3(dY)local du=vec3(fr)local ft=fs-self.body.center;local fu=du:len2()local fv=ft:len()local fw=self.body.GM;local fx=((fu-fw/fv)*ft-ft:dot(du)*du)/fw;local ez=fw/(2*fw/fv-fu)local fy=fx:len()local eB=fx:normalize()local fz=ez*(1-fy)local fA=ez*(1+fy)local fB=fz*eB+self.body.center;local fC=fy<=1 and-fA*eB+self.body.center or nil;local fD=dk(ez*fw*(1-fy*fy))local fE=fC and 2*math.pi*dk(ez^3/fw)local fF=math.acos(fx:dot(ft)/(fy*fv))if ft:dot(du)<0 then fF=-(fF-2*math.pi)end;local fG=math.acos((math.cos(fF)+fy)/(1+fy*math.cos(fF)))local fH=fG;if fH<0 then fH=fH+2*math.pi end;local fI=fH-fy*math.sin(fH)local fJ=0;local fK=0;local fL=0;if fE~=nil then fJ=fI/(2*math.pi/fE)fK=fE-fJ;fL=fK+fE/2;if fF-math.pi>0 then fK=fJ;fL=fK+fE/2 end;if fL>fE then fL=fL-fE end end;return{periapsis={position=fB,speed=fD/fz,circularOrbitSpeed=dk(fw/fz),altitude=fz-self.body.radius},apoapsis=fC and{position=fC,speed=fD/fA,circularOrbitSpeed=dk(fw/fA),altitude=fA-self.body.radius},currentVelocity=du,currentPosition=fs,eccentricity=fy,period=fE,eccentricAnomaly=fG,meanAnomaly=fI,timeToPeriapsis=fK,timeToApoapsis=fL,trueAnomaly=fF}end;local function fM(fN)local eL=dg.BodyParameters(fN.systemId,fN.id,fN.radius,fN.center,fN.GM)return setmetatable({body=eL},fp)end;return setmetatable(fp,{__call=function(dN,...)return fM(...)end})end;local function fO(d,b,c,a,dbHud_1,e,fP,fQ,bJ,dj,dk,fR,fS)local function fT(fU)local de=fV:closestBody(fU)if(fU-de.center):len()>de.radius+de.noAtmosphericDensityAltitude then de=e[0][0]end;return de end;local function fW()local function fX(fY,fZ)return fY.name<fZ.name end;cR={}for dI,du in pairs(e[0])do cR[#cR+1]={name=du.name,index=dI}end;table.sort(cR,fX)end;local function f_(g0,g1)if not g1 then g1=g2.name end;for dI,du in pairs(g0)do if du.name and du.name==g1 then return dI end end;return-1 end;local function g3()cZ=bk;if bk==0 then bi="None"c3=nil;g2=nil;return true end;local g4=cR[bk].index;local g5=e[0][g4]if g5.center then bi=g5.name;c3=cl[0][g4]if g2~=nil then if cc==0 then if fP(g6,g7)~=1 then fQ(g6,g7)end;if fP(g8,g9)~=1 then fQ(g8,g9)end;if fP(ga,gb)~=1 then fQ(ga,gb)end;if fP(gc,gd)~=1 then fQ(gc,gd)end;if fP(ge,gf)~=1 then fQ(ge,gf)end end;if fP(gg,gh)~=1 then fQ(gg,gh)end;if fP(gi,gj)~=1 then fQ(gi,gj)end;if fP(gk,gl)~=1 then fQ(gk,gl)end end;g2=nil else g2=g5;for dN,du in pairs(cl[0])do if du.name==g2.planetname then c3=du;bi=g2.name;break end end;if fP(gg,gh)~=1 then fQ(gg,gh)end;if fP(gi,gj)~=1 then fQ(gi,gj)end end;if g2==nil then bj=vec3(c3.center)else bj=g2.position end;if c3.planetname~="Space"then if c3.hasAtmosphere then gm=bJ(c3.radius*(S-1)+c3.noAtmosphericDensityAltitude)else gm=bJ(c3.radius*(S-1)+c3.surfaceMaxAltitude)end else gm=R end;if g2~=nil and g2.planetname=="Space"then be=0 else dN,be=cn(c3):escapeAndOrbitalSpeed(gm)end;bg=0;ba=false;bc=false;bd=false;b2=false;bb=false;bf="Aligning"return true end;local function gn(go)if not b2 and not bp and not c8 and not by and not b7 and not c9 then if go==nil then bk=bk+1;if bk>#cR then bk=0 end else bk=bk-1;if bk<0 then bk=#cR end end;if bk==0 then g3()else local g4=cR[bk].index;local g5=e[0][g4]if g5 and(g5~=nil and g5.name=="Space"or bz=="Custom Only"and g5.center or bz=="No Moons"and string.find(g5.name,"Moon")~=nil)then if go==nil then gn()else gn(1)end else g3()end end else bZ="Disengage autopilot before changing Interplanetary Helper"fR("iph","AP")end end;local function gp()local function gq(gr)local gs;if gr then gs=d6 else gs=bo end;local gt=-1;gt=f_(e[0])if gt>-1 then table.remove(e[0],gt)end;gt=-1;gt=f_(gs)if gt~=-1 then bZ=g2.name.." saved location cleared"table.remove(gs,gt)end;gn()fW()return gs end;if string.sub(bi,1,1)=="*"then d6=gq(true)else bo=gq(false)end end;local function gu(gv,fU,gw,gx)local function gy(gr)if gr then gs=d6 else gs=bo end;if dbHud_1 or gw or gr then local de=fT(fU)local gz={position=fU,name=gv,planetname=de.name,gravity=b.getGravityIntensity(),safe=gx}if not gw then gs[#gs+1]=gz else for dI,du in pairs(e[0])do if du.name and gv==du.name then table.remove(e[0],dI)end end end;table.insert(e[0],gz)fW()g3()bZ="Location saved as "..gv.."("..de.name..")"return gs else bZ="Databank must be installed to save permanent locations"end end;if string.sub(gv,1,1)=="*"then d6=gy(true)else bo=gy(false)end end;local gA={}function gA.UpdateAtlasLocationsList()fW()end;function gA.UpdateAutopilotTarget()g3()end;function gA.adjustAutopilotTargetIndex(go)gn(go)end;function gA.findAtlasIndex(g0,g1)return f_(g0,g1)end;function gA.UpdatePosition(gB,gC,gD)local function gE(gr)local gs;if gr then gs=d6 else gs=bo end;local gt=f_(gs)if gt~=-1 then if gB~=nil then if gr then gB="*"..gB end;gs[gt].name=gB;bk=bk-1;gn()elseif gD~=nil then if gD then local gF=cd;if gF<1000 then gF=1000 end;gs[gt].agg=fS(gF,0)bZ=gs[gt].name.." AGG Altitude:"..gs[gt].agg.." saved ("..gs[gt].planetname..")"return elseif gD==false then gs[gt].agg=nil;bZ=gs[gt].name.." AGG Altitude cleared ("..gs[gt].planetname..")"return end else local gG=gs[gt]if gC then gG.heading=cF:cross(cJ)*5000;bZ=gs[gt].name.." heading saved ("..gs[gt].planetname..")"return elseif gC==false then gG.heading=nil;bZ=gs[gt].name.." heading cleared ("..gs[gt].planetname..")"return end;gG.gravity=b.getGravityIntensity()gG.position=cL;gG.safe=true end;bZ=gs[gt].name.." position updated ("..gs[gt].planetname..")"else bZ="Name Not Found"end end;if string.sub(bi,1,1)=="*"then gE(true)else gE(false)end end;function gA.AddNewLocation(gv,fU,gw,gx)gu(gv,fU,gw,gx)end;function gA.ClearCurrentPosition()gp()end;for dI,du in pairs(d7)do table.insert(e[0],du)end;if gH then for dI,du in pairs(gH)do gA[dI]=du end end;fW()if bk>#cR then bk=0 end;gA.UpdateAutopilotTarget()return gA end;local function gI(b,a,c,gJ,radar_1,radar_2,warpdrive,eW,gK,dk,gL,dj,gM,fR)local gN={}local gO={}local gP={XS=13,S=27,M=55,L=110,XL=221}local gQ={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gR={}local gS=0;local gT;local gU;local gV;local gW;local gX={gW}local gY="Atmo"local gZ;local g_;local h0=0;local h1={}local h2;local h3=0;local vec3=vec3;local h4=table.insert;local h5=-4;local h6={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local function h7()local function h8(h9,ha,hb,hc,hd,he,hf,hg)ha,hc,he,hg=vec3(ha),vec3(hc),vec3(he),vec3(hg)local hh,hi,hj=h9*h9,hb*hb,hd*hd;local fu=hc-ha;local hk=fu:normalize()local hl=fu:len()local hm=he-ha;local hn=(hm-hm:project_on(hk)):normalize()local ho,hp=hm:dot(hk),hm:dot(hn)local hq=ho*ho+hp*hp;local hr=hk:cross(hn)local hs=(hh-hi+hl*hl)/(2*hl)local ht=(hh-hj+hq-2*ho*hs)/(2*hp)local dw=hh-hs^2-ht^2;local hu=dk(dw)local hv=ha+hk*hs+hn*ht+hr*hu;local hw=ha+hk*hs+hn*ht-hr*hu;if eW((hg-hv):len()-hf)<eW((hg-hw):len()-hf)then return hv else return hw end end;local function hx(hy,fv,hz)local hA=hy.pts;local gt=#hA;local hB=hy.ref;if gt>3 then local hC,hD,hE,hF=hA[gt],hA[gt-1],hA[gt-2],hA[gt-3]hy.ref=hz;local fs=h8(hC[1],hC[2],hD[1],hD[2],hE[1],hE[2],hF[1],hF[2])local hs,ht,hu=fs.x,fs.y,fs.z;if hs==hs and ht==ht and hu==hu then hs=hs+hB[1]ht=ht+hB[2]hu=hu+hB[3]local hG=vec3(hs,ht,hu)hy.center=hG;if hy.lastPos then if(hy.lastPos-hG):len()<2 then local hH=(hG-vec3(hz)):len()if eW(hH-fv)<10 then hy.skipCalc=true end end end;hy.lastPos=hG end;hy.pts={}else local hI={hz[1]-hB[1],hz[2]-hB[2],hz[3]-hB[3]}hA[gt+1]={fv,hI}end end;if radar_1 or radar_2 then cr.assignRadar()end;if gW then gS=#gW.getConstructIds()if gS>0 then local hJ=h2:gmatch('{"constructId[^}]*}[^}]*}')local hK=gW.hasMatchingTransponder;local hL=gW.getConstructKind;local hM=gW.isConstructAbandoned;local hN=gW.getConstructName;local hz={cL["x"],cL["y"],cL["z"]}local hO,hP=0,0;local hQ=cI*10;local cV=cV;gV,gU=0,0;gO={}for du in hJ do local dS,c6,hR=du:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hS=gP[hR]c6=dj(c6)if hK(dS)==1 then h4(gO,dS)end;if E then local hT=hL(dS)local hU=F and hM(dS)==1;if hU or c6<hQ and(hS>27 or hT==4 or hT==6)then gV=gV+1;local gv=hN(dS)local hy=h1[dS]if hy==nil then hS=hS+gM;h1[dS]={pts={},ref=hz,name=gv,i=0,radius=hS,skipCalc=false}hy=h1[dS]end;if not hy.skipCalc then hx(hy,c6,hz)if hU and not hy.abandoned and hy.center then local bM=a.getArkTime()if h3+5<bM then h3=bM;fR("abRdr","RD")end;a.print("Abandoned Construct: "..gv.." ("..hR.." "..gQ[hT]..") at estimated ::pos{0,0,"..hy.center.x..","..hy.center.y..","..hy.center.z.."}")bZ="Abandoned Radar Contact ("..hR.." "..gQ[hT]..") detected"hy.abandoned=true end;hP=hP+1 else h4(gR,hy)end end;hO=hO+1;if cV and hO>700 or hP>70 or(not cV and hO>300 or hP>30)then coroutine.yield()hO,hP=0,0 end end end;gU=#gR;if gU>0 and(cI>20 or b5)then local ep,hV,hW,hX;local hY=0;local hZ=cl:getPlanetarySystem(0)hX=cH:normalize()while hY<gU do coroutine.yield()local h_={table.unpack(gR,hY,math.min(hY+75,gU))}ep,hV,hW=hZ:castIntersections(cL,hX,nil,nil,h_,true)if ep and hW then cX={ep,hV,hW}break end;hY=hY+75 end;if not ep then cX=nil end else cX=nil end;gR={}gT=h2:find('identifiedConstructs":%[%]')end end end;local function i0()if gW then gY="Atmo"if h2:find('worksInAtmosphere":false')then gY="Space"end end end;function gN.pickType()i0()end;function gN.assignRadar()if radar_2 and h5~=1 then if h5==-1 then if gW==radar_2 then gW=radar_1 else gW=radar_2 end end;gX={gW}h2=gW.getWidgetData()i0()else h2=gW.getWidgetData()end;h5=gW.getOperationalState()end;function gN.UpdateRadar()local i1=coroutine.status(gZ)if i1=="suspended"then local dJ,i2=coroutine.resume(gZ)if i2 then a.print("ERROR UPDATE RADAR: "..i2)end elseif i1=="dead"then gZ=coroutine.create(h7)local dJ,i2=coroutine.resume(gZ)end end;function gN.GetRadarHud(i3,i4,av,aw)local i5,df;local dA=gU or 0;if gS>0 then if E then df=dA.."/"..gV.." Plotted : "..gS-gV.." Ignored"else df="Radar Contacts: "..gS end;i5=gL(av,aw,df,"pbright txtbig txtmid")if#gO>0 then i5=i5 ..gL(i3,i4,"Friendlies In Range","pbright txtbig txtmid")for dI,du in pairs(gO)do i4=i4+20;i5=i5 ..gL(i3,i4,gW.getConstructName(du),"pdim txtmid")end end;if gT==nil and g_==nil then h0=1;cr.ToggleRadarPanel()end;if gT~=nil and g_~=nil then cr.ToggleRadarPanel()end;if d5==nil then cr.ToggleRadarPanel()end else if h5~=1 then i5=gL(av,aw,gY.." Radar: "..h6[h5],"pbright txtbig txtmid")else i5=gL(av,aw,"Radar: No "..gY.." Contacts","pbright txtbig txtmid")end;if d5~=nil then h0=0;cr.ToggleRadarPanel()end end;return i5 end;function gN.GetClosestName(gv)if gW then local dS,dN=gW.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dS~=nil and dS~=""then gv=gv.." "..gW.getConstructName(dS)end end;return gv end;function gN.ToggleRadarPanel()if d5~=nil and h0==0 then gK(d5)d5=nil;if g_~=nil then gK(g_)g_=nil end else if h0==1 then gK(d5)d5=nil;_autoconf.displayCategoryPanel(gX,1,"Periscope","periscope")g_=_autoconf.panels[_autoconf.panels_size]end;if d5==nil then _autoconf.displayCategoryPanel(gX,1,"Radar","radar")d5=_autoconf.panels[_autoconf.panels_size]end;h0=0 end end;function gN.ContactTick()if not i6 then i6=0 end;if bM>i6+10 then bZ="Radar Contact"fR("rdrCon","RC")i6=bM end;c.stopTimer("contact")end;function gN.onEnter(dS)if gW and not cb and not cS then c.setTimer("contact",0.1)if warpdrive and a7>0 and gW.getConstructDistance(dS)<a7 and warpdrive.getStatus()==15 then bZ="INITIATING WARP"b_=7;warpdrive.initiate()end end end;function gN.onLeave(dS)if gW and E then if#h1>650 then dS=tostring(dS)h1[dS]=nil end end end;gW=nil;if radar_2 and radar_2.getOperationalState()==1 then gW=radar_2 else gW=radar_1 end;h5=gW.getOperationalState()gX={gW}h2=gW.getWidgetData()i0()gZ=coroutine.create(h7)if i7 then for dI,du in pairs(i7)do gN[dI]=du end end;return gN end;local function i8(shield,e1,bJ)local i9={}local ia=shield.getResistancesCooldown()local function ib()local ic=shield.isActive()if G then if not cS and ic==0 and shield.isVenting()~=1 then shield.toggle()elseif cS and ic==1 then shield.toggle()end end end;local function id()local ie=shield.getStressRatioRaw()local ig=0.5999;if ie[1]==0.0 and ie[2]==0.0 and ie[3]==0.0 and ie[4]==0.0 then return end;local ih=shield.setResistances(ig*ie[1],ig*ie[2],ig*ie[3],ig*ie[4])if ih==1 then bZ="Shield Resistances updated"else bZ="Value Exceeded. Failed to update Shield Resistances"end end;function i9.shieldTick()dd=bJ(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ib()ia=shield.getResistancesCooldown()if ia==0 and dd<a6 then id()end end;function i9.setResist(ii)if not shield then bZ="No shield found"return elseif ii==nil or ia>0 then bZ="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dA=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dB=dA..', '..dA..', '..dA..', '..dA;local ij,ik,il,im=e1(ii,dB)if im==nil or ij+ik+il+im>0.6 then bZ="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(ij,ik,il,im)==1 then bZ="Shield Resistances set"else bZ="Resistance setting failed."end end;function i9.ventShield()local io=shield.getVentingCooldown()if io>0 then bZ="Cannot vent again for "..io.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()bZ="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bZ="Shields already at max hitpoints"end end;if ip then for dI,du in pairs(ip)do i9[dI]=du end end;return i9 end;local function iq(d,b,c,a,e,antigrav,hover,shield,warpdrive,ir,eW,bJ,dh,is,bK,it,iu,eR,bI,di,iv,fQ,fP,gK,iw,dk,fS,gL,fR,ix,iy,iz,iA,iB,iC)local bL=DUConstruct;local iD=9.80665;local iE={}local iF={}local iG={}local iH={}local iI=nil;local iJ=nil;local iK=nil;local iL=false;local iM="none"local iN=""local iO=55;local iP=0;local iQ=0;local iR=nil;local iS=ad;local iT=ae;local iU=af;local iV=[[rgb(]]..bJ(iS+0.5)..","..bJ(iT+0.5)..","..bJ(iU+0.5)..[[)]]local iW=[[rgb(]]..bJ(iS*0.9+0.5)..","..bJ(iT*0.9+0.5)..","..bJ(iU*0.9+0.5)..[[)]]local iX=0;local iY=0;local iZ=""local i_=bI()local j0=false;local j1=false;local function j2(du)if cg==1920 then return du else return fS(cg*du/1920,0)end end;local function j3(du)if ch==1080 then return du else return fS(ch*du/1080,0)end end;local function j4()return iw()==0 and g~="keyboard"and iu()==0 end;local function j5()local j6="TRAVEL"if not cO then j6="CRUISE"end;if b2 then j6="AUTOPILOT"end;return j6 end;local i5=""local j7=""local j8=""local j9=1;local ja=2;local jb=3;local jc=4;local jd=5;local je=6;local jf=7;local jg=""local jh=0;local ji=120.0*aS;local jj={}local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}jp["atmofueltank"],jp["spacefueltank"],jp["rocketfueltank"]=0,0,0;local jq=0;local function jr(hs,js,jt,ju,jv,jw)local jx=jq;local jy=jq+5;if not B then jy=jy+5 end;if iu()==1 and not l then jx=jx-50;jy=jy-50 end;if jt=="ATMO"then jg="atmofueltank"elseif jt=="SPACE"then jg="spacefueltank"else jg="rocketfueltank"end;jh=_G[jg.."_size"]if#ju>0 then for K=1,#ju do local gv=ju[K][ja]local jz=ju[K][jf]for jA=1,jh do if ju[K][ja]==is(c[jg.."_"..jA].getWidgetData()).name then jz=jA;break end end;local jB=bI()if jv[K]==nil or jw[K]==nil or jB-ju[K][je]>ji then local jC;local jD=0;jD=it(ju[K][j9])-ju[K][jc]jC=ju[K][jd]if jC>jD then jp[jg]=jp[jg]+jC-jD end;if jz~=0 then local jE=is(c[jg.."_"..jz].getWidgetData())jw[K]=jE.percentage;jv[K]=jE.timeLeft;if jv[K]=="n/a"then jv[K]=0 end else jw[K]=bJ(0.5+jD*100/ju[K][jb])if jC<=jD then jv[K]=0 else jv[K]=bJ(0.5+jD/((jC-jD)/(jB-ju[K][je])))end end;ju[K][je]=jB;ju[K][jd]=jD end;if gv==js then gv=dh("%s %d",jt,K)end;if jz==0 then gv=gv.." *"end;local jF;if jv[K]==0 then jF=""else jF=iA(jv[K])end;if jw[K]~=nil then local jG=bJ(jw[K]*2.55)local jH=dh("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jv[K]<120 or jw[K]<5 then jI="red "end;local jJ=dh("rgb(%d,%d,%d)",di(bJ((255-jG)/2.55),50,100),di(bJ(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if jt=="ATMO"then jK="rgb(0,188,255)"elseif jt=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if B then if jL then jx=jx-5;jy=jy-5 end;j7=j7 ..dh([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hs,jy,jH,bJ(jw[K]*1.7+0.5)-2,hs+1,jy+1,hs+5,jy+14,gv,jw[K],jF)jx=jx-22;jy=jy-22 else j7=j7 ..gL(hs,jx,gv,jI.."pdim txtfuel")j7=j7 ..gL(hs,jy,dh("%d%% %s",jw[K],jF),"pdim txtfuel","fill:"..jH)jx=jx+30;jy=jy+30 end end end end;jq=jx end;local function jN(jO,e0)if an==0 and ao==0 then return end;if e0<200000 and not cb or e0 and cb then local jP=0;if eW(cK)>1 then jP=45*math.log(eW(cK),10)if cK<0 then jP=-jP end end;jO[#jO+1]=dh([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],an,ao,bJ(cK),bJ(jP))end;return jO end;local function jQ(jR)local go=-cJ;jR=jR-jR:project_on(go)local jS=vec3(0,0,1)jS=jS-jS:project_on(go)local jT=jS:cross(go)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,aj,ak,jV,jW,cV)if ac==0 then return end;local jX=ac;local jY=20;local jZ=bJ(jV)if cV then for K=-45,45,5 do local j_=K;jO[#jO+1]=dh([[<g transform="rotate(%f,%d,%d)">]],j_,aj,ak)k0=5;if K%15==0 then k0=15 elseif K%10==0 then k0=10 end;jO[#jO+1]=dh([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],aj,ak+jX+jY-k0,aj,ak+jX+jY)end;jO[#jO+1]=gL(aj,ak+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gL(aj,ak+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=dh([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)jO[#jO+1]=dh([[<<polygon points="%d,%d %d,%d %d,%d"/>]],aj-5,ak+jX+jY-20,aj+5,ak+jX+jY-20,aj,ak+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cV then k1=jQ(cE)end;local k2=20;local k3=bJ(k1)local k4=0;local k5=ak+jX+jY+20;local k6=aj;if jW~="YAW"then k5=j3(130)k6=j2(960)end;local k7=[[<path class="txttick line" d="]]local k8=bJ(k3-(k2+10)-k3%5+0.5)for K=k8+70,k8,-5 do local hs=k6-(-K*5+k1*5)if K%10==0 then k4=10;local dA=K;if dA==360 then dA=0 elseif dA>360 then dA=dA-360 elseif dA<0 then dA=dA+360 end;jO[#jO+1]=gL(hs,k5+15,dA,"txtmid bright")elseif K%5==0 then k4=5 end;if k4==10 then k7=dh([[%s M %f %f v %d]],k7,hs,k5-5,k4)else k7=dh([[%s M %f %f v %d]],k7,hs,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=dh([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if I then if cV then jW="HDG"end;jO[#jO+1]=gL(j2(960),j3(100),k3 .."°","dim txt txtmid size14","")jO[#jO+1]=gL(j2(960),j3(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,aj,ak,cV,kb,fm)if ac==0 then return end;local jX=ac;local kc=bJ(jX*3/5)if jX>0 then local kd=bJ(ka)local k0=0;local k7=dh([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,aj,ak)if not cb then k7=dh([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],aj,ak)end;jO[#jO+1]=dh([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,aj,ak)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bJ(kd-30-kd%5+0.5),bJ(kd+30+kd%5+0.5),5 do if K%10==0 then k0=30 elseif K%5==0 then k0=20 end;local ht=ak+-K*5+ka*5;if k0==30 then k7=dh([[%s M %d %f h %d]],k7,aj-kc-k0,ht,k0)if cb then jO[#jO+1]=dh([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj-kc+10,ht+4,K)jO[#jO+1]=dh([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,aj,ak,aj+kc-10,ht+4,K)if K==0 or K==180 or K==-180 then jO[#jO+1]=dh([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+20,ht,kc*2-40)end else jO[#jO+1]=gL(aj-kc+10,ht,K,"pdim txt txtmid")jO[#jO+1]=gL(aj+kc-10,ht,K,"pdim txt txtmid")end;k7=dh([[%s M %d %f h %d]],k7,aj+kc,ht,k0)else k7=dh([[%s M %d %f h %d]],k7,aj-kc-k0,ht,k0)k7=dh([[%s M %d %f h %d]],k7,aj+kc,ht,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cV then ke="REL PITCH"end;if ka>90 and not cb then ka=90-(ka-90)elseif ka<-90 and not cb then ka=-90-(ka+90)end;if jX>200 then if cb then if fm>iO then jO[#jO+1]=gL(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gL(aj,ak+20,kb,"pdim txt txtmid")end;jO[#jO+1]=dh([[<g transform="rotate(%f,%d,%d)">]],-jV,aj,ak)else jO[#jO+1]=dh([[<g transform="rotate(0,%d,%d)">]],aj,ak)end;jO[#jO+1]=dh([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj-kc+25,ak-5,aj-kc+20,ak,aj-kc+25,ak+5,aj-kc+50,ak+4,kd)jO[#jO+1]=dh([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],aj+kc-25,ak-5,aj+kc-20,ak,aj+kc-25,ak+5,aj+kc-30,ak+4,kd)jO[#jO+1]="</g>"end;local kf=bJ(jX/3)jO[#jO+1]=dh([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],aj-kf,ak,jX-kf)if not cb and cV then jO[#jO+1]=dh([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,aj,ak,aj-kc+10,ak,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if cb and fm>iO then jO[#jO+1]=gL(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gL(aj,ak-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gL(aj,ak-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gL(aj,ak+20,kb,"pdim txt txtmid")else jO[#jO+1]=gL(aj,ak-jX,ke,"pdim txt txtmid")jO[#jO+1]=gL(aj,ak-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,e0,cV)local kh=ap;local ki=aq;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=ca;if ca~=-1 then jO[#jO+1]=gL(kh+kj,ki+kk+20,dh("AGL: %.1fm",ca),"pdim altsm txtend")end;if cV and(e0<200000 and not cb or e0 and cb)then table.insert(jO,dh([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gt=0;local km=1;local kn=0;local ko=e0<0;local kp=e0<kq.surfaceMaxAltitude;local kr=9;if ko then kr=0 end;local e0=eW(e0)while gt<6 do local ks=11;local kt=16;local ku=9;local kv=14;local jI="altsm"if gt>2 then kt=kt+3;ks=ks+2;kv=kv+2;ku=ku-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kw=e0/km%10;local kx=bJ(kw)local ky=bJ((kx+1)%10)local kz=kn;if gt==0 then kz=kw-kx;if ko then kz=1-kz end end;if ko and(gt==0 or kn~=0)then local gw=ky;ky=kx;kx=gw end;local kA=kt*(kz-1)local kB=kA+kt;local hs=kh+ku+(6-gt)*ks;local ht=ki+kv;jO[#jO+1]=gL(hs,ht+kA,ky,jI)jO[#jO+1]=gL(hs,ht+kB,kx,jI)gt=gt+1;km=km*10;if kx==kr then kn=kz else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kC(fr)local kD=-math.deg(eR(fr.y,fr.z))+180;kD=kD-90;if kD<0 then kD=360+kD end;if kD>180 then kD=-180+kD-180 end;return-kD end;local function kE(fr)local k1=math.deg(eR(fr.y,fr.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kF(jO,fr,fm,aj,ak)if fm>5 and not cb or fm>iO then local jX=ac;local kG=20;local kH=20;local kI=kC(fr)local kJ=kE(fr)local kK=14;local kL=kK/2;local kM=-kJ/kH*jX;local kN=kI/kG*jX;local hs=aj+kM;local ht=ak+kN;local c6=dk(kM^2+kN^2)local kO=[[<circle
                            cx="]]..hs..[["
                            cy="]]..ht..[["
                            r="]]..kL/kK..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hs..[["
                            cy="]]..ht..[["
                            r="]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hs-kK..[[,]]..ht..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hs+kL..[[,]]..ht..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hs..[[,]]..ht-kK..[[ v ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c6<jX then jO[#jO+1]=kO else local jP=eR(kN,kM)local kP=4;local kQ=aj+jX*math.cos(jP)local kR=ak+jX*math.sin(jP)jO[#jO+1]=dh('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kQ,kR,kQ-kP,kR-kP/2,kP*2,kP,kQ+kP,kR-kP,kP,kP,-kP,kP)end;if not cb then local kS=vec3(fr)kI=kC(-kS)kJ=kE(-kS)kM=-kJ/kH*jX;kN=kI/kG*jX;hs=aj+kM;ht=ak+kN;c6=dk(kM^2+kN^2)if c6<jX then local kT=[[<circle
                                    cx="]]..hs..[["
                                    cy="]]..ht..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hs..[[,]]..ht-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hs..[[,]]..ht..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hs..[[,]]..ht..[[)" />
                                <path
                                    d="M ]]..hs-kL..[[,]]..ht..[[ h ]]..kK..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hs..[[,]]..ht..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hs..[[,]]..ht..[[)"/>]]jO[#jO+1]=kT end end end end;local function kU(jO,j6,kV,kW)if al==0 and am==0 then return end;kV=bJ(kV+0.5)local jx=am+10;local jy=am+20;if iu()==1 and not l then jx=55;jy=65 end;local kX="CRUISE"local c="km/h"local dJ=kW;if j6=="TRAVEL"or j6=="AUTOPILOT"then kX="THROT"c="%"dJ=kV;local kY="dim"if kV<0 then kY="red"end;jO[#jO+1]=dh([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kY,al-7,am-50,al,am-50,al,am+50,al-7,am+50,1-eW(kV),al-10,am+50,al-15,am+53,al-15,am+47)end;jO[#jO+1]=gL(al+10,jx,kX,"pbright txtstart")jO[#jO+1]=gL(al+10,jy,dh("%.0f %s",dJ,c),"pbright txtstart")if cb and t and cO and bP then kV=bJ(bQ*100+0.5)local kY="red"if kV<0 then kY="red"end;jO[#jO+1]=dh([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kY,1-eW(kV),al-10,am+50,al-15,am+53,al-15,am+47)jO[#jO+1]=gL(al+10,jx+40,"LIMIT","pbright txtstart")jO[#jO+1]=gL(al+10,jy+40,kV.."%","pbright txtstart")end;if cb and t or b7 then jO[#jO+1]=gL(al+10,jx-40,"LIMIT: "..cy.." km/h","dim txtstart")elseif not cb and b2 then jO[#jO+1]=gL(al+10,jx-40,"LIMIT: "..bJ(a9*3.6+0.5).." km/h","dim txtstart")end end;local function kZ(jO,k_)if al==0 and am==0 then return end;local l0=am-10;local l1=al+10;jO[#jO+1]=gL(0,0,"","pdim txt txtend")if iu()==1 and not l then l0=75 end;jO[#jO+1]=gL(l1,l0,bJ(k_).." km/h","pbright txtbig txtstart")end;local function l2(jO)jO[#jO+1]=gL(j2(150),j3(1070),dh("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gL(j2(960),j3(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gL(j2(960),j3(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gL(j2(960),j3(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l3=j2(960)local l4=j3(860)local l5=j3(880)local l6=j3(900)local l7=j3(960)local l8=j3(200)local l9=j3(250)local la=j3(960)if iu()==1 and not l then l4=j3(135)l5=j3(155)l6=j3(175)l8=j3(115)l9=j3(95)end;local lb="#222222"local lc="white"local ld="dimmer"local le="pbright"local lf="#110000"local lg=lb;local lh=ld;if a_ then local li=""if type(a_)=="string"then li="-"..a_ end;jO[#jO+1]=gL(l3,l4,"Brake Engaged"..li,"warnings")lf="#440000"lg=lc;lh=le elseif bO>0 then jO[#jO+1]=gL(l3,l4,"Auto-Brake Engaged","warnings","opacity:"..bO)end;local lj="#110000"local lk=lb;local ll=ld;if cb and cx and ca==-1 then if not b2 and not bp and not b5 and not cN and not b8 and not b6 then jO[#jO+1]=gL(l3,l8+50,"** STALL WARNING **","warnings")lj="#ff0000"lk=lc;ll=le;fR("stall","SW",2)end end;if cU then jO[#jO+1]=gL(l3,l8+90,"Flight Assist in Progress","warnings")end;if cf then jO[#jO+1]=gL(l3,la,"Gyro Enabled","warnings")end;local lm="#111100"local ln=lb;local lo=ld;if bl then lm="#775500"ln=lc;lo=le;if bS then jO[#jO+1]=gL(l3,l5,"Gear Extended","warn")else jO[#jO+1]=gL(l3,l5,"Landed (G: Takeoff)","warnings")end end;if ca>-1 and(not cN or cd<100)then local lp=iz(d:getTargetGroundAltitude())jO[#jO+1]=gL(l3,l6,"Hover Height: "..lp,"warn")end;local lq="#000011"local lr=lb;local ls=ld;if c0 then lq="#0000DD"lr=lc;ls=le;jO[#jO+1]=gL(l3,l7+20,"ROCKET BOOST ENABLED","warn")end;local lt="#001100"local lu=lb;local lv=ld;if antigrav and not q and cN and bu~=nil then lt="#00DD00"lu=lc;lv=le;local lw="warnings"if eW(cd-antigrav.getBaseAltitude())<501 then lw="warn"end;jO[#jO+1]=gL(l3,l8+40,dh("Target Altitude: %d Singularity Altitude: %d",bJ(bu),bJ(antigrav.getBaseAltitude())),lw)end;if b2 and bi~="None"then jO[#jO+1]=gL(l3,l8,"Autopilot "..bf,"warn")elseif bs~=nil then jO[#jO+1]=gL(l3,l8+20,dh("LockedPitch: %d",bJ(bs)),"warn")elseif bX then jO[#jO+1]=gL(l3,l8+20,"Follow Mode Engaged","warn")elseif b7 or c9 then jO[#jO+1]=gL(l3,l8+20,"Re-entry in Progress","warn")end;if b4 or b8 then local lp=iz(b9,2)if b8 then if cN then lp=iz(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gL(l3,l8,"VTO to "..lp,"warn")elseif b6 and not by then if c8 then jO[#jO+1]=gL(l3,l8,"Takeoff to "..bi,"warn")else jO[#jO+1]=gL(l3,l8,"Takeoff to "..lp,"warn")end;if a_ and not b8 then jO[#jO+1]=gL(l3,l8+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gL(l3,l8,"Altitude Hold: "..dh("%.1fm",b9),"warn")end end;if b8 and(antigrav~=nil and antigrav)then if cc>0.1 then jO[#jO+1]=gL(l3,l8+20,"Beginning ascent","warn")elseif cc<0.09 and cc>0.05 then jO[#jO+1]=gL(l3,l8+20,"Aligning trajectory","warn")elseif cc<0.05 then jO[#jO+1]=gL(l3,l8+20,"Leaving atmosphere","warn")end end;if by then if cz~=nil then jO[#jO+1]=gL(l3,l8,cz,"warn")end end;if b5 then if lx then local ly="Brake Landing"if d9 then ly=ly.."-Aligning"end;if d8 then ly=ly.."-Drift Limited"end;jO[#jO+1]=gL(l3,l8,ly,"warnings")else jO[#jO+1]=gL(l3,l8,"Coast-Landing","warnings")end end;if b1 then jO[#jO+1]=gL(l3,l8,"Prograde Alignment","crit")end;if b0 then jO[#jO+1]=gL(l3,l8,"Retrograde Alignment","crit")end;local lz="#110000"local lA=lb;local lB=ld;if cW then lz="#FF0000"lA=lc;lB=le;local type;if string.find(cW,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gL(l3,l9+20,cW,type)elseif cc==0 then local lC,lD=cq.checkLOS(cH:normalize())if lD~=nil then lB=le;lz="#FF0000"lA=lc;local lp=iz(lD)local lE=cm.computeTravelTime(cI,0,lD)local lF="Collision"if lC.noAtmosphericDensityAltitude>0 then lF="Atmosphere"end;jO[#jO+1]=gL(l3,l9+20,lC.name.." "..lF.." "..iA(lE).." In "..lp,"crit")end end;if bp and not by then jO[#jO+1]=gL(l3,l8+60,lG,"warn")end;local lH="#111100"local lI=lb;local lJ=ld;if c_ and#c_>1 then lH="#DDDD00"lI=lc;lJ=le end;local lK=j2;local lL=j3;local ld="topButton"local lM="topButtonActive"local lN=ld;if b2 or bp or c8 or by then lN=lM end;local lO=ld;if b1 then lO=lM end;local lP=ld;if b5 or bl then lP=lM end;local lQ=ld;if b4 or bp then lQ=lM end;local lR=ld;if b0 then lR=lM end;local lS=ld;if by or cB and b2 then lS=lM end;if w and I then local lT=lL(30)jO[#jO+1]=dh([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lN,lK(960),lL(54),lL(-53),lK(-120),lK(25),lL(50))jO[#jO+1]=gL(lK(910),lT,"AUTOPILOT")jO[#jO+1]=dh([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lK(865),lL(51),lK(-25),lL(-50),lK(-110),lK(25),lL(46))jO[#jO+1]=gL(lK(800),lT,"PROGRADE")jO[#jO+1]=dh([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lP,lK(755),lL(47),lK(-25),lL(-46),lK(-98),lK(44),lL(44))jO[#jO+1]=gL(lK(700),lT,"LAND")jO[#jO+1]=dh([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lK(960),lL(54),lL(-53),lK(120),lK(-25),lL(50))jO[#jO+1]=gL(lK(1010),lT,"ALT HOLD")jO[#jO+1]=dh([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lK(1055),lL(51),lK(25),lL(-50),lK(110),lK(-25),lL(46))jO[#jO+1]=gL(lK(1122),lT,"RETROGRADE")jO[#jO+1]=dh([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lS,lK(1165),lL(47),lK(25),lL(-46),lK(98),lK(-44),lL(44))jO[#jO+1]=gL(lK(1220),lT,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lU(fm)return bJ(fS(fm*3.6,0)+0.5).." km/h"end;local function lV(gt)local gv=bi;if gt~=nil and type(gt)=="number"then if gt==0 then return"None"end;gv=cR[gt].name end;if gv==nil then gv=g2.name end;if gv==nil then gv="None"end;return gv end;local function lW(jO)local lX=cq.routeWP(true)if not lX or#lX==0 then return end;local hs=j2(750)local ht=j3(360)if b2 or bp then jO[#jO+1]=gL(hs,ht,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gL(hs,ht,"LOADED ROUTE","pdim txtstart size20")end;for dI,K in pairs(lX)do ht=ht+20;jO[#jO+1]=gL(hs,ht,dI..". "..lX[dI],"pdim txtstart size20")end end;local function lY(jO)local hs=az+10;local ht=aA+20;local lZ={}local l_={"Alt-4: AutoTakeoff to Target"}local m0={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m1={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local m2={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lZ,"--------------DYNAMIC-----------------")if cb then if ca~=-1 then ix(lZ,l_)if c3 and kq and c3.name==kq.name then table.insert(lZ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aZ then if antigrav then if cN then table.insert(lZ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lZ,"Turn on AGG to takeoff to AGG Height")end end;if aZ then table.insert(lZ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lZ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lZ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bl then table.insert(lZ,"G: Takeoff to hover height, raise gear")else table.insert(lZ,"G: Lowergear and Land")end else ix(lZ,m0)table.insert(lZ,"G: Begin BrakeLanding or Land")end;if b8 then table.insert(lZ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ix(lZ,m1)if shield then table.insert(lZ,"Alt-Shift-6: Vent shields")if not G then table.insert(lZ,"Alt-Shift-7: Toggle shield off/on")end end end;if g2~=nil then table.insert(lZ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lZ,"Alt-9: Activate Gyroscope")end;if aV~="none"or aU~="none"or aW~="none"then table.insert(lZ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b4 then table.insert(lZ,"Alt-Spacebar/C will raise/lower target height")table.insert(lZ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not cb then table.insert(lZ,"LALT+Mousewheel will lower/raise speed limit")end;ix(lZ,m2)for K=1,#lZ do ht=ht+12;jO[#jO+1]=gL(hs,ht,lZ[K],"pdim txtbig txtstart")end end;local function m3(jO)local m4=az;local m5=aA;local m6=ay;local m7=4;local m8=15;local hs=0;local ht=0;local m9,ma,mb,mc;local md;local function me(type)local gF,bM,fm,mf,jI,mg;if type=="Periapsis"then gF=md.periapsis.altitude;bM=md.timeToPeriapsis;fm=md.periapsis.speed;jI="txtend"mf=12;mg=math.min(hs,m4+m6-kq.radius/mb-m7*2)else gF=md.apoapsis.altitude;bM=md.timeToApoapsis;fm=md.apoapsis.speed;mf=-12;jI="txtstart"mg=hs end;if cI<1 then bM=0 end;jO[#jO+1]=dh([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg+mf,ht-5,hs,ht-5)jO[#jO+1]=dh([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg-mf*4,ht+2,hs,ht+2)jO[#jO+1]=gL(mg,ht,type,jI)hs=mg-mf*2;ht=ht+m8;local lp=iz(gF)jO[#jO+1]=gL(hs,ht,lp,jI)ht=ht+m8;jO[#jO+1]=gL(hs,ht,iA(bM),jI)ht=ht+m8;jO[#jO+1]=gL(hs,ht,lU(fm),jI)end;local mh=m6*1.5;if bG=="INFO"then mh=25*10 end;if bG~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=dh('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m6*2,mh,m4,m5)jO[#jO+1]=dh([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m6*2,mh,m4,m5)end;local mi=m6*1.5;local mj=m6*2;local mk=mi/2;local ml=m6;local mm=m4+ml;local mn=m5+mk;local mo=m4+mj;local mp=m5+mi;if bG=="ORBIT"then m5=m5+m7;m9=m6/2;mc=0;md={}md.periapsis={}md.apoapsis={}if fq~=nil then if fq.periapsis~=nil then md.periapsis.altitude=fq.periapsis.altitude;md.periapsis.speed=fq.periapsis.speed end;if fq.apoapsis~=nil then md.apoapsis.altitude=fq.apoapsis.altitude;md.apoapsis.speed=fq.apoapsis.speed end;md.period=fq.period;md.eccentricity=fq.eccentricity;md.timeToApoapsis=fq.timeToApoapsis;md.timeToPeriapsis=fq.timeToPeriapsis;md.eccentricAnomaly=fq.eccentricAnomaly;md.trueAnomaly=fq.trueAnomaly end;if md.periapsis==nil then md.periapsis={}md.periapsis.altitude=-kq.radius;md.periapsis.speed=a9 end;if md.eccentricity==nil then md.eccentricity=1 end;if md.apoapsis==nil then md.apoapsis={}md.apoapsis.altitude=cd;md.apoapsis.speed=0 end;if cI<1 then md.apoapsis.altitude=cd;md.apoapsis.speed=0 end;if md.apoapsis.altitude then mb=(md.apoapsis.altitude+md.periapsis.altitude+kq.radius*2)/(m9*2)ma=(kq.radius+md.apoapsis.altitude)/mb*(1-md.eccentricity)mc=m9-md.periapsis.altitude/mb-kq.radius/mb;local mq=math.pi;if md.period~=nil and md.period>0 and md.timeToApoapsis~=nil then mq=md.eccentricAnomaly;if md.timeToPeriapsis<md.timeToApoapsis then mq=2*math.pi-mq end end;if cI<1 or mq~=mq then mq=math.pi end;local mr=-m9*math.cos(mq)+m4+ml+m7;local ms=ma*math.sin(mq)+m5+mk+m7;local mt=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=dh([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mt,m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)if ma<1 then jO[#jO+1]=dh([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m4+m6+m7-mc,m5+m6*1.5/2+m7,mr,ms)end;jO[#jO+1]=dh('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,(kq.radius+kq.noAtmosphericDensityAltitude)/mb)jO[#jO+1]=dh('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m4+m6+m7-mc,m5+m6*1.5/2+m7,(kq.radius+kq.noAtmosphericDensityAltitude)/mb)jO[#jO+1]=dh([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)jO[#jO+1]=dh('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,kq.radius/mb)jO[#jO+1]='</g>'local mu=math.floor(kq.radius/mb+0.5)hs=m4+m6+m7*4+m9;ht=m5+m6*1.5/2+5+m7;if md.apoapsis~=nil and md.apoapsis.speed<a9 then me("Apoapsis")end;ht=m5+m6*1.5/2+5+m7;hs=m4+m6-m7*2-m9;if md.periapsis~=nil and md.periapsis.speed<a9 and md.periapsis.altitude>0 then me("Periapsis")end;jO[#jO+1]=gL(m4+m6+m7,m5+20+m7,kq.name,"txtorbbig")jO[#jO+1]=dh('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mr,ms)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mv=""local mw=1.2*(mx-my)/(m6*2)local mz=1.4*(mA-mB)/(m6*1.5)for dI,du in pairs(e[0])do if du.center then local hs=m4+m6+du.center.x/mw;local ht=m5+m6*1.5/2+du.center.y/mz;mv=mv..'<circle cx="'..hs..'" cy="'..ht..'" r="'..du.radius/mw*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(du.name,"Moon")and not string.match(du.name,"Sanctuary")and not string.match(du.name,"Space")then mv=mv.."<text x='"..hs.."' y='"..ht+du.radius/mw*30+20 .."' font-size='12' fill="..iV.." text-anchor='middle' font-family='Montserrat'>"..du.name.."</text>"end end end;local fs=vec3(bL.getWorldPosition())local hs=m4+m6+fs.x/mw;local ht=m5+m6*1.5/2+fs.y/mz;mv=mv..'<circle cx="'..hs..'" cy="'..ht..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mv=mv.."<text x='"..hs.."' y='"..ht-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iI=mw;iJ=mz;local mC=fs+cH*1000000;local mD=m4+m6+mC.x/mw;local jy=m5+m6*1.5/2+mC.y/mz;mv=mv..'<line x1="'..hs..'" y1="'..ht..'" x2="'..mD..'" y2="'..jy..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=mv;jO[#jO+1]='</g>'end elseif bG=="INFO"then jO=co.DrawOdometer(jO,iX,bm,iY)elseif bG=="HELP"then jO=lY(jO)elseif bG=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mE=d2;if cc>0 then table.sort(d1,function(ex,ey)local ez,eA=ex.center,ey.center;return(ez.x-cL.x)^2+(ez.y-cL.y)^2+(ez.z-cL.z)^2<(eA.x-cL.x)^2+(eA.y-cL.y)^2+(eA.z-cL.z)^2 end)end;local mF={}local mG={}local mH=120;local mI=nil;local mJ=nil;for K,du in ipairs(d1)do local gT=du.center-cL;local mK=gT:len()local mL=gT:normalize()local mM=gT:cross(cE):normalize()local mN=math.acos(mM:dot(cF))if mN~=mN then mN=0 end;if mM:cross(cF):dot(cE)<0 then mN=-mN end;local mO=gT:project_on_plane(cE):len()local mP=math.sin(mN)*math.asin(mO/mK)*constants.rad2deg;local mQ=math.cos(mN)*math.asin(mO/mK)*constants.rad2deg;if mL:dot(cE)<0 then mQ=90*math.cos(mN)+90*math.cos(mN)-mQ;mP=90*math.sin(mN)+90*math.sin(mN)-mP end;local hs=mm+mP/mE*mi;local ht=mn+mQ/mE*mi;local mR=(hs-mm)*(hs-mm)+(ht-mn)*(ht-mn)local mS=math.asin((du.radius+du.surfaceMaxAltitude)/mK)*constants.rad2deg;if mS~=mS then mS=mE end;local hR=mS/mE*mi;local mT=math.asin(du.atmosphereRadius/mK)*constants.rad2deg;if mT~=mT then mT=mS end;local mU=mT/mE*mi;local c6=iz(mK,1)local mV=du.name;local mW=false;if ht>m5 then if ht>mp then if ht-mU<=mp then mW=true end else mW=true end else if ht+mU>=m5 then mW=true end end;local mX=false;local mY=hs;if du.systemId==0 then mY=hs+mH else mY=hs-mH end;if mY+mH>m4 then if mY+mH>mo then if mY-mU-mH<=mo then mX=true end else mX=true end else if mY+mU+mH>=m4 then mX=true end end;local mZ={}mZ.x=hs;mZ.y=ht;mZ.planet=du;mZ.atmoSize=mU;if not mI or mR<mI then mI=mR;mJ=mZ end;if mX and mW then local m_=math.max(mU,5)if mR<m_*m_ then mV=mV.." - "..c6 end;mZ.size=hR;mZ.i=K;mZ.displayString=mV;mZ.distance=c6;mZ.visible=true;mG[#mG+1]=mZ else mZ.visible=false end end;local n0=false;table.sort(mG,function(ez,eA)return ez.y<eA.y end)for dI,fv in ipairs(mG)do local du,hR,K,mU,hs,ht,mV,c6=fv.planet,fv.size,fv.i,fv.atmoSize,fv.x,fv.y,fv.displayString,fv.distance;local mg,n1,n2,n3;local n4=15;local jI="pdim"if du.systemId~=0 then n2=j2(string.len(mV)*5)n4=-(15+n2)n3=j3(10)jI="pdimfill"else n2=j2(string.len(mV)*9)n3=j3(15)end;if hR*2>n2 then mg=di(hs,m4+n2/2,mo-n2/2)n1=di(ht,m5+n3,mp-5)mg=di(mg,hs-hR+n2/2,hs+hR-n2/2)n1=di(n1,ht-hR+n3,ht+hR)else mg=hs+n4;n1=ht end;for n5,fv in pairs(mF)do local n6=fv.textPositions;local n7=n6.y-n1;if n5~=K and eW(n7)<n6.height and n6.x+n6.width>mg and n6.x<mg+n2 then if hR>n2 then n1=di(n1+n3,m5+15,mp-5)else n1=n6.y+n6.height+1 end end end;local n8=mV~=du.name or mg<=mm and mg+n2>=mm and n1-n3<=mn and n1>=mn;fv.hovered=n8;local n9=1;if n8 then n9=2;if hR*2<n2 then n9=10 end;if mV==du.name then mV=mV.." - "..c6 end;jI="pbright"if du.systemId~=0 then n2=j2(string.len(mV)*5)n4=-(15+n2)else n2=j2(string.len(mV)*7)end;if hR*2>n2 then mg=di(hs,m4+n2/2,mo-n2/2)mg=di(mg,hs-hR+n2/2,hs+hR-n2/2)else mg=hs+n4 end end;mF[K]={}mF[K].textPositions={}mF[K].textPositions.y=n1;mF[K].textPositions.x=mg;mF[K].textPositions.width=n2;mF[K].textPositions.height=n3;mF[K].output=""if hR*2>n2 then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mU-hR>2 then mF[K].output=dh('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hs,ht,mU,iW,0.1*n9)end;mF[K].output=mF[K].output..dh('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hs,ht,hR,iW,0.2*n9)if du.systemId==0 then mF[K].output=mF[K].output..dh([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n1,iV,jI,mV)if hR*2<=n2 then mF[K].output=mF[K].output..dh("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg+n2,n1+2,mg,n1+2,hs,ht)end else mF[K].output=mF[K].output..dh([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n1,iW,jI,mV)if hR*2<=n2 then mF[K].output=mF[K].output..dh("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg,n1+2,mg+n2,n1+2,hs,ht)end end end;for dI=#d1,1,-1 do if mF[dI]then jO[#jO+1]=mF[dI].output end end;if mJ~=nil and d2<90 and not mJ.hovered then local na=mJ.planet.atmosphereRadius/mJ.atmoSize;local nb=dk(mI)*na;local nc=iz(nb,1)local n2=j2(math.max(string.len(nc)*7,string.len(mJ.planet.name)*7))local n3=j3(12)local mg=di(mJ.x+(mm-mJ.x)/2,m4+n2/2,mo-n2/2)local n1=di(mJ.y+(mn-mJ.y)/2,m5+n3*2,mp-5)jO[#jO+1]=dh("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mJ.x,mJ.y,mm,mn)jO[#jO+1]=dh([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n1,"white",nc)if not mJ.visible then jO[#jO+1]=dh([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n1-n3,"white",mJ.planet.name)end end;if cI>1 then local gT=cH;local mL=gT:normalize()local mO=gT:project_on_plane(cE):len()local mM=gT:cross(cE):normalize()local mN=math.acos(mM:dot(cF))if mN~=mN then mN=0 end;if mM:cross(cF):dot(cE)<0 then mN=-mN end;local mP=math.sin(mN)*math.asin(mO/gT:len())*constants.rad2deg;local mQ=math.cos(mN)*math.asin(mO/gT:len())*constants.rad2deg;if mL:dot(cE)<0 then mQ=90*math.cos(mN)+90*math.cos(mN)-mQ;mP=90*math.sin(mN)+90*math.sin(mN)-mP end;local hs=mm+mP/mE*mi;local ht=mn+mQ/mE*mi;local kK=14;local kL=kK/2;local kO=[[<circle
                                    cx="]]..hs..[["
                                    cy="]]..ht..[["
                                    r="]]..kL/kK..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hs..[["
                                    cy="]]..ht..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hs-kK..[[,]]..ht..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hs+kL..[[,]]..ht..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hs..[[,]]..ht-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kO end;jO[#jO+1]=dh("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm,mn-10,mm,mn+10)jO[#jO+1]=dh("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm-10,mn,mm+10,mn)jO[#jO+1]='</g>'else return jO end end;local function nd(ne,nf)local ng;local nh=(nf-ne):normalize()local ft=(cL-ne):dot(nh)/nh:dot(nh)if ft<=0. then return(cL-ne):len()elseif ft>=(nf-ne):len()then return(cL-nf):len()end;local ni=ne+ft*nh;ng=(ni-cL):len()return ng end;local function nj()local ng;local nk=nil;local nl=nil;local nm=nil;for dI,nn in pairs(e[0])do if nn.hasAtmosphere then local c6=nd(kq.center,nn.center)if nk==nil or c6<nk then nl=nn;nk=c6;nm=kq end;if c3 and c3.hasAtmosphere and c3.name~=kq.name then local eM=nd(c3.center,nn.center)if eM<nk then nl=nn;nk=eM;nm=c3 end end end end;local no=j2(1770)local np=j3(330)if nk then local nq="txttick "local nr=500000;if nk<nl.radius+nr or nk<nm.radius+nr then if cS then nq="txttick red "else nq="txttick orange "end end;ng=iz(nk,2)iN=gL(no,np,"Pipe ("..nm.name.."--"..nl.name.."): "..ng,nq.."pbright txtmid")end end;local function ns(hs,ht,nt,nu,kX)local nv={x=hs,y=ht,width=nt,height=nu,label=kX}iH[kX]=nv;return nv end;local function nw(nx,ny,nt,nu,hs,ht,nz,nA,nB,nC,jI)local nv={enableName=nx,disableName=ny,width=nt,height=nu,x=hs,y=ht,toggleVar=nz,toggleFunction=nA,drawCondition=nB,hovered=false,class=jI}if nC then table.insert(iG,nv)else table.insert(iF,nv)end;return nv end;local function nD(nE)if not iL then nF=false;nG=false;nH=false;w=true;return elseif nE=="handling"then nF=not nF;nG=false;nH=false elseif nE=="hud"then nG=not nG;nF=false;nH=false elseif nE=="physics"then nH=not nH;nF=false;nG=false end;if nH or nG or nF then iM=iy(nE)w=false else iM="none"w=true end end;local function nI()iL=not iL;if iL then iE=iG;bZ="Hold SHIFT to see Settings"d3=w else iE=iF;bZ="Hold SHIFT to see Control Buttons"nD()w=d3 end end;local function nJ()local function nK(du,dI)du.set(not du.get())if du.get()then bZ=dI.." set to true"else bZ=dI.." set to false"end;if dI=="showHud"then d3=du.get()elseif dI=="BrakeToggleDefault"then aY=j end end;local nL=50;local nM=340;local hs=500;local ht=ch/2-400;local nN=0;for dI,du in pairs(iy("boolean"))do if type(du.get())=="boolean"then nw(dI,dI,nM,nL,hs,ht,function()return du.get()end,function()nK(du,dI)end,function()return true end,true)ht=ht+nL+20;if nN==9 then hs=hs+nM+20;ht=ch/2-400;nN=0 else nN=nN+1 end end end;nw("Control View","Control View",nM,nL,10,ch/2-500,function()return true end,nI,function()return true end,true)nw("View Handling Settings",'Hide Handling Settings',nM,nL,10,ch/2-(500-nL),function()return nF end,function()nD("handling")end,function()return true end,true)nw("View Hud Settings",'Hide Hud Settings',nM,nL,10,ch/2-(500-nL*2),function()return nG end,function()nD("hud")end,function()return true end,true)nw("View Physics Settings",'Hide Physics Settings',nM,nL,10,ch/2-(500-nL*3),function()return nH end,function()nD("physics")end,function()return true end,true)end;local function nO()local function gu()local fU=cL;local gv=kq.name..". "..#bo;if cr then gv=cr.GetClosestName(gv)end;return cp.AddNewLocation(gv,fU,false,true)end;local function nP()b3=not b3 end;local function nQ(nR)if nR==1 then b1=not b1;b0=false else b0=not b0;b1=false end;b2=false;b4=false;bX=false;b5=false;bs=nil;b7=false;b6=false end;local function nS(nT,nU)cp.UpdatePosition(nil,nT,nU)end;local function gp()cp.ClearCurrentPosition()end;local function nV(gt)local lX=cq.routeWP(true)if lX and#lX>0 then return"Engage Route: "..lX[1]end;return"Engage Autopilot: "..lV(gt)end;local function nW(gt)local lX=cq.routeWP(true)if lX and#lX>0 then return"Next Route Point: "..lX[1]end;return"Disable Autopilot: "..lV(gt)end;local function nX()if iu()==1 then bX=not bX;if bX then b2=false;b0=false;b1=false;b4=false;b7=false;b5=false;b6=false;nY=bl;bl=false;d.control.retractLandingGears()iv:setTargetGroundAltitude(X)fR("folOn","F")else fR("folOff","F")a_="Follow Off"cw=p;bl=nY;if bl then d.control.deployLandingGears()iv:setTargetGroundAltitude(Y)end end else bZ="Follow Mode only works with Remote controller"bX=false end end;local nL=50;local nM=260;local nZ=j2(30)local n_=az+ay*2+2;local o0=aA+1;nw("+","+",nZ,nZ,n_,o0+nZ+1,function()return false end,function()d2=d2/8 end,function()return bG=="SCOPE"end,nil,"ZoomButton")nw("-","-",nZ,nZ,n_,o0,function()return false end,function()d2=math.min(d2*8,90)end,function()return bG=="SCOPE"end,nil,"ZoomButton")nw("0","0",nZ,nZ,n_,o0+nZ*2+2,function()return false end,function()d2=90 end,function()return bG=="SCOPE"and d2~=90 end,nil,"ZoomButton")local o1=nw("Enable Brake Toggle","Disable Brake Toggle",nM,nL,cg/2-nM/2,ch/2+350,function()return aY end,function()aY=not aY;if aY then bZ="Brakes in Toggle Mode"else bZ="Brakes in Default Mode"end end)nw("Align Prograde","Disable Prograde",nM,nL,cg/2-nM/2-50-o1.width,ch/2-nL+380,function()return b1 end,function()nQ(1)end)nw("Align Retrograde","Disable Retrograde",nM,nL,cg/2-nM/2+o1.width+50,ch/2-nL+380,function()return b0 end,nQ,function()return cc==0 end)o2=nw(nV,nW,600,60,cg/2-600/2,ch/2-60/2-330,function()return b2 or bp or c8 or by end,function()end)local K;local function o3(o4)local gt=cZ+o4;if gt>#cR then gt=gt-#cR-1 end;if gt<0 then gt=#cR+gt end;return gt end;o5={}for K=0,10 do local o6=nw(function(eA)local gt=o3(eA.apExtraIndex)if b2 or bp or c8 or by then return"Redirect: "..lV(gt)end;return nV(gt)end,function(eA)local gt=o3(eA.apExtraIndex)return nW(gt)end,600,60,cg/2-600/2,ch/2-60/2-330+60*K,function(eA)local gt=o3(eA.apExtraIndex)return gt==bk and(b2 or bp or c8 or by)end,function(eA)local gt=o3(eA.apExtraIndex)local o7=bk==gt;bk=gt;cp.UpdateAutopilotTarget()cq.ToggleAutopilot()if not o7 and not(b2 or bp or c8 or by)then cq.ToggleAutopilot()end end,function()return cY and(#cq.routeWP(true)==0 or K==0)end)o6.apExtraIndex=K;o5[K]=o6 end;nw("Save Position","Save Position",200,o2.height,o2.x+o2.width+30,o2.y,function()return false end,gu,function()return bk==0 or g2==nil end)nw("Update Position","Update Position",200,o2.height,o2.x+o2.width+30,o2.y,function()return false end,function()nS(nil)end,function()return bk>0 and g2~=nil end)nw("Save Heading","Clear Heading",200,o2.height,o2.x+o2.width+30,o2.y+o2.height+20,function()return g2.heading~=nil end,function()if g2.heading~=nil then nS(false)else nS(true)end end,function()return bk>0 and g2~=nil end)nw("Save AGG Alt","Clear AGG Alt",200,o2.height,o2.x+o2.width+30,o2.y+o2.height*2+40,function()return g2.agg~=nil end,function()if g2.agg~=nil then nS(nil,false)else nS(nil,true)end end,function()return bk>0 and g2~=nil and antigrav end)nw("Clear Position","Clear Position",200,o2.height,o2.x-200-30,o2.y,function()return true end,gp,function()return bk>0 and g2~=nil end)nw("Save Route","Save Route",200,o2.height,o2.x-200-30,o2.y+o2.height*2+40,function()return false end,function()cq.routeWP(false,false,2)end,function()return#cq.routeWP(true)>0 end)nw("Load Route","Clear Route",200,o2.height,o2.x-200-30,o2.y+o2.height+20,function()return#cq.routeWP(true)>0 end,function()if#cq.routeWP(true)>0 then cq.routeWP(false,true)elseif b2 or bp then bZ="Disable Autopilot before loading route"return else cq.routeWP(false,false,1)end end,function()return true end)nL=60;nM=300;local hs=0;local ht=ch/2-150;nw("Enable Check Damage","Disable Check Damage",nM,nL,hs,ht-nL-20,function()return s end,function()s=not s end)nw("View Settings","View Settings",nM,nL,hs,ht,function()return true end,nI)ht=ht+nL+20;nw("Enable Turn and Burn","Disable Turn and Burn",nM,nL,hs,ht,function()return b3 end,nP)hs=10;ht=ch/2-300;nw("Horizontal Takeoff Mode","Vertical Takeoff Mode",nM,nL,cg/2-nM/2,ht+20,function()return aZ end,function()aZ=not aZ;if aZ then bZ="Vertical Takeoff Mode"else bZ="Horizontal Takeoff Mode"end end,function()return cM end)ht=ht+nL+20;nw("Engage Orbiting","Cancel Orbiting",nM,nL,hs+nM+20,ht,function()return by end,cq.ToggleIntoOrbit,function()return cc==0 and cV end)ht=ch/2-150;nw("Glide Re-Entry","Cancel Glide Re-Entry",nM,nL,hs+nM+20,ht,function()return b7 end,function()c7=1;nQ(1)end,function()return kq.hasAtmosphere and not cb end)ht=ht+nL+20;nw("Parachute Re-Entry","Cancel Parachute Re-Entry",nM,nL,hs+nM+20,ht,function()return b7 end,function()c7=2;nQ(1)end,function()return kq.hasAtmosphere and not cb end)ht=ht+nL+20;nw("Engage Follow Mode","Disable Follow Mode",nM,nL,hs,ht,function()return bX end,nX,function()return iu()==1 end)nw("Enable Repair Arrows","Disable Repair Arrows",nM,nL,hs+nM+20,ht,function()return j0 end,function()j0=not j0;if j0 then bZ="Repair Arrows Enabled"else bZ="Repair Arrows Diabled"end end,function()return iu()==1 end)ht=ht+nL+20;if not q then nw("Enable AGG","Disable AGG",nM,nL,hs,ht,function()return cN end,cq.ToggleAntigrav,function()return antigrav~=nil end)end;nw(function()return dh("Switch IPH Mode - Current: %s",bz)end,function()return dh("IPH Mode: %s",bz)end,nM*2,nL,hs,ht,function()return false end,function()if bz=="All"then bz="Custom Only"elseif bz=="Custom Only"then bz="No Moons"else bz="All"end;bZ="IPH Mode: "..bz end)ht=ht+nL+20;nw(function()return dh("Toggle Control Scheme - Current: %s",g)end,function()return dh("Control Scheme: %s",g)end,nM*2,nL,hs,ht,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bZ="New Control Scheme: "..g end)local o8=j3(20)local o6=ns(0,0,j2(70),o8,"HELP")o6=ns(o6.x+o6.width,o6.y,j2(80),o8,"INFO")o6=ns(o6.x+o6.width,o6.y,j2(70),o8,"ORBIT")o6=ns(o6.x+o6.width,o6.y,j2(70),o8,"SCOPE")ns(o6.x+o6.width,o6.y,j2(70),o8,"HIDE")end;local o9={}local oa=nil;function o9.HUDPrologue(jO)if not cS then iS=ag;iT=ah;iU=ai else iS=ad;iT=ae;iU=af end;iV=[[rgb(]]..bJ(iS+0.6)..","..bJ(iT+0.6)..","..bJ(iU+0.6)..[[)]]iW=[[rgb(]]..bJ(iS*0.8+0.5)..","..bJ(iT*0.8+0.5)..","..bJ(iU*0.8+0.5)..[[)]]local ob=iV;local oc=iW;local od=[[rgb(]]..bJ(iS*0.4+0.5)..","..bJ(iT*0.4+0.5)..","..bJ(iU*0.4+0.5)..[[)]]local oe=iV;local of=iW;local og=od;if j4()and not m then ob=[[rgb(]]..bJ(iS*0.5+0.5)..","..bJ(iT*0.5+0.5)..","..bJ(iU*0.5+0.5)..[[)]]oc=[[rgb(]]..bJ(iS*0.3+0.5)..","..bJ(iT*0.3+0.5)..","..bJ(iU*0.2+0.5)..[[)]]od=[[rgb(]]..bJ(iS*0.2+0.5)..","..bJ(iT*0.2+0.5)..","..bJ(iU*0.2+0.5)..[[)]]end;local lK=j2;local lL=j3;jO[#jO+1]=dh([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],ob,ob,ob,oe,oe,oc,oc,of,of,oc,ob,od,of,ob,ob,od,od,og,od,cg,ch,oc,oc,oc,oc,oc,oe,oc,of,og,of,of,og)if not oa then oa=dh([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lK(630),lL(0),lK(675),lL(45),lK(960),lL(55),lK(1245),lL(45),lK(1290),lL(0),lK(1000),lL(105),lK(1040),lL(59),lK(1250),lL(51),lK(1300),lL(0),lK(1920),lL(0),lK(1920),lL(20),lK(1400),lL(20),lK(1300),lL(105),lK(920),lL(105),lK(880),lL(59),lK(670),lL(51),lK(620),lL(0),lK(0),lL(0),lK(0),lL(20),lK(520),lL(20),lK(620),lL(105),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112))end;if w and I then jO[#jO+1]=oa end;return jO end;function o9.DrawVerticalSpeed(jO,e0)jN(jO,e0)end;function o9.UpdateHud(jO)local kD=cP;local oh=cQ;local jV=oh;local ka=kD;local kV=bJ(c.getThrottle())local k_=cI*3.6;local kW=c.getAxisCommandValue(0)local oi=j2(1770)local oj=j3(310)if t and cO then kW=bN;kV=bN*100 end;local j6=j5()local jW="ROLL"if kV==nil then kV=0 end;if not cV then if cI>5 then kD=kC(cG)oh=kE(cG)else kD=0;oh=0 end;jW="YAW"end;if cT>50000 and not cb then local ok;ok=iz(cT)jO[#jO+1]=gL(oi,oj,"PvP Boundary: "..ok,"pbright txtbig txtmid")end;jO[#jO+1]=iZ;jO[#jO+1]=i5;if iN~=""then jO[#jO+1]=iN end;if j7~=""then jO[#jO+1]=j7 end;if j8~=""then jO[#jO+1]=j8 end;jN(jO,cd)if iu()==0 or l then if not j4()or m then if cV then jU(jO,aj,ak,jV,jW,cV)k9(jO,ka,jV,aj,ak,cV,bJ(kE(cG)),cI)else jU(jO,aj,ak,oh,jW,cV)k9(jO,kD,oh,aj,ak,cV,bJ(oh),cI)end;kg(jO,cd,cV)kF(jO,cG,cI,aj,ak)end end;kU(jO,j6,kV,kW)kZ(jO,k_)l2(jO)m3(jO)if not iL and bY then lW(jO)end;return jO end;function o9.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o9.ExtraData(jO)local ol=j2(1240)local om=j3(55)local on=om+10;local oo;local lK=j2;local lL=j3;local op=0;local j6=j5()if aZ then j6=j6 .."-VERTICAL"end;if E and not b6 and not b5 and cI>20 then j6=j6 .."-COLLISION ON"end;if bB~="Off"then j6="("..bB..")-"..j6 end;if b3 then j6="TB-"..j6 end;if not bA then j6=j6 .."-DeCoupled"end;local oq=lL(99)local os=lL(80)local ot=lL(85)local ou=lL(31)local ov=0;local ow=0;local ox=ce>1000000 and fS(ce/1000000,2).."kT"or fS(ce/1000,2).."T"if cb then op=bt else op=br end;local oy,oz=cm.computeDistanceAndTime(cI,0,ce,0,0,op)if oy<0 then oy=0 end;op=fS(op/(ce*iD),2).."g"local oA=d:maxForceForward()oo=b.getGravityIntensity()if oo>0.1 then ow=ce*oo;ow=fS(ow/(ce*iD),2).."g"ov=0.5*oA/oo;ov=ov>1000000 and fS(ov/1000000,2).."kT"or fS(ov/1000,2).."T"end;oA=fS(oA/(ce*iD),2).."g"local oB=vec3(bL.getWorldAcceleration()):len()/9.80665;oo=b.getGravityIntensity()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if iu()==1 and not l then ol=j2(1120)om=j3(55)on=om+10 elseif cb and I then local oC=j2(770)jO[#jO+1]=gL(lK(895),oq,"ATMO","")jO[#jO+1]=dh([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lK(895),ot,lK(-80))jO[#jO+1]=gL(lK(815),os,dh("%.1f%%",cc*100),"txtstart size20")end;if I then jO[#jO+1]=gL(lK(1025),oq,"GRAVITY","txtstart")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1025),ot,lK(80))jO[#jO+1]=gL(lK(1105),os,dh("%.2fg",oo/9.80665),"size20")jO[#jO+1]=gL(lK(1125),oq,"ACCEL","txtstart")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1125),ot,lK(80))jO[#jO+1]=gL(lK(1205),os,dh("%.2fg",oB),"size20")jO[#jO+1]=gL(lK(695),oq,"BRK TIME","")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(695),ot,lK(-80))jO[#jO+1]=gL(lK(615),os,dh("%s",iA(oz)),"txtstart size20")jO[#jO+1]=gL(lK(635),lL(45),"TRIP","")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(635),lL(31),lK(-90))if lE then jO[#jO+1]=gL(lK(545),lL(26),dh("%s",iA(lE)),"txtstart size20")end;jO[#jO+1]=gL(lK(795),oq,"BRK DIST","")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(795),ot,lK(-80))jO[#jO+1]=gL(lK(715),os,dh("%s",iz(oy)),"txtstart size20")jO[#jO+1]=gL(lK(1285),lL(45),"MASS","txtstart")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1285),lL(31),lK(90))jO[#jO+1]=gL(lK(1375),lL(26),dh("%s",ox),"size20")jO[#jO+1]=gL(lK(1220),oq,"THRUST","txtstart")jO[#jO+1]=dh([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1220),ot,lK(80))jO[#jO+1]=gL(lK(1300),os,dh("%s",oA),"size20")jO[#jO+1]=gL(j2(960),j3(175),j6,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local oD=1-(a4*0.05+a5*0.05)function o9.FuelUsed(oE)local oF;if oE=="atmofueltank"then oF=dh("Atmo Fuel Used: %.1f L",jp[oE]/(4*oD))elseif oE=="spacefueltank"then oF=dh("Space Fuel Used: %.1f L",jp[oE]/(6*oD))else oF=dh("Rocket Fuel Used: %.1f L",jp[oE]/(0.8*oD))end;return oF end;function o9.DrawOdometer(jO,iX,bm,iY)if bG~="INFO"then return jO end;local oo;local ov=0;local ow=0;local op=0;local ox=ce>1000000 and fS(ce/1000000,2).." kTons"or fS(ce/1000,2).." Tons"if cb then op=bt else op=br end;local oy,oz=cm.computeDistanceAndTime(cI,0,ce,0,0,op)op=fS(op/(ce*iD),2).." g"local oA=d:maxForceForward()oo=b.getGravityIntensity()if oo>0.1 then ow=ce*oo;ow=fS(ow/(ce*iD),2).." g"ov=0.5*oA/oo;ov=ov>1000000 and fS(ov/1000000,2).." kTons"or fS(ov/1000,2).." Tons"end;oA=fS(oA/(ce*iD),2).." g"if iu()==0 or l then local oG=j2(az+10)local oH=j3(aA+20)local oI=j2(az+10+ay/1.25)local nu=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gL(oG,oH,dh("BrkTime: %s",iA(oz)))jO[#jO+1]=gL(oI,oH,dh("Trip: %.2f km",iX))jO[#jO+1]=gL(oG,oH+nu,dh("Lifetime: %.2f kSU",bm/200000))jO[#jO+1]=gL(oI,oH+nu,dh("BrkDist: %s",iz(oy)))jO[#jO+1]=gL(oG,oH+nu*2,"Trip Time: "..iA(iY))jO[#jO+1]=gL(oI,oH+nu*2,"Total Time: "..iA(bn))jO[#jO+1]=gL(oG,oH+nu*3,dh("Mass: %s",ox))jO[#jO+1]=gL(oI,oH+nu*3,dh("Max Brake: %s",op))jO[#jO+1]=gL(oG,oH+nu*4,dh("Max Thrust: %s",oA))if oo>0.1 then jO[#jO+1]=gL(oI,oH+nu*4,dh("Max Thrust Mass: %s",ov))jO[#jO+1]=gL(oG,oH+nu*5,dh("Req Thrust: %s",ow))else jO[#jO+1]=gL(oI,oH+nu*4,"Max Mass: n/a")jO[#jO+1]=gL(oG,oH+nu*5,"Req Thrust: n/a")end;jO[#jO+1]=gL(oI,oH+nu*5,co.FuelUsed("atmofueltank"))jO[#jO+1]=gL(oG,oH+nu*6,co.FuelUsed("spacefueltank"))jO[#jO+1]=gL(oI,oH+nu*6,co.FuelUsed("rocketfueltank"))jO[#jO+1]=gL(oG,oH+nu*7,dh("Set Max Speed: %s",bJ(a9*3.6+0.5)))jO[#jO+1]=gL(oI,oH+nu*7,dh("Actual Max Speed: %s",bJ(dc*3.6+0.5)))jO[#jO+1]=gL(oG,oH+nu*8,dh("Friction Burn Speed: %s",bJ(bL.getFrictionBurnSpeed()*3.6)))end;jO[#jO+1]="</g></g>"return jO end;function o9.DrawWarnings(jO)return l2(jO)end;function o9.DisplayOrbitScreen(jO)return m3(jO)end;function o9.DisplayMessage(jO,lp)if lp~="empty"then local ht=310;for ly in string.gmatch(lp,"([^\n]+)")do ht=ht+35;jO[#jO+1]=gL("50%",ht,ly,"msg")end end;if b_~=0 then c.setTimer("msgTick",b_)b_=0 end end;function o9.DrawDeadZone(jO)jO[#jO+1]=dh([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],ax)end;function o9.UpdatePipe()if cb then iN=""return end;nj()end;function o9.DrawSettings(jO)local hs=j2(640)local ht=j3(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hO=0;for dI,du in pairs(iM)do hO=hO+1;jO[#jO+1]=gL(hs,ht,dI..": "..du.get())ht=ht+20;if hO%12==0 then hs=hs+j2(350)ht=j3(200)end end;jO[#jO+1]=gL(j2(640),j3(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local i4=j3(125)local i3=j2(1225)function o9.DrawRadarInfo()i5=cr.GetRadarHud(i3,i4,av,aw)end;function o9.DrawTanks()if ar~=0 and as~=0 then j7=gL(ar,as,"","txtstart pdim txtfuel")jq=as;jr(ar,"Atmospheric ","ATMO",ci,jn,jo)jr(ar,"Space Fuel T","SPACE",cj,jl,jm)jr(ar,"Rocket Fuel ","ROCKET",ck,jj,jk)end end;function o9.DrawShield()local ic=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oJ=bL.getPvPTimer()local oK=shield.getResistances()local oL="A: "..10+oK[1]*100 .."% / E: "..10+oK[2]*100 .."% / K:"..10+oK[3]*100 .."% / T: "..10+oK[4]*100 .."%"local hs,ht=at-60,au+30;local jG=bJ(dd*2.55)local jH=dh("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""j8=gL(hs,ht,"","txtmid pdim txtfuel")if dd<10 and ic~="Shield Disabled"then jI="red "end;oJ=oJ>0 and"   PvPTime: "..iA(oJ)or""j8=j8 ..dh([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hs,ht,jH,dd*2,hs,ht,hs+2,ht+10,dd,oJ)j8=j8 ..gL(hs,ht-5,ic,jI.."txtstart pbright txtbig")j8=j8 ..gL(hs,ht+30,oL,jI.."txtstart pbright txtsmall")end;function o9.hudtick()if not kq then return end;local function oM(jO)local jK=bJ(di(da/(cg/4)*255,0,255))jO[#jO+1]=dh("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c4,c5,bJ(iS+0.5)+jK,bJ(iT+0.5)-jK,bJ(iU+0.5)-jK)end;local function oN()for dN,du in pairs(iE)do if du.hovered then if not du.drawCondition or du.drawCondition(du)then du.toggleFunction(du)end;du.hovered=false end end;for dN,du in pairs(iH)do if du.hovered then bG=du.label;du.hovered=false end end end;local function oO()local function oP(oQ,oR,hs,ht,nt,nu)if oQ>=hs and oQ<=hs+nt and oR>=ht and oR<=ht+nu then return true else return false end end;local hs=c4+cg/2;local ht=c5+ch/2;for dN,du in pairs(iE)do du.hovered=oP(hs,ht,du.x,du.y,du.width,du.height)end;for dN,du in pairs(iH)do du.hovered=oP(hs,ht,du.x,du.y,du.width,du.height)end;if cY then local n8=false;for dN,eA in ipairs(o5)do if eA.hovered then n8=true;break end end;if o2.hovered then n8=true end;cY=n8 else cY=o2.hovered;if not cY then cZ=bk end end end;local function oS(jO)if not bG or bG==""then bG="HELP"end;if w then for dI,du in pairs(iH)do local jI="dim brightstroke"local oT=0.2;if bG==dI then jI="pbright dimstroke"oT=0.6 end;local oU=""if du.hovered then oT=0.8;oU=";stroke:white"end;jO[#jO+1]=dh([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],du.width,du.height,du.x,du.y,jI,oT,oU)jO[#jO+1]=gL(du.x+du.width/2,du.y+du.height/2+5,du.label,"txt txtmid pdim")end end end;local function oV(jO)local function oW(jO,oX,hover,hs,ht,ff,oY,oZ,o_,p0,p1,o6)if type(p0)=="function"then p0=p0(o6)end;if type(p1)=="function"then p1=p1(o6)end;jO[#jO+1]=dh("<rect x='%f' y='%f' width='%f' height='%f' fill='",hs,ht,ff,oY)if oX then jO[#jO+1]=dh("%s'",oZ)else jO[#jO+1]=o_ end;if hover then jO[#jO+1]=dh(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ad,ae,af)else jO[#jO+1]=dh(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fS(ad*0.5,0),fS(ae*0.5,0),fS(af*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=dh("<text x='%f' y='%f' font-size='24' fill='",hs+ff/2,ht+oY/2+5)if oX then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oX then jO[#jO+1]=dh("%s</text>",p0)else jO[#jO+1]=dh("%s</text>",p1)end end;local p2=dh("rgb(%d,%d,%d)'",fS(ad*0.1,0),fS(ae*0.1,0),fS(af*0.1,0))local p3=dh("rgb(%d,%d,%d)",fS(ad*0.8,0),fS(ae*0.8,0),fS(af*0.8,0))local p4=oW;for dN,du in pairs(iE)do local ny=du.disableName;local nx=du.enableName;if type(ny)=="function"then ny=ny(du)end;if type(nx)=="function"then nx=nx(du)end;if not du.drawCondition or du.drawCondition(du)then p4(jO,du.toggleVar(du),du.hovered,du.x,du.y,du.width,du.height,p3,p2,ny,nx,du)end end end;local p5=fS(cg/2,0)local p6=fS(ch/2,0)local jO={}if p7 then jO[#jO+1]=p7 end;co.HUDPrologue(jO)if w then co.UpdateHud(jO)else if A then co.DrawVerticalSpeed(jO,cd)end;co.DrawWarnings(jO)end;if iL and iM~="none"then co.DrawSettings(jO)end;if cr then co.DrawRadarInfo()end;co.HUDEpilogue(jO)jO[#jO+1]=dh([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cg,ch)if bZ~="empty"then co.DisplayMessage(jO,bZ)end;if iu()==0 and g=="virtual joystick"then if v then co.DrawDeadZone(jO)end end;oS(jO)if iw()==0 then if iu()==1 and bY then if not p8 then oO()oV(jO)end;if not cu and not cv then local p9=table.concat(jO,"")jO={}jO[#jO+1]=dh("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cg,ch)jO[#jO+1]=p9;jO[#jO+1]="</body>"cu=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cv then local p9=table.concat(jO,"")jO={}jO[#jO+1]=dh("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cg,ch)jO[#jO+1]=p9;jO[#jO+1]="</body>"end;if not cu then jO[#jO+1]=dh([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,c4,c5)end else oN()end else if not bY and iu()==0 then oN()if da>ax then if v then oM(jO)end end elseif bY and(not p8 or not i)then oO()oV(jO)end;jO[#jO+1]=dh([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p5,p6,c4,c5)end;jO[#jO+1]=[[</svg></body>]]pa=table.concat(jO,"")end;function o9.TenthTick()local function pb()local pc=a.createData;local pd=a.createWidget;pe=a.createWidgetPanel("Interplanetary Helper")pf=pd(pe,"value")pg=pc('{"label": "Target Planet", "value": "N/A", "unit":""}')fQ(pg,pf)ph=pd(pe,"value")pi=pc('{"label": "distance", "value": "N/A", "unit":""}')fQ(pi,ph)gj=pd(pe,"value")gi=pc('{"label": "Travel Time", "value": "N/A", "unit":""}')fQ(gi,gj)gh=pd(pe,"value")gg=pc('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fQ(gg,gh)gl=pd(pe,"value")gk=pc('{"label": "Target Altitude", "value": "N/A", "unit":""}')fQ(gk,gl)gd=pd(pe,"value")gc=pc('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gb=pd(pe,"value")ga=pc('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g9=pd(pe,"value")g8=pc('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g7=pd(pe,"value")g6=pc('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gf=pd(pe,"value")ge=pc('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not cb then fQ(gc,gd)fQ(ga,gb)fQ(g8,g9)fQ(g6,g7)fQ(ge,gf)end end;local function pj()gK(pe)pe=nil end;co.DrawTanks()if shield then co.DrawShield()end;if bi~="None"then if pe==nil then pb()end;if bi~=nil then local mK;local pk=g2~=nil;local pl=0.5*bt/c3:getGravity(c3.center+vec3(0,0,1)*c3.radius):len()pl=pl>1000000 and fS(pl/1000000,2).." kTons"or fS(pl/1000,2).." Tons"fP(pg,'{"label": "Target", "value": "'..bi..'", "unit":""}')if pk and not b2 then mK=(cL-g2.position):len()else mK=(bj-cL):len()end;if not b3 then c1,c2=cq.GetAutopilotBrakeDistanceAndTime(cI)iP,iQ=cq.GetAutopilotBrakeDistanceAndTime(a9)else c1,c2=cq.GetAutopilotTBBrakeDistanceAndTime(cI)iP,iQ=cq.GetAutopilotTBBrakeDistanceAndTime(a9)end;local lp=iz(mK)fP(pi,'{"label": "distance", "value": "'..lp..'"}')fP(gi,'{"label": "Travel Time", "value": "'..iA(lE)..'", "unit":""}')lp=iz(c1)fP(gc,'{"label": "Cur Brake distance", "value": "'..lp..'"}')fP(ga,'{"label": "Cur Brake Time", "value": "'..iA(c2)..'", "unit":""}')lp=iz(iP)fP(g8,'{"label": "Max Brake distance", "value": "'..lp..'"}')fP(g6,'{"label": "Max Brake Time", "value": "'..iA(iQ)..'", "unit":""}')fP(gg,'{"label": "Max Brake Mass", "value": "'..dh("%s",pl)..'", "unit":""}')lp=iz(gm)fP(gk,'{"label": "Target Orbit", "value": "'..lp..'"}')if cb and not pm then a.removeDataFromWidget(g6,g7)a.removeDataFromWidget(g8,g9)a.removeDataFromWidget(ga,gb)a.removeDataFromWidget(gc,gd)a.removeDataFromWidget(ge,gf)pm=true;if not cO and t and(b4 or b7 or c9)then cq.cmdThrottle(1)a_=false;bR=false end end;if not cb and pm then if fP(g6,g7)==1 then fQ(g6,g7)end;if fP(g8,g9)==1 then fQ(g8,g9)end;if fP(ga,gb)==1 then fQ(ga,gb)end;if fP(gc,gd)==1 then fQ(gc,gd)end;if fP(ge,gf)==1 then fQ(ge,gf)end;pm=false end end else pj()end;if warpdrive~=nil then local pn=is(warpdrive.getWidgetData())if pn.destination~="Unknown"and pn.distance>400000 then if not j1 then warpdrive.showWidget()j1=true end elseif j1 then warpdrive.hideWidget()j1=false end end end;function o9.OneSecondTick()local function po()local jB=bI()local k_=cI;local pp=jB-i_;if k_>1.38889 then k_=k_/1000;local pq=k_*(jB-i_)bm=bm+pq;iX=iX+pq end;iY=iY+pp;bn=bn+pp;i_=jB end;local function pr(jO)local ps=0;local pt=iC;local pu=0;local pv=0;local pw=0;local jG=0;local jH=""local px=b.getElementHitPointsById;local py=b.getElementMaxHitPointsById;local pz={}for dI in pairs(iB)do local pA=0;local pB=0;pB=py(iB[dI])pA=px(iB[dI])pu=pu+pA;if pA+1<pB then if pA==0 then pw=pw+1 else pv=pv+1 end;if j0 and#pz==0 then fU=vec3(b.getElementPositionById(iB[dI]))local hs=fU.x;local ht=fU.y;local hu=fU.z;table.insert(pz,b.spawnArrowSticker(hs,ht,hu+1,"down"))table.insert(pz,b.spawnArrowSticker(hs,ht,hu+1,"down"))b.rotateSticker(pz[2],0,0,90)table.insert(pz,b.spawnArrowSticker(hs+1,ht,hu,"north"))table.insert(pz,b.spawnArrowSticker(hs+1,ht,hu,"north"))b.rotateSticker(pz[4],90,90,0)table.insert(pz,b.spawnArrowSticker(hs-1,ht,hu,"south"))table.insert(pz,b.spawnArrowSticker(hs-1,ht,hu,"south"))b.rotateSticker(pz[6],90,-90,0)table.insert(pz,b.spawnArrowSticker(hs,ht-1,hu,"east"))table.insert(pz,b.spawnArrowSticker(hs,ht-1,hu,"east"))b.rotateSticker(pz[8],90,0,90)table.insert(pz,b.spawnArrowSticker(hs,ht+1,hu,"west"))table.insert(pz,b.spawnArrowSticker(hs,ht+1,hu,"west"))b.rotateSticker(pz[10],-90,0,90)table.insert(pz,iB[dI])end elseif j0 and#pz>0 and pz[11]==iB[dI]then for jA in pairs(pz)do b.deleteSticker(pz[jA])end;pz={}end end;ps=fS(pu/pt*100,2)if pw>0 or pv>0 then jO[#jO+1]=gL(0,0,"","pbright txt")jG=bJ(ps*2.55)jH=dh("rgb(%d,%d,%d)",255-jG,jG,0)jO[#jO+1]=gL("50%",1035,"Elemental Integrity: "..ps.."%","txtbig txtmid","fill:"..jH)if pw>0 then jO[#jO+1]=gL("50%",1055,"Disabled Modules: "..pw.." Damaged Modules: "..pv,"txtbig txtmid","fill:"..jH)elseif pv>0 then jO[#jO+1]=gL("50%",1055,"Damaged Modules: "..pv,"txtbig txtmid","fill:"..jH)end end end;local function pC()if ir then if iR==nil and(d5~=nil or bl)then _autoconf.displayCategoryPanel(ir,weapon_size,"Weapons","weapon",true)iR=_autoconf.panels[_autoconf.panels_size]elseif iR~=nil and d5==nil and not bl then gK(iR)iR=nil end end end;c_=bL.getPlayersOnBoard()d0=bL.getDockedConstructs()local jO={}po()if s then pr(jO)end;pC()co.UpdatePipe()co.ExtraData(jO)iZ=table.concat(jO,"")end;function o9.AnimateTick()cv=true;cu=false;c4=0;c5=0;c.stopTimer("animateTick")end;function o9.MsgTick()local jO={}co.DisplayMessage(jO,"empty")bZ="empty"c.stopTimer("msgTick")b_=3 end;function o9.ButtonSetup()nJ()nO()iE=iF end;if pD then for dI,du in pairs(pD)do o9[dI]=du end end;return o9 end;local function pE(d,b,c,e,vBooster,hover,pF,antigrav,warpdrive,dbHud_1,eW,bJ,bK,iu,eR,bI,di,iv,fP,iw,dk,fS,fR,ix,dl,iz,iA,pG,is,dh,fQ)local a=DUSystem;local bL=DUConstruct;local pH={}local pI=false;local pJ=0;local pK=0;local pL=0;local pM=bI()local pN=0;local pO=0;local pP=0;local pQ=0;local pR=false;local pS=false;local pT=false;local pU=nil;local pV=0;local iO=55;local pW=nil;local pX=false;local pY=false;local pZ=false;local p_=0;local q0=0;local q1=0;local q2=0;local q3=0;local q4={VectorToTarget=false}local q5=vec3(bL.getWorldOrientationUp())local q6=nil;local q7=0;local q8=-1;local q9=-1;local qa=false;local qb=false;local qc=0;local qd=false;local qe=false;local qf=false;local qg=false;local qh=""local qi=false;local qj=false;local qk=""local ql=false;local qm=0;local function qn()return bL.isInPvPZone()~=1,eW(bL.getDistanceToSafeZone())end;local function qo(fm)local qp=be;if not b2 then qp=0 end;local qq=br;if cb then if bt and bt>0 then qq=bt else return 0,0 end end;return cm.computeDistanceAndTime(fm,qp,ce,0,0,qq-bg*ce)end;local function qr(fm)local qp=be;if not b2 then qp=0 end;return cm.computeDistanceAndTime(fm,qp,ce,d:maxForceForward(),a0,br-bg*ce)end;local function qs(qt,qu,qv)qu=qu:project_on_plane(qt)qv=qv:project_on_plane(qt)return eR(qu:cross(qv):dot(qt),qu:dot(qv))end;local function qw()local function qx()local qy=-1;local qz=-1;if vBooster then qy=vBooster.getDistance()end;if hover then qz=hover.getDistance()end;if qy~=-1 and qz~=-1 then if qy<qz then return qy else return qz end elseif qy~=-1 then return qy elseif qz~=-1 then return qz else return-1 end end;local qA=qx()local qB=-1;if antigrav and antigrav.isActive()==1 and not q and cI<iO then local qC=eW(cd-antigrav.getBaseAltitude())if qC<50 then return qC end end;if pF then qB=pF.raycast().distance end;if qA~=-1 and qB~=-1 then if qA<qB then return qA else return qB end elseif qA~=-1 then return qA else return qB end end;local function qD(kq,eI,qE)local function qF(qG,dU)local eO=vec3(dU)if qG.id==0 then return setmetatable({latitude=eO.x,longitude=eO.y,altitude=eO.z,id=0,systemId=qG.systemId},dW)end;local eP=eO-qG.center;local c6=eP:len()local e0=c6-qG.radius;local dZ=0;local d_=0;if not dl(c6,0)then local eQ=eR(eP.y,eP.x)d_=eQ>=0 and eQ or 2*math.pi+eQ;dZ=math.pi/2-math.acos(eP.z/c6)end;return setmetatable({latitude=math.deg(dZ),longitude=math.deg(d_),altitude=e0,id=qG.id,systemId=qG.systemId},dW)end;local qH=qF(kq,eI)qH="::pos{"..qH.systemId..","..qH.id..","..qH.latitude..","..qH.longitude..","..qH.altitude.."}"if qE then return qH else qf=qH;return true end end;local function qI(qJ,qK,qL)local function qM(qJ,er)qJ=vec3(qJ)er=vec3(er):normalize()local dD=qJ*er;return dD.x+dD.y+dD.z end;local qN=0.001;local qO=1;if not cb or not cx or ca~=-1 or cI<iO then if qL==nil then qL=aR end;if qK==nil then qK=qN end;qJ=vec3(qJ):normalize()local qP=vec3()-qJ;local qQ=-qM(qP,bL.getWorldOrientationRight())*qO;local qR=-qM(qP,bL.getWorldOrientationUp())*qO;if pK==0 then pK=qQ/2 end;if pL==0 then pL=qR/2 end;if eW(qQ)<0.1 then q0=q0-qQ*2 else q0=q0-(qQ+(qQ-pK)*qL)end;if eW(qR)<0.1 then p_=p_+qR*2 else p_=p_+qR+(qR-pL)*qL end;pK=qQ;pL=qR;if eW(qQ)<qK and eW(qR)<qK then return true end;return false elseif cx and ca==-1 then qJ=cH;if qL==nil then qL=aR end;if qK==nil then qK=qN end;qJ=vec3(qJ):normalize()local qP=cE-qJ;local qQ=-qM(qP,bL.getWorldOrientationRight())*qO;local qR=-qM(qP,bL.getWorldOrientationUp())*qO;if pK==0 then pK=qQ/2 end;if pL==0 then pL=qR/2 end;if eW(qQ)<0.1 then q0=q0-qQ*5 else q0=q0-(qQ+(qQ-pK)*qL)end;if eW(qR)<0.1 then p_=p_+qR*5 else p_=p_+qR+(qR-pL)*qL end;pK=qQ;pL=qR;if eW(qQ)<qK and eW(qR)<qK then return true end;return false end end;function pH.clearAll()ba=false;bc=false;bd=false;b2=false;bb=false;bf="Aligning"b0=false;b1=false;cU=nil;b4=false;b7=false;b5=false;b6=false;b8=false;bX=false;pY=false;c7=false;c8=false;pZ=false;cw=p;bp=false;b3=false;cf=false;bs=nil;by=false;d8=false;d9=nil end;function pH.GetAutopilotBrakeDistanceAndTime(fm)return qo(fm)end;function pH.GetAutopilotTBBrakeDistanceAndTime(fm)return qr(fm)end;function pH.showWayPoint(kq,eI,qE)return qD(kq,eI,qE)end;function pH.APTick()local qS=a.getMouseWheel()if qS>0 then cq.changeSpd()elseif qS<0 then cq.changeSpd(true)else pX=true end;qc=iw()if qf then a.setWaypoint(qf)qf=false end;if qi then antigrav.setTargetAltitude(qi)qi=false end;if qg then fP(qg,qh)qg=false;qh=""end;if q9~=-1 then cq.cmdCruise(q9,qa)qa=false;q9=-1 end;if q6~=nil then if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iv:getTargetSpeed(axisCommandId.longitudinal)~=q6 then iv:setTargetSpeedCommand(axisCommandId.longitudinal,q6)else q6=nil end end;if q8~=-1 then cq.cmdThrottle(q8,qa)qa=false;q8=-1 end;if qb then cs.landingGear()qb=false end;if qj then cq.ToggleAutopilot()end end;function pH.ToggleIntoOrbit()cB=false;pP=nil;pQ=nil;pV=0;if not cb then if by then fR("orOff","AP")by=false;pR=false;pU=nil;cw=p;if b4 then b4=false;b6=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false elseif cV then fR("orOn","AP")by=true;cw=true;if pU==nil then pU=kq end;if b4 then b4=false;b6=false end else bZ="Unable to engage auto-orbit, not near a planet"end else by=false;pR=false;pU=nil;cw=p;if b4 then b4=false end;q4.VectorToTarget=false;q4.AutopilotAlign=false;pT=false end end;function pH.ToggleVerticalTakeoff()b4=false;if b8 then lx=true;b7=false;b6=false;b5=true;cw=true;bW=0;if cb and ca==-1 then b5=false;b4=true;bW=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)q9=bJ(cy)end else cB=false;bl=false;d.control.retractLandingGears()iv:setTargetGroundAltitude(X)a_="VTO Takeoff"end;b8=not b8 end;function pH.checkLOS(qJ)local lC,eG,eH=cl:getPlanetarySystem(0):castIntersections(cL,qJ,function(ep)if ep.noAtmosphericDensityAltitude>0 then return ep.radius+ep.noAtmosphericDensityAltitude else return ep.radius+ep.surfaceMaxAltitude*1.5 end end)local lD=eG;if eH~=nil and eG~=nil then lD=math.min(eH,eG)end;if lD~=nil then return lC,lD else return nil,nil end end;function pH.ToggleAutopilot()local function qT(bw)cW=false;bp=not bp;if bp then b3=false;if not b4 and not bw then cq.ToggleAltitudeHold()end end;lG="Proceeding to Waypoint"end;local function qU(gv)if gv then for K,dI in pairs(cR)do if dI.name and dI.name==gv then return K end end else return 0 end end;local qV=false;if bM-pO<1.5 and cb then if not cD then if cb then b9=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude;fR("11","EP")pO=-1;if b2 or bp or by then return end else bZ="No space engines detected, Orbital Hop not supported"return end elseif kq.hasAtmosphere then if cb then b9=kq.noAtmosphericDensityAltitude+T;fR("orH","OH")end;pO=-1;if b2 or bp or by then return end end else pO=bM end;qW=false;if(bk>0 or#bE>0)and not b2 and not bp and not c8 and not by then if 0.5*d:maxForceForward()/b.getGravityIntensity()<ce then bZ="WARNING: Heavy Loads may affect autopilot performance."b_=5 end;if#bE>0 and not c9 then bk=qU(bE[1])cp.UpdateAutopilotTarget()bZ="Route Autopilot in Progress"local qP=g2.position-cL;local qX=qP:project_on_plane(cJ):len()if qX>50000 and g2.planetname==kq.name then qV=true end end;cp.UpdateAutopilotTarget()cq.showWayPoint(c3,bj)if g2~=nil then if g2.agg and not q and antigrav then if not cN then cq.ToggleAntigrav()end;bu=g2.agg end;bs=nil;bw=g2.planetname=="Space"if bw then fR("apSpc","AP")if cb then c8=true;cq.ToggleAltitudeHold()else b2=true end elseif kq.name==g2.planetname then lx=true;if cb then if not bp then fR("vtt","AP")qT(bw)if qV then b9=kq.noAtmosphericDensityAltitude+T end end else fR("apOn","AP")if not(c3.name==kq.name and cd<gm*1.5)then cB=false;b2=true elseif not cb then if by then cq.ToggleIntoOrbit()end;cA=kq.noAtmosphericDensityAltitude+T;pT=true;q4.AutopilotAlign=true;q4.VectorToTarget=true;pR=false;if not by then cq.ToggleIntoOrbit()end end end else fR("apP","AP")b0=false;b1=false;if cb then c8=true;cq.ToggleAltitudeHold()else b2=true end end elseif not cb then if g2==nil and(c3.name==kq.name and cV)and not by then qY=false;cB=false;pR=false;cq.ToggleIntoOrbit()else fR("apP","AP")b2=true;b0=false;b1=false;bb=false;bX=false;b4=false;b5=false;b7=false;b6=false;pY=false;bs=nil;qY=false end else fR("apP","AP")c8=true;cq.ToggleAltitudeHold()end;qj=false else fR("apOff","AP")cq.ResetAutopilots(1)if qj==2 then qj=true end end end;function pH.routeWP(qZ,q_,r0)if r0 then if r0==1 then bE={}bE=ix(bE,bD)if#bE>0 then bZ="Route Loaded"else bZ="No Saved Route found on Databank"end;return bE else bD={}bD=ix(bD,bE)bZ="Route Saved"pG()return end end;if qZ then return bE end;if q_ then bE={}bZ="Current Route Cleared"else bE[#bE+1]=g2.name;bZ="Added "..g2.name.." to route. "end;return bE end;function pH.cmdThrottle(dJ,r1)if iv:getAxisCommandType(0)~=axisCommandType.byThrottle and not r1 then d.control.cancelCurrentControlMasterMode()end;iv:setThrottleCommand(axisCommandId.longitudinal,dJ)bN=di(fS(dJ*100,0)/100,-1,1)q6=nil end;function pH.cmdCruise(dJ,r1)if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r1 then d.control.cancelCurrentControlMasterMode()end;iv:setTargetSpeedCommand(axisCommandId.longitudinal,dJ)q6=dJ end;function pH.ToggleLockPitch()if bs==nil then fR("lkPOn","LP")if not bY then bs=cP else bs=Q end;b6=false;b4=false;b5=false else fR("lkPOff","LP")bs=nil end end;function pH.ToggleAltitudeHold()if bM-pN<1.5 then if kq.hasAtmosphere then if cb then b9=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude;fR("11","EP")else if cV then b9=kq.noAtmosphericDensityAltitude+T;cA=b9;pT=true;if not by then cq.ToggleIntoOrbit()end;pR=true end end;pN=-1;if b4 or by or b8 then return end end else pN=bM end;if cV and not cb then cA=cd;pT=true;pR=true;cq.ToggleIntoOrbit()if by then pN=bM else pN=0 end;return end;b4=not b4;b5=false;b7=false;if b4 then b2=false;b1=false;b0=false;bX=false;cw=true;bs=nil;cB=false;if ca~=-1 and cI<20 then if bl then cs.landingGear()end;fR("lfs","LS")b6=true;if pN>-1 then b9=cd+W end;a_="ATO Hold"iv:setTargetGroundAltitude(X)if aZ and cM then cq.ToggleVerticalTakeoff()end else fR("altOn","AH")b6=false;if pN>-1 then if cV then b9=cd end end;if b8 then cq.ToggleVerticalTakeoff()end end;if cN and not q then local r2=antigrav.getBaseAltitude()if bp and g2.agg and g2.agg>cd then b9=g2.agg elseif b6 then b9=r2 end;if eW(cd-r2)<100 and cI<20 then b9=r2;a_="AGG Hold"q8=0 end end;if c8 then b9=200000 end else fR("altOff","AH")if by then cq.ToggleIntoOrbit()end;if b8 then cq.ToggleVerticalTakeoff()end;cw=p;b6=false;bp=false;pN=0 end end;function pH.ResetAutopilots(pH)if pH then c8=false;b2=false;bb=false;pY=false;b9=cd;qW=false;d8=false;bf="Aligning"end;bp=false;b6=false;b7=false;b1=false;b5=false;d9=nil;r3=false;cU=nil;d8=false;if not cN then b4=false;bs=nil end;if b8 then cq.ToggleVerticalTakeoff()end;if by then cq.ToggleIntoOrbit()end;cw=p;c7=false;c9=false;bW=0 end;function pH.BrakeToggle(r4)if not a_ then if r4 then a_=r4 else a_=true end else a_=false end;if b5 then b5=false;cw=p;d8=false end;if a_ then fR("bkOn","B",1)cq.ResetAutopilots()else fR("bkOff","B",1)end end;function pH.BeginReentry()if b7 then bZ="Re-Entry cancelled"fR("reOff","RE")b7=false;cw=p;b4=false elseif not kq.hasAtmosphere then bZ="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"b_=5 elseif not pZ then b7=true;if iv:getAxisCommandType(0)~=r5.cruise then d.control.cancelCurrentControlMasterMode()end;cw=true;a_=false;bZ="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cy;fR("par","RE")else b7=true;b4=true;cw=true;a_=false;b9=kq.surfaceMaxAltitude+Z;if b9>kq.spaceEngineMinAltitude then b9=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude end;local r6=iz(b9)bZ="Beginning Re-entry.  Target speed: "..cy.." Target Altitude: "..r6;fR("glide","RE")q9=bJ(cy)end;b6=false end;function pH.ToggleAntigrav()if antigrav and not q then if cN then fR("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bu==nil then bu=cd end;if bu<1000 then bu=1000 end;fR("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pH.changeSpd(r7)local r8=1;if r7 then r8=-1 end;if not bY then if t and not p8 and pX then local r9=bN;bN=fS(di(bN+r8*aD/100,-1,1),2)if bN>=0 and r9<0 then bN=0;pX=false end elseif p8 then if cb or b7 then cy=di(cy+r8*aD,0,U)elseif b2 then a9=di(a9+r8*aD/3.6*100,0,dc-0.2)end else iv:updateCommandFromActionStart(axisCommandId.longitudinal,r8*aD/10)end else if b2 or bp or c8 or by then cZ=cZ+1*r8*-1;if cZ>#cR then cZ=1 end;if cZ<1 then cZ=#cR end else if not r7 then r8=1 else r8=nil end;cp.adjustAutopilotTargetIndex(r8)end end end;function pH.TenthTick()local function ra()if not b2 then if g2==nil or g2.planetname~=kq.name then rb=(c3.center-cL):len()else rb=(g2.position-cL):len()end end;local fm=cI;local rc=c.getThrottle()/100;if t then rc=bN end;local rd,re=cm.computeDistanceAndTime(cI,a9,ce,d:maxForceForward()*rc,a0,0)local c1,c2;if not b3 then c1,c2=cq.GetAutopilotBrakeDistanceAndTime(a9)else c1,c2=cq.GetAutopilotTBBrakeDistanceAndTime(a9)end;local dN,rf;if not b3 and fm>0 then dN,rf=cq.GetAutopilotBrakeDistanceAndTime(fm)else dN,rf=cq.GetAutopilotTBBrakeDistanceAndTime(fm)end;local rg=0;local rh=0;if bd or not b2 and fm>5 then rh=cm.computeTravelTime(fm,0,rb)elseif c1+rd<rb then rg=rb-(c1+rd)rh=cm.computeTravelTime(8333.0556,0,rg)else local ri=(rb-c1)/rd;rd=rb-c1;re=re*ri end;if g2~=nil and g2.planetname==kq.name and not b2 then return rh elseif bc then return rf elseif bd then return rh+rf else return re+c2+rh end end;local function rj(oo,rk)if oo==nil then oo=b.getGravityIntensity()end;oo=fS(oo,5)if rk~=nil and rk or(pW==nil or pW~=oo)then local fm=cG:len()local rl=is(c.getWidgetData()).maxBrake;if rl~=nil and rl>0 and cb then rl=rl/di(fm/100,0.1,1)rl=rl/cc;if cc>0.10 then if bt then bt=(bt+rl)/2 else bt=rl end end end;if rl~=nil and rl>0 then br=rl end;pW=oo end end;cS,cT=qn()dc=bL.getMaxSpeed()if bi~="None"and(c3 or g2)then lE=ra()end;rj(nil,true)end;function pH.SatNavTick()if not r then return end;qk=dbHud_1.getStringValue("SPBAutopilotTargetName")if qk~=nil and qk~=""and qk~="SatNavNotChanged"then local dD=is(dbHud_1.getStringValue("SavedLocations"))if dD~=nil then bo=dD;local gt=-1;local gz;for dI,du in pairs(bo)do if du.name and du.name=="SatNav Location"then gt=dI;break end end;if gt~=-1 then gz=bo[gt]gt=-1;for dI,du in pairs(e[0])do if du.name and du.name=="SatNav Location"then gt=dI;break end end;if gt>-1 then e[0][gt]=gz end;cp.UpdateAtlasLocationsList()bZ=gz.name.." position updated"end end;for K=1,#cR do if cR[K].name==qk then bk=K;a.print("Index = "..bk.." "..cR[K].name)cp.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pH.onFlush()local function rm(rn,ro)local rp=vec3()local rq=vec3()if rn==axisCommandId.longitudinal then rp=vec3(bL.getOrientationForward())rq=cE elseif rn==axisCommandId.vertical then rp=vec3(bL.getOrientationUp())rq=q5 elseif rn==axisCommandId.lateral then rp=vec3(bL.getOrientationRight())rq=cF else return vec3()end;local rr=vec3(b.getWorldGravity())local rs=rr:dot(rq)local rt=vec3(bL.getWorldAirFrictionAcceleration())local ru=rt:dot(rq)local rv=cG:dot(rp)local rw=ro*constants.kph2m;if rx==nil then rx=pid.new(10,0,10.0)end;rx:inject(rw-rv)local ry=rx:get()local rz=(ry-ru-rs)*rq;return rz end;local function rA(rn,ro)local rp=vec3()local rq=vec3()if rn==axisCommandId.longitudinal then rp=vec3(bL.getOrientationForward())rq=cE elseif rn==axisCommandId.vertical then rp=vec3(bL.getOrientationUp())rq=q5 elseif rn==axisCommandId.lateral then rp=vec3(bL.getOrientationRight())rq=cF else return vec3()end;local rr=vec3(b.getWorldGravity())local rs=rr:dot(rq)local rt=vec3(bL.getWorldAirFrictionAcceleration())local ru=rt:dot(rq)local rv=cG:dot(rp)local rw=ro*constants.kph2m;if rB==nil then rB=pid.new(10,0,10.0)end;rB:inject(rw-rv)local ry=rB:get()local rz=(ry-ru-rs)*rq;return rz end;local function rC(rD,jR,fZ)local rE=rD:cross(fZ):normalize_inplace()local kD=math.acos(di(rE:dot(-jR),-1,1))*constants.rad2deg;if rE:cross(-jR):dot(fZ)<0 then kD=-kD end;return kD end;local function rF()if cX and not b5 then local ep=cX[1]local hV,hW=cX[2],cX[3]local rG=math.min(hV,hW or hV)local rH=rG/cI;local rI=b6 and(cI<42 or ca~=-1)local rJ=b4 or bp or bs or b2;if rJ and not rI and(c1*1.5>rG or rH<1)then a_="Collision"bE={}q8=0;if b4 then cq.ToggleAltitudeHold()end;if bs then cq.ToggleLockPitch()end;bZ="Autopilot Cancelled due to possible collision"a.print(ep.name.." COLLISION "..iA(rH).." / "..iz(rG,2))cq.ResetAutopilots(1)lx=true;if cb then b5=true end;cw=true end;if rH<11 then cW=ep.name.." COLLISION "..iA(rH).." / "..iz(rG,2)else cW=ep.name.." collision "..iA(rH)end;if rH<6 then fR("alarm","AL",2)end else cW=false end end;if antigrav and not q then if not cN and antigrav.getBaseAltitude()~=bu then qi=bu end end;if db then d:setEngineForceCommand('hover',vec3(),1)db=false end;cO=iv:getAxisCommandType(0)==axisCommandType.byThrottle;aN=math.max(aN,0.01)aO=math.max(aO,0.01)aI=math.max(aI,0.01)aM=math.max(aM,0.01)aP=math.max(aP,0.01)aQ=math.max(aQ,0.01)aH=math.max(aH,0.01)local rK=di(bT+p_+a.getControlDeviceForwardInput(),-1,1)local rL=di(bU+q1+a.getControlDeviceYawInput(),-1,1)local rM=di(bV+q0-a.getControlDeviceLeftRightInput(),-1,1)local rN=a_ and 1 or 0;cJ=vec3(b.getWorldVertical())if cJ==nil or cJ:len()==0 then cJ=(kq.center-cL):normalize()end;q5=vec3(bL.getWorldOrientationUp())cE=vec3(bL.getWorldOrientationForward())cF=vec3(bL.getWorldOrientationRight())cH=vec3(bL.getWorldVelocity())cG=vec3(bL.getVelocity())cL=vec3(bL.getWorldPosition())ce=bL.getMass()cI=vec3(cH):len()cK=-cJ:dot(cH)cQ=getRoll(cJ,cE,cF)local rO=cQ/180*math.pi;local rP=math.cos(rO)local rQ=math.sin(rO)cP=rC(cJ,cE,cF*rP+q5*rQ)local rR=cH:normalize()local rS=eW(cQ)local rT=utils.sign(cQ)local rU=vec3(bL.getWorldAngularVelocity())local rV=rK*aN*cF+rL*aI*cE+rM*aO*q5;if cw==true and cJ:len()>0.01 then local rW=eW(q2-cQ)if((b1 or b7 or b5 or c7 or b4 or by)and rW>0 or cb and rW<aJ and p)and rL==0 and eW(cP)<85 then local rX=q2;local rY=aH;if not cb then rY=rY/4;q2=0;rX=0 end;if rZ==nil then rZ=pid.new(rY*0.01,0,rY*0.1)end;rZ:inject(rX-cQ)local r_=rZ:get()rV=rV+r_*cE end end;local s0=1;local s1=0;local s2=1;bO=0;cc=bK()cb=false or cd<kq.noAtmosphericDensityAltitude and cc>0.00001;cd=b.getAltitude()ca=qw()bM=bI()pM=bM;if bl and ca>-1 and ca-3<Y then if iv.targetGroundAltitudeActivated then iv:deactivateGroundEngineAltitudeStabilization()end end;if cr then ql=not ql;if ql then cr.UpdateRadar()end;if E then rF()end end;if antigrav then cN=antigrav.isActive()==1 end;local s3=1;local s4=1;local s5=bM-pM;local s6=-math.deg(qs(q5,cH,cE))local s7=math.deg(qs(cF,cH,cE))local go=cJ*-1;cx=cb and s6<-L or s6>L or s7<-M or s7>M;local s8=a.getMouseDeltaX()local s9=a.getMouseDeltaY()if qm then local sa=bI()-qm;s8=s8*sa/0.016;s9=s9*sa/0.016 end;qm=bI()if o and not bY then s9=-s9 end;q0=0;q1=0;p_=0;fV=cl[0]local sb=bL.getWorldPosition()kq=fV:closestBody(sb)sc=cn(kq)fq=sc:orbitalParameters(sb,cH)if cd==0 then cd=(cL-kq.center):len()-kq.radius end;cV=c.getClosestPlanetInfluence()>0 or cd>0 and cd<200000;local oo=kq:getGravity(sb):len()*ce;q2=0;local sd=bL.getMaxThrustAlongAxis("ground",bL.getOrientationUp())[1]if qc==0 then if iu()==1 and bY then if not cu then c4=di(c4+s8/2,-cg/2,cg/2)c5=di(c5+s9/2,-ch/2,ch/2)end else c4=0;c5=0 end else c4=di(c4+s8/2,-cg/2,cg/2)c5=di(c5+s9/2,-ch/2,ch/2)da=dk(c4*c4+c5*c5)if not bY and iu()==0 then local kM,kN=1,1;if bG=="SCOPE"then kM,kN=d2/90,d2/90 end;if g=="virtual joystick"then if da>ax then q0=q0-di(eW(c4)-ax,0,cg/2)*utils.sign(c4)*aF*kM;p_=p_-di(eW(c5)-ax,0,ch/2)*utils.sign(c5)*aG*kN end else c4=0;c5=0;if g=="mouse"then p_=(-utils.smoothstep(s9,-100,100)+0.5)*2*s3;q0=(-utils.smoothstep(s8,-100,100)+0.5)*2*s4 end end end end;local se=cI>27777;if cI>V/3.6 and not cb and not b2 and not se then bZ="Space Speed Engine Shutoff reached"q8=0 end;if not se and sf then if not a_ then cq.BrakeToggle()end;if b2 then cq.ResetAutopilots(1)end;q8=0 end;sf=se;if cc>0.09 then if cI>cy/3.6 and not t and not pI then a_="SpdLmt"pI=true elseif not t and pI then if cI<cy/3.6 then a_=false;pI=false end end end;if b1 then if c7 then a_=false;local sg=false;if g2 and c7==true then sg=qI(g2.position-cL,0.1)else sg=qI(vec3(cH),0.01)end;cw=true;if sg then q9=bJ(cy)if(eW(cQ)<2 or eW(cP)>85)and cI>=cy/3.6-1 then a_=false;b1=false;if c7~=2 then pZ=true end;if c7==true then c9=true end;c7=false;b2=false;cq.BeginReentry()end elseif cb and t then q8=1 end elseif cI>iO then qI(vec3(cH),0.01)end end;if b0 then if cb then b0=false elseif cI>iO then qI(-vec3(cH))end end;if not b1 and c7 and not by then if not cb then if c7~=2 then pZ=true end;cq.BeginReentry()c7=false;c9=true else c7=false;if not qj then qj=true end end end;if c9 and g2 and(cd<b9+250 and cd>b9-250)and cI*3.6>cy-250 and eW(cK)<25 and cc>=0.1 and(g2.position-cL):len()>2000+cd then if not qj then qj=true end;c9=false end;if b8 then cw=true;local sh=b9;if cK<-30 then bZ="Unable to achieve lift. Safety Landing."bW=0;cw=p;b8=false;b5=true elseif not q and cN or b9<kq.spaceEngineMinAltitude then if cN then sh=antigrav.getBaseAltitude()end;if cd<sh-100 then q3=0;bW=15;a_=false elseif cK>0 then a_="VTO Limit"bW=0 elseif cK<-30 then a_="VTO Fall"bW=15 elseif cd>=sh then if cN then if b2 or bp then cq.ToggleVerticalTakeoff()else a_="VTO Complete"b8=false end;bZ="Takeoff complete. Singularity engaged"fR("aggLk","AG")else a_=false;bZ="VTO complete. Engaging Horizontal Flight"fR("vtoc","VT")cq.ToggleVerticalTakeoff()end;bW=0 end else if cc>0.08 then q3=0;a_=false;bW=20 elseif cc<0.08 and cb then a_=false;if cC then q3=0;bW=20 else bW=0;q3=36;q9=3500 end else cw=p;by=true;cB=false;si=false;pR=false;pP=nil;pQ=nil;if pU==nil then pU=kq end;cA=sh;pT=true;b8=false end end;if q3~=nil then if sj==nil then sj=pid.new(2*0.01,0,2*0.1)end;local sk=di(q3-cP,-M*0.80,M*0.80)sj:inject(sk)local sl=di(sj:get(),-1,1)p_=sl end end;if by then local function sm()if fq.periapsis.altitude>=cA*0.99 and fq.apoapsis.altitude>=cA*0.99 and fq.periapsis.altitude<fq.apoapsis.altitude and fq.periapsis.altitude*1.05>=fq.apoapsis.altitude and eW(cA-cd)<1000 then return true else return false end end;local qP;local sn=false;local so=iz(cA)if pU==nil then pU=kq;if bp then pU=c3 end end;if not pT then cA=bJ(pU.radius+pU.surfaceMaxAltitude+T)if pU.hasAtmosphere then cA=bJ(pU.radius+pU.noAtmosphericDensityAltitude+T)end;pT=true end;if q4.VectorToTarget and g2 then qP=g2.position-cL end;local sp,sq=cn(pU):escapeAndOrbitalSpeed((cL-pU.center):len()-pU.radius)local sr=cQ;if not pR then local ss=false;local st=false;q8=0;pQ=0;cz="Aligning to orbital path - OrbitHeight: "..so;if q4.VectorToTarget then qI(qP:normalize():project_on_plane(cJ))sn=cE:dot(qP:project_on_plane(q5):normalize())>0.95 else qI(cH)sn=s6<0.5;if cI<150 then sn=true end end;p_=0;pP=0;if cP<=pP+2 and cP>=pP-2 then ss=true else ss=false end;if sr<=pQ+2 and sr>=pQ-2 then st=true else st=false end;if ss and st and sn then pP=nil;pQ=nil;pR=true end else if q4.VectorToTarget then qI(qP:normalize():project_on_plane(cJ))elseif cI>150 then qI(cH)end;p_=0;if q4.VectorToTarget and g2 then local c1,dN=cm.computeDistanceAndTime(cI,cy/3.6,ce,0,0,br)if cB and qP:len()>15000+c1+cd then cz="Orbiting to Target"if cd-100<=pU.noAtmosphericDensityAltitude or lE>fq.timeToPeriapsis and fq.periapsis.altitude<pU.noAtmosphericDensityAltitude or not sm()and fq.eccentricity>0.1 then bZ="Re-Aligning Orbit"cB=false end elseif cB or qP:len()<15000+c1+cd then bZ="Orbit complete, proceeding with reentry"fR("orCom","OB")bj=g2.position;pZ=true;c9=true;q4.VectorToTarget,q4.AutopilotAlign=false,false;cq.ToggleIntoOrbit()cq.BeginReentry()return end end;if fq.periapsis~=nil and fq.apoapsis~=nil and fq.eccentricity<1 and cd>cA*0.9 and cd<cA*1.4 then if fq.apoapsis~=nil then if sm()or cB then if cB then a_=false;q8=0;pP=0;if not q4.VectorToTarget then bZ="Orbit complete"fR("orCom","OB")cq.ToggleIntoOrbit()end else pV=pV+1;if pV>=2 then cB=true end end else cz="Adjusting Orbit - OrbitHeight: "..so;pS=true;q9=sq*3.6+1;local su=cA-cd;if sv==nil then sv=pid.new(0.1,0,1*0.1)end;sv:inject(su-cK*di(utils.smoothstep(2000-su,-2000,2000)^6*10,1,10))pP=di(sv:get(),-60,60)end end else local sw=2.75;local sx=eW(fS(sp*sw))local oD=sx%50;if oD>0 then sx=sx-oD+50 end;a_=false;if cd<cA*0.8 then cz="Escaping planet gravity - OrbitHeight: "..so;pP=utils.map(cK,200,0,-15,80)elseif cd>=cA*0.8 and cd<cA*1.15 then cz="Approaching orbital corridor - OrbitHeight: "..so;sx=sx*0.75;pP=utils.map(cK,100,-100,-15,65)elseif cd>=cA*1.15 and cd<cA*1.5 then cz="Approaching orbital corridor - OrbitHeight: "..so;sx=sx*0.75;if cK<0 or pS then pP=utils.map(cd,cA*1.5,cA*1.01,-30,0)else pP=utils.map(cd,cA*0.99,cA*1.5,0,30)end elseif cd>cA*1.5 then cz="Reentering orbital corridor - OrbitHeight: "..so;pP=-65;local sy=utils.map(cK,-150,-400,1,0.55)sx=sx*sy end;q9=bJ(sx)end end;if pP~=nil then if sz==nil then sz=pid.new(1*0.01,0,5*0.1)end;local sA=pP-cP;sz:inject(sA)local sB=di(sz:get(),-0.5,0.5)p_=sB end end;if b2 and not cb and not c7 then local function sC(df,fq)a.print(df)a_=false;bc=false;b2=false;qW=false;bf="Aligning"q8=0;pY=false;bZ=df;fR("apCom","AP")if fq or c7 then if fq and gm~=nil and not c7 then if not cd or cd==0 then return end;cA=cd;pT=true end;cq.ToggleIntoOrbit()end end;local sD,sE=bj,false;if g2 and g2.planetname~="Space"then bb=true;if not qW then local sF=(g2.position-c3.center):normalize()local sG=sF:project_on_plane((c3.center-cL):normalize()):normalize()local sH=c3.center+sG*(c3.radius+gm)local sI=g2.position+(g2.position-c3.center):normalize()*(gm-c3:getAltitude(g2.position))if(cL-sH):len()<(cL-sI):len()then sD=sH else sD=sI;be=0 end;bj=sD;cq.showWayPoint(c3,bj)sE=true;qW=true end;bg=0 elseif g2 and g2.planetname=="Space"then if not qW then bg=0;sE=true;bb=true;qW=true;sD=g2.position+(cL-g2.position):normalize()*R;bj=sD end elseif g2==nil then bg=0;if not qW then local sF=(cL+cH*100000-c3.center):normalize()local sG=sF:project_on_plane((c3.center-cL):normalize()):normalize()if sG:len()<1 then sF=(cL+cE*100000-c3.center):normalize()sG=sF:project_on_plane((c3.center-cL):normalize()):normalize()end;sD=c3.center+sG*(c3.radius+gm)bj=sD;qW=true;sE=true;bb=true;cq.showWayPoint(c3,bj)end end;rb=(vec3(sD)-cL):len()local lC,eG,eH=cl:getPlanetarySystem(0):castIntersections(cL,cH:normalize(),function(ep)if ep.noAtmosphericDensityAltitude>0 then return ep.radius+ep.noAtmosphericDensityAltitude else return ep.radius+ep.surfaceMaxAltitude*1.5 end end)local lD=eG;if eH~=nil and eG~=nil then lD=math.min(eH,eG)end;if lD~=nil and lD<rb and lC.name==c3.name then rb=lD end;local sg=true;local sJ=(c3.center-(cL+vec3(cH):normalize()*rb)):len()-c3.radius;local lp=iz(sJ)qg=ge;qh='{"label": "Projected Altitude", "value": "'..lp..'"}'if cI>50 and ba then local qP=vec3(sD)-cL;local sK=di(math.deg(qs(q5,cH:normalize(),qP:normalize()))*cI/500,-90,90)local sL=di(math.deg(qs(cF,cH:normalize(),qP:normalize()))*cI/500,-90,90)if eW(sK)<20 and eW(sL)<20 then sK=sK*2;sL=sL*2 end;if eW(sK)<2 and eW(sL)<2 then sK=sK*2;sL=sL*2 end;local s6=-math.deg(qs(q5,cE,cH:normalize()))local s7=-math.deg(qs(cF,cE,cH:normalize()))if sM==nil then sM=pid.new(2*0.01,0,2*0.1)end;sM:inject(sL-s7)local sN=di(sM:get(),-1,1)p_=p_+sN;if sO==nil then sO=pid.new(2*0.01,0,2*0.1)end;sO:inject(sK-s6)local sP=di(sO:get(),-1,1)q0=q0+sP;sE=true;if eW(sK)>2 or eW(sL)>2 then if bf~="Adjusting Trajectory"then bf="Adjusting Trajectory"fR("apAdj","AP")end else if bf~="Accelerating"then bf="Accelerating"fR("apAcc","AP")end end elseif ba and cI<=50 then qI((sD-cL):normalize())end;if sJ<gm*1.5 then be=cy/3.6;if g2==nil then dN,be=cn(c3):escapeAndOrbitalSpeed(sJ)end end;local c1,c2;if not b3 then c1,c2=qo(cI)else c1,c2=qr(cI)end;if b2 and not ba and not bd and not bc then local lC,lD=cq.checkLOS((bj-cL):normalize())if c3.name~=kq.name then if lC~=nil and c3.name~=lC.name and lD<rb then bZ="Collision with "..lC.name.." in "..iz(lD).."\nClear LOS to continue."b_=5;qd=true else qd=false;bZ=""end end end;if not qd then if not bd and not bc and not sE then sg=qI((sD-cL):normalize())elseif b3 and(bc or bd)then sg=qI(-vec3(cH):normalize())end end;if ba then if not pY then a_=false;q8=_;bN=fS(_,2)pY=true end;local rc=c.getThrottle()if t then rc=bN end;local sQ=99999;local oB=-vec3(bL.getWorldAcceleration()):dot(cH:normalize())local sR=di(cH:dot((sD-cL):normalize()),0,cI)if sR>0 or oB>0 then sQ=cm.computeTravelTime(sR,oB,rb-c1)end;if a9>dc then a9=dc-0.2 end;if cG:len()>=a9 or rc==0 and pY or a0/4>sQ then ba=false;if bf~="Cruising"then fR("apCru","AP")bf="Cruising"end;bd=true;q8=0 end;local sS=rb;if sS<=c1 or H and cT<=c1+10000 and cS then if H and cT<=c1+10000 and cS then if cT<pJ and cT>2000 then cq.ResetAutopilots(1)bZ="Autopilot cancelled to prevent crossing PvP Line"a_="PvP Prevent"pJ=cT else pJ=cT;return end end;ba=false;if bf~="Braking"then fR("apBrk","AP")bf="Braking"end;bc=true;q8=0;pY=false end elseif bc then if bf~="Orbiting to Target"then a_="AP Brk"end;if b3 then q8=1;qa=true end;local dN,sq=cn(c3):escapeAndOrbitalSpeed((cL-kq.center):len()-kq.radius)local qP;if g2 then qP=g2.position-cL end;if g2 and g2.planetname=="Space"and cI<50 then if#bE>0 then if not qj then table.remove(bE,1)end;if#bE>0 then a_=false;if not qj then qj=2 end;return end end;sC("Autopilot complete, arrived at space location")a_="Space Arrival"elseif g2 and g2.planetname~="Space"and cI<=sq and(fq.apoapsis==nil or fq.periapsis==nil or fq.apoapsis.altitude<=0 or fq.periapsis.altitude<=0)then sC("Autopilot complete, commencing reentry")bj=g2.position;c7=true;cq.showWayPoint(c3,bj)elseif(g2 and g2.planetname~="Space"or g2==nil)and fq.periapsis~=nil and fq.periapsis.altitude>0 and fq.eccentricity<1 or bf=="Circularizing"then if bf~="Circularizing"then fR("apCir","AP")bf="Circularizing"end;if cI<=sq then if g2 then if cH:normalize():dot(qP:normalize())>0.4 then if bf~="Orbiting to Target"then fR("apOrb","OB")bf="Orbiting to Target"end;if not qY then a_=false;cq.showWayPoint(c3,g2.position)qY=true end else sC("Autopilot complete, proceeding with reentry")bj=g2.position;c7=true;cq.showWayPoint(c3,g2.position)qY=false end else sC("Autopilot completed, setting orbit",true)a_=false end end elseif bf=="Circularizing"then sC("Autopilot complete, fixing Orbit",true)end elseif bd then local sS=rb;if sS<=c1 or H and cT<=c1+10000 and cS then if H and cT<=c1+10000 and cS then if cT<pJ and cT>2000 then if not qj then qj=true end;bZ="Autopilot cancelled to prevent crossing PvP Line"a_="Prevent PvP"pJ=cT else pJ=cT;return end end;ba=false;if bf~="Braking"then fR("apBrk","AP")bf="Braking"end;bc=true end;local rc=c.getThrottle()if t then rc=bN end;if rc>0 then ba=true;if bf~="Accelerating"then bf="Accelerating"fR("apAcc","AP")end;bd=false end else if sg then if not bb and g2==nil or not bb and g2 and g2.planetname~="Space"then if not c7 then bj=vec3(c3.center)+(gm+c3.radius)*cF;sT=q5;sU=cF end;bb=true elseif sg and not qd then ba=true;if bf~="Accelerating"then bf="Accelerating"fR("apAcc","AP")end;if not pY then q8=_;qa=true;bN=fS(_,2)pY=true;a_=false end end end end elseif b2 and(g2~=nil and g2.planetname~="Space"and cb)then bZ="Autopilot complete, starting reentry"fR("apCom","AP")bj=g2.position;a_=false;bc=false;b2=false;qW=false;bf="Aligning"q8=0;pY=false;b1=true;c7=true;cq.showWayPoint(c3,g2.position)end;if bX then cw=true;local sL=0;local fs=cL+vec3(c.getMasterPlayerRelativePosition())local sV=fs-cL;local sW=vec3(sV):project_on(cE):len()local sX=vec3(sV):project_on(cF):len()local c6=dk(sW*sW+sX*sX)qI(sV:normalize())local mK=40;local sY=c6<mK;local sZ=100;local ro=di((c6-mK)/2,10,sZ)p_=0;local sg=eW(q0)<0.1;if sg and cI<ro and not sY then a_=false;sL=-20 else a_="Follow"sL=0 end;local s_=0;if eW(sL-cP)>s_ then if t0==nil then t0=pid.new(2*0.01,0,2*0.1)end;t0:inject(sL-cP)local sN=t0:get()p_=sN end end;if b4 or b5 or b7 or bp or bs~=nil then local t1=bt;if t1 then t1=t1*di(cI/100,0.1,1)*cc else t1=br end;if not cb then t1=br end;q7=cE:project_on_plane(cJ):normalize():dot(cH)if q7>100 then c1,c2=cm.computeDistanceAndTime(q7,100,ce,0,0,t1)local t2,t3=cm.computeDistanceAndTime(100,0,ce,0,0,t1*0.55)c1=c1+t2 else c1,c2=cm.computeDistanceAndTime(q7,0,ce,0,0,t1*0.55)end;local su=b9-cd-cK;local t4=200+cI;if b7 or c7 then t5=2000+cI end;local t6=1;if b6 then t6=di(cI/100,0.1,1)end;local sL=(utils.smoothstep(su,-t4,t4)-0.5)*2*O*t6;if not b7 and not c7 and not bp and cE:dot(cH:normalize())<0.99 then sL=(utils.smoothstep(su,-t4*di(20-19*cc*10,1,20),t4*di(20-19*cc*10,1,20))-0.5)*2*O*di(2-cc*10,1,2)*t6 end;if not b4 then sL=0 end;if bs~=nil then if cV and not by then sL=bs else bs=nil end end;cw=true;local t7=p_;if b7 then local t8=bJ(cy)local t9,ta=cm.computeDistanceAndTime(cI,t8/3.6,ce,0,0,br-kq.gravity*9.8*ce)t9=t9==-1 and 5000 or t9;local qX=cd-(kq.noAtmosphericDensityAltitude+t9)local tb=cd>kq.noAtmosphericDensityAltitude+t9*1.35;if tb then sL=P;if cI<=t8/3.6 and cI>t8/3.6-10 and eW(cH:normalize():dot(cE))>0.9 and not cO then bR=false;q8=1 end elseif(cO or iv:getTargetSpeed(axisCommandId.longitudinal)~=t8)and not tb and not cb then q9=t8;qa=true end;if cO then if cI>t8/3.6 and not tb then a_="Reentry Limit"if bN>0 then q8=0 end else a_=false end else a_=false end;if cK>0 then a_="Reentry vSpd"end;if not pZ then sL=-80;if cd<kq.surfaceMaxAltitude+(kq.atmosphereThickness-kq.surfaceMaxAltitude)*0.25 then bZ="PARACHUTE DEPLOYED at "..fS(cd,0)b7=false;b5=true;lx=true;q8=0;sL=0;cw=p end elseif kq.noAtmosphericDensityAltitude>0 and tb then cw=true elseif not tb then if not cb and(cO or iv:getTargetSpeed(axisCommandId.longitudinal)~=t8)then q9=t8 end;if cI<t8/3.6+1 then a_=false;pZ=false;b7=false;cw=true;q8=1 end end end;if cI>iO and not c8 and not bp and not b5 and u then qI(vec3(cH))end;if cU or(bp or c8)and bk>0 and cb then local qP;if cU then if type(cU)=="table"then qP=cU elseif cU<3 and cU>0 then qP=-cJ:cross(cH)*5000 elseif cU>=3 then qP=cJ:cross(cH)*5000 elseif cU<0 then qP=cH*25000 end elseif g2~=nil then qP=g2.position-cL else qP=c3.center-cL end;local sK=math.deg(qs(cJ:normalize(),cH,qP))*2;local mN=math.rad(eW(cQ))if cI>aK and cb then local tc=1000+cI;local td=(utils.smoothstep(su-cK*10,-tc,tc)-0.5)*2*O;local te=di(90-td,0,180)q2=di(sK*2,-te,te)local tf=sK;sK=di(di(sK,-L*0.80,L*0.80)*math.cos(mN)+4*(cP-sL)*math.sin(math.rad(cQ)),-L*0.80,L*0.80)local tg=1;if q2~=0 then tg=eW(mN/q2)end;tg=(90-di(eW(q2-cQ),0,90))/90;local th=sL;if eW(cQ)>90 then th=-th end;sL=tg*di(di(th*math.cos(mN),-M*0.8,M*0.8)+eW(di(eW(tf)*math.sin(mN),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q2=0;sK=di(sK,-L*0.80,L*0.80)end;local ti=s6-sK;if cU and eW(ti)<=0.0001 and(type(cU)=="table"or type(cU)~="table"and cU<0 and eW(cQ)<1)then if cU==-2 then cq.ToggleAltitudeHold()end;cU=nil;fR("180Off","BR")return end;if not cx and cI>aK and cb then if tj==nil then tj=pid.new(2*0.01,0,2*0.1)end;tj:inject(ti)local sP=di(tj:get(),-1,1)q0=q0+sP elseif cb and ca>-1 or cI<aK then qI(qP)elseif cx and cb then if(s6<-L or s6>L)and cb then qI(cH)end;if(s7<-M or s7>M)and cb then sL=di(cP-s7,cP-M*0.80,cP+M*0.80)end end;if g2~=nil and not c8 then local sh=kq:getAltitude(g2.position)local qX=qP:project_on_plane(cJ):len()lx=true;if b9<kq.noAtmosphericDensityAltitude and not c8 and not b6 and not b7 and(qX<=c1 and qP:len()<kq.radius)and(cH:project_on_plane(cJ):normalize():dot(qP:project_on_plane(cJ):normalize())>0.99 or lG=="Finalizing Approach")then lG="Finalizing Approach"if#bE>0 then if not qj then table.remove(bE,1)end;if#bE>0 then if not qj then qj=2 end;return end end;q8=0;if b4 then cq.ToggleAltitudeHold()bp=true end;a_="AP Finalizing"elseif not b6 then a_=false end;if lG=="Finalizing Approach"and(q7<0.1 or qX<0.1 or tk~=nil and tk<qX)then fR("bklOn","BL")b5=true;d8=true;if g2.heading then d9=g2.heading else d9=nil end;bp=false;lG="Proceeding to Waypoint"cW=false end;tk=qX end elseif bp and not cb and b9>kq.noAtmosphericDensityAltitude and not(c8 or b7)then if g2~=nil and c3.name==kq.name then local qP=g2.position-cL;local sh=kq:getAltitude(g2.position)local qX=dk(qP:len()^2-(cd-sh)^2)local t1=bt;if t1 then c1,c2=cm.computeDistanceAndTime(cI,0,ce,0,0,t1/2)lx=true;if qX<=c1+cI*s5/2 and cH:project_on_plane(cJ):normalize():dot(qP:project_on_plane(cJ):normalize())>0.99 then if kq.hasAtmosphere then a_=false;b1=false;pZ=true;c7=false;c9=true;b2=false;cq.BeginReentry()end end;tk=qX end end end;if not cb and(b4 and b9>kq.noAtmosphericDensityAltitude)and not(c8 or by or b7)then if not cB and not by then cA=b9;pT=true;if bp then q4.VectorToTarget=true end;cq.ToggleIntoOrbit()bp=false;pR=true end end;if cx and cb and ca==-1 and cI>aK and lG~="Finalizing Approach"then qI(cH)sL=di(cP-s7,cP-M*0.80,cP+M*0.80)end;p_=t7;local qB=-1;if b5 then if not qe then if not cO then q8=0 end;iv:setTargetGroundAltitude(500)iv:activateGroundEngineAltitudeStabilization(500)bA=true;qe=true end;sL=0;local tl=false;local tm=math.abs(q7)if not q and cN then tl=antigrav.getBaseAltitude()if tl<kq.surfaceMaxAltitude and g2==nil or g2~=nil and kq:getAltitude(g2.position)>tl then tl=false end else tl=false end;if d9 then if tm<0.05 then if cK>-N then a_=false else a_="BL Align BLR"end;if qI(d9,0.001)then d9=nil;cw=p else p_=0;cw=true end else a_="BL Align Hzn"end;if tl and eW(cd-tl)<250 then a_="AGG Align"end else local tn=false;local to=30;if tm<10 and sd~=nil and sd>0 then local tp=di(cc,0.4,2)local t1=bt*di(cI/100,0.1,1)*tp;local tq=sd*tp+t1-oo;local tr=t1/2-oo;local ts=cI-dk(eW(tr/2)*20/(0.5*ce))*utils.sign(tr)if ts<0 then ts=0 end;local tt;if cI>100 then local tu,dN=cm.computeDistanceAndTime(cI,100,ce,0,0,t1)local tv,dN=cm.computeDistanceAndTime(100,0,ce,0,0,dk(t1))tt=tu+tv else tt=cm.computeDistanceAndTime(cI,0,ce,0,0,dk(t1))end;if tt<20 then a_=false else local tw=0;if ts>100 then local tx,dN=cm.computeDistanceAndTime(ts,100,ce,0,0,tq)local ty,dN=cm.computeDistanceAndTime(100,0,ce,0,0,sd*tp+dk(t1)-oo)tw=tx+ty else tw,dN=cm.computeDistanceAndTime(ts,0,ce,0,0,sd*tp+dk(t1)-oo)end;tw=(tw+15+cI*s5)*1.1;local tz=d8 and g2~=nil and kq:getAltitude(g2.position)>0 and g2.safe;local sh=nil;if tl and tl<cd then sh=tl elseif tz then sh=kq:getAltitude(g2.position)+250 elseif cd>kq.surfaceMaxAltitude then sh=kq.surfaceMaxAltitude end;if cX then local tA=kq:getAltitude(cX[1].center)if sh then if tA>sh then sh=tA end else sh=tA end end;if sh~=nil then local tB=cd-sh;tn=true;if tB<=tw or tw==-1 or tm>0.05 and d8 then if tm>0.05 and d8 then a_="BL AP Hzn"else a_="BL Stop Dist"end else a_=false end end end end;qB=ca;if qB>-1 then if(cI<1 or cH:normalize():dot(cJ)<0)and not d9 then b5=false;b4=false;if not tl then qb=true;iv:setTargetGroundAltitude(Y)end;bW=0;a_="BL Complete"cw=p;d8=false else a_="BL Slowing"end elseif not tn then if lx and cH:normalize():dot(-go)<0.999 then a_="BL Strong"qI()elseif tm>10 or tm>0.05 and d8 then a_="BL hSpd"elseif cK<-N then a_="BL BLR"else a_=false end end end else qe=false end;if b6 or c8 then local lC,eH,eG;if bj~=nil then lC,eH,eG=cl:getPlanetarySystem(0):castIntersections(cL,(bj-cL):normalize(),function(ep)if ep.noAtmosphericDensityAltitude>0 then return ep.radius+ep.noAtmosphericDensityAltitude else return ep.radius+ep.surfaceMaxAltitude*1.5 end end)end;if cN and not c8 then if cd>=b9-50 and cI>iO then b6=false;if not b2 and not bp then a_="ATO Agg Arrive"q8=0 end end elseif eW(sL)<15 and cd/b9>0.75 then b6=false;if not c8 then if cO and not t then d.control.cancelCurrentControlMasterMode()end elseif c8 and cI<iO then b2=true;c8=false;b4=false;b6=false;q8=0 elseif c8 then q8=0;a_="ATO Space"end elseif c8 and not cb and c3~=nil and(lC==nil or lC.name==c3.name)then b2=true;c8=false;b4=false;b6=false;if not cO then q8=0 end;ba=true end end;local tC=ca>-1;local tD=cP;if(bp or c8 or cU)and not tC and cI>aK and cb then local mN=math.rad(eW(cQ))tD=cP*eW(math.cos(mN))+s7*math.sin(mN)end;local tE=di(sL-tD,-M*0.80,M*0.80)if not cb and bp then tE=di(sL-tD,-85,O)elseif not cb then tE=di(sL-tD,-O,O)end;if eW(cQ)<5 or bp or cU or b5 or tC or b4 then if t0==nil then t0=pid.new(5*0.01,0,5*0.1)end;t0:inject(tE)local sN=t0:get()p_=p_+sN end end;if antigrav~=nil and(antigrav and not q and cd<200000)then if bu==nil or bu<1000 then bu=1000 end;if tF~=bu then tF=bu;qi=tF end end;if(cb or b7 or c9)and t and cO then if tG==nil then tG=pid.new(0.1,0,1)end;local tH=0;if aT>0 and not b7 and cc>0.005 and cc<0.1 and cK>-50 then tH=(0.1-cc)*cy*aT end;tG:inject(cy/3.6+tH-cH:dot(cE))local tI=tG:get()bQ=di(tI,-1,1)if not d4 then if bQ<bN and(cc>0.005 or b7 or c9)then bP=true;d4=di(bQ,0.01,1)else bP=false;d4=bN end end;if tJ==nil then tJ=pid.new(1*0.01,0,1*0.1)end;tJ:inject(cH:len()-cy/3.6-tH)local tK=di(tJ:get(),0,1)if cb and cK<-80 or(cc>0.005 or b7 or c9)then bO=tK end;if bO>0 then if bP and bQ==0.01 and not d4 then d4=0 end else bQ=di(bQ,0.01,1)end;local tL=''local tM=vec3()local tN=rm(axisCommandId.vertical,bW*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tN,s1)local tO='thrust analog longitudinal 'if bB=="All"or bB=="Longitude"then tO=tO..aU end;local tP=iv:getAxisCommandType(axisCommandId.longitudinal)local tQ=iv:composeAxisAccelerationFromThrottle(tO,axisCommandId.longitudinal)local tR=rA(axisCommandId.lateral,bx*1000)tL=tL..' , '.."lateral airfoil , lateral ground "tM=tM+tR;if tM:len()>constants.epsilon then d:setEngineForceCommand(tL,tM,s1,'','','',s2)end;d:setEngineForceCommand(tO,tQ,s0)local tS='thrust analog vertical fueled 'local tT='thrust analog lateral fueled 'if bB=="All"or bB=="Lateral"then tT=tT..aV end;if bB=="All"or bB=="Vertical"then tS=tS..aW end;if bW~=0 or b5 and a_ or not bl and not bA then d:setEngineForceCommand(tS,tN,s0)else d:setEngineForceCommand(tS,vec3(),s0)end;if bx~=0 then d:setEngineForceCommand(tT,tR,s0)else d:setEngineForceCommand(tT,vec3(),s0)end;if rN==0 then rN=bO end;local tU=-rN*(aP*cH+aQ*rR)d:setEngineForceCommand('brake',tU)else if t then if not d4 then d4=bN end end;local ro=c.getAxisCommandValue(0)if not cO then if tJ==nil then tJ=pid.new(1*0.01,0,1*0.1)end;tJ:inject(cH:len()-ro/3.6)local tK=di(tJ:get(),0,1)rN=di(rN+tK,0,1)end;local tU=-rN*(aP*cH+aQ*rR)d:setEngineForceCommand('brake',tU)local tL=''local tM=vec3()local tV=false;local tO='thrust analog longitudinal 'if bB=="All"or bB=="Longitude"then tO=tO..aU end;local tP=iv:getAxisCommandType(axisCommandId.longitudinal)if tP==axisCommandType.byThrottle then local tQ=iv:composeAxisAccelerationFromThrottle(tO,axisCommandId.longitudinal)d:setEngineForceCommand(tO,tQ,s0)elseif tP==axisCommandType.byTargetSpeed then local tQ=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tL=tL..' , '..tO;tM=tM+tQ;if iv:getTargetSpeed(axisCommandId.longitudinal)==0 or iv:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iv:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tV=true end end;local tT='thrust analog lateral 'if bB=="All"or bB=="Lateral"then tT=tT..aV end;local tW=iv:getAxisCommandType(axisCommandId.lateral)if tW==axisCommandType.byThrottle then local tX=iv:composeAxisAccelerationFromThrottle(tT,axisCommandId.lateral)d:setEngineForceCommand(tT,tX,s0)elseif tW==axisCommandType.byTargetSpeed then local tR=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tL=tL..' , '..tT;tM=tM+tR end;local tS='thrust analog vertical 'if bB=="All"or bB=="Vertical"then tS=tS..aW end;local tY=iv:getAxisCommandType(axisCommandId.vertical)if tY==axisCommandType.byThrottle then local tN=iv:composeAxisAccelerationFromThrottle(tS,axisCommandId.vertical)if bW~=0 or b5 and a_ then d:setEngineForceCommand(tS,tN,s0,'airfoil','ground','',s2)else d:setEngineForceCommand(tS,vec3(),s0)d:setEngineForceCommand('airfoil vertical',tN,s0,'airfoil','','',s2)d:setEngineForceCommand('ground vertical',tN,s0,'ground','','',s2)end elseif tY==axisCommandType.byTargetSpeed then if bW<0 then d:setEngineForceCommand('hover',vec3(),s0)end;local tZ=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tL=tL..' , '..tS;tM=tM+tZ end;if tM:len()>constants.epsilon then if rN~=0 or tV or eW(rR:dot(cE))<0.5 then tL=tL..', brake'end;d:setEngineForceCommand(tL,tM,s1,'','','',s2)end end;local t_=aM*(rV-rU)local u0=vec3(bL.getWorldAirFrictionAngularAcceleration())t_=t_-u0;d:setEngineTorqueCommand('torque',t_,s0,'airfoil','','',s2)d:setBoosterCommand('rocket_engine')if c0 and not n then local fm=cG:len()local u1=0.15;if not cO then local u2=iv:getTargetSpeed(axisCommandId.longitudinal)if fm*3.6>u2*(1-u1)and u3 then u3=false;d:toggleBoosters()elseif fm*3.6<u2*(1-u1)and not u3 then u3=true;d:toggleBoosters()end else local rc=c.getThrottle()if t then rc=bN*100 end;local ro=rc/100;if not cb then ro=ro*a9;if fm>=ro*(1-u1)and u3 then u3=false;d:toggleBoosters()elseif fm<ro*(1-u1)and not u3 then u3=true;d:toggleBoosters()end else local t8=bJ(cy)ro=ro*t8/3.6;if fm>=ro*(1-u1)and u3 then u3=false;d:toggleBoosters()elseif fm<ro*(1-u1)and not u3 then u3=true;d:toggleBoosters()end end end end end;if u4 then for dI,du in pairs(u4)do pH[dI]=du end end;ca=qw()return pH end;local function u5(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u6,iu,iv,iw,u7,gK,fS,e1,dj,di,fR,iy,pG)local u8={}local u9=true;local ua=5;local ub=5;local uc=ua;local ud=ub;local ue=bM;function u8.landingGear()bl=not bl;if bl then bp=false;bs=nil;cq.cmdThrottle(0)if vBooster or hover then if cb and ca==-1 then fR("bklOn","BL")lx=true;b7=false;b6=false;b8=false;b4=false;if b5 then d8=not d8 end;b5=true;cw=true;bl=false else if bS then fR("grOut","LG",1)d.control.deployLandingGears()end;d8=false;iv:setTargetGroundAltitude(Y)if cb then a_="Landing"end end elseif bS and not b5 then fR("grOut","LG",1)d.control.deployLandingGears()end else if bS then fR("grIn","LG",1)d.control.retractLandingGears()end;iv:activateGroundEngineAltitudeStabilization(uf)if bA then if Y<iv.targetGroundAltitude then iv:setTargetGroundAltitude(iv.targetGroundAltitude)else iv:setTargetGroundAltitude(X)end end end end;function u8.startControl(ug)local function uh(r7)local r8=1;local function ui(uj,r7)local uk={kq.surfaceMaxAltitude+100,kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude,kq.noAtmosphericDensityAltitude+T,kq.radius*(S-1)+kq.noAtmosphericDensityAltitude}local ul=uj;for dN,du in ipairs(uk)do if r7 and ul>du then uj=du elseif uj<du and not r7 then uj=du;break end end;return uj end;if r7 then r8=-1 end;if not q and cN then if bY and r7 then bu=1000 elseif bu~=nil then bu=bu+r8*ub;if bu<1000 then bu=1000 end;if b4 and bu<b9+10 and bu>b9-10 then b9=bu end else bu=tF+r8*100 end elseif b4 or b8 or by then if by then if bY then cA=ui(cA,r7)else cA=cA+r8*ua end;if cA<kq.noAtmosphericDensityAltitude then cA=kq.noAtmosphericDensityAltitude end else if bY and cb then b9=ui(b9,r7)else b9=b9+r8*ua end end else iv:updateTargetGroundAltitudeFromActionStart(r8*1.0)end end;local function um(un)if not cb then bZ="Flight Assist in Atmo only"return end;local dr=type(un)if cU==nil then if dr=="table"then if b2 or bp then cq.ToggleAutopilot()end;fR("180On","BR")elseif un==1 then fR("bnkLft","BR")else fR("bnkRht","BR")end;if not b4 and not b2 and not bp then cq.ToggleAltitudeHold()if dr~="table"then un=un+1 end end;cU=un else fR("180Off","BR")cU=nil end end;local function uo()if iw()==1 then c4=0;c5=0;u7(bh)elseif iu()==1 and y then cv=false;cu=false end;bY=false end;if ug=="gear"then cs.landingGear()elseif ug=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ug=="forward"then if p8 and not cb and not b2 then b1=not b1;b0=false else bT=bT-1 end elseif ug=="backward"then if p8 then if not cb then if not b2 then b0=not b0;b1=false else b3=not b3 end else um(-cH*5000)end else bT=bT+1 end elseif ug=="left"then if p8 then um(1)else bU=bU-1 end elseif ug=="right"then if p8 then um(3)else bU=bU+1 end elseif ug=="yawright"then bV=bV-1;d9=nil elseif ug=="yawleft"then bV=bV+1;d9=nil elseif ug=="straferight"then iv:updateCommandFromActionStart(axisCommandId.lateral,1.0)bx=1 elseif ug=="strafeleft"then iv:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bx=-1 elseif ug=="up"then bW=bW+1;if ca-3<Y and cd>0 and bl then cs.landingGear()end;iv:deactivateGroundEngineAltitudeStabilization()iv:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ug=="down"then bW=bW-1;iv:deactivateGroundEngineAltitudeStabilization()iv:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ug=="groundaltitudeup"then uh()elseif ug=="groundaltitudedown"then uh(true)elseif ug=="option1"then up=false;if p8 and bY then local uq=""for K=1,#c_ do uq=uq.."| Name: "..a.getPlayerName(c_[K]).." Mass: "..fS(b.getBoardedPlayerMass(c_[K])/1000,1).."t "end;a.print("Onboard: "..uq)return end;cp.adjustAutopilotTargetIndex()elseif ug=="option2"then up=false;if p8 and bY then for K=1,#c_ do b.forceDeboard(c_[K])b.forceInterruptVRSession(c_[K])end;bZ="Deboarded All Passengers"return end;cp.adjustAutopilotTargetIndex(1)elseif ug=="option3"then local function ur()u9=not u9;if not u9 then fR("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(us,atmofueltank_size,"Atmo Fuel","fuel_container")ut=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uu,spacefueltank_size,"Space Fuel","fuel_container")uv=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uw,rocketfueltank_size,"Rocket Fuel","fuel_container")ux=_autoconf.panels[_autoconf.panels_size]end;uy=a.createWidgetPanel("Docking")uz=a.createWidget(uy,"parenting")a.addDataToWidget(c.getWidgetDataId(),uz)uA=a.createWidgetPanel("Core combat stress")uB=a.createWidget(uA,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uB)if shield~=nil then shield.showWidget()end else fR("hud","DH")c.hideWidget()b.hideWidget()if ut~=nil then gK(ut)ut=nil end;if uy~=nil then gK(uy)uy=nil end;if uA~=nil then gK(uA)uA=nil end;if uv~=nil then gK(uv)uv=nil end;if ux~=nil then gK(ux)ux=nil end;if shield~=nil then shield.hideWidget()end end end;up=false;if p8 and bY then local uq=""for K=1,#d0 do uq=uq.."| ID: "..d0[K].." Mass: "..fS(b.getDockedConstructMass(d0[K])/1000,1).."t "end;a.print("Docked Ships: "..uq)return end;if x then if w then w=false else w=true end end;ur()elseif ug=="option4"then up=false;if p8 and bY then for K=1,#d0 do b.forceUndock(d0[K])end;bZ="Undocked all ships"return end;cU=nil;cq.ToggleAutopilot()elseif ug=="option5"then up=false;cq.ToggleLockPitch()elseif ug=="option6"then up=false;if p8 and bY then if shield then ct.ventShield()else bZ="No shield found"end;return end;cq.ToggleAltitudeHold()elseif ug=="option7"then up=false;if p8 and bY then if shield then shield.toggle()return else bZ="No shield found"return end end;E=not E;if E then bZ="Collision System Enabled"else bZ="Collision System Secured"end elseif ug=="option8"then up=false;if p8 and bY then if bk>0 and g2~=nil then cq.routeWP()else bZ="Select a saved wp on IPH to add to or remove from route"end;return end;bA=not bA;if not bA then bZ="DeCoupled Mode - Ground Stabilization off"iv:deactivateGroundEngineAltitudeStabilization()fR("gsOff","GS")else bZ="Coupled Mode - Ground Stabilization on"iv:activateGroundEngineAltitudeStabilization(uf)db=true;fR("gsOn","GS")end elseif ug=="option9"then up=false;if p8 and bY then iv:resetCommand(axisCommandId.longitudinal)iv:resetCommand(axisCommandId.lateral)iv:resetCommand(axisCommandId.vertical)cq.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cf=gyro.getState()==1;if cf then fR("gyOn","GA")else fR("gyOff","GA")end else bZ="No gyro found"end elseif ug=="lshift"then cY=false;if p8 then bY=true elseif bY then uo()else if iw()==1 then bY=true;bh=iw()u7(1)elseif iu()==1 and y then bY=true;cv=false;cu=false end end elseif ug=="brake"then if aY or p8 then cq.BrakeToggle("Manual")elseif not a_ then cq.BrakeToggle("Manual")else a_="Manual"end elseif ug=="lalt"then up=true;p8=true;if iu()==0 and not i and g=="keyboard"then u7(1)end elseif ug=="booster"then if n then d:toggleBoosters()elseif not c0 then if not u3 then d:toggleBoosters()u3=true end;c0=true else if u3 then d:toggleBoosters()u3=false end;c0=false end elseif ug=="stopengines"then local function uC()if bM-ue<1.5 then fR("clear","CA")cq.clearAll()end end;uC()ue=bM;if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bN~=0 then iv:resetCommand(axisCommandId.longitudinal)cq.cmdThrottle(0)else cq.cmdThrottle(100)end else if iv:getTargetSpeed(axisCommandId.longitudinal)~=0 then iv:resetCommand(axisCommandId.longitudinal)else if cb then cq.cmdCruise(cy)else cq.cmdCruise(a9*3.6)end end end elseif ug=="speedup"then cq.changeSpd()elseif ug=="speeddown"then cq.changeSpd(true)elseif ug=="antigravity"and not q then if antigrav~=nil then cq.ToggleAntigrav()else bZ="No antigrav found"end elseif ug=="leftmouse"then if bY then uo()end end end;function u8.stopControl(ug)local function uD()if not q and cN then ud=ub end;if b4 or b8 or by then uc=ua end end;if ug=="forward"then bT=0 elseif ug=="backward"then bT=0 elseif ug=="left"then if cU then if cU==2 then cU=-2 else cU=-1 end end;bU=0 elseif ug=="right"then if cU then if cU==4 then cU=-2 else cU=-1 end end;bU=0 elseif ug=="yawright"then bV=0 elseif ug=="yawleft"then bV=0 elseif ug=="straferight"then iv:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bx=0 elseif ug=="strafeleft"then iv:updateCommandFromActionStop(axisCommandId.lateral,1.0)bx=0 elseif ug=="up"then bW=0;iv:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bA then iv:activateGroundEngineAltitudeStabilization(uf)db=true end elseif ug=="down"then bW=0;iv:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bA then iv:activateGroundEngineAltitudeStabilization(uf)db=true end elseif ug=="groundaltitudeup"then uD()up=false elseif ug=="groundaltitudedown"then uD()up=false elseif ug=="brake"then if not aY and not p8 then if a_ then cq.BrakeToggle()else a_=false end end elseif ug=="lalt"then if bY then bY=false end;if iu()==0 and i then if up then if iw()==1 then u7(0)else u7(1)end else up=true end elseif iu()==0 and not i and g=="keyboard"then u7(0)end;p8=false end end;function u8.loopControl(ug)local function uE(r7)local r8=1;if r7 then r8=-1 end;if not q and cN then if bu~=nil then bu=bu+r8*ud;if bu<1000 then bu=1000 end;if b4 and bu<b9+10 and bu>b9-10 then b9=bu end;ud=di(ud*1.05,ub,50)else bu=tF+r8*100 end elseif b4 or b8 or by then if by then cA=cA+r8*uc;if cA<kq.noAtmosphericDensityAltitude then cA=kq.noAtmosphericDensityAltitude end else b9=b9+r8*uc end;uc=di(uc*1.05,ua,50)else iv:updateTargetGroundAltitudeFromActionLoop(r8*1.0)end end;local function uF(r7)local r8=1;if r7 then r8=-1 end;if not bY then if t and not p8 then bN=di(bN+r8*aE/100,-1,1)else iv:updateCommandFromActionLoop(axisCommandId.longitudinal,r8*aE)end end end;if ug=="groundaltitudeup"then if not bY then uE()end elseif ug=="groundaltitudedown"then if not bY then uE(true)end elseif ug=="speedup"then uF()elseif ug=="speeddown"then uF(true)end end;function u8.inputTextControl(r6)local function uG(uH,fs,gw)local function uI(fs)local dA=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dB='::pos{'..dA..','..dA..','..dA..','..dA..','..dA..'}'local dR,dS,dZ,d_,e0=e1(fs,dB)if dR=="0"and dS=="0"then return vec3(dj(dZ),dj(d_),dj(e0))end;d_=math.rad(d_)dZ=math.rad(dZ)local kq=e[dj(dR)][dj(dS)]local eS=math.cos(dZ)local uJ=vec3(eS*math.cos(d_),eS*math.sin(d_),math.sin(dZ))return kq.center+(kq.radius+e0)*uJ end;local fU=uI(fs)return cp.AddNewLocation(uH,fU,gw)end;local K;local uK,ii=nil,nil;local uL="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(r6," ")uK=r6;if K~=nil then uK=string.sub(r6,0,K-1)ii=string.sub(r6,K+1)end;if uK=="/help"or uK=="/commands"then for ly in string.gmatch(uL,"([^\n]+)")do a.print(ly)end;return elseif uK=="/setname"then if ii==nil or ii==""then bZ="Usage: ah-setname Newname"return end;if bk>0 and g2~=nil then cp.UpdatePosition(ii)else bZ="Select a saved target to rename first"end elseif shield and uK=="/resist"then ct.setResist(ii)elseif uK=="/addlocation"or string.find(r6,"::pos")~=nil then local gw=false;local uH="0-Temp"if ii==nil or ii==""or uK~="/addlocation"then ii=uK;gw=true end;K=string.find(ii,"::")if not gw then uH=string.sub(ii,1,K-2)end;local fs=string.sub(ii,K)uG(uH,fs,gw)elseif uK=="/agg"then if ii==nil or ii==""then bZ="Usage: /agg targetheight"return end;ii=dj(ii)if ii<1000 then ii=1000 end;bu=ii;bZ="AGG Target Height set to "..ii elseif uK=="/G"then if ii==nil or ii==""then bZ="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ii=="dump"then for dI,du in pairs(iy())do if type(du.get())=="boolean"then if du.get()==true then a.print(dI.." true")else a.print(dI.." false")end elseif du.get()==nil then a.print(dI.." nil")else a.print(dI.." "..du.get())end end;return end;K=string.find(ii," ")local uM=string.sub(ii,0,K-1)local uN=string.sub(ii,K+1)for dI,du in pairs(iy())do if dI==uM then local uO=type(du.get())if uO=="number"then uN=dj(uN)if dI=="AtmoSpeedLimit"then cy=uN end end;bZ="Variable "..uM.." changed to "..uN;if dI=="MaxGameVelocity"then uN=uN/3.6;if uN>dc-0.2 then uN=dc-0.2;bZ="Variable "..uM.." changed to "..fS(uN*3.6,1)end end;if uO=="boolean"then if string.lower(uN)=="true"then uN=true else uN=false end end;du.set(uN)return end end;bZ="No such global variable: "..uM elseif uK=="/deletewp"then if bk>0 and g2~=nil then cp.ClearCurrentPosition()else bZ="Select a custom wp to delete first in IPH"end elseif uK=="/copydatabank"then if dbHud_2 then pG(true)else bZ="Spare Databank required to copy databank"end elseif uK=="/iphWP"then if bk>0 then a.print(cq.showWayPoint(c3,bj,true))a.print(json.encode(bj))bZ="::pos waypoint shown in lua chat in local and world format"else bZ="No target selected in IPH"end elseif uK=="/createPrivate"then local uP="privatelocations = {\n"local uQ=""if#d6>0 then for dI,du in pairs(d6)do uP=uP.."{position = {x = "..du.position.x..", y = "..du.position.y..", z = "..du.position.z.."},\n ".."name = '"..du.name.."',\n planetname = '"..du.planetname.."',\n gravity = "..du.gravity..",\n"if du.heading then uP=uP.."heading = {x = "..du.heading.x..", y = "..du.heading.y..", z = "..du.heading.z.."},\n"end;if du.safe then uP=uP.."safe = true},\n"else uP=uP.."safe = false},\n"end end end;uQ=#d6 .."-Private "if ii=="all"then for dI,du in pairs(bo)do uP=uP.."{position = {x = "..du.position.x..", y = "..du.position.y..", z = "..du.position.z.."},\n ".."name = '*"..du.name.."',\n planetname = '"..du.planetname.."',\n gravity = "..du.gravity..",\n"if du.heading then uP=uP.."heading = {x = "..du.heading.x..", y = "..du.heading.y..", z = "..du.heading.z.."},\n"end;if du.safe then uP=uP.." safe = true},\n"else uP=uP.."safe = false},\n"end end;uQ=uQ..#bo.."-Public "end;uP=uP.."}\n return privatelocations"if u6 then u6.setHTML(uP)end;bZ=uQ.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"b_=7 end end;function u8.tagTick()if bB=="Off"then bB="All"elseif bB=="All"then bB="Longitude"elseif bB=="Longitude"then bB="Lateral"elseif bB=="Lateral"then bB="Vertical"else bB="Off"end;bZ="Extra Engine Tags: "..bB;c.stopTimer("tagTick")end;if uR then for dI,du in pairs(uR)do u8[dI]=du end end;return u8 end;local function uS(d,b,c,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ir,u6)local a=DUSystem;local bL=DUConstruct;local uT=DUPlayer;local gJ=DULibrary;local uU={}local dh=string.format;local is=json.decode;local uV=json.encode;local py=b.getElementMaxHitPointsById;local it=b.getElementMassById;local iu=d.control.isRemoteControlled;local e1=string.match;local gK=a.destroyWidgetPanel;local fP=a.updateData;local fQ=a.addDataToWidget;local u7=a.lockView;local iw=a.isViewLocked;local dk=math.sqrt;local dj=tonumber;local eW=math.abs;local bJ=math.floor;local bK=c.getAtmosphereDensity;local eR=math.atan;local bI=a.getArkTime;local di=utils.clamp;local iv=d.axisCommandManager;local uW=Y;local gM=13;local iB=b.getElementIdList()local iC=0;local function dl(ez,eA)if ez==0 then return eW(eA)<1e-09 end;if eA==0 then return eW(ez)<1e-09 end;return eW(ez-eA)<math.max(eW(ez),eW(eA))*dz end;local function fS(dA,uX)local r8=10^(uX or 0)return bJ(dA*r8+0.5)/r8 end;local function ix(uY,uZ)for dI,du in pairs(uZ)do if type(dI)=="string"then uY[dI]=du else uY[#uY+1]=uZ[dI]end end;return uY end;local function iy(u_)local v0={}if not u_ then ix(v0,J)ix(v0,a8)ix(v0,aC)ix(v0,aX)return v0 elseif u_=="boolean"then return J elseif u_=="handling"then return a8 elseif u_=="hud"then return aC elseif u_=="physics"then return aX end end;local function pG(v1)local function v2(v3)for dI,du in pairs(v3)do dbHud_1.setStringValue(dI,uV(du.get()))if v1 and dbHud_2 then dbHud_2.setStringValue(dI,uV(du.get()))end end end;if dbHud_1 then v2(bF)v2(iy())a.print("Saved Variables to Datacore")if v1 and dbHud_2 then bZ="Databank copied.  Remove copy when ready."end end end;local function fR(v4,v5,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..v4 ..".mp3")end;local function gL(hs,ht,r6,jI,v6)if jI==nil then jI=""end;if v6==nil then v6=""end;return dh([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hs,ht,v6,r6)end;local function iz(c6,v7)local v8=c6>100000;if v7==nil then v7=1 end;if v8 then return fS(c6/1000/200,v7).."SU"elseif c6<1000 then return fS(c6,v7).."M"else return fS(c6/1000,v7).."KM"end end;local function iA(v9)local va=0;local vb=0;local vc=0;if v9<60 then v9=bJ(v9)elseif v9<3600 then va=bJ(v9/60)v9=bJ(v9%60)elseif v9<86400 then vb=bJ(v9/3600)va=bJ(v9%3600/60)else vc=bJ(v9/86400)vb=bJ(v9%86400/3600)end;if vc>0 then return vc.."d "..vb.."h "elseif vb>0 then return vb.."h "..va.."m "elseif va>0 then return va.."m "..v9 .."s"elseif v9>0 then return v9 .."s"else return"0s"end end;function uU.onStart()local vd=false;local function ve()local function vf(vg)local vh=dbHud_1.hasKey;for dI,du in pairs(vg)do if vh(dI)then local dD=is(dbHud_1.getStringValue(dI))if dD~=nil then du.set(dD)vd=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vf(iy())coroutine.yield()vf(bF)else vf(bF)bZ="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"b_=5;vd=false end;coroutine.yield()if vd then bZ="Loaded Saved Variables"elseif not f then bZ="No Databank Saved Variables Found\nVariables will save to Databank on standing"b_=5 end;if#bo>0 then d7=ix(d7,bo)end else bZ="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;cg=aa;ch=ab;aY=j;g=string.lower(g)cw=p;cy=U;if bv+180<bM then bt=0 end;bv=bM;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bZ="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"b_=7 end;if antigrav and not q then if bu==nil then bu=cd end;antigrav.setTargetAltitude(bu)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d6>0 then d7=ix(d7,d6)end end;lG="Proceeding to Waypoint"if a9<0 then a9=bL.getMaxSpeed()-0.1 end end;local function vi()local function vj(vk,vl)if vk>vl then vl=vk end;local vm,vn=0,0;if a4>0 then vm=a4*0.05 end;if a5>0 then vn=a5*0.05 end;vl=vl*(1-(vm+vn))return vl end;local vo=b.getElementNameById;local vp=ar~=0 and as~=0;local vq=_G["atmofueltank_size"]local vr=_G["spacefueltank_size"]local vs=_G["rocketfueltank_size"]for dI in pairs(iB)do local type=b.getElementDisplayNameById(iB[dI])if e1(type,'^.*Atmospheric Engine$')then if e1(tostring(b.getElementTagsById(iB[dI])),'^.*vertical.*$')and b.getElementForwardById(iB[dI])[3]>0 then cM=true end end;if e1(type,'^.*Space Engine$')then cD=true;if e1(tostring(b.getElementTagsById(iB[dI])),'^.*vertical.*$')then local vt=b.getElementForwardById(iB[dI])if vt[3]<0 then vu=true else cC=true end end end;if type=="Landing Gear"then bS=true end;if type=="Dynamic Core Unit"then local pA=py(iB[dI])if pA>10000 then gM=110 elseif pA>1000 then gM=55 elseif pA>150 then gM=27 end end;iC=iC+py(iB[dI])if vp and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pA=py(iB[dI])local ox=it(iB[dI])local vk=0;local jB=bI()if type=="Atmospheric Fuel Tank"then local vl=400;local vv=35.03;if pA>10000 then vl=51200;vv=5480 elseif pA>1300 then vl=6400;vv=988.67 elseif pA>150 then vl=1600;vv=182.67 end;vk=ox-vv;if a1>0 then vl=vl+vl*a1*0.2 end;vl=vj(vk,vl)local gv=vo(iB[dI])local jz=0;for jA=1,vq do if gv==is(c["atmofueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vw={iB[dI],string.sub(gv,1,12),vl,vv,vk,jB,jz}ci[#ci+1]=vw end;if type=="Rocket Fuel Tank"then local vl=320;local vv=173.42;if pA>65000 then vl=40000;vv=25740 elseif pA>6000 then vl=5120;vv=4720 elseif pA>700 then vl=640;vv=886.72 end;vk=ox-vv;if a3>0 then vl=vl+vl*a3*0.1 end;vl=vj(vk,vl)local gv=vo(iB[dI])local jz=0;for jA=1,vs do if gv==is(c["rocketfueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vw={iB[dI],string.sub(gv,1,12),vl,vv,vk,jB,jz}ck[#ck+1]=vw end;if type=="Space Fuel Tank"then local vl=600;local vv=35.03;if pA>10000 then vl=76800;vv=5480 elseif pA>1300 then vl=9600;vv=988.67 elseif pA>150 then vl=2400;vv=182.67 end;vk=ox-vv;if a2>0 then vl=vl+vl*a2*0.2 end;vl=vj(vk,vl)local gv=vo(iB[dI])local jz=0;for jA=1,vr do if gv==is(c["spacefueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vw={iB[dI],string.sub(gv,1,12),vl,vv,vk,jB,jz}cj[#cj+1]=vw end end end;if not cM then b8,aZ=false,false end end;local function vx()if gyro~=nil then cf=gyro.isActive()==1 end;if not bA then iv:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u7(1)else u7(0)end;if door and(cb or not cb and cd<10000)then for dN,du in pairs(door)do du.toggle()end end;if switch then for dN,du in pairs(switch)do du.toggle()end end;if forcefield and(cb or not cb==0 and cd<10000)then for dN,du in pairs(forcefield)do du.toggle()end end;if antigrav then cN=antigrav.isActive()==1;if cN and not q then antigrav.showWidget()end end;if iu()==1 and k then uT.freeze(1)else uT.freeze(0)end;if bS then if ca~=-1 and not cN then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bl=d.control.isAnyLandingGearDeployed()==1 or ca~=-1 and ca-3<Y;if ca~=-1 or not cb and cG:len()<50 then a_="Startup"else a_=false end;iv:setTargetGroundAltitude(uW)pm=cb end;local function vy()local vz={}local function vA()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vB={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vC={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vD,vE in pairs(e)do e[vD][0]=vA()e[vD][0].systemId=vD;vz[vD]={}for vF,kq in pairs(e[vD])do kq.gravity=kq.gravity/9.8;kq.center=vec3(kq.center)kq.name=kq.name[1]kq.noAtmosphericDensityAltitude=vC[kq.id]or kq.atmosphereThickness or kq.atmosphereRadius-kq.radius;kq.spaceEngineMinAltitude=vB[kq.id]or 0.68377*kq.atmosphereThickness;kq.planetarySystemId=vD;kq.bodyId=kq.id;vz[vD][vF]=kq;if my==nil or kq.center.x<my then my=kq.center.x end;if mx==nil or kq.center.x>mx then mx=kq.center.x end;if mB==nil or kq.center.y<mB then mB=kq.center.y end;if mA==nil or kq.center.y>mA then mA=kq.center.y end;if kq.center and kq.name~="Space"then d1[#d1+1]=kq end end end;eb=dg(d,b,c,a,dh,di,dj,dk,dl)cl=eb(vz)cm=eV(d,b,c,a,dk,eW)cn=fo(d,b,c,a,dh,di,dj,dk,dl)cp=fO(d,b,c,a,dbHud_1,e,fP,fQ,bJ,dj,dk,fR,fS)kq=cl[0]:closestBody(bL.getWorldPosition())end;vG=false;vH=coroutine.create(function()iv:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})ve()coroutine.yield()vi()coroutine.yield()cq=pE(d,b,c,e,vBooster,hover,pF,antigrav,warpdrive,dbHud_1,eW,bJ,bK,iu,eR,bI,di,iv,fP,iw,dk,fS,fR,ix,dl,iz,iA,pG,is,dh,fQ)vx()coroutine.yield()vy()if radar_1 then cr=gI(b,a,c,library,radar_1,radar_2,warpdrive,eW,gK,dk,gL,dj,gM,fR)end;if iq then co=iq(d,b,c,a,e,antigrav,hover,shield,warpdrive,ir,eW,bJ,dh,is,bK,it,iu,eR,bI,di,iv,fQ,fP,gK,iw,dk,fS,gL,fR,ix,iy,iz,iA,iB,iC)end;if co then co.ButtonSetup()end;cs=u5(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,u6,iu,iv,iw,u7,gK,fS,e1,dj,di,fR,iy,pG)if shield then ct=i8(shield,e1,bJ)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if u6 then u6.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aS)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vI then vJ.ExtraOnStart()end;fR("start","SU")end)coroutine.resume(vH)end;function uU.onUpdate()if not vG then local i1=coroutine.status(vH)if i1=="suspended"then local dJ,i2=coroutine.resume(vH)if i2 then a.print("ERROR STARTUP: "..i2)end elseif i1=="dead"then vG=true end end;if vG then d:update()if cb and t and cO then if cO and bR then cq.cmdThrottle(0)bR=false elseif not cO and not bR then bN=0;bR=true end end;if d4 then iv:setThrottleCommand(axisCommandId.longitudinal,d4)d4=nil end;if not cu and pa~=vK then a.setScreen(pa)end;vK=pa;if vI then vJ.ExtraOnUpdate()end end end;function uU.onFlush()if vG then cq.onFlush()if vI then vJ.ExtraOnFlush()end end end;function uU.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cc>0 or cc==0 and cd<10000)then for dN,du in pairs(door)do du.toggle()end end;if switch then for dN,du in pairs(switch)do du.toggle()end end;if forcefield and(cc>0 or cc==0 and cd<10000)then for dN,du in pairs(forcefield)do du.toggle()end end;w=d3;pG()if o6 then o6.activate()end;if z then cq.showWayPoint(kq,cL)end;if co then a.print(co.FuelUsed("atmofueltank")..", "..co.FuelUsed("spacefueltank")..", "..co.FuelUsed("rocketfueltank"))end;if vI then vJ.ExtraOnStop()end;fR("stop","SU")end;function uU.controlStart(ug)if vG then cs.startControl(ug)end end;function uU.controlStop(ug)if vG then cs.stopControl(ug)end end;function uU.controlLoop(ug)if vG then cs.loopControl(ug)end end;function uU.controlInput(r6)if vG then cs.inputTextControl(r6)end end;function uU.radarEnter(dS)if cr then cr.onEnter(dS)end end;function uU.radarLeave(dS)if cr then cr.onLeave(dS)end end;function uU.onTick(vL)if vL=="tenthSecond"then cq.TenthTick()if co then co.TenthTick()end elseif vL=="oneSecond"then if co then co.OneSecondTick()end elseif vL=="fiveSecond"then cq.SatNavTick()elseif vL=="msgTick"then if co then co.MsgTick()end elseif vL=="animateTick"then if co then co.AnimateTick()end elseif vL=="hudTick"then if co then co.hudtick()end elseif vL=="apTick"then cq.APTick()elseif vL=="shieldTick"then ct.shieldTick()elseif vL=="tagTick"then cs.tagTick()elseif vL=="contact"then cr.ContactTick()end end;if vI then for dI,du in pairs(vI)do uU[dI]=du end end;return uU end;function script.onStart()vJ.onStart()end;function script.onOnStop()vJ.onStop()end;function script.onTick(vL)vJ.onTick(vL)end;function script.onOnFlush()vJ.onFlush()end;function script.onOnUpdate()vJ.onUpdate()end;function script.onActionStart(ug)vJ.controlStart(ug)end;function script.onActionStop(ug)vJ.controlStop(ug)end;function script.onActionLoop(ug)vJ.controlLoop(ug)end;function script.onInputText(r6)vJ.controlInput(r6)end;function script.onEnter(dS)vJ.radarEnter(dS)end;function script.onLeave(dS)vJ.radarLeave(dS)end;bH(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vJ=uS(d,core,unit,e,vBooster,hover,pF,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ir,u6)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
