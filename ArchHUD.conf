name: ArchHud - Archaegeo v1.351 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.351;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;sounds=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized","sounds"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local function x(num,y)local z=10^(y or 0)return d(num*z+0.5)/z end;local A=p()local B=p()local C=16;local D=SafeR;local E=SafeB;local F=SafeG;local G=0;local H=0;local I=false;local J=0;local K=false;local L=x(ResolutionX/2,0)local M=x(ResolutionY/2,0)local N=false;local O=55;local P=false;local Q=false;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=false;local Z=false;local a0="empty"local a1=5;local a2=5;local a3=a1;local a4=a2;local a5=false;local a6,a7=0;local a8,a9=0;local aa=nil;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=0;local ak=false;local al=false;local am=false;local an=-1;local ao=""local ap=j()>0;local aq=j()local ar=core.getAltitude()local as=core.getElementIdList()local at=p()local au=core.getConstructMass()local av=false;local aw=nil;local ax=false;local ay=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]local az=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG={}local aH={}local aI=ResolutionX;local aJ=ResolutionY;local aK=false;local aL=false;local aM=nil;local aN={}local aO={}local aP={}local aQ=0;local aR=false;local aS={}local aT={}local aU=d(1/apTickRate)*2;local aV={}local aW={}local aX={}local aY={}local aZ=false;local a_=0;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=false;local bd=false;local be=autoRollPreference;local bf=LandingGearGroundHeight;local bg=false;local bh=p()local bi=0;local bj=0;local bk=0;local bl=AtmoSpeedLimit;local bm=0;local bn=nil;local bo=0;local bp=0;local bq=false;local br=false;local bs={VectorToTarget=false}local bt=false;local bu=0;local bv=nil;local bw=false;local bx=false;local by=false;local bz=false;local bA=0;local bB=vec3(core.getConstructWorldOrientationUp())local bC=vec3(core.getConstructWorldOrientationForward())local bD=vec3(core.getConstructWorldOrientationRight())local bE=vec3(core.getWorldVelocity())local bF=vec3(bE):len()local bG=vec3(core.getWorldVertical())local bH=-bG:dot(bE)local bI=vec3(core.getConstructWorldPos())local bJ=0;local bK=false;local bL=false;local bM=nil;local bN=true;local bO=0;local bP=0;local bQ=false;local bR={}local bS=showHud;local bT={}local bU=false;local bV=""local bW=""local bX=nil;contacts={}collisionAlertStatus=false;collisionTarget=nil;function getTrueWorldPos()local function bY()local bZ=core.getConstructWorldOrientationRight()local b_=core.getConstructWorldOrientationForward()local c0=core.getConstructWorldOrientationUp()local c1=library.systemResolution3(bZ,b_,c0,{1,0,0})local c2=library.systemResolution3(bZ,b_,c0,{0,1,0})local c3=library.systemResolution3(bZ,b_,c0,{0,0,1})return function(c4)return library.systemResolution3(c1,c2,c3,c4)end end;local c5=bY()local c6=core.getConstructWorldPos()local c7=core.getElementPositionById(1)local c8={c7[1]-C,c7[2]-C,c7[3]-C}local c9=c5(c8)local ca={c6[1]-c9[1],c6[2]-c9[2],c6[3]-c9[3]}return ca end;local function cb(cc,cd,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"or not sounds then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..cc.."|"..cd.."|"..soundVolume)end end;local function ce(cf,cg)for i=1,#cg do cf[#cf+1]=cg[i]end;return cf end;local function ch(ci)local cj={}local ck={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cl={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local cm={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cn={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not ci then ce(cj,ck)ce(cj,cl)ce(cj,cm)ce(cj,cn)return cj elseif ci=="boolean"then return ck elseif ci=="handling"then return cl elseif ci=="hud"then return cm elseif ci=="physics"then return cn end end;local function co(cp,cq,cr,cs,ct)if cs==nil then cs=""end;if ct==nil then ct=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cs,cp,cq,ct,cr)end;local function cu(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cw then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,cv)G=q(x(cv*100,0)/100,-1,1)end;local function cx(cv,cw)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cw then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,cv)bM=cv end;local function cy(cz,cA)if cz==0 then return c(cA)<1e-09 end;if cA==0 then return c(cz)<1e-09 end;return c(cz-cA)<math.max(c(cz),c(cA))*epsilon end;local function cB(ah,cC)local cD=ah>100000;if cC==nil then cC=1 end;if cD then return x(ah/1000/200,cC).."SU"elseif ah<1000 then return x(ah,cC).."M"else return x(ah/1000,cC).."KM"end end;local function cE()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;be=true;ad=0;if ap and an==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cx(d(bl))end else bw=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cF()bw=false;bo=nil;bp=nil;bA=0;if aq==0 then if IntoOrbit then cb("orOff","AP")IntoOrbit=false;bq=false;bv=nil;be=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bs.VectorToTarget=false;bs.AutopilotAlign=false;bt=false elseif unit.getClosestPlanetInfluence()>0 then cb("orOn","AP")IntoOrbit=true;be=true;if bv==nil then bv=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a0="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bq=false;bv=nil;be=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bs.VectorToTarget=false;bs.AutopilotAlign=false;bt=false end end;local function cG()if A-bj<1.5 then if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;cb("11","EP")else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bu=HoldAltitude;bt=true;if not IntoOrbit then cF()end;bq=true end end;bj=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bj=A end;if unit.getClosestPlanetInfluence()>0 and aq==0 then bu=ar;bt=true;bq=true;cF()if IntoOrbit then bj=A else bj=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Y=false;be=true;LockPitch=nil;bw=false;if an==-1 then cb("altOn","AH")AutoTakeoff=false;if bj>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=ar end end;if VertTakeOff then cE()end else cb("lfs","LS")AutoTakeoff=true;if bj>-1 then HoldAltitude=ar+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bK then cE()end end;if al then HoldAltitude=100000 end else cb("altOff","AH")if IntoOrbit then cF()end;if VertTakeOff then cE()end;be=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bj=0 end end;local function cH()if l()==1 then Y=not Y;if Y then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)cb("folOn","F")else cb("folOff","F")BrakeIsOn=true;be=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else a0="Follow Mode only works with Remote controller"Y=false end end;local function cI()local function cJ(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cG()end end;VectorStatus="Proceeding to Waypoint"end;if A-bk<1.5 and aq>0 then if not bz then a0="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if aq>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;cb("orH","OH")end;bk=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bk=A end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not al and not IntoOrbit then ba.UpdateAutopilotTarget()bb.showWayPoint(aa,AutopilotTargetCoords)local cK=unit.getClosestPlanetInfluence()>0;if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then cb("apSpc","AP")if aq~=0 then al=true;cG()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if aq>0 then if not VectorToTarget then cb("vtt","AP")cJ(SpaceTarget)end else cb("apOn","AP")if not(aa.name==planet.name and cK)then bw=false;Autopilot=true elseif not ap then if IntoOrbit then cF()end;bu=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bt=true;bs.AutopilotAlign=true;bs.VectorToTarget=true;bq=false;if not IntoOrbit then cF()end end end else cb("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if aq~=0 then al=true;cG()else Autopilot=true end end elseif aq==0 then if CustomTarget==nil and(aa.name==planet.name and cK)and not IntoOrbit then WaypointSet=false;bw=false;bq=false;cF()else cb("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Y=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;N=false;LockPitch=nil;WaypointSet=false end else cb("apP","AP")al=true;cG()end else cb("apOff","AP")al=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;N=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=ar;TargetSet=false;Reentry=false;if IntoOrbit then cF()end end end;local function cL(cM)local cN=-1;local cO;cN=ba.findAtlasIndex(SavedLocations)if cN~=-1 then local cP;if cM~=nil then cO={position=SavedLocations[cN].position,name=cM,atmosphere=SavedLocations[cN].atmosphere,planetname=SavedLocations[cN].planetname,gravity=SavedLocations[cN].gravity}else cO={position=bI,name=SavedLocations[cN].name,atmosphere=aq,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cN]=cO;cN=-1;cN=ba.findAtlasIndex(b0[0])if cN>-1 then b0[0][cN]=cO end;ba.UpdateAtlasLocationsList()a0=CustomTarget.name.." position updated"ba.UpdateAutopilotTarget()else a0="Name Not Found"end end;local function cQ()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;be=autoRollPreference end;if BrakeIsOn then cb("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bX=nil;if not bL then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cE()end;if IntoOrbit then cF()end;be=autoRollPreference;ak=false;am=false;ad=0 else cb("bkOff","B",1)end end;local function cR(cS,cT,cU)local function cV(cS,cW)cS=vec3(cS)cW=vec3(cW):normalize()local cX=cS*cW;return cX.x+cX.y+cX.z end;local cY=0.001;local cZ=1;if not ap or not bg or an~=-1 or bF<O then if cU==nil then cU=DampingMultiplier end;if cT==nil then cT=cY end;cS=vec3(cS):normalize()local c_=vec3()-cS;local d0=-cV(c_,core.getConstructWorldOrientationRight())*cZ;local d1=-cV(c_,core.getConstructWorldOrientationUp())*cZ;if aB==0 then aB=d0/2 end;if aC==0 then aC=d1/2 end;if c(d0)<0.1 then T=T-d0*2 else T=T-(d0+(d0-aB)*cU)end;if c(d1)<0.1 then S=S+d1*2 else S=S+d1+(d1-aC)*cU end;aB=d0;aC=d1;if c(d0)<cT and c(d1)<cT then return true end;return false elseif bg and an==-1 then cS=bE;if cU==nil then cU=DampingMultiplier end;if cT==nil then cT=cY end;cS=vec3(cS):normalize()local c_=bC-cS;local d0=-cV(c_,core.getConstructWorldOrientationRight())*cZ;local d1=-cV(c_,core.getConstructWorldOrientationUp())*cZ;if aB==0 then aB=d0/2 end;if aC==0 then aC=d1/2 end;if c(d0)<0.1 then T=T-d0*5 else T=T-(d0+(d0-aB)*cU)end;if c(d1)<0.1 then S=S+d1*5 else S=S+d1+(d1-aC)*cU end;aB=d0;aC=d1;if c(d0)<cT and c(d1)<cT then return true end;return false end end;local function d2()if Reentry then a0="Re-Entry cancelled"cb("reOff","RE")Reentry=false;be=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not P then Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;be=true;BrakeIsOn=false;a0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bl;cb("par","RE")else Reentry=true;AltitudeHold=true;be=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cr=cB(HoldAltitude)a0="Beginning Re-entry.  Target speed: "..bl.." Target Altitude: "..cr;cb("glide","RE")cx(d(bl))end;AutoTakeoff=false end;local function d3()if antigrav and not ExternalAGG then if bL then cb("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;cb("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function d4(d5)local d6=0;local d7=0;local d8=0;if d5<60 then d5=d(d5)elseif d5<3600 then d6=d(d5/60)d5=d(d5%60)elseif d5<86400 then d7=d(d5/3600)d6=d(d5%3600/60)else d8=d(d5/86400)d7=d(d5%86400/3600)end;if d8>0 then return d8 .."d "..d7 .."h "elseif d7>0 then return d7 .."h "..d6 .."m "elseif d6>0 then return d6 .."m "..d5 .."s"elseif d5>0 then return d5 .."s"else return"0s"end end;local function d9(da)local function db(dc)for dd,de in pairs(dc)do dbHud_1.setStringValue(de,g(_G[de]))if da and dbHud_2 then dbHud_2.setStringValue(de,g(_G[de]))end end end;if dbHud_1 then db(b)db(ch())system.print("Saved Variables to Datacore")if da and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end;local function df()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function dg()local function dh(di)return type(di)=='number'end;local function dj(di)return type(tonumber(di))=='number'end;local function dk(dl)return type(dl)=='table'end;local function dm(dn)return type(dn)=='string'end;local function dp(de)return dk(de)and dh(de.x and de.y and de.z)end;local function dq(dr)return dk(dr)and dh(dr.latitude and dr.longitude and dr.altitude and dr.bodyId and dr.systemId)end;local ds=math.pi/180;local dt=180/math.pi;local epsilon=1e-10;local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..num..','..num..','..num..','..num..','..num..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dv(di)local cX=string.gsub(string.reverse(e('%.4f',di)),'^0*%.?','')return cX==''and'0'or string.reverse(cX)end;local function dw(dx)if dp(dx)then return e('{x=%.3f,y=%.3f,z=%.3f}',dx.x,dx.y,dx.z)end;if dk(dx)and not getmetatable(dx)then local dy={}local dz=next(dx)if type(dz)=='nil'or dz==1 then dy=dx else for dd,de in pairs(dx)do local cv=dw(de)if type(dd)=='number'then table.insert(dy,e('[%s]=%s',dd,cv))else table.insert(dy,e('%s=%s',dd,cv))end end end;return e('{%s}',table.concat(dy,','))end;if dm(dx)then return e("'%s'",dx:gsub("'",[[\']]))end;return tostring(dx)end;local dA={}dA.__index=dA;dA.__tostring=function(dx,dB)local dC={}for dd in pairs(dx)do table.insert(dC,dd)end;table.sort(dC)local dy={}for _,dd in ipairs(dC)do local cv=dw(dx[dd])if type(dd)=='number'then table.insert(dy,e('[%s]=%s',dd,cv))else table.insert(dy,e('%s=%s',dd,cv))end end;if dB then return e('%s%s',dB,table.concat(dy,',\n'..dB))end;return e('{%s}',table.concat(dy,','))end;dA.__eq=function(dD,dE)return dD.planetarySystemId==dE.planetarySystemId and dD.bodyId==dE.bodyId and cy(dD.radius,dE.radius)and cy(dD.center.x,dE.center.x)and cy(dD.center.y,dE.center.y)and cy(dD.center.z,dE.center.z)and cy(dD.GM,dE.GM)end;local function dF(dG,dH,dI,dJ,dK)assert(dj(dG),'Argument 1 (planetarySystemId) must be a number:'..type(dG))assert(dj(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(dj(dI),'Argument 3 (radius) must be a number:'..type(dI))assert(dk(dJ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dJ))assert(dj(dK),'Argument 5 (GM) must be a number:'..type(dK))return setmetatable({planetarySystemId=tonumber(dG),bodyId=tonumber(dH),radius=tonumber(dI),center=vec3(dJ),GM=tonumber(dK)},dA)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dL)return e('::pos{%d,%d,%s,%s,%s}',dL.systemId,dL.bodyId,dv(dL.latitude*dt),dv(dL.longitude*dt),dv(dL.altitude))end;MapPosition.__eq=function(dD,dE)return dD.bodyId==dE.bodyId and dD.systemId==dE.systemId and cy(dD.latitude,dE.latitude)and cy(dD.altitude,dE.altitude)and(cy(dD.longitude,dE.longitude)or cy(dD.latitude,math.pi/2)or cy(dD.latitude,-math.pi/2))end;local function dM(dN,dH,dO,dP,dQ)local dG=dN;if dm(dN)and not dP and not dQ and not dH and not dO then dG,dH,dO,dP,dQ=n(dN,du)assert(dG,'Argument 1 (position string) is malformed.')else assert(dj(dG),'Argument 1 (systemId) must be a number:'..type(dG))assert(dj(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(dj(dO),'Argument 3 (latitude) must be in degrees:'..type(dO))assert(dj(dP),'Argument 4 (longitude) must be in degrees:'..type(dP))assert(dj(dQ),'Argument 5 (altitude) must be in meters:'..type(dQ))end;dG=tonumber(dG)dH=tonumber(dH)dO=tonumber(dO)dP=tonumber(dP)dQ=tonumber(dQ)if dH==0 then return setmetatable({latitude=dO,longitude=dP,altitude=dQ,bodyId=dH,systemId=dG},MapPosition)end;return setmetatable({latitude=ds*q(dO,-90,90),longitude=ds*(dP%360),altitude=dQ,bodyId=dH,systemId=dG},MapPosition)end;local dR={}dR.__index=dR;dR.__tostring=function(dx,dB)local dS=dB and dB..'  'local dT={}local dC={}for dd in pairs(dx)do table.insert(dC,dd)end;table.sort(dC)for _,dU in ipairs(dC)do bdy=dx[dU]local dV=dA.__tostring(bdy,dS)if dB then table.insert(dT,e('[%s]={\n%s\n%s}',dU,dV,dB))else table.insert(dT,e('  [%s]=%s',dU,dV))end end;if dB then return e('\n%s%s%s',dB,table.concat(dT,',\n'..dB),dB)end;return e('{\n%s\n}',table.concat(dT,',\n'))end;local function dW(dX)local b0={}local pid;for _,de in pairs(dX)do local dY=de.planetarySystemId;if type(dY)~='number'then error('Invalid planetary system ID: '..tostring(dY))elseif pid and dY~=pid then error('Mistringmatch planetary system IDs: '..dY..' and '..pid)end;local dZ=de.bodyId;if type(dZ)~='number'then error('Invalid body ID: '..tostring(dZ))elseif b0[dZ]then error('Duplicate body ID: '..tostring(dZ))end;setmetatable(de.center,getmetatable(vec3.unit_x))b0[dZ]=setmetatable(de,dA)pid=dY end;return setmetatable(b0,dR)end;b4={}local function d_(dX)return setmetatable({galaxyAtlas=dX or{}},b4)end;b4.__index=function(dl,i)if type(i)=='number'then local system=dl.galaxyAtlas[i]return dW(system)end;return rawget(b4,i)end;b4.__pairs=function(dx)return function(dl,dd)local e0,nv=next(dl,dd)return e0,nv and dW(nv)end,dx.galaxyAtlas,nil end;b4.__tostring=function(dx)local e1={}for _,e2 in pairs(dx or{})do local e3=e2:getPlanetarySystemId()local e4=dR.__tostring(e2,'    ')table.insert(e1,e('  [%s]={%s\n  }',e3,e4))end;return e('{\n%s\n}\n',table.concat(e1,',\n'))end;b4.BodyParameters=dF;b4.MapPosition=dM;b4.PlanetarySystem=dW;function b4.createBodyParameters(e5,dH,e6,e7,e8,e9,ea)assert(dj(e5),'Argument 1 (planetarySystemId) must be a number:'..type(e5))assert(dj(dH),'Argument 2 (bodyId) must be a number:'..type(dH))assert(dj(e6),'Argument 3 (surfaceArea) must be a number:'..type(e6))assert(dk(e7),'Argument 4 (aPosition) must be an array or vec3:'..type(e7))assert(dk(e8),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(e8))assert(dj(e9),'Argument 6 (altitude) must be in meters:'..type(e9))assert(dj(ea),'Argument 7 (gravityAtPosition) must be number:'..type(ea))local dI=math.sqrt(e6/4/math.pi)local ah=dI+e9;local eb=vec3(e7)+ah*vec3(e8)local dK=ea*ah*ah;return dF(e5,dH,dI,eb,dK)end;b4.isMapPosition=dq;function b4:getPlanetarySystem(dN)if i==nil then i=0 end;if nv==nil then nv=0 end;local e5=dN;if dq(dN)then e5=dN.systemId end;if type(e5)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dR then system=dW(system)end;return system end end end;function dR:castIntersections(ec,cW,ed,ee,ef)local ed=ed or function(eg)return 1.05*eg.radius end;local eh={}local ei;if ef then ei=ef else ei=self end;if ee then for _,i in ipairs(ee)do eh[i]=ei[i]end else ee={}for dd,eg in pairs(ei)do table.insert(ee,dd)eh[dd]=eg end end;local function ej(ek,el)local bZ=eh[ek].center-ec;local b_=eh[el].center-ec;return bZ:len()<b_:len()end;table.sort(ee,ej)local em=cW:normalize()for i,dY in ipairs(ee)do local eg=eh[dY]local en=eg.center-ec;local dI=ed(eg)local eo=en:dot(em)local ep=eo^2-(en:len2()-dI^2)if ep>=0 then local eq=math.sqrt(ep)local er=eo+eq;local es=eo-eq;if es>0 then return eg,er,es elseif er>0 then return eg,er,nil end end end;return nil,nil,nil end;function dR:closestBody(et)assert(type(et)=='table','Invalid coordinates.')local eu,eg;local ev=vec3(et)for _,ew in pairs(self)do local ex=(ew.center-ev):len2()if(not eg or ex<eu)and ew.name~="Space"then eg=ew;eu=ex end end;return eg end;function dR:convertToBodyIdAndWorldCoordinates(dN)local ey=dN;if dm(dN)then ey=dM(dN)end;if ey.bodyId==0 then return 0,vec3(ey.latitude,ey.longitude,ey.altitude)end;local ew=self:getBodyParameters(ey)if ew then return ey.bodyId,ew:convertToWorldCoordinates(ey)end end;function dR:getBodyParameters(dN)local dH=dN;if dq(dN)then dH=dN.bodyId end;assert(dj(dH),'Argument 1 (bodyId) must be a number:'..type(dH))return self[dH]end;function dR:getPlanetarySystemId()local _,de=next(self)return de and de.planetarySystemId end;function dA:convertToMapPosition(dJ)assert(dk(dJ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dJ))local ez=vec3(dJ)if self.bodyId==0 then return setmetatable({latitude=ez.x,longitude=ez.y,altitude=ez.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local eA=ez-self.center;local ah=eA:len()local dQ=ah-self.radius;local dO=0;local dP=0;if not cy(ah,0)then local eB=m(eA.y,eA.x)dP=eB>=0 and eB or 2*math.pi+eB;dO=math.pi/2-math.acos(eA.z/ah)end;return setmetatable({latitude=dO,longitude=dP,altitude=dQ,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dA:convertToWorldCoordinates(dN)local ey=dm(dN)and dM(dN)or dN;if ey.bodyId==0 then return vec3(ey.latitude,ey.longitude,ey.altitude)end;assert(dq(ey),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ey.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ey.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local eC=math.cos(ey.latitude)return self.center+(self.radius+ey.altitude)*vec3(eC*math.cos(ey.longitude),eC*math.sin(ey.longitude),math.sin(ey.latitude))end;function dA:getAltitude(dJ)return(vec3(dJ)-self.center):len()-self.radius end;function dA:getDistance(dJ)return(vec3(dJ)-self.center):len()end;function dA:getGravity(dJ)local eD=self.center-vec3(dJ)local eE=eD:len2()return self.GM/eE*eD/math.sqrt(eE)end;return setmetatable(b4,{__call=function(_,...)return d_(...)end})end;local function eF()local b6={}local eG=30000000/3600;local eH=eG*eG;local eI=100;local function eJ(de)return 1/math.sqrt(1-de*de/eH)end;function b6.computeAccelerationTime(eK,eL,eM)local eN=eG*math.asin(eK/eG)return(eG*math.asin(eM/eG)-eN)/eL end;function b6.computeDistanceAndTime(eK,eM,eO,eP,eQ,eR)eQ=eQ or 0;eR=eR or 0;local eS=eK<=eM;local eT=eP*(eS and 1 or-1)/eO;local eU=-eR/eO;local eV=eT+eU;if eS and eV<=0 or not eS and eV>=0 then return-1,-1 end;local eW,eX=0,0;if eT~=0 and eQ>0 then local eN=math.asin(eK/eG)local eY=math.pi*(eT/2+eU)local eZ=eT*eQ;local e_=eG*math.pi;local de=function(dl)local f0=(eY*dl-eZ*math.sin(math.pi*dl/2/eQ)+e_*eN)/e_;local f1=math.tan(f0)return eG*f1/math.sqrt(f1*f1+1)end;local f2=eS and function(dn)return dn>=eM end or function(dn)return dn<=eM end;eX=2*eQ;if f2(de(eX))then local f3=0;while c(eX-f3)>0.5 do local dl=(eX+f3)/2;if f2(de(dl))then eX=dl else f3=dl end end end;local f4=eK;local f5=eX/eI;for f6=1,eI do local f7=de(f6*f5)eW=eW+(f7+f4)*f5/2;f4=f7 end;if eX<2*eQ then return eW,eX end;eK=f4 end;local eN=eG*math.asin(eK/eG)local A=(eG*math.asin(eM/eG)-eN)/eV;local f8=eH*math.cos(eN/eG)/eV;local ah=f8-eH*math.cos((eV*A+eN)/eG)/eV;return ah+eW,A+eX end;function b6.computeTravelTime(eK,eL,ah)if ah==0 then return 0 end;if eL>0 then local eN=eG*math.asin(eK/eG)local f8=eH*math.cos(eN/eG)/eL;return(eG*math.acos(eL*(f8-ah)/eH)-eN)/eL end;if eK==0 then return-1 end;assert(eK>0,'Acceleration and initial speed are both zero.')return ah/eK end;function b6.lorentz(de)return eJ(de)end;return b6 end;local function f9()local vec3=require('cpml.vec3')local dg=dg()local function dm(dn)return type(dn)=='string'end;local function dk(dl)return type(dl)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dQ)assert(self.body)local ah=dQ+self.body.radius;if not cy(ah,0)then local orbit=math.sqrt(self.body.GM/ah)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dN,fa)assert(self.body)assert(dk(dN)or dm(dN))assert(dk(fa))local c7=(dm(dN)or dg.isMapPosition(dN))and self.body:convertToWorldCoordinates(dN)or vec3(dN)local de=vec3(fa)local fb=c7-self.body.center;local b_=de:len2()local fc=fb:len()local fd=self.body.GM;local fe=((b_-fd/fc)*fb-fb:dot(de)*de)/fd;local cz=fd/(2*fd/fc-b_)local ff=fe:len()local em=fe:normalize()local fg=cz*(1-ff)local fh=cz*(1+ff)local fi=fg*em+self.body.center;local fj=ff<=1 and-fh*em+self.body.center or nil;local fk=math.sqrt(cz*fd*(1-ff*ff))local fl=fj and 2*math.pi*math.sqrt(cz^3/fd)local fm=math.acos(fe:dot(fb)/(ff*fc))if fb:dot(de)<0 then fm=-(fm-2*math.pi)end;local fn=math.acos((math.cos(fm)+ff)/(1+ff*math.cos(fm)))local fo=fn;if fo<0 then fo=fo+2*math.pi end;local fp=fo-ff*math.sin(fo)local fq=0;local fr=0;local fs=0;if fl~=nil then fq=fp/(2*math.pi/fl)fr=fl-fq;fs=fr+fl/2;if fm-math.pi>0 then fr=fq;fs=fr+fl/2 end;if fs>fl then fs=fs-fl end end;return{periapsis={position=fi,speed=fk/fg,circularOrbitSpeed=math.sqrt(fd/fg),altitude=fg-self.body.radius},apoapsis=fj and{position=fj,speed=fk/fh,circularOrbitSpeed=math.sqrt(fd/fh),altitude=fh-self.body.radius},currentVelocity=de,currentPosition=c7,eccentricity=ff,period=fl,eccentricAnomaly=fn,meanAnomaly=fp,timeToPeriapsis=fr,timeToApoapsis=fs}end;local function ft(fu)local ew=dg.BodyParameters(fu.planetarySystemId,fu.bodyId,fu.radius,fu.center,fu.GM)return setmetatable({body=ew},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return ft(...)end})end;local function fv()local fw=0;local function fx(fy)local dI=500000;local fz,fA,fB=math.huge;local fC=false;local fD=vec3({13771471,7435803,-128971})local fE=18000000;fz=vec3(fy):dist(fD)if fz<fE then return true,c(fz-fE),"Safe Zone",0 end;fA=vec3(fy):dist(vec3(planet.center))if fA<dI then fC=true end;if c(fA-dI)<c(fz-fE)then return fC,c(fA-dI),planet.name,planet.bodyId else return fC,c(fz-fE),"Safe Zone",0 end end;local function fF(de)if aI==1920 then return de else return x(aI*de/1920,0)end end;local function fG(de)if aJ==1080 then return de else return x(aJ*de/1080,0)end end;local function fH()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fI()local fJ="TRAVEL"if not bN then fJ="CRUISE"end;if Autopilot then fJ="AUTOPILOT"end;return fJ end;local function fK(fL,aZ,cp,fM,fN,fO,fP,fQ)local fR=1;local fS=2;local fT=3;local fU=4;local fV=5;local fW=6;local fX=""local fY=0;local fZ=fuelY;local f_=fuelY+5;if not BarFuelDisplay then f_=f_+5 end;if l()==1 and not RemoteHud then fZ=fZ-50;f_=f_-50 end;if fN=="ATMO"then fX="atmofueltank"elseif fN=="SPACE"then fX="spacefueltank"else fX="rocketfueltank"end;fY=_G[fX.."_size"]if#fO>0 then for i=1,#fO do local g0=string.sub(fO[i][fS],1,12)local g1=0;for g2=1,fY do if fO[i][fS]==f(unit[fX.."_"..g2].getData()).name then g1=g2;break end end;if aZ or fP[i]==nil or fQ[i]==nil then local g3=0;local g4=0;local g5=0;local g6=0;local g7=p()if g1~=0 then fQ[i]=f(unit[fX.."_"..g1].getData()).percentage;fP[i]=f(unit[fX.."_"..g1].getData()).timeLeft;if fP[i]=="n/a"then fP[i]=0 end else g5=k(fO[i][fR])-fO[i][fU]g3=fO[i][fT]fQ[i]=d(0.5+g5*100/g3)g4=fO[i][fV]g6=fO[i][fW]if g4<=g5 then fP[i]=0 else fP[i]=d(0.5+g5/((g4-g5)/(g7-g6)))end;fO[i][fV]=g5;fO[i][fW]=g7 end end;if g0==fM then g0=e("%s %d",fN,i)end;if g1==0 then g0=g0 .." *"end;local g8;if fP[i]==0 then g8=""else g8=d4(fP[i])end;if fQ[i]~=nil then local g9=d(fQ[i]*2.55)local ga=e("rgb(%d,%d,%d)",255-g9,g9,0)local cs=""if g8~=""and fP[i]<120 or fQ[i]<5 then if aZ then cs=[[class="red"]]end end;if BarFuelDisplay then table.insert(fL,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cp,f_,ga,fQ[i],cp,f_,cp+2,f_+10,fQ[i],g8))fL[#fL+1]=co(cp,fZ,g0,cs.."txtstart pdim txtfuel")fZ=fZ-30;f_=f_-30 else fL[#fL+1]=co(cp,fZ,g0,cs.." pdim txtfuel")fL[#fL+1]=co(cp,f_,e("%d%% %s",fQ[i],g8),"pdim txtfuel","fill:"..ga)fZ=fZ+30;f_=f_+30 end end end end end;local function gb(fL,dQ)if dQ<200000 and not ap or dQ and ap then local gc=0;if c(bH)>1 then gc=45*math.log(c(bH),10)if bH<0 then gc=-gc end end;fL[#fL+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bH),d(gc))end;return fL end;local function gd(ge)local gf=-bG;ge=ge-ge:project_on(gf)local gg=vec3(0,0,1)gg=gg-gg:project_on(gf)local gh=gg:cross(gf)local gc=gg:angle_between(ge)*constants.rad2deg;if ge:dot(gh)<0 then gc=360-gc end;return gc end;local function gi(fL,centerX,centerY,gj,gk,cK)local gl=circleRad;local gm=20;local gn=d(gj)if cK then for i=-45,45,5 do local go=i;fL[#fL+1]=e([[<g transform="rotate(%f,%d,%d)">]],go,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fL[#fL+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+gl+gm-len,centerX,centerY+gl+gm)end;fL[#fL+1]=co(centerX,centerY+gl+gm-35,gk,"pdim txt txtmid")fL[#fL+1]=co(centerX,centerY+gl+gm-25,gn.." deg","pdim txt txtmid")fL[#fL+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gj,centerX,centerY)fL[#fL+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+gl+gm-20,centerX+5,centerY+gl+gm-20,centerX,centerY+gl+gm-15)fL[#fL+1]="</g>"end;local gp=gn;if cK then gp=gd(bC)end;local gq=20;local gr=d(gp)local gs=0;local gt=centerY+gl+gm+20;local gu=centerX;if gk~="YAW"then gt=fG(130)gu=fF(960)end;local gv=[[<path class="txttick line" d="]]local gw=d(gr-(gq+10)-gr%5+0.5)for i=gw+60,gw,-5 do local cp=gu-(-i*5+gp*5)if i%10==0 then gs=10;local num=i;if num==360 then num=0 elseif num>360 then num=num-360 elseif num<0 then num=num+360 end;fL[#fL+1]=co(cp+5,gt-12,num)elseif i%5==0 then gs=5 end;if gs==10 then gv=e([[%s M %f %f v %d]],gv,cp,gt-5,gs)else gv=e([[%s M %f %f v %d]],gv,cp,gt-2.5,gs)end end;fL[#fL+1]=gv..[["/>]]fL[#fL+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gu-5,gt+10,gu+5,gt+10,gu,gt+5)if cK then gk="HDG"end;fL[#fL+1]=co(gu,gt+25,gr.."deg","pdim txt txtmid","")fL[#fL+1]=co(gu,gt+35,gk,"pdim txt txtmid","")end;local function gx(fL,gy,gj,centerX,centerY,cK,gz,f7)local gl=circleRad;local gA=d(gl*3/5)if gl>0 then local gB=d(gy)local len=0;local gv=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*gj,centerX,centerY)if not ap then gv=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fL[#fL+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],gl-1,centerX,centerY)fL[#fL+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gB-30-gB%5+0.5),d(gB+30+gB%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cq=centerY+-i*5+gy*5;if len==30 then gv=e([[%s M %d %f h %d]],gv,centerX-gA-len,cq,len)if ap then fL[#fL+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gj,centerX,centerY,centerX-gA+10,cq,i)fL[#fL+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*gj,centerX,centerY,centerX+gA-10,cq,i)if i==0 or i==180 or i==-180 then fL[#fL+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gj,centerX,centerY,centerX-gA+20,cq,gA*2-40)end else fL[#fL+1]=co(centerX-gA+10,cq,i,"pdim txt txtmid")fL[#fL+1]=co(centerX+gA-10,cq,i,"pdim txt txtmid")end;gv=e([[%s M %d %f h %d]],gv,centerX+gA,cq,len)else gv=e([[%s M %d %f h %d]],gv,centerX-gA-len,cq,len)gv=e([[%s M %d %f h %d]],gv,centerX+gA,cq,len)end end;fL[#fL+1]=gv..[["/>]]local gC="PITCH"if not cK then gC="REL PITCH"end;if gy>90 and not ap then gy=90-(gy-90)elseif gy<-90 and not ap then gy=-90-(gy+90)end;if gl>200 then if ap then if f7>O then fL[#fL+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fL[#fL+1]=co(centerX,centerY+20,gz,"pdim txt txtmid")end;fL[#fL+1]=e([[<g transform="rotate(%f,%d,%d)">]],-gj,centerX,centerY)else fL[#fL+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fL[#fL+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gA+25,centerY-5,centerX-gA+20,centerY,centerX-gA+25,centerY+5,centerX-gA+50,centerY+4,gB)fL[#fL+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gA-25,centerY-5,centerX+gA-20,centerY,centerX+gA-25,centerY+5,centerX+gA-30,centerY+4,gB)fL[#fL+1]="</g>"end;local gD=d(gl/3)fL[#fL+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gD,centerY,gl-gD)if not ap and cK then fL[#fL+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*gj,centerX,centerY,centerX-gA+10,centerY,gA*2-20)end;fL[#fL+1]="</g>"if gl<200 then if ap and f7>O then fL[#fL+1]=co(centerX,centerY-gl,gC,"pdim txt txtmid")fL[#fL+1]=co(centerX,centerY-gl+10,gB,"pdim txt txtmid")fL[#fL+1]=co(centerX,centerY-15,"Yaw","pdim txt txtmid")fL[#fL+1]=co(centerX,centerY+20,gz,"pdim txt txtmid")else fL[#fL+1]=co(centerX,centerY-gl,gC,"pdim txt txtmid")fL[#fL+1]=co(centerX,centerY-gl+15,gB,"pdim txt txtmid")end end end end;local function gE(fL,dQ,cK)local gF=altMeterX;local gG=altMeterY;local gH=78;local gI=19;local gJ=an;if an~=-1 then fL[#fL+1]=co(gF+gH,gG+gI+20,e("AGL: %.1fm",an),"pdim altsm txtend")end;if cK and(dQ<200000 and not ap or dQ and ap)then table.insert(fL,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gF-1,gG-4,gH+2,gI+6,gF+1,gG-1,gH-4,gI))local cN=0;local gK=1;local gL=0;local gM=dQ<0;local gN=9;if gM then gN=0 end;local dQ=c(dQ)while cN<6 do local gO=11;local gP=16;local gQ=9;local gR=14;local cs="altsm"if cN>2 then gP=gP+3;gO=gO+2;gR=gR+2;gQ=gQ-6;cs="altbig"end;if gM then cs=cs.." red"end;local gS=dQ/gK%10;local gT=d(gS)local gU=d((gT+1)%10)local gV=gL;if cN==0 then gV=gS-gT;if gM then gV=1-gV end end;if gM and(cN==0 or gL~=0)then local gW=gU;gU=gT;gT=gW end;local gX=gP*(gV-1)local gY=gX+gP;local cp=gF+gQ+(6-cN)*gO;local cq=gG+gR;fL[#fL+1]=co(cp,cq+gX,gU,cs)fL[#fL+1]=co(cp,cq+gY,gT,cs)cN=cN+1;gK=gK*10;if gT==gN then gL=gV else gL=0 end end;table.insert(fL,[[</g></g>]])end end;local function gZ(fa)fa=vec3(fa)local g_=-math.deg(m(fa.y,fa.z))+180;g_=g_-90;if g_<0 then g_=360+g_ end;if g_>180 then g_=-180+g_-180 end;return-g_ end;local function h0(fa)fa=vec3(fa)local gp=math.deg(m(fa.y,fa.x))-90;if gp<-180 then gp=360+gp end;return gp end;local function h1(fL,fa,f7,centerX,centerY)if f7>5 and not ap or f7>O then local gl=circleRad;local h2=20;local h3=20;local h4=vec3(fa)local h5=gZ(h4)local h6=h0(h4)local h7=14;local h8=h7/2;local h9=-h6/h3*gl;local ha=h5/h2*gl;local cp=centerX+h9;local cq=centerY+ha;local ah=math.sqrt(h9^2+ha^2)local hb=[[<circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h8/h7 ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cp..[["
                            cy="]]..cq..[["
                            r="]]..h8 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cp-h7 ..[[,]]..cq..[[ h ]]..h8 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp+h8 ..[[,]]..cq..[[ h ]]..h8 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cp..[[,]]..cq-h7 ..[[ v ]]..h8 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<gl then fL[#fL+1]=hb else local gc=m(ha,h9)local hc=4;local hd=centerX+gl*math.cos(gc)local he=centerY+gl*math.sin(gc)fL[#fL+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gc*180/math.pi,hd,he,hd-hc,he-hc/2,hc*2,hc,hd+hc,he-hc,hc,hc,-hc,hc)end;if not ap then h5=gZ(-h4)h6=h0(-h4)h9=-h6/h3*gl;ha=h5/h2*gl;cp=centerX+h9;cq=centerY+ha;ah=math.sqrt(h9^2+ha^2)if ah<gl then local hf=[[<circle
                                    cx="]]..cp..[["
                                    cy="]]..cq..[["
                                    r="]]..h8 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cp..[[,]]..cq-h7 ..[[ v ]]..h8 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cp..[[,]]..cq..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cp..[[,]]..cq..[[)" />
                                <path
                                    d="M ]]..cp-h8 ..[[,]]..cq..[[ h ]]..h7 ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cp..[[,]]..cq..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cp..[[,]]..cq..[[)"/>]]fL[#fL+1]=hf end end end end;local function hg(fL,fJ,hh,hi)hh=d(hh+0.5)local fZ=throtPosY+10;local f_=throtPosY+20;if l()==1 and not RemoteHud then fZ=55;f_=65 end;local hj="CRUISE"local unit="km/h"local cv=hi;if fJ=="TRAVEL"or fJ=="AUTOPILOT"then hj="THROT"unit="%"cv=hh;local hk="dim"if hh<0 then hk="red"end;fL[#fL+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],hk,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(hh),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fL[#fL+1]=co(throtPosX+10,fZ,hj,"pbright txtstart")fL[#fL+1]=co(throtPosX+10,f_,e("%.0f %s",cv,unit),"pbright txtstart")if ap and AtmoSpeedAssist and bN and I then hh=d(J*100+0.5)local hk="red"if hh<0 then hk="red"end;fL[#fL+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],hk,1-c(hh),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fL[#fL+1]=co(throtPosX+10,fZ+40,"LIMIT","pbright txtstart")fL[#fL+1]=co(throtPosX+10,f_+40,hh.."%","pbright txtstart")end;if ap and AtmoSpeedAssist or Reentry then fL[#fL+1]=co(throtPosX+10,fZ-40,"LIMIT: "..bl.." km/h","dim txtstart")elseif not ap and Autopilot then fL[#fL+1]=co(throtPosX+10,fZ-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function hl(fL,hm)local hn=throtPosY-10;local ho=throtPosX+10;fL[#fL+1]=co(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then hn=75 end;fL[#fL+1]=co(ho,hn,d(hm).." km/h","pbright txtbig txtstart")end;local function hp(fL)fL[#fL+1]=co(fF(1900),fG(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fL[#fL+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fL[#fL+1]=co(fF(960),fG(550),"Warning: Invalid Control Scheme Detected","warnings")fL[#fL+1]=co(fF(960),fG(600),"Keyboard Scheme must be selected","warnings")fL[#fL+1]=co(fF(960),fG(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hq=fF(960)local hr=fG(860)local hs=fG(880)local ht=fG(900)local hu=fG(960)local hv=fG(200)local hw=fG(250)local hx=fG(960)if l()==1 and not RemoteHud then hr=fG(135)hs=fG(155)ht=fG(175)hv=fG(115)hw=fG(95)end;if BrakeIsOn then fL[#fL+1]=co(hq,hr,"Brake Engaged","warnings")elseif H>0 then fL[#fL+1]=co(hq,hr,"Auto-Brake Engaged","warnings","opacity:"..H)end;if ap and bg and an==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bL and not VertTakeOff and not AutoTakeoff then fL[#fL+1]=co(hq,hv+50,"** STALL WARNING **","warnings")cb("stall","SW",2)end end;if bX then fL[#fL+1]=co(hq,hv+70,"Flight Assist in Progress","warnings")end;if aw then fL[#fL+1]=co(hq,hx,"Gyro Enabled","warnings")end;if GearExtended then if Q then fL[#fL+1]=co(hq,hs,"Gear Extended","warn")else fL[#fL+1]=co(hq,hs,"Landed (G: Takeoff)","warnings")end;local hy=cB(a:getTargetGroundAltitude())fL[#fL+1]=co(hq,ht,"Hover Height: "..hy,"warn")end;if a5 then fL[#fL+1]=co(hq,hu+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bL and AntigravTargetAltitude~=nil then if c(ar-antigrav.getBaseAltitude())<501 then fL[#fL+1]=co(hq,hv+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fL[#fL+1]=co(hq,hv+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fL[#fL+1]=co(hq,hv+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fL[#fL+1]=co(hq,hv+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Y then fL[#fL+1]=co(hq,hv+20,"Follow Mode Engaged","warn")elseif Reentry then fL[#fL+1]=co(hq,hv+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local hy=cB(HoldAltitude,2)if VertTakeOff then if bL then hy=cB(antigrav.getBaseAltitude(),2).." AGG singularity height"end;fL[#fL+1]=co(hq,hv,"VTO to "..hy,"warn")elseif AutoTakeoff and not IntoOrbit then if al then fL[#fL+1]=co(hq,hv,"Takeoff to "..AutopilotTargetName,"warn")else fL[#fL+1]=co(hq,hv,"Takeoff to "..hy,"warn")end;if BrakeIsOn and not VertTakeOff then fL[#fL+1]=co(hq,hv+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fL[#fL+1]=co(hq,hv,"Altitude Hold: "..hy,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if aq>0.1 then fL[#fL+1]=co(hq,hv+20,"Beginning ascent","warn")elseif aq<0.09 and aq>0.05 then fL[#fL+1]=co(hq,hv+20,"Aligning trajectory","warn")elseif aq<0.05 then fL[#fL+1]=co(hq,hv+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bn~=nil then fL[#fL+1]=co(hq,hv,bn,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fL[#fL+1]=co(hq,hv+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bJ.."kg DETECTED","warnings")cb("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then fL[#fL+1]=co(hq,hv,"Brake-Landing","warnings")else fL[#fL+1]=co(hq,hv,"Coast-Landing","warnings")end end;if ProgradeIsOn then fL[#fL+1]=co(hq,hv,"Prograde Alignment","crit")end;if RetrogradeIsOn then fL[#fL+1]=co(hq,hv,"Retrograde Alignment","crit")end;local hz,er,es=b5:getPlanetarySystem(0):castIntersections(bI,bE:normalize(),function(eg)if eg.noAtmosphericDensityAltitude>0 then return eg.radius+eg.noAtmosphericDensityAltitude else return eg.radius+eg.surfaceMaxAltitude*1.5 end end)local hA=er;if es~=nil and er~=nil then hA=math.min(es,er)end;if hA~=nil and aq==0 then local hy=cB(hA)local travelTime=b6.computeTravelTime(bF,0,hA)local hB="Collision"if hz.noAtmosphericDensityAltitude>0 then hB="Atmosphere"end;fL[#fL+1]=co(hq,hw+20,hz.name.." "..hB.." "..d4(travelTime).." In "..hy,"crit")end;if collisionAlertStatus then local type;if string.find(collisionAlertStatus,"COLLISION")then type="warnings"else type="crit"end;fL[#fL+1]=co(hq,hw+20,collisionAlertStatus,type)end;if VectorToTarget and not IntoOrbit then fL[#fL+1]=co(hq,hv+35,VectorStatus,"warn")end;fL[#fL+1]="</g>"return fL end;local function hC(f7)return d(x(f7*3.6,0)+0.5).." km/h"end;local function hD(fL)local hE=OrbitMapX;local hF=OrbitMapY;local hG=OrbitMapSize;local hH=4;local hI=15;local cp=0;local cq=0;local hJ,hK,hL,hM;local function hN(type)local hO,A,f7,hP;if type=="Periapsis"then hO=orbit.periapsis.altitude;A=orbit.timeToPeriapsis;f7=orbit.periapsis.speed;hP=35 else hO=orbit.apoapsis.altitude;A=orbit.timeToApoapsis;f7=orbit.apoapsis.speed;hP=-35 end;fL[#fL+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cp+hP,cq-5,hE+hG/2-hJ+hM,cq-5)fL[#fL+1]=co(cp,cq,type)cq=cq+hI;local hy=cB(hO)fL[#fL+1]=co(cp,cq,hy)cq=cq+hI;fL[#fL+1]=co(cp,cq,d4(A))cq=cq+hI;fL[#fL+1]=co(cp,cq,hC(f7))end;if orbit~=nil and aq<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hF=hF+hH;cp=hE+hG+hE/2+hH;cq=hF+hG/2+5+hH;hJ=hG/4;hM=0;fL[#fL+1]=[[<g class="pbright txtorb txtmid">]]fL[#fL+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hG+hE*2,hG+hF,hH,hH)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hL=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hJ*2)hK=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hL*(1-orbit.eccentricity)hM=hJ-orbit.periapsis.altitude/hL-planet.radius/hL;local hQ=""if orbit.periapsis.altitude<=0 then hQ='redout'end;fL[#fL+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hQ,hE+hG/2+hM+hH,hF+hG/2+hH,hJ,hK)fL[#fL+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',hE+hG/2+hH,hF+hG/2+hH,planet.radius/hL)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hN("Apoapsis")end;cq=hF+hG/2+5+hH;cp=hE-hE/2+10+hH;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hN("Periapsis")end;fL[#fL+1]=co(hE+hG/2+hH,planet.name,20+hH,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hR=orbit.timeToApoapsis/orbit.period*2*math.pi;local hS=hJ*math.cos(hR)local hT=hK*math.sin(hR)fL[#fL+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',hE+hG/2+hS+hM+hH,hF+hG/2+hT+hH)end;fL[#fL+1]=[[</g>]]return fL else return fL end end;local function hU()if radarPanelID~=nil and aj==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if aj==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;aj=0 end end;local function hV(fL)local cp=30;local cq=275;local hW={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hX={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere"}local hY={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local hZ={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle InHud Sounds","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ap then ce(hW,hX)table.insert(hW,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(hW,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if an~=-1 then if antigrav then if bL then table.insert(hW,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hW,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hW,"Alt-6: Begins Vertical Takeoff.")else table.insert(hW,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hW,"G: Begin BrakeLanding or Land")end else ce(hW,hY)end;if AltitudeHold then table.insert(hW,"Alt-Spacebar/Alt-C will raise/lower target height")end;ce(hW,hZ)for i=1,#hW do cq=cq+12;fL[#fL+1]=co(cp,cq,hW[i],"pdim txttick txtstart")end end;local function h_(i0,i1)local i2;local i3=(i1-i0):normalize()local fb=(bI-i0):dot(i3)/i3:dot(i3)if fb<=0.then return(bI-i0):len()elseif fb>=(i1-i0):len()then return(bI-i1):len()end;local i4=i0+fb*i3;i2=(i4-bI):len()return i2 end;local function i5()local i2;local i6=nil;local i7=nil;local i8=nil;for dd,i9 in pairs(b0[0])do if i9.hasAtmosphere then local ah=h_(planet.center,i9.center)if i6==nil or ah<i6 then i7=i9;i6=ah;i8=planet end;if aa and aa.hasAtmosphere and aa.name~=planet.name then local ex=h_(aa.center,i9.center)if ex<i6 then i7=i9;i6=ex;i8=aa end end end end;local ia=fF(1770)local ib=fG(330)if i6 then local ic="txttick "local id=500000;if i6<i7.radius+id or i6<i8.radius+id then if bU then ic="txttick red "else ic="txttick orange "end end;i2=cB(i6,2)bW=co(ia,ib,"Pipe ("..i8.name.."--"..i7.name.."): "..i2,ic.."pbright txtmid")end end;local ie={}function ie.HUDPrologue(fL)bU,fw,_,_=fx(bI)if not bU then D=PvPR;F=PvPG;E=PvPB else D=SafeR;F=SafeG;E=SafeB end;ay=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]az=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]local ig=ay;local ih=az;local ii=ay;local ij=az;if fH()and not brightHud then ig=[[rgb(]]..d(D*0.4+0.5)..","..d(F*0.4+0.5)..","..d(E*0.3+0.5)..[[)]]ih=[[rgb(]]..d(D*0.3+0.5)..","..d(F*0.3+0.5)..","..d(E*0.2+0.5)..[[)]]end;fL[#fL+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],ig,ig,ii,ii,ih,ih,ij,ij,aI,aJ)return fL end;function ie.DrawVerticalSpeed(fL,dQ)gb(fL,dQ)end;function ie.UpdateHud(fL)local dQ=ar;local fa=core.getVelocity()local f7=vec3(fa):len()local g_=bO;local ik=bP;local gj=ik;local gy=bO;local hh=d(unit.getThrottle())local hm=f7*3.6;local hi=unit.getAxisCommandValue(0)local il=fF(1770)local im=fG(310)if AtmoSpeedAssist and bN then hi=G;hh=G*100 end;local fJ=fI()local gk="ROLL"local cK=unit.getClosestPlanetInfluence()>0;if hh==nil then hh=0 end;if not cK then if f7>5 then g_=gZ(fa)ik=h0(fa)else g_=0;ik=0 end;gk="YAW"end;if fw>50000 and not ap then local io;if fw>200000 then io=x(fw/200000,2).." su"else io=x(fw/1000,1).." km"end;fL[#fL+1]=co(il,im,"PvP Boundary: "..io,"pbright txtbig txtmid")end;fL[#fL+1]=ai;fL[#fL+1]=aD;fL[#fL+1]=bV;if bW~=""then fL[#fL+1]=bW end;if a_%aU==0 then aZ=true end;if fuelX~=0 and fuelY~=0 then fK(fL,aZ,fuelX,"Atmospheric ","ATMO",aN,aX,aY)fK(fL,aZ,fuelX+120,"Space fuel t","SPACE",aO,aV,aW)fK(fL,aZ,fuelX+240,"Rocket fuel ","ROCKET",aP,aS,aT)end;if aZ then aZ=false;a_=0 end;a_=a_+1;gb(fL,dQ)if l()==0 or RemoteHud then if not fH()or brightHud then if cK then gi(fL,centerX,centerY,gj,gk,cK)gx(fL,gy,gj,centerX,centerY,cK,d(h0(fa)),f7)else gi(fL,centerX,centerY,ik,gk,cK)gx(fL,g_,ik,centerX,centerY,cK,d(ik),f7)end;gE(fL,dQ,cK)h1(fL,fa,f7,centerX,centerY)end end;hg(fL,fJ,hh,hi)hl(fL,hm)hp(fL)hD(fL)if showHelp then hV(fL)end;return fL end;function ie.HUDEpilogue(fL)fL[#fL+1]="</svg>"return fL end;function ie.ExtraData(fL)local ip=fF(1240)local iq=fG(55)local ir=iq+10;local is;local it=0;local fJ=fI()if VertTakeOffEngine then fJ=fJ.."-VERTICAL"end;if TurnBurn then fJ="TB-"..fJ end;if not stablized then fJ=fJ.."-DeCoupled"end;local iu=vec3(core.getWorldAcceleration()):len()/9.80665;is=core.g()fL[#fL+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then ip=fF(1120)iq=fG(55)ir=iq+10 elseif ap then local iv=fF(770)fL[#fL+1]=co(iv,iq,"ATMOSPHERE","pdim txt txtend")fL[#fL+1]=co(iv,ir,e("%.2f",aq),"pdim txt txtend","")end;fL[#fL+1]=co(ip,iq,"GRAVITY","pdim txt txtend")fL[#fL+1]=co(ip,ir,e("%.2f",is/9.80665),"pdim txt txtend")fL[#fL+1]=co(ip,iq+20,"ACCEL","pdim txt txtend")fL[#fL+1]=co(ip,ir+20,e("%.2f",iu),"pdim txt txtend")fL[#fL+1]=co(fF(960),fG(180),fJ,"txtbig txtmid")end;function ie.DrawOdometer(fL,ab,TotalDistanceTravelled,ac)local is;local iw=0;local ix=0;local it=0;if ap then it=LastMaxBrakeInAtmo else it=LastMaxBrake end;maxThrust=a:maxForceForward()is=core.g()if is>0.1 then ix=au*is;iw=maxThrust/is end;fL[#fL+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fF(660),fF(700),fG(35),fF(960),fG(55),fF(1240),fG(35),fF(1280))if l()==0 or RemoteHud then fL[#fL+1]=co(fF(700),fG(20),e("Trip: %.2f km",ab),"txtstart")fL[#fL+1]=co(fF(700),fG(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fL[#fL+1]=co(fF(830),fG(20),"Trip Time: "..d4(ac),"txtstart")fL[#fL+1]=co(fF(830),fG(30),"Total Time: "..d4(TotalFlightTime),"txtstart")fL[#fL+1]=co(fF(970),fG(20),e("Mass: %.2f Tons",au/1000),"txtstart")fL[#fL+1]=co(fF(1240),fG(10),e("Max Brake: %.2f kN",it/1000),"txtend")fL[#fL+1]=co(fF(1240),fG(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if is>0.1 then fL[#fL+1]=co(fF(970),fG(30),e("Max Mass: %.2f Tons",iw/1000),"txtstart")fL[#fL+1]=co(fF(1240),fG(20),e("Req Thrust: %.2f kN",ix/1000),"txtend")else fL[#fL+1]=co(fF(970),fG(30),"Max Mass: n/a","txtstart")fL[#fL+1]=co(fF(1240),fG(20),"Req Thrust: n/a","txtend")end end;fL[#fL+1]="</g>"return fL end;function ie.DrawWarnings(fL)return hp(fL)end;function ie.DisplayOrbitScreen(fL)return hD(fL)end;function ie.DisplayMessage(fL,hy)if hy~="empty"then local cq=310;for iy in string.gmatch(hy,"([^\n]+)")do cq=cq+35;fL[#fL+1]=co("50%",cq,iy,"msg")end end;if ag~=0 then unit.setTimer("msgTick",ag)ag=0 end end;function ie.DrawDeadZone(fL)fL[#fL+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function ie.UpdatePipe()if ap then bW=""return end;i5()end;function ie.UpdateRadarRoutine()local iz={}local function iA(iB,iC,iD,iE,iF,iG,iH,iI)iC,iE,iG,iI=vec3(iC),vec3(iE),vec3(iG),vec3(iI)local iJ,iK,iL=iB*iB,iD*iD,iF*iF;local b_=iE-iC;local iM=b_:normalize()local iN=b_:len()local c0=iG-iC;local iO=(c0-c0:project_on(iM)):normalize()local iP,iQ=c0:dot(iM),c0:dot(iO)local iR=iP*iP+iQ*iQ;local iS=iM:cross(iO)local cp=(iJ-iK+iN*iN)/(2*iN)local cq=(iJ-iL+iR-2*iP*cp)/(2*iQ)local dr=iJ-cp^2-cq^2;local iT=math.sqrt(dr)local iU=iC+iM*cp+iO*cq+iS*iT;local iV=iC+iM*cp+iO*cq-iS*iT;if math.abs((iI-iU):len()-iH)<math.abs((iI-iV):len()-iH)then return iU else return iV end end;local function iW(iX,fc,iY)local iZ=iX.pts;local cN=#iZ;local i_=iX.ref;if cN>4 then local j0,j1,j2,j3=iZ[cN],iZ[cN-1],iZ[cN-2],iZ[cN-3]iX.ref=iY;local c7=iA(j0[1],j0[2],j1[1],j1[2],j2[1],j2[2],j3[1],j3[2])local cp,cq,iT=c7.x,c7.y,c7.z;if cp==cp and cq==cq and iT==iT then cp=cp+i_[1]cq=cq+i_[2]iT=iT+i_[3]local j4=iX.center;if j4==nil or iX.i>2 then iX.center=vec3(cp,cq,iT)iX.i=0 elseif c(j4.x-cp)>2 or c(j4.y-cq)>2 then iX.i=iX.i+1 else end end;iX.pts={}else local j5={iY[1]-i_[1],iY[2]-i_[2],iY[3]-i_[3]}iZ[cN+1]={fc,j5}end end;if radar_1 then local j6=radar_1.getEntries()local j7=radar_1.getData()local j8=j7:gmatch('{"constructId[^}]*}[^}]*}')local j9=fF(1770)local ja=fG(350)local iY=getTrueWorldPos()if#j6>0 then local jb={}local jc,jd,je,jf=0,0,0,0;for de in j8 do local dY,ah,jg=de:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local jh=16;ah=tonumber(ah)if radar_1.hasMatchingTransponder(dY)==1 then table.insert(jb,dY)end;if ah>0 and radar_1.getConstructType(dY)=="static"then je=je+1;if CollisionSystem then local g0=radar_1.getConstructName(dY)local iX=contacts[dY]if iX==nil then contacts[dY]={}contacts[dY].pts={}contacts[dY].ref=iY;contacts[dY].name=g0;contacts[dY].i=0;if jg=="L"then jh=128 elseif jg=="M"then jh=64 elseif jg=="S"then jh=32 end;contacts[dY].radius=jh/2+C/2;iX=contacts[dY]end;iW(iX,ah,iY)if iX.center then table.insert(iz,iX)end;jd=jd+1 end end;jc=jc+1;if jc>500 or jd>50 then coroutine.yield()jc,jd=0,0 end end;if#iz>0 then local eg,ji,jj,jk;local jl=0;local jm=b5:getPlanetarySystem(0)jk=bE:normalize()while jl<#iz do coroutine.yield()local jn={table.unpack(iz,jl,math.min(jl+75,#iz))}eg,ji,jj=jm:castIntersections(bI,jk,nil,nil,jn)if eg and jj then collisionTarget={eg,ji,jj}break end;jl=jl+75 end;if not eg then collisionTarget=nil end;jf=#iz;iz={}else collisionTarget=nil end;local jo=j7:find('identifiedConstructs":%[%]')if jo==nil and perisPanelID==nil then aj=1;hU()end;if jo~=nil and perisPanelID~=nil then hU()end;if radarPanelID==nil then hU()end;local jp;if CollisionSystem then jp=jf.."/"..je.." Buildings : "..#j6-je.." Ships"else jp=je.." Buildings : "..#j6-je.." Ships"end;bV=co(j9,ja,jp,"pbright txtbig txtmid")if#jb>0 then local cq=fG(15)local cp=fF(1370)bV=bV..co(cp,cq,"Friendlies In Range","pbright txtbig txtmid")for dd,de in pairs(jb)do cq=cq+20;bV=bV..co(cp,cq,radar_1.getConstructName(de),"pdim txtmid")end end else local jq;jq=j7:find('worksInEnvironment":false')if jq then bV=co(j9,ja,"Radar: Jammed","pbright txtbig txtmid")else bV=co(j9,ja,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then aj=0;hU()end end end end;function ie.UpdateRadar()local jr=coroutine.status(UpdateRadarCoroutine)if jr=="suspended"then local cv,js=coroutine.resume(UpdateRadarCoroutine)if js then system.print("ERROR UPDATE RADAR: "..js)end elseif jr=="dead"then UpdateRadarCoroutine=coroutine.create(ie.UpdateRadarRoutine)local cv,js=coroutine.resume(UpdateRadarCoroutine)end end;function ie.DrawSettings(fL)if#bR>0 then local cp=fF(640)local cq=fG(200)fL[#fL+1]=[[<g class="pbright txtvspd txtstart">]]for dd,de in pairs(bR)do fL[#fL+1]=co(cp,cq,de..": ".._G[de])cq=cq+20;if dd%12==0 then cp=cp+fF(350)cq=fG(200)end end;fL[#fL+1]=co(fF(640),fG(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fL[#fL+1]="</g>"end;return fL end;UpdateRadarCoroutine=coroutine.create(ie.UpdateRadarRoutine)return ie end;local function jt()local function ju()local function jv(jw,jx)return jw.name<jx.name end;bT={}for dd,de in pairs(b0[0])do bT[#bT+1]={name=de.name,index=dd}end;table.sort(bT,jv)end;local df={}function df.UpdateAtlasLocationsList()ju()end;function df.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local jy=bT[AutopilotTargetIndex].index;local jz=b0[0][jy]if jz.center then AutopilotTargetName=jz.name;aa=b5[0][jy]if CustomTarget~=nil then if aq==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jz;for _,de in pairs(b5[0])do if de.name==CustomTarget.planetname then aa=de;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b8(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function df.adjustAutopilotTargetIndex(gf)if not Autopilot and not VectorToTarget and not al and not IntoOrbit then if gf==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bT then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bT end end;if AutopilotTargetIndex==0 then ba.UpdateAutopilotTarget()else local jy=bT[AutopilotTargetIndex].index;local jz=b0[0][jy]if jz.name=="Space"or iphCondition=="Custom Only"and jz.center or iphCondition=="No Moons"and string.find(jz.name,"Moon")~=nil then if gf==nil then ba.adjustAutopilotTargetIndex()else ba.adjustAutopilotTargetIndex(1)end else ba.UpdateAutopilotTarget()end end else a0="Disengage autopilot before changing Interplanetary Helper"cb("iph","AP")end end;function df.findAtlasIndex(jA)for dd,de in pairs(jA)do if de.name and de.name==CustomTarget.name then return dd end end;return-1 end;for dd,de in pairs(SavedLocations)do table.insert(b0[0],de)end;ju()df.UpdateAutopilotTarget()return df end;local function jB()local jC={}local jD={vec3(bE),-vec3(bE),vec3(bB),-vec3(bB),vec3(bD),-vec3(bD)}local function jE(f7)local jF=AutopilotEndSpeed;if not Autopilot then jF=0 end;if not ap then return b6.computeDistanceAndTime(f7,jF,au,0,0,LastMaxBrake-AutopilotPlanetGravity*au)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b6.computeDistanceAndTime(f7,jF,au,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*au)else return 0,0 end end end;local function jG(f7)local jF=AutopilotEndSpeed;if not Autopilot then jF=0 end;return b6.computeDistanceAndTime(f7,jF,au,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*au)end;function jC.GetAutopilotBrakeDistanceAndTime(f7)return jE(f7)end;function jC.GetAutopilotTBBrakeDistanceAndTime(f7)return jG(f7)end;local function jH(jI,jJ,jK)jJ=jJ:project_on_plane(jI)jK=jK:project_on_plane(jI)return m(jJ:cross(jK):dot(jI),jJ:dot(jK))end;local function jL()local function jM()local jN=-1;local jO=-1;if vBooster then jN=vBooster.distance()end;if hover then jO=hover.distance()end;if jN~=-1 and jO~=-1 then if jN<jO then return jN else return jO end elseif jN~=-1 then return jN elseif jO~=-1 then return jO else return-1 end end;local jP=jM()local jQ=-1;if telemeter_1 then jQ=telemeter_1.getDistance()end;if jP~=-1 and jQ~=-1 then if jP<jQ then return jP else return jQ end elseif jP~=-1 then return jP else return jQ end end;local function jR(planet,et,jS)local function jT(jU,dJ)local ez=vec3(dJ)if jU.bodyId==0 then return setmetatable({latitude=ez.x,longitude=ez.y,altitude=ez.z,bodyId=0,systemId=jU.planetarySystemId},MapPosition)end;local eA=ez-jU.center;local ah=eA:len()local dQ=ah-jU.radius;local dO=0;local dP=0;if not cy(ah,0)then local eB=m(eA.y,eA.x)dP=eB>=0 and eB or 2*math.pi+eB;dO=math.pi/2-math.acos(eA.z/ah)end;return setmetatable({latitude=math.deg(dO),longitude=math.deg(dP),altitude=dQ,bodyId=jU.bodyId,systemId=jU.planetarySystemId},MapPosition)end;local jV=jT(planet,et)jV="::pos{"..jV.systemId..","..jV.bodyId..","..jV.latitude..","..jV.longitude..","..jV.altitude.."}"if jS then return jV else system.setWaypoint(jV)return true end end;function jC.showWayPoint(planet,et,jS)return jR(planet,et,jS)end;function jC.APTick()local function jW()if collisionTarget and not BrakeLanding then local eg=collisionTarget[1]local ji,jj=collisionTarget[2],collisionTarget[3]local jX=math.min(ji,jj or ji)local jY=jX/bF;if(AltitudeHold or VectorToTarget or LockPitch)and not AutoTakeoff and(a6*1.5>jX or jY<1)then BrakeIsOn=true;cu(0)if AltitudeHold then cG()end;if LockPitch then ToggleLockPitch()end;a0="Autopilot Cancelled due to possible collision"if VectorToTarget then cI()end;StrongBrakes=true;BrakeLanding=true;be=true end;if jY<11 then collisionAlertStatus=eg.name.." COLLISION "..d4(jY).." / "..cB(jX,2)else collisionAlertStatus=eg.name.." collision "..d4(jY)end;if jY<6 then cb("alarm","AL",2)end else collisionAlertStatus=false end end;ap=j()>0;aq=j()ar=core.getAltitude()an=jL()A=p()bh=A;if CollisionSystem then jW()end;if antigrav then bL=antigrav.getState()==1 end;local jZ=1;local j_=1;local k0=A-bh;local k1=-math.deg(jH(bB,bE,bC))local k2=math.deg(jH(bD,bE,bC))local gf=bG*-1;bg=ap and k1<-YawStallAngle or k1>YawStallAngle or k2<-PitchStallAngle or k2>PitchStallAngle;local k3=system.getMouseDeltaX()local k4=system.getMouseDeltaY()if InvertMouse and not Z then k4=-k4 end;T=0;X=0;S=0;sys=b5[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b8(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bE)if ar==0 then ar=(bI-planet.center):len()-planet.radius end;local is=planet:getGravity(core.getConstructWorldPos()):len()*au;bi=0;b7=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and Z then if not bc then ae=ae+k3;af=af+k4 end else ae=0;af=0 end else ae=ae+k3;af=af+k4;ah=math.sqrt(ae*ae+af*af)if not Z and l()==0 then if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then T=T-(ae-DeadZone)*MouseXSensitivity elseif ae<0 and ae<DeadZone*-1 then T=T-(ae+DeadZone)*MouseXSensitivity else T=0 end;if af>0 and af>DeadZone then S=S-(af-DeadZone)*MouseYSensitivity elseif af<0 and af<DeadZone*-1 then S=S-(af+DeadZone)*MouseYSensitivity else S=0 end else ae=0;af=0;if userControlScheme=="mouse"then S=(-utils.smoothstep(k4,-100,100)+0.5)*2*jZ;T=(-utils.smoothstep(k3,-100,100)+0.5)*2*j_ end end end end;local k5=bF>8334;if bF>SpaceSpeedLimit/3.6 and not ap and not Autopilot and not k5 then a0="Space Speed Engine Shutoff reached"cu(0)end;if not k5 and LastIsWarping then if not BrakeIsOn then cQ()end;if Autopilot then cI()end end;LastIsWarping=k5;if ap and aq>0.09 then if bF>bl/3.6 and not AtmoSpeedAssist and not ax then BrakeIsOn=true;ax=true elseif not AtmoSpeedAssist and ax then if bF<bl/3.6 then BrakeIsOn=false;ax=false end end end;if BrakeIsOn then W=1 else W=0 end;if ProgradeIsOn then if ak then BrakeIsOn=false;local k6=false;if CustomTarget~=nil then k6=cR(CustomTarget.position-bI,0.1)else k6=cR(vec3(bE),0.01)end;be=true;if k6 then cx(d(bl))if(c(bP)<2 or c(bO)>85)and bF>=bl/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;P=true;ak=false;am=true;Autopilot=false;d2()end elseif ap and AtmoSpeedAssist then cu(1)end elseif bF>O then cR(vec3(bE),0.01)end end;if RetrogradeIsOn then if ap then RetrogradeIsOn=false elseif bF>O then cR(-vec3(bE))end end;if not ProgradeIsOn and ak and not IntoOrbit then if aq==0 then P=true;d2()ak=false;am=true else ak=false;cI()end end;if am and CustomTarget~=nil and(ar<HoldAltitude+250 and ar>HoldAltitude-250)and bF*3.6>bl-250 and c(bH)<25 and aq>=0.1 and(CustomTarget.position-bI):len()>2000+ar then cI()am=false end;if VertTakeOff then be=true;local k7=HoldAltitude;if bH<-30 then a0="Unable to achieve lift. Safety Landing."ad=0;be=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bL or HoldAltitude<planet.spaceEngineMinAltitude then if bL then k7=antigrav.getBaseAltitude()end;if ar<k7-100 then bm=0;ad=15;BrakeIsOn=false elseif bH>0 then BrakeIsOn=true;ad=0 elseif bH<-30 then BrakeIsOn=true;ad=15 elseif ar>=k7 then if bL then if Autopilot or VectorToTarget then cE()else BrakeIsOn=true;VertTakeOff=false end;a0="Takeoff complete. Singularity engaged"cb("aggLk","AG")else BrakeIsOn=false;a0="VTO complete. Engaging Horizontal Flight"cb("vtoc","VT")cE()end;ad=0 end else if aq>0.08 then bm=0;BrakeIsOn=false;ad=20 elseif aq<0.08 and aq>0 then BrakeIsOn=false;if by then bm=0;ad=20 else ad=0;bm=36;cx(3500)end else be=autoRollPreference;IntoOrbit=true;bw=false;CancelIntoOrbit=false;bq=false;bo=nil;bp=nil;if bv==nil then bv=planet end;bu=k7;bt=true;VertTakeOff=false end end;if bm~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local k8=q(bm-bO,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(k8)local k9=q(vTpitchPID:get(),-1,1)S=k9 end end;if IntoOrbit then local c_;local ka=false;local kb=cB(bu)if bv==nil then bv=planet;if VectorToTarget then bv=aa end end;if not bt then bu=d(bv.radius+bv.surfaceMaxAltitude+LowOrbitHeight)if bv.hasAtmosphere then bu=d(bv.radius+bv.noAtmosphericDensityAltitude+LowOrbitHeight)end;bt=true end;if bs.VectorToTarget then c_=CustomTarget.position-bI end;local kc,kd=b8(bv):escapeAndOrbitalSpeed((bI-bv.center):len()-bv.radius)local ke=bP;if not bq then local kf=false;local kg=false;cu(0)bp=0;bn="Aligning to orbital path - OrbitHeight: "..kb;if bs.VectorToTarget then cR(c_:normalize():project_on_plane(bG))ka=bC:dot(c_:project_on_plane(bB):normalize())>0.95 else cR(bE)ka=k1<0.5;if bF<150 then ka=true end end;S=0;bo=0;if bO<=bo+1 and bO>=bo-1 then kf=true else kf=false end;if ke<=bp+1 and ke>=bp-1 then kg=true else kg=false end;if kf and kg and ka then bo=nil;bp=nil;bq=true end else if bs.VectorToTarget then cR(c_:normalize():project_on_plane(bG))elseif bF>150 then cR(bE)end;S=0;if bs.VectorToTarget then local a6,_=b6.computeDistanceAndTime(bF,bl/3.6,au,0,0,LastMaxBrake)if bw and c_:len()>15000+a6+ar then bn="Orbiting to Target"if ar-100<=bv.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bv.noAtmosphericDensityAltitude then bw=false end elseif bw or c_:len()<15000+a6+ar then a0="Orbit complete, proceeding with reentry"cb("orCom","OB")AutopilotTargetCoords=CustomTarget.position;P=true;am=true;bs.VectorToTarget,bs.AutopilotAlign=false,false;cF()d2()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and ar>bu*0.9 and ar<bu*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bu*0.99 and orbit.apoapsis.altitude>=bu*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bw then if bw then BrakeIsOn=false;cu(0)bo=0;if not bs.VectorToTarget then a0="Orbit complete"cb("orCom","OB")cF()end else bA=bA+1;if bA>=2 then bw=true end end else bn="Adjusting Orbit - OrbitHeight: "..kb;br=true;cx(kd*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kh=bH;local ki=ar-bu;local kj=c(ki)if bH<10 and c(bO)<10 and kj<100 then kh=bH*2 end;if kh<10 and c(bO)<10 and kj<100 then kh=kh*2 end;if kh<5 and c(bO)<5 and kj<100 then kh=kh*4 end;VSpdPID:inject(kh)bo=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(ki)bo=q(bo-q(OrbitAltPID:get(),-15,15),-90,90)end end else local kk=2.75;local kl=c(o(kc*kk))local km=kl%50;if km>0 then kl=kl-km+50 end;BrakeIsOn=false;if ar<bu*0.8 then bn="Escaping planet gravity - OrbitHeight: "..kb;bo=utils.map(bH,200,0,-15,80)elseif ar>=bu*0.8 and ar<bu*1.15 then bn="Approaching orbital corridor - OrbitHeight: "..kb;kl=kl*0.75;bo=utils.map(bH,100,-100,-15,65)elseif ar>=bu*1.15 and ar<bu*1.5 then bn="Approaching orbital corridor - OrbitHeight: "..kb;kl=kl*0.75;if bH<0 or br then bo=utils.map(ar,bu*1.5,bu*1.01,-30,0)else bo=utils.map(ar,bu*0.99,bu*1.5,0,30)end elseif ar>bu*1.5 then bn="Reentering orbital corridor - OrbitHeight: "..kb;bo=-65;local kn=utils.map(bH,-150,-400,1,0.55)kl=kl*kn end;cx(d(kl))end end;if bo~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local ko=bo-bO;OrbitPitchPID:inject(ko)local kp=q(OrbitPitchPID:get(),-0.5,0.5)S=kp end end;if Autopilot and aq==0 and not ak then local function kq(jp,orbit)system.print(jp)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cu(0)N=false;a0=jp;cb("apCom","AP")if orbit or ak then if orbit and AutopilotTargetOrbit~=nil and not ak then if not ar or ar==0 then return end;bu=ar;bt=true end;cF()end end;local kr,ks=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kt=(CustomTarget.position-aa.center):normalize()local ku=kt:project_on_plane((aa.center-bI):normalize()):normalize()local kv=aa.center+ku*(aa.radius+AutopilotTargetOrbit)local kw=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bI-kv):len()<(bI-kw):len()then kr=kv else kr=kw;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kr;bb.showWayPoint(aa,AutopilotTargetCoords)ks=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;ks=true;TargetSet=true;AutopilotRealigned=true;kr=CustomTarget.position+(bI-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kt=(bI+bE*100000-aa.center):normalize()local ku=kt:project_on_plane((aa.center-bI):normalize()):normalize()if ku:len()<1 then kt=(bI+bC*100000-aa.center):normalize()ku=kt:project_on_plane((aa.center-bI):normalize()):normalize()end;kr=aa.center+ku*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kr;TargetSet=true;ks=true;AutopilotRealigned=true;bb.showWayPoint(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kr)-bI):len()local hz,er,es=b5:getPlanetarySystem(0):castIntersections(bI,bE:normalize(),function(eg)if eg.noAtmosphericDensityAltitude>0 then return eg.radius+eg.noAtmosphericDensityAltitude else return eg.radius+eg.surfaceMaxAltitude*1.5 end end)local hA=er;if es~=nil and er~=nil then hA=math.min(es,er)end;if hA~=nil and hA<AutopilotDistance and hz.name==aa.name then AutopilotDistance=hA end;local k6=true;local kx=(aa.center-(bI+vec3(bE):normalize()*AutopilotDistance)):len()-aa.radius;local hy=cB(kx)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hy..'"}')local a6,a7;if not TurnBurn then a6,a7=jE(bF)else a6,a7=jG(bF)end;if bF>300 and AutopilotAccelerating then local c_=vec3(kr)-bI;local ky=q(math.deg(jH(bB,bE:normalize(),c_:normalize()))*bF/500,-90,90)local kz=q(math.deg(jH(bD,bE:normalize(),c_:normalize()))*bF/500,-90,90)if c(ky)<20 and c(kz)<20 then ky=ky*2;kz=kz*2 end;if c(ky)<2 and c(kz)<2 then ky=ky*2;kz=kz*2 end;local k1=-math.deg(jH(bB,bC,bE:normalize()))local k2=-math.deg(jH(bD,bC,bE:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kz-k2)local kA=q(apPitchPID:get(),-1,1)S=S+kA;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(ky-k1)local kB=q(apYawPID:get(),-1,1)T=T+kB;ks=true;if c(ky)>2 or c(kz)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"cb("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end end end;if kx<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b8(aa):escapeAndOrbitalSpeed(kx)end end;if not AutopilotCruising and not AutopilotBraking and not ks then k6=cR((kr-bI):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then k6=cR(-vec3(bE):normalize())end;if AutopilotAccelerating then if not N then BrakeIsOn=false;cu(AutopilotInterplanetaryThrottle)G=x(AutopilotInterplanetaryThrottle,2)N=true end;local kC=unit.getThrottle()if AtmoSpeedAssist then kC=G end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or kC==0 and N then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then cb("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cu(0)end;if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cu(0)N=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;W=1 end;if TurnBurn then cu(1,true)end;local _,kd=b8(aa):escapeAndOrbitalSpeed((bI-planet.center):len()-planet.radius)local c_;if CustomTarget~=nil then c_=CustomTarget.position-bI end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bF<50 then kq("Autopilot complete, arrived at space location")BrakeIsOn=true;W=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bF<=kd and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kq("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;bb.showWayPoint(aa,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then cb("apCir","AP")AutopilotStatus="Circularizing"end;if bF<=kd then if CustomTarget~=nil then if bE:normalize():dot(c_:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then cb("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;bb.showWayPoint(aa,CustomTarget.position)WaypointSet=true end else kq("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;ak=true;bb.showWayPoint(aa,CustomTarget.position)WaypointSet=false end else kq("Autopilot completed, setting orbit",true)W=0 end end elseif AutopilotStatus=="Circularizing"then kq("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then cb("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kC=unit.getThrottle()if AtmoSpeedAssist then kC=G end;if kC>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;AutopilotCruising=false end else if k6 then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not ak then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*bD;AutopilotShipUp=bB;AutopilotShipRight=bD end;AutopilotRealigned=true elseif k6 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"cb("apAcc","AP")end;if not N then cu(AutopilotInterplanetaryThrottle,true)G=x(AutopilotInterplanetaryThrottle,2)N=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and aq>0)then a0="Autopilot complete, proceeding with reentry"cb("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"W=0;cu(0)N=false;ProgradeIsOn=true;ak=true;bb.showWayPoint(aa,CustomTarget.position)end;if Y then be=true;local kz=0;local c7=bI+vec3(unit.getMasterPlayerRelativePosition())local kD=c7-bI;local kE=vec3(kD):project_on(bC):len()local kF=vec3(kD):project_on(bD):len()local ah=math.sqrt(kE*kE+kF*kF)cR(kD:normalize())local kG=40;local kH=ah<kG;local kI=100;local kJ=q((ah-kG)/2,10,kI)S=0;local k6=c(T)<0.1;if k6 and bF<kJ and not kH then BrakeIsOn=false;kz=-20 else BrakeIsOn=true;kz=0 end;local kK=0;if c(kz-bO)>kK then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kz-bO)local kA=pitchPID:get()S=kA end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local kL=LastMaxBrakeInAtmo;if kL then kL=kL*q(bF/100,0.1,1)*aq else kL=LastMaxBrake end;if aq<0.01 then kL=LastMaxBrake end;local kM=vec3(core.getWorldAirFrictionAcceleration())local kN=math.sqrt(kM:len()-kM:project_on(gf):len())*au;if bF>100 then a6,a7=b6.computeDistanceAndTime(bF,100,au,0,0,kL+kN)local kO,kP=b6.computeDistanceAndTime(100,0,au,0,0,kL/2)a6=a6+kO else a6,a7=b6.computeDistanceAndTime(bF,0,au,0,0,kL/2)end;local cK=unit.getClosestPlanetInfluence()>0;local kQ=HoldAltitude-ar;local kR=500+bF;local kS=1;if AutoTakeoff then kS=q(bF/100,0.1,1)end;local kz=(utils.smoothstep(kQ,-kR,kR)-0.5)*2*MaxPitch*kS;if not Reentry and not ak and not VectorToTarget and bC:dot(bE:normalize())<0.99 then kz=(utils.smoothstep(kQ,-kR*q(20-19*aq*10,1,20),kR*q(20-19*aq*10,1,20))-0.5)*2*MaxPitch*q(2-aq*10,1,2)*kS end;if not AltitudeHold then kz=0 end;if LockPitch~=nil then if cK and not IntoOrbit then kz=LockPitch else LockPitch=nil end end;be=true;local kT=S;if Reentry then local kU=d(bl)local kV,kW=b6.computeDistanceAndTime(bF,kU/3.6,au,0,0,LastMaxBrake-planet.gravity*9.8*au)local kX=ar-(planet.noAtmosphericDensityAltitude+5000)if not bN and ar>planet.noAtmosphericDensityAltitude+5000 and bF<=kU/3.6 and bF>kU/3.6-10 and c(bE:normalize():dot(bC))>0.9 then cu(0)elseif bN and bF>kU/3.6 and(kV>-1 and kX<=kV or ar<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cx(kU,true)if not P then kz=-80;if aq>0.02 then a0="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kz=0;be=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and ar>planet.noAtmosphericDensityAltitude+5000 then be=true elseif ar<=planet.noAtmosphericDensityAltitude+5000 then cx(kU)if not bN and r:getTargetSpeed(axisCommandId.longitudinal)==bl then P=false;Reentry=false;be=true end end end;if bF>O and not al and not VectorToTarget and not BrakeLanding and ForceAlignment then cR(vec3(bE))end;if bX or(VectorToTarget or al)and AutopilotTargetIndex>0 and aq>0.01 then local c_;if bX then if type(bX)=="table"then c_=bX elseif bX<3 and bX>0 then c_=-bG:cross(bE)*5000 elseif bX>=3 then c_=bG:cross(bE)*5000 elseif bX==0 then c_=bE*25000 end elseif CustomTarget~=nil then c_=CustomTarget.position-bI else c_=aa.center-bI end;local ky=math.deg(jH(bG:normalize(),bE,c_))*2;local kY=math.rad(c(bP))if bF>minRollVelocity and aq>0.01 then local kZ=q(90-kz*2,-90,90)bi=q(ky*2,-kZ,kZ)local k_=ky;ky=q(q(ky,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(kY)+4*(bO-kz)*math.sin(math.rad(bP)),-YawStallAngle*0.80,YawStallAngle*0.80)kz=q(q(kz*math.cos(kY),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(k_)*math.sin(kY),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bi=0;ky=q(ky,-YawStallAngle*0.80,YawStallAngle*0.80)end;local l0=k1-ky;if(type(bX)=="table"or bX==0)and c(l0)<=0.0001 then if bX==0 then cG()end;bX=nil;cb("180Off","BR")return end;if not bg and bF>minRollVelocity and aq>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(l0)local kB=q(yawPID:get(),-1,1)T=T+kB elseif ap and an>-1 or bF<minRollVelocity then cR(c_)elseif bg and aq>0.01 then if(k1<-YawStallAngle or k1>YawStallAngle)and aq>0.01 then cR(bE)end;if(k2<-PitchStallAngle or k2>PitchStallAngle)and aq>0.01 then kz=q(bO-k2,bO-PitchStallAngle*0.80,bO+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not al then local k7=planet:getAltitude(CustomTarget.position)local kX=math.sqrt(c_:len()^2-(ar-k7)^2)local l1=bE:len()-c(bH)StrongBrakes=true;if not al and not Reentry and kX<=a6+bF*k0/2 and(bE:project_on_plane(bG):normalize():dot(c_:project_on_plane(bG):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cu(0)if AltitudeHold then cG()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l1<0.1 or kX<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<kX)then if not bL then cb("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"collisionAlertStatus=false end;LastDistanceToTarget=kX end elseif VectorToTarget and aq==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(al or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local c_=CustomTarget.position-bI;local k7=planet:getAltitude(CustomTarget.position)local kX=math.sqrt(c_:len()^2-(ar-k7)^2)local kL=LastMaxBrakeInAtmo;if kL then a6,a7=b6.computeDistanceAndTime(bF,0,au,0,0,kL/2)StrongBrakes=true;if kX<=a6+bF*k0/2 and bE:project_on_plane(bG):normalize():dot(c_:project_on_plane(bG):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;P=true;ak=false;am=true;Autopilot=false;d2()end end;LastDistanceToTarget=kX end end end;if aq==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(al or IntoOrbit or Reentry)then if not bw and not IntoOrbit then bu=HoldAltitude;bt=true;if VectorToTarget then bs.VectorToTarget=true end;cF()VectorToTarget=false;bq=true end end;if bg and aq>0.01 and an==-1 and bF>minRollVelocity and VectorStatus~="Finalizing Approach"then cR(bE)kz=q(bO-k2,bO-PitchStallAngle*0.80,bO+PitchStallAngle*0.80)end;S=kT;local jQ=-1;if BrakeLanding then kz=0;local l2=false;local l3=30;if b7~=nil and b7>0 then local l4=q(aq,0.4,2)local kL=LastMaxBrakeInAtmo*q(bF/100,0.1,1)*l4;local l5=b7*l4+kL-is;local l6=kL/2-is;local l7=bF-math.sqrt(c(l6/2)*20/(0.5*au))*utils.sign(l6)if l7<0 then l7=0 end;local l8;if bF>100 then local l9,_=b6.computeDistanceAndTime(bF,100,au,0,0,kL)local la,_=b6.computeDistanceAndTime(100,0,au,0,0,math.sqrt(kL))l8=l9+la else l8=b6.computeDistanceAndTime(bF,0,au,0,0,math.sqrt(kL))end;if l8<20 then BrakeIsOn=false else local lb=0;if l7>100 then local lc,_=b6.computeDistanceAndTime(l7,100,au,0,0,l5)local ld,_=b6.computeDistanceAndTime(100,0,au,0,0,b7*l4+math.sqrt(kL)-is)lb=lc+ld else lb,_=b6.computeDistanceAndTime(l7,0,au,0,0,b7*l4+math.sqrt(kL)-is)end;lb=(lb+15+bF*k0)*1.1;local le=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if le then local k7=planet:getAltitude(CustomTarget.position)local lf=ar-k7-100;local c_=CustomTarget.position-bI;local lg=math.sqrt(c_:len()^2-(ar-k7)^2)if lg>100 then le=false elseif lf<=lb or lb==-1 then BrakeIsOn=true;l2=true else BrakeIsOn=false;l2=true end end;if not le and CalculateBrakeLandingSpeed then if lb>=l3 then BrakeIsOn=true else BrakeIsOn=false end;l2=true end end end;if not bN then cu(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)stablized=true;jQ=an;if jQ>-1 then be=autoRollPreference;if bF<1 or bE:normalize():dot(bG)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if Q then a.control.extendLandingGears()cb("grOut","LG",1)end;r:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bE:normalize():dot(-gf)<0.999 then BrakeIsOn=true elseif bH<-brakeLandingRate and not l2 then BrakeIsOn=true elseif not l2 then BrakeIsOn=false end end;if AutoTakeoff or al then local hz,es,er;if AutopilotTargetCoords~=nil then hz,es,er=b5:getPlanetarySystem(0):castIntersections(bI,(AutopilotTargetCoords-bI):normalize(),function(eg)return eg.radius+eg.noAtmosphericDensityAltitude end)end;if bL then if ar>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cu(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kz)<15 and ar/HoldAltitude>0.75 then AutoTakeoff=false;if not al then if bN and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif al and bF<O then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;cu(0)elseif al then cu(0)BrakeIsOn=true end elseif al and aq==0 and aa~=nil and(hz==nil or hz.name==aa.name)then Autopilot=true;al=false;AltitudeHold=false;AutoTakeoff=false;if not bN then cu(0)end;AutopilotAccelerating=true end end;local lh=an>-1;local li=bO;if(VectorToTarget or al or bX)and not lh and bF>minRollVelocity and aq>0.01 then local kY=math.rad(c(bP))li=bO*c(math.cos(kY))+k2*math.sin(kY)end;local lj=q(kz-li,-PitchStallAngle*0.80,PitchStallAngle*0.80)if aq<0.01 and VectorToTarget then lj=q(kz-li,-85,MaxPitch)elseif aq<0.01 then lj=q(kz-li,-MaxPitch,MaxPitch)end;if c(bP)<5 or VectorToTarget or bX or BrakeLanding or lh or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lj)local kA=pitchPID:get()S=S+kA end end;if antigrav~=nil and(antigrav and not ExternalAGG and ar<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;an=jL()return jC end;function script.onStart()local function lk()local function ll(lm)local ln=dbHud_1.hasKey;for dd,de in pairs(lm)do if ln(de)then local cX=f(dbHud_1.getStringValue(de))if cX~=nil then _G[de]=cX;aK=true end end end end;if dbHud_1 then if not useTheseSettings then ll(ch())coroutine.yield()ll(b)else ll(b)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;aK=false end;coroutine.yield()if aK then a0="Loaded Saved Variables"L=x(ResolutionX/2,0)M=x(ResolutionY/2,0)aI=ResolutionX;aJ=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)be=autoRollPreference;bl=AtmoSpeedLimit;ay=[[rgb(]]..d(D+0.5)..","..d(F+0.5)..","..d(E+0.5)..[[)]]az=[[rgb(]]..d(D*0.9+0.5)..","..d(F*0.9+0.5)..","..d(E*0.9+0.5)..[[)]]elseif not useTheseSettings then a0="No Saved Variables Found - Exit HUD to save settings"end else a0="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<A then LastMaxBrakeInAtmo=0 end;LastStartTime=A;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=ar end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=au end;VectorStatus="Proceeding to Waypoint"end;local function lo()local function lp(lq,lr)if lq>lr then lr=lq end;local ls,lt=0,0;if ContainerOptimization>0 then ls=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lt=FuelTankOptimization*0.05 end;lr=lr*(1-(ls+lt))return lr end;local lu=core.getElementNameById;local lv=fuelX~=0 and fuelY~=0;for dd in pairs(as)do local type=core.getElementTypeById(as[dd])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(as[dd])),'^.*vertical.*$')then bK=true end end;if n(type,'^.*Space Engine$')then bz=true;if n(tostring(core.getElementTagsById(as[dd])),'^.*vertical.*$')then local lw=core.getElementRotationById(as[dd])if lw[4]<0 then if o(-lw[4],0.1)==0.5 then bx=true end else if o(lw[4],0.1)==0.5 then by=true end end end end;if type=="Landing Gear"then Q=true end;if type=="Dynamic Core Unit"then local lx=h(as[dd])if lx>10000 then C=128 elseif lx>1000 then C=64 elseif lx>150 then C=32 end end;aQ=aQ+h(as[dd])if lv and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lx=h(as[dd])local ly=k(as[dd])local lq=0;local g7=p()if type=="Atmospheric Fuel Tank"then local lr=400;local lz=35.03;if lx>10000 then lr=51200;lz=5480 elseif lx>1300 then lr=6400;lz=988.67 elseif lx>150 then lr=1600;lz=182.67 end;lq=ly-lz;if fuelTankHandlingAtmo>0 then lr=lr+lr*fuelTankHandlingAtmo*0.2 end;lr=lp(lq,lr)aN[#aN+1]={as[dd],lu(as[dd]),lr,lz,lq,g7}end;if type=="Rocket Fuel Tank"then local lr=320;local lz=173.42;if lx>65000 then lr=40000;lz=25740 elseif lx>6000 then lr=5120;lz=4720 elseif lx>700 then lr=640;lz=886.72 end;lq=ly-lz;if fuelTankHandlingRocket>0 then lr=lr+lr*fuelTankHandlingRocket*0.1 end;lr=lp(lq,lr)aP[#aP+1]={as[dd],lu(as[dd]),lr,lz,lq,g7}end;if type=="Space Fuel Tank"then local lr=2400;local lz=182.67;if lx>10000 then lr=76800;lz=5480 elseif lx>1300 then lr=9600;lz=988.67 end;lq=ly-lz;if fuelTankHandlingSpace>0 then lr=lr+lr*fuelTankHandlingSpace*0.2 end;lr=lp(lq,lr)aO[#aO+1]={as[dd],lu(as[dd]),lr,lz,lq,g7}end end end;if not bK then VertTakeOff,VertTakeOffEngine=false,false end end;local function lA()if gyro~=nil then aw=gyro.getState()==1 end;if not stablized then r:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(ap or not ap and ar<10000)then for _,de in pairs(door)do de.toggle()end end;if switch then for _,de in pairs(switch)do de.toggle()end end;if forcefield and(ap or not ap==0 and ar<10000)then for _,de in pairs(forcefield)do de.toggle()end end;if antigrav then bL=antigrav.getState()==1;if bL and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if Q then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if an~=-1 or not ap and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;GearExtended=true;if Q then a.control.extendLandingGears()end else BrakeIsOn=false end;r:setTargetGroundAltitude(bf)if ap and an~=-1 then b7=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ap end;local function lB(lC,lD,lE,lF,cp,cq,lG,lH,lI,lJ)local lK={enableName=lC,disableName=lD,width=lE,height=lF,x=cp,y=cq,toggleVar=lG,toggleFunction=lH,drawCondition=lI,hovered=false}if lJ then table.insert(aH,lK)else table.insert(aG,lK)end;return lK end;local function lL(lM)if not bQ then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif lM=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif lM=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif lM=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bR=ch(lM)showHud=false else bR={}showHud=true end end;local function lN()bQ=not bQ;if bQ then aF=aH;a0="Hold SHIFT to see Settings"bS=showHud else aF=aG;a0="Hold SHIFT to see Control Buttons"lL()showHud=bS end end;local function lO(de)_G[de]=not _G[de]if _G[de]then a0=de.." set to true"else a0=de.." set to false"end;if de=="showHud"then bS=_G[de]elseif de=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif de=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function lP()local lQ=50;local lR=340;local cp=500;local cq=aJ/2-400;local lS=0;for dd,de in pairs(ch("boolean"))do if type(_G[de])=="boolean"then lB(de,de,lR,lQ,cp,cq,function()return _G[de]end,function()lO(de)end,function()return true end,true)cq=cq+lQ+20;if lS==9 then cp=cp+lR+20;cq=aJ/2-400;lS=0 else lS=lS+1 end end end;lB("Control View","Control View",lR,lQ,10,aJ/2-500,function()return true end,lN,function()return true end,true)lB("View Handling Settings",'Hide Handling Settings',lR,lQ,10,aJ/2-(500-lQ),function()return showHandlingVariables end,function()lL("handling")end,function()return true end,true)lB("View Hud Settings",'Hide Hud Settings',lR,lQ,10,aJ/2-(500-lQ*2),function()return showHudVariables end,function()lL("hud")end,function()return true end,true)lB("View Physics Settings",'Hide Physics Settings',lR,lQ,10,aJ/2-(500-lQ*3),function()return showPhysicsVariables end,function()lL("physics")end,function()return true end,true)end;local function lT()local function lU()if dbHud_1 then local position=bI;local g0=planet.name..". "..#SavedLocations;if radar_1 then local dY,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dY~=nil and dY~=""then g0=g0 .." "..radar_1.getConstructName(dY)end end;local cO={}cO={position=position,name=g0,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cO;table.insert(b0[0],cO)ba.UpdateAtlasLocationsList()a0="Location saved as "..g0 else a0="Databank must be installed to save locations"end end;local function lV()TurnBurn=not TurnBurn end;local function lW(lX)if lX==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Y=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function lY()lW(1)end;local function lZ()local cN=-1;cN=ba.findAtlasIndex(b0[0])if cN>-1 then table.remove(b0[0],cN)end;cN=-1;cN=ba.findAtlasIndex(SavedLocations)if cN~=-1 then a0=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cN)end;ba.adjustAutopilotTargetIndex()ba.UpdateAtlasLocationsList()end;local function l_()local g0=AutopilotTargetName;if g0==nil then local hy=cB((bI-CustomTarget.position):len())g0=CustomTarget.name.." "..hy end;if g0==nil then g0="None"end;return"Engage Autopilot: "..g0 end;local function m0()local g0=AutopilotTargetName;if g0==nil then g0=CustomTarget.name end;if g0==nil then g0="None"end;return"Disable Autopilot: "..g0 end;local function m1()if safeMass>0 then a0="Safe Mass set to "..x(au,2).." kg"else a0="Intruder Detection reset\nSafe Mass set to "..x(au,2).." kg"ag=5;bJ=0 end;safeMass=au end;local lQ=50;local lR=260;local m2=lB("Enable Brake Toggle","Disable Brake Toggle",lR,lQ,aI/2-lR/2,aJ/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a0="Brakes in Toggle Mode"else a0="Brakes in Default Mode"end end)lB("Align Prograde","Disable Prograde",lR,lQ,aI/2-lR/2-50-m2.width,aJ/2-lQ+380,function()return ProgradeIsOn end,lY)lB("Align Retrograde","Disable Retrograde",lR,lQ,aI/2-lR/2+m2.width+50,aJ/2-lQ+380,function()return RetrogradeIsOn end,lW,function()return aq==0 end)local m3=lB(l_,m0,600,60,aI/2-600/2,aJ/2-60/2-400,function()return Autopilot end,cI)lB("Save Position","Save Position",200,m3.height,m3.x+m3.width+30,m3.y,function()return false end,lU,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lB("Update Position","Update Position",200,m3.height,m3.x+m3.width+30,m3.y,function()return false end,cL,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lB("Clear Position","Clear Position",200,m3.height,m3.x-200-30,m3.y,function()return true end,lZ,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lQ=60;lR=300;local cp=10;local cq=aJ/2-500;lB("Show Help","Hide Help",lR,lQ,cp,cq,function()return showHelp end,function()showHelp=not showHelp end)cq=cq+lQ+20;lB("View Settings","View Settings",lR,lQ,cp,cq,function()return true end,lN)local cq=aJ/2-300;lB("Enable Turn and Burn","Disable Turn and Burn",lR,lQ,cp,cq,function()return TurnBurn end,lV)lB("Horizontal Takeoff Mode","Vertical Takeoff Mode",lR,lQ,cp+lR+20,cq,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a0="Vertical Takeoff Mode"else a0="Horizontal Takeoff Mode"end end,function()return bK end)cq=cq+lQ+20;lB("Show Orbit Display","Hide Orbit Display",lR,lQ,cp,cq,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a0="Orbit Display Enabled"else a0="Orbit Display Disabled"end end)lB("Engage Orbiting","Cancel Orbiting",lR,lQ,cp+lR+20,cq,function()return IntoOrbit end,cF,function()return aq==0 and unit.getClosestPlanetInfluence()>0 end)cq=cq+lQ+20;lB("Glide Re-Entry","Cancel Glide Re-Entry",lR,lQ,cp,cq,function()return Reentry end,function()ak=true;lY()end,function()return planet.hasAtmosphere and not ap end)lB("Parachute Re-Entry","Cancel Parachute Re-Entry",lR,lQ,cp+lR+20,cq,function()return Reentry end,d2,function()return planet.hasAtmosphere and not ap end)cq=cq+lQ+20;lB("Engage Follow Mode","Disable Follow Mode",lR,lQ,cp,cq,function()return Y end,cH,function()return l()==1 end)lB("Enable Repair Arrows","Disable Repair Arrows",lR,lQ,cp+lR+20,cq,function()return aR end,function()aR=not aR;if aR then a0="Repair Arrows Enabled"else a0="Repair Arrows Diabled"end end,function()return l()==1 end)cq=cq+lQ+20;if not ExternalAGG then lB("Enable AGG","Disable AGG",lR,lQ,cp,cq,function()return bL end,d3,function()return antigrav~=nil end)end;lB("Reset Intruder Alert","Set Safe Mass",lR,lQ,cp+lR+20,cq,function()return safeMass>0 end,m1,function()return IntruderAlertSystem end)cq=cq+lQ+20;lB(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,lR*2,lQ,cp,cq,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a0="IPH Mode: "..iphCondition end)cq=cq+lQ+20;lB(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,lR*2,lQ,cp,cq,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a0="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lk()coroutine.yield()lo()coroutine.yield()bb=jB()lA()lP()lT()aF=aG;coroutine.yield()b0=df()b4=dg()b5=b4(df())b6=eF()b8=f9()b9=fv()ba=jt()bb=jB()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)cb("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(aq>0 or aq==0 and ar<10000)then for _,de in pairs(door)do de.toggle()end end;if switch then for _,de in pairs(switch)do de.toggle()end end;if forcefield and(aq>0 or aq==0 and ar<10000)then for _,de in pairs(forcefield)do de.toggle()end end;safeMass=au;d9()if button then button.activate()end;if SetWaypointOnExit then bb.showWayPoint(planet,bI)end;cb("stop","SU")end;function script.onTick(m4)if m4=="contact"then if not contactTimer then contactTimer=0 end;if A>contactTimer+10 then a0="Radar Contact"cb("rdrCon","RC")contactTimer=A end;unit.stopTimer("contact")elseif m4=="tenthSecond"then local function m5()local m6=system.createData;local m7=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=m7(panelInterplanetary,"value")interplanetaryHeaderText=m6('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=m7(panelInterplanetary,"value")widgetDistanceText=m6('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=m7(panelInterplanetary,"value")widgetTravelTimeText=m6('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=m7(panelInterplanetary,"value")widgetMaxMassText=m6('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=m7(panelInterplanetary,"value")widgetTargetOrbitText=m6('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=m7(panelInterplanetary,"value")widgetCurBrakeDistanceText=m6('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=m7(panelInterplanetary,"value")widgetCurBrakeTimeText=m6('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=m7(panelInterplanetary,"value")widgetMaxBrakeDistanceText=m6('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=m7(panelInterplanetary,"value")widgetMaxBrakeTimeText=m6('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=m7(panelInterplanetary,"value")widgetTrajectoryAltitudeText=m6('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ap then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function m8()s(panelInterplanetary)panelInterplanetary=nil end;local function m9()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bI):len()else AutopilotDistance=(CustomTarget.position-bI):len()end end;local f7=bF;local kC=unit.getThrottle()/100;if AtmoSpeedAssist then kC=G end;local ma,mb=b6.computeDistanceAndTime(bF,MaxGameVelocity,au,a:maxForceForward()*kC,warmup,0)local a6,a7;if not TurnBurn then a6,a7=bb.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=bb.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mc;if not TurnBurn and f7>0 then _,mc=bb.GetAutopilotBrakeDistanceAndTime(f7)else _,mc=bb.GetAutopilotTBBrakeDistanceAndTime(f7)end;local md=0;local me=0;if AutopilotCruising or not Autopilot and f7>5 then me=b6.computeTravelTime(f7,0,AutopilotDistance)elseif a6+ma<AutopilotDistance then md=AutopilotDistance-(a6+ma)me=b6.computeTravelTime(8333.0556,0,md)else local mf=(AutopilotDistance-a6)/ma;ma=AutopilotDistance-a6;mb=mb*mf end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return me elseif AutopilotBraking then return mc elseif AutopilotCruising then return me+mc else return mb+a7+me end end;local function mg(is,mh)if is==nil then is=core.g()end;is=x(is,5)if mh~=nil and mh or(aM==nil or aM~=is)then local fa=core.getVelocity()local f7=vec3(fa):len()local mi=f(unit.getData()).maxBrake;if mi~=nil and mi>0 and ap then mi=mi/q(f7/100,0.1,1)mi=mi/aq;if aq>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mi)/2 else LastMaxBrakeInAtmo=mi end end end;if mi~=nil and mi>0 then LastMaxBrake=mi end;aM=is end end;mg(nil,true)if aq>0 and not WasInAtmo then if not bN and AtmoSpeedAssist and(AltitudeHold or Reentry)then cu(1)K=false end end;if bM~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bM then cx(bM,TRUE)else bM=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then m5()end;if AutopilotTargetName~=nil then local mj=CustomTarget~=nil;local mk=LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=m9()if mj and not Autopilot then ah=(bI-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bI):len()end;if not TurnBurn then a6,a7=bb.GetAutopilotBrakeDistanceAndTime(bF)a8,a9=bb.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=bb.GetAutopilotTBBrakeDistanceAndTime(bF)a8,a9=bb.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hy=cB(ah)t(widgetDistanceText,'{"label": "distance", "value": "'..hy..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..d4(travelTime)..'", "unit":""}')hy=cB(a6)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hy..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..d4(a7)..'", "unit":""}')hy=cB(a8)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hy..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..d4(a9)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mk/1000)..'", "unit":" Tons"}')hy=cB(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..hy..'"}')if aq>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if aq==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else m8()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif m4=="oneSecond"then local function ml(fL)local mm=0;aD=""local mn=aQ;local mo=0;local mp=0;local mq=0;local g9=0;local ga=""local mr=core.getElementHitPointsById;for dd in pairs(as)do local lx=0;local ms=0;ms=h(as[dd])lx=mr(as[dd])mo=mo+lx;if lx<ms then if lx==0 then mq=mq+1 else mp=mp+1 end;if aR and#aA==0 then position=vec3(core.getElementPositionById(as[dd]))local cp=position.x-C;local cq=position.y-C;local iT=position.z-C;table.insert(aA,core.spawnArrowSticker(cp,cq,iT+1,"down"))table.insert(aA,core.spawnArrowSticker(cp,cq,iT+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cp+1,cq,iT,"north"))table.insert(aA,core.spawnArrowSticker(cp+1,cq,iT,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cp-1,cq,iT,"south"))table.insert(aA,core.spawnArrowSticker(cp-1,cq,iT,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cp,cq-1,iT,"east"))table.insert(aA,core.spawnArrowSticker(cp,cq-1,iT,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cp,cq+1,iT,"west"))table.insert(aA,core.spawnArrowSticker(cp,cq+1,iT,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,as[dd])end elseif aR and#aA>0 and aA[11]==as[dd]then for g2 in pairs(aA)do core.deleteSticker(aA[g2])end;aA={}end end;mm=d(mo/mn*100)if mm<100 then fL[#fL+1]=co(0,0,"","pbright txt")g9=d(mm*2.55)ga=e("rgb(%d,%d,%d)",255-g9,g9,0)if mm<100 then fL[#fL+1]=co("50%",1035,"Elemental Integrity: "..mm.."%","txtbig txtmid","fill:"..ga)if mq>0 then fL[#fL+1]=co("50%",1055,"Disabled Modules: "..mq.." Damaged Modules: "..mp,"txtbig txtmid","fill:"..ga)elseif mp>0 then fL[#fL+1]=co("50%",1055,"Damaged Modules: "..mp,"txtbig txtmid","fill:"..ga)end end end end;local function mt()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function mu()local g7=p()local hm=bF;local mv=g7-at;if hm>1.38889 then hm=hm/1000;local mw=hm*(g7-at)TotalDistanceTravelled=TotalDistanceTravelled+mw;ab=ab+mw end;ac=ac+mv;TotalFlightTime=TotalFlightTime+mv;at=g7 end;local function mx()if safeMass>0 then if au>safeMass+50 then bJ=d(au-safeMass)safeMass=-1 elseif au<safeMass then safeMass=au end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mx()end;mu()b9.UpdatePipe()mt()local fL={}b9.ExtraData(fL)if ShowOdometer then fL=b9.DrawOdometer(fL,ab,TotalDistanceTravelled,ac)end;if ShouldCheckDamage then ml(fL)end;ai=table.concat(fL,"")collectgarbage("collect")elseif m4=="fiveSecond"then if not UseSatNav then return end;ao=dbHud_1.getStringValue("SPBAutopilotTargetName")if ao~=nil and ao~=""and ao~="SatNavNotChanged"then local cX=f(dbHud_1.getStringValue("SavedLocations"))if cX~=nil then _G["SavedLocations"]=cX;local cN=-1;local cO;for dd,de in pairs(SavedLocations)do if de.name and de.name=="SatNav Location"then cN=dd;break end end;if cN~=-1 then cO=SavedLocations[cN]cN=-1;for dd,de in pairs(b0[0])do if de.name and de.name=="SatNav Location"then cN=dd;break end end;if cN>-1 then b0[0][cN]=cO end;ba.UpdateAtlasLocationsList()a0=cO.name.." position updated"end end;for i=1,#bT do if bT[i].name==ao then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bT[i].name)ba.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif m4=="msgTick"then local fL={}b9.DisplayMessage(fL,"empty")a0="empty"unit.stopTimer("msgTick")ag=3 elseif m4=="animateTick"then bd=true;bc=false;ae=0;af=0;unit.stopTimer("animateTick")elseif m4=="hudTick"then local function my(fL)local mz=d(q(ah/(aI/4)*255,0,255))fL[#fL+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,d(D+0.5)+mz,d(F+0.5)-mz,d(E+0.5)-mz)end;local function mA()for _,de in pairs(aF)do if de.hovered then if not de.drawCondition or de.drawCondition()then de.toggleFunction()end;de.hovered=false end end end;local function mB()local function mC(mD,mE,cp,cq,lE,lF)if mD>cp and mD<cp+lE and mE>cq and mE<cq+lF then return true else return false end end;local cp=ae+aI/2;local cq=af+aJ/2;for _,de in pairs(aF)do de.hovered=mC(cp,cq,de.x,de.y,de.width,de.height)end end;local function mF(fL)local function mG(fL,mH,hover,cp,cq,f0,mI,mJ,mK,mL,mM)if type(mL)=="function"then mL=mL()end;if type(mM)=="function"then mM=mM()end;fL[#fL+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cp,cq,f0,mI)if mH then fL[#fL+1]=e("%s'",mJ)else fL[#fL+1]=mK end;if hover then fL[#fL+1]=" style='stroke:white; stroke-width:2'"else fL[#fL+1]=" style='stroke:black; stroke-width:1'"end;fL[#fL+1]="></rect>"fL[#fL+1]=e("<text x='%f' y='%f' font-size='24' fill='",cp+f0/2,cq+mI/2+5)if mH then fL[#fL+1]="black"else fL[#fL+1]="white"end;fL[#fL+1]="' text-anchor='middle' font-family='Montserrat'>"if mH then fL[#fL+1]=e("%s</text>",mL)else fL[#fL+1]=e("%s</text>",mM)end end;local mN="rgb(50,50,50)'"local mO="rgb(210,200,200)"local mP=mG;for _,de in pairs(aF)do local lD=de.disableName;local lC=de.enableName;if type(lD)=="function"then lD=lD()end;if type(lC)=="function"then lC=lC()end;if not de.drawCondition or de.drawCondition()then mP(fL,de.toggleVar(),de.hovered,de.x,de.y,de.width,de.height,mO,mN,lD,lC)end end end;local fL={}b9.HUDPrologue(fL)if showHud then b9.UpdateHud(fL)else if AlwaysVSpd then b9.DrawVerticalSpeed(fL,ar)end;b9.DisplayOrbitScreen(fL)b9.DrawWarnings(fL)end;if bQ and bR~={}then b9.DrawSettings(fL)end;b9.UpdateRadar()b9.HUDEpilogue(fL)fL[#fL+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aI,aJ)if a0~="empty"then b9.DisplayMessage(fL,a0)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b9.DrawDeadZone(fL)end end;if w()==0 then if l()==1 and Z then if not AltIsOn then mB()mF(fL)end;if not bc and not bd then local mQ=table.concat(fL,"")fL={}fL[#fL+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aI,aJ)fL[#fL+1]=mQ;fL[#fL+1]="</body>"bc=true;fL[#fL+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fL,"")system.setScreen(content)elseif bd then local mQ=table.concat(fL,"")fL={}fL[#fL+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aI,aJ)fL[#fL+1]=mQ;fL[#fL+1]="</body>"end;if not bc then fL[#fL+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,ae,af)end else mA()end else if not Z and l()==0 then mA()if ah>DeadZone then if DisplayDeadZone then my(fL)end end elseif not AltIsOn then mB()mF(fL)end;fL[#fL+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],L,M,ae,af)end;fL[#fL+1]=[[</svg></body>]]content=table.concat(fL,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif m4=="apTick"then bb.APTick()end end;function script.onFlush()local function mR(mS,kJ)local mT=vec3()local mU=vec3()if mS==axisCommandId.longitudinal then mT=vec3(core.getConstructOrientationForward())mU=bC elseif mS==axisCommandId.vertical then mT=vec3(core.getConstructOrientationUp())mU=bB elseif mS==axisCommandId.lateral then mT=vec3(core.getConstructOrientationRight())mU=bD else return vec3()end;local mV=vec3(core.getWorldGravity())local mW=mV:dot(mU)local mX=vec3(core.getWorldAirFrictionAcceleration())local mY=mX:dot(mU)local mZ=vec3(core.getVelocity())local m_=mZ:dot(mT)local n0=kJ*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(n0-m_)local n1=targetSpeedPID2:get()local n2=(n1-mY-mW)*mU;return n2 end;local function n3(mS,kJ)local mT=vec3()local mU=vec3()if mS==axisCommandId.longitudinal then mT=vec3(core.getConstructOrientationForward())mU=bC elseif mS==axisCommandId.vertical then mT=vec3(core.getConstructOrientationUp())mU=bB elseif mS==axisCommandId.lateral then mT=vec3(core.getConstructOrientationRight())mU=bD else return vec3()end;local mV=vec3(core.getWorldGravity())local mW=mV:dot(mU)local mX=vec3(core.getWorldAirFrictionAcceleration())local mY=mX:dot(mU)local mZ=vec3(core.getVelocity())local m_=mZ:dot(mT)local n0=kJ*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(n0-m_)local n1=targetSpeedPID:get()local n2=(n1-mY-mW)*mU;return n2 end;local function n4(n5,ge,jx)local n6=n5:cross(jx):normalize_inplace()local g_=math.acos(q(n6:dot(-ge),-1,1))*constants.rad2deg;if n6:cross(-ge):dot(jx)<0 then g_=-g_ end;return g_ end;if antigrav and not ExternalAGG then if not bL and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bN=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bN and K then cu(0)K=false elseif not bN and not K then G=0;K=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local n7=q(R+S+system.getControlDeviceForwardInput(),-1,1)local n8=q(U+X+system.getControlDeviceYawInput(),-1,1)local n9=q(V+T-system.getControlDeviceLeftRightInput(),-1,1)local na=W;bG=vec3(core.getWorldVertical())if bG==nil or bG:len()==0 then bG=(planet.center-bI):normalize()end;bB=vec3(core.getConstructWorldOrientationUp())bC=vec3(core.getConstructWorldOrientationForward())bD=vec3(core.getConstructWorldOrientationRight())bE=vec3(core.getWorldVelocity())bI=vec3(core.getConstructWorldPos())au=core.getConstructMass()bF=vec3(bE):len()bH=-bG:dot(bE)bP=getRoll(bG,bC,bD)local nb=bP/180*math.pi;local nc=math.cos(nb)local nd=math.sin(nb)bO=n4(bG,bC,bD*nc+bB*nd)local ne=bE:normalize()local nf=c(bP)local ng=utils.sign(bP)local nh=vec3(core.getWorldAngularVelocity())local ni=n7*pitchSpeedFactor*bD+n8*rollSpeedFactor*bC+n9*yawSpeedFactor*bB;if be==true and bG:len()>0.01 then local nj=c(bi-bP)if((ProgradeIsOn or Reentry or BrakeLanding or ak or AltitudeHold or IntoOrbit)and nj>0 or aq>0.0 and nj<autoRollRollThreshold and autoRollPreference)and n8==0 and c(bO)<85 then local nk=bi;local nl=autoRollFactor;if aq==0 then nl=nl/4;bi=0;nk=0 end;if rollPID==nil then rollPID=pid.new(nl*0.01,0,nl*0.1)end;rollPID:inject(nk-bP)local nm=rollPID:get()ni=ni+nm*bC end end;if bG:len()>0.01 and aq>0.0 then local nn=20.0;if turnAssist==true and nf>nn and n7==0 and n9==0 then local no=turnAssistFactor*0.1;local np=turnAssistFactor*0.025;local nq=(nf-nn)/(180-nn)*180;local nr=0;if nq<90 then nr=nq/90 elseif nq<180 then nr=(180-nq)/90 end;nr=nr*nr;local ns=-ng*np*(1.0-nr)local nt=no*nr;ni=ni+nt*bD+ns*bB end end;local nu=1;local nw=0;local nx=1;if system.getMouseWheel()>0 then if AltIsOn then if aq>0 or Reentry then bl=q(bl+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif av then local ny=G;G=x(q(G+speedChangeLarge/100,-1,1),2)if G>=0 and ny<0 then G=0;av=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if aq>0 or Reentry then bl=q(bl-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif av then local ny=G;G=x(q(G-speedChangeLarge/100,-1,1),2)if G<=0 and ny>0 then G=0;av=false end end else av=true end;H=0;if ap and AtmoSpeedAssist and bN then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bl/3.6-bE:dot(bC))local nz=throttlePID:get()J=q(nz,-1,1)if J<G and aq>0.005 then I=true;r:setThrottleCommand(axisCommandId.longitudinal,q(J,0.01,1))else I=false;r:setThrottleCommand(axisCommandId.longitudinal,G)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bE:len()-bl/3.6)local nA=q(brakePID:get(),0,1)if aq>0 and bH<-80 or aq>0.005 then H=nA end;if H>0 then if I and J==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else J=q(J,0.01,1)end;local nB=''local nC=vec3()local nD=mR(axisCommandId.vertical,ad*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nD,nw)local nE='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nE=nE..ExtraLongitudeTags end;local nF=r:getAxisCommandType(axisCommandId.longitudinal)local nG=r:composeAxisAccelerationFromThrottle(nE,axisCommandId.longitudinal)local nH=n3(axisCommandId.lateral,LeftAmount*1000)nB=nB..' , '.."lateral airfoil , lateral ground "nC=nC+nH;if nC:len()>constants.epsilon then a:setEngineForceCommand(nB,nC,nw,'','','',nx)end;a:setEngineForceCommand(nE,nG,nu)local nI='thrust analog vertical fueled 'local nJ='thrust analog lateral fueled 'if ExtraLateralTags~="none"then nJ=nJ..ExtraLateralTags end;if ExtraVerticalTags~="none"then nI=nI..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(nI,nD,nu)else a:setEngineForceCommand(nI,vec3(),nu)end;if LeftAmount~=0 then a:setEngineForceCommand(nJ,nH,nu)else a:setEngineForceCommand(nJ,vec3(),nu)end;if na==0 then na=H end;local nK=-na*(brakeSpeedFactor*bE+brakeFlatFactor*ne)a:setEngineForceCommand('brake',nK)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,G)end;local kJ=unit.getAxisCommandValue(0)if not bN then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bE:len()-kJ/3.6)local nA=q(brakePID:get(),0,1)na=q(na+nA,0,1)end;local nK=-na*(brakeSpeedFactor*bE+brakeFlatFactor*ne)a:setEngineForceCommand('brake',nK)local nB=''local nC=vec3()local nL=false;local nE='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then nE=nE..ExtraLongitudeTags end;local nF=r:getAxisCommandType(axisCommandId.longitudinal)if nF==axisCommandType.byThrottle then local nG=r:composeAxisAccelerationFromThrottle(nE,axisCommandId.longitudinal)a:setEngineForceCommand(nE,nG,nu)elseif nF==axisCommandType.byTargetSpeed then local nG=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nB=nB..' , '..nE;nC=nC+nG;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then nL=true end end;local nJ='thrust analog lateral 'if ExtraLateralTags~="none"then nJ=nJ..ExtraLateralTags end;local nM=r:getAxisCommandType(axisCommandId.lateral)if nM==axisCommandType.byThrottle then local nN=r:composeAxisAccelerationFromThrottle(nJ,axisCommandId.lateral)a:setEngineForceCommand(nJ,nN,nu)elseif nM==axisCommandType.byTargetSpeed then local nH=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nB=nB..' , '..nJ;nC=nC+nH end;local nI='thrust analog vertical 'if ExtraVerticalTags~="none"then nI=nI..ExtraVerticalTags end;local nO=r:getAxisCommandType(axisCommandId.vertical)if nO==axisCommandType.byThrottle then local nD=r:composeAxisAccelerationFromThrottle(nI,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(nI,nD,nu,'airfoil','ground','',nx)else a:setEngineForceCommand(nI,vec3(),nu)a:setEngineForceCommand('airfoil vertical',nD,nu,'airfoil','','',nx)a:setEngineForceCommand('ground vertical',nD,nu,'ground','','',nx)end elseif nO==axisCommandType.byTargetSpeed then if ad<0 then a:setEngineForceCommand('hover',vec3(),nu)end;local nP=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nB=nB..' , '..nI;nC=nC+nP end;if nC:len()>constants.epsilon then if W~=0 or nL or c(ne:dot(bC))<0.8 then nB=nB..', brake'end;a:setEngineForceCommand(nB,nC,nw,'','','',nx)end end;local nQ=torqueFactor*(ni-nh)local nR=vec3(core.getWorldAirFrictionAngularAcceleration())nQ=nQ-nR;a:setEngineTorqueCommand('torque',nQ,nu,'airfoil','','',nx)a:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local f7=vec3(core.getVelocity()):len()local nS=0.15;if not bN then local nT=r:getTargetSpeed(axisCommandId.longitudinal)if f7*3.6>nT*(1-nS)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f7*3.6<nT*(1-nS)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kC=unit.getThrottle()if AtmoSpeedAssist then kC=G*100 end;local kJ=kC/100;if j==0 then kJ=kJ*MaxGameVelocity;if f7>=kJ*(1-nS)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f7<kJ*(1-nS)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kU=d(bl)kJ=kJ*kU/3.6;if f7>=kJ*(1-nS)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif f7<kJ*(1-nS)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local jr=coroutine.status(beginSetup)if jr=="suspended"then local cv,js=coroutine.resume(beginSetup)if js then system.print("ERROR STARTUP: "..js)end elseif jr=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not bc and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(nU)local z=1;local function nV(nW)local function nX(nY,nW)local nZ={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local n_=nY;for _,de in ipairs(nZ)do if nW and n_>de then nY=de elseif nY<de and not nW then nY=de;break end end;return nY end;if nW then z=-1 end;if not ExternalAGG and bL then if Z and nW then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+z*a2;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+z*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if Z then bu=nX(bu,nW)else bu=bu+z*a1 end;if bu<planet.noAtmosphericDensityAltitude then bu=planet.noAtmosphericDensityAltitude end else if Z and ap then HoldAltitude=nX(HoldAltitude,nW)else HoldAltitude=HoldAltitude+z*a1 end end else r:updateTargetGroundAltitudeFromActionStart(z*1.0)end end;local function o0(nW)if nW then z=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=q(G+z*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,z*speedChangeLarge)end else if nW then z=1 else z=nil end;ba.adjustAutopilotTargetIndex(z)end end;local function o1(o2)if not ap then a0="Flight Assist in Atmo only"return end;local dl=type(o2)if bX==nil then if dl=="table"then if Autopilot or VectorToTarget then cI()end;cb("180On","BR")elseif dl==1 then cb("bnkLft","BR")else cb("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cG()if dl~="table"then o2=o2+1 end end;bX=o2 elseif dl=="table"then cb("180Off","BR")bX=nil end end;if nU=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cu(0)if vBooster or hover then if ap and an==-1 then cb("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;be=true;GearExtended=false else if Q then cb("grOut","LG",1)a.control.extendLandingGears()end;r:setTargetGroundAltitude(LandingGearGroundHeight)if ap then BrakeIsOn=true end end end;if Q and not BrakeLanding and not(vBooster or hover)then cb("grOut","LG",1)a.control.extendLandingGears()end else if Q then cb("grIn","LG",1)a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif nU=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif nU=="forward"then R=R-1 elseif nU=="backward"then if AltIsOn then o1(-bE*5000)else R=R+1 end elseif nU=="left"then if AltIsOn then o1(1)else U=U-1 end elseif nU=="right"then if AltIsOn then o1(3)else U=U+1 end elseif nU=="yawright"then V=V-1 elseif nU=="yawleft"then V=V+1 elseif nU=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif nU=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif nU=="up"then ad=ad+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif nU=="down"then ad=ad-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif nU=="groundaltitudeup"then nV()elseif nU=="groundaltitudedown"then nV(true)elseif nU=="option1"then ba.adjustAutopilotTargetIndex()toggleView=false elseif nU=="option2"then ba.adjustAutopilotTargetIndex(1)toggleView=false elseif nU=="option3"then local function o3()aE=not aE;if not aE then cb("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else cb("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;o3()toggleView=false elseif nU=="option4"then bX=nil;cI()toggleView=false elseif nU=="option5"then function ToggleLockPitch()if LockPitch==nil then cb("lkPOn","LP")LockPitch=bO;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else cb("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif nU=="option6"then cG()toggleView=false elseif nU=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a0="Collision System Enabled"else a0="Collision System Secured"end;toggleView=false elseif nU=="option8"then stablized=not stablized;if not stablized then a0="DeCoupled Mode - Ground Stabilization off"r:deactivateGroundEngineAltitudeStabilization()cb("gsOff","GS")else a0="Coupled Mode - Ground Stabilization on"r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)cb("gsOn","GS")end;toggleView=false elseif nU=="option9"then if gyro~=nil then gyro.toggle()aw=gyro.getState()==1;if aw then cb("gyOn","GA")else cb("gyOff","GA")end end;toggleView=false elseif nU=="lshift"then if AltIsOn then Z=true;return end;if w()==1 then Z=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then Z=true;bd=false;bc=false end elseif nU=="brake"then if BrakeToggleStatus then cQ()elseif not BrakeIsOn then cQ()else BrakeIsOn=true end elseif nU=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif nU=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a5 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a5=false end elseif nU=="stopengines"then local function o4()if A-B<1.5 then cb("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bX=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Y=false;N=false;ak=false;al=false;P=false;be=autoRollPreference;VectorToTarget=false;TurnBurn=false;aw=false;LockPitch=nil;IntoOrbit=false end end;o4()B=A;if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if G~=0 then r:resetCommand(axisCommandId.longitudinal)cu(0)else cu(100)end else if r:getTargetSpeed(axisCommandId.longitudinal)~=0 then r:resetCommand(axisCommandId.longitudinal)else if ap then cx(AtmoSpeedLimit)else cx(MaxGameVelocity*3.6)end end end elseif nU=="speedup"then o0()elseif nU=="speeddown"then o0(true)elseif nU=="antigravity"and not ExternalAGG then if antigrav~=nil then d3()end end end;function script.onActionStop(nU)local function o5()if not ExternalAGG and bL then a4=a2 end;if AltitudeHold or VertTakeOff or IntoOrbit then a3=a1 end end;if nU=="forward"then R=0 elseif nU=="backward"then R=0 elseif nU=="left"then if bX==2 then bX=0 else bX=nil end;U=0 elseif nU=="right"then if bX==4 then bX=0 else bX=nil end;U=0 elseif nU=="yawright"then V=0 elseif nU=="yawleft"then V=0 elseif nU=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif nU=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif nU=="up"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif nU=="down"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif nU=="groundaltitudeup"then o5()toggleView=false elseif nU=="groundaltitudedown"then o5()toggleView=false elseif nU=="lshift"then if w()==1 then ae=0;af=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then bd=false;bc=false end;Z=false elseif nU=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cQ()else BrakeIsOn=false end end elseif nU=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(nU)local z=1;local function o6(nW)if nW then z=-1 end;if not ExternalAGG and bL then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+z*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a4=a4*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+z*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bu=bu+z*a3;if bu<planet.noAtmosphericDensityAltitude then bu=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+z*a3 end;a3=a3*1.05 else r:updateTargetGroundAltitudeFromActionLoop(z*1.0)end end;local function o7(nW)if nW then z=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then G=q(G+z*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,z*speedChangeSmall)end end end;if nU=="groundaltitudeup"then if not Z then o6()end elseif nU=="groundaltitudedown"then if not Z then o6(true)end elseif nU=="speedup"then o7()elseif nU=="speeddown"then o7(true)end end;function script.onInputText(cr)local function o8()for dd,de in pairs(ch())do dbHud_1.setStringValue(de,g(nil))end;for dd,de in pairs(b)do if de~="SavedLocations"then dbHud_1.setStringValue(de,g(nil))end end;a0="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ag=5;aK=false end;local function o9(g0,c7)local oa=false;local du='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dG,dH,dO,dP,dQ=n(c7,du)for _,de in pairs(b5[0])do if de.name==g0 then dP=math.rad(dP)dO=math.rad(dO)local planet=b0[tonumber(dG)][tonumber(dH)]local eC=math.cos(dO)local ob=vec3(eC*math.cos(dP),eC*math.sin(dP),math.sin(dO))return planet.center+(planet.radius+dQ)*ob end end;return g0 .." not found"end;local function oc(od,planet,c7,gW)local function oe(c7)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dG,dH,dO,dP,dQ=n(c7,du)if dG=="0"and dH=="0"then return vec3(tonumber(dO),tonumber(dP),tonumber(dQ))end;dP=math.rad(dP)dO=math.rad(dO)local planet=b0[tonumber(dG)][tonumber(dH)]local eC=math.cos(dO)local ob=vec3(eC*math.cos(dP),eC*math.sin(dP),math.sin(dO))return planet.center+(planet.radius+dQ)*ob end;if dbHud_1 or gW then local cO={}local position=oe(c7)if planet.name=="Space"then cO={position=position,name=od,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cO={position=position,name=od,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;if not gW then SavedLocations[#SavedLocations+1]=cO else for dd,de in pairs(b0[0])do if de.name and od==de.name then table.remove(b0[0],dd)end end end;table.insert(b0[0],cO)ba.UpdateAtlasLocationsList()else a0="Databank must be installed to save permanent locations"end end;local i;local of,og=nil,nil;local oh="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cr," ")of=cr;if i~=nil then of=string.sub(cr,0,i-1)og=string.sub(cr,i+1)end;if of=="/help"or of=="/commands"then for iy in string.gmatch(oh,"([^\n]+)")do system.print(iy)end;return elseif of=="/setname"then if og==nil or og==""then a0="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cL(og)else a0="Select a saved target to rename first"end elseif of=="/addlocation"or string.find(cr,"::pos")~=nil then local gW=false;local od="0-Temp"if og==nil or og==""then og=of;gW=true end;i=string.find(og,"::")if not gW then od=string.sub(og,1,i-2)end;local c7=string.sub(og,i)local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local du='::pos{'..num..','..num..','..num..','..num..','..num..'}'local dG,dH,dO,dP,dQ=n(c7,du)local planet=b0[tonumber(dG)][tonumber(dH)]if planet.name=="Space"then local oi=vec3(tonumber(dO),tonumber(dP),tonumber(dQ))local dL=sys:closestBody(oi)if(oi-dL.center):len()<dL.radius+dL.noAtmosphericDensityAltitude then planet=dL end end;oc(od,planet,c7,gW)a0="Added "..od.." to saved locations,\nplanet "..planet.name.." at "..c7;ag=5 elseif of=="/agg"then if og==nil or og==""then a0="Usage: /agg targetheight"return end;og=tonumber(og)if og<1000 then og=1000 end;AntigravTargetAltitude=og;a0="AGG Target Height set to "..og elseif of=="/G"then if og==nil or og==""then a0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if og=="dump"then for dd,de in pairs(ch())do if type(_G[de])=="boolean"then if _G[de]==true then system.print(de.." true")else system.print(de.." false")end elseif _G[de]==nil then system.print(de.." nil")else system.print(de.." ".._G[de])end end;return end;i=string.find(og," ")local oj=string.sub(og,0,i-1)local ok=string.sub(og,i+1)for dd,de in pairs(ch())do if de==oj then a0="Variable "..oj.." changed to "..ok;local ol=type(_G[de])if ol=="number"then ok=tonumber(ok)elseif ol=="boolean"then if string.lower(ok)=="true"then ok=true else ok=false end end;_G[de]=ok;return end end;a0="No such global variable: "..oj elseif of=="/copydatabank"then if dbHud_2 then d9(true)else a0="Spare Databank required to copy databank"end elseif of=="/iphWP"then if AutopilotTargetIndex>0 then system.print(bb.showWayPoint(aa,AutopilotTargetCoords,true))a0="::pos waypoint shown in lua chat"else a0="No target selected in IPH"end end end;function script.onEnter(dY)if radar_1 and not ap and not bU then unit.setTimer("contact",0.1)end end;function script.onLeave(dY)if radar_1 and CollisionSystem then dY=tostring(dY)contacts[dY]=nil end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
