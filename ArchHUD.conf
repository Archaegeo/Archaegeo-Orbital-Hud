name: ArchHud - Archaegeo v1.502 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.502;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;BrakeForceMultiplier=1.0;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","BrakeForceMultiplier"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8,a9=0;local aa,ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=0;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;function p(bP)system.print(E..": "..bP)end;local function bQ(bR)local bS,bT,bU=aR:getPlanetarySystem(0):castIntersections(bv,bR,function(bV)if bV.noAtmosphericDensityAltitude>0 then return bV.radius+bV.noAtmosphericDensityAltitude else return bV.radius+bV.surfaceMaxAltitude*1.5 end end)local bW=bT;if bU~=nil and bT~=nil then bW=math.min(bU,bT)end;if bW~=nil then return bS,bW else return nil,nil end end;local function bX(bY,bZ,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..bY.."|"..bZ.."|"..soundVolume)end end;local function b_(c0,c1)for i=1,#c1 do c0[#c0+1]=c1[i]end;return c0 end;local function c2(c3)local c4={}local c5={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","Cockpit","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local c6={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c7={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local c8={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c3 then b_(c4,c5)b_(c4,c6)b_(c4,c7)b_(c4,c8)return c4 elseif c3=="boolean"then return c5 elseif c3=="handling"then return c6 elseif c3=="hud"then return c7 elseif c3=="physics"then return c8 end end;local function c9(ca,cb,cc,cd,ce)if cd==nil then cd=""end;if ce==nil then ce=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cd,ca,cb,ce,cc)end;local function cf(cg,ch)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not ch then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cg)K=r(A(cg*100,0)/100,-1,1)end;local function ci(cg,ch)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not ch then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cg)bz=cg end;local function cj(ck,cl)if ck==0 then return d(cl)<1e-09 end;if cl==0 then return d(ck)<1e-09 end;return d(ck-cl)<math.max(d(ck),d(cl))*epsilon end;local function cm(aj,cn)local co=aj>100000;if cn==nil then cn=1 end;if co then return A(aj/1000/200,cn).."SU"elseif aj<1000 then return A(aj,cn).."M"else return A(aj/1000,cn).."KM"end end;local function cp()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)ci(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cq()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then bX("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then bX("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cr()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bX("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cq()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cq()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then bX("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cp()end else bX("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cp()end end;if am then HoldAltitude=100000 end else bX("altOff","AH")if IntoOrbit then cq()end;if VertTakeOff then cp()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cs()local function ct(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cr()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bX("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bX("apSpc","AP")if ar~=0 then am=true;cr()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then bX("vtt","AP")ct(SpaceTarget)end else bX("apOn","AP")if not(ac.name==planet.name and bM)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cq()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cq()end end end else bX("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cr()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cq()else bX("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else bX("apP","AP")am=true;cr()end else bX("apOff","AP")am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;P=false;AutoTakeoff=false;AltitudeHold=false;HoldAltitude=as;TargetSet=false;Reentry=false;if IntoOrbit then cq()end end end;local function cu()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then bX("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cp()end;if IntoOrbit then cq()end;b0=autoRollPreference;al=false;an=false;af=0 else bX("bkOff","B",1)end end;local function cv()if Reentry then a2="Re-Entry cancelled"bX("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;bX("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cc=cm(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..cc;bX("glide","RE")ci(e(b7))end;AutoTakeoff=false end;local function cw()if antigrav and not ExternalAGG then if by then bX("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bX("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cx(cy)local cz=0;local cA=0;local cB=0;if cy<60 then cy=e(cy)elseif cy<3600 then cz=e(cy/60)cy=e(cy%60)elseif cy<86400 then cA=e(cy/3600)cz=e(cy%3600/60)else cB=e(cy/86400)cA=e(cy%86400/3600)end;if cB>0 then return cB.."d "..cA.."h "elseif cA>0 then return cA.."h "..cz.."m "elseif cz>0 then return cz.."m "..cy.."s"elseif cy>0 then return cy.."s"else return"0s"end end;local function cC(cD)local function cE(cF)for cG,cH in pairs(cF)do dbHud_1.setStringValue(cH,h(_G[cH]))if cD and dbHud_2 then dbHud_2.setStringValue(cH,h(_G[cH]))end end end;if dbHud_1 then cE(c)cE(c2())system.print("Saved Variables to Datacore")if cD and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cI()local function cJ(cK)return type(cK)=='number'end;local function cL(cK)return type(z(cK))=='number'end;local function cM(cN)return type(cN)=='table'end;local function cO(cP)return type(cP)=='string'end;local function cQ(cH)return cM(cH)and cJ(cH.x and cH.y and cH.z)end;local function cR(cS)return cM(cS)and cJ(cS.latitude and cS.longitude and cS.altitude and cS.id and cS.systemId)end;local cT=math.pi/180;local cU=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cW(cK)local cX=string.gsub(string.reverse(f('%.4f',cK)),'^0*%.?','')return cX==''and'0'or string.reverse(cX)end;local function cY(cZ)if cQ(cZ)then return f('{x=%.3f,y=%.3f,z=%.3f}',cZ.x,cZ.y,cZ.z)end;if cM(cZ)and not getmetatable(cZ)then local c_={}local d0=next(cZ)if type(d0)=='nil'or d0==1 then c_=cZ else for cG,cH in pairs(cZ)do local cg=cY(cH)if type(cG)=='number'then table.insert(c_,f('[%s]=%s',cG,cg))else table.insert(c_,f('%s=%s',cG,cg))end end end;return f('{%s}',table.concat(c_,','))end;if cO(cZ)then return f("'%s'",cZ:gsub("'",[[\']]))end;return tostring(cZ)end;local d1={}d1.__index=d1;d1.__tostring=function(cZ,d2)local d3={}for cG in pairs(cZ)do table.insert(d3,cG)end;table.sort(d3)local c_={}for _,cG in ipairs(d3)do local cg=cY(cZ[cG])if type(cG)=='number'then table.insert(c_,f('[%s]=%s',cG,cg))else table.insert(c_,f('%s=%s',cG,cg))end end;if d2 then return f('%s%s',d2,table.concat(c_,',\n'..d2))end;return f('{%s}',table.concat(c_,','))end;d1.__eq=function(d4,d5)return d4.systemId==d5.systemId and d4.id==d5.id and cj(d4.radius,d5.radius)and cj(d4.center.x,d5.center.x)and cj(d4.center.y,d5.center.y)and cj(d4.center.z,d5.center.z)and cj(d4.GM,d5.GM)end;local function d6(d7,d8,d9,da,db)assert(cL(d7),'Argument 1 (systemId) must be a number:'..type(d7))assert(cL(d8),'Argument 2 (id) must be a number:'..type(d8))assert(cL(d9),'Argument 3 (radius) must be a number:'..type(d9))assert(cM(da),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(da))assert(cL(db),'Argument 5 (GM) must be a number:'..type(db))return setmetatable({systemId=z(d7),id=z(d8),radius=z(d9),center=vec3(da),GM=z(db)},d1)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cW(p.latitude*cU),cW(p.longitude*cU),cW(p.altitude))end;MapPosition.__eq=function(d4,d5)return d4.id==d5.id and d4.systemId==d5.systemId and cj(d4.latitude,d5.latitude)and cj(d4.altitude,d5.altitude)and(cj(d4.longitude,d5.longitude)or cj(d4.latitude,math.pi/2)or cj(d4.latitude,-math.pi/2))end;local function dc(dd,d8,de,df,dg)local d7=dd;if cO(dd)and not df and not dg and not d8 and not de then d7,d8,de,df,dg=o(dd,cV)assert(d7,'Argument 1 (position string) is malformed.')else assert(cL(d7),'Argument 1 (systemId) must be a number:'..type(d7))assert(cL(d8),'Argument 2 (id) must be a number:'..type(d8))assert(cL(de),'Argument 3 (latitude) must be in degrees:'..type(de))assert(cL(df),'Argument 4 (longitude) must be in degrees:'..type(df))assert(cL(dg),'Argument 5 (altitude) must be in meters:'..type(dg))end;d7=z(d7)d8=z(d8)de=z(de)df=z(df)dg=z(dg)if d8==0 then return setmetatable({latitude=de,longitude=df,altitude=dg,id=d8,systemId=d7},MapPosition)end;return setmetatable({latitude=cT*r(de,-90,90),longitude=cT*(df%360),altitude=dg,id=d8,systemId=d7},MapPosition)end;local dh={}dh.__index=dh;dh.__tostring=function(cZ,d2)local di=d2 and d2 ..'  'local dj={}local d3={}for cG in pairs(cZ)do table.insert(d3,cG)end;table.sort(d3)for _,dk in ipairs(d3)do bdy=cZ[dk]local dl=d1.__tostring(bdy,di)if d2 then table.insert(dj,f('[%s]={\n%s\n%s}',dk,dl,d2))else table.insert(dj,f('  [%s]=%s',dk,dl))end end;if d2 then return f('\n%s%s%s',d2,table.concat(dj,',\n'..d2),d2)end;return f('{\n%s\n}',table.concat(dj,',\n'))end;local function dm(dn)local b={}local pid;for _,cH in pairs(dn)do local d8=cH.planetarySystemId;if type(d8)~='number'then error('Invalid planetary system ID: '..tostring(d8))elseif pid and d8~=pid then error('Mistringmatch planetary system IDs: '..d8 ..' and '..pid)end;local dp=cH.bodyId;if type(dp)~='number'then error('Invalid body ID: '..tostring(dp))elseif b[dp]then error('Duplicate body ID: '..tostring(dp))end;setmetatable(cH.center,getmetatable(vec3.unit_x))b[dp]=setmetatable(cH,d1)pid=d8 end;return setmetatable(b,dh)end;aQ={}local function dq(dn)return setmetatable({galaxyAtlas=dn or{}},aQ)end;aQ.__index=function(cN,i)if type(i)=='number'then local system=cN.galaxyAtlas[i]return dm(system)end;return rawget(aQ,i)end;aQ.__pairs=function(cZ)return function(cN,cG)local dr,nv=next(cN,cG)return dr,nv and dm(nv)end,cZ.galaxyAtlas,nil end;aQ.__tostring=function(cZ)local ds={}for _,dt in pairs(cZ or{})do local du=dt:getPlanetarySystemId()local dv=dh.__tostring(dt,'    ')table.insert(ds,f('  [%s]={%s\n  }',du,dv))end;return f('{\n%s\n}\n',table.concat(ds,',\n'))end;aQ.BodyParameters=d6;aQ.MapPosition=dc;aQ.PlanetarySystem=dm;function aQ.createBodyParameters(d7,d8,dw,dx,dy,dz,dA)assert(cL(d7),'Argument 1 (systemId) must be a number:'..type(d7))assert(cL(d8),'Argument 2 (id) must be a number:'..type(d8))assert(cL(dw),'Argument 3 (surfaceArea) must be a number:'..type(dw))assert(cM(dx),'Argument 4 (aPosition) must be an array or vec3:'..type(dx))assert(cM(dy),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dy))assert(cL(dz),'Argument 6 (altitude) must be in meters:'..type(dz))assert(cL(dA),'Argument 7 (gravityAtPosition) must be number:'..type(dA))local d9=y(dw/4/math.pi)local aj=d9+dz;local dB=vec3(dx)+aj*vec3(dy)local db=dA*aj*aj;return d6(d7,d8,d9,dB,db)end;aQ.isMapPosition=cR;function aQ:getPlanetarySystem(dd)if i==nil then i=0 end;if nv==nil then nv=0 end;local d7=dd;if cR(dd)then d7=dd.systemId end;if type(d7)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dh then system=dm(system)end;return system end end end;function dh:sizeCalculator(bV)return 1.05*bV.radius end;function dh:castIntersections(dC,dD,dE,dF,dG,dH)local dI={}local dJ=dG or self;for _,bV in pairs(dJ)do table.insert(dI,bV)end;if not dH then table.sort(dI,function(dK,dL)return(dK.center-dC):len()<(dL.center-dC):len()end)end;local dM=dD:normalize()for _,bV in ipairs(dI)do local dN=bV.center-dC;local d9=self:sizeCalculator(bV)local dO=dN:dot(dM)local dP=dO^2-(dN:len2()-d9^2)if dP>=0 then local dQ=y(dP)local bT=dO+dQ;local bU=dO-dQ;if bU>0 then return bV,bT,bU elseif bT>0 then return bV,bT,nil end end end;return nil,nil,nil end;function dh:closestBody(dR)assert(type(dR)=='table','Invalid coordinates.')local dS,bV;local dT=vec3(dR)for _,dU in pairs(self)do local dV=(dU.center-dT):len2()if(not bV or dV<dS)and dU.name~="Space"then bV=dU;dS=dV end end;return bV end;function dh:convertToBodyIdAndWorldCoordinates(dd)local dW=dd;if cO(dd)then dW=dc(dd)end;if dW.id==0 then return 0,vec3(dW.latitude,dW.longitude,dW.altitude)end;local dU=self:getBodyParameters(dW)if dU then return dW.id,dU:convertToWorldCoordinates(dW)end end;function dh:getBodyParameters(dd)local d8=dd;if cR(dd)then d8=dd.id end;assert(cL(d8),'Argument 1 (id) must be a number:'..type(d8))return self[d8]end;function dh:getPlanetarySystemId()local _,cH=next(self)return cH and cH.systemId end;function d1:convertToMapPosition(da)assert(cM(da),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(da))local dX=vec3(da)if self.id==0 then return setmetatable({latitude=dX.x,longitude=dX.y,altitude=dX.z,id=0,systemId=self.systemId},MapPosition)end;local dY=dX-self.center;local aj=dY:len()local dg=aj-self.radius;local de=0;local df=0;if not cj(aj,0)then local dZ=n(dY.y,dY.x)df=dZ>=0 and dZ or 2*math.pi+dZ;de=math.pi/2-math.acos(dY.z/aj)end;return setmetatable({latitude=de,longitude=df,altitude=dg,id=self.id,systemId=self.systemId},MapPosition)end;function d1:convertToWorldCoordinates(dd)local dW=cO(dd)and dc(dd)or dd;if dW.id==0 then return vec3(dW.latitude,dW.longitude,dW.altitude)end;assert(cR(dW),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dW.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dW.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local d_=math.cos(dW.latitude)return self.center+(self.radius+dW.altitude)*vec3(d_*math.cos(dW.longitude),d_*math.sin(dW.longitude),math.sin(dW.latitude))end;function d1:getAltitude(da)return(vec3(da)-self.center):len()-self.radius end;function d1:getDistance(da)return(vec3(da)-self.center):len()end;function d1:getGravity(da)local e0=self.center-vec3(da)local e1=e0:len2()return self.GM/e1*e0/y(e1)end;return setmetatable(aQ,{__call=function(_,...)return dq(...)end})end;local function e2()local aS={}local e3=30000000/3600;local e4=e3*e3;local e5=100;function aS.computeAccelerationTime(e6,e7,e8)local e9=e3*math.asin(e6/e3)return(e3*math.asin(e8/e3)-e9)/e7 end;function aS.computeDistanceAndTime(e6,e8,ea,eb,ec,ed)ec=ec or 0;ed=ed or 0;local ee=e6<=e8;local ef=eb*(ee and 1 or-1)/ea;local eg=-ed/ea;local eh=ef+eg;if ee and eh<=0 or not ee and eh>=0 then return-1,-1 end;local ei,ej=0,0;if ef~=0 and ec>0 then local e9=math.asin(e6/e3)local ek=math.pi*(ef/2+eg)local el=ef*ec;local em=e3*math.pi;local cH=function(cN)local en=(ek*cN-el*math.sin(math.pi*cN/2/ec)+em*e9)/em;local eo=math.tan(en)return e3*eo/y(eo*eo+1)end;local ep=ee and function(cP)return cP>=e8 end or function(cP)return cP<=e8 end;ej=2*ec;if ep(cH(ej))then local eq=0;while d(ej-eq)>0.5 do local cN=(ej+eq)/2;if ep(cH(cN))then ej=cN else eq=cN end end end;local er=e6;local es=ej/e5;for et=1,e5 do local eu=cH(et*es)ei=ei+(eu+er)*es/2;er=eu end;if ej<2*ec then return ei,ej end;e6=er end;local e9=e3*math.asin(e6/e3)local E=(e3*math.asin(e8/e3)-e9)/eh;local ev=e4*math.cos(e9/e3)/eh;local aj=ev-e4*math.cos((eh*E+e9)/e3)/eh;return aj+ei,E+ej end;function aS.computeTravelTime(e6,e7,aj)if aj==0 then return 0 end;if e7>0 then local e9=e3*math.asin(e6/e3)local ev=e4*math.cos(e9/e3)/e7;return(e3*math.acos(e7*(ev-aj)/e4)-e9)/e7 end;if e6==0 then return-1 end;assert(e6>0,'Acceleration and initial speed are both zero.')return aj/e6 end;return aS end;local function ew()local vec3=require('cpml.vec3')local cI=cI()local function cO(cP)return type(cP)=='string'end;local function cM(cN)return type(cN)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dg)assert(self.body)local aj=dg+self.body.radius;if not cj(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dd,ex)assert(self.body)assert(cM(dd)or cO(dd))assert(cM(ex))local ey=(cO(dd)or cI.isMapPosition(dd))and self.body:convertToWorldCoordinates(dd)or vec3(dd)local cH=vec3(ex)local ez=ey-self.body.center;local eA=cH:len2()local eB=ez:len()local eC=self.body.GM;local eD=((eA-eC/eB)*ez-ez:dot(cH)*cH)/eC;local ck=eC/(2*eC/eB-eA)local eE=eD:len()local dM=eD:normalize()local eF=ck*(1-eE)local eG=ck*(1+eE)local eH=eF*dM+self.body.center;local eI=eE<=1 and-eG*dM+self.body.center or nil;local eJ=y(ck*eC*(1-eE*eE))local eK=eI and 2*math.pi*y(ck^3/eC)local eL=math.acos(eD:dot(ez)/(eE*eB))if ez:dot(cH)<0 then eL=-(eL-2*math.pi)end;local eM=math.acos((math.cos(eL)+eE)/(1+eE*math.cos(eL)))local eN=eM;if eN<0 then eN=eN+2*math.pi end;local eO=eN-eE*math.sin(eN)local eP=0;local eQ=0;local eR=0;if eK~=nil then eP=eO/(2*math.pi/eK)eQ=eK-eP;eR=eQ+eK/2;if eL-math.pi>0 then eQ=eP;eR=eQ+eK/2 end;if eR>eK then eR=eR-eK end end;return{periapsis={position=eH,speed=eJ/eF,circularOrbitSpeed=y(eC/eF),altitude=eF-self.body.radius},apoapsis=eI and{position=eI,speed=eJ/eG,circularOrbitSpeed=y(eC/eG),altitude=eG-self.body.radius},currentVelocity=cH,currentPosition=ey,eccentricity=eE,period=eK,eccentricAnomaly=eM,meanAnomaly=eO,timeToPeriapsis=eQ,timeToApoapsis=eR}end;local function eS(eT)local dU=cI.BodyParameters(eT.systemId,eT.id,eT.radius,eT.center,eT.GM)return setmetatable({body=dU},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eS(...)end})end;local function eU()local eV={}local eW={}local eX={XS=13,S=27,M=55,L=110,XL=221}local eY={}local eZ;local e_;local f0;local f1;local f2;local function f3()local function f4(f5,f6,f7,f8,f9,fa,fb,fc)f6,f8,fa,fc=vec3(f6),vec3(f8),vec3(fa),vec3(fc)local fd,fe,ff=f5*f5,f7*f7,f9*f9;local eA=f8-f6;local fg=eA:normalize()local fh=eA:len()local fi=fa-f6;local fj=(fi-fi:project_on(fg)):normalize()local fk,fl=fi:dot(fg),fi:dot(fj)local fm=fk*fk+fl*fl;local fn=fg:cross(fj)local ca=(fd-fe+fh*fh)/(2*fh)local cb=(fd-ff+fm-2*fk*ca)/(2*fl)local cS=fd-ca^2-cb^2;local fo=y(cS)local fp=f6+fg*ca+fj*cb+fn*fo;local fq=f6+fg*ca+fj*cb-fn*fo;if d((fc-fp):len()-fb)<d((fc-fq):len()-fb)then return fp else return fq end end;local function fr()local function fs()local ft=core.getConstructWorldOrientationRight()local eA=core.getConstructWorldOrientationForward()local fi=core.getConstructWorldOrientationUp()local fu=library.systemResolution3(ft,eA,fi,{1,0,0})local fv=library.systemResolution3(ft,eA,fi,{0,1,0})local fw=library.systemResolution3(ft,eA,fi,{0,0,1})return function(fx)return library.systemResolution3(fu,fv,fw,fx)end end;local fy=fs()local fz=core.getConstructWorldPos()local ey=core.getElementPositionById(1)local fA={ey[1],ey[2],ey[3]}local fB=fy(fA)local fC={fz[1]-fB[1],fz[2]-fB[2],fz[3]-fB[3]}return fC end;local function fD(fE,eB,fF)local fG=fE.pts;local fH=#fG;local fI=fE.ref;if fH>3 then local fJ,fK,fL,fM=fG[fH],fG[fH-1],fG[fH-2],fG[fH-3]fE.ref=fF;local ey=f4(fJ[1],fJ[2],fK[1],fK[2],fL[1],fL[2],fM[1],fM[2])local ca,cb,fo=ey.x,ey.y,ey.z;if ca==ca and cb==cb and fo==fo then ca=ca+fI[1]cb=cb+fI[2]fo=fo+fI[3]local fN=vec3(ca,cb,fo)if not fE.lastPos then fE.center=fN elseif(fE.lastPos-fN):len()<2 then fE.center=fN;fE.skipCalc=true end;fE.lastPos=fN end;fE.pts={}else local fO={fF[1]-fI[1],fF[2]-fI[2],fF[3]-fI[3]}fG[fH+1]={eB,fO}end end;if radar_1 then eZ=#radar_1.getConstructIds()local fP=radar_1.getData()local fQ=fP:gmatch('{"constructId[^}]*}[^}]*}')if eZ>0 then local fF=fr()local fR,fS=0,0;f2,f1=0,0;for cH in fQ do local d8,aj,fT=cH:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fU=eX[fT]aj=z(aj)if radar_1.hasMatchingTransponder(d8)==1 then table.insert(eW,d8)end;local fV=radar_1.getConstructType(d8)if CollisionSystem then if fU>27 or fV=="static"or fV=="space"then f2=f2+1;local fW=radar_1.getConstructName(d8)local fE=bL[d8]if fE==nil then fU=fU+G;bL[d8]={pts={},ref=fF,name=fW,i=0,radius=fU,skipCalc=false}fE=bL[d8]end;if not fE.skipCalc then fD(fE,aj,fF)fS=fS+1 end;if fE.center then table.insert(eY,fE)end end;fR=fR+1;if bM and fR>700 or fS>70 or(not bM and fR>300 or fS>30)then coroutine.yield()fR,fS=0,0 end end end;f1=#eY;if f1>0 and bs>20 then local bV,fX,fY,fZ;local f_=0;local g0=aR:getPlanetarySystem(0)fZ=br:normalize()while f_<f1 do coroutine.yield()local g1={table.unpack(eY,f_,math.min(f_+75,f1))}bV,fX,fY=g0:castIntersections(bv,fZ,nil,nil,g1,true)if bV and fY then bO={bV,fX,fY}break end;f_=f_+75 end;if not bV then bO=nil end else bO=nil end;eY={}e_=fP:find('identifiedConstructs":%[%]')else f0=fP:find('worksInEnvironment":false')end end end;function eV.UpdateRadar()local g2=coroutine.status(UpdateRadarCoroutine)if g2=="suspended"then local cg,g3=coroutine.resume(UpdateRadarCoroutine)if g3 then system.print("ERROR UPDATE RADAR: "..g3)end elseif g2=="dead"then UpdateRadarCoroutine=coroutine.create(f3)local cg,g3=coroutine.resume(UpdateRadarCoroutine)end end;function eV.GetRadarHud()local g4=eW;eW={}return e_,f0,eZ,f1,f2,g4 end;UpdateRadarCoroutine=coroutine.create(f3)return eV end;local function g5()local g6=9.80665;local g7=vec3({13771471,7435803,-128971})local g8=18000000;local g9=500000;local ga,gb=math.huge;local gc;local function gd(ge)ga=vec3(ge):dist(g7)if ga<g8 then return true,d(ga-g8)end;gb=vec3(ge):dist(vec3(planet.center))if gb<g9 then gc=true else gc=false end;if d(gb-g9)<d(ga-g8)then return gc,d(gb-g9)else return gc,d(ga-g8)end end;local function gf(cH)if aG==1920 then return cH else return A(aG*cH/1920,0)end end;local function gg(cH)if aH==1080 then return cH else return A(aH*cH/1080,0)end end;local function gh()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gi()local gj="TRAVEL"if not bA then gj="CRUISE"end;if Autopilot then gj="AUTOPILOT"end;return gj end;local gk=""local gl=""local gm=""local gn=1;local go=2;local gp=3;local gq=4;local gr=5;local gs=6;local gt=""local gu=0;local gv=e(1/apTickRate)*2*hudTickRate;local gw={}local gx={}local gy={}local gz={}local gA={}local gB={}local function gC(ca,gD,gE,gF,gG,gH)local gI=fuelY;local gJ=fuelY+5;if not BarFuelDisplay then gJ=gJ+5 end;if m()==1 and not RemoteHud then gI=gI-50;gJ=gJ-50 end;if gE=="ATMO"then gt="atmofueltank"elseif gE=="SPACE"then gt="spacefueltank"else gt="rocketfueltank"end;gu=_G[gt.."_size"]if#gF>0 then for i=1,#gF do local fW=string.sub(gF[i][go],1,12)local gK=0;for gL=1,gu do if gF[i][go]==g(unit[gt.."_"..gL].getData()).name then gK=gL;break end end;local gM=q()if gG[i]==nil or gH[i]==nil or gM-gF[i][gs]>gv then local gN;local gO=0;if gK~=0 then gH[i]=g(unit[gt.."_"..gK].getData()).percentage;gG[i]=g(unit[gt.."_"..gK].getData()).timeLeft;if gG[i]=="n/a"then gG[i]=0 end else gO=l(gF[i][gn])-gF[i][gq]gH[i]=e(0.5+gO*100/gF[i][gp])gN=gF[i][gr]if gN<=gO then gG[i]=0 else gG[i]=e(0.5+gO/((gN-gO)/(gM-gF[i][gs])))end;gF[i][gr]=gO;gF[i][gs]=gM end end;if fW==gD then fW=f("%s %d",gE,i)end;if gK==0 then fW=fW.." *"end;local gP;if gG[i]==0 then gP=""else gP=cx(gG[i])end;if gH[i]~=nil then local gQ=e(gH[i]*2.55)local gR=f("rgb(%d,%d,%d)",255-gQ,gQ,0)local cd=""if gP~=""and gG[i]<120 or gH[i]<5 then cd="red "end;if BarFuelDisplay then gl=gl..f([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],ca,gJ,gR,gH[i],ca,gJ,ca+2,gJ+10,gH[i],gP)gl=gl..c9(ca,gI,fW,cd.."txtstart pdim txtfuel")gI=gI-30;gJ=gJ-30 else gl=gl..c9(ca,gI,fW,cd.."pdim txtfuel")gl=gl..c9(ca,gJ,f("%d%% %s",gH[i],gP),"pdim txtfuel","fill:"..gR)gI=gI+30;gJ=gJ+30 end end end end end;local function gS(gT,dg)if dg<200000 and not aq or dg and aq then local gU=0;if d(bu)>1 then gU=45*math.log(d(bu),10)if bu<0 then gU=-gU end end;gT[#gT+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(gU))end;return gT end;local function gV(gW)local gX=-bt;gW=gW-gW:project_on(gX)local gY=vec3(0,0,1)gY=gY-gY:project_on(gX)local gZ=gY:cross(gX)local gU=gY:angle_between(gW)*constants.rad2deg;if gW:dot(gZ)<0 then gU=360-gU end;return gU end;local function g_(gT,centerX,centerY,h0,h1,bM)local h2=circleRad;local h3=20;local h4=e(h0)if bM then for i=-45,45,5 do local h5=i;gT[#gT+1]=f([[<g transform="rotate(%f,%d,%d)">]],h5,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gT[#gT+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h2+h3-len,centerX,centerY+h2+h3)end;gT[#gT+1]=c9(centerX,centerY+h2+h3-35,h1,"pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY+h2+h3-25,h4 .." deg","pdim txt txtmid")gT[#gT+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h0,centerX,centerY)gT[#gT+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h2+h3-20,centerX+5,centerY+h2+h3-20,centerX,centerY+h2+h3-15)gT[#gT+1]="</g>"end;local h6=h4;if bM then h6=gV(bo)end;local h7=20;local h8=e(h6)local h9=0;local ha=centerY+h2+h3+20;local hb=centerX;if h1~="YAW"then ha=gg(130)hb=gf(960)end;local hc=[[<path class="txttick line" d="]]local hd=e(h8-(h7+10)-h8%5+0.5)for i=hd+60,hd,-5 do local ca=hb-(-i*5+h6*5)if i%10==0 then h9=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gT[#gT+1]=c9(ca+5,ha-12,B)elseif i%5==0 then h9=5 end;if h9==10 then hc=f([[%s M %f %f v %d]],hc,ca,ha-5,h9)else hc=f([[%s M %f %f v %d]],hc,ca,ha-2.5,h9)end end;gT[#gT+1]=hc..[["/>]]gT[#gT+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hb-5,ha+10,hb+5,ha+10,hb,ha+5)if bM then h1="HDG"end;gT[#gT+1]=c9(hb,ha+25,h8 .."deg","pdim txt txtmid","")gT[#gT+1]=c9(hb,ha+35,h1,"pdim txt txtmid","")end;local function he(gT,hf,h0,centerX,centerY,bM,hg,eu)local h2=circleRad;local hh=e(h2*3/5)if h2>0 then local hi=e(hf)local len=0;local hc=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h0,centerX,centerY)if not aq then hc=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gT[#gT+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h2-1,centerX,centerY)gT[#gT+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hi-30-hi%5+0.5),e(hi+30+hi%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cb=centerY+-i*5+hf*5;if len==30 then hc=f([[%s M %d %f h %d]],hc,centerX-hh-len,cb,len)if aq then gT[#gT+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h0,centerX,centerY,centerX-hh+10,cb,i)gT[#gT+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h0,centerX,centerY,centerX+hh-10,cb,i)if i==0 or i==180 or i==-180 then gT[#gT+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h0,centerX,centerY,centerX-hh+20,cb,hh*2-40)end else gT[#gT+1]=c9(centerX-hh+10,cb,i,"pdim txt txtmid")gT[#gT+1]=c9(centerX+hh-10,cb,i,"pdim txt txtmid")end;hc=f([[%s M %d %f h %d]],hc,centerX+hh,cb,len)else hc=f([[%s M %d %f h %d]],hc,centerX-hh-len,cb,len)hc=f([[%s M %d %f h %d]],hc,centerX+hh,cb,len)end end;gT[#gT+1]=hc..[["/>]]local hj="PITCH"if not bM then hj="REL PITCH"end;if hf>90 and not aq then hf=90-(hf-90)elseif hf<-90 and not aq then hf=-90-(hf+90)end;if h2>200 then if aq then if eu>Q then gT[#gT+1]=c9(centerX,centerY-15,"Yaw","pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY+20,hg,"pdim txt txtmid")end;gT[#gT+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h0,centerX,centerY)else gT[#gT+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gT[#gT+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hh+25,centerY-5,centerX-hh+20,centerY,centerX-hh+25,centerY+5,centerX-hh+50,centerY+4,hi)gT[#gT+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hh-25,centerY-5,centerX+hh-20,centerY,centerX+hh-25,centerY+5,centerX+hh-30,centerY+4,hi)gT[#gT+1]="</g>"end;local hk=e(h2/3)gT[#gT+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hk,centerY,h2-hk)if not aq and bM then gT[#gT+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h0,centerX,centerY,centerX-hh+10,centerY,hh*2-20)end;gT[#gT+1]="</g>"if h2<200 then if aq and eu>Q then gT[#gT+1]=c9(centerX,centerY-h2,hj,"pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY-h2+10,hi,"pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY-15,"Yaw","pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY+20,hg,"pdim txt txtmid")else gT[#gT+1]=c9(centerX,centerY-h2,hj,"pdim txt txtmid")gT[#gT+1]=c9(centerX,centerY-h2+15,hi,"pdim txt txtmid")end end end end;local function hl(gT,dg,bM)local hm=altMeterX;local hn=altMeterY;local ho=78;local hp=19;local hq=ao;if ao~=-1 then gT[#gT+1]=c9(hm+ho,hn+hp+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dg<200000 and not aq or dg and aq)then table.insert(gT,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hm-1,hn-4,ho+2,hp+6,hm+1,hn-1,ho-4,hp))local fH=0;local hr=1;local hs=0;local ht=dg<0;local hu=dg<planet.surfaceMaxAltitude;local hv=9;if ht then hv=0 end;local dg=d(dg)while fH<6 do local hw=11;local hx=16;local hy=9;local hz=14;local cd="altsm"if fH>2 then hx=hx+3;hw=hw+2;hz=hz+2;hy=hy-6;cd="altbig"end;if ht then cd=cd.." red"elseif hu then cd=cd.." orange"end;local hA=dg/hr%10;local hB=e(hA)local hC=e((hB+1)%10)local hD=hs;if fH==0 then hD=hA-hB;if ht then hD=1-hD end end;if ht and(fH==0 or hs~=0)then local hE=hC;hC=hB;hB=hE end;local hF=hx*(hD-1)local hG=hF+hx;local ca=hm+hy+(6-fH)*hw;local cb=hn+hz;gT[#gT+1]=c9(ca,cb+hF,hC,cd)gT[#gT+1]=c9(ca,cb+hG,hB,cd)fH=fH+1;hr=hr*10;if hB==hv then hs=hD else hs=0 end end;table.insert(gT,[[</g></g>]])end end;local function hH(ex)local hI=-math.deg(n(ex.y,ex.z))+180;hI=hI-90;if hI<0 then hI=360+hI end;if hI>180 then hI=-180+hI-180 end;return-hI end;local function hJ(ex)local h6=math.deg(n(ex.y,ex.x))-90;if h6<-180 then h6=360+h6 end;return h6 end;local function hK(gT,ex,eu,centerX,centerY)if eu>5 and not aq or eu>Q then local h2=circleRad;local hL=20;local hM=20;local hN=hH(ex)local hO=hJ(ex)local hP=14;local hQ=hP/2;local hR=-hO/hM*h2;local hS=hN/hL*h2;local ca=centerX+hR;local cb=centerY+hS;local aj=y(hR^2+hS^2)local hT=[[<circle
                            cx="]]..ca..[["
                            cy="]]..cb..[["
                            r="]]..hQ/hP..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ca..[["
                            cy="]]..cb..[["
                            r="]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ca-hP..[[,]]..cb..[[ h ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ca+hQ..[[,]]..cb..[[ h ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ca..[[,]]..cb-hP..[[ v ]]..hQ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h2 then gT[#gT+1]=hT else local gU=n(hS,hR)local hU=4;local hV=centerX+h2*math.cos(gU)local hW=centerY+h2*math.sin(gU)gT[#gT+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gU*180/math.pi,hV,hW,hV-hU,hW-hU/2,hU*2,hU,hV+hU,hW-hU,hU,hU,-hU,hU)end;if not aq then local hX=vec3(ex)hN=hH(-hX)hO=hJ(-hX)hR=-hO/hM*h2;hS=hN/hL*h2;ca=centerX+hR;cb=centerY+hS;aj=y(hR^2+hS^2)if aj<h2 then local hY=[[<circle
                                    cx="]]..ca..[["
                                    cy="]]..cb..[["
                                    r="]]..hQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ca..[[,]]..cb-hP..[[ v ]]..hQ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ca..[[,]]..cb..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ca..[[,]]..cb..[[)" />
                                <path
                                    d="M ]]..ca-hQ..[[,]]..cb..[[ h ]]..hP..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ca..[[,]]..cb..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ca..[[,]]..cb..[[)"/>]]gT[#gT+1]=hY end end end end;local function hZ(gT,gj,h_,i0)h_=e(h_+0.5)local gI=throtPosY+10;local gJ=throtPosY+20;if m()==1 and not RemoteHud then gI=55;gJ=65 end;local i1="CRUISE"local unit="km/h"local cg=i0;if gj=="TRAVEL"or gj=="AUTOPILOT"then i1="THROT"unit="%"cg=h_;local i2="dim"if h_<0 then i2="red"end;gT[#gT+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i2,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(h_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gT[#gT+1]=c9(throtPosX+10,gI,i1,"pbright txtstart")gT[#gT+1]=c9(throtPosX+10,gJ,f("%.0f %s",cg,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then h_=e(N*100+0.5)local i2="red"if h_<0 then i2="red"end;gT[#gT+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i2,1-d(h_),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gT[#gT+1]=c9(throtPosX+10,gI+40,"LIMIT","pbright txtstart")gT[#gT+1]=c9(throtPosX+10,gJ+40,h_.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gT[#gT+1]=c9(throtPosX+10,gI-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then gT[#gT+1]=c9(throtPosX+10,gI-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i3(gT,i4)local i5=throtPosY-10;local i6=throtPosX+10;gT[#gT+1]=c9(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then i5=75 end;gT[#gT+1]=c9(i6,i5,e(i4).." km/h","pbright txtbig txtstart")end;local function i7(gT)gT[#gT+1]=c9(gf(1900),gg(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gT[#gT+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gT[#gT+1]=c9(gf(960),gg(550),"Warning: Invalid Control Scheme Detected","warnings")gT[#gT+1]=c9(gf(960),gg(600),"Keyboard Scheme must be selected","warnings")gT[#gT+1]=c9(gf(960),gg(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local i8=gf(960)local i9=gg(860)local ia=gg(880)local ib=gg(900)local ic=gg(960)local id=gg(200)local ie=gg(250)local ig=gg(960)if m()==1 and not RemoteHud then i9=gg(135)ia=gg(155)ib=gg(175)id=gg(115)ie=gg(95)end;if BrakeIsOn then gT[#gT+1]=c9(i8,i9,"Brake Engaged","warnings")elseif L>0 then gT[#gT+1]=c9(i8,i9,"Auto-Brake Engaged","warnings","opacity:"..L)end;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gT[#gT+1]=c9(i8,id+50,"** STALL WARNING **","warnings")bX("stall","SW",2)end end;if bK then gT[#gT+1]=c9(i8,id+90,"Flight Assist in Progress","warnings")end;if ax then gT[#gT+1]=c9(i8,ig,"Gyro Enabled","warnings")end;if GearExtended then if S then gT[#gT+1]=c9(i8,ia,"Gear Extended","warn")else gT[#gT+1]=c9(i8,ia,"Landed (G: Takeoff)","warnings")end;local ih=cm(a:getTargetGroundAltitude())gT[#gT+1]=c9(i8,ib,"Hover Height: "..ih,"warn")end;if a7 then gT[#gT+1]=c9(i8,ic+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then if d(as-antigrav.getBaseAltitude())<501 then gT[#gT+1]=c9(i8,id+15,f("AGG On - Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gT[#gT+1]=c9(i8,id+15,f("AGG On - Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gT[#gT+1]=c9(i8,id+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gT[#gT+1]=c9(i8,id+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gT[#gT+1]=c9(i8,id+20,"Follow Mode Engaged","warn")elseif Reentry or an then gT[#gT+1]=c9(i8,id+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ih=cm(HoldAltitude,2)if VertTakeOff then if by then ih=cm(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gT[#gT+1]=c9(i8,id,"VTO to "..ih,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gT[#gT+1]=c9(i8,id,"Takeoff to "..AutopilotTargetName,"warn")else gT[#gT+1]=c9(i8,id,"Takeoff to "..ih,"warn")end;if BrakeIsOn and not VertTakeOff then gT[#gT+1]=c9(i8,id+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gT[#gT+1]=c9(i8,id,"Altitude Hold: "..ih,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gT[#gT+1]=c9(i8,id+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gT[#gT+1]=c9(i8,id+20,"Aligning trajectory","warn")elseif ar<0.05 then gT[#gT+1]=c9(i8,id+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gT[#gT+1]=c9(i8,id,b9,"warn")end end;if BrakeLanding then if StrongBrakes then gT[#gT+1]=c9(i8,id,"Brake-Landing","warnings")else gT[#gT+1]=c9(i8,id,"Coast-Landing","warnings")end end;if ProgradeIsOn then gT[#gT+1]=c9(i8,id,"Prograde Alignment","crit")end;if RetrogradeIsOn then gT[#gT+1]=c9(i8,id,"Retrograde Alignment","crit")end;if bN then local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gT[#gT+1]=c9(i8,ie+20,bN,type)elseif ar==0 then local bS,bW=bQ(br:normalize())if bW~=nil then local ih=cm(bW)local travelTime=aS.computeTravelTime(bs,0,bW)local ii="Collision"if bS.noAtmosphericDensityAltitude>0 then ii="Atmosphere"end;gT[#gT+1]=c9(i8,ie+20,bS.name.." "..ii.." "..cx(travelTime).." In "..ih,"crit")end end;if VectorToTarget and not IntoOrbit then gT[#gT+1]=c9(i8,id+35,VectorStatus,"warn")end;gT[#gT+1]="</g>"return gT end;local function ij(eu)return e(A(eu*3.6,0)+0.5).." km/h"end;local function ik(gT)local il=OrbitMapX;local im=OrbitMapY;local io=OrbitMapSize;local ip=4;local iq=15;local ca=0;local cb=0;local ir,is,it,iu;local function iv(type)local iw,E,eu,ix;if type=="Periapsis"then iw=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;eu=orbit.periapsis.speed;ix=35 else iw=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;eu=orbit.apoapsis.speed;ix=-35 end;gT[#gT+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ca+ix,cb-5,il+io/2-ir+iu,cb-5)gT[#gT+1]=c9(ca,cb,type)cb=cb+iq;local ih=cm(iw)gT[#gT+1]=c9(ca,cb,ih)cb=cb+iq;gT[#gT+1]=c9(ca,cb,cx(E))cb=cb+iq;gT[#gT+1]=c9(ca,cb,ij(eu))end;if orbit~=nil and ar<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then im=im+ip;ca=il+io+il/2+ip;cb=im+io/2+5+ip;ir=io/4;iu=0;gT[#gT+1]=[[<g class="pbright txtorb txtmid">]]gT[#gT+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',io+il*2,io+im,ip,ip)if orbit.periapsis~=nil and orbit.apoapsis~=nil then it=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(ir*2)is=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/it*(1-orbit.eccentricity)iu=ir-orbit.periapsis.altitude/it-planet.radius/it;local iy=""if orbit.periapsis.altitude<=0 then iy='redout'end;gT[#gT+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iy,il+io/2+iu+ip,im+io/2+ip,ir,is)gT[#gT+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',il+io/2+ip,im+io/2+ip,planet.radius/it)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iv("Apoapsis")end;cb=im+io/2+5+ip;ca=il-il/2+10+ip;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iv("Periapsis")end;gT[#gT+1]=c9(il+io/2+ip,planet.name,20+ip,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iz=orbit.timeToApoapsis/orbit.period*2*math.pi;local iA=ir*math.cos(iz)local iB=is*math.sin(iz)gT[#gT+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',il+io/2+iA+iu+ip,im+io/2+iB+ip)end;gT[#gT+1]=[[</g>]]return gT else return gT end end;local function iC(iD,iE)local iF;local iG=(iE-iD):normalize()local ez=(bv-iD):dot(iG)/iG:dot(iG)if ez<=0.then return(bv-iD):len()elseif ez>=(iE-iD):len()then return(bv-iE):len()end;local iH=iD+ez*iG;iF=(iH-bv):len()return iF end;local function iI()local iF;local iJ=nil;local iK=nil;local iL=nil;for cG,iM in pairs(b[0])do if iM.hasAtmosphere then local aj=iC(planet.center,iM.center)if iJ==nil or aj<iJ then iK=iM;iJ=aj;iL=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dV=iC(ac.center,iM.center)if dV<iJ then iK=iM;iJ=dV;iL=ac end end end end;local iN=gf(1770)local iO=gg(330)if iJ then local iP="txttick "local iQ=500000;if iJ<iK.radius+iQ or iJ<iL.radius+iQ then if bH then iP="txttick red "else iP="txttick orange "end end;iF=cm(iJ,2)bJ=c9(iN,iO,"Pipe ("..iL.name.."--"..iK.name.."): "..iF,iP.."pbright txtmid")end end;local iR={}function iR.HUDPrologue(gT)bH,bI=gd(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local iS=ay;local iT=az;local iU=ay;local iV=az;if gh()and not brightHud then iS=[[rgb(]]..e(H*0.4+0.5)..","..e(J*0.4+0.5)..","..e(I*0.3+0.5)..[[)]]iT=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;gT[#gT+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],iS,iS,iU,iU,iT,iT,iV,iV,aG,aH)return gT end;function iR.DrawVerticalSpeed(gT,dg)gS(gT,dg)end;function iR.UpdateHud(gT)local hI=bB;local iW=bC;local h0=iW;local hf=hI;local h_=e(unit.getThrottle())local i4=bs*3.6;local i0=unit.getAxisCommandValue(0)local iX=gf(1770)local iY=gg(310)if AtmoSpeedAssist and bA then i0=K;h_=K*100 end;local gj=gi()local h1="ROLL"if h_==nil then h_=0 end;if not bM then if bs>5 then hI=hH(bq)iW=hJ(bq)else hI=0;iW=0 end;h1="YAW"end;if bI>50000 and not aq then local iZ;iZ=cm(bI)gT[#gT+1]=c9(iX,iY,"PvP Boundary: "..iZ,"pbright txtbig txtmid")end;gT[#gT+1]=ak;gT[#gT+1]=aD;gT[#gT+1]=gk;if bJ~=""then gT[#gT+1]=bJ end;if gl~=""then gT[#gT+1]=gl end;if gm~=""then gT[#gT+1]=gm end;gS(gT,as)if m()==0 or RemoteHud then if not gh()or brightHud then if bM then g_(gT,centerX,centerY,h0,h1,bM)he(gT,hf,h0,centerX,centerY,bM,e(hJ(bq)),bs)else g_(gT,centerX,centerY,iW,h1,bM)he(gT,hI,iW,centerX,centerY,bM,e(iW),bs)end;hl(gT,as,bM)hK(gT,bq,bs,centerX,centerY)end end;hZ(gT,gj,h_,i0)i3(gT,i4)i7(gT)ik(gT)return gT end;function iR.HUDEpilogue(gT)gT[#gT+1]="</svg>"return gT end;function iR.ExtraData(gT)local i_=gf(1240)local j0=gg(55)local j1=j0+10;local j2;local j3=0;local gj=gi()if VertTakeOffEngine then gj=gj.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bs>20 then gj=gj.."-COLLISION ON"end;if UseExtra~="Off"then gj="("..UseExtra..")-"..gj end;if TurnBurn then gj="TB-"..gj end;if not stablized then gj=gj.."-DeCoupled"end;local j4=vec3(core.getWorldAcceleration()):len()/9.80665;j2=core.g()gT[#gT+1]=[[<g class="pdim txt txtend">]]if m()==1 and not RemoteHud then i_=gf(1120)j0=gg(55)j1=j0+10 elseif aq then local j5=gf(770)gT[#gT+1]=c9(j5,j0,"ATMOSPHERE","pdim txt txtend")gT[#gT+1]=c9(j5,j1,f("%.2f",ar),"pdim txt txtend","")end;gT[#gT+1]=c9(i_,j0,"GRAVITY","pdim txt txtend")gT[#gT+1]=c9(i_,j1,f("%.2f",j2/9.80665),"pdim txt txtend")gT[#gT+1]=c9(i_,j0+20,"ACCEL","pdim txt txtend")gT[#gT+1]=c9(i_,j1+20,f("%.2f",j4),"pdim txt txtend")gT[#gT+1]=c9(gf(960),gg(180),gj,"txtbig txtmid")end;function iR.DrawOdometer(gT,ad,TotalDistanceTravelled,ae)local j2;local j6=0;local j7=0;local j3=0;local j8=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then j3=LastMaxBrakeInAtmo else j3=LastMaxBrake end;local j9,ja=aS.computeDistanceAndTime(bs,0,av,0,0,j3)j3=A(j3/(av*g6),2).." g"local jb=a:maxForceForward()j2=core.g()if j2>0.1 then j7=av*j2;j7=A(j7/(av*g6),2).." g"j6=0.5*jb/j2;j6=j6>1000000 and A(j6/1000000,2).." kTons"or A(j6/1000,2).." Tons"end;jb=A(jb/(av*g6),2).." g"gT[#gT+1]=f([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gf(660),gf(700),gg(35),gf(960),gg(55),gf(1240),gg(35),gf(1280))if m()==0 or RemoteHud then gT[#gT+1]=c9(gf(700),gg(10),f("BrkTime: %s",cx(ja)),"txtstart")gT[#gT+1]=c9(gf(700),gg(20),f("Trip: %.2f km",ad),"txtstart")gT[#gT+1]=c9(gf(700),gg(30),f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gT[#gT+1]=c9(gf(830),gg(10),f("BrkDist: %s",cm(j9)),"txtstart")gT[#gT+1]=c9(gf(830),gg(20),"Trip Time: "..cx(ae),"txtstart")gT[#gT+1]=c9(gf(830),gg(30),"Total Time: "..cx(TotalFlightTime),"txtstart")gT[#gT+1]=c9(gf(970),gg(20),f("Mass: %s",j8),"txtstart")gT[#gT+1]=c9(gf(1240),gg(10),f("Max Brake: %s",j3),"txtend")gT[#gT+1]=c9(gf(1240),gg(30),f("Max Thrust: %s",jb),"txtend")if j2>0.1 then gT[#gT+1]=c9(gf(970),gg(30),f("Max Thrust Mass: %s",j6),"txtstart")gT[#gT+1]=c9(gf(1240),gg(20),f("Req Thrust: %s",j7),"txtend")else gT[#gT+1]=c9(gf(970),gg(30),"Max Mass: n/a","txtstart")gT[#gT+1]=c9(gf(1240),gg(20),"Req Thrust: n/a","txtend")end end;gT[#gT+1]="</g>"return gT end;function iR.DrawWarnings(gT)return i7(gT)end;function iR.DisplayOrbitScreen(gT)return ik(gT)end;function iR.DisplayMessage(gT,ih)if ih~="empty"then local cb=310;for jc in string.gmatch(ih,"([^\n]+)")do cb=cb+35;gT[#gT+1]=c9("50%",cb,jc,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function iR.DrawDeadZone(gT)gT[#gT+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iR.UpdatePipe()if aq then bJ=""return end;iI()end;function iR.DrawSettings(gT)if#bE>0 then local ca=gf(640)local cb=gg(200)gT[#gT+1]=[[<g class="pbright txtvspd txtstart">]]for cG,cH in pairs(bE)do gT[#gT+1]=c9(ca,cb,cH..": ".._G[cH])cb=cb+20;if cG%12==0 then ca=ca+gf(350)cb=gg(200)end end;gT[#gT+1]=c9(gf(640),gg(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gT[#gT+1]="</g>"end;return gT end;local jd;local je=gf(1770)local jf=gg(350)local jg=gg(15)local jh=gf(1370)local bP,ji;local jj=0;function iR.DrawRadarInfo()local function jk()if radarPanelID~=nil and jj==0 then t(radarPanelID)radarPanelID=nil;if jd~=nil then t(jd)jd=nil end else if jj==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jd=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jj=0 end end;local e_,f0,eZ,f1,f2,eW=aY.GetRadarHud()local B=f1 or 0;if eZ>0 then if CollisionSystem then bP=B.."/"..f2 .." Plotted : "..eZ-f2 .." Ignored"else bP="Radar Contacts: "..eZ end;gk=c9(je,jf,bP,"pbright txtbig txtmid")if#eW>0 then gk=gk..c9(jh,jg,"Friendlies In Range","pbright txtbig txtmid")for cG,cH in pairs(eW)do jg=jg+20;gk=gk..c9(jh,jg,radar_1.getConstructName(cH),"pdim txtmid")end end;if e_==nil and jd==nil then jj=1;jk()end;if e_~=nil and jd~=nil then jk()end;if radarPanelID==nil then jk()end else if f0 then gk=c9(je,jf,"Radar: Jammed","pbright txtbig txtmid")else gk=c9(je,jf,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jj=0;jk()end end end;function iR.DrawTanks()if fuelX~=0 and fuelY~=0 then gl=c9(fuelX,fuelY,"","txtstart pdim txtfuel")gC(fuelX,"Atmospheric ","ATMO",aI,gA,gB)gC(fuelX+120,"Space fuel t","SPACE",aJ,gy,gz)gC(fuelX+240,"Rocket fuel ","ROCKET",aK,gw,gx)end end;function iR.DrawShield()local jl=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local jm=core.getPvPTimer()local jn=shield_1.getResistances()local jo="A: "..10+jn[1]*100 .."% / E: "..10+jn[2]*100 .."% / K:"..10+jn[3]*100 .."% / T: "..10+jn[4]*100 .."%"local ca,cb=shieldX-60,shieldY+30;local jp=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gQ=e(jp*2.55)local gR=f("rgb(%d,%d,%d)",255-gQ,gQ,0)local cd=""gm=c9(ca,cb,"","txtmid pdim txtfuel")if jp<10 and jl~="Shield Disabled"then cd="red "end;jm=jm>0 and"   PvPTime: "..cx(jm)or""gm=gm..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ca,cb,gR,jp*2,ca,cb,ca+2,cb+10,jp,jm)gm=gm..c9(ca,cb-5,jl,cd.."txtstart pbright txtbig")gm=gm..c9(ca,cb+30,jo,cd.."txtstart pbright txtsmall")end;return iR end;local function jq()local function jr(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function js()local function jt(ju,jv)return ju.name<jv.name end;bG={}for cG,cH in pairs(b[0])do bG[#bG+1]={name=cH.name,index=cG}end;table.sort(bG,jt)end;local function jw(jx)for cG,cH in pairs(jx)do if cH.name and cH.name==CustomTarget.name then return cG end end;return-1 end;local function jy()if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local jz=bG[AutopilotTargetIndex].index;local jA=b[0][jz]if jA.center then AutopilotTargetName=jA.name;ac=aR[0][jz]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jA;for _,cH in pairs(aR[0])do if cH.name==CustomTarget.planetname then ac=cH;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jB(gX)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gX==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then jy()else local jz=bG[AutopilotTargetIndex].index;local jA=b[0][jz]if jA~=nil and jA.name=="Space"or iphCondition=="Custom Only"and jA.center or iphCondition=="No Moons"and string.find(jA.name,"Moon")~=nil then if gX==nil then jB()else jB(1)end else jy()end end else a2="Disengage autopilot before changing Interplanetary Helper"bX("iph","AP")end end;local function jC()local fH=-1;fH=jw(b[0])if fH>-1 then table.remove(b[0],fH)end;fH=-1;fH=jw(SavedLocations)if fH~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fH)end;jB()js()end;local function jD(fW,position,hE,jE)if dbHud_1 or hE then local p=jr(position)local j2=p.gravity;if jE then j2=unit.getClosestPlanetInfluence()end;local jF={position=position,name=fW,planetname=p.name,gravity=j2,safe=jE}if not hE then SavedLocations[#SavedLocations+1]=jF else for cG,cH in pairs(b[0])do if cH.name and fW==cH.name then table.remove(b[0],cG)end end end;table.insert(b[0],jF)js()jy()a2="Location saved as "..fW.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local jG={}function jG.UpdateAtlasLocationsList()js()end;function jG.UpdateAutopilotTarget()jy()end;function jG.adjustAutopilotTargetIndex(gX)jB(gX)end;function jG.findAtlasIndex(jx)jw(jx)end;function jG.UpdatePosition(jH)local fH=jw(SavedLocations)if fH~=-1 then if jH~=nil then SavedLocations[fH].name=jH;AutopilotTargetIndex=AutopilotTargetIndex-1;jB()else local jI=SavedLocations[fH]jI.gravity=unit.getClosestPlanetInfluence()jI.position=bv;jI.safe=true end;a2=SavedLocations[fH].name.." position updated ("..SavedLocations[fH].planetname..")"else a2="Name Not Found"end end;function jG.AddNewLocation(fW,position,hE,jE)jD(fW,position,hE,jE)end;function jG.ClearCurrentPosition()jC()end;for cG,cH in pairs(SavedLocations)do table.insert(b[0],cH)end;js()jG.UpdateAutopilotTarget()return jG end;local function jJ()local jK={}local function jL(eu)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;if not aq then return aS.computeDistanceAndTime(eu,jM,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eu,jM,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function jN(eu)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;return aS.computeDistanceAndTime(eu,jM,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local jO=false;function jK.GetAutopilotBrakeDistanceAndTime(eu)return jL(eu)end;function jK.GetAutopilotTBBrakeDistanceAndTime(eu)return jN(eu)end;local function jP(jQ,jR,jS)jR=jR:project_on_plane(jQ)jS=jS:project_on_plane(jQ)return n(jR:cross(jS):dot(jQ),jR:dot(jS))end;local function jT()local function jU()local jV=-1;local jW=-1;if vBooster then jV=vBooster.getDistance()end;if hover then jW=hover.getDistance()end;if jV~=-1 and jW~=-1 then if jV<jW then return jV else return jW end elseif jV~=-1 then return jV elseif jW~=-1 then return jW else return-1 end end;local jX=jU()local jY=-1;if telemeter_1 then jY=telemeter_1.getDistance()end;if jX~=-1 and jY~=-1 then if jX<jY then return jX else return jY end elseif jX~=-1 then return jX else return jY end end;local function jZ(planet,dR,j_)local function k0(k1,da)local dX=vec3(da)if k1.id==0 then return setmetatable({latitude=dX.x,longitude=dX.y,altitude=dX.z,id=0,systemId=k1.systemId},MapPosition)end;local dY=dX-k1.center;local aj=dY:len()local dg=aj-k1.radius;local de=0;local df=0;if not cj(aj,0)then local dZ=n(dY.y,dY.x)df=dZ>=0 and dZ or 2*math.pi+dZ;de=math.pi/2-math.acos(dY.z/aj)end;return setmetatable({latitude=math.deg(de),longitude=math.deg(df),altitude=dg,id=k1.id,systemId=k1.systemId},MapPosition)end;local k2=k0(planet,dR)k2="::pos{"..k2.systemId..","..k2.id..","..k2.latitude..","..k2.longitude..","..k2.altitude.."}"if j_ then return k2 else system.setWaypoint(k2)return true end end;local k3=false;function jK.showWayPoint(planet,dR,j_)return jZ(planet,dR,j_)end;function jK.APTick()local function k4()if bO and not BrakeLanding then local bV=bO[1]local fX,fY=bO[2],bO[3]local k5=math.min(fX,fY or fX)local k6=k5/bs;local k7=AutoTakeoff and(bs<42 or ao~=-1)local k8=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if k8 and not k7 and(a8*1.5>k5 or k6<1)then BrakeIsOn=true;cf(0)if AltitudeHold then cr()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cs()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if k6<11 then bN=bV.name.." COLLISION "..cx(k6).." / "..cm(k5,2)else bN=bV.name.." collision "..cx(k6)end;if k6<6 then bX("alarm","AL",2)end else bN=false end end;local function k9(bR,ka,kb)local function kc(bR,dD)bR=vec3(bR)dD=vec3(dD):normalize()local cX=bR*dD;return cX.x+cX.y+cX.z end;local kd=0.001;local ke=1;if not aq or not b2 or ao~=-1 or bs<Q then if kb==nil then kb=DampingMultiplier end;if ka==nil then ka=kd end;bR=vec3(bR):normalize()local kf=vec3()-bR;local kg=-kc(kf,core.getConstructWorldOrientationRight())*ke;local kh=-kc(kf,core.getConstructWorldOrientationUp())*ke;if aB==0 then aB=kg/2 end;if aC==0 then aC=kh/2 end;if d(kg)<0.1 then V=V-kg*2 else V=V-(kg+(kg-aB)*kb)end;if d(kh)<0.1 then U=U+kh*2 else U=U+kh+(kh-aC)*kb end;aB=kg;aC=kh;if d(kg)<ka and d(kh)<ka then return true end;return false elseif b2 and ao==-1 then bR=br;if kb==nil then kb=DampingMultiplier end;if ka==nil then ka=kd end;bR=vec3(bR):normalize()local kf=bo-bR;local kg=-kc(kf,core.getConstructWorldOrientationRight())*ke;local kh=-kc(kf,core.getConstructWorldOrientationUp())*ke;if aB==0 then aB=kg/2 end;if aC==0 then aC=kh/2 end;if d(kg)<0.1 then V=V-kg*5 else V=V-(kg+(kg-aB)*kb)end;if d(kh)<0.1 then U=U+kh*5 else U=U+kh+(kh-aC)*kb end;aB=kg;aC=kh;if d(kg)<ka and d(kh)<ka then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=jT()E=q()b3=E;if CollisionSystem then k4()end;if antigrav then by=antigrav.getState()==1 end;local ki=1;local kj=1;local kk=E-b3;local kl=-math.deg(jP(bn,br,bo))local km=math.deg(jP(bp,br,bo))local gX=bt*-1;b2=aq and kl<-YawStallAngle or kl>YawStallAngle or km<-PitchStallAngle or km>PitchStallAngle;local kn=system.getMouseDeltaX()local ko=system.getMouseDeltaY()if InvertMouse and not a1 then ko=-ko end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local j2=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+kn;ah=ah+ko end else ag=0;ah=0 end else ag=ag+kn;ah=ah+ko;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(ko,-100,100)+0.5)*2*ki;V=(-utils.smoothstep(kn,-100,100)+0.5)*2*kj end end end end;local kp=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not kp then a2="Space Speed Engine Shutoff reached"cf(0)end;if not kp and LastIsWarping then if not BrakeIsOn then cu()end;if Autopilot then cs()end end;LastIsWarping=kp;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not jO then BrakeIsOn=true;jO=true elseif not AtmoSpeedAssist and jO then if bs<b7/3.6 then BrakeIsOn=false;jO=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local kq=false;if CustomTarget~=nil and al~=1 then kq=k9(CustomTarget.position-bv,0.1)else kq=k9(vec3(br),0.01)end;b0=true;if kq then ci(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cv()end elseif aq and AtmoSpeedAssist then cf(1)end elseif bs>Q then k9(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then k9(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cv()al=false;an=true else al=false;cs()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cs()an=false end;if VertTakeOff then b0=true;local kr=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then kr=antigrav.getBaseAltitude()end;if as<kr-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=kr then if by then if Autopilot or VectorToTarget then cp()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"bX("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"bX("vtoc","VT")cp()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;ci(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=kr;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ks=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ks)local kt=r(vTpitchPID:get(),-1,1)U=kt end end;if IntoOrbit then local kf;local ku=false;local kv=cm(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then kf=CustomTarget.position-bv end;local kw,kx=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local ky=bC;if not bc then local kz=false;local kA=false;cf(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..kv;if be.VectorToTarget then k9(kf:normalize():project_on_plane(bt))ku=bo:dot(kf:project_on_plane(bn):normalize())>0.95 else k9(br)ku=kl<0.5;if bs<150 then ku=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then kz=true else kz=false end;if ky<=bb+1 and ky>=bb-1 then kA=true else kA=false end;if kz and kA and ku then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then k9(kf:normalize():project_on_plane(bt))elseif bs>150 then k9(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and kf:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or kf:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"bX("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cq()cv()end end;if orbit.apoapsis and orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cf(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"bX("orCom","OB")cq()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..kv;bd=true;local kB=bg-as;if VSpdPID==nil then VSpdPID=pid.new(1,0,10*0.1)end;if kB<0 and kB>-1000 then kB=0 end;local jb=a:maxForceForward()local kC=jb/(av*planet.gravity*9.8)local kD=math.max(d(kB)/1000*10*kC,20*kC)*utils.sign(kB)if kB==0 then kD=0 end;ci(math.max(kx*3.6+1,d(kD)))VSpdPID:inject(kD-bu)local kE=bC/180*math.pi;local kF=math.cos(kE)local kG=math.sin(kE)local kH=getPitch(bt,br:normalize(),bp*kF+bn*kG)ba=r(r(VSpdPID:get(),kH-60,kH+60),-60,60)end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kI=ba-bB;OrbitPitchPID:inject(kI)local kJ=r(OrbitPitchPID:get(),-0.5,0.5)U=kJ end end;if Autopilot and ar==0 and not al then local function kK(bP,orbit)system.print(bP)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cf(0)P=false;a2=bP;bX("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cq()end end;local kL,kM=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kN=(CustomTarget.position-ac.center):normalize()local kO=kN:project_on_plane((ac.center-bv):normalize()):normalize()local kP=ac.center+kO*(ac.radius+AutopilotTargetOrbit)local kQ=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-kP):len()<(bv-kQ):len()then kL=kP else kL=kQ;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kL;aX.showWayPoint(ac,AutopilotTargetCoords)kM=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kM=true;TargetSet=true;AutopilotRealigned=true;kL=CustomTarget.position+(bv-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kN=(bv+br*100000-ac.center):normalize()local kO=kN:project_on_plane((ac.center-bv):normalize()):normalize()if kO:len()<1 then kN=(bv+bo*100000-ac.center):normalize()kO=kN:project_on_plane((ac.center-bv):normalize()):normalize()end;kL=ac.center+kO*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kL;TargetSet=true;kM=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kL)-bv):len()local bS,bT,bU=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(bV)if bV.noAtmosphericDensityAltitude>0 then return bV.radius+bV.noAtmosphericDensityAltitude else return bV.radius+bV.surfaceMaxAltitude*1.5 end end)local bW=bT;if bU~=nil and bT~=nil then bW=math.min(bU,bT)end;if bW~=nil and bW<AutopilotDistance and bS.name==ac.name then AutopilotDistance=bW end;local kq=true;local kR=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local ih=cm(kR)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ih..'"}')local a8,a9;if not TurnBurn then a8,a9=jL(bs)else a8,a9=jN(bs)end;if bs>300 and AutopilotAccelerating then local kf=vec3(kL)-bv;local kS=r(math.deg(jP(bn,br:normalize(),kf:normalize()))*bs/500,-90,90)local kT=r(math.deg(jP(bp,br:normalize(),kf:normalize()))*bs/500,-90,90)if d(kS)<20 and d(kT)<20 then kS=kS*2;kT=kT*2 end;if d(kS)<2 and d(kT)<2 then kS=kS*2;kT=kT*2 end;local kl=-math.deg(jP(bn,bo,br:normalize()))local km=-math.deg(jP(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kT-km)local kU=r(apPitchPID:get(),-1,1)U=U+kU;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kS-kl)local kV=r(apYawPID:get(),-1,1)V=V+kV;kM=true;if d(kS)>2 or d(kT)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bX("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end end end;if kR<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(kR)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local bS,bW=bQ((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if bS~=nil and ac.name~=bS.name then a2="Collision with "..bS.name.." in "..cm(bW).."\nClear LOS to continue."ai=5;k3=true else k3=false;a2=""end end end;if not k3 then if not AutopilotCruising and not AutopilotBraking and not kM then kq=k9((kL-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kq=k9(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cf(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local kW=unit.getThrottle()if AtmoSpeedAssist then kW=K end;if bq:len()>=MaxGameVelocity or kW==0 and P then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bX("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cf(0)end;local kX=AutopilotDistance;if ac.name=="Space"then kX=kX-AutopilotSpaceDistance end;if kX<=a8 or PreventPvP and bI<=a8+10000 then if PreventPvP and bI<=a8+10000 then cs()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bX("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cf(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cf(1,true)end;local _,kx=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local kf;if CustomTarget~=nil then kf=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then kK("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=kx and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kK("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bX("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=kx then if CustomTarget~=nil then if br:normalize():dot(kf:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then bX("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else kK("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else kK("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then kK("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local kX=AutopilotDistance;if ac.name=="Space"then kX=kX-AutopilotSpaceDistance end;if kX<=a8 or PreventPvP and bI<=a8+10000 then if PreventPvP and bI<=a8+10000 then cs()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bX("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kW=unit.getThrottle()if AtmoSpeedAssist then kW=K end;if kW>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end;AutopilotCruising=false end else if kq then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif kq and not k3 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bX("apAcc","AP")end;if not P then cf(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"bX("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cf(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local kT=0;local ey=bv+vec3(unit.getMasterPlayerRelativePosition())local kY=ey-bv;local kZ=vec3(kY):project_on(bo):len()local k_=vec3(kY):project_on(bp):len()local aj=y(kZ*kZ+k_*k_)k9(kY:normalize())local l0=40;local l1=aj<l0;local l2=100;local l3=r((aj-l0)/2,10,l2)U=0;local kq=d(V)<0.1;if kq and bs<l3 and not l1 then BrakeIsOn=false;kT=-20 else BrakeIsOn=true;kT=0 end;local l4=0;if d(kT-bB)>l4 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kT-bB)local kU=pitchPID:get()U=kU end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l5=LastMaxBrakeInAtmo;if l5 then l5=l5*r(bs/100,0.1,1)*ar else l5=LastMaxBrake end;if ar<0.01 then l5=LastMaxBrake end;local l6=bo:project_on_plane(bt):normalize():dot(br)local l7=vec3(core.getWorldAirFrictionAcceleration())local l8=l7:len()*av;if l6>100 then a8,a9=aS.computeDistanceAndTime(l6,100,av,0,0,l5)local l9,la=aS.computeDistanceAndTime(100,0,av,0,0,l5*0.55)a8=a8+l9 else a8,a9=aS.computeDistanceAndTime(l6,0,av,0,0,l5*0.55)end;local kB=HoldAltitude-as-bu;local lb=200+bs;if Reentry or al then minMax=2000+bs end;local lc=1;if AutoTakeoff then lc=r(bs/100,0.1,1)end;local kT=(utils.smoothstep(kB,-lb,lb)-0.5)*2*MaxPitch*lc;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then kT=(utils.smoothstep(kB,-lb*r(20-19*ar*10,1,20),lb*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*lc end;if not AltitudeHold then kT=0 end;if LockPitch~=nil then if bM and not IntoOrbit then kT=LockPitch else LockPitch=nil end end;b0=true;local ld=U;if Reentry then local le=e(b7)local lf,lg=aS.computeDistanceAndTime(bs,le/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)lf=lf==-1 and 5000 or lf;local lh=as-(planet.noAtmosphericDensityAltitude+lf)local li=as>planet.noAtmosphericDensityAltitude+lf*1.35;if li then kT=ReEntryPitch;if bs<=le/3.6 and bs>le/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cf(1)end elseif bA and not li and not aq then ci(le,true)end;if bA then if bs>le/3.6 and not li then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then kT=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kT=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and li then b0=true elseif not li then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=le)then ci(le)end;if bs<le/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then k9(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local kf;if bK then if type(bK)=="table"then kf=bK elseif bK<3 and bK>0 then kf=-bt:cross(br)*5000 elseif bK>=3 then kf=bt:cross(br)*5000 elseif bK<0 then kf=br*25000 end elseif CustomTarget~=nil then kf=CustomTarget.position-bv else kf=ac.center-bv end;local kS=math.deg(jP(bt:normalize(),br,kf))*2;local lj=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local lk=1000+bs;local ll=(utils.smoothstep(kB-bu*10,-lk,lk)-0.5)*2*MaxPitch;local lm=r(90-ll,0,180)b4=r(kS*2,-lm,lm)local ln=kS;kS=r(r(kS,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lj)+4*(bB-kT)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local lo=1;if b4~=0 then lo=d(lj/b4)end;lo=(90-r(d(b4-bC),0,90))/90;local lp=kT;if d(bC)>90 then lp=-lp end;kT=lo*r(r(lp*math.cos(lj),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(ln)*math.sin(lj),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;kS=r(kS,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lq=kl-kS;if bK and d(lq)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cr()end;bK=nil;bX("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lq)local kV=r(yawPID:get(),-1,1)V=V+kV elseif aq and ao>-1 or bs<minRollVelocity then k9(kf)elseif b2 and ar>0.01 then if(kl<-YawStallAngle or kl>YawStallAngle)and ar>0.01 then k9(br)end;if(km<-PitchStallAngle or km>PitchStallAngle)and ar>0.01 then kT=r(bB-km,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local kr=planet:getAltitude(CustomTarget.position)local lh=kf:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and lh<=a8 and(br:project_on_plane(bt):normalize():dot(kf:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cf(0)if AltitudeHold then cr()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(l6<0.1 or lh<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<lh)then if not by then bX("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=lh end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local kf=CustomTarget.position-bv;local kr=planet:getAltitude(CustomTarget.position)local lh=y(kf:len()^2-(as-kr)^2)local l5=LastMaxBrakeInAtmo;if l5 then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,l5/2)StrongBrakes=true;if lh<=a8+bs*kk/2 and br:project_on_plane(bt):normalize():dot(kf:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cv()end end;LastDistanceToTarget=lh end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cq()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then k9(br)kT=r(bB-km,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=ld;local jY=-1;if BrakeLanding then kT=0;local lr=false;local ls=30;if aT~=nil and aT>0 then local lt=r(ar,0.4,2)local l5=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*lt;local lu=aT*lt+l5-j2;local lv=l5/2-j2;local lw=bs-y(d(lv/2)*20/(0.5*av))*utils.sign(lv)if lw<0 then lw=0 end;local lx;if bs>100 then local ly,_=aS.computeDistanceAndTime(bs,100,av,0,0,l5)local lz,_=aS.computeDistanceAndTime(100,0,av,0,0,y(l5))lx=ly+lz else lx=aS.computeDistanceAndTime(bs,0,av,0,0,y(l5))end;if lx<20 then BrakeIsOn=false else local lA=0;if lw>100 then local lB,_=aS.computeDistanceAndTime(lw,100,av,0,0,lu)local lC,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*lt+y(l5)-j2)lA=lB+lC else lA,_=aS.computeDistanceAndTime(lw,0,av,0,0,aT*lt+y(l5)-j2)end;lA=(lA+15+bs*kk)*1.1;local lD=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if lD then local kr=planet:getAltitude(CustomTarget.position)local lE=as-kr-100;local kf=CustomTarget.position-bv;local lF=y(kf:len()^2-(as-kr)^2)if lF>100 then lD=false elseif lE<=lA or lA==-1 then BrakeIsOn=true;lr=true else BrakeIsOn=false;lr=true end end;if not lD and CalculateBrakeLandingSpeed then if lA>=ls then BrakeIsOn=true else BrakeIsOn=false end;lr=true end end end;if not bA then cf(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;jY=ao;if jY>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()bX("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-gX)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not lr then BrakeIsOn=true elseif not lr then BrakeIsOn=false end end;if AutoTakeoff or am then local bS,bU,bT;if AutopilotTargetCoords~=nil then bS,bU,bT=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(bV)return bV.radius+bV.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cf(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(kT)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cf(0)elseif am then cf(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(bS==nil or bS.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cf(0)end;AutopilotAccelerating=true end end;local lG=ao>-1;local lH=bB;if(VectorToTarget or am or bK)and not lG and bs>minRollVelocity and ar>0.01 then local lj=math.rad(d(bC))lH=bB*d(math.cos(lj))+km*math.sin(lj)end;local lI=r(kT-lH,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then lI=r(kT-lH,-85,MaxPitch)elseif ar<0.01 then lI=r(kT-lH,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or lG or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lI)local kU=pitchPID:get()U=U+kU end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=jT()return jK end;function script.onStart()local lJ={}local lK={}local lL=false;local function lM()local function lN(lO)local lP=dbHud_1.hasKey;for cG,cH in pairs(lO)do if lP(cH)then local cX=g(dbHud_1.getStringValue(cH))if cX~=nil then _G[cH]=cX;lL=true end end end end;if dbHud_1 then if not useTheseSettings then lN(c2())coroutine.yield()lN(c)else lN(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;lL=false end;coroutine.yield()if lL then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function lQ()local function lR(lS,lT)if lS>lT then lT=lS end;local lU,lV=0,0;if ContainerOptimization>0 then lU=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lV=FuelTankOptimization*0.05 end;lT=lT*(1-(lU+lV))return lT end;local lW=core.getElementNameById;local lX=fuelX~=0 and fuelY~=0;for cG in pairs(at)do local type=core.getElementTypeById(at[cG])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cG])),'^.*vertical.*$')and core.getElementForwardById(at[cG])[3]>0 then bx=true;p("UpEngine")end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cG])),'^.*vertical.*$')then local lY=core.getElementForwardById(at[cG])if lY[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local lZ=j(at[cG])if lZ>10000 then G=110 elseif lZ>1000 then G=55 elseif lZ>150 then G=27 end end;aL=aL+j(at[cG])if lX and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lZ=j(at[cG])local j8=l(at[cG])local lS=0;local gM=q()if type=="Atmospheric Fuel Tank"then local lT=400;local l_=35.03;if lZ>10000 then lT=51200;l_=5480 elseif lZ>1300 then lT=6400;l_=988.67 elseif lZ>150 then lT=1600;l_=182.67 end;lS=j8-l_;if fuelTankHandlingAtmo>0 then lT=lT+lT*fuelTankHandlingAtmo*0.2 end;lT=lR(lS,lT)aI[#aI+1]={at[cG],lW(at[cG]),lT,l_,lS,gM}end;if type=="Rocket Fuel Tank"then local lT=320;local l_=173.42;if lZ>65000 then lT=40000;l_=25740 elseif lZ>6000 then lT=5120;l_=4720 elseif lZ>700 then lT=640;l_=886.72 end;lS=j8-l_;if fuelTankHandlingRocket>0 then lT=lT+lT*fuelTankHandlingRocket*0.1 end;lT=lR(lS,lT)aK[#aK+1]={at[cG],lW(at[cG]),lT,l_,lS,gM}end;if type=="Space Fuel Tank"then local lT=600;local l_=35.03;if lZ>10000 then lT=76800;l_=5480 elseif lZ>1300 then lT=9600;l_=988.67 elseif lZ>150 then lT=2400;l_=182.67 end;lS=j8-l_;if fuelTankHandlingSpace>0 then lT=lT+lT*fuelTankHandlingSpace*0.2 end;lT=lR(lS,lT)aJ[#aJ+1]={at[cG],lW(at[cG]),lT,l_,lS,gM}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function m0()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cH in pairs(door)do cH.toggle()end end;if switch then for _,cH in pairs(switch)do cH.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cH in pairs(forcefield)do cH.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function m1(m2,m3,m4,m5,ca,cb,m6,m7,m8,m9)local ma={enableName=m2,disableName=m3,width=m4,height=m5,x=ca,y=cb,toggleVar=m6,toggleFunction=m7,drawCondition=m8,hovered=false}if m9 then table.insert(lK,ma)else table.insert(lJ,ma)end;return ma end;local function mb(mc)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif mc=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif mc=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif mc=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c2(mc)showHud=false else bE={}showHud=true end end;local function md()bD=not bD;if bD then aF=lK;a2="Hold SHIFT to see Settings"bF=showHud else aF=lJ;a2="Hold SHIFT to see Control Buttons"mb()showHud=bF end end;local function me(cH)_G[cH]=not _G[cH]if _G[cH]then a2=cH.." set to true"else a2=cH.." set to false"end;if cH=="showHud"then bF=_G[cH]elseif cH=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif cH=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function mf()local mg=50;local mh=340;local ca=500;local cb=aH/2-400;local mi=0;for cG,cH in pairs(c2("boolean"))do if type(_G[cH])=="boolean"then m1(cH,cH,mh,mg,ca,cb,function()return _G[cH]end,function()me(cH)end,function()return true end,true)cb=cb+mg+20;if mi==9 then ca=ca+mh+20;cb=aH/2-400;mi=0 else mi=mi+1 end end end;m1("Control View","Control View",mh,mg,10,aH/2-500,function()return true end,md,function()return true end,true)m1("View Handling Settings",'Hide Handling Settings',mh,mg,10,aH/2-(500-mg),function()return showHandlingVariables end,function()mb("handling")end,function()return true end,true)m1("View Hud Settings",'Hide Hud Settings',mh,mg,10,aH/2-(500-mg*2),function()return showHudVariables end,function()mb("hud")end,function()return true end,true)m1("View Physics Settings",'Hide Physics Settings',mh,mg,10,aH/2-(500-mg*3),function()return showPhysicsVariables end,function()mb("physics")end,function()return true end,true)end;local function mj()local function jD()local position=bv;local fW=planet.name..". "..#SavedLocations;if radar_1 then local d8,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d8~=nil and d8~=""then fW=fW.." "..radar_1.getConstructName(d8)end end;return aW.AddNewLocation(fW,position,false,true)end;local function mk()TurnBurn=not TurnBurn end;local function ml(mm)if mm==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mn()aW.UpdatePosition()end;local function jC()aW.ClearCurrentPosition()end;local function mo()local fW=AutopilotTargetName;if fW==nil then local ih=cm((bv-CustomTarget.position):len())fW=CustomTarget.name.." "..ih end;if fW==nil then fW="None"end;return"Engage Autopilot: "..fW end;local function mp()local fW=AutopilotTargetName;if fW==nil then fW=CustomTarget.name end;if fW==nil then fW="None"end;return"Disable Autopilot: "..fW end;local function mq()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)bX("folOn","F")else bX("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local mg=50;local mh=260;local mr=m1("Enable Brake Toggle","Disable Brake Toggle",mh,mg,aG/2-mh/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)m1("Align Prograde","Disable Prograde",mh,mg,aG/2-mh/2-50-mr.width,aH/2-mg+380,function()return ProgradeIsOn end,function()ml(1)end)m1("Align Retrograde","Disable Retrograde",mh,mg,aG/2-mh/2+mr.width+50,aH/2-mg+380,function()return RetrogradeIsOn end,ml,function()return ar==0 end)local ms=m1(mo,mp,600,60,aG/2-600/2,aH/2-60/2-400,function()return Autopilot end,cs)m1("Save Position","Save Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,jD,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)m1("Update Position","Update Position",200,ms.height,ms.x+ms.width+30,ms.y,function()return false end,mn,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)m1("Clear Position","Clear Position",200,ms.height,ms.x-200-30,ms.y,function()return true end,jC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mg=60;mh=300;local ca=10;local cb=aH/2-500;cb=cb+mg+20;m1("View Settings","View Settings",mh,mg,ca,cb,function()return true end,md)local cb=aH/2-300;m1("Enable Turn and Burn","Disable Turn and Burn",mh,mg,ca,cb,function()return TurnBurn end,mk)m1("Horizontal Takeoff Mode","Vertical Takeoff Mode",mh,mg,ca+mh+20,cb,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cb=cb+mg+20;m1("Show Orbit Display","Hide Orbit Display",mh,mg,ca,cb,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a2="Orbit Display Enabled"else a2="Orbit Display Disabled"end end)m1("Engage Orbiting","Cancel Orbiting",mh,mg,ca+mh+20,cb,function()return IntoOrbit end,cq,function()return ar==0 and bM end)cb=cb+mg+20;m1("Glide Re-Entry","Cancel Glide Re-Entry",mh,mg,ca,cb,function()return Reentry end,function()al=1;ml(1)end,function()return planet.hasAtmosphere and not aq end)m1("Parachute Re-Entry","Cancel Parachute Re-Entry",mh,mg,ca+mh+20,cb,function()return Reentry end,cv,function()return planet.hasAtmosphere and not aq end)cb=cb+mg+20;m1("Engage Follow Mode","Disable Follow Mode",mh,mg,ca,cb,function()return a0 end,mq,function()return m()==1 end)m1("Enable Repair Arrows","Disable Repair Arrows",mh,mg,ca+mh+20,cb,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cb=cb+mg+20;if not ExternalAGG then m1("Enable AGG","Disable AGG",mh,mg,ca,cb,function()return by end,cw,function()return antigrav~=nil end)end;m1(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,mh*2,mg,ca,cb,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cb=cb+mg+20;m1(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,mh*2,mg,ca,cb,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)end;local function mt()local mu={}local function mv()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local mw={[1]=4480,[6]=4480,[7]=6270}for mx,my in pairs(b)do b[mx][0]=mv()b[mx][0].systemId=mx;mu[mx]={}for mz,planet in pairs(b[mx])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]if planet.name=="Lacobus"then planet.surfaceMaxAltitude=1660 end;planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=mw[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=mx;planet.bodyId=planet.id;mu[mx][mz]=planet end end;aQ=cI()aR=aQ(mu)aS=e2()aU=ew()aY=eU()aV=g5()aW=jq()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lM()coroutine.yield()lQ()coroutine.yield()aX=jJ()m0()mf()mj()aF=lJ;coroutine.yield()mt()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bX("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cH in pairs(door)do cH.toggle()end end;if switch then for _,cH in pairs(switch)do cH.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cH in pairs(forcefield)do cH.toggle()end end;cC()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;bX("stop","SU")end;function script.onTick(mA)local mB=nil;if mA=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"bX("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif mA=="tenthSecond"then local function mC()local mD=system.createData;local mE=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mE(panelInterplanetary,"value")interplanetaryHeaderText=mD('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mE(panelInterplanetary,"value")widgetDistanceText=mD('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=mE(panelInterplanetary,"value")widgetTravelTimeText=mD('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mE(panelInterplanetary,"value")widgetMaxMassText=mD('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mE(panelInterplanetary,"value")widgetTargetOrbitText=mD('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mE(panelInterplanetary,"value")widgetCurBrakeDistanceText=mD('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mE(panelInterplanetary,"value")widgetCurBrakeTimeText=mD('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mE(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mD('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mE(panelInterplanetary,"value")widgetMaxBrakeTimeText=mD('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mE(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mD('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mF()t(panelInterplanetary)panelInterplanetary=nil end;local function mG()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eu=bs;local kW=unit.getThrottle()/100;if AtmoSpeedAssist then kW=K end;local mH,mI=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*kW,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mJ;if not TurnBurn and eu>0 then _,mJ=aX.GetAutopilotBrakeDistanceAndTime(eu)else _,mJ=aX.GetAutopilotTBBrakeDistanceAndTime(eu)end;local mK=0;local mL=0;if AutopilotCruising or not Autopilot and eu>5 then mL=aS.computeTravelTime(eu,0,AutopilotDistance)elseif a8+mH<AutopilotDistance then mK=AutopilotDistance-(a8+mH)mL=aS.computeTravelTime(8333.0556,0,mK)else local mM=(AutopilotDistance-a8)/mH;mH=AutopilotDistance-a8;mI=mI*mM end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mL elseif AutopilotBraking then return mJ elseif AutopilotCruising then return mL+mJ else return mI+a9+mL end end;local function mN(j2,mO)if j2==nil then j2=core.g()end;j2=A(j2,5)if mO~=nil and mO or(mB==nil or mB~=j2)then local eu=bq:len()local mP=g(unit.getData()).maxBrake;if mP~=nil and mP>0 and aq then mP=mP/r(eu/100,0.1,1)mP=mP/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mP)/2 else LastMaxBrakeInAtmo=mP end end end;if mP~=nil and mP>0 then LastMaxBrake=mP end;mB=j2 end end;mN(nil,true)if bz~=nil then if s:getTargetSpeed(axisCommandId.longitudinal)~=bz then ci(bz,TRUE)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mC()end;if AutopilotTargetName~=nil then local mQ=CustomTarget~=nil;local mR=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()mR=mR>1000000 and A(mR/1000000,2).." kTons"or A(mR/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mG()if mQ and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ih=cm(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ih..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cx(travelTime)..'", "unit":""}')ih=cm(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ih..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cx(a9)..'", "unit":""}')ih=cm(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ih..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cx(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",mR)..'", "unit":""}')ih=cm(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ih..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cf(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mF()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif mA=="oneSecond"then local function mS(gT)local mT=0;aD=""local mU=aL;local mV=0;local mW=0;local mX=0;local gQ=0;local gR=""local mY=core.getElementHitPointsById;for cG in pairs(at)do local lZ=0;local mZ=0;mZ=j(at[cG])lZ=mY(at[cG])mV=mV+lZ;if lZ<mZ then if lZ==0 then mX=mX+1 else mW=mW+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cG]))local ca=position.x;local cb=position.y;local fo=position.z;table.insert(aA,core.spawnArrowSticker(ca,cb,fo+1,"down"))table.insert(aA,core.spawnArrowSticker(ca,cb,fo+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(ca+1,cb,fo,"north"))table.insert(aA,core.spawnArrowSticker(ca+1,cb,fo,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(ca-1,cb,fo,"south"))table.insert(aA,core.spawnArrowSticker(ca-1,cb,fo,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(ca,cb-1,fo,"east"))table.insert(aA,core.spawnArrowSticker(ca,cb-1,fo,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(ca,cb+1,fo,"west"))table.insert(aA,core.spawnArrowSticker(ca,cb+1,fo,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cG])end elseif aM and#aA>0 and aA[11]==at[cG]then for gL in pairs(aA)do core.deleteSticker(aA[gL])end;aA={}end end;mT=e(mV/mU*100)if mT<100 then gT[#gT+1]=c9(0,0,"","pbright txt")gQ=e(mT*2.55)gR=f("rgb(%d,%d,%d)",255-gQ,gQ,0)if mT<100 then gT[#gT+1]=c9("50%",1035,"Elemental Integrity: "..mT.."%","txtbig txtmid","fill:"..gR)if mX>0 then gT[#gT+1]=c9("50%",1055,"Disabled Modules: "..mX.." Damaged Modules: "..mW,"txtbig txtmid","fill:"..gR)elseif mW>0 then gT[#gT+1]=c9("50%",1055,"Damaged Modules: "..mW,"txtbig txtmid","fill:"..gR)end end end end;local function m_()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function n0()local gM=q()local i4=bs;local n1=gM-au;if i4>1.38889 then i4=i4/1000;local n2=i4*(gM-au)TotalDistanceTravelled=TotalDistanceTravelled+n2;ad=ad+n2 end;ae=ae+n1;TotalFlightTime=TotalFlightTime+n1;au=gM end;n0()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()m_()local gT={}aV.ExtraData(gT)if ShowOdometer then gT=aV.DrawOdometer(gT,ad,TotalDistanceTravelled,ae)end;if ShouldCheckDamage then mS(gT)end;ak=table.concat(gT,"")collectgarbage("collect")elseif mA=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cX=g(dbHud_1.getStringValue("SavedLocations"))if cX~=nil then _G["SavedLocations"]=cX;local fH=-1;local jF;for cG,cH in pairs(SavedLocations)do if cH.name and cH.name=="SatNav Location"then fH=cG;break end end;if fH~=-1 then jF=SavedLocations[fH]fH=-1;for cG,cH in pairs(b[0])do if cH.name and cH.name=="SatNav Location"then fH=cG;break end end;if fH>-1 then b[0][fH]=jF end;aW.UpdateAtlasLocationsList()a2=jF.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mA=="msgTick"then local gT={}aV.DisplayMessage(gT,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif mA=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif mA=="hudTick"then if not planet then return end;local function n3(gT)local n4=e(r(aj/(aG/4)*255,0,255))gT[#gT+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+n4,e(J+0.5)-n4,e(I+0.5)-n4)end;local function n5()for _,cH in pairs(aF)do if cH.hovered then if not cH.drawCondition or cH.drawCondition()then cH.toggleFunction()end;cH.hovered=false end end end;local function n6()local function n7(n8,n9,ca,cb,m4,m5)if n8>ca and n8<ca+m4 and n9>cb and n9<cb+m5 then return true else return false end end;local ca=ag+aG/2;local cb=ah+aH/2;for _,cH in pairs(aF)do cH.hovered=n7(ca,cb,cH.x,cH.y,cH.width,cH.height)end end;local function na(gT)local function nb(gT,nc,hover,ca,cb,en,nd,ne,nf,ng,nh)if type(ng)=="function"then ng=ng()end;if type(nh)=="function"then nh=nh()end;gT[#gT+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",ca,cb,en,nd)if nc then gT[#gT+1]=f("%s'",ne)else gT[#gT+1]=nf end;if hover then gT[#gT+1]=" style='stroke:white; stroke-width:2'"else gT[#gT+1]=" style='stroke:black; stroke-width:1'"end;gT[#gT+1]="></rect>"gT[#gT+1]=f("<text x='%f' y='%f' font-size='24' fill='",ca+en/2,cb+nd/2+5)if nc then gT[#gT+1]="black"else gT[#gT+1]="white"end;gT[#gT+1]="' text-anchor='middle' font-family='Montserrat'>"if nc then gT[#gT+1]=f("%s</text>",ng)else gT[#gT+1]=f("%s</text>",nh)end end;local ni="rgb(50,50,50)'"local nj="rgb(210,200,200)"local nk=nb;for _,cH in pairs(aF)do local m3=cH.disableName;local m2=cH.enableName;if type(m3)=="function"then m3=m3()end;if type(m2)=="function"then m2=m2()end;if not cH.drawCondition or cH.drawCondition()then nk(gT,cH.toggleVar(),cH.hovered,cH.x,cH.y,cH.width,cH.height,nj,ni,m3,m2)end end end;local nl=A(ResolutionX/2,0)local nm=A(ResolutionY/2,0)local gT={}aV.HUDPrologue(gT)if showHud then aV.UpdateHud(gT)else if AlwaysVSpd then aV.DrawVerticalSpeed(gT,as)end;aV.DisplayOrbitScreen(gT)aV.DrawWarnings(gT)end;if bD and bE~={}then aV.DrawSettings(gT)end;if radar_1 then aV.DrawRadarInfo()end;aV.HUDEpilogue(gT)gT[#gT+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(gT,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gT)end end;if x()==0 then if m()==1 and a1 then if not AltIsOn then n6()na(gT)end;if not aZ and not a_ then local nn=table.concat(gT,"")gT={}gT[#gT+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gT[#gT+1]=nn;gT[#gT+1]="</body>"aZ=true;gT[#gT+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gT,"")system.setScreen(content)elseif a_ then local nn=table.concat(gT,"")gT={}gT[#gT+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gT[#gT+1]=nn;gT[#gT+1]="</body>"end;if not aZ then gT[#gT+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nl,nm,ag,ah)end else n5()end else if not a1 and m()==0 then n5()if aj>DeadZone then if DisplayDeadZone then n3(gT)end end elseif not AltIsOn or AltIsOn and a1 then n6()na(gT)end;gT[#gT+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nl,nm,ag,ah)end;gT[#gT+1]=[[</svg></body>]]content=table.concat(gT,"")elseif mA=="apTick"then aX.APTick()elseif mA=="radarTick"then aY.UpdateRadar()elseif mA=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function getPitch(no,gW,jv)local np=no:cross(jv):normalize_inplace()local hI=math.acos(r(np:dot(-gW),-1,1))*constants.rad2deg;if np:cross(-gW):dot(jv)<0 then hI=-hI end;return hI end;function script.onFlush()local function nq(nr,l3)local ns=vec3()local nt=vec3()if nr==axisCommandId.longitudinal then ns=vec3(core.getConstructOrientationForward())nt=bo elseif nr==axisCommandId.vertical then ns=vec3(core.getConstructOrientationUp())nt=bn elseif nr==axisCommandId.lateral then ns=vec3(core.getConstructOrientationRight())nt=bp else return vec3()end;local nu=vec3(core.getWorldGravity())local nw=nu:dot(nt)local nx=vec3(core.getWorldAirFrictionAcceleration())local ny=nx:dot(nt)local nz=bq:dot(ns)local nA=l3*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nA-nz)local nB=targetSpeedPID2:get()local nC=(nB-ny-nw)*nt;return nC end;local function nD(nr,l3)local ns=vec3()local nt=vec3()if nr==axisCommandId.longitudinal then ns=vec3(core.getConstructOrientationForward())nt=bo elseif nr==axisCommandId.vertical then ns=vec3(core.getConstructOrientationUp())nt=bn elseif nr==axisCommandId.lateral then ns=vec3(core.getConstructOrientationRight())nt=bp else return vec3()end;local nu=vec3(core.getWorldGravity())local nw=nu:dot(nt)local nx=vec3(core.getWorldAirFrictionAcceleration())local ny=nx:dot(nt)local nz=bq:dot(ns)local nA=l3*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nA-nz)local nB=targetSpeedPID:get()local nC=(nB-ny-nw)*nt;return nC end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cf(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local nE=r(T+U+system.getControlDeviceForwardInput(),-1,1)local nF=r(W+Z+system.getControlDeviceYawInput(),-1,1)local nG=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local nH=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local kE=bC/180*math.pi;local kF=math.cos(kE)local kG=math.sin(kE)bB=getPitch(bt,bo,bp*kF+bn*kG)local nI=br:normalize()local nJ=d(bC)local nK=utils.sign(bC)local nL=vec3(core.getWorldAngularVelocity())local nM=nE*pitchSpeedFactor*bp+nF*rollSpeedFactor*bo+nG*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local nN=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and nN>0 or ar>0.0 and nN<autoRollRollThreshold and autoRollPreference)and nF==0 and d(bB)<85 then local nO=b4;local nP=autoRollFactor;if ar==0 then nP=nP/4;b4=0;nO=0 end;if rollPID==nil then rollPID=pid.new(nP*0.01,0,nP*0.1)end;rollPID:inject(nO-bC)local nQ=rollPID:get()nM=nM+nQ*bo end end;local nR=1;local nS=0;local nT=1;if system.getMouseWheel()>0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nU=K;K=A(r(K+speedChangeLarge/100,-1,1),2)if K>=0 and nU<0 then K=0;aw=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ar>0 or Reentry then b7=r(b7-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif aw then local nU=K;K=A(r(K-speedChangeLarge/100,-1,1),2)if K<=0 and nU>0 then K=0;aw=false end end else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local nV=throttlePID:get()N=r(nV,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local nW=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=nW end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local nX=''local nY=vec3()local nZ=nq(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",nZ,nS)local n_='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then n_=n_..ExtraLongitudeTags end;local o0=s:getAxisCommandType(axisCommandId.longitudinal)local o1=s:composeAxisAccelerationFromThrottle(n_,axisCommandId.longitudinal)local o2=nD(axisCommandId.lateral,LeftAmount*1000)nX=nX..' , '.."lateral airfoil , lateral ground "nY=nY+o2;if nY:len()>constants.epsilon then a:setEngineForceCommand(nX,nY,nS,'','','',nT)end;a:setEngineForceCommand(n_,o1,nR)local o3='thrust analog vertical fueled 'local o4='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then o4=o4 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then o3=o3 ..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o3,nZ,nR)else a:setEngineForceCommand(o3,vec3(),nR)end;if LeftAmount~=0 then a:setEngineForceCommand(o4,o2,nR)else a:setEngineForceCommand(o4,vec3(),nR)end;if nH==0 then nH=L end;local o5=-nH*(brakeSpeedFactor*br+brakeFlatFactor*nI)a:setEngineForceCommand('brake',o5)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local l3=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-l3/3.6)local nW=r(brakePID:get(),0,1)nH=r(nH+nW,0,1)end;local o5=-nH*(brakeSpeedFactor*br+brakeFlatFactor*nI)a:setEngineForceCommand('brake',o5)local nX=''local nY=vec3()local o6=false;local n_='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then n_=n_..ExtraLongitudeTags end;local o0=s:getAxisCommandType(axisCommandId.longitudinal)if o0==axisCommandType.byThrottle then local o1=s:composeAxisAccelerationFromThrottle(n_,axisCommandId.longitudinal)a:setEngineForceCommand(n_,o1,nR)elseif o0==axisCommandType.byTargetSpeed then local o1=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)nX=nX..' , '..n_;nY=nY+o1;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then o6=true end end;local o4='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then o4=o4 ..ExtraLateralTags end;local o7=s:getAxisCommandType(axisCommandId.lateral)if o7==axisCommandType.byThrottle then local o8=s:composeAxisAccelerationFromThrottle(o4,axisCommandId.lateral)a:setEngineForceCommand(o4,o8,nR)elseif o7==axisCommandType.byTargetSpeed then local o2=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)nX=nX..' , '..o4;nY=nY+o2 end;local o3='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then o3=o3 ..ExtraVerticalTags end;local o9=s:getAxisCommandType(axisCommandId.vertical)if o9==axisCommandType.byThrottle then local nZ=s:composeAxisAccelerationFromThrottle(o3,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o3,nZ,nR,'airfoil','ground','',nT)else a:setEngineForceCommand(o3,vec3(),nR)a:setEngineForceCommand('airfoil vertical',nZ,nR,'airfoil','','',nT)a:setEngineForceCommand('ground vertical',nZ,nR,'ground','','',nT)end elseif o9==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),nR)end;local oa=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)nX=nX..' , '..o3;nY=nY+oa end;if nY:len()>constants.epsilon then if Y~=0 or o6 or d(nI:dot(bo))<0.5 then nX=nX..', brake'end;a:setEngineForceCommand(nX,nY,nS,'','','',nT)end end;local ob=torqueFactor*(nM-nL)local oc=vec3(core.getWorldAirFrictionAngularAcceleration())ob=ob-oc;a:setEngineTorqueCommand('torque',ob,nR,'airfoil','','',nT)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local eu=bq:len()local od=0.15;if not bA then local oe=s:getTargetSpeed(axisCommandId.longitudinal)if eu*3.6>oe*(1-od)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eu*3.6<oe*(1-od)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kW=unit.getThrottle()if AtmoSpeedAssist then kW=K*100 end;local l3=kW/100;if k==0 then l3=l3*MaxGameVelocity;if eu>=l3*(1-od)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eu<l3*(1-od)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local le=e(b7)l3=l3*le/3.6;if eu>=l3*(1-od)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eu<l3*(1-od)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g2=coroutine.status(beginSetup)if g2=="suspended"then local cg,g3=coroutine.resume(beginSetup)if g3 then system.print("ERROR STARTUP: "..g3)end elseif g2=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(of)local function og(oh)local D=1;local function oi(oj,oh)local ok={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local ol=oj;for _,cH in ipairs(ok)do if oh and ol>cH then oj=cH elseif oj<cH and not oh then oj=cH;break end end;return oj end;if oh then D=-1 end;if not ExternalAGG and by then if a1 and oh then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=oi(bg,oh)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=oi(HoldAltitude,oh)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function om(oh)local D=1;if oh then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeLarge/100,-1,1)else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if oh then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end;local function on(oo)if not aq then a2="Flight Assist in Atmo only"return end;local cN=type(oo)if bK==nil then if cN=="table"then if Autopilot or VectorToTarget then cs()end;bX("180On","BR")elseif oo==1 then bX("bnkLft","BR")else bX("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cr()if cN~="table"then oo=oo+1 end end;bK=oo else bX("180Off","BR")bK=nil end end;if of=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cf(0)if vBooster or hover then if aq and ao==-1 then bX("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then bX("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then bX("grOut","LG",1)a.control.extendLandingGears()end else if S then bX("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif of=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif of=="forward"then T=T-1 elseif of=="backward"then if AltIsOn then on(-br*5000)else T=T+1 end elseif of=="left"then if AltIsOn then on(1)else W=W-1 end elseif of=="right"then if AltIsOn then on(3)else W=W+1 end elseif of=="yawright"then X=X-1 elseif of=="yawleft"then X=X+1 elseif of=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif of=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif of=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif of=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif of=="groundaltitudeup"then og()elseif of=="groundaltitudedown"then og(true)elseif of=="option1"then toggleView=false;if AltIsOn and a1 then local op=""for i=1,#passengers do op=op.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..op)return end;aW.adjustAutopilotTargetIndex()elseif of=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif of=="option3"then local function oq()aE=not aE;if not aE then bX("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else bX("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local op=""for i=1,#ships do op=op.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..op)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;oq()toggleView=false elseif of=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cs()elseif of=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then bX("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bX("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif of=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local os=shield_1.getVentingCooldown()if os>0 then a2="Cannot vent again for "..os.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cr()elseif of=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif of=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()bX("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)bX("gsOn","GS")end;toggleView=false elseif of=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cf(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then bX("gyOn","GA")else bX("gyOff","GA")end end;toggleView=false elseif of=="lshift"then if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif of=="brake"then if BrakeToggleStatus then cu()elseif not BrakeIsOn then cu()else BrakeIsOn=true end elseif of=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif of=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif of=="stopengines"then local function ot()if E-F<1.5 then bX("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;ot()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cf(0)else cf(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then ci(AtmoSpeedLimit)else ci(MaxGameVelocity*3.6)end end end elseif of=="speedup"then om()elseif of=="speeddown"then om(true)elseif of=="antigravity"and not ExternalAGG then if antigrav~=nil then cw()end end end;function script.onActionStop(of)local function ou()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if of=="forward"then T=0 elseif of=="backward"then T=0 elseif of=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif of=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif of=="yawright"then X=0 elseif of=="yawleft"then X=0 elseif of=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif of=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif of=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif of=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif of=="groundaltitudeup"then ou()toggleView=false elseif of=="groundaltitudedown"then ou()toggleView=false elseif of=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif of=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cu()else BrakeIsOn=false end end elseif of=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(of)local function ov(oh)local D=1;if oh then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function ow(oh)local D=1;if oh then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if of=="groundaltitudeup"then if not a1 then ov()end elseif of=="groundaltitudedown"then if not a1 then ov(true)end elseif of=="speedup"then ow()elseif of=="speeddown"then ow(true)end end;function script.onInputText(cc)local function ox()for cG,cH in pairs(c2())do dbHud_1.setStringValue(cH,h(nil))end;for cG,cH in pairs(c)do if cH~="SavedLocations"then dbHud_1.setStringValue(cH,h(nil))end end;a2="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ai=5 end;local function oy(oz,ey,hE)local function oA(ey)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV='::pos{'..B..','..B..','..B..','..B..','..B..'}'local d7,d8,de,df,dg=o(ey,cV)if d7=="0"and d8=="0"then return vec3(z(de),z(df),z(dg))end;df=math.rad(df)de=math.rad(de)local planet=b[z(d7)][z(d8)]local d_=math.cos(de)local oB=vec3(d_*math.cos(df),d_*math.sin(df),math.sin(de))return planet.center+(planet.radius+dg)*oB end;local position=oA(ey)return aW.AddNewLocation(oz,position,hE)end;local i;local oC,oD=nil,nil;local oE="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(cc," ")oC=cc;if i~=nil then oC=string.sub(cc,0,i-1)oD=string.sub(cc,i+1)end;if oC=="/help"or oC=="/commands"then for jc in string.gmatch(oE,"([^\n]+)")do system.print(jc)end;return elseif oC=="/setname"then if oD==nil or oD==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(oD)else a2="Select a saved target to rename first"end elseif shield_1 and oC=="/resist"then if oD==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cV=B..', '..B..', '..B..', '..B;local oF,oG,oH,oI=o(oD,cV)if oI==nil or oF+oG+oH+oI>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(oF,oG,oH,oI)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif oC=="/addlocation"or string.find(cc,"::pos")~=nil then local hE=false;local oz="0-Temp"if oD==nil or oD==""then oD=oC;hE=true end;i=string.find(oD,"::")if not hE then oz=string.sub(oD,1,i-2)end;local ey=string.sub(oD,i)oy(oz,ey,hE)elseif oC=="/agg"then if oD==nil or oD==""then a2="Usage: /agg targetheight"return end;oD=z(oD)if oD<1000 then oD=1000 end;AntigravTargetAltitude=oD;a2="AGG Target Height set to "..oD elseif oC=="/G"then if oD==nil or oD==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oD=="dump"then for cG,cH in pairs(c2())do if type(_G[cH])=="boolean"then if _G[cH]==true then system.print(cH.." true")else system.print(cH.." false")end elseif _G[cH]==nil then system.print(cH.." nil")else system.print(cH.." ".._G[cH])end end;return end;i=string.find(oD," ")local oJ=string.sub(oD,0,i-1)local oK=string.sub(oD,i+1)for cG,cH in pairs(c2())do if cH==oJ then a2="Variable "..oJ.." changed to "..oK;local oL=type(_G[cH])if oL=="number"then oK=z(oK)elseif oL=="boolean"then if string.lower(oK)=="true"then oK=true else oK=false end end;_G[cH]=oK;return end end;a2="No such global variable: "..oJ elseif oC=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif oC=="/copydatabank"then if dbHud_2 then cC(true)else a2="Spare Databank required to copy databank"end elseif oC=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(d8)if radar_1 and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(d8)if radar_1 and CollisionSystem then if#bL>650 then d8=tostring(d8)bL[d8]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
