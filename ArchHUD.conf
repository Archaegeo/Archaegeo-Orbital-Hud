name: ArchHud - Archaegeo v0.708 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.708;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(K)t=K end,get=function()return t end},AtmoSpeedAssist={set=function(K)u=K end,get=function()return u end},ForceAlignment={set=function(K)v=K end,get=function()return v end},DisplayDeadZone={set=function(K)w=K end,get=function()return w end},showHud={set=function(K)x=K end,get=function()return x end},hideHudOnToggleWidgets={set=function(K)y=K end,get=function()return y end},ShiftShowsRemoteButtons={set=function(K)z=K end,get=function()return z end},SetWaypointOnExit={set=function(K)A=K end,get=function()return A end},AlwaysVSpd={set=function(K)B=K end,get=function()return B end},BarFuelDisplay={set=function(K)C=K end,get=function()return C end},voices={set=function(K)D=K end,get=function()return D end},alerts={set=function(K)E=K end,get=function()return E end},CollisionSystem={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=30000;W=1000;X=50;Y=0;Z=100000;_=8333.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end}}a8=1920;a9=1080;aa=400;ab=130;ac=224;ad=255;ae=255;af=0;ag=0;ah=960;ai=540;aj=1300;ak=540;al=1525;am=325;an=550;ao=540;ap=30;aq=700;ar=1750;as=250;at=50;au=250;av=0;aw=30;ax=100;ay={ResolutionX={set=function(K)a8=K end,get=function()return a8 end},ResolutionY={set=function(K)a9=K end,get=function()return a9 end},circleRad={set=function(K)aa=K end,get=function()return aa end},SafeR={set=function(K)ab=K end,get=function()return ab end},SafeG={set=function(K)ac=K end,get=function()return ac end},SafeB={set=function(K)ad=K end,get=function()return ad end},PvPR={set=function(K)ae=K end,get=function()return ae end},PvPG={set=function(K)af=K end,get=function()return af end},PvPB={set=function(K)ag=K end,get=function()return ag end},centerX={set=function(K)ah=K end,get=function()return ah end},centerY={set=function(K)ai=K end,get=function()return ai end},throtPosX={set=function(K)aj=K end,get=function()return aj end},throtPosY={set=function(K)ak=K end,get=function()return ak end},vSpdMeterX={set=function(K)al=K end,get=function()return al end},vSpdMeterY={set=function(K)am=K end,get=function()return am end},altMeterX={set=function(K)an=K end,get=function()return an end},altMeterY={set=function(K)ao=K end,get=function()return ao end},fuelX={set=function(K)ap=K end,get=function()return ap end},fuelY={set=function(K)aq=K end,get=function()return aq end},shieldX={set=function(K)ar=K end,get=function()return ar end},shieldY={set=function(K)as=K end,get=function()return as end},DeadZone={set=function(K)at=K end,get=function()return at end},OrbitMapSize={set=function(K)au=K end,get=function()return au end},OrbitMapX={set=function(K)av=K end,get=function()return av end},OrbitMapY={set=function(K)aw=K end,get=function()return aw end},soundVolume={set=function(K)ax=K end,get=function()return ax end}}az=5;aA=1;aB=0.003;aC=0.003;aD=2;aE=1.5;aF=180;aG=150;aH=0.002;aI=2;aJ=0.8;aK=1;aL=3;aM=1;aN=40;aO=0.0166667;aP=0.0666667;aQ="none"aR="none"aS="none"aT={speedChangeLarge={set=function(K)az=K end,get=function()return az end},speedChangeSmall={set=function(K)aA=K end,get=function()return aA end},MouseXSensitivity={set=function(K)aB=K end,get=function()return aB end},MouseYSensitivity={set=function(K)aC=K end,get=function()return aC end},autoRollFactor={set=function(K)aD=K end,get=function()return aD end},rollSpeedFactor={set=function(K)aE=K end,get=function()return aE end},autoRollRollThreshold={set=function(K)aF=K end,get=function()return aF end},minRollVelocity={set=function(K)aG=K end,get=function()return aG end},TrajectoryAlignmentStrength={set=function(K)aH=K end,get=function()return aH end},torqueFactor={set=function(K)aI=K end,get=function()return aI end},pitchSpeedFactor={set=function(K)aJ=K end,get=function()return aJ end},yawSpeedFactor={set=function(K)aK=K end,get=function()return aK end},brakeSpeedFactor={set=function(K)aL=K end,get=function()return aL end},brakeFlatFactor={set=function(K)aM=K end,get=function()return aM end},DampingMultiplier={set=function(K)aN=K end,get=function()return aN end},apTickRate={set=function(K)aO=K end,get=function()return aO end},hudTickRate={set=function(K)aP=K end,get=function()return aP end},ExtraLongitudeTags={set=function(K)aQ=K end,get=function()return aQ end},ExtraLateralTags={set=function(K)aR=K end,get=function()return aR end},ExtraVerticalTags={set=function(K)aS=K end,get=function()return aS end}}aU=j;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=1000;b6=false;b7=false;b8=false;b9=false;ba=0;bb="Aligning"bc=0;bd=1;be="None"bf=nil;bg=0;bh=nil;bi=0.0;bj=0;bk={}bl=false;bm=0;bn=0;bo=nil;bp=0;bq=1000;br=0;bs=false;bt=0;bu=false;bv="All"bw=true;bx="Off"by=0.000;bz={}bA={VertTakeOff={set=function(K)b4=K end,get=function()return b4 end},VertTakeOffEngine={set=function(K)aV=K end,get=function()return aV end},SpaceTarget={set=function(K)bs=K end,get=function()return bs end},BrakeToggleStatus={set=function(K)aU=K end,get=function()return aU end},BrakeIsOn={set=function(K)aW=K end,get=function()return aW end},RetrogradeIsOn={set=function(K)aX=K end,get=function()return aX end},ProgradeIsOn={set=function(K)aY=K end,get=function()return aY end},Autopilot={set=function(K)aZ=K end,get=function()return aZ end},TurnBurn={set=function(K)a_=K end,get=function()return a_ end},AltitudeHold={set=function(K)b0=K end,get=function()return b0 end},BrakeLanding={set=function(K)b1=K end,get=function()return b1 end},Reentry={set=function(K)b3=K end,get=function()return b3 end},AutoTakeoff={set=function(K)b2=K end,get=function()return b2 end},HoldAltitude={set=function(K)b5=K end,get=function()return b5 end},AutopilotAccelerating={set=function(K)b6=K end,get=function()return b6 end},AutopilotBraking={set=function(K)b8=K end,get=function()return b8 end},AutopilotCruising={set=function(K)b9=K end,get=function()return b9 end},AutopilotRealigned={set=function(K)b7=K end,get=function()return b7 end},AutopilotEndSpeed={set=function(K)ba=K end,get=function()return ba end},AutopilotStatus={set=function(K)bb=K end,get=function()return bb end},AutopilotPlanetGravity={set=function(K)bc=K end,get=function()return bc end},PrevViewLock={set=function(K)bd=K end,get=function()return bd end},AutopilotTargetName={set=function(K)be=K end,get=function()return be end},AutopilotTargetCoords={set=function(K)bf=K end,get=function()return bf end},AutopilotTargetIndex={set=function(K)bg=K end,get=function()return bg end},TotalDistanceTravelled={set=function(K)bi=K end,get=function()return bi end},TotalFlightTime={set=function(K)bj=K end,get=function()return bj end},SavedLocations={set=function(K)bk=K end,get=function()return bk end},VectorToTarget={set=function(K)bl=K end,get=function()return bl end},LocationIndex={set=function(K)bm=K end,get=function()return bm end},LastMaxBrake={set=function(K)bn=K end,get=function()return bn end},LockPitch={set=function(K)bo=K end,get=function()return bo end},LastMaxBrakeInAtmo={set=function(K)bp=K end,get=function()return bp end},AntigravTargetAltitude={set=function(K)bq=K end,get=function()return bq end},LastStartTime={set=function(K)br=K end,get=function()return br end},iphCondition={set=function(K)bv=K end,get=function()return bv end},stablized={set=function(K)bw=K end,get=function()return bw end},UseExtra={set=function(K)bx=K end,get=function()return bx end},SelectedTab={set=function(K)bB=K end,get=function()return bB end},saveRoute={set=function(K)bz=K end,get=function()return bz end}}local function bC(a,b,c,bD,bE,bF)bG=bD()bH=ab;bI=ad;bJ=ac;bK=0;bL=0;bM=false;bN=0;bO=false;bP=false;bQ=false;bR=false;bS=0;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=false;b_=false;bZ=false;b_=false;c0="empty"c1=false;c2=0;c3=0;c4=nil;c5=0;c6=0;c7=0;c8=0;c9=0;ca=3;cb=0;cc=""cd=false;ce=false;cf=false;cg=-1;ch=bF()>0;ci=bF()cj=b.getAltitude()ck=bD()cl=b.getConstructMass()cm=false;cn=nil;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]cq=""cr=a8;cs=a9;ct={}cu={}cv={}cw=false;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=false;cH=false;cI=p;cJ=false;cK=0;cL=U;cM=0;cN=nil;cO={VectorToTarget=false}cP=0;cQ=false;cR=false;cS=false;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getVelocity())cX=vec3(b.getWorldVelocity())cY=vec3(cX):len()cZ=vec3(b.getWorldVertical())c_=-cZ:dot(cX)d0=vec3(b.getConstructWorldPos())d1=false;d2=false;d3=nil;d4=true;d5=0;d6=0;d7={}d8=false;d9=50000;da=nil;db={}dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;dd=false;de=nil;df=false;dg=0;dh=nil;di=nil;dj={}dk=90;dl=x;dm=nil end;local function dn(d,b,c,a,dp,dq,dr,ds,dt)local function du(dv)return type(dv)=='number'end;local function dw(dv)return type(dr(dv))=='number'end;local function dx(dy)return type(dy)=='table'end;local function dz(a)return type(a)=='string'end;local function dA(dB)return dx(dB)and du(dB.x and dB.y and dB.z)end;local function dC(dD)return dx(dD)and du(dD.latitude and dD.longitude and dD.altitude and dD.id and dD.systemId)end;local dE=math.pi/180;local dF=180/math.pi;local dG=1e-10;local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI='::pos{'..dH..','..dH..','..dH..','..dH..','..dH..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dJ(dv)local dK=string.gsub(string.reverse(dp('%.4f',dv)),'^0*%.?','')return dK==''and'0'or string.reverse(dK)end;local function dL(dM)if dA(dM)then return dp('{x=%.3f,y=%.3f,z=%.3f}',dM.x,dM.y,dM.z)end;if dx(dM)and not getmetatable(dM)then local dN={}local dO=next(dM)if type(dO)=='nil'or dO==1 then dN=dM else for dP,dB in pairs(dM)do local dQ=dL(dB)if type(dP)=='number'then table.insert(dN,dp('[%s]=%s',dP,dQ))else table.insert(dN,dp('%s=%s',dP,dQ))end end end;return dp('{%s}',table.concat(dN,','))end;if dz(dM)then return dp("'%s'",dM:gsub("'",[[\']]))end;return tostring(dM)end;local dR={}dR.__index=dR;dR.__tostring=function(dM,dS)local dT={}for dP in pairs(dM)do table.insert(dT,dP)end;table.sort(dT)local dN={}for dU,dP in ipairs(dT)do local dQ=dL(dM[dP])if type(dP)=='number'then table.insert(dN,dp('[%s]=%s',dP,dQ))else table.insert(dN,dp('%s=%s',dP,dQ))end end;if dS then return dp('%s%s',dS,table.concat(dN,',\n'..dS))end;return dp('{%s}',table.concat(dN,','))end;dR.__eq=function(dV,dW)return dV.systemId==dW.systemId and dV.id==dW.id and dt(dV.radius,dW.radius)and dt(dV.center.x,dW.center.x)and dt(dV.center.y,dW.center.y)and dt(dV.center.z,dW.center.z)and dt(dV.GM,dW.GM)end;local function dX(dY,dZ,d_,e0,e1)assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(d_),'Argument 3 (radius) must be a number:'..type(d_))assert(dx(e0),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e0))assert(dw(e1),'Argument 5 (GM) must be a number:'..type(e1))return setmetatable({systemId=dr(dY),id=dr(dZ),radius=dr(d_),center=vec3(e0),GM=dr(e1)},dR)end;local e2={}e2.__index=e2;e2.__tostring=function(e3)return dp('::pos{%d,%d,%s,%s,%s}',e3.systemId,e3.id,dJ(e3.latitude*dF),dJ(e3.longitude*dF),dJ(e3.altitude))end;e2.__eq=function(dV,dW)return dV.id==dW.id and dV.systemId==dW.systemId and dt(dV.latitude,dW.latitude)and dt(dV.altitude,dW.altitude)and(dt(dV.longitude,dW.longitude)or dt(dV.latitude,math.pi/2)or dt(dV.latitude,-math.pi/2))end;local function e4(e5,dZ,e6,e7,e8)local dY=e5;if dz(e5)and not e7 and not e8 and not dZ and not e6 then dY,dZ,e6,e7,e8=e9(e5,dI)assert(dY,'Argument 1 (position string) is malformed.')else assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(e6),'Argument 3 (latitude) must be in degrees:'..type(e6))assert(dw(e7),'Argument 4 (longitude) must be in degrees:'..type(e7))assert(dw(e8),'Argument 5 (altitude) must be in meters:'..type(e8))end;dY=dr(dY)dZ=dr(dZ)e6=dr(e6)e7=dr(e7)e8=dr(e8)if dZ==0 then return setmetatable({latitude=e6,longitude=e7,altitude=e8,id=dZ,systemId=dY},e2)end;return setmetatable({latitude=dE*dq(e6,-90,90),longitude=dE*(e7%360),altitude=e8,id=dZ,systemId=dY},e2)end;local ea={}ea.__index=ea;ea.__tostring=function(dM,dS)local eb=dS and dS..'  'local ec={}local dT={}for dP in pairs(dM)do table.insert(dT,dP)end;table.sort(dT)for dU,ed in ipairs(dT)do ee=dM[ed]local ef=dR.__tostring(ee,eb)if dS then table.insert(ec,dp('[%s]={\n%s\n%s}',ed,ef,dS))else table.insert(ec,dp('  [%s]=%s',ed,ef))end end;if dS then return dp('\n%s%s%s',dS,table.concat(ec,',\n'..dS),dS)end;return dp('{\n%s\n}',table.concat(ec,',\n'))end;local function eg(eh)local e={}local pid;for dU,dB in pairs(eh)do local dZ=dB.planetarySystemId;if type(dZ)~='number'then error('Invalid planetary s ID: '..tostring(dZ))elseif pid and dZ~=pid then error('Mistringmatch planetary s IDs: '..dZ..' and '..pid)end;local ei=dB.bodyId;if type(ei)~='number'then error('Invalid body ID: '..tostring(ei))elseif e[ei]then error('Duplicate body ID: '..tostring(ei))end;setmetatable(dB.center,getmetatable(vec3.unit_x))e[ei]=setmetatable(dB,dR)pid=dZ end;return setmetatable(e,ea)end;ej={}local function ek(eh)return setmetatable({galaxyAtlas=eh or{}},ej)end;ej.__index=function(dy,K)if type(K)=='number'then local a=dy.galaxyAtlas[K]return eg(a)end;return rawget(ej,K)end;ej.__pairs=function(dM)return function(dy,dP)local el,em=next(dy,dP)return el,em and eg(em)end,dM.galaxyAtlas,nil end;ej.__tostring=function(dM)local en={}for dU,eo in pairs(dM or{})do local ep=eo:getPlanetarySystemId()local eq=ea.__tostring(eo,'    ')table.insert(en,dp('  [%s]={%s\n  }',ep,eq))end;return dp('{\n%s\n}\n',table.concat(en,',\n'))end;ej.BodyParameters=dX;ej.MapPosition=e4;ej.PlanetarySystem=eg;function ej.createBodyParameters(dY,dZ,er,es,et,eu,ev)assert(dw(dY),'Argument 1 (systemId) must be a number:'..type(dY))assert(dw(dZ),'Argument 2 (id) must be a number:'..type(dZ))assert(dw(er),'Argument 3 (surfaceArea) must be a number:'..type(er))assert(dx(es),'Argument 4 (aPosition) must be an array or vec3:'..type(es))assert(dx(et),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(et))assert(dw(eu),'Argument 6 (altitude) must be in meters:'..type(eu))assert(dw(ev),'Argument 7 (gravityAtPosition) must be number:'..type(ev))local d_=ds(er/4/math.pi)local cb=d_+eu;local ew=vec3(es)+cb*vec3(et)local e1=ev*cb*cb;return dX(dY,dZ,d_,ew,e1)end;ej.isMapPosition=dC;function ej:getPlanetarySystem(e5)if K==nil then K=0 end;if em==nil then em=0 end;local dY=e5;if dC(e5)then dY=e5.systemId end;if type(dY)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(em)~=ea then a=eg(a)end;return a end end end;function ea:sizeCalculator(ex)return 1.05*ex.radius end;function ea:castIntersections(ey,ez,eA,eB,eC,eD)local eE={}if eC then for dU,ex in pairs(eC)do table.insert(eE,ex)end else eE=dj end;if not eD then table.sort(eE,function(eF,eG)local eH=eF.center;local eI=eG.center;return(eH.x-ey.x)^2+(eH.y-ey.y)^2+(eH.z-ey.z)^2<(eI.x-ey.x)^2+(eI.y-ey.y)^2+(eI.z-ey.z)^2 end)end;local eJ=ez:normalize()for dU,ex in ipairs(eE)do local eK=ex.center-ey;local d_=self:sizeCalculator(ex)local eL=eK:dot(eJ)local eM=eL^2-(eK:len2()-d_^2)if eM>=0 then local eN=ds(eM)local eO=eL+eN;local eP=eL-eN;if eP>0 then return ex,eO,eP elseif eO>0 then return ex,eO,nil end end end;return nil,nil,nil end;function ea:closestBody(eQ)assert(type(eQ)=='table','Invalid coordinates.')local eR,ex;local eS=vec3(eQ)for dU,eT in pairs(self)do local eU=(eT.center-eS):len2()if(not ex or eU<eR)and eT.name~="Space"then ex=eT;eR=eU end end;return ex end;function ea:convertToBodyIdAndWorldCoordinates(e5)local eV=e5;if dz(e5)then eV=e4(e5)end;if eV.id==0 then return 0,vec3(eV.latitude,eV.longitude,eV.altitude)end;local eT=self:getBodyParameters(eV)if eT then return eV.id,eT:convertToWorldCoordinates(eV)end end;function ea:getBodyParameters(e5)local dZ=e5;if dC(e5)then dZ=e5.id end;assert(dw(dZ),'Argument 1 (id) must be a number:'..type(dZ))return self[dZ]end;function ea:getPlanetarySystemId()local dU,dB=next(self)return dB and dB.systemId end;function dR:convertToMapPosition(e0)assert(dx(e0),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e0))local eW=vec3(e0)if self.id==0 then return setmetatable({latitude=eW.x,longitude=eW.y,altitude=eW.z,id=0,systemId=self.systemId},e2)end;local eX=eW-self.center;local cb=eX:len()local e8=cb-self.radius;local e6=0;local e7=0;if not dt(cb,0)then local eY=eZ(eX.y,eX.x)e7=eY>=0 and eY or 2*math.pi+eY;e6=math.pi/2-math.acos(eX.z/cb)end;return setmetatable({latitude=e6,longitude=e7,altitude=e8,id=self.id,systemId=self.systemId},e2)end;function dR:convertToWorldCoordinates(e5)local eV=dz(e5)and e4(e5)or e5;if eV.id==0 then return vec3(eV.latitude,eV.longitude,eV.altitude)end;assert(dC(eV),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eV.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eV.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e_=math.cos(eV.latitude)return self.center+(self.radius+eV.altitude)*vec3(e_*math.cos(eV.longitude),e_*math.sin(eV.longitude),math.sin(eV.latitude))end;function dR:getAltitude(e0)return(vec3(e0)-self.center):len()-self.radius end;function dR:getDistance(e0)return(vec3(e0)-self.center):len()end;function dR:getGravity(e0)local f0=self.center-vec3(e0)local f1=f0:len2()return self.GM/f1*f0/ds(f1)end;return setmetatable(ej,{__call=function(dU,...)return ek(...)end})end;local function f2(d,b,c,a,ds,f3)local cy={}local f4=30000000/3600;local f5=f4*f4;local f6=100;function cy.computeAccelerationTime(f7,f8,f9)local fa=f4*math.asin(f7/f4)return(f4*math.asin(f9/f4)-fa)/f8 end;function cy.computeDistanceAndTime(f7,f9,fb,fc,fd,fe)fd=fd or 0;fe=fe or 0;local ff=f7<=f9;local fg=fc*(ff and 1 or-1)/fb;local fh=-fe/fb;local fi=fg+fh;if ff and fi<=0 or not ff and fi>=0 then return-1,-1 end;local fj,fk=0,0;if fg~=0 and fd>0 then local fa=math.asin(f7/f4)local fl=math.pi*(fg/2+fh)local fm=fg*fd;local fn=f4*math.pi;local dB=function(dy)local fo=(fl*dy-fm*math.sin(math.pi*dy/2/fd)+fn*fa)/fn;local fp=math.tan(fo)return f4*fp/ds(fp*fp+1)end;local fq=ff and function(a)return a>=f9 end or function(a)return a<=f9 end;fk=2*fd;if fq(dB(fk))then local fr=0;while f3(fk-fr)>0.5 do local dy=(fk+fr)/2;if fq(dB(dy))then fk=dy else fr=dy end end end;local fs=f7;local ft=fk/f6;for fu=1,f6 do local fv=dB(fu*ft)fj=fj+(fv+fs)*ft/2;fs=fv end;if fk<2*fd then return fj,fk end;f7=fs end;local fa=f4*math.asin(f7/f4)local bG=(f4*math.asin(f9/f4)-fa)/fi;local fw=f5*math.cos(fa/f4)/fi;local cb=fw-f5*math.cos((fi*bG+fa)/f4)/fi;return cb+fj,bG+fk end;function cy.computeTravelTime(f7,f8,cb)if cb==0 then return 0 end;if f8>0 then local fa=f4*math.asin(f7/f4)local fw=f5*math.cos(fa/f4)/f8;return(f4*math.acos(f8*(fw-cb)/f5)-fa)/f8 end;if f7==0 then return-1 end;assert(f7>0,'Acceleration and initial speed are both zero.')return cb/f7 end;return cy end;local function fx(d,b,c,a,dp,dq,dr,ds,dt)local vec3=require('cpml.vec3')local dn=dn(d,b,c,a,dp,dq,dr,ds,dt)local function dz(a)return type(a)=='string'end;local function dx(dy)return type(dy)=='table'end;fy={}fy.__index=fy;function fy:escapeAndOrbitalSpeed(e8)assert(self.body)local cb=e8+self.body.radius;if not dt(cb,0)then local fz=ds(self.body.GM/cb)return ds(2)*fz,fz end;return nil,nil end;function fy:orbitalParameters(e5,fA)assert(self.body)assert(dx(e5)or dz(e5))assert(dx(fA))local fB=(dz(e5)or dn.isMapPosition(e5))and self.body:convertToWorldCoordinates(e5)or vec3(e5)local dB=vec3(fA)local fC=fB-self.body.center;local fD=dB:len2()local fE=fC:len()local fF=self.body.GM;local fG=((fD-fF/fE)*fC-fC:dot(dB)*dB)/fF;local eH=fF/(2*fF/fE-fD)local fH=fG:len()local eJ=fG:normalize()local fI=eH*(1-fH)local fJ=eH*(1+fH)local fK=fI*eJ+self.body.center;local fL=fH<=1 and-fJ*eJ+self.body.center or nil;local fM=ds(eH*fF*(1-fH*fH))local fN=fL and 2*math.pi*ds(eH^3/fF)local fO=math.acos(fG:dot(fC)/(fH*fE))if fC:dot(dB)<0 then fO=-(fO-2*math.pi)end;local fP=math.acos((math.cos(fO)+fH)/(1+fH*math.cos(fO)))local fQ=fP;if fQ<0 then fQ=fQ+2*math.pi end;local fR=fQ-fH*math.sin(fQ)local fS=0;local fT=0;local fU=0;if fN~=nil then fS=fR/(2*math.pi/fN)fT=fN-fS;fU=fT+fN/2;if fO-math.pi>0 then fT=fS;fU=fT+fN/2 end;if fU>fN then fU=fU-fN end end;return{periapsis={position=fK,speed=fM/fI,circularOrbitSpeed=ds(fF/fI),altitude=fI-self.body.radius},apoapsis=fL and{position=fL,speed=fM/fJ,circularOrbitSpeed=ds(fF/fJ),altitude=fJ-self.body.radius},currentVelocity=dB,currentPosition=fB,eccentricity=fH,period=fN,eccentricAnomaly=fP,meanAnomaly=fR,timeToPeriapsis=fT,timeToApoapsis=fU,trueAnomaly=fO}end;local function fV(fW)local eT=dn.BodyParameters(fW.systemId,fW.id,fW.radius,fW.center,fW.GM)return setmetatable({body=eT},fy)end;return setmetatable(fy,{__call=function(dU,...)return fV(...)end})end;local function fX(d,b,c,a,dbHud_1,e,fY,fZ,bE,dr,ds,f_)local function g0(g1)local e3=g2:closestBody(g1)if(g1-e3.center):len()>e3.radius+e3.noAtmosphericDensityAltitude then e3=e[0][0]end;return e3 end;local function g3()local function g4(g5,g6)return g5.name<g6.name end;d7={}for dP,dB in pairs(e[0])do d7[#d7+1]={name=dB.name,index=dP}end;table.sort(d7,g4)end;local function g7(g8)for dP,dB in pairs(g8)do if dB.name and dB.name==g9.name then return dP end end;return-1 end;local function ga()dg=bg;if bg==0 then be="None"c4=nil;g9=nil;return true end;local gb=d7[bg].index;local gc=e[0][gb]if gc.center then be=gc.name;c4=cx[0][gb]if g9~=nil then if ci==0 then if fY(gd,ge)~=1 then fZ(gd,ge)end;if fY(gf,gg)~=1 then fZ(gf,gg)end;if fY(gh,gi)~=1 then fZ(gh,gi)end;if fY(gj,gk)~=1 then fZ(gj,gk)end;if fY(gl,gm)~=1 then fZ(gl,gm)end end;if fY(gn,go)~=1 then fZ(gn,go)end;if fY(gp,gq)~=1 then fZ(gp,gq)end;if fY(gr,gs)~=1 then fZ(gr,gs)end end;g9=nil else g9=gc;for dU,dB in pairs(cx[0])do if dB.name==g9.planetname then c4=dB;be=g9.name;break end end;if fY(gn,go)~=1 then fZ(gn,go)end;if fY(gp,gq)~=1 then fZ(gp,gq)end end;if g9==nil then bf=vec3(c4.center)else bf=g9.position end;if c4.planetname~="Space"then if c4.hasAtmosphere then gt=bE(c4.radius*(S-1)+c4.noAtmosphericDensityAltitude)else gt=bE(c4.radius*(S-1)+c4.surfaceMaxAltitude)end else gt=R end;if g9~=nil and g9.planetname=="Space"then ba=0 else dU,ba=cA(c4):escapeAndOrbitalSpeed(gt)end;bc=0;b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"return true end;local function gu(gv)if not aZ and not bl and not ce and not bu and not b3 and not cf then if gv==nil then bg=bg+1;if bg>#d7 then bg=0 end else bg=bg-1;if bg<0 then bg=#d7 end end;if bg==0 then ga()else local gb=d7[bg].index;local gc=e[0][gb]if gc~=nil and gc.name=="Space"or bv=="Custom Only"and gc.center or bv=="No Moons"and string.find(gc.name,"Moon")~=nil then if gv==nil then gu()else gu(1)end else ga()end end else c0="Disengage autopilot before changing Interplanetary Helper"f_("iph","AP")end end;local function gw()local gx=-1;gx=g7(e[0])if gx>-1 then table.remove(e[0],gx)end;gx=-1;gx=g7(bk)if gx~=-1 then c0=g9.name.." saved location cleared"table.remove(bk,gx)end;gu()g3()end;local function gy(gz,g1,gA,gB)if dbHud_1 or gA then local e3=g0(g1)local gC=e3.gravity;if gB then gC=c.getClosestPlanetInfluence()end;local gD={position=g1,name=gz,planetname=e3.name,gravity=gC,safe=gB}if not gA then bk[#bk+1]=gD else for dP,dB in pairs(e[0])do if dB.name and gz==dB.name then table.remove(e[0],dP)end end end;table.insert(e[0],gD)g3()ga()c0="Location saved as "..gz.."("..e3.name..")"else c0="Databank must be installed to save permanent locations"end end;local gE={}function gE.UpdateAtlasLocationsList()g3()end;function gE.UpdateAutopilotTarget()ga()end;function gE.adjustAutopilotTargetIndex(gv)gu(gv)end;function gE.findAtlasIndex(g8)g7(g8)end;function gE.UpdatePosition(gF)local gx=g7(bk)if gx~=-1 then if gF~=nil then bk[gx].name=gF;bg=bg-1;gu()else local gG=bk[gx]gG.gravity=c.getClosestPlanetInfluence()gG.position=d0;gG.safe=true end;c0=bk[gx].name.." position updated ("..bk[gx].planetname..")"else c0="Name Not Found"end end;function gE.AddNewLocation(gz,g1,gA,gB)gy(gz,g1,gA,gB)end;function gE.ClearCurrentPosition()gw()end;for dP,dB in pairs(bk)do table.insert(e[0],dB)end;g3()if bg>#d7 then bg=0 end;gE.UpdateAutopilotTarget()return gE end;local function gH(b,a,c,library,radar_1,radar_2,f3,gI,ds,gJ,dr,gK,f_)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local gX;local gY=0;local function gZ()local function g_(h0,h1,h2,h3,h4,h5,h6,h7)h1,h3,h5,h7=vec3(h1),vec3(h3),vec3(h5),vec3(h7)local h8,h9,ha=h0*h0,h2*h2,h4*h4;local fD=h3-h1;local hb=fD:normalize()local hc=fD:len()local hd=h5-h1;local he=(hd-hd:project_on(hb)):normalize()local hf,hg=hd:dot(hb),hd:dot(he)local hh=hf*hf+hg*hg;local hi=hb:cross(he)local hj=(h8-h9+hc*hc)/(2*hc)local hk=(h8-ha+hh-2*hf*hj)/(2*hg)local dD=h8-hj^2-hk^2;local hl=ds(dD)local hm=h1+hb*hj+he*hk+hi*hl;local hn=h1+hb*hj+he*hk-hi*hl;if f3((h7-hm):len()-h6)<f3((h7-hn):len()-h6)then return hm else return hn end end;local function ho()local function hp()local hq=b.getConstructWorldOrientationRight()local fD=b.getConstructWorldOrientationForward()local hd=b.getConstructWorldOrientationUp()local hr=library.systemResolution3(hq,fD,hd,{1,0,0})local hs=library.systemResolution3(hq,fD,hd,{0,1,0})local ht=library.systemResolution3(hq,fD,hd,{0,0,1})return function(hu)return library.systemResolution3(hr,hs,ht,hu)end end;local hv=hp()local hw=b.getConstructWorldPos()local fB=b.getElementPositionById(1)local hx={fB[1],fB[2],fB[3]}local hy=hv(hx)local hz={hw[1]-hy[1],hw[2]-hy[2],hw[3]-hy[3]}return hz end;local function hA(hB,fE,hC)local hD=hB.pts;local gx=#hD;local hE=hB.ref;if gx>3 then local hF,hG,hH,hI=hD[gx],hD[gx-1],hD[gx-2],hD[gx-3]hB.ref=hC;local fB=g_(hF[1],hF[2],hG[1],hG[2],hH[1],hH[2],hI[1],hI[2])local hj,hk,hl=fB.x,fB.y,fB.z;if hj==hj and hk==hk and hl==hl then hj=hj+hE[1]hk=hk+hE[2]hl=hl+hE[3]local hJ=vec3(hj,hk,hl)if not hB.lastPos then hB.center=hJ elseif(hB.lastPos-hJ):len()<2 then hB.center=hJ;hB.skipCalc=true end;hB.lastPos=hJ end;hB.pts={}else local hK={hC[1]-hE[1],hC[2]-hE[2],hC[3]-hE[3]}hD[gx+1]={fE,hK}end end;if radar_1 or radar_2 then cE.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hL=gU[1].getData()local hM=hL:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hC=ho()local hN,hO=0,0;gT,gS=0,0;for dB in hM do local dZ,cb,hP=dB:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hQ=gN[hP]cb=dr(cb)if gU[1].hasMatchingTransponder(dZ)==1 then table.insert(gM,dZ)end;local hR=gU[1].getConstructType(dZ)if F then if hQ>27 or hR=="static"or hR=="space"then gT=gT+1;local gz=gU[1].getConstructName(dZ)local hB=db[dZ]if hB==nil then hQ=hQ+gK;db[dZ]={pts={},ref=hC,name=gz,i=0,radius=hQ,skipCalc=false}hB=db[dZ]end;if not hB.skipCalc then hA(hB,cb,hC)hO=hO+1 end;if hB.center then table.insert(gO,hB)end end;hN=hN+1;if dc and hN>700 or hO>70 or(not dc and hN>300 or hO>30)then coroutine.yield()hN,hO=0,0 end end end;gS=#gO;if gS>0 and cY>20 then local ex,hS,hT,hU;local hV=0;local hW=cx:getPlanetarySystem(0)hU=cX:normalize()while hV<gS do coroutine.yield()local hX={table.unpack(gO,hV,math.min(hV+75,gS))}ex,hS,hT=hW:castIntersections(d0,hU,nil,nil,hX,true)if ex and hT then de={ex,hS,hT}break end;hV=hV+75 end;if not ex then de=nil end else de=nil end;gO={}gQ=hL:find('identifiedConstructs":%[%]')else gR=hL:find('worksInEnvironment":false')end end end;local function hY()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hY()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hY()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hY()end end end;function gL.UpdateRadar()local hZ=coroutine.status(gW)if hZ=="suspended"then local dQ,h_=coroutine.resume(gW)if h_ then a.print("ERROR UPDATE RADAR: "..h_)end elseif hZ=="dead"then gW=coroutine.create(gZ)local dQ,h_=coroutine.resume(gW)end end;function gL.GetRadarHud(i0,i1,i2,i3)local i4=gM;local i5,i6;gM={}local dH=gS or 0;if gP>0 then if F then i6=dH.."/"..gT.." Plotted : "..gP-gT.." Ignored"else i6="Radar Contacts: "..gP end;i5=gJ(i2,i3,i6,"pbright txtbig txtmid")if#gM>0 then i5=i5 ..gJ(i0,i1,"Friendlies In Range","pbright txtbig txtmid")for dP,dB in pairs(gM)do i1=i1+20;i5=i5 ..gJ(i0,i1,gU[1].getConstructName(dB),"pdim txtmid")end end;if gQ==nil and gX==nil then gY=1;cE.ToggleRadarPanel()end;if gQ~=nil and gX~=nil then cE.ToggleRadarPanel()end;if i7==nil then cE.ToggleRadarPanel()end else if gR then i5=gJ(i2,i3,gV.." Radar: Jammed","pbright txtbig txtmid")else i5=gJ(i2,i3,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if i7~=nil then gY=0;cE.ToggleRadarPanel()end end;return i5 end;function gL.GetClosestName(gz)if gU[1]then local dZ,dU=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dZ~=nil and dZ~=""then gz=gz.." "..gU[1].getConstructName(dZ)end end;return gz end;function gL.ToggleRadarPanel()if i7~=nil and gY==0 then gI(i7)i7=nil;if gX~=nil then gI(gX)gX=nil end else if gY==1 then gI(i7)i7=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")gX=_autoconf.panels[_autoconf.panels_size]end;if i7==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")i7=_autoconf.panels[_autoconf.panels_size]end;gY=0 end end;function gL.ContactTick()if not i8 then i8=0 end;if bG>i8+10 then c0="Radar Contact"f_("rdrCon","RC")i8=bG end;c.stopTimer("contact")end;function gL.onEnter(dZ)if radar_1 and not ch and not d8 then c.setTimer("contact",0.1)end end;function gL.onLeave(dZ)if radar_1 and F then if#db>650 then dZ=tostring(dZ)db[dZ]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hY()end;gW=coroutine.create(gZ)return gL end;local function i9(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ia,warpdrive,f3,bE,dp,ib,bF,ic,id,eZ,bD,dq,ie,fZ,fY,gI,ig,ds,ih,gJ,f_,ii,ij,ik,il)local im=9.80665;local io={}local ip={}local iq={}local ir={}local is=nil;local it=nil;local iu=nil;local iv=false;local iw="none"local ix=""local iy=55;local iz=0;local iA=0;local iB=vec3({13771471,7435803,-128971})local iC=18000000;local iD=500000;local iE,iF=math.huge;local iG;local function iH(iI)iE=vec3(iI):dist(iB)if iE<iC then return true,f3(iE-iC)end;iF=vec3(iI):dist(vec3(iJ.center))if iF<iD then iG=true else iG=false end;if f3(iF-iD)<f3(iE-iC)then return iG,f3(iF-iD)else return iG,f3(iE-iC)end end;local function iK(dB)if cr==1920 then return dB else return ih(cr*dB/1920,0)end end;local function iL(dB)if cs==1080 then return dB else return ih(cs*dB/1080,0)end end;local function iM()return ig()==0 and g~="keyboard"and id()==0 end;local function iN()local iO="TRAVEL"if not d4 then iO="CRUISE"end;if aZ then iO="AUTOPILOT"end;return iO end;local i5=""local iP=""local iQ=""local iR=1;local iS=2;local iT=3;local iU=4;local iV=5;local iW=6;local iX=""local iY=0;local iZ=bE(1/aO)*2*aP;local i_={}local j0={}local j1={}local j2={}local j3={}local j4={}local j5={}j5["atmofueltank"],j5["spacefueltank"],j5["rocketfueltank"]=0,0,0;local j6=0;local function j7(hj,j8,j9,ja,jb,jc)local jd=j6;local je=j6+5;if not C then je=je+5 end;if id()==1 and not l then jd=jd-50;je=je-50 end;if j9=="ATMO"then iX="atmofueltank"elseif j9=="SPACE"then iX="spacefueltank"else iX="rocketfueltank"end;iY=_G[iX.."_size"]if#ja>0 then for K=1,#ja do local gz=string.sub(ja[K][iS],1,12)local jf=0;for jg=1,iY do if ja[K][iS]==ib(c[iX.."_"..jg].getData()).name then jf=jg;break end end;local jh=bD()if jb[K]==nil or jc[K]==nil or jh-ja[K][iW]>iZ then local ji;local jj=0;jj=ic(ja[K][iR])-ja[K][iU]ji=ja[K][iV]if ji>jj then ja[K][iW]=jh;j5[iX]=j5[iX]+ji-jj end;ja[K][iV]=jj;if jf~=0 then jc[K]=ib(c[iX.."_"..jf].getData()).percentage;jb[K]=ib(c[iX.."_"..jf].getData()).timeLeft;if jb[K]=="n/a"then jb[K]=0 end else jc[K]=bE(0.5+jj*100/ja[K][iT])if ji<=jj then jb[K]=0 else jb[K]=bE(0.5+jj/((ji-jj)/(jh-ja[K][iW])))end end end;if gz==j8 then gz=dp("%s %d",j9,K)end;if jf==0 then gz=gz.." *"end;local jk;if jb[K]==0 then jk=""else jk=il(jb[K])end;if jc[K]~=nil then local jl=bE(jc[K]*2.55)local jm=dp("rgb(%d,%d,%d)",255-jl,jl,0)local jn=""if jk~=""and jb[K]<120 or jc[K]<5 then jn="red "end;local jo=dp("rgb(%d,%d,%d)",dq(bE((255-jl)/2.55),50,100),dq(bE(jl/2.55),0,50),50)local jp="rgb(196,0,255)"if j9=="ATMO"then jp="rgb(0,188,255)"elseif j9=="SPACE"then jp="rgb(239,255,0)"end;local jq=false;if jr~=jp then jq=true end;jr=jp;if C then if jq then jd=jd-5;je=je-5 end;iP=iP..dp([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jo,jp,hj,je,jm,bE(jc[K]*1.7+0.5)-2,hj+1,je+1,hj+5,je+14,gz,jc[K],jk)jd=jd-22;je=je-22 else iP=iP..gJ(hj,jd,gz,jn.."pdim txtfuel")iP=iP..gJ(hj,je,dp("%d%% %s",jc[K],jk),"pdim txtfuel","fill:"..jm)jd=jd+30;je=je+30 end end end end;j6=jd end;local function js(jt,e8)if al==0 and am==0 then return end;if e8<200000 and not ch or e8 and ch then local ju=0;if f3(c_)>1 then ju=45*math.log(f3(c_),10)if c_<0 then ju=-ju end end;jt[#jt+1]=dp([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],al,am,bE(c_),bE(ju))end;return jt end;local function jv(jw)local gv=-cZ;jw=jw-jw:project_on(gv)local jx=vec3(0,0,1)jx=jx-jx:project_on(gv)local jy=jx:cross(gv)local ju=jx:angle_between(jw)*constants.rad2deg;if jw:dot(jy)<0 then ju=360-ju end;return ju end;local function jz(jt,ah,ai,jA,jB,dc)if aa==0 then return end;local jC=aa;local jD=20;local jE=bE(jA)if dc then for K=-45,45,5 do local jF=K;jt[#jt+1]=dp([[<g transform="rotate(%f,%d,%d)">]],jF,ah,ai)jG=5;if K%15==0 then jG=15 elseif K%10==0 then jG=10 end;jt[#jt+1]=dp([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ah,ai+jC+jD-jG,ah,ai+jC+jD)end;jt[#jt+1]=gJ(ah,ai+jC+jD-35,jB,"pdim txt txtmid")jt[#jt+1]=gJ(ah,ai+jC+jD-25,jE.." deg","pdim txt txtmid")jt[#jt+1]=dp([[<g transform="rotate(%f,%d,%d)">]],-jA,ah,ai)jt[#jt+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ah-5,ai+jC+jD-20,ah+5,ai+jC+jD-20,ah,ai+jC+jD-15)jt[#jt+1]="</g>"end;jt[#jt+1]=[[<g style="clip-path: url(#headingClip);">]]local jH=jE;if dc then jH=jv(cU)end;local jI=20;local jJ=bE(jH)local jK=0;local jL=ai+jC+jD+20;local jM=ah;if jB~="YAW"then jL=iL(130)jM=iK(960)end;local jN=[[<path class="txttick line" d="]]local jO=bE(jJ-(jI+10)-jJ%5+0.5)for K=jO+70,jO,-5 do local hj=jM-(-K*5+jH*5)if K%10==0 then jK=10;local dH=K;if dH==360 then dH=0 elseif dH>360 then dH=dH-360 elseif dH<0 then dH=dH+360 end;jt[#jt+1]=gJ(hj,jL+15,dH,"txtmid bright")elseif K%5==0 then jK=5 end;if jK==10 then jN=dp([[%s M %f %f v %d]],jN,hj,jL-5,jK)else jN=dp([[%s M %f %f v %d]],jN,hj,jL-2.5,jK)end end;jt[#jt+1]=jN..[["/>]]jt[#jt+1]=dp([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jM-5,jL-20,jM+5,jL-20,jM,jL-10)if I then if dc then jB="HDG"end;jt[#jt+1]=gJ(iK(960),iL(100),jJ.."°","dim txt txtmid size14","")jt[#jt+1]=gJ(iK(960),iL(85),jB,"dim txt txtmid size20","")end;jt[#jt+1]=[[</g>]]end;local function jP(jt,jQ,jA,ah,ai,dc,jR,fv)if aa==0 then return end;local jC=aa;local jS=bE(jC*3/5)if jC>0 then local jT=bE(jQ)local jG=0;local jN=dp([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jA,ah,ai)if not ch then jN=dp([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ah,ai)end;jt[#jt+1]=dp([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jC-1,ah,ai)jt[#jt+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bE(jT-30-jT%5+0.5),bE(jT+30+jT%5+0.5),5 do if K%10==0 then jG=30 elseif K%5==0 then jG=20 end;local hk=ai+-K*5+jQ*5;if jG==30 then jN=dp([[%s M %d %f h %d]],jN,ah-jS-jG,hk,jG)if ch then jt[#jt+1]=dp([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jA,ah,ai,ah-jS+10,hk+4,K)jt[#jt+1]=dp([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jA,ah,ai,ah+jS-10,hk+4,K)if K==0 or K==180 or K==-180 then jt[#jt+1]=dp([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jA,ah,ai,ah-jS+20,hk,jS*2-40)end else jt[#jt+1]=gJ(ah-jS+10,hk,K,"pdim txt txtmid")jt[#jt+1]=gJ(ah+jS-10,hk,K,"pdim txt txtmid")end;jN=dp([[%s M %d %f h %d]],jN,ah+jS,hk,jG)else jN=dp([[%s M %d %f h %d]],jN,ah-jS-jG,hk,jG)jN=dp([[%s M %d %f h %d]],jN,ah+jS,hk,jG)end end;jt[#jt+1]=jN..[["/>]]local jU="PITCH"if not dc then jU="REL PITCH"end;if jQ>90 and not ch then jQ=90-(jQ-90)elseif jQ<-90 and not ch then jQ=-90-(jQ+90)end;if jC>200 then if ch then if fv>iy then jt[#jt+1]=gJ(ah,ai-15,"Yaw","pdim txt txtmid")jt[#jt+1]=gJ(ah,ai+20,jR,"pdim txt txtmid")end;jt[#jt+1]=dp([[<g transform="rotate(%f,%d,%d)">]],-jA,ah,ai)else jt[#jt+1]=dp([[<g transform="rotate(0,%d,%d)">]],ah,ai)end;jt[#jt+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah-jS+25,ai-5,ah-jS+20,ai,ah-jS+25,ai+5,ah-jS+50,ai+4,jT)jt[#jt+1]=dp([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ah+jS-25,ai-5,ah+jS-20,ai,ah+jS-25,ai+5,ah+jS-30,ai+4,jT)jt[#jt+1]="</g>"end;local jV=bE(jC/3)jt[#jt+1]=dp([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ah-jV,ai,jC-jV)if not ch and dc then jt[#jt+1]=dp([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jA,ah,ai,ah-jS+10,ai,jS*2-20)end;jt[#jt+1]="</g>"if jC<200 then if ch and fv>iy then jt[#jt+1]=gJ(ah,ai-jC,jU,"pdim txt txtmid")jt[#jt+1]=gJ(ah,ai-jC+10,jT,"pdim txt txtmid")jt[#jt+1]=gJ(ah,ai-15,"Yaw","pdim txt txtmid")jt[#jt+1]=gJ(ah,ai+20,jR,"pdim txt txtmid")else jt[#jt+1]=gJ(ah,ai-jC,jU,"pdim txt txtmid")jt[#jt+1]=gJ(ah,ai-jC+15,jT,"pdim txt txtmid")end end end end;local function jW(jt,e8,dc)local jX=an;local jY=ao;if jX==0 and jY==0 then return end;local jZ=78;local j_=19;local k0=cg;if cg~=-1 then jt[#jt+1]=gJ(jX+jZ,jY+j_+20,dp("AGL: %.1fm",cg),"pdim altsm txtend")end;if dc and(e8<200000 and not ch or e8 and ch)then table.insert(jt,dp([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],jX-1,jY-4,jZ+2,j_+6,jX+1,jY-1,jZ-4,j_))local gx=0;local k1=1;local k2=0;local k3=e8<0;local k4=e8<iJ.surfaceMaxAltitude;local k5=9;if k3 then k5=0 end;local e8=f3(e8)while gx<6 do local k6=11;local k7=16;local k8=9;local k9=14;local jn="altsm"if gx>2 then k7=k7+3;k6=k6+2;k9=k9+2;k8=k8-6;jn="altbig"end;if k3 then jn=jn.." red"elseif k4 then jn=jn.." orange"end;local ka=e8/k1%10;local kb=bE(ka)local kc=bE((kb+1)%10)local kd=k2;if gx==0 then kd=ka-kb;if k3 then kd=1-kd end end;if k3 and(gx==0 or k2~=0)then local gA=kc;kc=kb;kb=gA end;local ke=k7*(kd-1)local kf=ke+k7;local hj=jX+k8+(6-gx)*k6;local hk=jY+k9;jt[#jt+1]=gJ(hj,hk+ke,kc,jn)jt[#jt+1]=gJ(hj,hk+kf,kb,jn)gx=gx+1;k1=k1*10;if kb==k5 then k2=kd else k2=0 end end;table.insert(jt,[[</g></g>]])end end;local function kg(fA)local kh=-math.deg(eZ(fA.y,fA.z))+180;kh=kh-90;if kh<0 then kh=360+kh end;if kh>180 then kh=-180+kh-180 end;return-kh end;local function ki(fA)local jH=math.deg(eZ(fA.y,fA.x))-90;if jH<-180 then jH=360+jH end;return jH end;local function kj(jt,fA,fv,ah,ai)if fv>5 and not ch or fv>iy then local jC=aa;local kk=20;local kl=20;local km=kg(fA)local kn=ki(fA)local ko=14;local kp=ko/2;local kq=-kn/kl*jC;local kr=km/kk*jC;local hj=ah+kq;local hk=ai+kr;local cb=ds(kq^2+kr^2)local ks=[[<circle
                            cx="]]..hj..[["
                            cy="]]..hk..[["
                            r="]]..kp/ko..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hj..[["
                            cy="]]..hk..[["
                            r="]]..kp..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hj-ko..[[,]]..hk..[[ h ]]..kp..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hj+kp..[[,]]..hk..[[ h ]]..kp..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hj..[[,]]..hk-ko..[[ v ]]..kp..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cb<jC then jt[#jt+1]=ks else local ju=eZ(kr,kq)local kt=4;local ku=ah+jC*math.cos(ju)local kv=ai+jC*math.sin(ju)jt[#jt+1]=dp('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',ju*180/math.pi,ku,kv,ku-kt,kv-kt/2,kt*2,kt,ku+kt,kv-kt,kt,kt,-kt,kt)end;if not ch then local kw=vec3(fA)km=kg(-kw)kn=ki(-kw)kq=-kn/kl*jC;kr=km/kk*jC;hj=ah+kq;hk=ai+kr;cb=ds(kq^2+kr^2)if cb<jC then local kx=[[<circle
                                    cx="]]..hj..[["
                                    cy="]]..hk..[["
                                    r="]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hj..[[,]]..hk-ko..[[ v ]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hj..[[,]]..hk..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hj..[[,]]..hk..[[)" />
                                <path
                                    d="M ]]..hj-kp..[[,]]..hk..[[ h ]]..ko..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hj..[[,]]..hk..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hj..[[,]]..hk..[[)"/>]]jt[#jt+1]=kx end end end end;local function ky(jt,iO,kz,kA)if aj==0 and ak==0 then return end;kz=bE(kz+0.5)local jd=ak+10;local je=ak+20;if id()==1 and not l then jd=55;je=65 end;local kB="CRUISE"local c="km/h"local dQ=kA;if iO=="TRAVEL"or iO=="AUTOPILOT"then kB="THROT"c="%"dQ=kz;local kC="dim"if kz<0 then kC="red"end;jt[#jt+1]=dp([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kC,aj-7,ak-50,aj,ak-50,aj,ak+50,aj-7,ak+50,1-f3(kz),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)end;jt[#jt+1]=gJ(aj+10,jd,kB,"pbright txtstart")jt[#jt+1]=gJ(aj+10,je,dp("%.0f %s",dQ,c),"pbright txtstart")if ch and u and d4 and bM then kz=bE(bN*100+0.5)local kC="red"if kz<0 then kC="red"end;jt[#jt+1]=dp([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kC,1-f3(kz),aj-10,ak+50,aj-15,ak+53,aj-15,ak+47)jt[#jt+1]=gJ(aj+10,jd+40,"LIMIT","pbright txtstart")jt[#jt+1]=gJ(aj+10,je+40,kz.."%","pbright txtstart")end;if ch and u or b3 then jt[#jt+1]=gJ(aj+10,jd-40,"LIMIT: "..cL.." km/h","dim txtstart")elseif not ch and aZ then jt[#jt+1]=gJ(aj+10,jd-40,"LIMIT: "..bE(_*3.6+0.5).." km/h","dim txtstart")end end;local function kD(jt,kE)if aj==0 and ak==0 then return end;local kF=ak-10;local kG=aj+10;jt[#jt+1]=gJ(0,0,"","pdim txt txtend")if id()==1 and not l then kF=75 end;jt[#jt+1]=gJ(kG,kF,bE(kE).." km/h","pbright txtbig txtstart")end;local function kH(jt)jt[#jt+1]=gJ(iK(1900),iL(1070),dp("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jt[#jt+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jt[#jt+1]=gJ(iK(960),iL(550),"Warning: Invalid Control Scheme Detected","warnings")jt[#jt+1]=gJ(iK(960),iL(600),"Keyboard Scheme must be selected","warnings")jt[#jt+1]=gJ(iK(960),iL(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kI=iK(960)local kJ=iL(860)local kK=iL(880)local kL=iL(900)local kM=iL(960)local kN=iL(200)local kO=iL(250)local kP=iL(960)if id()==1 and not l then kJ=iL(135)kK=iL(155)kL=iL(175)kN=iL(115)kO=iL(95)end;local kQ="#222222"local kR="white"local kS="dimmer"local kT="pbright"local kU="#110000"local kV=kQ;local kW=kS;if aW then jt[#jt+1]=gJ(kI,kJ,"Brake Engaged","warnings")kU="#440000"kV=kR;kW=kT elseif bL>0 then jt[#jt+1]=gJ(kI,kJ,"Auto-Brake Engaged","warnings","opacity:"..bL)end;local kX="#110000"local kY=kQ;local kZ=kS;if ch and cJ and cg==-1 then if not aZ and not bl and not b1 and not d2 and not b4 and not b2 then jt[#jt+1]=gJ(kI,kN+50,"** STALL WARNING **","warnings")kX="#ff0000"kY=kR;kZ=kT;f_("stall","SW",2)end end;if da then jt[#jt+1]=gJ(kI,kN+90,"Flight Assist in Progress","warnings")end;if cn then jt[#jt+1]=gJ(kI,kP,"Gyro Enabled","warnings")end;local k_="#111100"local l0=kQ;local l1=kS;if bh then k_="#775500"l0=kR;l1=kT;if bR then jt[#jt+1]=gJ(kI,kK,"Gear Extended","warn")else jt[#jt+1]=gJ(kI,kK,"Landed (G: Takeoff)","warnings")end;local l2=ik(d:getTargetGroundAltitude())jt[#jt+1]=gJ(kI,kL,"Hover Height: "..l2,"warn")end;local l3="#000011"local l4=kQ;local l5=kS;if c1 then l3="#0000DD"l4=kR;l5=kT;jt[#jt+1]=gJ(kI,kM+20,"ROCKET BOOST ENABLED","warn")end;local l6="#001100"local l7=kQ;local l8=kS;if antigrav and not q and d2 and bq~=nil then l6="#00DD00"l7=kR;l8=kT;if f3(cj-antigrav.getBaseAltitude())<501 then jt[#jt+1]=gJ(kI,kN+15,dp("Target Altitude: %d Singularity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warn")else jt[#jt+1]=gJ(kI,kN+15,dp("Target Altitude: %d Singluarity Altitude: %d",bE(bq),bE(antigrav.getBaseAltitude())),"warnings")end elseif aZ and be~="None"then jt[#jt+1]=gJ(kI,kN+20,"Autopilot "..bb,"warn")elseif bo~=nil then jt[#jt+1]=gJ(kI,kN+20,dp("LockedPitch: %d",bE(bo)),"warn")elseif bZ then jt[#jt+1]=gJ(kI,kN+20,"Follow Mode Engaged","warn")elseif b3 or cf then jt[#jt+1]=gJ(kI,kN+20,"Re-entry in Progress","warn")end;if b0 or b4 then local l2=ik(b5,2)if b4 then if d2 then l2=ik(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jt[#jt+1]=gJ(kI,kN,"VTO to "..l2,"warn")elseif b2 and not bu then if ce then jt[#jt+1]=gJ(kI,kN,"Takeoff to "..be,"warn")else jt[#jt+1]=gJ(kI,kN,"Takeoff to "..l2,"warn")end;if aW and not b4 then jt[#jt+1]=gJ(kI,kN+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jt[#jt+1]=gJ(kI,kN,"Altitude Hold: "..l2,"warn")end end;if b4 and(antigrav~=nil and antigrav)then if ci>0.1 then jt[#jt+1]=gJ(kI,kN+20,"Beginning ascent","warn")elseif ci<0.09 and ci>0.05 then jt[#jt+1]=gJ(kI,kN+20,"Aligning trajectory","warn")elseif ci<0.05 then jt[#jt+1]=gJ(kI,kN+20,"Leaving atmosphere","warn")end end;if bu then if cN~=nil then jt[#jt+1]=gJ(kI,kN,cN,"warn")end end;if b1 then if l9 then jt[#jt+1]=gJ(kI,kN,"Brake-Landing","warnings")else jt[#jt+1]=gJ(kI,kN,"Coast-Landing","warnings")end end;if aY then jt[#jt+1]=gJ(kI,kN,"Prograde Alignment","crit")end;if aX then jt[#jt+1]=gJ(kI,kN,"Retrograde Alignment","crit")end;local la="#110000"local lb=kQ;local lc=kS;if dd then la="#FF0000"lb=kR;lc=kT;local type;if string.find(dd,"COLLISION")then type="warnings"else type="crit"end;jt[#jt+1]=gJ(kI,kO+20,dd,type)elseif ci==0 then local ld,le=cD.checkLOS(cX:normalize())if le~=nil then lc=kT;la="#FF0000"lb=kR;local l2=ik(le)local lf=cy.computeTravelTime(cY,0,le)local lg="Collision"if ld.noAtmosphericDensityAltitude>0 then lg="Atmosphere"end;jt[#jt+1]=gJ(kI,kO+20,ld.name.." "..lg.." "..il(lf).." In "..l2,"crit")end end;if bl and not bu then jt[#jt+1]=gJ(kI,kN+35,lh,"warn")end;local li="#111100"local lj=kQ;local lk=kS;if dh and#dh>1 then li="#DDDD00"lj=kR;lk=kT end;local ll=iK;local lm=iL;local kS="topButton"local ln="topButtonActive"local lo=kS;if aZ or bl or ce or bu then lo=ln end;local lp=kS;if aY then lp=ln end;local lq=kS;if b1 or bh then lq=ln end;local lr=kS;if b0 or bl then lr=ln end;local ls=kS;if aX then ls=ln end;local lt=kS;if bu or cQ and aZ then lt=ln end;if x and I then local lu=lm(30)jt[#jt+1]=dp([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lo,ll(960),lm(54),lm(-53),ll(-120),ll(25),lm(50))jt[#jt+1]=gJ(ll(910),lu,"AUTOPILOT")jt[#jt+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lp,ll(865),lm(51),ll(-25),lm(-50),ll(-110),ll(25),lm(46))jt[#jt+1]=gJ(ll(800),lu,"PROGRADE")jt[#jt+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lq,ll(755),lm(47),ll(-25),lm(-46),ll(-98),ll(44),lm(44))jt[#jt+1]=gJ(ll(700),lu,"LAND")jt[#jt+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lr,ll(960),lm(54),lm(-53),ll(120),ll(-25),lm(50))jt[#jt+1]=gJ(ll(1010),lu,"ALT HOLD")jt[#jt+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ls,ll(1055),lm(51),ll(25),lm(-50),ll(110),ll(-25),lm(46))jt[#jt+1]=gJ(ll(1122),lu,"RETROGRADE")jt[#jt+1]=dp([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lt,ll(1165),lm(47),ll(25),lm(-46),ll(98),ll(-44),lm(44))jt[#jt+1]=gJ(ll(1220),lu,"ORBIT")jt[#jt+1]=[[
                                    </g>
                                </g>]]jt[#jt+1]="</g>"end;return jt end;local function lv(fv)return bE(ih(fv*3.6,0)+0.5).." km/h"end;local function lw(gx)local gz=be;if gx~=nil and type(gx)=="number"then if gx==0 then return"None"end;gz=d7[gx].name end;if gz==nil then gz=g9.name end;if gz==nil then gz="None"end;return gz end;local function lx(jt)local ly=cD.routeWP(true)if not ly or#ly==0 then return end;local hj=iK(750)local hk=iL(360)if aZ or bl then jt[#jt+1]=gJ(hj,hk,"REMAINING ROUTE","pdim txtstart size20")else jt[#jt+1]=gJ(hj,hk,"LOADED ROUTE","pdim txtstart size20")end;for dP,K in pairs(ly)do hk=hk+20;jt[#jt+1]=gJ(hj,hk,dP..". "..lw(ly[dP]),"pdim txtstart size20")end end;local function lz(jt)local hj=av+10;local hk=aw+20;local lA={}local lB={"Alt-4: AutoTakeoff to Target"}local lC={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lD={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lE={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lA,"--------------DYNAMIC-----------------")if ch then if cg~=-1 then ii(lA,lB)if c4 and iJ and c4.name==iJ.name then table.insert(lA,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aV then if antigrav then if d2 then table.insert(lA,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lA,"Turn on AGG to takeoff to AGG Height")end end;if aV then table.insert(lA,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lA,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lA,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bh then table.insert(lA,"G: Takeoff to hover height, raise gear")else table.insert(lA,"G: Lowergear and Land")end else ii(lA,lC)table.insert(lA,"G: Begin BrakeLanding or Land")end;if b4 then table.insert(lA,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ii(lA,lD)if ia then table.insert(lA,"Alt-Shift-6: Vent shields")table.insert(lA,"Alt-Shift-7: Toggle shied off/on")end end;if g9~=nil then table.insert(lA,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lA,"Alt-9: Activate Gyroscope")end;if aR~="none"or aQ~="none"or aS~="none"then table.insert(lA,"Alt-Shift-9: Cycles engines with Extra tags")end;if b0 then table.insert(lA,"Alt-Spacebar/C will raise/lower target height")table.insert(lA,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ch then table.insert(lA,"LALT+Mousewheel will lower/raise speed limit")end;ii(lA,lE)for K=1,#lA do hk=hk+12;jt[#jt+1]=gJ(hj,hk,lA[K],"pdim txtbig txtstart")end end;local function lF(jt)local lG=av;local lH=aw;local lI=au;local lJ=4;local lK=15;local hj=0;local hk=0;local lL,lM,lN,lO;local lP;local function lQ(type)local lR,bG,fv,lS,jn,lT;if type=="Periapsis"then lR=lP.periapsis.altitude;bG=lP.timeToPeriapsis;fv=lP.periapsis.speed;jn="txtend"lS=12;lT=math.min(hj,lG+lI-iJ.radius/lN-lJ*2)else lR=lP.apoapsis.altitude;bG=lP.timeToApoapsis;fv=lP.apoapsis.speed;lS=-12;jn="txtstart"lT=hj end;if cY<1 then bG=0 end;jt[#jt+1]=dp([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lT+lS,hk-5,hj,hk-5)jt[#jt+1]=dp([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lT-lS*4,hk+2,hj,hk+2)jt[#jt+1]=gJ(lT,hk,type,jn)hj=lT-lS*2;hk=hk+lK;local l2=ik(lR)jt[#jt+1]=gJ(hj,hk,l2,jn)hk=hk+lK;jt[#jt+1]=gJ(hj,hk,il(bG),jn)hk=hk+lK;jt[#jt+1]=gJ(hj,hk,lv(fv),jn)end;local lU=lI*1.5;if bB=="INFO"then lU=25*9 end;if bB~="HIDE"then jt[#jt+1]=[[<g class="pbright txtorb txtmid">]]jt[#jt+1]=dp('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lI*2,lU,lG,lH)jt[#jt+1]=dp([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lI*2,lU,lG,lH)end;local lV=lI*1.5;local lW=lI*2;local lX=lV/2;local lY=lI;local lZ=lG+lY;local l_=lH+lX;local m0=lG+lW;local m1=lH+lV;if bB=="ORBIT"then lH=lH+lJ;lL=lI/2;lO=0;lP={}lP.periapsis={}lP.apoapsis={}if fz~=nil then if fz.periapsis~=nil then lP.periapsis.altitude=fz.periapsis.altitude;lP.periapsis.speed=fz.periapsis.speed end;if fz.apoapsis~=nil then lP.apoapsis.altitude=fz.apoapsis.altitude;lP.apoapsis.speed=fz.apoapsis.speed end;lP.period=fz.period;lP.eccentricity=fz.eccentricity;lP.timeToApoapsis=fz.timeToApoapsis;lP.timeToPeriapsis=fz.timeToPeriapsis;lP.eccentricAnomaly=fz.eccentricAnomaly;lP.trueAnomaly=fz.trueAnomaly end;if lP.periapsis==nil then lP.periapsis={}lP.periapsis.altitude=-iJ.radius;lP.periapsis.speed=_ end;if lP.eccentricity==nil then lP.eccentricity=1 end;if lP.apoapsis==nil then lP.apoapsis={}lP.apoapsis.altitude=cj;lP.apoapsis.speed=0 end;if cY<1 then lP.apoapsis.altitude=cj;lP.apoapsis.speed=0 end;if lP.apoapsis.altitude then lN=(lP.apoapsis.altitude+lP.periapsis.altitude+iJ.radius*2)/(lL*2)lM=(iJ.radius+lP.apoapsis.altitude)/lN*(1-lP.eccentricity)lO=lL-lP.periapsis.altitude/lN-iJ.radius/lN;local m2=math.pi;if lP.period~=nil and lP.period>0 and lP.timeToApoapsis~=nil then m2=lP.eccentricAnomaly;if lP.timeToPeriapsis<lP.timeToApoapsis then m2=2*math.pi-m2 end end;if cY<1 or m2~=m2 then m2=math.pi end;local m3=-lL*math.cos(m2)+lG+lY+lJ;local m4=lM*math.sin(m2)+lH+lX+lJ;local m5=""jt[#jt+1]='<g clip-path="url(#orbitRect)">'jt[#jt+1]=dp([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],m5,lG+lI+lJ,lH+lI*1.5/2+lJ,lL,lM)if lM<1 then jt[#jt+1]=dp([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lG+lI+lJ-lO,lH+lI*1.5/2+lJ,m3,m4)end;jt[#jt+1]=dp('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lG+lI+lJ-lO,lH+lI*1.5/2+lJ,(iJ.radius+iJ.noAtmosphericDensityAltitude)/lN)jt[#jt+1]=dp('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lG+lI+lJ-lO,lH+lI*1.5/2+lJ,(iJ.radius+iJ.noAtmosphericDensityAltitude)/lN)jt[#jt+1]=dp([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lG+lI+lJ,lH+lI*1.5/2+lJ,lL,lM)jt[#jt+1]=dp('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lG+lI+lJ-lO,lH+lI*1.5/2+lJ,iJ.radius/lN)jt[#jt+1]='</g>'local m6=math.floor(iJ.radius/lN+0.5)hj=lG+lI+lJ*4+lL;hk=lH+lI*1.5/2+5+lJ;if lP.apoapsis~=nil and lP.apoapsis.speed<_ then lQ("Apoapsis")end;hk=lH+lI*1.5/2+5+lJ;hj=lG+lI-lJ*2-lL;if lP.periapsis~=nil and lP.periapsis.speed<_ and lP.periapsis.altitude>0 then lQ("Periapsis")end;jt[#jt+1]=gJ(lG+lI+lJ,lH+20+lJ,iJ.name,"txtorbbig")jt[#jt+1]=dp('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m3,m4)jt[#jt+1]=[[</g>]]return jt else jt[#jt+1]='<g clip-path="url(#orbitRect)">'local m7=""local m8=1.2*(m9-ma)/(lI*2)local mb=1.4*(mc-md)/(lI*1.5)for dP,dB in pairs(e[0])do if dB.center then local hj=lG+lI+dB.center.x/m8;local hk=lH+lI*1.5/2+dB.center.y/mb;m7=m7 ..'<circle cx="'..hj..'" cy="'..hk..'" r="'..dB.radius/m8*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dB.name,"Moon")and not string.match(dB.name,"Sanctuary")and not string.match(dB.name,"Space")then m7=m7 .."<text x='"..hj.."' y='"..hk+dB.radius/m8*30+20 .."' font-size='12' fill="..co.." text-anchor='middle' font-family='Montserrat'>"..dB.name.."</text>"end end end;local fB=vec3(b.getConstructWorldPos())local hj=lG+lI+fB.x/m8;local hk=lH+lI*1.5/2+fB.y/mb;m7=m7 ..'<circle cx="'..hj..'" cy="'..hk..'" r="2" stroke="white" stroke-width="1" fill="red"/>'m7=m7 .."<text x='"..hj.."' y='"..hk-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"is=m8;it=mb;local me=fB+cX*1000000;local mf=lG+lI+me.x/m8;local je=lH+lI*1.5/2+me.y/mb;m7=m7 ..'<line x1="'..hj..'" y1="'..hk..'" x2="'..mf..'" y2="'..je..'" stroke="purple" stroke-width="1"/>'jt[#jt+1]=m7;jt[#jt+1]='</g>'end elseif bB=="INFO"then jt=cB.DrawOdometer(jt,c5,bi,c6)elseif bB=="HELP"then jt=lz(jt)elseif bB=="SCOPE"then jt[#jt+1]='<g clip-path="url(#orbitRect)">'local mg=dk;if ci>0 then table.sort(dj,function(eF,eG)local eH,eI=eF.center,eG.center;return(eH.x-d0.x)^2+(eH.y-d0.y)^2+(eH.z-d0.z)^2<(eI.x-d0.x)^2+(eI.y-d0.y)^2+(eI.z-d0.z)^2 end)end;local gR={}local mh={}local mi=120;local mj=nil;local mk=nil;for K,dB in ipairs(dj)do local gQ=dB.center-d0;local ml=gQ:len()local mm=gQ:normalize()local mn=gQ:cross(cU):normalize()local mo=math.acos(mn:dot(cV))if mo~=mo then mo=0 end;if mn:cross(cV):dot(cU)<0 then mo=-mo end;local mp=gQ:project_on_plane(cU):len()local mq=math.sin(mo)*math.asin(mp/ml)*constants.rad2deg;local mr=math.cos(mo)*math.asin(mp/ml)*constants.rad2deg;if mm:dot(cU)<0 then mr=90*math.cos(mo)+90*math.cos(mo)-mr;mq=90*math.sin(mo)+90*math.sin(mo)-mq end;local hj=lZ+mq/mg*lV;local hk=l_+mr/mg*lV;local ms=(hj-lZ)*(hj-lZ)+(hk-l_)*(hk-l_)local mt=math.asin((dB.radius+dB.surfaceMaxAltitude)/ml)*constants.rad2deg;if mt~=mt then mt=mg end;local hP=mt/mg*lV;local mu=math.asin(dB.atmosphereRadius/ml)*constants.rad2deg;if mu~=mu then mu=mt end;local mv=mu/mg*lV;local cb=ik(ml,1)local mw=dB.name;local mx=false;if hk>lH then if hk>m1 then if hk-mv<=m1 then mx=true end else mx=true end else if hk+mv>=lH then mx=true end end;local my=false;local mz=hj;if dB.systemId==0 then mz=hj+mi else mz=hj-mi end;if mz+mi>lG then if mz+mi>m0 then if mz-mv-mi<=m0 then my=true end else my=true end else if mz+mv+mi>=lG then my=true end end;local mA={}mA.x=hj;mA.y=hk;mA.planet=dB;mA.atmoSize=mv;if not mj or ms<mj then mj=ms;mk=mA end;if my and mx then local mB=math.max(mv,5)if ms<mB*mB then mw=mw.." - "..cb end;mA.size=hP;mA.i=K;mA.displayString=mw;mA.distance=cb;mA.visible=true;mh[#mh+1]=mA else mA.visible=false end end;local mC=false;table.sort(mh,function(eH,eI)return eH.y<eI.y end)for dP,fE in ipairs(mh)do local dB,hP,K,mv,hj,hk,mw,cb=fE.planet,fE.size,fE.i,fE.atmoSize,fE.x,fE.y,fE.displayString,fE.distance;local lT,mD,mE,mF;local mG=15;local jn="pdim"if dB.systemId~=0 then mE=iK(string.len(mw)*5)mG=-(15+mE)mF=iL(10)jn="pdimfill"else mE=iK(string.len(mw)*9)mF=iL(15)end;if hP*2>mE then lT=dq(hj,lG+mE/2,m0-mE/2)mD=dq(hk,lH+mF,m1-5)lT=dq(lT,hj-hP+mE/2,hj+hP-mE/2)mD=dq(mD,hk-hP+mF,hk+hP)else lT=hj+mG;mD=hk end;for mH,fE in pairs(gR)do local mI=fE.textPositions;local mJ=mI.y-mD;if mH~=K and f3(mJ)<mI.height and mI.x+mI.width>lT and mI.x<lT+mE then if hP>mE then mD=dq(mD+mF,lH+15,m1-5)else mD=mI.y+mI.height+1 end end end;local mK=mw~=dB.name or lT<=lZ and lT+mE>=lZ and mD-mF<=l_ and mD>=l_;fE.hovered=mK;local mL=1;if mK then mL=2;if hP*2<mE then mL=10 end;if mw==dB.name then mw=mw.." - "..cb end;jn="pbright"if dB.systemId~=0 then mE=iK(string.len(mw)*5)mG=-(15+mE)else mE=iK(string.len(mw)*7)end;if hP*2>mE then lT=dq(hj,lG+mE/2,m0-mE/2)lT=dq(lT,hj-hP+mE/2,hj+hP-mE/2)else lT=hj+mG end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=mD;gR[K].textPositions.x=lT;gR[K].textPositions.width=mE;gR[K].textPositions.height=mF;gR[K].output=""if hP*2>mE then jn=jn.." txtmid"else jn=jn.." txtstart"end;if mv-hP>2 then gR[K].output=dp('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hj,hk,mv,cp,0.1*mL)end;gR[K].output=gR[K].output..dp('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hj,hk,hP,cp,0.2*mL)if dB.systemId==0 then gR[K].output=gR[K].output..dp([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lT,mD,co,jn,mw)if hP*2<=mE then gR[K].output=gR[K].output..dp("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lT+mE,mD+2,lT,mD+2,hj,hk)end else gR[K].output=gR[K].output..dp([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lT,mD,cp,jn,mw)if hP*2<=mE then gR[K].output=gR[K].output..dp("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lT,mD+2,lT+mE,mD+2,hj,hk)end end end;for dP=#dj,1,-1 do if gR[dP]then jt[#jt+1]=gR[dP].output end end;if mk~=nil and dk<90 and not mk.hovered then local mM=mk.planet.atmosphereRadius/mk.atmoSize;local mN=ds(mj)*mM;local mO=ik(mN,1)local mE=iK(math.max(string.len(mO)*7,string.len(mk.planet.name)*7))local mF=iL(12)local lT=dq(mk.x+(lZ-mk.x)/2,lG+mE/2,m0-mE/2)local mD=dq(mk.y+(l_-mk.y)/2,lH+mF*2,m1-5)jt[#jt+1]=dp("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mk.x,mk.y,lZ,l_)jt[#jt+1]=dp([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lT,mD,"white",mO)if not mk.visible then jt[#jt+1]=dp([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lT,mD-mF,"white",mk.planet.name)end end;if cY>1 then local gQ=cX;local mm=gQ:normalize()local mp=gQ:project_on_plane(cU):len()local mn=gQ:cross(cU):normalize()local mo=math.acos(mn:dot(cV))if mo~=mo then mo=0 end;if mn:cross(cV):dot(cU)<0 then mo=-mo end;local mq=math.sin(mo)*math.asin(mp/gQ:len())*constants.rad2deg;local mr=math.cos(mo)*math.asin(mp/gQ:len())*constants.rad2deg;if mm:dot(cU)<0 then mr=90*math.cos(mo)+90*math.cos(mo)-mr;mq=90*math.sin(mo)+90*math.sin(mo)-mq end;local hj=lZ+mq/mg*lV;local hk=l_+mr/mg*lV;local ko=14;local kp=ko/2;local ks=[[<circle
                                    cx="]]..hj..[["
                                    cy="]]..hk..[["
                                    r="]]..kp/ko..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hj..[["
                                    cy="]]..hk..[["
                                    r="]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hj-ko..[[,]]..hk..[[ h ]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hj+kp..[[,]]..hk..[[ h ]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hj..[[,]]..hk-ko..[[ v ]]..kp..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jt[#jt+1]=ks end;jt[#jt+1]=dp("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lZ,l_-10,lZ,l_+10)jt[#jt+1]=dp("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",lZ-10,l_,lZ+10,l_)jt[#jt+1]='</g>'else return jt end end;local function mP(mQ,mR)local mS;local mT=(mR-mQ):normalize()local fC=(d0-mQ):dot(mT)/mT:dot(mT)if fC<=0. then return(d0-mQ):len()elseif fC>=(mR-mQ):len()then return(d0-mR):len()end;local mU=mQ+fC*mT;mS=(mU-d0):len()return mS end;local function mV()local mS;local mW=nil;local mX=nil;local mY=nil;for dP,mZ in pairs(e[0])do if mZ.hasAtmosphere then local cb=mP(iJ.center,mZ.center)if mW==nil or cb<mW then mX=mZ;mW=cb;mY=iJ end;if c4 and c4.hasAtmosphere and c4.name~=iJ.name then local eU=mP(c4.center,mZ.center)if eU<mW then mX=mZ;mW=eU;mY=c4 end end end end;local m_=iK(1770)local n0=iL(330)if mW then local n1="txttick "local n2=500000;if mW<mX.radius+n2 or mW<mY.radius+n2 then if d8 then n1="txttick red "else n1="txttick orange "end end;mS=ik(mW,2)ix=gJ(m_,n0,"Pipe ("..mY.name.."--"..mX.name.."): "..mS,n1 .."pbright txtmid")end end;local function n3(hj,hk,n4,n5,kB)local n6={x=hj,y=hk,width=n4,height=n5,label=kB}ir[kB]=n6;return n6 end;local function n7(n8,n9,n4,n5,hj,hk,na,nb,nc,nd,jn)local n6={enableName=n8,disableName=n9,width=n4,height=n5,x=hj,y=hk,toggleVar=na,toggleFunction=nb,drawCondition=nc,hovered=false,class=jn}if nd then table.insert(iq,n6)else table.insert(ip,n6)end;return n6 end;local function ne(nf)if not iv then ng=false;nh=false;ni=false;x=true;return elseif nf=="handling"then ng=not ng;nh=false;ni=false elseif nf=="hud"then nh=not nh;ng=false;ni=false elseif nf=="physics"then ni=not ni;ng=false;nh=false end;if ni or nh or ng then iw=ij(nf)x=false else iw="none"x=true end end;local function nj()iv=not iv;if iv then io=iq;c0="Hold SHIFT to see Settings"dl=x else io=ip;c0="Hold SHIFT to see Control Buttons"ne()x=dl end end;local function nk()local function nl(dB,dP)dB.set(not dB.get())if dB.get()then c0=dP.." set to true"else c0=dP.." set to false"end;if dP=="showHud"then dl=dB.get()elseif dP=="BrakeToggleDefault"then aU=j end end;local nm=50;local nn=340;local hj=500;local hk=cs/2-400;local no=0;for dP,dB in pairs(ij("boolean"))do if type(dB.get())=="boolean"then n7(dP,dP,nn,nm,hj,hk,function()return dB.get()end,function()nl(dB,dP)end,function()return true end,true)hk=hk+nm+20;if no==9 then hj=hj+nn+20;hk=cs/2-400;no=0 else no=no+1 end end end;n7("Control View","Control View",nn,nm,10,cs/2-500,function()return true end,nj,function()return true end,true)n7("View Handling Settings",'Hide Handling Settings',nn,nm,10,cs/2-(500-nm),function()return ng end,function()ne("handling")end,function()return true end,true)n7("View Hud Settings",'Hide Hud Settings',nn,nm,10,cs/2-(500-nm*2),function()return nh end,function()ne("hud")end,function()return true end,true)n7("View Physics Settings",'Hide Physics Settings',nn,nm,10,cs/2-(500-nm*3),function()return ni end,function()ne("physics")end,function()return true end,true)end;local function np()local function gy()local g1=d0;local gz=iJ.name..". "..#bk;if radar_1 then gz=cE.GetClosestName(gz)end;return cC.AddNewLocation(gz,g1,false,true)end;local function nq()a_=not a_ end;local function nr(ns)if ns==1 then aY=not aY;aX=false else aX=not aX;aY=false end;aZ=false;b0=false;bZ=false;b1=false;bo=nil;b3=false;b2=false end;local function nt()cC.UpdatePosition()end;local function gw()cC.ClearCurrentPosition()end;local function nu(gx)local ly=cD.routeWP(true)if ly and#ly>0 then return"Engage Route: "..lw(ly[1])end;return"Engage Autopilot: "..lw(gx)end;local function nv(gx)local ly=cD.routeWP(true)if ly and#ly>0 then return"Next Route Point: "..lw(ly[1])end;return"Disable Autopilot: "..lw(gx)end;local function nw()if id()==1 then bZ=not bZ;if bZ then aZ=false;aX=false;aY=false;b0=false;b3=false;b1=false;b2=false;nx=bh;bh=false;d.control.retractLandingGears()ie:setTargetGroundAltitude(X)f_("folOn","F")else f_("folOff","F")aW=true;cI=p;bh=nx;if bh then d.control.extendLandingGears()ie:setTargetGroundAltitude(Y)end end else c0="Follow Mode only works with Remote controller"bZ=false end end;local nm=50;local nn=260;local ny=iK(30)local nz=av+au*2+2;local nA=aw+1;n7("+","+",ny,ny,nz,nA+ny+1,function()return false end,function()dk=dk/8 end,function()return bB=="SCOPE"end,nil,"ZoomButton")n7("-","-",ny,ny,nz,nA,function()return false end,function()dk=math.min(dk*8,90)end,function()return bB=="SCOPE"end,nil,"ZoomButton")n7("0","0",ny,ny,nz,nA+ny*2+2,function()return false end,function()dk=90 end,function()return bB=="SCOPE"and dk~=90 end,nil,"ZoomButton")local nB=n7("Enable Brake Toggle","Disable Brake Toggle",nn,nm,cr/2-nn/2,cs/2+350,function()return aU end,function()aU=not aU;if aU then c0="Brakes in Toggle Mode"else c0="Brakes in Default Mode"end end)n7("Align Prograde","Disable Prograde",nn,nm,cr/2-nn/2-50-nB.width,cs/2-nm+380,function()return aY end,function()nr(1)end)n7("Align Retrograde","Disable Retrograde",nn,nm,cr/2-nn/2+nB.width+50,cs/2-nm+380,function()return aX end,nr,function()return ci==0 end)nC=n7(nu,nv,600,60,cr/2-600/2,cs/2-60/2-330,function()return aZ or bl or ce or bu end,function()end)local K;local function nD(nE)local ly=cD.routeWP(true)if ly and#ly>0 then return ly[1]end;local gx=dg+nE;if gx>#d7 then gx=gx-#d7-1 end;if gx<0 then gx=#d7+gx end;return gx end;nF={}for K=0,10 do local nG=n7(function(eI)local gx=nD(eI.apExtraIndex)if aZ or bl or ce or bu then return"Redirect: "..lw(gx)end;return nu(gx)end,function(eI)local gx=nD(eI.apExtraIndex)return nv(gx)end,600,60,cr/2-600/2,cs/2-60/2-330+60*K,function(eI)local gx=nD(eI.apExtraIndex)return gx==bg and(aZ or bl or ce or bu)end,function(eI)local gx=nD(eI.apExtraIndex)local nH=bg==gx;bg=gx;cC.UpdateAutopilotTarget()cD.ToggleAutopilot()if not nH and not(aZ or bl or ce or bu)then cD.ToggleAutopilot()end end,function()return df and(#cD.routeWP(true)==0 or K==0)end)nG.apExtraIndex=K;nF[K]=nG end;n7("Save Position","Save Position",200,nC.height,nC.x+nC.width+30,nC.y,function()return false end,gy,function()return bg==0 or g9==nil end)n7("Update Position","Update Position",200,nC.height,nC.x+nC.width+30,nC.y,function()return false end,nt,function()return bg>0 and g9~=nil end)n7("Clear Position","Clear Position",200,nC.height,nC.x-200-30,nC.y,function()return true end,gw,function()return bg>0 and g9~=nil end)n7("Save Route","Save Route",200,nC.height,nC.x+nC.width+30,nC.y+nC.height+20,function()return false end,function()cD.routeWP(false,false,2)end,function()return#cD.routeWP(true)>0 end)n7("Load Route","Clear Route",200,nC.height,nC.x-200-30,nC.y+nC.height+20,function()return#cD.routeWP(true)>0 end,function()if#cD.routeWP(true)>0 then cD.routeWP(false,true)elseif aZ or bl then c0="Disable Autopilot before loading route"return else cD.routeWP(false,false,1)end end,function()return true end)nm=60;nn=300;local hj=0;local hk=cs/2-150;n7("Enable Check Damage","Disable Check Damage",nn,nm,hj,hk-nm-20,function()return s end,function()s=not s end)n7("View Settings","View Settings",nn,nm,hj,hk,function()return true end,nj)hk=hk+nm+20;n7("Enable Turn and Burn","Disable Turn and Burn",nn,nm,hj,hk,function()return a_ end,nq)hj=10;hk=cs/2-300;n7("Horizontal Takeoff Mode","Vertical Takeoff Mode",nn,nm,hj+nn+20,hk,function()return aV end,function()aV=not aV;if aV then c0="Vertical Takeoff Mode"else c0="Horizontal Takeoff Mode"end end,function()return d1 end)hk=hk+nm+20;n7("Engage Orbiting","Cancel Orbiting",nn,nm,hj+nn+20,hk,function()return bu end,cD.ToggleIntoOrbit,function()return ci==0 and dc end)hk=cs/2-150;n7("Glide Re-Entry","Cancel Glide Re-Entry",nn,nm,hj+nn+20,hk,function()return b3 end,function()cd=1;nr(1)end,function()return iJ.hasAtmosphere and not ch end)hk=hk+nm+20;n7("Parachute Re-Entry","Cancel Parachute Re-Entry",nn,nm,hj+nn+20,hk,function()return b3 end,function()cd=2;nr(1)end,function()return iJ.hasAtmosphere and not ch end)hk=hk+nm+20;n7("Engage Follow Mode","Disable Follow Mode",nn,nm,hj,hk,function()return bZ end,nw,function()return id()==1 end)n7("Enable Repair Arrows","Disable Repair Arrows",nn,nm,hj+nn+20,hk,function()return cw end,function()cw=not cw;if cw then c0="Repair Arrows Enabled"else c0="Repair Arrows Diabled"end end,function()return id()==1 end)hk=hk+nm+20;if not q then n7("Enable AGG","Disable AGG",nn,nm,hj,hk,function()return d2 end,cD.ToggleAntigrav,function()return antigrav~=nil end)end;n7(function()return dp("Switch IPH Mode - Current: %s",bv)end,function()return dp("IPH Mode: %s",bv)end,nn*2,nm,hj,hk,function()return false end,function()if bv=="All"then bv="Custom Only"elseif bv=="Custom Only"then bv="No Moons"else bv="All"end;c0="IPH Mode: "..bv end)hk=hk+nm+20;n7(function()return dp("Toggle Control Scheme - Current: %s",g)end,function()return dp("Control Scheme: %s",g)end,nn*2,nm,hj,hk,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c0="New Control Scheme: "..g end)local nI=iL(20)local nG=n3(0,0,iK(70),nI,"HELP")nG=n3(nG.x+nG.width,nG.y,iK(80),nI,"INFO")nG=n3(nG.x+nG.width,nG.y,iK(70),nI,"ORBIT")nG=n3(nG.x+nG.width,nG.y,iK(70),nI,"SCOPE")n3(nG.x+nG.width,nG.y,iK(70),nI,"HIDE")end;local nJ={}local nK=nil;function nJ.HUDPrologue(jt)d8,d9=iH(d0)if not d8 then bH=ae;bJ=af;bI=ag;if ia and G and ia.getState()==0 then ia.toggle()end else bH=ab;bJ=ac;bI=ad;if ia and G and ia.getState()==1 then ia.toggle()end end;co=[[rgb(]]..bE(bH+0.6)..","..bE(bJ+0.6)..","..bE(bI+0.6)..[[)]]cp=[[rgb(]]..bE(bH*0.8+0.5)..","..bE(bJ*0.8+0.5)..","..bE(bI*0.8+0.5)..[[)]]local nL=co;local nM=cp;local nN=[[rgb(]]..bE(bH*0.4+0.5)..","..bE(bJ*0.4+0.5)..","..bE(bI*0.4+0.5)..[[)]]local nO=co;local nP=cp;local nQ=nN;if iM()and not m then nL=[[rgb(]]..bE(bH*0.5+0.5)..","..bE(bJ*0.5+0.5)..","..bE(bI*0.5+0.5)..[[)]]nM=[[rgb(]]..bE(bH*0.3+0.5)..","..bE(bJ*0.3+0.5)..","..bE(bI*0.2+0.5)..[[)]]nN=[[rgb(]]..bE(bH*0.2+0.5)..","..bE(bJ*0.2+0.5)..","..bE(bI*0.2+0.5)..[[)]]end;local ll=iK;local lm=iL;jt[#jt+1]=dp([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nL,nL,nL,nO,nO,nM,nM,nP,nP,nM,nL,nN,nP,nL,nL,nN,nN,nQ,nN,cr,cs,nM,nM,nM,nM,nM,nO,nM,nP,nQ,nP,nP,nQ)if not nK then nK=dp([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],ll(630),lm(0),ll(675),lm(45),ll(960),lm(55),ll(1245),lm(45),ll(1290),lm(0),ll(1000),lm(105),ll(1040),lm(59),ll(1250),lm(51),ll(1300),lm(0),ll(1920),lm(0),ll(1920),lm(20),ll(1400),lm(20),ll(1300),lm(105),ll(920),lm(105),ll(880),lm(59),ll(670),lm(51),ll(620),lm(0),ll(0),lm(0),ll(0),lm(20),ll(520),lm(20),ll(620),lm(105),ll(890),lm(59),ll(960),lm(62),ll(1030),lm(59),ll(985),lm(112),ll(1150),lm(112),ll(1100),lm(152),ll(820),lm(152),ll(780),lm(112),ll(935),lm(112),ll(890),lm(59),ll(960),lm(62),ll(1030),lm(59),ll(985),lm(112),ll(1150),lm(112),ll(1100),lm(152),ll(820),lm(152),ll(780),lm(112),ll(935),lm(112))end;if x and I then jt[#jt+1]=nK end;return jt end;function nJ.DrawVerticalSpeed(jt,e8)js(jt,e8)end;function nJ.UpdateHud(jt)local kh=d5;local nR=d6;local jA=nR;local jQ=kh;local kz=bE(c.getThrottle())local kE=cY*3.6;local kA=c.getAxisCommandValue(0)local nS=iK(1770)local nT=iL(310)if u and d4 then kA=bK;kz=bK*100 end;local iO=iN()local jB="ROLL"if kz==nil then kz=0 end;if not dc then if cY>5 then kh=kg(cW)nR=ki(cW)else kh=0;nR=0 end;jB="YAW"end;if d9>50000 and not ch then local nU;nU=ik(d9)jt[#jt+1]=gJ(nS,nT,"PvP Boundary: "..nU,"pbright txtbig txtmid")end;jt[#jt+1]=cc;jt[#jt+1]=cq;jt[#jt+1]=i5;if ix~=""then jt[#jt+1]=ix end;if iP~=""then jt[#jt+1]=iP end;if iQ~=""then jt[#jt+1]=iQ end;js(jt,cj)if id()==0 or l then if dc then jz(jt,ah,ai,jA,jB,dc)else jz(jt,ah,ai,nR,jB,dc)end;if not iM()or m then if dc then jz(jt,ah,ai,jA,jB,dc)jP(jt,jQ,jA,ah,ai,dc,bE(ki(cW)),cY)else jz(jt,ah,ai,nR,jB,dc)jP(jt,kh,nR,ah,ai,dc,bE(nR),cY)end;jW(jt,cj,dc)kj(jt,cW,cY,ah,ai)end end;ky(jt,iO,kz,kA)kD(jt,kE)kH(jt)lF(jt)if not iv and b_ then lx(jt)end;return jt end;function nJ.HUDEpilogue(jt)jt[#jt+1]="</svg>"return jt end;function nJ.ExtraData(jt)local nV=iK(1240)local nW=iL(55)local nX=nW+10;local gC;local ll=iK;local lm=iL;local nY=0;local iO=iN()if aV then iO=iO.."-VERTICAL"end;if F and not b2 and not b1 and cY>20 then iO=iO.."-COLLISION ON"end;if bx~="Off"then iO="("..bx..")-"..iO end;if a_ then iO="TB-"..iO end;if not bw then iO=iO.."-DeCoupled"end;local nZ=lm(99)local n_=lm(80)local o0=lm(85)local o1=lm(31)local o2=0;local o3=0;local o4=cl>1000000 and ih(cl/1000000,2).."kT"or ih(cl/1000,2).."T"if ch then nY=bp else nY=bn end;local o5,o6=cy.computeDistanceAndTime(cY,0,cl,0,0,nY)if o5<0 then o5=0 end;nY=ih(nY/(cl*im),2).."g"local o7=d:maxForceForward()gC=b.g()if gC>0.1 then o3=cl*gC;o3=ih(o3/(cl*im),2).."g"o2=0.5*o7/gC;o2=o2>1000000 and ih(o2/1000000,2).."kT"or ih(o2/1000,2).."T"end;o7=ih(o7/(cl*im),2).."g"local o8=vec3(b.getWorldAcceleration()):len()/9.80665;gC=b.g()jt[#jt+1]=[[<g class="dim txt txtend size14">]]if id()==1 and not l then nV=iK(1120)nW=iL(55)nX=nW+10 elseif ch and I then local o9=iK(770)jt[#jt+1]=gJ(ll(895),nZ,"ATMO","")jt[#jt+1]=dp([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],ll(895),o0,ll(-80))jt[#jt+1]=gJ(ll(815),n_,dp("%.1f%%",ci*100),"txtstart size20")end;if I then jt[#jt+1]=gJ(ll(1025),nZ,"GRAVITY","txtstart")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(1025),o0,ll(80))jt[#jt+1]=gJ(ll(1105),n_,dp("%.2fg",gC/9.80665),"size20")jt[#jt+1]=gJ(ll(1125),nZ,"ACCEL","txtstart")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(1125),o0,ll(80))jt[#jt+1]=gJ(ll(1205),n_,dp("%.2fg",o8),"size20")jt[#jt+1]=gJ(ll(695),nZ,"BRK TIME","")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(695),o0,ll(-80))jt[#jt+1]=gJ(ll(615),n_,dp("%s",il(o6)),"txtstart size20")jt[#jt+1]=gJ(ll(635),lm(45),"TRIP","")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(635),lm(31),ll(-90))if lf then jt[#jt+1]=gJ(ll(532),lm(23),dp("%s",il(lf)),"txtstart size20")end;jt[#jt+1]=gJ(ll(795),nZ,"BRK DIST","")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(795),o0,ll(-80))jt[#jt+1]=gJ(ll(715),n_,dp("%s",ik(o5)),"txtstart size20")jt[#jt+1]=gJ(ll(1285),lm(45),"MASS","txtstart")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(1285),lm(31),ll(90))jt[#jt+1]=gJ(ll(1388),lm(23),dp("%s",o4),"size20")jt[#jt+1]=gJ(ll(1220),nZ,"THRUST","txtstart")jt[#jt+1]=dp([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],ll(1220),o0,ll(80))jt[#jt+1]=gJ(ll(1300),n_,dp("%s",o7),"size20")jt[#jt+1]=gJ(iK(960),iL(175),iO,"pbright txtbig txtmid size20")end;jt[#jt+1]="</g>"end;local oa=1-(a5*0.05+a6*0.05)function nJ.DrawOdometer(jt,c5,bi,c6)if bB~="INFO"then return jt end;local gC;local o2=0;local o3=0;local nY=0;local o4=cl>1000000 and ih(cl/1000000,2).." kTons"or ih(cl/1000,2).." Tons"if ch then nY=bp else nY=bn end;local o5,o6=cy.computeDistanceAndTime(cY,0,cl,0,0,nY)nY=ih(nY/(cl*im),2).." g"local o7=d:maxForceForward()gC=b.g()if gC>0.1 then o3=cl*gC;o3=ih(o3/(cl*im),2).." g"o2=0.5*o7/gC;o2=o2>1000000 and ih(o2/1000000,2).." kTons"or ih(o2/1000,2).." Tons"end;o7=ih(o7/(cl*im),2).." g"if id()==0 or l then local ob=iK(av+10)local oc=iL(aw+20)local od=iK(av+10+au/1.25)local n5=25;jt[#jt+1]="<g class='txtstart size14 bright'>"jt[#jt+1]=gJ(ob,oc,dp("BrkTime: %s",il(o6)))jt[#jt+1]=gJ(od,oc,dp("Trip: %.2f km",c5))jt[#jt+1]=gJ(ob,oc+n5,dp("Lifetime: %.2f kSU",bi/200000))jt[#jt+1]=gJ(od,oc+n5,dp("BrkDist: %s",ik(o5)))jt[#jt+1]=gJ(ob,oc+n5*2,"Trip Time: "..il(c6))jt[#jt+1]=gJ(od,oc+n5*2,"Total Time: "..il(bj))jt[#jt+1]=gJ(ob,oc+n5*3,dp("Mass: %s",o4))jt[#jt+1]=gJ(od,oc+n5*3,dp("Max Brake: %s",nY))jt[#jt+1]=gJ(ob,oc+n5*4,dp("Max Thrust: %s",o7))if gC>0.1 then jt[#jt+1]=gJ(od,oc+n5*4,dp("Max Thrust Mass: %s",o2))jt[#jt+1]=gJ(ob,oc+n5*5,dp("Req Thrust: %s",o3))else jt[#jt+1]=gJ(od,oc+n5*4,"Max Mass: n/a")jt[#jt+1]=gJ(ob,oc+n5*5,"Req Thrust: n/a")end;jt[#jt+1]=gJ(od,oc+n5*5,dp("Atmo Fuel Used: %.1f L",j5["atmofueltank"]/(4*oa)))jt[#jt+1]=gJ(ob,oc+n5*6,dp("Space Fuel Used: %.1f L",j5["spacefueltank"]/(6*oa)))jt[#jt+1]=gJ(od,oc+n5*6,dp("Rocket Fuel Used: %.1f L",j5["rocketfueltank"]/(0.8*oa)))end;jt[#jt+1]="</g></g>"return jt end;function nJ.DrawWarnings(jt)return kH(jt)end;function nJ.DisplayOrbitScreen(jt)return lF(jt)end;function nJ.DisplayMessage(jt,l2)if l2~="empty"then local hk=310;for oe in string.gmatch(l2,"([^\n]+)")do hk=hk+35;jt[#jt+1]=gJ("50%",hk,oe,"msg")end end;if ca~=0 then c.setTimer("msgTick",ca)ca=0 end end;function nJ.DrawDeadZone(jt)jt[#jt+1]=dp([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],at)end;function nJ.UpdatePipe()if ch then ix=""return end;mV()end;function nJ.DrawSettings(jt)local hj=iK(640)local hk=iL(200)jt[#jt+1]=[[<g class="pbright txtvspd txtstart">]]local hN=0;for dP,dB in pairs(iw)do hN=hN+1;jt[#jt+1]=gJ(hj,hk,dP..": "..dB.get())hk=hk+20;if hN%12==0 then hj=hj+iK(350)hk=iL(200)end end;jt[#jt+1]=gJ(iK(640),iL(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jt[#jt+1]="</g>"return jt end;local i2=iK(1770)local i3=iL(350)local i1=iL(15)local i0=iK(1370)local i6,of;function nJ.DrawRadarInfo()i5=cE.GetRadarHud(i0,i1,i2,i3)end;function nJ.DrawTanks()if ap~=0 and aq~=0 then iP=gJ(ap,aq,"","txtstart pdim txtfuel")j6=aq;j7(ap,"Atmospheric ","ATMO",ct,j3,j4)j7(ap,"Space Fuel T","SPACE",cu,j1,j2)j7(ap,"Rocket Fuel ","ROCKET",cv,i_,j0)end end;function nJ.DrawShield()local og=ia.getState()==1 and"Shield Active"or"Shield Disabled"local oh=b.getPvPTimer()local oi=ia.getResistances()local oj="A: "..10+oi[1]*100 .."% / E: "..10+oi[2]*100 .."% / K:"..10+oi[3]*100 .."% / T: "..10+oi[4]*100 .."%"local hj,hk=ar-60,as+30;local ok=bE(0.5+ia.getShieldHitpoints()*100/ia.getMaxShieldHitpoints())local jl=bE(ok*2.55)local jm=dp("rgb(%d,%d,%d)",255-jl,jl,0)local jn=""iQ=gJ(hj,hk,"","txtmid pdim txtfuel")if ok<10 and og~="Shield Disabled"then jn="red "end;oh=oh>0 and"   PvPTime: "..il(oh)or""iQ=iQ..dp([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hj,hk,jm,ok*2,hj,hk,hj+2,hk+10,ok,oh)iQ=iQ..gJ(hj,hk-5,og,jn.."txtstart pbright txtbig")iQ=iQ..gJ(hj,hk+30,oj,jn.."txtstart pbright txtsmall")end;function nJ.hudtick()if not iJ then return end;local function ol(jt)local jp=bE(dq(cb/(cr/4)*255,0,255))jt[#jt+1]=dp("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c8,c9,bE(bH+0.5)+jp,bE(bJ+0.5)-jp,bE(bI+0.5)-jp)end;local function om()for dU,dB in pairs(io)do if dB.hovered then if not dB.drawCondition or dB.drawCondition(dB)then dB.toggleFunction(dB)end;dB.hovered=false end end;for dU,dB in pairs(ir)do if dB.hovered then bB=dB.label;dB.hovered=false end end end;local function on()local function oo(op,oq,hj,hk,n4,n5)if op>=hj and op<=hj+n4 and oq>=hk and oq<=hk+n5 then return true else return false end end;local hj=c8+cr/2;local hk=c9+cs/2;for dU,dB in pairs(io)do dB.hovered=oo(hj,hk,dB.x,dB.y,dB.width,dB.height)end;for dU,dB in pairs(ir)do dB.hovered=oo(hj,hk,dB.x,dB.y,dB.width,dB.height)end;if df then local mK=false;for dU,eI in ipairs(nF)do if eI.hovered then mK=true;break end end;if nC.hovered then mK=true end;df=mK else df=nC.hovered;if not df then dg=bg end end end;local function os(jt)if not bB or bB==""then bB="HELP"end;if x then for dP,dB in pairs(ir)do local jn="dim brightstroke"local ot=0.2;if bB==dP then jn="pbright dimstroke"ot=0.6 end;local ou=""if dB.hovered then ot=0.8;ou=";stroke:white"end;jt[#jt+1]=dp([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dB.width,dB.height,dB.x,dB.y,jn,ot,ou)jt[#jt+1]=gJ(dB.x+dB.width/2,dB.y+dB.height/2+5,dB.label,"txt txtmid pdim")end end end;local function ov(jt)local function ow(jt,ox,hover,hj,hk,fo,oy,oz,oA,oB,oC,nG)if type(oB)=="function"then oB=oB(nG)end;if type(oC)=="function"then oC=oC(nG)end;jt[#jt+1]=dp("<rect x='%f' y='%f' width='%f' height='%f' fill='",hj,hk,fo,oy)if ox then jt[#jt+1]=dp("%s'",oz)else jt[#jt+1]=oA end;if hover then jt[#jt+1]=dp(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ab,ac,ad)else jt[#jt+1]=dp(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ih(ab*0.5,0),ih(ac*0.5,0),ih(ad*0.5,0))end;jt[#jt+1]=" rx='5'></rect>"jt[#jt+1]=dp("<text x='%f' y='%f' font-size='24' fill='",hj+fo/2,hk+oy/2+5)if ox then jt[#jt+1]="black"else jt[#jt+1]="white"end;jt[#jt+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if ox then jt[#jt+1]=dp("%s</text>",oB)else jt[#jt+1]=dp("%s</text>",oC)end end;local oD=dp("rgb(%d,%d,%d)'",ih(ab*0.1,0),ih(ac*0.1,0),ih(ad*0.1,0))local oE=dp("rgb(%d,%d,%d)",ih(ab*0.8,0),ih(ac*0.8,0),ih(ad*0.8,0))local oF=ow;for dU,dB in pairs(io)do local n9=dB.disableName;local n8=dB.enableName;if type(n9)=="function"then n9=n9(dB)end;if type(n8)=="function"then n8=n8(dB)end;if not dB.drawCondition or dB.drawCondition(dB)then oF(jt,dB.toggleVar(dB),dB.hovered,dB.x,dB.y,dB.width,dB.height,oE,oD,n9,n8,dB)end end end;local oG=ih(cr/2,0)local oH=ih(cs/2,0)local jt={}cB.HUDPrologue(jt)if x then cB.UpdateHud(jt)else if B then cB.DrawVerticalSpeed(jt,cj)end;cB.DrawWarnings(jt)end;if iv and iw~="none"then cB.DrawSettings(jt)end;if radar_1 then cB.DrawRadarInfo()end;cB.HUDEpilogue(jt)jt[#jt+1]=dp([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cr,cs)if c0~="empty"then cB.DisplayMessage(jt,c0)end;if id()==0 and g=="virtual joystick"then if w then cB.DrawDeadZone(jt)end end;os(jt)if ig()==0 then if id()==1 and b_ then if not oI then on()ov(jt)end;if not cG and not cH then local oJ=table.concat(jt,"")jt={}jt[#jt+1]=dp("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jt[#jt+1]=oJ;jt[#jt+1]="</body>"cG=true;jt[#jt+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oK=table.concat(jt,"")a.setScreen(oK)elseif cH then local oJ=table.concat(jt,"")jt={}jt[#jt+1]=dp("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jt[#jt+1]=oJ;jt[#jt+1]="</body>"end;if not cG then jt[#jt+1]=dp([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oG,oH,c8,c9)end else om()end else if not b_ and id()==0 then om()if cb>at then if w then ol(jt)end end elseif b_ and(not oI or not i)then on()ov(jt)end;jt[#jt+1]=dp([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oG,oH,c8,c9)end;jt[#jt+1]=[[</svg></body>]]oK=table.concat(jt,"")end;function nJ.TenthTick()local function oL()local oM=a.createData;local oN=a.createWidget;oO=a.createWidgetPanel("Interplanetary Helper")oP=oN(oO,"value")oQ=oM('{"label": "Target Planet", "value": "N/A", "unit":""}')fZ(oQ,oP)oR=oN(oO,"value")oS=oM('{"label": "distance", "value": "N/A", "unit":""}')fZ(oS,oR)gq=oN(oO,"value")gp=oM('{"label": "Travel Time", "value": "N/A", "unit":""}')fZ(gp,gq)go=oN(oO,"value")gn=oM('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fZ(gn,go)gs=oN(oO,"value")gr=oM('{"label": "Target Altitude", "value": "N/A", "unit":""}')fZ(gr,gs)gk=oN(oO,"value")gj=oM('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gi=oN(oO,"value")gh=oM('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gg=oN(oO,"value")gf=oM('{"label": "Max Brake distance", "value": "N/A", "unit":""}')ge=oN(oO,"value")gd=oM('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gm=oN(oO,"value")gl=oM('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ch then fZ(gj,gk)fZ(gh,gi)fZ(gf,gg)fZ(gd,ge)fZ(gl,gm)end end;local function oT()gI(oO)oO=nil end;local function oU()if not aZ then if g9==nil or g9.planetname~=iJ.name then oV=(c4.center-d0):len()else oV=(g9.position-d0):len()end end;local fv=cY;local oW=c.getThrottle()/100;if u then oW=bK end;local oX,oY=cy.computeDistanceAndTime(cY,_,cl,d:maxForceForward()*oW,a1,0)local c2,c3;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local dU,oZ;if not a_ and fv>0 then dU,oZ=cD.GetAutopilotBrakeDistanceAndTime(fv)else dU,oZ=cD.GetAutopilotTBBrakeDistanceAndTime(fv)end;local o_=0;local p0=0;if b9 or not aZ and fv>5 then p0=cy.computeTravelTime(fv,0,oV)elseif c2+oX<oV then o_=oV-(c2+oX)p0=cy.computeTravelTime(8333.0556,0,o_)else local p1=(oV-c2)/oX;oX=oV-c2;oY=oY*p1 end;if g9~=nil and g9.planetname==iJ.name and not aZ then return p0 elseif b8 then return oZ elseif b9 then return p0+oZ else return oY+c3+p0 end end;cB.DrawTanks()if ia then cB.DrawShield()end;if be~="None"then if oO==nil then oL()end;if be~=nil then local p2=g9~=nil;local p3=0.5*bp/c4:getGravity(c4.center+vec3(0,0,1)*c4.radius):len()p3=p3>1000000 and ih(p3/1000000,2).." kTons"or ih(p3/1000,2).." Tons"fY(oQ,'{"label": "Target", "value": "'..be..'", "unit":""}')lf=oU()if p2 and not aZ then cb=(d0-g9.position):len()else cb=(bf-d0):len()end;if not a_ then c2,c3=cD.GetAutopilotBrakeDistanceAndTime(cY)iz,iA=cD.GetAutopilotBrakeDistanceAndTime(_)else c2,c3=cD.GetAutopilotTBBrakeDistanceAndTime(cY)iz,iA=cD.GetAutopilotTBBrakeDistanceAndTime(_)end;local l2=ik(cb)fY(oS,'{"label": "distance", "value": "'..l2 ..'"}')fY(gp,'{"label": "Travel Time", "value": "'..il(lf)..'", "unit":""}')l2=ik(c2)fY(gj,'{"label": "Cur Brake distance", "value": "'..l2 ..'"}')fY(gh,'{"label": "Cur Brake Time", "value": "'..il(c3)..'", "unit":""}')l2=ik(iz)fY(gf,'{"label": "Max Brake distance", "value": "'..l2 ..'"}')fY(gd,'{"label": "Max Brake Time", "value": "'..il(iA)..'", "unit":""}')fY(gn,'{"label": "Max Brake Mass", "value": "'..dp("%s",p3)..'", "unit":""}')l2=ik(gt)fY(gr,'{"label": "Target Orbit", "value": "'..l2 ..'"}')if ci>0 and not p4 then a.removeDataFromWidget(gd,ge)a.removeDataFromWidget(gf,gg)a.removeDataFromWidget(gh,gi)a.removeDataFromWidget(gj,gk)a.removeDataFromWidget(gl,gm)p4=true;if not d4 and u and(b0 or b3 or cf)then cD.cmdThrottle(1)aW=false;bO=false end end;if ci==0 and p4 then if fY(gd,ge)==1 then fZ(gd,ge)end;if fY(gf,gg)==1 then fZ(gf,gg)end;if fY(gh,gi)==1 then fZ(gh,gi)end;if fY(gj,gk)==1 then fZ(gj,gk)end;if fY(gl,gm)==1 then fZ(gl,gm)end;p4=false end end else oT()end;if warpdrive~=nil then if ib(warpdrive.getData()).destination~="Unknown"and ib(warpdrive.getData()).distance>400000 then warpdrive.show()p5=true else warpdrive.hide()p5=false end end end;function nJ.OneSecondTick(jt)local function p6()local jh=bD()local kE=cY;local p7=jh-ck;if kE>1.38889 then kE=kE/1000;local p8=kE*(jh-ck)bi=bi+p8;c5=c5+p8 end;c6=c6+p7;bj=bj+p7;ck=jh end;p6()cB.UpdatePipe()cB.ExtraData(jt)end;function nJ.AnimateTick()cH=true;cG=false;c8=0;c9=0;c.stopTimer("animateTick")end;function nJ.MsgTick()local jt={}cB.DisplayMessage(jt,"empty")c0="empty"c.stopTimer("msgTick")ca=3 end;function nJ.ButtonSetup()nk()np()io=ip end;return nJ end;local function p9(d,b,c,a,e,vBooster,hover,pa,antigrav,warpdrive,dbHud_1,f3,bE,bF,id,eZ,bD,dq,ie,fY,ig,ds,ih,f_,ii,dt,ik,il,pb,ib,dp,fZ)local pc={}local function pd(fv)local pe=ba;if not aZ then pe=0 end;if not ch then return cy.computeDistanceAndTime(fv,pe,cl,0,0,bn-bc*cl)else if bp and bp>0 then return cy.computeDistanceAndTime(fv,pe,cl,0,0,bp-bc*cl)else return 0,0 end end end;local function pf(fv)local pe=ba;if not aZ then pe=0 end;return cy.computeDistanceAndTime(fv,pe,cl,d:maxForceForward(),a1,bn-bc*cl)end;local pg=false;local ph=0;local pi=0;local pj=0;local pk=bD()local pl=0;local pm=0;local pn=0;local po=0;local pp=false;local pq=false;local pr=false;local ps=nil;local pt=0;local pu={}local iy=55;local pv=nil;local pw=""function pc.GetAutopilotBrakeDistanceAndTime(fv)return pd(fv)end;function pc.GetAutopilotTBBrakeDistanceAndTime(fv)return pf(fv)end;local function px(py,pz,pA)pz=pz:project_on_plane(py)pA=pA:project_on_plane(py)return eZ(pz:cross(pA):dot(py),pz:dot(pA))end;local function pB()local function pC()local pD=-1;local pE=-1;if vBooster then pD=vBooster.getDistance()end;if hover then pE=hover.getDistance()end;if pD~=-1 and pE~=-1 then if pD<pE then return pD else return pE end elseif pD~=-1 then return pD elseif pE~=-1 then return pE else return-1 end end;local pF=pC()local pG=-1;if pa then pG=pa.getDistance()end;if pF~=-1 and pG~=-1 then if pF<pG then return pF else return pG end elseif pF~=-1 then return pF else return pG end end;local function pH(iJ,eQ,pI)local function pJ(pK,e0)local eW=vec3(e0)if pK.id==0 then return setmetatable({latitude=eW.x,longitude=eW.y,altitude=eW.z,id=0,systemId=pK.systemId},e2)end;local eX=eW-pK.center;local cb=eX:len()local e8=cb-pK.radius;local e6=0;local e7=0;if not dt(cb,0)then local eY=eZ(eX.y,eX.x)e7=eY>=0 and eY or 2*math.pi+eY;e6=math.pi/2-math.acos(eX.z/cb)end;return setmetatable({latitude=math.deg(e6),longitude=math.deg(e7),altitude=e8,id=pK.id,systemId=pK.systemId},e2)end;local pL=pJ(iJ,eQ)pL="::pos{"..pL.systemId..","..pL.id..","..pL.latitude..","..pL.longitude..","..pL.altitude.."}"if pI then return pL else a.setWaypoint(pL)return true end end;local pM=false;function pc.showWayPoint(iJ,eQ,pI)return pH(iJ,eQ,pI)end;function pc.APTick()local function pN()if de and not b1 then local ex=de[1]local hS,hT=de[2],de[3]local pO=math.min(hS,hT or hS)local pP=pO/cY;local pQ=b2 and(cY<42 or cg~=-1)local pR=b0 or bl or bo or aZ;if pR and not pQ and(c2*1.5>pO or pP<1)then aW=true;pu={}cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()end;if bo then cD.ToggleLockPitch()end;c0="Autopilot Cancelled due to possible collision"if bl or aZ then cD.ToggleAutopilot()end;l9=true;b1=true;cI=true end;if pP<11 then dd=ex.name.." COLLISION "..il(pP).." / "..ik(pO,2)else dd=ex.name.." collision "..il(pP)end;if pP<6 then f_("alarm","AL",2)end else dd=false end end;local function pS(pT,pU,pV)local function pW(pT,ez)pT=vec3(pT)ez=vec3(ez):normalize()local dK=pT*ez;return dK.x+dK.y+dK.z end;local pX=0.001;local pY=1;if not ch or not cJ or cg~=-1 or cY<iy then if pV==nil then pV=aN end;if pU==nil then pU=pX end;pT=vec3(pT):normalize()local pZ=vec3()-pT;local p_=-pW(pZ,b.getConstructWorldOrientationRight())*pY;local q0=-pW(pZ,b.getConstructWorldOrientationUp())*pY;if pi==0 then pi=p_/2 end;if pj==0 then pj=q0/2 end;if f3(p_)<0.1 then bU=bU-p_*2 else bU=bU-(p_+(p_-pi)*pV)end;if f3(q0)<0.1 then bT=bT+q0*2 else bT=bT+q0+(q0-pj)*pV end;pi=p_;pj=q0;if f3(p_)<pU and f3(q0)<pU then return true end;return false elseif cJ and cg==-1 then pT=cX;if pV==nil then pV=aN end;if pU==nil then pU=pX end;pT=vec3(pT):normalize()local pZ=cU-pT;local p_=-pW(pZ,b.getConstructWorldOrientationRight())*pY;local q0=-pW(pZ,b.getConstructWorldOrientationUp())*pY;if pi==0 then pi=p_/2 end;if pj==0 then pj=q0/2 end;if f3(p_)<0.1 then bU=bU-p_*5 else bU=bU-(p_+(p_-pi)*pV)end;if f3(q0)<0.1 then bT=bT+q0*5 else bT=bT+q0+(q0-pj)*pV end;pi=p_;pj=q0;if f3(p_)<pU and f3(q0)<pU then return true end;return false end end;ch=bF()>0;ci=bF()cj=b.getAltitude()cg=pB()bG=bD()pk=bG;if F then pN()end;if antigrav then d2=antigrav.getState()==1 end;local q1=a.getMouseWheel()if q1>0 then cD.changeSpd()elseif q1<0 then cD.changeSpd(true)else cm=true end;local q2=1;local q3=1;local q4=bG-pk;local q5=-math.deg(px(cT,cX,cU))local q6=math.deg(px(cV,cX,cU))local gv=cZ*-1;cJ=ch and q5<-L or q5>L or q6<-M or q6>M;local q7=a.getMouseDeltaX()local q8=a.getMouseDeltaY()if o and not b_ then q8=-q8 end;bU=0;bY=0;bT=0;g2=cx[0]iJ=g2:closestBody(b.getConstructWorldPos())q9=cA(iJ)fz=q9:orbitalParameters(b.getConstructWorldPos(),cX)if cj==0 then cj=(d0-iJ.center):len()-iJ.radius end;dc=c.getClosestPlanetInfluence()>0 or cj>0 and cj<200000;local gC=iJ:getGravity(b.getConstructWorldPos()):len()*cl;cK=0;cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ig()==0 then if id()==1 and b_ then if not cG then c8=dq(c8+q7,-cr/2,cr/2)c9=dq(c9+q8,-cs/2,cs/2)end else c8=0;c9=0 end else c8=dq(c8+q7,-cr/2,cr/2)c9=dq(c9+q8,-cs/2,cs/2)cb=ds(c8*c8+c9*c9)if not b_ and id()==0 then local kq,kr=1,1;if bB=="SCOPE"then kq,kr=dk/90,dk/90 end;if g=="virtual joystick"then if c8>0 and c8>at then bU=bU-(c8-at)*aB*kq elseif c8<0 and c8<at*-1 then bU=bU-(c8+at)*aB*kq else bU=0 end;if c9>0 and c9>at then bT=bT-(c9-at)*aC*kr elseif c9<0 and c9<at*-1 then bT=bT-(c9+at)*aC*kr else bT=0 end else c8=0;c9=0;if g=="mouse"then bT=(-utils.smoothstep(q8,-100,100)+0.5)*2*q2;bU=(-utils.smoothstep(q7,-100,100)+0.5)*2*q3 end end end end;local qa=cY>8334;if cY>V/3.6 and not ch and not aZ and not qa then c0="Space Speed Engine Shutoff reached"cD.cmdThrottle(0)end;if not qa and qb then if not aW then cD.BrakeToggle()end;if aZ then cD.ToggleAutopilot()end end;qb=qa;if ch and ci>0.09 then if cY>cL/3.6 and not u and not pg then aW=true;pg=true elseif not u and pg then if cY<cL/3.6 then aW=false;pg=false end end end;if aW then bX=1 else bX=0 end;if aY then if cd then aW=false;local qc=false;if g9 and cd==true then qc=pS(g9.position-d0,0.1)else qc=pS(vec3(cX),0.01)end;cI=true;if qc then cD.cmdCruise(bE(cL))if(f3(d6)<2 or f3(d5)>85)and cY>=cL/3.6-1 then aW=false;aY=false;if cd~=2 then bQ=true end;if cd==true then cf=true end;cd=false;aZ=false;cD.BeginReentry()end elseif ch and u then cD.cmdThrottle(1)end elseif cY>iy then pS(vec3(cX),0.01)end end;if aX then if ch then aX=false elseif cY>iy then pS(-vec3(cX))end end;if not aY and cd and not bu then if ci==0 then if cd~=2 then bQ=true end;cD.BeginReentry()cd=false;cf=true else cd=false;cD.ToggleAutopilot()end end;if cf and g9 and(cj<b5+250 and cj>b5-250)and cY*3.6>cL-250 and f3(c_)<25 and ci>=0.1 and(g9.position-d0):len()>2000+cj then cD.ToggleAutopilot()cf=false end;if b4 then cI=true;local qd=b5;if c_<-30 then c0="Unable to achieve lift. Safety Landing."c7=0;cI=p;b4=false;b1=true elseif not q and d2 or b5<iJ.spaceEngineMinAltitude then if d2 then qd=antigrav.getBaseAltitude()end;if cj<qd-100 then cM=0;c7=15;aW=false elseif c_>0 then aW=true;c7=0 elseif c_<-30 then aW=true;c7=15 elseif cj>=qd then if d2 then if aZ or bl then cD.ToggleVerticalTakeoff()else aW=true;b4=false end;c0="Takeoff complete. Singularity engaged"f_("aggLk","AG")else aW=false;c0="VTO complete. Engaging Horizontal Flight"f_("vtoc","VT")cD.ToggleVerticalTakeoff()end;c7=0 end else if ci>0.08 then cM=0;aW=false;c7=20 elseif ci<0.08 and ci>0 then aW=false;if cR then cM=0;c7=20 else c7=0;cM=36;cD.cmdCruise(3500)end else cI=p;bu=true;cQ=false;qe=false;pp=false;pn=nil;po=nil;if ps==nil then ps=iJ end;cP=qd;pr=true;b4=false end end;if cM~=nil then if qf==nil then qf=pid.new(2*0.01,0,2*0.1)end;local qg=dq(cM-d5,-M*0.80,M*0.80)qf:inject(qg)local qh=dq(qf:get(),-1,1)bT=qh end end;if bu then local pZ;local qi=false;local qj=ik(cP)if ps==nil then ps=iJ;if bl then ps=c4 end end;if not pr then cP=bE(ps.radius+ps.surfaceMaxAltitude+T)if ps.hasAtmosphere then cP=bE(ps.radius+ps.noAtmosphericDensityAltitude+T)end;pr=true end;if cO.VectorToTarget and g9 then pZ=g9.position-d0 end;local qk,ql=cA(ps):escapeAndOrbitalSpeed((d0-ps.center):len()-ps.radius)local qm=d6;if not pp then local qn=false;local qo=false;cD.cmdThrottle(0)po=0;cN="Aligning to orbital path - OrbitHeight: "..qj;if cO.VectorToTarget then pS(pZ:normalize():project_on_plane(cZ))qi=cU:dot(pZ:project_on_plane(cT):normalize())>0.95 else pS(cX)qi=q5<0.5;if cY<150 then qi=true end end;bT=0;pn=0;if d5<=pn+1 and d5>=pn-1 then qn=true else qn=false end;if qm<=po+1 and qm>=po-1 then qo=true else qo=false end;if qn and qo and qi then pn=nil;po=nil;pp=true end else if cO.VectorToTarget then pS(pZ:normalize():project_on_plane(cZ))elseif cY>150 then pS(cX)end;bT=0;if cO.VectorToTarget and g9 then local c2,dU=cy.computeDistanceAndTime(cY,cL/3.6,cl,0,0,bn)if cQ and pZ:len()>15000+c2+cj then cN="Orbiting to Target"if cj-100<=ps.noAtmosphericDensityAltitude or lf>fz.timeToPeriapsis and fz.periapsis.altitude<ps.noAtmosphericDensityAltitude then cQ=false end elseif cQ or pZ:len()<15000+c2+cj then c0="Orbit complete, proceeding with reentry"f_("orCom","OB")bf=g9.position;bQ=true;cf=true;cO.VectorToTarget,cO.AutopilotAlign=false,false;cD.ToggleIntoOrbit()cD.BeginReentry()return end end;if fz.periapsis~=nil and fz.apoapsis~=nil and fz.eccentricity<1 and cj>cP*0.9 and cj<cP*1.4 then if fz.apoapsis~=nil then if fz.periapsis.altitude>=cP*0.99 and fz.apoapsis.altitude>=cP*0.99 and fz.periapsis.altitude<fz.apoapsis.altitude and fz.periapsis.altitude*1.05>=fz.apoapsis.altitude or cQ then if cQ then aW=false;cD.cmdThrottle(0)pn=0;if not cO.VectorToTarget then c0="Orbit complete"f_("orCom","OB")cD.ToggleIntoOrbit()end else pt=pt+1;if pt>=2 then cQ=true end end else cN="Adjusting Orbit - OrbitHeight: "..qj;pq=true;cD.cmdCruise(ql*3.6+1)local qp=cP-cj;if qq==nil then qq=pid.new(0.1,0,1*0.1)end;qq:inject(qp-c_*dq(utils.smoothstep(2000-qp,-2000,2000)^6*10,1,10))pn=dq(qq:get(),-60,60)end end else local qr=2.75;local qs=f3(ih(qk*qr))local oa=qs%50;if oa>0 then qs=qs-oa+50 end;aW=false;if cj<cP*0.8 then cN="Escaping planet gravity - OrbitHeight: "..qj;pn=utils.map(c_,200,0,-15,80)elseif cj>=cP*0.8 and cj<cP*1.15 then cN="Approaching orbital corridor - OrbitHeight: "..qj;qs=qs*0.75;pn=utils.map(c_,100,-100,-15,65)elseif cj>=cP*1.15 and cj<cP*1.5 then cN="Approaching orbital corridor - OrbitHeight: "..qj;qs=qs*0.75;if c_<0 or pq then pn=utils.map(cj,cP*1.5,cP*1.01,-30,0)else pn=utils.map(cj,cP*0.99,cP*1.5,0,30)end elseif cj>cP*1.5 then cN="Reentering orbital corridor - OrbitHeight: "..qj;pn=-65;local qt=utils.map(c_,-150,-400,1,0.55)qs=qs*qt end;cD.cmdCruise(bE(qs))end end;if pn~=nil then if qu==nil then qu=pid.new(1*0.01,0,5*0.1)end;local qv=pn-d5;qu:inject(qv)local qw=dq(qu:get(),-0.5,0.5)bT=qw end end;if aZ and ci==0 and not cd then local function qx(i6,fz)a.print(i6)aW=false;b8=false;aZ=false;qy=false;bb="Aligning"cD.cmdThrottle(0)bP=false;c0=i6;f_("apCom","AP")if fz or cd then if fz and gt~=nil and not cd then if not cj or cj==0 then return end;cP=cj;pr=true end;cD.ToggleIntoOrbit()end end;local qz,qA=bf,false;if g9 and g9.planetname~="Space"then b7=true;if not qy then local qB=(g9.position-c4.center):normalize()local qC=qB:project_on_plane((c4.center-d0):normalize()):normalize()local qD=c4.center+qC*(c4.radius+gt)local qE=g9.position+(g9.position-c4.center):normalize()*(gt-c4:getAltitude(g9.position))if(d0-qD):len()<(d0-qE):len()then qz=qD else qz=qE;ba=0 end;bf=qz;cD.showWayPoint(c4,bf)qA=true;qy=true end;bc=0 elseif g9 and g9.planetname=="Space"then if not qy then bc=0;qA=true;b7=true;qy=true;qz=g9.position+(d0-g9.position):normalize()*R;bf=qz end elseif g9==nil then bc=0;if not qy then local qB=(d0+cX*100000-c4.center):normalize()local qC=qB:project_on_plane((c4.center-d0):normalize()):normalize()if qC:len()<1 then qB=(d0+cU*100000-c4.center):normalize()qC=qB:project_on_plane((c4.center-d0):normalize()):normalize()end;qz=c4.center+qC*(c4.radius+gt)bf=qz;qy=true;qA=true;b7=true;cD.showWayPoint(c4,bf)end end;oV=(vec3(qz)-d0):len()local ld,eO,eP=cx:getPlanetarySystem(0):castIntersections(d0,cX:normalize(),function(ex)if ex.noAtmosphericDensityAltitude>0 then return ex.radius+ex.noAtmosphericDensityAltitude else return ex.radius+ex.surfaceMaxAltitude*1.5 end end)local le=eO;if eP~=nil and eO~=nil then le=math.min(eP,eO)end;if le~=nil and le<oV and ld.name==c4.name then oV=le end;local qc=true;local qF=(c4.center-(d0+vec3(cX):normalize()*oV)):len()-c4.radius;local l2=ik(qF)fY(gl,'{"label": "Projected Altitude", "value": "'..l2 ..'"}')local c2,c3;if not a_ then c2,c3=pd(cY)else c2,c3=pf(cY)end;if cY>50 and b6 then local pZ=vec3(qz)-d0;local qG=dq(math.deg(px(cT,cX:normalize(),pZ:normalize()))*cY/500,-90,90)local qH=dq(math.deg(px(cV,cX:normalize(),pZ:normalize()))*cY/500,-90,90)if f3(qG)<20 and f3(qH)<20 then qG=qG*2;qH=qH*2 end;if f3(qG)<2 and f3(qH)<2 then qG=qG*2;qH=qH*2 end;local q5=-math.deg(px(cT,cU,cX:normalize()))local q6=-math.deg(px(cV,cU,cX:normalize()))if qI==nil then qI=pid.new(2*0.01,0,2*0.1)end;qI:inject(qH-q6)local qJ=dq(qI:get(),-1,1)bT=bT+qJ;if qK==nil then qK=pid.new(2*0.01,0,2*0.1)end;qK:inject(qG-q5)local qL=dq(qK:get(),-1,1)bU=bU+qL;qA=true;if f3(qG)>2 or f3(qH)>2 then if bb~="Adjusting Trajectory"then bb="Adjusting Trajectory"f_("apAdj","AP")end else if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end end elseif b6 and cY<=50 then pS((qz-d0):normalize())end;if qF<gt*1.5 then if g9 and g9.planetname=="Space"then ba=0 elseif g9==nil then dU,ba=cA(c4):escapeAndOrbitalSpeed(qF)end end;if aZ and not b6 and not b9 and not b8 then local ld,le=cD.checkLOS((bf-d0):normalize())if c4.name~=iJ.name then if ld~=nil and c4.name~=ld.name and le<oV then c0="Collision with "..ld.name.." in "..ik(le).."\nClear LOS to continue."ca=5;pM=true else pM=false;c0=""end end end;if not pM then if not b9 and not b8 and not qA then qc=pS((qz-d0):normalize())elseif a_ and(b8 or b9)then qc=pS(-vec3(cX):normalize())end end;if b6 then if not bP then aW=false;cD.cmdThrottle(a0)bK=ih(a0,2)bP=true end;local oW=c.getThrottle()if u then oW=bK end;local qM=99999;local o8=-vec3(b.getWorldAcceleration()):dot(cX:normalize())local qN=dq(cX:dot((qz-d0):normalize()),0,cY)if qN>0 or o8>0 then qM=cy.computeTravelTime(qN,o8,oV-c2)end;if cW:len()>=_ or oW==0 and bP or a1/4>qM then b6=false;if bb~="Cruising"then f_("apCru","AP")bb="Cruising"end;b9=true;cD.cmdThrottle(0)end;local qO=oV;if qO<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<ph and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;ph=d9 else ph=d9;return end end;b6=false;if bb~="Braking"then f_("apBrk","AP")bb="Braking"end;b8=true;cD.cmdThrottle(0)bP=false end elseif b8 then if bb~="Orbiting to Target"then aW=true;bX=1 end;if a_ then cD.cmdThrottle(1,true)end;local dU,ql=cA(c4):escapeAndOrbitalSpeed((d0-iJ.center):len()-iJ.radius)local pZ;if g9 then pZ=g9.position-d0 end;if g9 and g9.planetname=="Space"and cY<50 then if#pu>0 then aW=false;cD.ToggleAutopilot()cD.ToggleAutopilot()return end;qx("Autopilot complete, arrived at space location")aW=true;bX=1 elseif g9 and g9.planetname~="Space"and cY<=ql and(fz.apoapsis==nil or fz.periapsis==nil or fz.apoapsis.altitude<=0 or fz.periapsis.altitude<=0)then qx("Autopilot complete, commencing reentry")bf=g9.position;cd=true;cD.showWayPoint(c4,bf)elseif(g9 and g9.planetname~="Space"or g9==nil)and fz.periapsis~=nil and fz.periapsis.altitude>0 and fz.eccentricity<1 or bb=="Circularizing"then if bb~="Circularizing"then f_("apCir","AP")bb="Circularizing"end;if cY<=ql then if g9 then if cX:normalize():dot(pZ:normalize())>0.4 then if bb~="Orbiting to Target"then f_("apOrb","OB")bb="Orbiting to Target"end;if not qP then aW=false;cD.showWayPoint(c4,g9.position)qP=true end else qx("Autopilot complete, proceeding with reentry")bf=g9.position;cd=true;cD.showWayPoint(c4,g9.position)qP=false end else qx("Autopilot completed, setting orbit",true)bX=0 end end elseif bb=="Circularizing"then qx("Autopilot complete, fixing Orbit",true)end elseif b9 then local qO=oV;if qO<=c2 or H and d9<=c2+10000 and d8 then if H and d9<=c2+10000 and d8 then if d9<ph and d9>2000 then cD.ToggleAutopilot()c0="Autopilot cancelled to prevent crossing PvP Line"aW=true;ph=d9 else ph=d9;return end end;b6=false;if bb~="Braking"then f_("apBrk","AP")bb="Braking"end;b8=true end;local oW=c.getThrottle()if u then oW=bK end;if oW>0 then b6=true;if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end;b9=false end else if qc then if not b7 and g9==nil or not b7 and g9 and g9.planetname~="Space"then if not cd then bf=vec3(c4.center)+(gt+c4.radius)*cV;qQ=cT;qR=cV end;b7=true elseif qc and not pM then b6=true;if bb~="Accelerating"then bb="Accelerating"f_("apAcc","AP")end;if not bP then cD.cmdThrottle(a0,true)bK=ih(a0,2)bP=true;aW=false end end end end elseif aZ and(g9~=nil and g9.planetname~="Space"and ci>0)then c0="Autopilot complete, starting reentry"f_("apCom","AP")bf=g9.position;aW=false;b8=false;aZ=false;qy=false;bb="Aligning"bX=0;cD.cmdThrottle(0)bP=false;aY=true;cd=true;cD.showWayPoint(c4,g9.position)end;if bZ then cI=true;local qH=0;local fB=d0+vec3(c.getMasterPlayerRelativePosition())local qS=fB-d0;local qT=vec3(qS):project_on(cU):len()local qU=vec3(qS):project_on(cV):len()local cb=ds(qT*qT+qU*qU)pS(qS:normalize())local ml=40;local qV=cb<ml;local qW=100;local qX=dq((cb-ml)/2,10,qW)bT=0;local qc=f3(bU)<0.1;if qc and cY<qX and not qV then aW=false;qH=-20 else aW=true;qH=0 end;local qY=0;if f3(qH-d5)>qY then if qZ==nil then qZ=pid.new(2*0.01,0,2*0.1)end;qZ:inject(qH-d5)local qJ=qZ:get()bT=qJ end end;if b0 or b1 or b3 or bl or bo~=nil then local q_=bp;if q_ then q_=q_*dq(cY/100,0.1,1)*ci else q_=bn end;if ci<0.01 then q_=bn end;local r0=cU:project_on_plane(cZ):normalize():dot(cX)local r1=vec3(b.getWorldAirFrictionAcceleration())local r2=r1:len()*cl;if r0>100 then c2,c3=cy.computeDistanceAndTime(r0,100,cl,0,0,q_)local r3,r4=cy.computeDistanceAndTime(100,0,cl,0,0,q_*0.55)c2=c2+r3 else c2,c3=cy.computeDistanceAndTime(r0,0,cl,0,0,q_*0.55)end;local qp=b5-cj-c_;local r5=200+cY;if b3 or cd then r6=2000+cY end;local r7=1;if b2 then r7=dq(cY/100,0.1,1)end;local qH=(utils.smoothstep(qp,-r5,r5)-0.5)*2*O*r7;if not b3 and not cd and not bl and cU:dot(cX:normalize())<0.99 then qH=(utils.smoothstep(qp,-r5*dq(20-19*ci*10,1,20),r5*dq(20-19*ci*10,1,20))-0.5)*2*O*dq(2-ci*10,1,2)*r7 end;if not b0 then qH=0 end;if bo~=nil then if dc and not bu then qH=bo else bo=nil end end;cI=true;local r8=bT;if b3 then local r9=bE(cL)local ra,rb=cy.computeDistanceAndTime(cY,r9/3.6,cl,0,0,bn-iJ.gravity*9.8*cl)ra=ra==-1 and 5000 or ra;local rc=cj-(iJ.noAtmosphericDensityAltitude+ra)local rd=cj>iJ.noAtmosphericDensityAltitude+ra*1.35;if rd then qH=P;if cY<=r9/3.6 and cY>r9/3.6-10 and f3(cX:normalize():dot(cU))>0.9 and not d4 then bO=false;cD.cmdThrottle(1)end elseif(d4 or ie:getTargetSpeed(axisCommandId.longitudinal)~=r9)and not rd and not ch then cD.cmdCruise(r9,true)end;if d4 then if cY>r9/3.6 and not rd then aW=true else aW=false end else aW=false end;if c_>0 then aW=true end;if not bQ then qH=-80;if cj<iJ.surfaceMaxAltitude+(iJ.atmosphereThickness-iJ.surfaceMaxAltitude)*0.25 then c0="PARACHUTE DEPLOYED at "..ih(cj,0)b3=false;b1=true;l9=true;cD.cmdThrottle(0)qH=0;cI=p end elseif iJ.noAtmosphericDensityAltitude>0 and rd then cI=true elseif not rd then if not ch and(d4 or ie:getTargetSpeed(axisCommandId.longitudinal)~=r9)then cD.cmdCruise(r9)end;if cY<r9/3.6+1 then aW=false;bQ=false;b3=false;cI=true end end end;if cY>iy and not ce and not bl and not b1 and v then pS(vec3(cX))end;if da or(bl or ce)and bg>0 and ci>0.01 then local pZ;if da then if type(da)=="table"then pZ=da elseif da<3 and da>0 then pZ=-cZ:cross(cX)*5000 elseif da>=3 then pZ=cZ:cross(cX)*5000 elseif da<0 then pZ=cX*25000 end elseif g9~=nil then pZ=g9.position-d0 else pZ=c4.center-d0 end;local qG=math.deg(px(cZ:normalize(),cX,pZ))*2;local mo=math.rad(f3(d6))if cY>aG and ci>0.01 then local re=1000+cY;local rf=(utils.smoothstep(qp-c_*10,-re,re)-0.5)*2*O;local rg=dq(90-rf,0,180)cK=dq(qG*2,-rg,rg)local rh=qG;qG=dq(dq(qG,-L*0.80,L*0.80)*math.cos(mo)+4*(d5-qH)*math.sin(math.rad(d6)),-L*0.80,L*0.80)local ri=1;if cK~=0 then ri=f3(mo/cK)end;ri=(90-dq(f3(cK-d6),0,90))/90;local rj=qH;if f3(d6)>90 then rj=-rj end;qH=ri*dq(dq(rj*math.cos(mo),-M*0.8,M*0.8)+f3(dq(f3(rh)*math.sin(mo),-M*0.80,M*0.80)),-M*0.80,M*0.80)else cK=0;qG=dq(qG,-L*0.80,L*0.80)end;local rk=q5-qG;if da and f3(rk)<=0.0001 and(type(da)=="table"or type(da)~="table"and da<0 and f3(d6)<1)then if da==-2 then cD.ToggleAltitudeHold()end;da=nil;f_("180Off","BR")return end;if not cJ and cY>aG and ci>0.01 then if rl==nil then rl=pid.new(2*0.01,0,2*0.1)end;rl:inject(rk)local qL=dq(rl:get(),-1,1)bU=bU+qL elseif ch and cg>-1 or cY<aG then pS(pZ)elseif cJ and ci>0.01 then if(q5<-L or q5>L)and ci>0.01 then pS(cX)end;if(q6<-M or q6>M)and ci>0.01 then qH=dq(d5-q6,d5-M*0.80,d5+M*0.80)end end;if g9~=nil and not ce then local qd=iJ:getAltitude(g9.position)local rc=pZ:project_on_plane(cZ):len()l9=true;if not ce and not b3 and rc<=c2 and(cX:project_on_plane(cZ):normalize():dot(pZ:project_on_plane(cZ):normalize())>0.99 or lh=="Finalizing Approach")then lh="Finalizing Approach"if#pu>0 then cD.ToggleAutopilot()cD.ToggleAutopilot()return end;cD.cmdThrottle(0)if b0 then cD.ToggleAltitudeHold()bl=true end;aW=true elseif not b2 then aW=false end;if lh=="Finalizing Approach"and(r0<0.1 or rc<0.1 or rm~=nil and rm<rc)then if not d2 then f_("bklOn","BL")b1=true end;bl=false;lh="Proceeding to Waypoint"dd=false end;rm=rc end elseif bl and ci==0 and b5>iJ.noAtmosphericDensityAltitude and not(ce or b3)then if g9~=nil and c4.name==iJ.name then local pZ=g9.position-d0;local qd=iJ:getAltitude(g9.position)local rc=ds(pZ:len()^2-(cj-qd)^2)local q_=bp;if q_ then c2,c3=cy.computeDistanceAndTime(cY,0,cl,0,0,q_/2)l9=true;if rc<=c2+cY*q4/2 and cX:project_on_plane(cZ):normalize():dot(pZ:project_on_plane(cZ):normalize())>0.99 then if iJ.hasAtmosphere then aW=false;aY=false;bQ=true;cd=false;cf=true;aZ=false;cD.BeginReentry()end end;rm=rc end end end;if ci==0 and(b0 and b5>iJ.noAtmosphericDensityAltitude)and not(ce or bu or b3)then if not cQ and not bu then cP=b5;pr=true;if bl then cO.VectorToTarget=true end;cD.ToggleIntoOrbit()bl=false;pp=true end end;if cJ and ci>0.01 and cg==-1 and cY>aG and lh~="Finalizing Approach"then pS(cX)qH=dq(d5-q6,d5-M*0.80,d5+M*0.80)end;bT=r8;local pG=-1;if b1 then qH=0;local rn=false;local ro=30;if cz~=nil and cz>0 then local rp=dq(ci,0.4,2)local q_=bp*dq(cY/100,0.1,1)*rp;local rq=cz*rp+q_-gC;local rr=q_/2-gC;local rs=cY-ds(f3(rr/2)*20/(0.5*cl))*utils.sign(rr)if rs<0 then rs=0 end;local rt;if cY>100 then local ru,dU=cy.computeDistanceAndTime(cY,100,cl,0,0,q_)local rv,dU=cy.computeDistanceAndTime(100,0,cl,0,0,ds(q_))rt=ru+rv else rt=cy.computeDistanceAndTime(cY,0,cl,0,0,ds(q_))end;if rt<20 then aW=false else local rw=0;if rs>100 then local rx,dU=cy.computeDistanceAndTime(rs,100,cl,0,0,rq)local ry,dU=cy.computeDistanceAndTime(100,0,cl,0,0,cz*rp+ds(q_)-gC)rw=rx+ry else rw,dU=cy.computeDistanceAndTime(rs,0,cl,0,0,cz*rp+ds(q_)-gC)end;rw=(rw+15+cY*q4)*1.1;local rz=g9~=nil and iJ:getAltitude(g9.position)>0 and g9.safe;if rz then local qd=iJ:getAltitude(g9.position)local rA=cj-qd-100;local pZ=g9.position-d0;local rB=ds(pZ:len()^2-(cj-qd)^2)if rB>100 then rz=false elseif rA<=rw or rw==-1 then aW=true;rn=true else aW=false;rn=true end end;if not rz and t then if rw>=ro then aW=true else aW=false end;rn=true end end end;if not d4 then cD.cmdThrottle(0)end;ie:setTargetGroundAltitude(500)ie:activateGroundEngineAltitudeStabilization(500)bw=true;pG=cg;if pG>-1 then cI=p;if cY<1 or cX:normalize():dot(cZ)<0 then b1=false;b0=false;bh=true;if bR then d.control.extendLandingGears()f_("grOut","LG",1)end;ie:setTargetGroundAltitude(Y)c7=0;aW=true else aW=true end elseif l9 and cX:normalize():dot(-gv)<0.999 then aW=true elseif c_<-N and not rn then aW=true elseif not rn then aW=false end end;if b2 or ce then local ld,eP,eO;if bf~=nil then ld,eP,eO=cx:getPlanetarySystem(0):castIntersections(d0,(bf-d0):normalize(),function(ex)return ex.radius+ex.noAtmosphericDensityAltitude end)end;if d2 then if cj>=b5-50 then b2=false;if not aZ and not bl then aW=true;cD.cmdThrottle(0)end else b5=antigrav.getBaseAltitude()end elseif f3(qH)<15 and cj/b5>0.75 then b2=false;if not ce then if d4 and not u then d.control.cancelCurrentControlMasterMode()end elseif ce and cY<iy then aZ=true;ce=false;b0=false;b2=false;cD.cmdThrottle(0)elseif ce then cD.cmdThrottle(0)aW=true end elseif ce and ci==0 and c4~=nil and(ld==nil or ld.name==c4.name)then aZ=true;ce=false;b0=false;b2=false;if not d4 then cD.cmdThrottle(0)end;b6=true end end;local rC=cg>-1;local rD=d5;if(bl or ce or da)and not rC and cY>aG and ci>0.01 then local mo=math.rad(f3(d6))rD=d5*f3(math.cos(mo))+q6*math.sin(mo)end;local rE=dq(qH-rD,-M*0.80,M*0.80)if ci<0.01 and bl then rE=dq(qH-rD,-85,O)elseif ci<0.01 then rE=dq(qH-rD,-O,O)end;if f3(d6)<5 or bl or da or b1 or rC or b0 then if qZ==nil then qZ=pid.new(5*0.01,0,5*0.1)end;qZ:inject(rE)local qJ=qZ:get()bT=bT+qJ end end;if antigrav~=nil and(antigrav and not q and cj<200000)then if bq==nil or bq<1000 then bq=1000 end;if rF~=bq then rF=bq;antigrav.setBaseAltitude(rF)end end end;function pc.ToggleIntoOrbit()cQ=false;pn=nil;po=nil;pt=0;if ci==0 then if bu then f_("orOff","AP")bu=false;pp=false;ps=nil;cI=p;if b0 then b0=false;b2=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pr=false elseif dc then f_("orOn","AP")bu=true;cI=true;if ps==nil then ps=iJ end;if b0 then b0=false;b2=false end else c0="Unable to engage auto-orbit, not near a planet"end else bu=false;pp=false;ps=nil;cI=p;if b0 then b0=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pr=false end end;function pc.ToggleVerticalTakeoff()b0=false;if b4 then l9=true;b3=false;b2=false;b1=true;cI=true;c7=0;if ch and cg==-1 then b1=false;b0=true;c7=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cD.cmdCruise(bE(cL))end else cQ=false;bh=false;d.control.retractLandingGears()ie:setTargetGroundAltitude(X)aW=true end;b4=not b4 end;function pc.checkLOS(pT)local ld,eO,eP=cx:getPlanetarySystem(0):castIntersections(d0,pT,function(ex)if ex.noAtmosphericDensityAltitude>0 then return ex.radius+ex.noAtmosphericDensityAltitude else return ex.radius+ex.surfaceMaxAltitude*1.5 end end)local le=eO;if eP~=nil and eO~=nil then le=math.min(eP,eO)end;if le~=nil then return ld,le else return nil,nil end end;function pc.ToggleAutopilot()local function rG(bs)dd=false;bl=not bl;if bl then a_=false;if not b0 and not bs then cD.ToggleAltitudeHold()end end;lh="Proceeding to Waypoint"end;local rH=false;if bG-pm<1.5 and ci>0 then if not cS then c0="No space engines detected, Orbital Hop not supported"return end;if iJ.hasAtmosphere then if ci>0 then b5=iJ.noAtmosphericDensityAltitude+T;f_("orH","OH")end;pm=-1;if aZ or bl or bu then return end end else pm=bG end;qy=false;if(bg>0 or#pu>0)and not aZ and not bl and not ce and not bu then if 0.5*d:maxForceForward()/b.g()<cl then c0="WARNING: Heavy Loads may affect autopilot performance."ca=5 end;if#pu>0 and not cf then bg=pu[1]cC.UpdateAutopilotTarget()table.remove(pu,1)c0="Route Autopilot in Progress"local pZ=g9.position-d0;local rc=pZ:project_on_plane(cZ):len()if rc>50000 and g9.planetname==iJ.name then rH=true end end;cC.UpdateAutopilotTarget()cD.showWayPoint(c4,bf)if g9~=nil then bo=nil;bs=g9.planetname=="Space"if bs then f_("apSpc","AP")if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end elseif iJ.name==g9.planetname then l9=true;if ci>0 then if not bl then f_("vtt","AP")rG(bs)if rH then b5=iJ.noAtmosphericDensityAltitude+T end end else f_("apOn","AP")if not(c4.name==iJ.name and cj<gt*1.5)then cQ=false;aZ=true elseif not ch then if bu then cD.ToggleIntoOrbit()end;cP=iJ.noAtmosphericDensityAltitude+T;pr=true;cO.AutopilotAlign=true;cO.VectorToTarget=true;pp=false;if not bu then cD.ToggleIntoOrbit()end end end else f_("apP","AP")aX=false;aY=false;if ci~=0 then ce=true;cD.ToggleAltitudeHold()else aZ=true end end elseif ci==0 then if g9==nil and(c4.name==iJ.name and dc)and not bu then qP=false;cQ=false;pp=false;cD.ToggleIntoOrbit()else f_("apP","AP")aZ=true;aX=false;aY=false;b7=false;bZ=false;b0=false;b1=false;b3=false;b2=false;bP=false;bo=nil;qP=false end else f_("apP","AP")ce=true;cD.ToggleAltitudeHold()end else f_("apOff","AP")cD.ResetAutopilots(1)end end;function pc.routeWP(rI,rJ,rK)if rK then if rK==1 then pu={}pu=ii(pu,bz)if#pu>0 then c0="Route Loaded"else c0="No Saved Route found on Databank"end;return pu else bz={}bz=ii(bz,pu)c0="Route Saved"pb()return end end;if rI then return pu end;if rJ then pu={}c0="Current Route Cleared"else pu[#pu+1]=bg;c0="Added "..g9.name.." to route. "end;return pu end;function pc.cmdThrottle(dQ,rL)if ie:getAxisCommandType(0)~=axisCommandType.byThrottle and not rL then d.control.cancelCurrentControlMasterMode()end;ie:setThrottleCommand(axisCommandId.longitudinal,dQ)bK=dq(ih(dQ*100,0)/100,-1,1)d3=nil end;function pc.cmdCruise(dQ,rL)if ie:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not rL then d.control.cancelCurrentControlMasterMode()end;ie:setTargetSpeedCommand(axisCommandId.longitudinal,dQ)d3=dQ end;function pc.ToggleLockPitch()if bo==nil then f_("lkPOn","LP")if not b_ then bo=d5 else bo=Q end;b2=false;b0=false;b1=false else f_("lkPOff","LP")bo=nil end end;function pc.ToggleAltitudeHold()if bG-pl<1.5 then if iJ.hasAtmosphere then if ci>0 then b5=iJ.spaceEngineMinAltitude-0.01*iJ.noAtmosphericDensityAltitude;f_("11","EP")else if dc then b5=iJ.noAtmosphericDensityAltitude+T;cP=b5;pr=true;if not bu then cD.ToggleIntoOrbit()end;pp=true end end;pl=-1;if b0 or bu or b4 then return end end else pl=bG end;if dc and ci==0 then cP=cj;pr=true;pp=true;cD.ToggleIntoOrbit()if bu then pl=bG else pl=0 end;return end;b0=not b0;b1=false;b3=false;if b0 then aZ=false;aY=false;aX=false;bZ=false;cI=true;bo=nil;cQ=false;if cg~=-1 and cY<20 then f_("lfs","LS")b2=true;if pl>-1 then b5=cj+W end;bh=false;d.control.retractLandingGears()aW=true;ie:setTargetGroundAltitude(X)if aV and d1 then cD.ToggleVerticalTakeoff()end else f_("altOn","AH")b2=false;if pl>-1 then if dc then b5=cj end end;if b4 then cD.ToggleVerticalTakeoff()end end;if ce then b5=100000 end else f_("altOff","AH")if bu then cD.ToggleIntoOrbit()end;if b4 then cD.ToggleVerticalTakeoff()end;cI=p;b2=false;bl=false;pl=0 end end;function pc.ResetAutopilots(pc)if pc then ce=false;aZ=false;b7=false;bP=false;b5=cj;qy=false end;bl=false;b2=false;b3=false;aY=false;b1=false;rM=false;da=nil;if not d2 then b0=false;bo=nil end;if b4 then cD.ToggleVerticalTakeoff()end;if bu then cD.ToggleIntoOrbit()end;cI=p;cd=false;cf=false;c7=0 end;function pc.BrakeToggle()aW=not aW;if b1 then b1=false;cI=p end;if aW then f_("bkOn","B",1)cD.ResetAutopilots()else f_("bkOff","B",1)end end;function pc.BeginReentry()if b3 then c0="Re-Entry cancelled"f_("reOff","RE")b3=false;cI=p;b0=false elseif not iJ.hasAtmosphere then c0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ca=5 elseif not bQ then b3=true;if ie:getAxisCommandType(0)~=rN.cruise then d.control.cancelCurrentControlMasterMode()end;cI=true;aW=false;c0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cL;f_("par","RE")else b3=true;b0=true;cI=true;aW=false;b5=iJ.surfaceMaxAltitude+Z;if b5>iJ.spaceEngineMinAltitude then b5=iJ.spaceEngineMinAltitude-0.01*iJ.noAtmosphericDensityAltitude end;local rO=ik(b5)c0="Beginning Re-entry.  Target speed: "..cL.." Target Altitude: "..rO;f_("glide","RE")cD.cmdCruise(bE(cL))end;b2=false end;function pc.ToggleAntigrav()if antigrav and not q then if d2 then f_("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bq==nil then bq=cj end;if bq<1000 then bq=1000 end;f_("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pc.changeSpd(rP)local rQ=1;if rP then rQ=-1 end;if not b_ then if u and not oI and cm then local rR=bK;bK=ih(dq(bK+rQ*az/100,-1,1),2)if bK>=0 and rR<0 then bK=0;cm=false end elseif oI then if ci>0 or b3 then cL=dq(cL+rQ*az,0,U)elseif aZ then _=dq(_+rQ*az/3.6*100,0,8333.00)end else ie:updateCommandFromActionStart(axisCommandId.longitudinal,rQ*az)end else if aZ or bl or ce or bu then dg=dg+1*rQ*-1;if dg>#d7 then dg=1 end;if dg<1 then dg=#d7 end else if not rP then rQ=1 else rQ=nil end;cC.adjustAutopilotTargetIndex(rQ)end end end;function pc.TenthTick()local function rS(gC,rT)if gC==nil then gC=b.g()end;gC=ih(gC,5)if rT~=nil and rT or(pv==nil or pv~=gC)then local fv=cW:len()local rU=ib(c.getData()).maxBrake;if rU~=nil and rU>0 and ch then rU=rU/dq(fv/100,0.1,1)rU=rU/ci;if ci>0.10 then if bp then bp=(bp+rU)/2 else bp=rU end end end;if rU~=nil and rU>0 then bn=rU end;pv=gC end end;rS(nil,true)if d3~=nil then if ie:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ie:getTargetSpeed(axisCommandId.longitudinal)~=d3 then cD.cmdCruise(d3)else d3=nil end end end;function pc.SatNavTick()if not r then return end;pw=dbHud_1.getStringValue("SPBAutopilotTargetName")if pw~=nil and pw~=""and pw~="SatNavNotChanged"then local dK=ib(dbHud_1.getStringValue("SavedLocations"))if dK~=nil then bk=dK;local gx=-1;local gD;for dP,dB in pairs(bk)do if dB.name and dB.name=="SatNav Location"then gx=dP;break end end;if gx~=-1 then gD=bk[gx]gx=-1;for dP,dB in pairs(e[0])do if dB.name and dB.name=="SatNav Location"then gx=dP;break end end;if gx>-1 then e[0][gx]=gD end;cC.UpdateAtlasLocationsList()c0=gD.name.." position updated"end end;for K=1,#d7 do if d7[K].name==pw then bg=K;a.print("Index = "..bg.." "..d7[K].name)cC.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;cg=pB()return pc end;local function rV(d,b,c,a,e,vBooster,hover,antigrav,ia,dbHud_2,gyro,id,ie,ig,rW,gI,ih,e9,dr,dq,f_,ij,pb)local rX={}local rY=true;local rZ=5;local r_=5;local s0=rZ;local s1=r_;local s2=bG;function rX.startControl(s3)local function s4(rP)local rQ=1;local function s5(s6,rP)local s7={iJ.surfaceMaxAltitude+100,iJ.spaceEngineMinAltitude-0.01*iJ.noAtmosphericDensityAltitude,iJ.noAtmosphericDensityAltitude+T,iJ.radius*(S-1)+iJ.noAtmosphericDensityAltitude}local s8=s6;for dU,dB in ipairs(s7)do if rP and s8>dB then s6=dB elseif s6<dB and not rP then s6=dB;break end end;return s6 end;if rP then rQ=-1 end;if not q and d2 then if b_ and rP then bq=1000 elseif bq~=nil then bq=bq+rQ*r_;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end else bq=rF+rQ*100 end elseif b0 or b4 or bu then if bu then if b_ then cP=s5(cP,rP)else cP=cP+rQ*rZ end;if cP<iJ.noAtmosphericDensityAltitude then cP=iJ.noAtmosphericDensityAltitude end else if b_ and ch then b5=s5(b5,rP)else b5=b5+rQ*rZ end end else ie:updateTargetGroundAltitudeFromActionStart(rQ*1.0)end end;local function s9(sa)if not ch then c0="Flight Assist in Atmo only"return end;local dy=type(sa)if da==nil then if dy=="table"then if aZ or bl then cD.ToggleAutopilot()end;f_("180On","BR")elseif sa==1 then f_("bnkLft","BR")else f_("bnkRht","BR")end;if not b0 and not aZ and not bl then cD.ToggleAltitudeHold()if dy~="table"then sa=sa+1 end end;da=sa else f_("180Off","BR")da=nil end end;if s3=="gear"then bh=not bh;if bh then bl=false;bo=nil;cD.cmdThrottle(0)if vBooster or hover then if ch and cg==-1 then f_("bklOn","BL")l9=true;b3=false;b2=false;b4=false;b0=false;b1=true;cI=true;bh=false else if bR then f_("grOut","LG",1)d.control.extendLandingGears()end;ie:setTargetGroundAltitude(Y)if ch then aW=true end end end;if bR and not b1 and not(vBooster or hover)then f_("grOut","LG",1)d.control.extendLandingGears()end else if bR then f_("grIn","LG",1)d.control.retractLandingGears()end;ie:setTargetGroundAltitude(X)end elseif s3=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif s3=="forward"then bS=bS-1 elseif s3=="backward"then if oI then s9(-cX*5000)else bS=bS+1 end elseif s3=="left"then if oI then s9(1)else bV=bV-1 end elseif s3=="right"then if oI then s9(3)else bV=bV+1 end elseif s3=="yawright"then bW=bW-1 elseif s3=="yawleft"then bW=bW+1 elseif s3=="straferight"then ie:updateCommandFromActionStart(axisCommandId.lateral,1.0)bt=1 elseif s3=="strafeleft"then ie:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bt=-1 elseif s3=="up"then c7=c7+1;ie:deactivateGroundEngineAltitudeStabilization()ie:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif s3=="down"then c7=c7-1;ie:deactivateGroundEngineAltitudeStabilization()ie:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif s3=="groundaltitudeup"then s4()elseif s3=="groundaltitudedown"then s4(true)elseif s3=="option1"then sb=false;if oI and b_ then local sc=""for K=1,#dh do sc=sc.."| Name: "..a.getPlayerName(dh[K]).." Mass: "..ih(b.getBoardedPlayerMass(dh[K])/1000,1).."t "end;a.print("Onboard: "..sc)return end;cC.adjustAutopilotTargetIndex()elseif s3=="option2"then sb=false;if oI and b_ then for K=1,#dh do b.forceDeboard(dh[K])end;c0="Deboarded All Passengers"return end;cC.adjustAutopilotTargetIndex(1)elseif s3=="option3"then local function sd()rY=not rY;if not rY then f_("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(se,atmofueltank_size,"Atmo Fuel","fuel_container")sf=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sg,spacefueltank_size,"Space Fuel","fuel_container")sh=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(si,rocketfueltank_size,"Rocket Fuel","fuel_container")sj=_autoconf.panels[_autoconf.panels_size]end;sk=a.createWidgetPanel("Docking")sl=a.createWidget(sk,"parenting")a.addDataToWidget(c.getDataId(),sl)sm=a.createWidgetPanel("Core combat stress")sn=a.createWidget(sm,"core_stress")a.addDataToWidget(b.getDataId(),sn)if ia~=nil then ia.show()end else f_("hud","DH")c.hide()b.hide()if sf~=nil then gI(sf)sf=nil end;if sk~=nil then gI(sk)sk=nil end;if sm~=nil then gI(sm)sm=nil end;if sh~=nil then gI(sh)sh=nil end;if sj~=nil then gI(sj)sj=nil end;if ia~=nil then ia.hide()end end end;sb=false;if oI and b_ then local sc=""for K=1,#di do sc=sc.."| ID: "..di[K].." Mass: "..ih(b.getDockedConstructMass(di[K])/1000,1).."t "end;a.print("Docked Ships: "..sc)return end;if y then if x then x=false else x=true end end;sd()elseif s3=="option4"then sb=false;if oI and b_ then for K=1,#di do b.forceUndock(di[K])end;c0="Undocked all ships"return end;da=nil;cD.ToggleAutopilot()elseif s3=="option5"then sb=false;cD.ToggleLockPitch()elseif s3=="option6"then sb=false;if oI and b_ then if ia then local so=ia.getVentingCooldown()if so>0 then c0="Cannot vent again for "..so.." seconds"return end;if ia.getShieldHitpoints()<ia.getMaxShieldHitpoints()then ia.startVenting()c0="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c0="Shields already at max hitpoints"end;return else c0="No shield found"return end end;cD.ToggleAltitudeHold()elseif s3=="option7"then sb=false;if oI and b_ then if ia then ia.toggle()return else c0="No shield found"return end end;F=not F;if F then c0="Collision System Enabled"else c0="Collision System Secured"end elseif s3=="option8"then sb=false;if oI and b_ then if bg>0 and g9~=nil then cD.routeWP()else c0="Select a saved wp on IPH to add to or remove from route"end;return end;bw=not bw;if not bw then c0="DeCoupled Mode - Ground Stabilization off"ie:deactivateGroundEngineAltitudeStabilization()f_("gsOff","GS")else c0="Coupled Mode - Ground Stabilization on"ie:activateGroundEngineAltitudeStabilization(sp)d:setEngineForceCommand('hover',vec3(),1)f_("gsOn","GS")end elseif s3=="option9"then sb=false;if oI and b_ then ie:resetCommand(axisCommandId.longitudinal)ie:resetCommand(axisCommandId.lateral)ie:resetCommand(axisCommandId.vertical)cD.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cn=gyro.getState()==1;if cn then f_("gyOn","GA")else f_("gyOff","GA")end else c0="No gyro found"end elseif s3=="lshift"then df=false;if oI then b_=true end;if ig()==1 then b_=true;bd=ig()rW(1)elseif id()==1 and z then b_=true;cH=false;cG=false end elseif s3=="brake"then if aU or oI then cD.BrakeToggle()elseif not aW then cD.BrakeToggle()else aW=true end elseif s3=="lalt"then sb=true;oI=true;if id()==0 and not i and g=="keyboard"then rW(1)end elseif s3=="booster"then if n then d:toggleBoosters()elseif not c1 then if not sq then d:toggleBoosters()sq=true end;c1=true else if sq then d:toggleBoosters()sq=false end;c1=false end elseif s3=="stopengines"then local function sr()if bG-s2<1.5 then f_("clear","CA")b6=false;b8=false;b9=false;aZ=false;b7=false;bb="Aligning"aX=false;aY=false;da=nil;b0=false;b3=false;b1=false;aW=false;b2=false;b4=false;bZ=false;bP=false;cd=false;ce=false;bQ=false;cI=p;bl=false;a_=false;cn=false;bo=nil;bu=false end end;sr()s2=bG;if ie:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bK~=0 then ie:resetCommand(axisCommandId.longitudinal)cD.cmdThrottle(0)else cD.cmdThrottle(100)end else if ie:getTargetSpeed(axisCommandId.longitudinal)~=0 then ie:resetCommand(axisCommandId.longitudinal)else if ch then cD.cmdCruise(U)else cD.cmdCruise(_*3.6)end end end elseif s3=="speedup"then cD.changeSpd()elseif s3=="speeddown"then cD.changeSpd(true)elseif s3=="antigravity"and not q then if antigrav~=nil then cD.ToggleAntigrav()else c0="No antigrav found"end end end;function rX.stopControl(s3)local function ss()if not q and d2 then s1=r_ end;if b0 or b4 or bu then s0=rZ end end;if s3=="forward"then bS=0 elseif s3=="backward"then bS=0 elseif s3=="left"then if da then if da==2 then da=-2 else da=-1 end end;bV=0 elseif s3=="right"then if da then if da==4 then da=-2 else da=-1 end end;bV=0 elseif s3=="yawright"then bW=0 elseif s3=="yawleft"then bW=0 elseif s3=="straferight"then ie:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bt=0 elseif s3=="strafeleft"then ie:updateCommandFromActionStop(axisCommandId.lateral,1.0)bt=0 elseif s3=="up"then c7=0;ie:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bw then ie:activateGroundEngineAltitudeStabilization(sp)d:setEngineForceCommand('hover',vec3(),1)end elseif s3=="down"then c7=0;ie:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bw then ie:activateGroundEngineAltitudeStabilization(sp)d:setEngineForceCommand('hover',vec3(),1)end elseif s3=="groundaltitudeup"then ss()sb=false elseif s3=="groundaltitudedown"then ss()sb=false elseif s3=="lshift"then if ig()==1 then c8=0;c9=0;rW(bd)elseif id()==1 and z then cH=false;cG=false end;b_=false elseif s3=="brake"then if not aU and not oI then if aW then cD.BrakeToggle()else aW=false end end elseif s3=="lalt"then if id()==0 and i then if sb then if ig()==1 then rW(0)else rW(1)end else sb=true end elseif id()==0 and not i and g=="keyboard"then rW(0)end;oI=false end end;function rX.loopControl(s3)local function st(rP)local rQ=1;if rP then rQ=-1 end;if not q and d2 then if bq~=nil then bq=bq+rQ*s1;if bq<1000 then bq=1000 end;if b0 and bq<b5+10 and bq>b5-10 then b5=bq end;s1=dq(s1*1.05,r_,50)aW=false else bq=rF+rQ*100;aW=false end elseif b0 or b4 or bu then if bu then cP=cP+rQ*s0;if cP<iJ.noAtmosphericDensityAltitude then cP=iJ.noAtmosphericDensityAltitude end else b5=b5+rQ*s0 end;s0=dq(s0*1.05,rZ,50)else ie:updateTargetGroundAltitudeFromActionLoop(rQ*1.0)end end;local function su(rP)local rQ=1;if rP then rQ=-1 end;if not b_ then if u and not oI then bK=dq(bK+rQ*aA/100,-1,1)else ie:updateCommandFromActionLoop(axisCommandId.longitudinal,rQ*aA)end end end;if s3=="groundaltitudeup"then if not b_ then st()end elseif s3=="groundaltitudedown"then if not b_ then st(true)end elseif s3=="speedup"then su()elseif s3=="speeddown"then su(true)end end;function rX.inputTextControl(rO)local function sv(sw,fB,gA)local function sx(fB)local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI='::pos{'..dH..','..dH..','..dH..','..dH..','..dH..'}'local dY,dZ,e6,e7,e8=e9(fB,dI)if dY=="0"and dZ=="0"then return vec3(dr(e6),dr(e7),dr(e8))end;e7=math.rad(e7)e6=math.rad(e6)local iJ=e[dr(dY)][dr(dZ)]local e_=math.cos(e6)local sy=vec3(e_*math.cos(e7),e_*math.sin(e7),math.sin(e6))return iJ.center+(iJ.radius+e8)*sy end;local g1=sx(fB)return cC.AddNewLocation(sw,g1,gA)end;local K;local sz,sA=nil,nil;local sB="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"K=string.find(rO," ")sz=rO;if K~=nil then sz=string.sub(rO,0,K-1)sA=string.sub(rO,K+1)end;if sz=="/help"or sz=="/commands"then for oe in string.gmatch(sB,"([^\n]+)")do a.print(oe)end;return elseif sz=="/setname"then if sA==nil or sA==""then c0="Usage: ah-setname Newname"return end;if bg>0 and g9~=nil then cC.UpdatePosition(sA)else c0="Select a saved target to rename first"end elseif ia and sz=="/resist"then if not ia then c0="No shield found"return elseif sA==nil or ia.getResistancesCooldown()>0 then c0="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dH=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dI=dH..', '..dH..', '..dH..', '..dH;local sC,sD,sE,sF=e9(sA,dI)if sF==nil or sC+sD+sE+sF>0.6 then c0="Improperly formatted or total exceeds 0.6"return end;if ia.setResistances(sC,sD,sE,sF)==1 then c0="Shield Resistances set"else c0="Resistance setting failed."end elseif sz=="/addlocation"or string.find(rO,"::pos")~=nil then local gA=false;local sw="0-Temp"if sA==nil or sA==""then sA=sz;gA=true end;K=string.find(sA,"::")if not gA then sw=string.sub(sA,1,K-2)end;local fB=string.sub(sA,K)sv(sw,fB,gA)elseif sz=="/agg"then if sA==nil or sA==""then c0="Usage: /agg targetheight"return end;sA=dr(sA)if sA<1000 then sA=1000 end;bq=sA;c0="AGG Target Height set to "..sA elseif sz=="/G"then if sA==nil or sA==""then c0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sA=="dump"then for dP,dB in pairs(ij())do if type(dB.get())=="boolean"then if dB.get()==true then a.print(dP.." true")else a.print(dP.." false")end elseif dB.get()==nil then a.print(dP.." nil")else a.print(dP.." "..dB.get())end end;return end;K=string.find(sA," ")local sG=string.sub(sA,0,K-1)local sH=string.sub(sA,K+1)for dP,dB in pairs(ij())do if dP==sG then c0="Variable "..sG.." changed to "..sH;local sI=type(dB.get())if sI=="number"then sH=dr(sH)if dP=="AtmoSpeedLimit"then cL=sH end elseif sI=="boolean"then if string.lower(sH)=="true"then sH=true else sH=false end end;dB.set(sH)return end end;c0="No such global variable: "..sG elseif sz=="/deletewp"then if bg>0 and g9~=nil then cC.ClearCurrentPosition()else c0="Select a custom wp to delete first in IPH"end elseif sz=="/copydatabank"then if dbHud_2 then pb(true)else c0="Spare Databank required to copy databank"end elseif sz=="/iphWP"then if bg>0 then a.print(cD.showWayPoint(c4,bf,true))c0="::pos waypoint shown in lua chat"else c0="No target selected in IPH"end end end;function rX.tagTick()if bx=="Off"then bx="All"elseif bx=="All"then bx="Longitude"elseif bx=="Longitude"then bx="Lateral"elseif bx=="Lateral"then bx="Vertical"else bx="Off"end;c0="Extra Engine Tags: "..bx;c.stopTimer("tagTick")end;return rX end;local function sJ(d,b,c,a,library,e,vBooster,hover,pa,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ia,gyro,warpdrive,sK)local sL={}local dp=string.format;local ib=json.decode;local sM=json.encode;local sN=b.getElementMaxHitPointsById;local ic=b.getElementMassById;local id=d.control.isRemoteControlled;local e9=string.match;local gI=a.destroyWidgetPanel;local fY=a.updateData;local fZ=a.addDataToWidget;local rW=a.lockView;local ig=a.isViewLocked;local ds=math.sqrt;local dr=tonumber;local f3=math.abs;local bE=math.floor;local bF=c.getAtmosphereDensity;local eZ=math.atan;local bD=a.getTime;local dq=utils.clamp;local ie=d.axisCommandManager;local sO=Y;local gK=13;local sP=b.getElementIdList()local sQ={}local sR=0;local function dt(eH,eI)if eH==0 then return f3(eI)<1e-09 end;if eI==0 then return f3(eH)<1e-09 end;return f3(eH-eI)<math.max(f3(eH),f3(eI))*dG end;local function ih(dH,sS)local rQ=10^(sS or 0)return bE(dH*rQ+0.5)/rQ end;local function ii(sT,sU)for dP,dB in pairs(sU)do if type(dP)=="string"then sT[dP]=dB else sT[#sT+1]=sU[dP]end end;return sT end;local function ij(sV)local sW={}if not sV then ii(sW,J)ii(sW,a7)ii(sW,ay)ii(sW,aT)return sW elseif sV=="boolean"then return J elseif sV=="handling"then return a7 elseif sV=="hud"then return ay elseif sV=="physics"then return aT end end;local function pb(sX)local function sY(sZ)for dP,dB in pairs(sZ)do dbHud_1.setStringValue(dP,sM(dB.get()))if sX and dbHud_2 then dbHud_2.setStringValue(dP,sM(dB.get()))end end end;if dbHud_1 then sY(bA)sY(ij())a.print("Saved Variables to Datacore")if sX and dbHud_2 then c0="Databank copied.  Remove copy when ready."end end end;local function f_(s_,t0,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..s_.."|"..t0 .."|"..ax)else a.logInfo("sound_notification|audiopacks/"..h.."/"..s_.."|"..t0 .."|"..ax)end else a.logInfo("sound_q|audiopacks/"..h.."/"..s_.."|"..t0 .."|"..ax)end end;local function gJ(hj,hk,rO,jn,t1)if jn==nil then jn=""end;if t1==nil then t1=""end;return dp([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jn,hj,hk,t1,rO)end;local function ik(cb,t2)local t3=cb>100000;if t2==nil then t2=1 end;if t3 then return ih(cb/1000/200,t2).."SU"elseif cb<1000 then return ih(cb,t2).."M"else return ih(cb/1000,t2).."KM"end end;local function il(t4)local t5=0;local t6=0;local t7=0;if t4<60 then t4=bE(t4)elseif t4<3600 then t5=bE(t4/60)t4=bE(t4%60)elseif t4<86400 then t6=bE(t4/3600)t5=bE(t4%3600/60)else t7=bE(t4/86400)t6=bE(t4%86400/3600)end;if t7>0 then return t7 .."d "..t6 .."h "elseif t6>0 then return t6 .."h "..t5 .."m "elseif t5>0 then return t5 .."m "..t4 .."s"elseif t4>0 then return t4 .."s"else return"0s"end end;function sL.onStart()local t8=false;local function t9()local function ta(tb)local tc=dbHud_1.hasKey;for dP,dB in pairs(tb)do if tc(dP)then local dK=ib(dbHud_1.getStringValue(dP))if dK~=nil then dB.set(dK)t8=true end end end end;if dbHud_1 then if not f then ta(ij())coroutine.yield()ta(bA)else ta(bA)c0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ca=5;t8=false end;coroutine.yield()if t8 then c0="Loaded Saved Variables"cr=a8;cs=a9;aU=j;g=string.lower(g)cI=p;cL=U;co=[[rgb(]]..bE(bH+0.5)..","..bE(bJ+0.5)..","..bE(bI+0.5)..[[)]]cp=[[rgb(]]..bE(bH*0.9+0.5)..","..bE(bJ*0.9+0.5)..","..bE(bI*0.9+0.5)..[[)]]elseif not f then c0="No Saved Variables Found - Exit HUD to save settings"end;if by<1.500 then if T<2000 then c0="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;by=VERSION_NUMBER else c0="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if br+180<bG then bp=0 end;br=bG;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ca=7 end;if antigrav and not q then if bq==nil then bq=cj end;antigrav.setBaseAltitude(bq)end;lh="Proceeding to Waypoint"end;local function td()local function te(tf,tg)if tf>tg then tg=tf end;local th,ti=0,0;if a5>0 then th=a5*0.05 end;if a6>0 then ti=a6*0.05 end;tg=tg*(1-(th+ti))return tg end;local tj=b.getElementNameById;local tk=ap~=0 and aq~=0;for dP in pairs(sP)do local type=b.getElementTypeById(sP[dP])if e9(type,'^.*Atmospheric Engine$')then if e9(tostring(b.getElementTagsById(sP[dP])),'^.*vertical.*$')and b.getElementForwardById(sP[dP])[3]>0 then d1=true end end;if e9(type,'^.*Space Engine$')then cS=true;if e9(tostring(b.getElementTagsById(sP[dP])),'^.*vertical.*$')then local tl=b.getElementForwardById(sP[dP])if tl[3]<0 then tm=true else cR=true end end end;if type=="Landing Gear"then bR=true end;if type=="Dynamic Core Unit"then local tn=sN(sP[dP])if tn>10000 then gK=110 elseif tn>1000 then gK=55 elseif tn>150 then gK=27 end end;sR=sR+sN(sP[dP])if tk and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local tn=sN(sP[dP])local o4=ic(sP[dP])local tf=0;local jh=bD()if type=="Atmospheric Fuel Tank"then local tg=400;local to=35.03;if tn>10000 then tg=51200;to=5480 elseif tn>1300 then tg=6400;to=988.67 elseif tn>150 then tg=1600;to=182.67 end;tf=o4-to;if a2>0 then tg=tg+tg*a2*0.2 end;tg=te(tf,tg)ct[#ct+1]={sP[dP],tj(sP[dP]),tg,to,tf,jh}end;if type=="Rocket Fuel Tank"then local tg=320;local to=173.42;if tn>65000 then tg=40000;to=25740 elseif tn>6000 then tg=5120;to=4720 elseif tn>700 then tg=640;to=886.72 end;tf=o4-to;if a4>0 then tg=tg+tg*a4*0.1 end;tg=te(tf,tg)cv[#cv+1]={sP[dP],tj(sP[dP]),tg,to,tf,jh}end;if type=="Space Fuel Tank"then local tg=600;local to=35.03;if tn>10000 then tg=76800;to=5480 elseif tn>1300 then tg=9600;to=988.67 elseif tn>150 then tg=2400;to=182.67 end;tf=o4-to;if a3>0 then tg=tg+tg*a3*0.2 end;tg=te(tf,tg)cu[#cu+1]={sP[dP],tj(sP[dP]),tg,to,tf,jh}end end end;if not d1 then b4,aV=false,false end end;local function tp()if gyro~=nil then cn=gyro.getState()==1 end;if not bw then ie:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then rW(1)else rW(0)end;if door and(ch or not ch and cj<10000)then for dU,dB in pairs(door)do dB.toggle()end end;if switch then for dU,dB in pairs(switch)do dB.toggle()end end;if forcefield and(ch or not ch==0 and cj<10000)then for dU,dB in pairs(forcefield)do dB.toggle()end end;if antigrav then d2=antigrav.getState()==1;if d2 and not q then antigrav.show()end end;if id()==1 and k then a.freeze(1)else a.freeze(0)end;if bR then bh=d.control.isAnyLandingGearExtended()==1;if bh then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if cg~=-1 or not ch and cW:len()<50 then aW=true;bh=true;if bR then d.control.extendLandingGears()end else aW=false end;ie:setTargetGroundAltitude(sO)if ch and cg~=-1 then cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;p4=ch end;local function tq()local tr={}local function ts()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tt={[1]=4480,[6]=4480,[7]=6270}for tu,tv in pairs(e)do e[tu][0]=ts()e[tu][0].systemId=tu;tr[tu]={}for tw,iJ in pairs(e[tu])do iJ.gravity=iJ.gravity/9.8;iJ.center=vec3(iJ.center)iJ.name=iJ.name[1]iJ.noAtmosphericDensityAltitude=iJ.atmosphereThickness or iJ.atmosphereRadius-iJ.radius;iJ.spaceEngineMinAltitude=tt[iJ.id]or 0.68377*(iJ.atmosphereThickness or iJ.atmosphereRadius-iJ.radius)iJ.planetarySystemId=tu;iJ.bodyId=iJ.id;tr[tu][tw]=iJ;if ma==nil or iJ.center.x<ma then ma=iJ.center.x end;if m9==nil or iJ.center.x>m9 then m9=iJ.center.x end;if md==nil or iJ.center.y<md then md=iJ.center.y end;if mc==nil or iJ.center.y>mc then mc=iJ.center.y end;if iJ.center and iJ.name~="Space"then dj[#dj+1]=iJ end end end;ej=dn(d,b,c,a,dp,dq,dr,ds,dt)cx=ej(tr)cy=f2(d,b,c,a,ds,f3)cA=fx(d,b,c,a,dp,dq,dr,ds,dt)cC=fX(d,b,c,a,dbHud_1,e,fY,fZ,bE,dr,ds,f_)end;tx=false;ty=coroutine.create(function()ie:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})t9()coroutine.yield()td()coroutine.yield()cD=p9(d,b,c,a,e,vBooster,hover,pa,antigrav,warpdrive,dbHud_1,f3,bE,bF,id,eZ,bD,dq,ie,fY,ig,ds,ih,f_,ii,dt,ik,il,pb,ib,dp,fZ)tp()coroutine.yield()tq()cE=gH(b,a,c,library,radar_1,radar_2,f3,gI,ds,gJ,dr,gK,f_)cB=i9(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ia,warpdrive,f3,bE,dp,ib,bF,ic,id,eZ,bD,dq,ie,fZ,fY,gI,ig,ds,ih,gJ,f_,ii,ij,ik,il)cB.ButtonSetup()cF=rV(d,b,c,a,e,vBooster,hover,antigrav,ia,dbHud_2,gyro,id,ie,ig,rW,gI,ih,e9,dr,dq,f_,ij,pb)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aO)c.setTimer("radarTick",aO)c.setTimer("hudTick",aP)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)f_("start","SU")end)coroutine.resume(ty)end;function sL.onUpdate()if not tx then local hZ=coroutine.status(ty)if hZ=="suspended"then local dQ,h_=coroutine.resume(ty)if h_ then a.print("ERROR STARTUP: "..h_)end elseif hZ=="dead"then tx=true end end;if tx then d:update()if ch and u and d4 then if d4 and bO then cD.cmdThrottle(0)bO=false elseif not d4 and not bO then bK=0;bO=true end end;if dm then ie:setThrottleCommand(axisCommandId.longitudinal,dm)dm=nil end;if not cG and oK~=tz then a.setScreen(oK)end;tz=oK end end;function sL.onFlush()local function tA(tB,qX)local tC=vec3()local tD=vec3()if tB==axisCommandId.longitudinal then tC=vec3(b.getConstructOrientationForward())tD=cU elseif tB==axisCommandId.vertical then tC=vec3(b.getConstructOrientationUp())tD=cT elseif tB==axisCommandId.lateral then tC=vec3(b.getConstructOrientationRight())tD=cV else return vec3()end;local tE=vec3(b.getWorldGravity())local tF=tE:dot(tD)local tG=vec3(b.getWorldAirFrictionAcceleration())local tH=tG:dot(tD)local tI=cW:dot(tC)local tJ=qX*constants.kph2m;if tK==nil then tK=pid.new(10,0,10.0)end;tK:inject(tJ-tI)local tL=tK:get()local tM=(tL-tH-tF)*tD;return tM end;local function tN(tB,qX)local tC=vec3()local tD=vec3()if tB==axisCommandId.longitudinal then tC=vec3(b.getConstructOrientationForward())tD=cU elseif tB==axisCommandId.vertical then tC=vec3(b.getConstructOrientationUp())tD=cT elseif tB==axisCommandId.lateral then tC=vec3(b.getConstructOrientationRight())tD=cV else return vec3()end;local tE=vec3(b.getWorldGravity())local tF=tE:dot(tD)local tG=vec3(b.getWorldAirFrictionAcceleration())local tH=tG:dot(tD)local tI=cW:dot(tC)local tJ=qX*constants.kph2m;if tO==nil then tO=pid.new(10,0,10.0)end;tO:inject(tJ-tI)local tL=tO:get()local tM=(tL-tH-tF)*tD;return tM end;local function tP(tQ,jw,g6)local tR=tQ:cross(g6):normalize_inplace()local kh=math.acos(dq(tR:dot(-jw),-1,1))*constants.rad2deg;if tR:cross(-jw):dot(g6)<0 then kh=-kh end;return kh end;if antigrav and not q then if not d2 and antigrav.getBaseAltitude()~=bq then antigrav.setBaseAltitude(bq)end end;d4=ie:getAxisCommandType(0)==axisCommandType.byThrottle;aJ=math.max(aJ,0.01)aK=math.max(aK,0.01)aE=math.max(aE,0.01)aI=math.max(aI,0.01)aL=math.max(aL,0.01)aM=math.max(aM,0.01)aD=math.max(aD,0.01)local tS=dq(bS+bT+a.getControlDeviceForwardInput(),-1,1)local tT=dq(bV+bY+a.getControlDeviceYawInput(),-1,1)local tU=dq(bW+bU-a.getControlDeviceLeftRightInput(),-1,1)local tV=bX;cZ=vec3(b.getWorldVertical())if cZ==nil or cZ:len()==0 then cZ=(iJ.center-d0):normalize()end;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getWorldVelocity())cW=vec3(b.getVelocity())d0=vec3(b.getConstructWorldPos())cl=b.getConstructMass()cY=vec3(cX):len()c_=-cZ:dot(cX)d6=getRoll(cZ,cU,cV)local tW=d6/180*math.pi;local tX=math.cos(tW)local tY=math.sin(tW)d5=tP(cZ,cU,cV*tX+cT*tY)local tZ=cX:normalize()local t_=f3(d6)local u0=utils.sign(d6)local u1=vec3(b.getWorldAngularVelocity())local u2=tS*aJ*cV+tT*aE*cU+tU*aK*cT;if cI==true and cZ:len()>0.01 then local u3=f3(cK-d6)if((aY or b3 or b1 or cd or b0 or bu)and u3>0 or ci>0.0 and u3<aF and p)and tT==0 and f3(d5)<85 then local u4=cK;local u5=aD;if ci==0 then u5=u5/4;cK=0;u4=0 end;if u6==nil then u6=pid.new(u5*0.01,0,u5*0.1)end;u6:inject(u4-d6)local u7=u6:get()u2=u2+u7*cU end end;local u8=1;local u9=0;local ua=1;bL=0;if ch and u and d4 then if ub==nil then ub=pid.new(0.1,0,1)end;ub:inject(cL/3.6-cX:dot(cU))local uc=ub:get()bN=dq(uc,-1,1)if not dm then if bN<bK and ci>0.005 then bM=true;dm=dq(bN,0.01,1)else bM=false;dm=bK end end;if ud==nil then ud=pid.new(1*0.01,0,1*0.1)end;ud:inject(cX:len()-cL/3.6)local ue=dq(ud:get(),0,1)if ci>0 and c_<-80 or ci>0.005 then bL=ue end;if bL>0 then if bM and bN==0.01 and not dm then dm=0 end else bN=dq(bN,0.01,1)end;local uf=''local ug=vec3()local uh=tA(axisCommandId.vertical,c7*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uh,u9)local ui='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ui=ui..aQ end;local uj=ie:getAxisCommandType(axisCommandId.longitudinal)local uk=ie:composeAxisAccelerationFromThrottle(ui,axisCommandId.longitudinal)local ul=tN(axisCommandId.lateral,bt*1000)uf=uf..' , '.."lateral airfoil , lateral ground "ug=ug+ul;if ug:len()>constants.epsilon then d:setEngineForceCommand(uf,ug,u9,'','','',ua)end;d:setEngineForceCommand(ui,uk,u8)local um='thrust analog vertical fueled 'local un='thrust analog lateral fueled 'if bx=="All"or bx=="Lateral"then un=un..aR end;if bx=="All"or bx=="Vertical"then um=um..aS end;if c7~=0 or b1 and aW or not bh and not bw then d:setEngineForceCommand(um,uh,u8)else d:setEngineForceCommand(um,vec3(),u8)end;if bt~=0 then d:setEngineForceCommand(un,ul,u8)else d:setEngineForceCommand(un,vec3(),u8)end;if tV==0 then tV=bL end;local uo=-tV*(aL*cX+aM*tZ)d:setEngineForceCommand('brake',uo)else if u then if not dm then dm=bK end end;local qX=c.getAxisCommandValue(0)if not d4 then if ud==nil then ud=pid.new(1*0.01,0,1*0.1)end;ud:inject(cX:len()-qX/3.6)local ue=dq(ud:get(),0,1)tV=dq(tV+ue,0,1)end;local uo=-tV*(aL*cX+aM*tZ)d:setEngineForceCommand('brake',uo)local uf=''local ug=vec3()local up=false;local ui='thrust analog longitudinal 'if bx=="All"or bx=="Longitude"then ui=ui..aQ end;local uj=ie:getAxisCommandType(axisCommandId.longitudinal)if uj==axisCommandType.byThrottle then local uk=ie:composeAxisAccelerationFromThrottle(ui,axisCommandId.longitudinal)d:setEngineForceCommand(ui,uk,u8)elseif uj==axisCommandType.byTargetSpeed then local uk=ie:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)uf=uf..' , '..ui;ug=ug+uk;if ie:getTargetSpeed(axisCommandId.longitudinal)==0 or ie:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ie:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then up=true end end;local un='thrust analog lateral 'if bx=="All"or bx=="Lateral"then un=un..aR end;local uq=ie:getAxisCommandType(axisCommandId.lateral)if uq==axisCommandType.byThrottle then local ur=ie:composeAxisAccelerationFromThrottle(un,axisCommandId.lateral)d:setEngineForceCommand(un,ur,u8)elseif uq==axisCommandType.byTargetSpeed then local ul=ie:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)uf=uf..' , '..un;ug=ug+ul end;local um='thrust analog vertical 'if bx=="All"or bx=="Vertical"then um=um..aS end;local us=ie:getAxisCommandType(axisCommandId.vertical)if us==axisCommandType.byThrottle then local uh=ie:composeAxisAccelerationFromThrottle(um,axisCommandId.vertical)if c7~=0 or b1 and aW then d:setEngineForceCommand(um,uh,u8,'airfoil','ground','',ua)else d:setEngineForceCommand(um,vec3(),u8)d:setEngineForceCommand('airfoil vertical',uh,u8,'airfoil','','',ua)d:setEngineForceCommand('ground vertical',uh,u8,'ground','','',ua)end elseif us==axisCommandType.byTargetSpeed then if c7<0 then d:setEngineForceCommand('hover',vec3(),u8)end;local ut=ie:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)uf=uf..' , '..um;ug=ug+ut end;if ug:len()>constants.epsilon then if bX~=0 or up or f3(tZ:dot(cU))<0.5 then uf=uf..', brake'end;d:setEngineForceCommand(uf,ug,u9,'','','',ua)end end;local uu=aI*(u2-u1)local uv=vec3(b.getWorldAirFrictionAngularAcceleration())uu=uu-uv;d:setEngineTorqueCommand('torque',uu,u8,'airfoil','','',ua)d:setBoosterCommand('rocket_engine')if c1 and not n then local fv=cW:len()local uw=0.15;if not d4 then local ux=ie:getTargetSpeed(axisCommandId.longitudinal)if fv*3.6>ux*(1-uw)and sq then sq=false;d:toggleBoosters()elseif fv*3.6<ux*(1-uw)and not sq then sq=true;d:toggleBoosters()end else local oW=c.getThrottle()if u then oW=bK*100 end;local qX=oW/100;if bF==0 then qX=qX*_;if fv>=qX*(1-uw)and sq then sq=false;d:toggleBoosters()elseif fv<qX*(1-uw)and not sq then sq=true;d:toggleBoosters()end else local r9=bE(cL)qX=qX*r9/3.6;if fv>=qX*(1-uw)and sq then sq=false;d:toggleBoosters()elseif fv<qX*(1-uw)and not sq then sq=true;d:toggleBoosters()end end end end end;function sL.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ci>0 or ci==0 and cj<10000)then for dU,dB in pairs(door)do dB.toggle()end end;if switch then for dU,dB in pairs(switch)do dB.toggle()end end;if forcefield and(ci>0 or ci==0 and cj<10000)then for dU,dB in pairs(forcefield)do dB.toggle()end end;x=dl;pb()if nG then nG.activate()end;if A then cD.showWayPoint(iJ,d0)end;f_("stop","SU")end;function sL.OneSecondTick()local function uy(jt)local uz=0;cq=""local uA=sR;local uB=0;local uC=0;local uD=0;local jl=0;local jm=""local uE=b.getElementHitPointsById;for dP in pairs(sP)do local tn=0;local uF=0;uF=sN(sP[dP])tn=uE(sP[dP])uB=uB+tn;if tn<uF then if tn==0 then uD=uD+1 else uC=uC+1 end;if cw and#sQ==0 then g1=vec3(b.getElementPositionById(sP[dP]))local hj=g1.x;local hk=g1.y;local hl=g1.z;table.insert(sQ,b.spawnArrowSticker(hj,hk,hl+1,"down"))table.insert(sQ,b.spawnArrowSticker(hj,hk,hl+1,"down"))b.rotateSticker(sQ[2],0,0,90)table.insert(sQ,b.spawnArrowSticker(hj+1,hk,hl,"north"))table.insert(sQ,b.spawnArrowSticker(hj+1,hk,hl,"north"))b.rotateSticker(sQ[4],90,90,0)table.insert(sQ,b.spawnArrowSticker(hj-1,hk,hl,"south"))table.insert(sQ,b.spawnArrowSticker(hj-1,hk,hl,"south"))b.rotateSticker(sQ[6],90,-90,0)table.insert(sQ,b.spawnArrowSticker(hj,hk-1,hl,"east"))table.insert(sQ,b.spawnArrowSticker(hj,hk-1,hl,"east"))b.rotateSticker(sQ[8],90,0,90)table.insert(sQ,b.spawnArrowSticker(hj,hk+1,hl,"west"))table.insert(sQ,b.spawnArrowSticker(hj,hk+1,hl,"west"))b.rotateSticker(sQ[10],-90,0,90)table.insert(sQ,sP[dP])end elseif cw and#sQ>0 and sQ[11]==sP[dP]then for jg in pairs(sQ)do b.deleteSticker(sQ[jg])end;sQ={}end end;uz=bE(uB/uA*100)if uz<100 then jt[#jt+1]=gJ(0,0,"","pbright txt")jl=bE(uz*2.55)jm=dp("rgb(%d,%d,%d)",255-jl,jl,0)if uz<100 then jt[#jt+1]=gJ("50%",1035,"Elemental Integrity: "..uz.."%","txtbig txtmid","fill:"..jm)if uD>0 then jt[#jt+1]=gJ("50%",1055,"Disabled Modules: "..uD.." Damaged Modules: "..uC,"txtbig txtmid","fill:"..jm)elseif uC>0 then jt[#jt+1]=gJ("50%",1055,"Damaged Modules: "..uC,"txtbig txtmid","fill:"..jm)end end end end;local function uG()if sK then if uH==nil and(i7~=nil or bh)then _autoconf.displayCategoryPanel(sK,weapon_size,"Weapons","weapon",true)uH=_autoconf.panels[_autoconf.panels_size]elseif uH~=nil and i7==nil and not bh then gI(uH)uH=nil end end end;local function p6()local jh=bD()local kE=cY;local p7=jh-ck;if kE>1.38889 then kE=kE/1000;local p8=kE*(jh-ck)bi=bi+p8;c5=c5+p8 end;c6=c6+p7;bj=bj+p7;ck=jh end;p6()dh=b.getPlayersOnBoard()di=b.getDockedConstructs()uG()local jt={}cB.OneSecondTick(jt)if s then uy(jt)end;cc=table.concat(jt,"")collectgarbage("collect")end;function sL.controlStart(s3)cF.startControl(s3)end;function sL.controlStop(s3)cF.stopControl(s3)end;function sL.controlLoop(s3)cF.loopControl(s3)end;function sL.controlInput(rO)cF.inputTextControl(rO)end;function sL.radarEnter(dZ)cE.onEnter(dZ)end;function sL.radarLeave(dZ)cE.onLeave(dZ)end;function sL.onTick(uI)if uI=="tenthSecond"then cD.TenthTick()cB.TenthTick()elseif uI=="oneSecond"then uJ.OneSecondTick()elseif uI=="fiveSecond"then cD.SatNavTick()elseif uI=="msgTick"then cB.MsgTick()elseif uI=="animateTick"then cB.AnimateTick()elseif uI=="hudTick"then cB.hudtick()elseif uI=="apTick"then cD.APTick()elseif uI=="radarTick"then cE.UpdateRadar()elseif uI=="tagTick"then cF.tagTick()elseif uI=="contact"then cE.ContactTick()end end;return sL end;function script.onStart()uJ.onStart()end;function script.onStop()uJ.onStop()end;function script.onTick(uI)uJ.onTick(uI)end;function script.onFlush()uJ.onFlush()end;function script.onUpdate()uJ.onUpdate()end;function script.onActionStart(s3)uJ.controlStart(s3)end;function script.onActionStop(s3)uJ.controlStop(s3)end;function script.onActionLoop(s3)uJ.controlLoop(s3)end;function script.onInputText(rO)uJ.controlInput(rO)end;function script.onEnter(dZ)uJ.radarEnter(dZ)end;function script.onLeave(dZ)uJ.radarLeave(dZ)end;bC(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uJ=sJ(d,b,c,a,library,e,vBooster,hover,pa,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ia,gyro,warpdrive,sK)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
