name: ArchHud - Archaegeo v0.733 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.733;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=13888.00;a0=1.0;a1=32;a2=0;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)_=K end,get=function()return _ end},AutopilotInterplanetaryThrottle={set=function(K)a0=K end,get=function()return a0 end},warmup={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingAtmo={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingSpace={set=function(K)a3=K end,get=function()return a3 end},fuelTankHandlingRocket={set=function(K)a4=K end,get=function()return a4 end},ContainerOptimization={set=function(K)a5=K end,get=function()return a5 end},FuelTankOptimization={set=function(K)a6=K end,get=function()return a6 end},AutoShieldPercent={set=function(K)a7=K end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(a,b,c,bH,bI,bJ)bK=bH()bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=0;bS=0;bT=0;bU=0;bV=false;bW=false;bX="empty"bY=3;bZ=false;b_=0;c0=0;c1=nil;c2=0;c3=0;c4=0;c5=false;c6=false;c7=false;c8=-1;c9=bJ()>0;ca=bJ()cb=b.getAltitude()cc=b.getConstructMass()cd=nil;ce=a9;cf=aa;cg={}ch={}ci={}cj=nil;ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=false;ct=false;cu=p;cv=false;cw=U;cx=nil;cy=0;cz=false;cA=false;cB=false;cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cE=vec3(b.getVelocity())cF=vec3(b.getWorldVelocity())cG=vec3(cF):len()cH=vec3(b.getWorldVertical())cI=-cH:dot(cF)cJ=vec3(b.getConstructWorldPos())cK=false;cL=false;cM=true;cN=0;cO=0;cP={}cQ=false;cR=50000;cS=nil;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;cU=false;cV=nil;cW=false;cX=0;cY=nil;cZ=nil;c_={}d0=90;d1=w;d2=nil;d3=nil;d4={}d5={}d6=false;d7=nil;d8=0;d9=false;da=b.getMaxSpeed()if db then dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())end end;local function dd(d,b,c,a,de,df,dg,dh,di)local function dj(dk)return type(dk)=='number'end;local function dl(dk)return type(dg(dk))=='number'end;local function dm(dn)return type(dn)=='table'end;local function dp(a)return type(a)=='string'end;local function dq(dr)return dm(dr)and dj(dr.x and dr.y and dr.z)end;local function ds(dt)return dm(dt)and dj(dt.latitude and dt.longitude and dt.altitude and dt.id and dt.systemId)end;local du=math.pi/180;local dv=180/math.pi;local dw=1e-10;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local utils=utils;local vec3=vec3;local function dz(dk)local dA=string.gsub(string.reverse(de('%.4f',dk)),'^0*%.?','')return dA==''and'0'or string.reverse(dA)end;local function dB(dC)if dq(dC)then return de('{x=%.3f,y=%.3f,z=%.3f}',dC.x,dC.y,dC.z)end;if dm(dC)and not getmetatable(dC)then local dD={}local dE=next(dC)if type(dE)=='nil'or dE==1 then dD=dC else for dF,dr in pairs(dC)do local dG=dB(dr)if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end end;return de('{%s}',table.concat(dD,','))end;if dp(dC)then return de("'%s'",dC:gsub("'",[[\']]))end;return tostring(dC)end;local dH={}dH.__index=dH;dH.__tostring=function(dC,dI)local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)local dD={}for dK,dF in ipairs(dJ)do local dG=dB(dC[dF])if type(dF)=='number'then table.insert(dD,de('[%s]=%s',dF,dG))else table.insert(dD,de('%s=%s',dF,dG))end end;if dI then return de('%s%s',dI,table.concat(dD,',\n'..dI))end;return de('{%s}',table.concat(dD,','))end;dH.__eq=function(dL,dM)return dL.systemId==dM.systemId and dL.id==dM.id and di(dL.radius,dM.radius)and di(dL.center.x,dM.center.x)and di(dL.center.y,dM.center.y)and di(dL.center.z,dM.center.z)and di(dL.GM,dM.GM)end;local function dN(dO,dP,dQ,dR,dS)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dQ),'Argument 3 (radius) must be a number:'..type(dQ))assert(dm(dR),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dR))assert(dl(dS),'Argument 5 (GM) must be a number:'..type(dS))return setmetatable({systemId=dg(dO),id=dg(dP),radius=dg(dQ),center=vec3(dR),GM=dg(dS)},dH)end;local dT={}dT.__index=dT;dT.__tostring=function(dU)return de('::pos{%d,%d,%s,%s,%s}',dU.systemId,dU.id,dz(dU.latitude*dv),dz(dU.longitude*dv),dz(dU.altitude))end;dT.__eq=function(dL,dM)return dL.id==dM.id and dL.systemId==dM.systemId and di(dL.latitude,dM.latitude)and di(dL.altitude,dM.altitude)and(di(dL.longitude,dM.longitude)or di(dL.latitude,math.pi/2)or di(dL.latitude,-math.pi/2))end;local function dV(dW,dP,dX,dY,dZ)local dO=dW;if dp(dW)and not dY and not dZ and not dP and not dX then dO,dP,dX,dY,dZ=d_(dW,dy)assert(dO,'Argument 1 (position string) is malformed.')else assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(dX),'Argument 3 (latitude) must be in degrees:'..type(dX))assert(dl(dY),'Argument 4 (longitude) must be in degrees:'..type(dY))assert(dl(dZ),'Argument 5 (altitude) must be in meters:'..type(dZ))end;dO=dg(dO)dP=dg(dP)dX=dg(dX)dY=dg(dY)dZ=dg(dZ)if dP==0 then return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=dP,systemId=dO},dT)end;return setmetatable({latitude=du*df(dX,-90,90),longitude=du*(dY%360),altitude=dZ,id=dP,systemId=dO},dT)end;local e0={}e0.__index=e0;e0.__tostring=function(dC,dI)local e1=dI and dI..'  'local e2={}local dJ={}for dF in pairs(dC)do table.insert(dJ,dF)end;table.sort(dJ)for dK,e3 in ipairs(dJ)do e4=dC[e3]local e5=dH.__tostring(e4,e1)if dI then table.insert(e2,de('[%s]={\n%s\n%s}',e3,e5,dI))else table.insert(e2,de('  [%s]=%s',e3,e5))end end;if dI then return de('\n%s%s%s',dI,table.concat(e2,',\n'..dI),dI)end;return de('{\n%s\n}',table.concat(e2,',\n'))end;local function e6(e7)local e={}local pid;for dK,dr in pairs(e7)do local dP=dr.planetarySystemId;if type(dP)~='number'then error('Invalid planetary s ID: '..tostring(dP))elseif pid and dP~=pid then error('Mistringmatch planetary s IDs: '..dP..' and '..pid)end;local e8=dr.bodyId;if type(e8)~='number'then error('Invalid body ID: '..tostring(e8))elseif e[e8]then error('Duplicate body ID: '..tostring(e8))end;setmetatable(dr.center,getmetatable(vec3.unit_x))e[e8]=setmetatable(dr,dH)pid=dP end;return setmetatable(e,e0)end;e9={}local function ea(e7)return setmetatable({galaxyAtlas=e7 or{}},e9)end;e9.__index=function(dn,K)if type(K)=='number'then local a=dn.galaxyAtlas[K]return e6(a)end;return rawget(e9,K)end;e9.__pairs=function(dC)return function(dn,dF)local eb,ec=next(dn,dF)return eb,ec and e6(ec)end,dC.galaxyAtlas,nil end;e9.__tostring=function(dC)local ed={}for dK,ee in pairs(dC or{})do local ef=ee:getPlanetarySystemId()local eg=e0.__tostring(ee,'    ')table.insert(ed,de('  [%s]={%s\n  }',ef,eg))end;return de('{\n%s\n}\n',table.concat(ed,',\n'))end;e9.BodyParameters=dN;e9.MapPosition=dV;e9.PlanetarySystem=e6;function e9.createBodyParameters(dO,dP,eh,ei,ej,ek,el)assert(dl(dO),'Argument 1 (systemId) must be a number:'..type(dO))assert(dl(dP),'Argument 2 (id) must be a number:'..type(dP))assert(dl(eh),'Argument 3 (surfaceArea) must be a number:'..type(eh))assert(dm(ei),'Argument 4 (aPosition) must be an array or vec3:'..type(ei))assert(dm(ej),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ej))assert(dl(ek),'Argument 6 (altitude) must be in meters:'..type(ek))assert(dl(el),'Argument 7 (gravityAtPosition) must be number:'..type(el))local dQ=dh(eh/4/math.pi)local c4=dQ+ek;local em=vec3(ei)+c4*vec3(ej)local dS=el*c4*c4;return dN(dO,dP,dQ,em,dS)end;e9.isMapPosition=ds;function e9:getPlanetarySystem(dW)if K==nil then K=0 end;if ec==nil then ec=0 end;local dO=dW;if ds(dW)then dO=dW.systemId end;if type(dO)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ec)~=e0 then a=e6(a)end;return a end end end;function e0:sizeCalculator(en)return 1.05*en.radius end;function e0:castIntersections(eo,ep,eq,er,es,et)local eu={}if es then for dK,en in pairs(es)do table.insert(eu,en)end else eu=c_ end;if not et then table.sort(eu,function(ev,ew)local ex=ev.center;local ey=ew.center;return(ex.x-eo.x)^2+(ex.y-eo.y)^2+(ex.z-eo.z)^2<(ey.x-eo.x)^2+(ey.y-eo.y)^2+(ey.z-eo.z)^2 end)end;local ez=ep:normalize()for dK,en in ipairs(eu)do local eA=en.center-eo;local dQ=self:sizeCalculator(en)local eB=eA:dot(ez)local eC=eB^2-(eA:len2()-dQ^2)if eC>=0 then local eD=dh(eC)local eE=eB+eD;local eF=eB-eD;if eF>0 then return en,eE,eF elseif eE>0 then return en,eE,nil end end end;return nil,nil,nil end;function e0:closestBody(eG)assert(type(eG)=='table','Invalid coordinates.')local eH,en;local eI=vec3(eG)for dK,eJ in pairs(self)do local eK=(eJ.center-eI):len2()if(not en or eK<eH)and eJ.name~="Space"then en=eJ;eH=eK end end;return en end;function e0:convertToBodyIdAndWorldCoordinates(dW)local eL=dW;if dp(dW)then eL=dV(dW)end;if eL.id==0 then return 0,vec3(eL.latitude,eL.longitude,eL.altitude)end;local eJ=self:getBodyParameters(eL)if eJ then return eL.id,eJ:convertToWorldCoordinates(eL)end end;function e0:getBodyParameters(dW)local dP=dW;if ds(dW)then dP=dW.id end;assert(dl(dP),'Argument 1 (id) must be a number:'..type(dP))return self[dP]end;function e0:getPlanetarySystemId()local dK,dr=next(self)return dr and dr.systemId end;function dH:convertToMapPosition(dR)assert(dm(dR),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dR))local eM=vec3(dR)if self.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=self.systemId},dT)end;local eN=eM-self.center;local c4=eN:len()local dZ=c4-self.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=dX,longitude=dY,altitude=dZ,id=self.id,systemId=self.systemId},dT)end;function dH:convertToWorldCoordinates(dW)local eL=dp(dW)and dV(dW)or dW;if eL.id==0 then return vec3(eL.latitude,eL.longitude,eL.altitude)end;assert(ds(eL),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eL.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eL.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eQ=math.cos(eL.latitude)return self.center+(self.radius+eL.altitude)*vec3(eQ*math.cos(eL.longitude),eQ*math.sin(eL.longitude),math.sin(eL.latitude))end;function dH:getAltitude(dR)return(vec3(dR)-self.center):len()-self.radius end;function dH:getDistance(dR)return(vec3(dR)-self.center):len()end;function dH:getGravity(dR)local eR=self.center-vec3(dR)local eS=eR:len2()return self.GM/eS*eR/dh(eS)end;return setmetatable(e9,{__call=function(dK,...)return ea(...)end})end;local function eT(d,b,c,a,dh,eU)local ck={}local eV=100000000/3600;local eW=eV*eV;local eX=100;function ck.computeAccelerationTime(eY,eZ,e_)local f0=eV*math.asin(eY/eV)return(eV*math.asin(e_/eV)-f0)/eZ end;function ck.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/eV)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=eV*math.pi;local dr=function(dn)local fe=(fb*dn-fc*math.sin(math.pi*dn/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return eV*ff/dh(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(dr(fa))then local fh=0;while eU(fa-fh)>0.5 do local dn=(fa+fh)/2;if fg(dr(dn))then fa=dn else fh=dn end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=dr(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=eV*math.asin(eY/eV)local bK=(eV*math.asin(e_/eV)-f0)/f8;local fm=eW*math.cos(f0/eV)/f8;local c4=fm-eW*math.cos((f8*bK+f0)/eV)/f8;return c4+f9,bK+fa end;function ck.computeTravelTime(eY,eZ,c4)if c4==0 then return 0 end;if eZ>0 then local f0=eV*math.asin(eY/eV)local fm=eW*math.cos(f0/eV)/eZ;return(eV*math.acos(eZ*(fm-c4)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c4/eY end;return ck end;local function fn(d,b,c,a,de,df,dg,dh,di)local vec3=vec3;local dd=dd(d,b,c,a,de,df,dg,dh,di)local function dp(a)return type(a)=='string'end;local function dm(dn)return type(dn)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(dZ)assert(self.body)local c4=dZ+self.body.radius;if not di(c4,0)then local fp=dh(self.body.GM/c4)return dh(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dW,fq)assert(self.body)assert(dm(dW)or dp(dW))assert(dm(fq))local fr=(dp(dW)or dd.isMapPosition(dW))and self.body:convertToWorldCoordinates(dW)or vec3(dW)local dr=vec3(fq)local fs=fr-self.body.center;local ft=dr:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(dr)*dr)/fv;local ex=fv/(2*fv/fu-ft)local fx=fw:len()local ez=fw:normalize()local fy=ex*(1-fx)local fz=ex*(1+fx)local fA=fy*ez+self.body.center;local fB=fx<=1 and-fz*ez+self.body.center or nil;local fC=dh(ex*fv*(1-fx*fx))local fD=fB and 2*math.pi*dh(ex^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(dr)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=dh(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=dh(fv/fz),altitude=fz-self.body.radius},currentVelocity=dr,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eJ=dd.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eJ},fo)end;return setmetatable(fo,{__call=function(dK,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)local function fS(fT)local dU=fU:closestBody(fT)if(fT-dU.center):len()>dU.radius+dU.noAtmosphericDensityAltitude then dU=e[0][0]end;return dU end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cP={}for dF,dr in pairs(e[0])do cP[#cP+1]={name=dr.name,index=dF}end;table.sort(cP,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dF,dr in pairs(f_)do if dr.name and dr.name==g0 then return dF end end;return-1 end;local function g2()cX=bj;if bj==0 then bh="None"c1=nil;g1=nil;return true end;local g3=cP[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c1=cj[0][g3]if g1~=nil then if ca==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dK,dr in pairs(cj[0])do if dr.name==g1.planetname then c1=dr;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c1.center)else bi=g1.position end;if c1.planetname~="Space"then if c1.hasAtmosphere then gl=bI(c1.radius*(S-1)+c1.noAtmosphericDensityAltitude)else gl=bI(c1.radius*(S-1)+c1.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dK,bd=cl(c1):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c6 and not bx and not b6 and not c7 then if gn==nil then bj=bj+1;if bj>#cP then bj=0 end else bj=bj-1;if bj<0 then bj=#cP end end;if bj==0 then g2()else local g3=cP[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bX="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bX=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d4=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d4 else gr=bn end;if dbHud_1 or gv or gq then local dU=fS(fT)local gy={position=fT,name=gu,planetname=dU.name,gravity=b.g(),safe=gw}if not gv then gr[#gr+1]=gy else for dF,dr in pairs(e[0])do if dr.name and gu==dr.name then table.remove(e[0],dF)end end end;table.insert(e[0],gy)fV()g2()bX="Location saved as "..gu.."("..dU.name..")"return gr else bX="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d4=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d4 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cb;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bX=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bX=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cD:cross(cH)*5000;bX=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bX=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.g()gF.position=cJ;gF.safe=true end;bX=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bX="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dF,dr in pairs(d5)do table.insert(e[0],dr)end;if gG then for dF,dr in pairs(gG)do gz[dF]=dr end end;fV()if bj>#cP then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)local gL={}local gM={}local gN={XS=13,S=27,M=55,L=110,XL=221}local gO={}local gP=0;local gQ;local gR;local gS;local gT;local gU={}local gV="Atmo"local gW;local gX;local gY=0;local gZ={}local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local ft=h4-h2;local hc=ft:normalize()local hd=ft:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local dt=h9-hk^2-hl^2;local hm=dh(dt)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if eU((h8-hn):len()-h7)<eU((h8-ho):len()-h7)then return hn else return ho end end;local function hp(hq,fu,hr)local hs=hq.pts;local gs=#hs;local ht=hq.ref;if gs>3 then local hu,hv,hw,hx=hs[gs],hs[gs-1],hs[gs-2],hs[gs-3]hq.ref=hr;local fr=h0(hu[1],hu[2],hv[1],hv[2],hw[1],hw[2],hx[1],hx[2])local hk,hl,hm=fr.x,fr.y,fr.z;if hk==hk and hl==hl and hm==hm then hk=hk+ht[1]hl=hl+ht[2]hm=hm+ht[3]local hy=vec3(hk,hl,hm)hq.center=hy;if hq.lastPos then if(hq.lastPos-hy):len()<2 then local hz=(hy-vec3(hr)):len()if eU(hz-fu)<10 then hq.skipCalc=true end end end;hq.lastPos=hy end;hq.pts={}else local hA={hr[1]-ht[1],hr[2]-ht[2],hr[3]-ht[3]}hs[gs+1]={fu,hA}end end;if radar_1 or radar_2 then cp.assignRadar()end;if gU[1]then gP=#gU[1].getConstructIds()local hB=gU[1].getData()local hC=hB:gmatch('{"constructId[^}]*}[^}]*}')if gP>0 then local hr={cJ["x"],cJ["y"],cJ["z"]}local hD,hE=0,0;local hF=cG*10;gT,gS=0,0;for dr in hC do local dP,c4,hG=dr:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hH=gN[hG]c4=dg(c4)if gU[1].hasMatchingTransponder(dP)==1 then table.insert(gM,dP)end;if E then local hI=gU[1].getConstructType(dP)if F and gU[1].isConstructAbandoned(dP)==1 or c4<hF and(hH>27 or hI=="static"or hI=="space")then gT=gT+1;local gu=gU[1].getConstructName(dP)local hq=gZ[dP]if hq==nil then hH=hH+gK;gZ[dP]={pts={},ref=hr,name=gu,i=0,radius=hH,skipCalc=false}hq=gZ[dP]end;if not hq.skipCalc then hp(hq,c4,hr)if F and not hq.abandoned and gU[1].isConstructAbandoned(dP)==1 and hq.center then fQ("abRdr","RD")a.print("Abandoned Construct: "..gu.." ("..hI..") rough ::pos{0,0,"..hq.center.x..","..hq.center.y..","..hq.center.z.."}")bX="Abandoned Radar Contact ("..hI..") detected"hq.abandoned=true end;hE=hE+1 else table.insert(gO,hq)end end;hD=hD+1;if cT and hD>700 or hE>70 or(not cT and hD>300 or hE>30)then coroutine.yield()hD,hE=0,0 end end end;gS=#gO;if gS>0 and(cG>20 or b4)then local en,hJ,hK,hL;local hM=0;local hN=cj:getPlanetarySystem(0)hL=cF:normalize()while hM<gS do coroutine.yield()local hO={table.unpack(gO,hM,math.min(hM+75,gS))}en,hJ,hK=hN:castIntersections(cJ,hL,nil,nil,hO,true)if en and hK then cV={en,hJ,hK}break end;hM=hM+75 end;if not en then cV=nil end else cV=nil end;gO={}gQ=hB:find('identifiedConstructs":%[%]')else gR=hB:find('worksInEnvironment":false')end end end;local function hP()if gU[1]then gV="Atmo"if gU[1].getData():find('worksInAtmosphere":false')then gV="Space"end end end;function gL.pickType()hP()end;function gL.assignRadar()if radar_1 and gU[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gU[1]=radar_2 end;if gU[1]==radar_2 then hP()end elseif radar_2 and gU[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gU[1]=radar_1 end;if gU[1]==radar_1 then hP()end end end;function gL.UpdateRadar()local hQ=coroutine.status(gW)if hQ=="suspended"then local dG,hR=coroutine.resume(gW)if hR then a.print("ERROR UPDATE RADAR: "..hR)end elseif hQ=="dead"then gW=coroutine.create(g_)local dG,hR=coroutine.resume(gW)end end;function gL.GetRadarHud(hS,hT,au,av)local hU=gM;local hV,hW;gM={}local dx=gS or 0;if gP>0 then if E then hW=dx.."/"..gT.." Plotted : "..gP-gT.." Ignored"else hW="Radar Contacts: "..gP end;hV=gJ(au,av,hW,"pbright txtbig txtmid")if#gM>0 then hV=hV..gJ(hS,hT,"Friendlies In Range","pbright txtbig txtmid")for dF,dr in pairs(gM)do hT=hT+20;hV=hV..gJ(hS,hT,gU[1].getConstructName(dr),"pdim txtmid")end end;if gQ==nil and gX==nil then gY=1;cp.ToggleRadarPanel()end;if gQ~=nil and gX~=nil then cp.ToggleRadarPanel()end;if d3==nil then cp.ToggleRadarPanel()end else if gR then hV=gJ(au,av,gV.." Radar: Jammed","pbright txtbig txtmid")else hV=gJ(au,av,"Radar: No "..gV.." Contacts","pbright txtbig txtmid")end;if d3~=nil then gY=0;cp.ToggleRadarPanel()end end;return hV end;function gL.GetClosestName(gu)if gU[1]then local dP,dK=gU[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dP~=nil and dP~=""then gu=gu.." "..gU[1].getConstructName(dP)end end;return gu end;function gL.ToggleRadarPanel()if d3~=nil and gY==0 then gI(d3)d3=nil;if gX~=nil then gI(gX)gX=nil end else if gY==1 then gI(d3)d3=nil;_autoconf.displayCategoryPanel(gU,1,"Periscope","periscope")gX=_autoconf.panels[_autoconf.panels_size]end;if d3==nil then _autoconf.displayCategoryPanel(gU,1,"Radar","radar")d3=_autoconf.panels[_autoconf.panels_size]end;gY=0 end end;function gL.ContactTick()if not hX then hX=0 end;if bK>hX+10 then bX="Radar Contact"fQ("rdrCon","RC")hX=bK end;c.stopTimer("contact")end;function gL.onEnter(dP)if radar_1 and not c9 and not cQ then c.setTimer("contact",0.1)end end;function gL.onLeave(dP)if radar_1 and E then if#gZ>650 then dP=tostring(dP)gZ[dP]=nil end end end;gU[1]=nil;if radar_1 then gU[1]=radar_1;hP()end;gW=coroutine.create(g_)if hY then for dF,dr in pairs(hY)do gL[dF]=dr end end;return gL end;local function hZ(db,d_,bI)local h_={}local i0=db.getResistancesCooldown()local function i1()local i2=db.getState()if G then if not cQ and i2==0 then db.toggle()elseif cQ and i2==1 then db.toggle()end end end;local function i3()local i4=db.getStressRatioRaw()local i5=0.5999;if i4[1]==0.0 and i4[2]==0.0 and i4[3]==0.0 and i4[4]==0.0 then return end;local i6=db.setResistances(i5*i4[1],i5*i4[2],i5*i4[3],i5*i4[4])if i6==1 then bX="Shield Resistances updated"else bX="Value Exceeded. Failed to update Shield Resistances"end end;function h_.shieldTick()dc=bI(0.5+db.getShieldHitpoints()*100/db.getMaxShieldHitpoints())i1()i0=db.getResistancesCooldown()if i0==0 and dc<a7 then i3()end end;function h_.setResist(i7)if not db then bX="No shield found"return elseif i7==nil or i0>0 then bX="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy=dx..', '..dx..', '..dx..', '..dx;local i8,i9,ia,ib=d_(i7,dy)if ib==nil or i8+i9+ia+ib>0.6 then bX="Improperly formatted or total exceeds 0.6"return end;if db.setResistances(i8,i9,ia,ib)==1 then bX="Shield Resistances set"else bX="Resistance setting failed."end end;function h_.ventShield()local ic=db.getVentingCooldown()if ic>0 then bX="Cannot vent again for "..ic.." seconds"return end;if db.getShieldHitpoints()<db.getMaxShieldHitpoints()then db.startVenting()bX="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bX="Shields already at max hitpoints"end end;if id then for dF,dr in pairs(id)do h_[dF]=dr end end;return h_ end;local function ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)local it=9.80665;local iu={}local iv={}local iw={}local ix={}local iy=nil;local iz=nil;local iA=nil;local iB=false;local iC="none"local iD=""local iE=55;local iF=0;local iG=0;local iH=""local iI=nil;local iJ=ac;local iK=ad;local iL=ae;local iM=[[rgb(]]..bI(iJ+0.5)..","..bI(iK+0.5)..","..bI(iL+0.5)..[[)]]local iN=[[rgb(]]..bI(iJ*0.9+0.5)..","..bI(iK*0.9+0.5)..","..bI(iL*0.9+0.5)..[[)]]local iO=0;local iP=0;local iQ=""local iR=bH()local iS=false;local iT=false;local iU=vec3({13771471,7435803,-128971})local iV=18000000;local iW=500000;local iX,iY=math.huge;local iZ;local function i_(j0)iX=vec3(j0):dist(iU)if iX<iV then return true,eU(iX-iV)end;iY=vec3(j0):dist(vec3(j1.center))if iY<iW then iZ=true else iZ=false end;if eU(iY-iW)<eU(iX-iV)then return iZ,eU(iY-iW)else return iZ,eU(iX-iV)end end;local function j2(dr)if ce==1920 then return dr else return fR(ce*dr/1920,0)end end;local function j3(dr)if cf==1080 then return dr else return fR(cf*dr/1080,0)end end;local function j4()return il()==0 and g~="keyboard"and ij()==0 end;local function j5()local j6="TRAVEL"if not cM then j6="CRUISE"end;if b1 then j6="AUTOPILOT"end;return j6 end;local hV=""local j7=""local j8=""local j9=1;local ja=2;local jb=3;local jc=4;local jd=5;local je=6;local jf=7;local jg=""local jh=0;local ji=120.0*aR;local jj={}local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}jp["atmofueltank"],jp["spacefueltank"],jp["rocketfueltank"]=0,0,0;local jq=0;local function jr(hk,js,jt,ju,jv,jw)local jx=jq;local jy=jq+5;if not B then jy=jy+5 end;if ij()==1 and not l then jx=jx-50;jy=jy-50 end;if jt=="ATMO"then jg="atmofueltank"elseif jt=="SPACE"then jg="spacefueltank"else jg="rocketfueltank"end;jh=_G[jg.."_size"]if#ju>0 then for K=1,#ju do local gu=ju[K][ja]local jz=ju[K][jf]for jA=1,jh do if ju[K][ja]==ih(c[jg.."_"..jA].getData()).name then jz=jA;break end end;local jB=bH()if jv[K]==nil or jw[K]==nil or jB-ju[K][je]>ji then local jC;local jD=0;jD=ii(ju[K][j9])-ju[K][jc]jC=ju[K][jd]if jC>jD then jp[jg]=jp[jg]+jC-jD end;if jz~=0 then local jE=ih(c[jg.."_"..jz].getData())jw[K]=jE.percentage;jv[K]=jE.timeLeft;if jv[K]=="n/a"then jv[K]=0 end else jw[K]=bI(0.5+jD*100/ju[K][jb])if jC<=jD then jv[K]=0 else jv[K]=bI(0.5+jD/((jC-jD)/(jB-ju[K][je])))end end;ju[K][je]=jB;ju[K][jd]=jD end;if gu==js then gu=de("%s %d",jt,K)end;if jz==0 then gu=gu.." *"end;local jF;if jv[K]==0 then jF=""else jF=iq(jv[K])end;if jw[K]~=nil then local jG=bI(jw[K]*2.55)local jH=de("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jv[K]<120 or jw[K]<5 then jI="red "end;local jJ=de("rgb(%d,%d,%d)",df(bI((255-jG)/2.55),50,100),df(bI(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if jt=="ATMO"then jK="rgb(0,188,255)"elseif jt=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if B then if jL then jx=jx-5;jy=jy-5 end;j7=j7 ..de([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hk,jy,jH,bI(jw[K]*1.7+0.5)-2,hk+1,jy+1,hk+5,jy+14,gu,jw[K],jF)jx=jx-22;jy=jy-22 else j7=j7 ..gJ(hk,jx,gu,jI.."pdim txtfuel")j7=j7 ..gJ(hk,jy,de("%d%% %s",jw[K],jF),"pdim txtfuel","fill:"..jH)jx=jx+30;jy=jy+30 end end end end;jq=jx end;local function jN(jO,dZ)if am==0 and an==0 then return end;if dZ<200000 and not c9 or dZ and c9 then local jP=0;if eU(cI)>1 then jP=45*math.log(eU(cI),10)if cI<0 then jP=-jP end end;jO[#jO+1]=de([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cI),bI(jP))end;return jO end;local function jQ(jR)local gn=-cH;jR=jR-jR:project_on(gn)local jS=vec3(0,0,1)jS=jS-jS:project_on(gn)local jT=jS:cross(gn)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,ai,aj,jV,jW,cT)if ab==0 then return end;local jX=ab;local jY=20;local jZ=bI(jV)if cT then for K=-45,45,5 do local j_=K;jO[#jO+1]=de([[<g transform="rotate(%f,%d,%d)">]],j_,ai,aj)k0=5;if K%15==0 then k0=15 elseif K%10==0 then k0=10 end;jO[#jO+1]=de([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jX+jY-k0,ai,aj+jX+jY)end;jO[#jO+1]=gJ(ai,aj+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gJ(ai,aj+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jV,ai,aj)jO[#jO+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jX+jY-20,ai+5,aj+jX+jY-20,ai,aj+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cT then k1=jQ(cC)end;local k2=20;local k3=bI(k1)local k4=0;local k5=aj+jX+jY+20;local k6=ai;if jW~="YAW"then k5=j3(130)k6=j2(960)end;local k7=[[<path class="txttick line" d="]]local k8=bI(k3-(k2+10)-k3%5+0.5)for K=k8+70,k8,-5 do local hk=k6-(-K*5+k1*5)if K%10==0 then k4=10;local dx=K;if dx==360 then dx=0 elseif dx>360 then dx=dx-360 elseif dx<0 then dx=dx+360 end;jO[#jO+1]=gJ(hk,k5+15,dx,"txtmid bright")elseif K%5==0 then k4=5 end;if k4==10 then k7=de([[%s M %f %f v %d]],k7,hk,k5-5,k4)else k7=de([[%s M %f %f v %d]],k7,hk,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=de([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if I then if cT then jW="HDG"end;jO[#jO+1]=gJ(j2(960),j3(100),k3 .."°","dim txt txtmid size14","")jO[#jO+1]=gJ(j2(960),j3(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,ai,aj,cT,kb,fl)if ab==0 then return end;local jX=ab;local kc=bI(jX*3/5)if jX>0 then local kd=bI(ka)local k0=0;local k7=de([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,ai,aj)if not c9 then k7=de([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jO[#jO+1]=de([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,ai,aj)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(kd-30-kd%5+0.5),bI(kd+30+kd%5+0.5),5 do if K%10==0 then k0=30 elseif K%5==0 then k0=20 end;local hl=aj+-K*5+ka*5;if k0==30 then k7=de([[%s M %d %f h %d]],k7,ai-kc-k0,hl,k0)if c9 then jO[#jO+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ai,aj,ai-kc+10,hl+4,K)jO[#jO+1]=de([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ai,aj,ai+kc-10,hl+4,K)if K==0 or K==180 or K==-180 then jO[#jO+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ai,aj,ai-kc+20,hl,kc*2-40)end else jO[#jO+1]=gJ(ai-kc+10,hl,K,"pdim txt txtmid")jO[#jO+1]=gJ(ai+kc-10,hl,K,"pdim txt txtmid")end;k7=de([[%s M %d %f h %d]],k7,ai+kc,hl,k0)else k7=de([[%s M %d %f h %d]],k7,ai-kc-k0,hl,k0)k7=de([[%s M %d %f h %d]],k7,ai+kc,hl,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cT then ke="REL PITCH"end;if ka>90 and not c9 then ka=90-(ka-90)elseif ka<-90 and not c9 then ka=-90-(ka+90)end;if jX>200 then if c9 then if fl>iE then jO[#jO+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gJ(ai,aj+20,kb,"pdim txt txtmid")end;jO[#jO+1]=de([[<g transform="rotate(%f,%d,%d)">]],-jV,ai,aj)else jO[#jO+1]=de([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jO[#jO+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-kc+25,aj-5,ai-kc+20,aj,ai-kc+25,aj+5,ai-kc+50,aj+4,kd)jO[#jO+1]=de([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+kc-25,aj-5,ai+kc-20,aj,ai+kc-25,aj+5,ai+kc-30,aj+4,kd)jO[#jO+1]="</g>"end;local kf=bI(jX/3)jO[#jO+1]=de([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kf,aj,jX-kf)if not c9 and cT then jO[#jO+1]=de([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ai,aj,ai-kc+10,aj,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if c9 and fl>iE then jO[#jO+1]=gJ(ai,aj-jX,ke,"pdim txt txtmid")jO[#jO+1]=gJ(ai,aj-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gJ(ai,aj-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gJ(ai,aj+20,kb,"pdim txt txtmid")else jO[#jO+1]=gJ(ai,aj-jX,ke,"pdim txt txtmid")jO[#jO+1]=gJ(ai,aj-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,dZ,cT)local kh=ao;local ki=ap;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=c8;if c8~=-1 then jO[#jO+1]=gJ(kh+kj,ki+kk+20,de("AGL: %.1fm",c8),"pdim altsm txtend")end;if cT and(dZ<200000 and not c9 or dZ and c9)then table.insert(jO,de([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gs=0;local km=1;local kn=0;local ko=dZ<0;local kp=dZ<j1.surfaceMaxAltitude;local kq=9;if ko then kq=0 end;local dZ=eU(dZ)while gs<6 do local kr=11;local ks=16;local kt=9;local ku=14;local jI="altsm"if gs>2 then ks=ks+3;kr=kr+2;ku=ku+2;kt=kt-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kv=dZ/km%10;local kw=bI(kv)local kx=bI((kw+1)%10)local ky=kn;if gs==0 then ky=kv-kw;if ko then ky=1-ky end end;if ko and(gs==0 or kn~=0)then local gv=kx;kx=kw;kw=gv end;local kz=ks*(ky-1)local kA=kz+ks;local hk=kh+kt+(6-gs)*kr;local hl=ki+ku;jO[#jO+1]=gJ(hk,hl+kz,kx,jI)jO[#jO+1]=gJ(hk,hl+kA,kw,jI)gs=gs+1;km=km*10;if kw==kq then kn=ky else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kB(fq)local kC=-math.deg(eP(fq.y,fq.z))+180;kC=kC-90;if kC<0 then kC=360+kC end;if kC>180 then kC=-180+kC-180 end;return-kC end;local function kD(fq)local k1=math.deg(eP(fq.y,fq.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kE(jO,fq,fl,ai,aj)if fl>5 and not c9 or fl>iE then local jX=ab;local kF=20;local kG=20;local kH=kB(fq)local kI=kD(fq)local kJ=14;local kK=kJ/2;local kL=-kI/kG*jX;local kM=kH/kF*jX;local hk=ai+kL;local hl=aj+kM;local c4=dh(kL^2+kM^2)local kN=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kK/kJ..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kJ..[[,]]..hl..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+kK..[[,]]..hl..[[ h ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kJ..[[ v ]]..kK..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c4<jX then jO[#jO+1]=kN else local jP=eP(kM,kL)local kO=4;local kP=ai+jX*math.cos(jP)local kQ=aj+jX*math.sin(jP)jO[#jO+1]=de('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kP,kQ,kP-kO,kQ-kO/2,kO*2,kO,kP+kO,kQ-kO,kO,kO,-kO,kO)end;if not c9 then local kR=vec3(fq)kH=kB(-kR)kI=kD(-kR)kL=-kI/kG*jX;kM=kH/kF*jX;hk=ai+kL;hl=aj+kM;c4=dh(kL^2+kM^2)if c4<jX then local kS=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-kK..[[,]]..hl..[[ h ]]..kJ..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]jO[#jO+1]=kS end end end end;local function kT(jO,j6,kU,kV)if ak==0 and al==0 then return end;kU=bI(kU+0.5)local jx=al+10;local jy=al+20;if ij()==1 and not l then jx=55;jy=65 end;local kW="CRUISE"local c="km/h"local dG=kV;if j6=="TRAVEL"or j6=="AUTOPILOT"then kW="THROT"c="%"dG=kU;local kX="dim"if kU<0 then kX="red"end;jO[#jO+1]=de([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kX,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eU(kU),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jO[#jO+1]=gJ(ak+10,jx,kW,"pbright txtstart")jO[#jO+1]=gJ(ak+10,jy,de("%.0f %s",dG,c),"pbright txtstart")if c9 and t and cM and bN then kU=bI(bO*100+0.5)local kX="red"if kU<0 then kX="red"end;jO[#jO+1]=de([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kX,1-eU(kU),ak-10,al+50,ak-15,al+53,ak-15,al+47)jO[#jO+1]=gJ(ak+10,jx+40,"LIMIT","pbright txtstart")jO[#jO+1]=gJ(ak+10,jy+40,kU.."%","pbright txtstart")end;if c9 and t or b6 then jO[#jO+1]=gJ(ak+10,jx-40,"LIMIT: "..cw.." km/h","dim txtstart")elseif not c9 and b1 then jO[#jO+1]=gJ(ak+10,jx-40,"LIMIT: "..bI(_*3.6+0.5).." km/h","dim txtstart")end end;local function kY(jO,kZ)if ak==0 and al==0 then return end;local k_=al-10;local l0=ak+10;jO[#jO+1]=gJ(0,0,"","pdim txt txtend")if ij()==1 and not l then k_=75 end;jO[#jO+1]=gJ(l0,k_,bI(kZ).." km/h","pbright txtbig txtstart")end;local function l1(jO)jO[#jO+1]=gJ(j2(150),j3(1070),de("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gJ(j2(960),j3(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gJ(j2(960),j3(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gJ(j2(960),j3(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l2=j2(960)local l3=j3(860)local l4=j3(880)local l5=j3(900)local l6=j3(960)local l7=j3(200)local l8=j3(250)local l9=j3(960)if ij()==1 and not l then l3=j3(135)l4=j3(155)l5=j3(175)l7=j3(115)l8=j3(95)end;local la="#222222"local lb="white"local lc="dimmer"local ld="pbright"local le="#110000"local lf=la;local lg=lc;if aZ then local lh=""if type(aZ)=="string"then lh="-"..aZ end;jO[#jO+1]=gJ(l2,l3,"Brake Engaged"..lh,"warnings")le="#440000"lf=lb;lg=ld elseif bM>0 then jO[#jO+1]=gJ(l2,l3,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local li="#110000"local lj=la;local lk=lc;if c9 and cv and c8==-1 then if not b1 and not bo and not b4 and not cL and not b7 and not b5 then jO[#jO+1]=gJ(l2,l7+50,"** STALL WARNING **","warnings")li="#ff0000"lj=lb;lk=ld;fQ("stall","SW",2)end end;if cS then jO[#jO+1]=gJ(l2,l7+90,"Flight Assist in Progress","warnings")end;if cd then jO[#jO+1]=gJ(l2,l9,"Gyro Enabled","warnings")end;local ll="#111100"local lm=la;local ln=lc;if bk then ll="#775500"lm=lb;ln=ld;if bQ then jO[#jO+1]=gJ(l2,l4,"Gear Extended","warn")else jO[#jO+1]=gJ(l2,l4,"Landed (G: Takeoff)","warnings")end end;if c8>-1 and(not cL or cb<100)then local lo=ip(d:getTargetGroundAltitude())jO[#jO+1]=gJ(l2,l5,"Hover Height: "..lo,"warn")end;local lp="#000011"local lq=la;local lr=lc;if bZ then lp="#0000DD"lq=lb;lr=ld;jO[#jO+1]=gJ(l2,l6+20,"ROCKET BOOST ENABLED","warn")end;local ls="#001100"local lt=la;local lu=lc;if antigrav and not q and cL and bt~=nil then ls="#00DD00"lt=lb;lu=ld;local lv="warnings"if eU(cb-antigrav.getBaseAltitude())<501 then lv="warn"end;jO[#jO+1]=gJ(l2,l7+40,de("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),lv)end;if b1 and bh~="None"then jO[#jO+1]=gJ(l2,l7,"Autopilot "..be,"warn")elseif br~=nil then jO[#jO+1]=gJ(l2,l7+20,de("LockedPitch: %d",bI(br)),"warn")elseif bV then jO[#jO+1]=gJ(l2,l7+20,"Follow Mode Engaged","warn")elseif b6 or c7 then jO[#jO+1]=gJ(l2,l7+20,"Re-entry in Progress","warn")end;if b3 or b7 then local lo=ip(b8,2)if b7 then if cL then lo=ip(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gJ(l2,l7,"VTO to "..lo,"warn")elseif b5 and not bx then if c6 then jO[#jO+1]=gJ(l2,l7,"Takeoff to "..bh,"warn")else jO[#jO+1]=gJ(l2,l7,"Takeoff to "..lo,"warn")end;if aZ and not b7 then jO[#jO+1]=gJ(l2,l7+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gJ(l2,l7,"Altitude Hold: "..de("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if ca>0.1 then jO[#jO+1]=gJ(l2,l7+20,"Beginning ascent","warn")elseif ca<0.09 and ca>0.05 then jO[#jO+1]=gJ(l2,l7+20,"Aligning trajectory","warn")elseif ca<0.05 then jO[#jO+1]=gJ(l2,l7+20,"Leaving atmosphere","warn")end end;if bx then if cx~=nil then jO[#jO+1]=gJ(l2,l7,cx,"warn")end end;if b4 then if lw then local lx="Brake Landing"if d7 then lx=lx.."-Aligning"end;if d6 then lx=lx.."-Drift Limited"end;jO[#jO+1]=gJ(l2,l7,lx,"warnings")else jO[#jO+1]=gJ(l2,l7,"Coast-Landing","warnings")end end;if b0 then jO[#jO+1]=gJ(l2,l7,"Prograde Alignment","crit")end;if a_ then jO[#jO+1]=gJ(l2,l7,"Retrograde Alignment","crit")end;local ly="#110000"local lz=la;local lA=lc;if cU then ly="#FF0000"lz=lb;lA=ld;local type;if string.find(cU,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gJ(l2,l8+20,cU,type)elseif ca==0 then local lB,lC=co.checkLOS(cF:normalize())if lC~=nil then lA=ld;ly="#FF0000"lz=lb;local lo=ip(lC)local lD=ck.computeTravelTime(cG,0,lC)local lE="Collision"if lB.noAtmosphericDensityAltitude>0 then lE="Atmosphere"end;jO[#jO+1]=gJ(l2,l8+20,lB.name.." "..lE.." "..iq(lD).." In "..lo,"crit")end end;if bo and not bx then jO[#jO+1]=gJ(l2,l7+60,lF,"warn")end;local lG="#111100"local lH=la;local lI=lc;if cY and#cY>1 then lG="#DDDD00"lH=lb;lI=ld end;local lJ=j2;local lK=j3;local lc="topButton"local lL="topButtonActive"local lM=lc;if b1 or bo or c6 or bx then lM=lL end;local lN=lc;if b0 then lN=lL end;local lO=lc;if b4 or bk then lO=lL end;local lP=lc;if b3 or bo then lP=lL end;local lQ=lc;if a_ then lQ=lL end;local lR=lc;if bx or cz and b1 then lR=lL end;if w and I then local lS=lK(30)jO[#jO+1]=de([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lM,lJ(960),lK(54),lK(-53),lJ(-120),lJ(25),lK(50))jO[#jO+1]=gJ(lJ(910),lS,"AUTOPILOT")jO[#jO+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lN,lJ(865),lK(51),lJ(-25),lK(-50),lJ(-110),lJ(25),lK(46))jO[#jO+1]=gJ(lJ(800),lS,"PROGRADE")jO[#jO+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lJ(755),lK(47),lJ(-25),lK(-46),lJ(-98),lJ(44),lK(44))jO[#jO+1]=gJ(lJ(700),lS,"LAND")jO[#jO+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lP,lJ(960),lK(54),lK(-53),lJ(120),lJ(-25),lK(50))jO[#jO+1]=gJ(lJ(1010),lS,"ALT HOLD")jO[#jO+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lJ(1055),lK(51),lJ(25),lK(-50),lJ(110),lJ(-25),lK(46))jO[#jO+1]=gJ(lJ(1122),lS,"RETROGRADE")jO[#jO+1]=de([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lJ(1165),lK(47),lJ(25),lK(-46),lJ(98),lJ(-44),lK(44))jO[#jO+1]=gJ(lJ(1220),lS,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lT(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lU(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cP[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lV(jO)local lW=co.routeWP(true)if not lW or#lW==0 then return end;local hk=j2(750)local hl=j3(360)if b1 or bo then jO[#jO+1]=gJ(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gJ(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dF,K in pairs(lW)do hl=hl+20;jO[#jO+1]=gJ(hk,hl,dF..". "..lW[dF],"pdim txtstart size20")end end;local function lX(jO)local hk=ay+10;local hl=az+20;local lY={}local lZ={"Alt-4: AutoTakeoff to Target"}local l_={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m0={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local m1={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lY,"--------------DYNAMIC-----------------")if c9 then if c8~=-1 then im(lY,lZ)if c1 and j1 and c1.name==j1.name then table.insert(lY,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cL then table.insert(lY,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lY,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lY,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lY,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lY,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lY,"G: Takeoff to hover height, raise gear")else table.insert(lY,"G: Lowergear and Land")end else im(lY,l_)table.insert(lY,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lY,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else im(lY,m0)if db then table.insert(lY,"Alt-Shift-6: Vent shields")if not G then table.insert(lY,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lY,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lY,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lY,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lY,"Alt-Spacebar/C will raise/lower target height")table.insert(lY,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not c9 then table.insert(lY,"LALT+Mousewheel will lower/raise speed limit")end;im(lY,m1)for K=1,#lY do hl=hl+12;jO[#jO+1]=gJ(hk,hl,lY[K],"pdim txtbig txtstart")end end;local function m2(jO)local m3=ay;local m4=az;local m5=ax;local m6=4;local m7=15;local hk=0;local hl=0;local m8,m9,ma,mb;local mc;local function md(type)local gE,bK,fl,me,jI,mf;if type=="Periapsis"then gE=mc.periapsis.altitude;bK=mc.timeToPeriapsis;fl=mc.periapsis.speed;jI="txtend"me=12;mf=math.min(hk,m3+m5-j1.radius/ma-m6*2)else gE=mc.apoapsis.altitude;bK=mc.timeToApoapsis;fl=mc.apoapsis.speed;me=-12;jI="txtstart"mf=hk end;if cG<1 then bK=0 end;jO[#jO+1]=de([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mf+me,hl-5,hk,hl-5)jO[#jO+1]=de([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mf-me*4,hl+2,hk,hl+2)jO[#jO+1]=gJ(mf,hl,type,jI)hk=mf-me*2;hl=hl+m7;local lo=ip(gE)jO[#jO+1]=gJ(hk,hl,lo,jI)hl=hl+m7;jO[#jO+1]=gJ(hk,hl,iq(bK),jI)hl=hl+m7;jO[#jO+1]=gJ(hk,hl,lT(fl),jI)end;local mg=m5*1.5;if bF=="INFO"then mg=25*9 end;if bF~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=de('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m5*2,mg,m3,m4)jO[#jO+1]=de([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m5*2,mg,m3,m4)end;local mh=m5*1.5;local mi=m5*2;local mj=mh/2;local mk=m5;local ml=m3+mk;local mm=m4+mj;local mn=m3+mi;local mo=m4+mh;if bF=="ORBIT"then m4=m4+m6;m8=m5/2;mb=0;mc={}mc.periapsis={}mc.apoapsis={}if fp~=nil then if fp.periapsis~=nil then mc.periapsis.altitude=fp.periapsis.altitude;mc.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then mc.apoapsis.altitude=fp.apoapsis.altitude;mc.apoapsis.speed=fp.apoapsis.speed end;mc.period=fp.period;mc.eccentricity=fp.eccentricity;mc.timeToApoapsis=fp.timeToApoapsis;mc.timeToPeriapsis=fp.timeToPeriapsis;mc.eccentricAnomaly=fp.eccentricAnomaly;mc.trueAnomaly=fp.trueAnomaly end;if mc.periapsis==nil then mc.periapsis={}mc.periapsis.altitude=-j1.radius;mc.periapsis.speed=_ end;if mc.eccentricity==nil then mc.eccentricity=1 end;if mc.apoapsis==nil then mc.apoapsis={}mc.apoapsis.altitude=cb;mc.apoapsis.speed=0 end;if cG<1 then mc.apoapsis.altitude=cb;mc.apoapsis.speed=0 end;if mc.apoapsis.altitude then ma=(mc.apoapsis.altitude+mc.periapsis.altitude+j1.radius*2)/(m8*2)m9=(j1.radius+mc.apoapsis.altitude)/ma*(1-mc.eccentricity)mb=m8-mc.periapsis.altitude/ma-j1.radius/ma;local mp=math.pi;if mc.period~=nil and mc.period>0 and mc.timeToApoapsis~=nil then mp=mc.eccentricAnomaly;if mc.timeToPeriapsis<mc.timeToApoapsis then mp=2*math.pi-mp end end;if cG<1 or mp~=mp then mp=math.pi end;local mq=-m8*math.cos(mp)+m3+mk+m6;local mr=m9*math.sin(mp)+m4+mj+m6;local ms=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ms,m3+m5+m6,m4+m5*1.5/2+m6,m8,m9)if m9<1 then jO[#jO+1]=de([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m3+m5+m6-mb,m4+m5*1.5/2+m6,mq,mr)end;jO[#jO+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m3+m5+m6-mb,m4+m5*1.5/2+m6,(j1.radius+j1.noAtmosphericDensityAltitude)/ma)jO[#jO+1]=de('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m3+m5+m6-mb,m4+m5*1.5/2+m6,(j1.radius+j1.noAtmosphericDensityAltitude)/ma)jO[#jO+1]=de([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m3+m5+m6,m4+m5*1.5/2+m6,m8,m9)jO[#jO+1]=de('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m3+m5+m6-mb,m4+m5*1.5/2+m6,j1.radius/ma)jO[#jO+1]='</g>'local mt=math.floor(j1.radius/ma+0.5)hk=m3+m5+m6*4+m8;hl=m4+m5*1.5/2+5+m6;if mc.apoapsis~=nil and mc.apoapsis.speed<_ then md("Apoapsis")end;hl=m4+m5*1.5/2+5+m6;hk=m3+m5-m6*2-m8;if mc.periapsis~=nil and mc.periapsis.speed<_ and mc.periapsis.altitude>0 then md("Periapsis")end;jO[#jO+1]=gJ(m3+m5+m6,m4+20+m6,j1.name,"txtorbbig")jO[#jO+1]=de('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mq,mr)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mu=""local mv=1.2*(mw-mx)/(m5*2)local my=1.4*(mz-mA)/(m5*1.5)for dF,dr in pairs(e[0])do if dr.center then local hk=m3+m5+dr.center.x/mv;local hl=m4+m5*1.5/2+dr.center.y/my;mu=mu..'<circle cx="'..hk..'" cy="'..hl..'" r="'..dr.radius/mv*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dr.name,"Moon")and not string.match(dr.name,"Sanctuary")and not string.match(dr.name,"Space")then mu=mu.."<text x='"..hk.."' y='"..hl+dr.radius/mv*30+20 .."' font-size='12' fill="..iM.." text-anchor='middle' font-family='Montserrat'>"..dr.name.."</text>"end end end;local fr=vec3(b.getConstructWorldPos())local hk=m3+m5+fr.x/mv;local hl=m4+m5*1.5/2+fr.y/my;mu=mu..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mu=mu.."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iy=mv;iz=my;local mB=fr+cF*1000000;local mC=m3+m5+mB.x/mv;local jy=m4+m5*1.5/2+mB.y/my;mu=mu..'<line x1="'..hk..'" y1="'..hl..'" x2="'..mC..'" y2="'..jy..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=mu;jO[#jO+1]='</g>'end elseif bF=="INFO"then jO=cm.DrawOdometer(jO,iO,bl,iP)elseif bF=="HELP"then jO=lX(jO)elseif bF=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mD=d0;if ca>0 then table.sort(c_,function(ev,ew)local ex,ey=ev.center,ew.center;return(ex.x-cJ.x)^2+(ex.y-cJ.y)^2+(ex.z-cJ.z)^2<(ey.x-cJ.x)^2+(ey.y-cJ.y)^2+(ey.z-cJ.z)^2 end)end;local gR={}local mE={}local mF=120;local mG=nil;local mH=nil;for K,dr in ipairs(c_)do local gQ=dr.center-cJ;local mI=gQ:len()local mJ=gQ:normalize()local mK=gQ:cross(cC):normalize()local mL=math.acos(mK:dot(cD))if mL~=mL then mL=0 end;if mK:cross(cD):dot(cC)<0 then mL=-mL end;local mM=gQ:project_on_plane(cC):len()local mN=math.sin(mL)*math.asin(mM/mI)*constants.rad2deg;local mO=math.cos(mL)*math.asin(mM/mI)*constants.rad2deg;if mJ:dot(cC)<0 then mO=90*math.cos(mL)+90*math.cos(mL)-mO;mN=90*math.sin(mL)+90*math.sin(mL)-mN end;local hk=ml+mN/mD*mh;local hl=mm+mO/mD*mh;local mP=(hk-ml)*(hk-ml)+(hl-mm)*(hl-mm)local mQ=math.asin((dr.radius+dr.surfaceMaxAltitude)/mI)*constants.rad2deg;if mQ~=mQ then mQ=mD end;local hG=mQ/mD*mh;local mR=math.asin(dr.atmosphereRadius/mI)*constants.rad2deg;if mR~=mR then mR=mQ end;local mS=mR/mD*mh;local c4=ip(mI,1)local mT=dr.name;local mU=false;if hl>m4 then if hl>mo then if hl-mS<=mo then mU=true end else mU=true end else if hl+mS>=m4 then mU=true end end;local mV=false;local mW=hk;if dr.systemId==0 then mW=hk+mF else mW=hk-mF end;if mW+mF>m3 then if mW+mF>mn then if mW-mS-mF<=mn then mV=true end else mV=true end else if mW+mS+mF>=m3 then mV=true end end;local mX={}mX.x=hk;mX.y=hl;mX.planet=dr;mX.atmoSize=mS;if not mG or mP<mG then mG=mP;mH=mX end;if mV and mU then local mY=math.max(mS,5)if mP<mY*mY then mT=mT.." - "..c4 end;mX.size=hG;mX.i=K;mX.displayString=mT;mX.distance=c4;mX.visible=true;mE[#mE+1]=mX else mX.visible=false end end;local mZ=false;table.sort(mE,function(ex,ey)return ex.y<ey.y end)for dF,fu in ipairs(mE)do local dr,hG,K,mS,hk,hl,mT,c4=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local mf,m_,n0,n1;local n2=15;local jI="pdim"if dr.systemId~=0 then n0=j2(string.len(mT)*5)n2=-(15+n0)n1=j3(10)jI="pdimfill"else n0=j2(string.len(mT)*9)n1=j3(15)end;if hG*2>n0 then mf=df(hk,m3+n0/2,mn-n0/2)m_=df(hl,m4+n1,mo-5)mf=df(mf,hk-hG+n0/2,hk+hG-n0/2)m_=df(m_,hl-hG+n1,hl+hG)else mf=hk+n2;m_=hl end;for n3,fu in pairs(gR)do local n4=fu.textPositions;local n5=n4.y-m_;if n3~=K and eU(n5)<n4.height and n4.x+n4.width>mf and n4.x<mf+n0 then if hG>n0 then m_=df(m_+n1,m4+15,mo-5)else m_=n4.y+n4.height+1 end end end;local n6=mT~=dr.name or mf<=ml and mf+n0>=ml and m_-n1<=mm and m_>=mm;fu.hovered=n6;local n7=1;if n6 then n7=2;if hG*2<n0 then n7=10 end;if mT==dr.name then mT=mT.." - "..c4 end;jI="pbright"if dr.systemId~=0 then n0=j2(string.len(mT)*5)n2=-(15+n0)else n0=j2(string.len(mT)*7)end;if hG*2>n0 then mf=df(hk,m3+n0/2,mn-n0/2)mf=df(mf,hk-hG+n0/2,hk+hG-n0/2)else mf=hk+n2 end end;gR[K]={}gR[K].textPositions={}gR[K].textPositions.y=m_;gR[K].textPositions.x=mf;gR[K].textPositions.width=n0;gR[K].textPositions.height=n1;gR[K].output=""if hG*2>n0 then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mS-hG>2 then gR[K].output=de('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mS,iN,0.1*n7)end;gR[K].output=gR[K].output..de('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hG,iN,0.2*n7)if dr.systemId==0 then gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mf,m_,iM,jI,mT)if hG*2<=n0 then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mf+n0,m_+2,mf,m_+2,hk,hl)end else gR[K].output=gR[K].output..de([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mf,m_,iN,jI,mT)if hG*2<=n0 then gR[K].output=gR[K].output..de("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mf,m_+2,mf+n0,m_+2,hk,hl)end end end;for dF=#c_,1,-1 do if gR[dF]then jO[#jO+1]=gR[dF].output end end;if mH~=nil and d0<90 and not mH.hovered then local n8=mH.planet.atmosphereRadius/mH.atmoSize;local n9=dh(mG)*n8;local na=ip(n9,1)local n0=j2(math.max(string.len(na)*7,string.len(mH.planet.name)*7))local n1=j3(12)local mf=df(mH.x+(ml-mH.x)/2,m3+n0/2,mn-n0/2)local m_=df(mH.y+(mm-mH.y)/2,m4+n1*2,mo-5)jO[#jO+1]=de("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mH.x,mH.y,ml,mm)jO[#jO+1]=de([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mf,m_,"white",na)if not mH.visible then jO[#jO+1]=de([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mf,m_-n1,"white",mH.planet.name)end end;if cG>1 then local gQ=cF;local mJ=gQ:normalize()local mM=gQ:project_on_plane(cC):len()local mK=gQ:cross(cC):normalize()local mL=math.acos(mK:dot(cD))if mL~=mL then mL=0 end;if mK:cross(cD):dot(cC)<0 then mL=-mL end;local mN=math.sin(mL)*math.asin(mM/gQ:len())*constants.rad2deg;local mO=math.cos(mL)*math.asin(mM/gQ:len())*constants.rad2deg;if mJ:dot(cC)<0 then mO=90*math.cos(mL)+90*math.cos(mL)-mO;mN=90*math.sin(mL)+90*math.sin(mL)-mN end;local hk=ml+mN/mD*mh;local hl=mm+mO/mD*mh;local kJ=14;local kK=kJ/2;local kN=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kK/kJ..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kJ..[[,]]..hl..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+kK..[[,]]..hl..[[ h ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kJ..[[ v ]]..kK..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kN end;jO[#jO+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ml,mm-10,ml,mm+10)jO[#jO+1]=de("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",ml-10,mm,ml+10,mm)jO[#jO+1]='</g>'else return jO end end;local function nb(nc,nd)local ne;local nf=(nd-nc):normalize()local fs=(cJ-nc):dot(nf)/nf:dot(nf)if fs<=0. then return(cJ-nc):len()elseif fs>=(nd-nc):len()then return(cJ-nd):len()end;local ng=nc+fs*nf;ne=(ng-cJ):len()return ne end;local function nh()local ne;local ni=nil;local nj=nil;local nk=nil;for dF,nl in pairs(e[0])do if nl.hasAtmosphere then local c4=nb(j1.center,nl.center)if ni==nil or c4<ni then nj=nl;ni=c4;nk=j1 end;if c1 and c1.hasAtmosphere and c1.name~=j1.name then local eK=nb(c1.center,nl.center)if eK<ni then nj=nl;ni=eK;nk=c1 end end end end;local nm=j2(1770)local nn=j3(330)if ni then local no="txttick "local np=500000;if ni<nj.radius+np or ni<nk.radius+np then if cQ then no="txttick red "else no="txttick orange "end end;ne=ip(ni,2)iD=gJ(nm,nn,"Pipe ("..nk.name.."--"..nj.name.."): "..ne,no.."pbright txtmid")end end;local function nq(hk,hl,nr,ns,kW)local nt={x=hk,y=hl,width=nr,height=ns,label=kW}ix[kW]=nt;return nt end;local function nu(nv,nw,nr,ns,hk,hl,nx,ny,nz,nA,jI)local nt={enableName=nv,disableName=nw,width=nr,height=ns,x=hk,y=hl,toggleVar=nx,toggleFunction=ny,drawCondition=nz,hovered=false,class=jI}if nA then table.insert(iw,nt)else table.insert(iv,nt)end;return nt end;local function nB(nC)if not iB then nD=false;nE=false;nF=false;w=true;return elseif nC=="handling"then nD=not nD;nE=false;nF=false elseif nC=="hud"then nE=not nE;nD=false;nF=false elseif nC=="physics"then nF=not nF;nD=false;nE=false end;if nF or nE or nD then iC=io(nC)w=false else iC="none"w=true end end;local function nG()iB=not iB;if iB then iu=iw;bX="Hold SHIFT to see Settings"d1=w else iu=iv;bX="Hold SHIFT to see Control Buttons"nB()w=d1 end end;local function nH()local function nI(dr,dF)dr.set(not dr.get())if dr.get()then bX=dF.." set to true"else bX=dF.." set to false"end;if dF=="showHud"then d1=dr.get()elseif dF=="BrakeToggleDefault"then aX=j end end;local nJ=50;local nK=340;local hk=500;local hl=cf/2-400;local nL=0;for dF,dr in pairs(io("boolean"))do if type(dr.get())=="boolean"then nu(dF,dF,nK,nJ,hk,hl,function()return dr.get()end,function()nI(dr,dF)end,function()return true end,true)hl=hl+nJ+20;if nL==9 then hk=hk+nK+20;hl=cf/2-400;nL=0 else nL=nL+1 end end end;nu("Control View","Control View",nK,nJ,10,cf/2-500,function()return true end,nG,function()return true end,true)nu("View Handling Settings",'Hide Handling Settings',nK,nJ,10,cf/2-(500-nJ),function()return nD end,function()nB("handling")end,function()return true end,true)nu("View Hud Settings",'Hide Hud Settings',nK,nJ,10,cf/2-(500-nJ*2),function()return nE end,function()nB("hud")end,function()return true end,true)nu("View Physics Settings",'Hide Physics Settings',nK,nJ,10,cf/2-(500-nJ*3),function()return nF end,function()nB("physics")end,function()return true end,true)end;local function nM()local function gt()local fT=cJ;local gu=j1.name..". "..#bn;if radar_1 then gu=cp.GetClosestName(gu)end;return cn.AddNewLocation(gu,fT,false,true)end;local function nN()b2=not b2 end;local function nO(nP)if nP==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bV=false;b4=false;br=nil;b6=false;b5=false end;local function nQ(nR,nS)cn.UpdatePosition(nil,nR,nS)end;local function go()cn.ClearCurrentPosition()end;local function nT(gs)local lW=co.routeWP(true)if lW and#lW>0 then return"Engage Route: "..lW[1]end;return"Engage Autopilot: "..lU(gs)end;local function nU(gs)local lW=co.routeWP(true)if lW and#lW>0 then return"Next Route Point: "..lW[1]end;return"Disable Autopilot: "..lU(gs)end;local function nV()if ij()==1 then bV=not bV;if bV then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nW=bk;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cu=p;bk=nW;if bk then d.control.extendLandingGears()ik:setTargetGroundAltitude(Y)end end else bX="Follow Mode only works with Remote controller"bV=false end end;local nJ=50;local nK=260;local nX=j2(30)local nY=ay+ax*2+2;local nZ=az+1;nu("+","+",nX,nX,nY,nZ+nX+1,function()return false end,function()d0=d0/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nu("-","-",nX,nX,nY,nZ,function()return false end,function()d0=math.min(d0*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nu("0","0",nX,nX,nY,nZ+nX*2+2,function()return false end,function()d0=90 end,function()return bF=="SCOPE"and d0~=90 end,nil,"ZoomButton")local n_=nu("Enable Brake Toggle","Disable Brake Toggle",nK,nJ,ce/2-nK/2,cf/2+350,function()return aX end,function()aX=not aX;if aX then bX="Brakes in Toggle Mode"else bX="Brakes in Default Mode"end end)nu("Align Prograde","Disable Prograde",nK,nJ,ce/2-nK/2-50-n_.width,cf/2-nJ+380,function()return b0 end,function()nO(1)end)nu("Align Retrograde","Disable Retrograde",nK,nJ,ce/2-nK/2+n_.width+50,cf/2-nJ+380,function()return a_ end,nO,function()return ca==0 end)o0=nu(nT,nU,600,60,ce/2-600/2,cf/2-60/2-330,function()return b1 or bo or c6 or bx end,function()end)local K;local function o1(o2)local gs=cX+o2;if gs>#cP then gs=gs-#cP-1 end;if gs<0 then gs=#cP+gs end;return gs end;o3={}for K=0,10 do local o4=nu(function(ey)local gs=o1(ey.apExtraIndex)if b1 or bo or c6 or bx then return"Redirect: "..lU(gs)end;return nT(gs)end,function(ey)local gs=o1(ey.apExtraIndex)return nU(gs)end,600,60,ce/2-600/2,cf/2-60/2-330+60*K,function(ey)local gs=o1(ey.apExtraIndex)return gs==bj and(b1 or bo or c6 or bx)end,function(ey)local gs=o1(ey.apExtraIndex)local o5=bj==gs;bj=gs;cn.UpdateAutopilotTarget()co.ToggleAutopilot()if not o5 and not(b1 or bo or c6 or bx)then co.ToggleAutopilot()end end,function()return cW and(#co.routeWP(true)==0 or K==0)end)o4.apExtraIndex=K;o3[K]=o4 end;nu("Save Position","Save Position",200,o0.height,o0.x+o0.width+30,o0.y,function()return false end,gt,function()return bj==0 or g1==nil end)nu("Update Position","Update Position",200,o0.height,o0.x+o0.width+30,o0.y,function()return false end,function()nQ(nil)end,function()return bj>0 and g1~=nil end)nu("Save Heading","Clear Heading",200,o0.height,o0.x+o0.width+30,o0.y+o0.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nQ(false)else nQ(true)end end,function()return bj>0 and g1~=nil end)nu("Save AGG Alt","Clear AGG Alt",200,o0.height,o0.x+o0.width+30,o0.y+o0.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nQ(nil,false)else nQ(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nu("Clear Position","Clear Position",200,o0.height,o0.x-200-30,o0.y,function()return true end,go,function()return bj>0 and g1~=nil end)nu("Save Route","Save Route",200,o0.height,o0.x-200-30,o0.y+o0.height*2+40,function()return false end,function()co.routeWP(false,false,2)end,function()return#co.routeWP(true)>0 end)nu("Load Route","Clear Route",200,o0.height,o0.x-200-30,o0.y+o0.height+20,function()return#co.routeWP(true)>0 end,function()if#co.routeWP(true)>0 then co.routeWP(false,true)elseif b1 or bo then bX="Disable Autopilot before loading route"return else co.routeWP(false,false,1)end end,function()return true end)nJ=60;nK=300;local hk=0;local hl=cf/2-150;nu("Enable Check Damage","Disable Check Damage",nK,nJ,hk,hl-nJ-20,function()return s end,function()s=not s end)nu("View Settings","View Settings",nK,nJ,hk,hl,function()return true end,nG)hl=hl+nJ+20;nu("Enable Turn and Burn","Disable Turn and Burn",nK,nJ,hk,hl,function()return b2 end,nN)hk=10;hl=cf/2-300;nu("Horizontal Takeoff Mode","Vertical Takeoff Mode",nK,nJ,hk+nK+20,hl,function()return aY end,function()aY=not aY;if aY then bX="Vertical Takeoff Mode"else bX="Horizontal Takeoff Mode"end end,function()return cK end)hl=hl+nJ+20;nu("Engage Orbiting","Cancel Orbiting",nK,nJ,hk+nK+20,hl,function()return bx end,co.ToggleIntoOrbit,function()return ca==0 and cT end)hl=cf/2-150;nu("Glide Re-Entry","Cancel Glide Re-Entry",nK,nJ,hk+nK+20,hl,function()return b6 end,function()c5=1;nO(1)end,function()return j1.hasAtmosphere and not c9 end)hl=hl+nJ+20;nu("Parachute Re-Entry","Cancel Parachute Re-Entry",nK,nJ,hk+nK+20,hl,function()return b6 end,function()c5=2;nO(1)end,function()return j1.hasAtmosphere and not c9 end)hl=hl+nJ+20;nu("Engage Follow Mode","Disable Follow Mode",nK,nJ,hk,hl,function()return bV end,nV,function()return ij()==1 end)nu("Enable Repair Arrows","Disable Repair Arrows",nK,nJ,hk+nK+20,hl,function()return iS end,function()iS=not iS;if iS then bX="Repair Arrows Enabled"else bX="Repair Arrows Diabled"end end,function()return ij()==1 end)hl=hl+nJ+20;if not q then nu("Enable AGG","Disable AGG",nK,nJ,hk,hl,function()return cL end,co.ToggleAntigrav,function()return antigrav~=nil end)end;nu(function()return de("Switch IPH Mode - Current: %s",by)end,function()return de("IPH Mode: %s",by)end,nK*2,nJ,hk,hl,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bX="IPH Mode: "..by end)hl=hl+nJ+20;nu(function()return de("Toggle Control Scheme - Current: %s",g)end,function()return de("Control Scheme: %s",g)end,nK*2,nJ,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bX="New Control Scheme: "..g end)local o6=j3(20)local o4=nq(0,0,j2(70),o6,"HELP")o4=nq(o4.x+o4.width,o4.y,j2(80),o6,"INFO")o4=nq(o4.x+o4.width,o4.y,j2(70),o6,"ORBIT")o4=nq(o4.x+o4.width,o4.y,j2(70),o6,"SCOPE")nq(o4.x+o4.width,o4.y,j2(70),o6,"HIDE")end;local o7={}local o8=nil;function o7.HUDPrologue(jO)cQ,cR=i_(cJ)if not cQ then iJ=af;iK=ag;iL=ah else iJ=ac;iK=ad;iL=ae end;iM=[[rgb(]]..bI(iJ+0.6)..","..bI(iK+0.6)..","..bI(iL+0.6)..[[)]]iN=[[rgb(]]..bI(iJ*0.8+0.5)..","..bI(iK*0.8+0.5)..","..bI(iL*0.8+0.5)..[[)]]local o9=iM;local oa=iN;local ob=[[rgb(]]..bI(iJ*0.4+0.5)..","..bI(iK*0.4+0.5)..","..bI(iL*0.4+0.5)..[[)]]local oc=iM;local od=iN;local oe=ob;if j4()and not m then o9=[[rgb(]]..bI(iJ*0.5+0.5)..","..bI(iK*0.5+0.5)..","..bI(iL*0.5+0.5)..[[)]]oa=[[rgb(]]..bI(iJ*0.3+0.5)..","..bI(iK*0.3+0.5)..","..bI(iL*0.2+0.5)..[[)]]ob=[[rgb(]]..bI(iJ*0.2+0.5)..","..bI(iK*0.2+0.5)..","..bI(iL*0.2+0.5)..[[)]]end;local lJ=j2;local lK=j3;jO[#jO+1]=de([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],o9,o9,o9,oc,oc,oa,oa,od,od,oa,o9,ob,od,o9,o9,ob,ob,oe,ob,ce,cf,oa,oa,oa,oa,oa,oc,oa,od,oe,od,od,oe)if not o8 then o8=de([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lJ(630),lK(0),lJ(675),lK(45),lJ(960),lK(55),lJ(1245),lK(45),lJ(1290),lK(0),lJ(1000),lK(105),lJ(1040),lK(59),lJ(1250),lK(51),lJ(1300),lK(0),lJ(1920),lK(0),lJ(1920),lK(20),lJ(1400),lK(20),lJ(1300),lK(105),lJ(920),lK(105),lJ(880),lK(59),lJ(670),lK(51),lJ(620),lK(0),lJ(0),lK(0),lJ(0),lK(20),lJ(520),lK(20),lJ(620),lK(105),lJ(890),lK(59),lJ(960),lK(62),lJ(1030),lK(59),lJ(985),lK(112),lJ(1150),lK(112),lJ(1100),lK(152),lJ(820),lK(152),lJ(780),lK(112),lJ(935),lK(112),lJ(890),lK(59),lJ(960),lK(62),lJ(1030),lK(59),lJ(985),lK(112),lJ(1150),lK(112),lJ(1100),lK(152),lJ(820),lK(152),lJ(780),lK(112),lJ(935),lK(112))end;if w and I then jO[#jO+1]=o8 end;return jO end;function o7.DrawVerticalSpeed(jO,dZ)jN(jO,dZ)end;function o7.UpdateHud(jO)local kC=cN;local of=cO;local jV=of;local ka=kC;local kU=bI(c.getThrottle())local kZ=cG*3.6;local kV=c.getAxisCommandValue(0)local og=j2(1770)local oh=j3(310)if t and cM then kV=bL;kU=bL*100 end;local j6=j5()local jW="ROLL"if kU==nil then kU=0 end;if not cT then if cG>5 then kC=kB(cE)of=kD(cE)else kC=0;of=0 end;jW="YAW"end;if cR>50000 and not c9 then local oi;oi=ip(cR)jO[#jO+1]=gJ(og,oh,"PvP Boundary: "..oi,"pbright txtbig txtmid")end;jO[#jO+1]=iQ;jO[#jO+1]=iH;jO[#jO+1]=hV;if iD~=""then jO[#jO+1]=iD end;if j7~=""then jO[#jO+1]=j7 end;if j8~=""then jO[#jO+1]=j8 end;jN(jO,cb)if ij()==0 or l then if not j4()or m then if cT then jU(jO,ai,aj,jV,jW,cT)k9(jO,ka,jV,ai,aj,cT,bI(kD(cE)),cG)else jU(jO,ai,aj,of,jW,cT)k9(jO,kC,of,ai,aj,cT,bI(of),cG)end;kg(jO,cb,cT)kE(jO,cE,cG,ai,aj)end end;kT(jO,j6,kU,kV)kY(jO,kZ)l1(jO)m2(jO)if not iB and bW then lV(jO)end;return jO end;function o7.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o7.ExtraData(jO)local oj=j2(1240)local ok=j3(55)local ol=ok+10;local om;local lJ=j2;local lK=j3;local on=0;local j6=j5()if aY then j6=j6 .."-VERTICAL"end;if E and not b5 and not b4 and cG>20 then j6=j6 .."-COLLISION ON"end;if bA~="Off"then j6="("..bA..")-"..j6 end;if b2 then j6="TB-"..j6 end;if not bz then j6=j6 .."-DeCoupled"end;local oo=lK(99)local op=lK(80)local oq=lK(85)local os=lK(31)local ot=0;local ou=0;local ov=cc>1000000 and fR(cc/1000000,2).."kT"or fR(cc/1000,2).."T"if c9 then on=bs else on=bq end;local ow,ox=ck.computeDistanceAndTime(cG,0,cc,0,0,on)if ow<0 then ow=0 end;on=fR(on/(cc*it),2).."g"local oy=d:maxForceForward()om=b.g()if om>0.1 then ou=cc*om;ou=fR(ou/(cc*it),2).."g"ot=0.5*oy/om;ot=ot>1000000 and fR(ot/1000000,2).."kT"or fR(ot/1000,2).."T"end;oy=fR(oy/(cc*it),2).."g"local oz=vec3(b.getWorldAcceleration()):len()/9.80665;om=b.g()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if ij()==1 and not l then oj=j2(1120)ok=j3(55)ol=ok+10 elseif c9 and I then local oA=j2(770)jO[#jO+1]=gJ(lJ(895),oo,"ATMO","")jO[#jO+1]=de([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lJ(895),oq,lJ(-80))jO[#jO+1]=gJ(lJ(815),op,de("%.1f%%",ca*100),"txtstart size20")end;if I then jO[#jO+1]=gJ(lJ(1025),oo,"GRAVITY","txtstart")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1025),oq,lJ(80))jO[#jO+1]=gJ(lJ(1105),op,de("%.2fg",om/9.80665),"size20")jO[#jO+1]=gJ(lJ(1125),oo,"ACCEL","txtstart")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1125),oq,lJ(80))jO[#jO+1]=gJ(lJ(1205),op,de("%.2fg",oz),"size20")jO[#jO+1]=gJ(lJ(695),oo,"BRK TIME","")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(695),oq,lJ(-80))jO[#jO+1]=gJ(lJ(615),op,de("%s",iq(ox)),"txtstart size20")jO[#jO+1]=gJ(lJ(635),lK(45),"TRIP","")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(635),lK(31),lJ(-90))if lD then jO[#jO+1]=gJ(lJ(545),lK(26),de("%s",iq(lD)),"txtstart size20")end;jO[#jO+1]=gJ(lJ(795),oo,"BRK DIST","")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(795),oq,lJ(-80))jO[#jO+1]=gJ(lJ(715),op,de("%s",ip(ow)),"txtstart size20")jO[#jO+1]=gJ(lJ(1285),lK(45),"MASS","txtstart")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1285),lK(31),lJ(90))jO[#jO+1]=gJ(lJ(1375),lK(26),de("%s",ov),"size20")jO[#jO+1]=gJ(lJ(1220),oo,"THRUST","txtstart")jO[#jO+1]=de([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lJ(1220),oq,lJ(80))jO[#jO+1]=gJ(lJ(1300),op,de("%s",oy),"size20")jO[#jO+1]=gJ(j2(960),j3(175),j6,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local oB=1-(a5*0.05+a6*0.05)function o7.FuelUsed(oC)local oD;if oC=="atmofueltank"then oD=de("Atmo Fuel Used: %.1f L",jp[oC]/(4*oB))elseif oC=="spacefueltank"then oD=de("Space Fuel Used: %.1f L",jp[oC]/(6*oB))else oD=de("Rocket Fuel Used: %.1f L",jp[oC]/(0.8*oB))end;return oD end;function o7.DrawOdometer(jO,iO,bl,iP)if bF~="INFO"then return jO end;local om;local ot=0;local ou=0;local on=0;local ov=cc>1000000 and fR(cc/1000000,2).." kTons"or fR(cc/1000,2).." Tons"if c9 then on=bs else on=bq end;local ow,ox=ck.computeDistanceAndTime(cG,0,cc,0,0,on)on=fR(on/(cc*it),2).." g"local oy=d:maxForceForward()om=b.g()if om>0.1 then ou=cc*om;ou=fR(ou/(cc*it),2).." g"ot=0.5*oy/om;ot=ot>1000000 and fR(ot/1000000,2).." kTons"or fR(ot/1000,2).." Tons"end;oy=fR(oy/(cc*it),2).." g"if ij()==0 or l then local oE=j2(ay+10)local oF=j3(az+20)local oG=j2(ay+10+ax/1.25)local ns=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gJ(oE,oF,de("BrkTime: %s",iq(ox)))jO[#jO+1]=gJ(oG,oF,de("Trip: %.2f km",iO))jO[#jO+1]=gJ(oE,oF+ns,de("Lifetime: %.2f kSU",bl/200000))jO[#jO+1]=gJ(oG,oF+ns,de("BrkDist: %s",ip(ow)))jO[#jO+1]=gJ(oE,oF+ns*2,"Trip Time: "..iq(iP))jO[#jO+1]=gJ(oG,oF+ns*2,"Total Time: "..iq(bm))jO[#jO+1]=gJ(oE,oF+ns*3,de("Mass: %s",ov))jO[#jO+1]=gJ(oG,oF+ns*3,de("Max Brake: %s",on))jO[#jO+1]=gJ(oE,oF+ns*4,de("Max Thrust: %s",oy))if om>0.1 then jO[#jO+1]=gJ(oG,oF+ns*4,de("Max Thrust Mass: %s",ot))jO[#jO+1]=gJ(oE,oF+ns*5,de("Req Thrust: %s",ou))else jO[#jO+1]=gJ(oG,oF+ns*4,"Max Mass: n/a")jO[#jO+1]=gJ(oE,oF+ns*5,"Req Thrust: n/a")end;jO[#jO+1]=gJ(oG,oF+ns*5,cm.FuelUsed("atmofueltank"))jO[#jO+1]=gJ(oE,oF+ns*6,cm.FuelUsed("spacefueltank"))jO[#jO+1]=gJ(oG,oF+ns*6,cm.FuelUsed("rocketfueltank"))jO[#jO+1]=gJ(oE,oF+ns*7,de("Set Max Speed: %s",bI(_*3.6+0.5)))jO[#jO+1]=gJ(oG,oF+ns*7,de("Actual Max Speed: %s",bI(da*3.6+0.5)))end;jO[#jO+1]="</g></g>"return jO end;function o7.DrawWarnings(jO)return l1(jO)end;function o7.DisplayOrbitScreen(jO)return m2(jO)end;function o7.DisplayMessage(jO,lo)if lo~="empty"then local hl=310;for lx in string.gmatch(lo,"([^\n]+)")do hl=hl+35;jO[#jO+1]=gJ("50%",hl,lx,"msg")end end;if bY~=0 then c.setTimer("msgTick",bY)bY=0 end end;function o7.DrawDeadZone(jO)jO[#jO+1]=de([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function o7.UpdatePipe()if c9 then iD=""return end;nh()end;function o7.DrawSettings(jO)local hk=j2(640)local hl=j3(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hD=0;for dF,dr in pairs(iC)do hD=hD+1;jO[#jO+1]=gJ(hk,hl,dF..": "..dr.get())hl=hl+20;if hD%12==0 then hk=hk+j2(350)hl=j3(200)end end;jO[#jO+1]=gJ(j2(640),j3(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local hT=j3(15)local hS=j2(1370)local hW,oH;function o7.DrawRadarInfo()hV=cp.GetRadarHud(hS,hT,au,av)end;function o7.DrawTanks()if aq~=0 and ar~=0 then j7=gJ(aq,ar,"","txtstart pdim txtfuel")jq=ar;jr(aq,"Atmospheric ","ATMO",cg,jn,jo)jr(aq,"Space Fuel T","SPACE",ch,jl,jm)jr(aq,"Rocket Fuel ","ROCKET",ci,jj,jk)end end;function o7.DrawShield()local i2=db.getState()==1 and"Shield Active"or"Shield Disabled"local oI=b.getPvPTimer()local oJ=db.getResistances()local oK="A: "..10+oJ[1]*100 .."% / E: "..10+oJ[2]*100 .."% / K:"..10+oJ[3]*100 .."% / T: "..10+oJ[4]*100 .."%"local hk,hl=as-60,at+30;local jG=bI(dc*2.55)local jH=de("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""j8=gJ(hk,hl,"","txtmid pdim txtfuel")if dc<10 and i2~="Shield Disabled"then jI="red "end;oI=oI>0 and"   PvPTime: "..iq(oI)or""j8=j8 ..de([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jH,dc*2,hk,hl,hk+2,hl+10,dc,oI)j8=j8 ..gJ(hk,hl-5,i2,jI.."txtstart pbright txtbig")j8=j8 ..gJ(hk,hl+30,oK,jI.."txtstart pbright txtsmall")end;function o7.hudtick()if not j1 then return end;local function oL(jO)local jK=bI(df(d8/(ce/4)*255,0,255))jO[#jO+1]=de("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c2,c3,bI(iJ+0.5)+jK,bI(iK+0.5)-jK,bI(iL+0.5)-jK)end;local function oM()for dK,dr in pairs(iu)do if dr.hovered then if not dr.drawCondition or dr.drawCondition(dr)then dr.toggleFunction(dr)end;dr.hovered=false end end;for dK,dr in pairs(ix)do if dr.hovered then bF=dr.label;dr.hovered=false end end end;local function oN()local function oO(oP,oQ,hk,hl,nr,ns)if oP>=hk and oP<=hk+nr and oQ>=hl and oQ<=hl+ns then return true else return false end end;local hk=c2+ce/2;local hl=c3+cf/2;for dK,dr in pairs(iu)do dr.hovered=oO(hk,hl,dr.x,dr.y,dr.width,dr.height)end;for dK,dr in pairs(ix)do dr.hovered=oO(hk,hl,dr.x,dr.y,dr.width,dr.height)end;if cW then local n6=false;for dK,ey in ipairs(o3)do if ey.hovered then n6=true;break end end;if o0.hovered then n6=true end;cW=n6 else cW=o0.hovered;if not cW then cX=bj end end end;local function oR(jO)if not bF or bF==""then bF="HELP"end;if w then for dF,dr in pairs(ix)do local jI="dim brightstroke"local oS=0.2;if bF==dF then jI="pbright dimstroke"oS=0.6 end;local oT=""if dr.hovered then oS=0.8;oT=";stroke:white"end;jO[#jO+1]=de([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dr.width,dr.height,dr.x,dr.y,jI,oS,oT)jO[#jO+1]=gJ(dr.x+dr.width/2,dr.y+dr.height/2+5,dr.label,"txt txtmid pdim")end end end;local function oU(jO)local function oV(jO,oW,hover,hk,hl,fe,oX,oY,oZ,o_,p0,o4)if type(o_)=="function"then o_=o_(o4)end;if type(p0)=="function"then p0=p0(o4)end;jO[#jO+1]=de("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fe,oX)if oW then jO[#jO+1]=de("%s'",oY)else jO[#jO+1]=oZ end;if hover then jO[#jO+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jO[#jO+1]=de(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=de("<text x='%f' y='%f' font-size='24' fill='",hk+fe/2,hl+oX/2+5)if oW then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oW then jO[#jO+1]=de("%s</text>",o_)else jO[#jO+1]=de("%s</text>",p0)end end;local p1=de("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local p2=de("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local p3=oV;for dK,dr in pairs(iu)do local nw=dr.disableName;local nv=dr.enableName;if type(nw)=="function"then nw=nw(dr)end;if type(nv)=="function"then nv=nv(dr)end;if not dr.drawCondition or dr.drawCondition(dr)then p3(jO,dr.toggleVar(dr),dr.hovered,dr.x,dr.y,dr.width,dr.height,p2,p1,nw,nv,dr)end end end;local p4=fR(ce/2,0)local p5=fR(cf/2,0)local jO={}if p6 then jO[#jO+1]=p6 end;cm.HUDPrologue(jO)if w then cm.UpdateHud(jO)else if A then cm.DrawVerticalSpeed(jO,cb)end;cm.DrawWarnings(jO)end;if iB and iC~="none"then cm.DrawSettings(jO)end;if radar_1 then cm.DrawRadarInfo()end;cm.HUDEpilogue(jO)jO[#jO+1]=de([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ce,cf)if bX~="empty"then cm.DisplayMessage(jO,bX)end;if ij()==0 and g=="virtual joystick"then if v then cm.DrawDeadZone(jO)end end;oR(jO)if il()==0 then if ij()==1 and bW then if not p7 then oN()oU(jO)end;if not cs and not ct then local p8=table.concat(jO,"")jO={}jO[#jO+1]=de("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jO[#jO+1]=p8;jO[#jO+1]="</body>"cs=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif ct then local p8=table.concat(jO,"")jO={}jO[#jO+1]=de("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ce,cf)jO[#jO+1]=p8;jO[#jO+1]="</body>"end;if not cs then jO[#jO+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,c2,c3)end else oM()end else if not bW and ij()==0 then oM()if d8>aw then if v then oL(jO)end end elseif bW and(not p7 or not i)then oN()oU(jO)end;jO[#jO+1]=de([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p4,p5,c2,c3)end;jO[#jO+1]=[[</svg></body>]]p9=table.concat(jO,"")end;function o7.TenthTick()local function pa()local pb=a.createData;local pc=a.createWidget;pd=a.createWidgetPanel("Interplanetary Helper")pe=pc(pd,"value")pf=pb('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(pf,pe)pg=pc(pd,"value")ph=pb('{"label": "distance", "value": "N/A", "unit":""}')fP(ph,pg)gi=pc(pd,"value")gh=pb('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=pc(pd,"value")gf=pb('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=pc(pd,"value")gj=pb('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=pc(pd,"value")gb=pb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=pc(pd,"value")g9=pb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=pc(pd,"value")g7=pb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=pc(pd,"value")g5=pb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=pc(pd,"value")gd=pb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not c9 then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function pi()gI(pd)pd=nil end;local function pj()if not b1 then if g1==nil or g1.planetname~=j1.name then pk=(c1.center-cJ):len()else pk=(g1.position-cJ):len()end end;local fl=cG;local pl=c.getThrottle()/100;if t then pl=bL end;local pm,pn=ck.computeDistanceAndTime(cG,_,cc,d:maxForceForward()*pl,a1,0)local b_,c0;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local dK,po;if not b2 and fl>0 then dK,po=co.GetAutopilotBrakeDistanceAndTime(fl)else dK,po=co.GetAutopilotTBBrakeDistanceAndTime(fl)end;local pp=0;local pq=0;if bc or not b1 and fl>5 then pq=ck.computeTravelTime(fl,0,pk)elseif b_+pm<pk then pp=pk-(b_+pm)pq=ck.computeTravelTime(8333.0556,0,pp)else local pr=(pk-b_)/pm;pm=pk-b_;pn=pn*pr end;if g1~=nil and g1.planetname==j1.name and not b1 then return pq elseif bb then return po elseif bc then return pq+po else return pn+c0+pq end end;cm.DrawTanks()if db then cm.DrawShield()end;if bh~="None"then if pd==nil then pa()end;if bh~=nil then local mI;local ps=g1~=nil;local pt=0.5*bs/c1:getGravity(c1.center+vec3(0,0,1)*c1.radius):len()pt=pt>1000000 and fR(pt/1000000,2).." kTons"or fR(pt/1000,2).." Tons"fO(pf,'{"label": "Target", "value": "'..bh..'", "unit":""}')lD=pj()if ps and not b1 then mI=(cJ-g1.position):len()else mI=(bi-cJ):len()end;if not b2 then b_,c0=co.GetAutopilotBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotBrakeDistanceAndTime(_)else b_,c0=co.GetAutopilotTBBrakeDistanceAndTime(cG)iF,iG=co.GetAutopilotTBBrakeDistanceAndTime(_)end;local lo=ip(mI)fO(ph,'{"label": "distance", "value": "'..lo..'"}')fO(gh,'{"label": "Travel Time", "value": "'..iq(lD)..'", "unit":""}')lo=ip(b_)fO(gb,'{"label": "Cur Brake distance", "value": "'..lo..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..iq(c0)..'", "unit":""}')lo=ip(iF)fO(g7,'{"label": "Max Brake distance", "value": "'..lo..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..iq(iG)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..de("%s",pt)..'", "unit":""}')lo=ip(gl)fO(gj,'{"label": "Target Orbit", "value": "'..lo..'"}')if c9 and not pu then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pu=true;if not cM and t and(b3 or b6 or c7)then co.cmdThrottle(1)aZ=false;bP=false end end;if not c9 and pu then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pu=false end end else pi()end;if warpdrive~=nil then local pv=ih(warpdrive.getData())if pv.destination~="Unknown"and pv.distance>400000 then if not iT then warpdrive.show()iT=true end elseif iT then warpdrive.hide()iT=false end end end;function o7.OneSecondTick()local function pw()local jB=bH()local kZ=cG;local px=jB-iR;if kZ>1.38889 then kZ=kZ/1000;local py=kZ*(jB-iR)bl=bl+py;iO=iO+py end;iP=iP+px;bm=bm+px;iR=jB end;local function pz(jO)local pA=0;iH=""local pB=is;local pC=0;local pD=0;local pE=0;local jG=0;local jH=""local pF=b.getElementHitPointsById;local pG=b.getElementMaxHitPointsById;local pH={}for dF in pairs(ir)do local pI=0;local pJ=0;pJ=pG(ir[dF])pI=pF(ir[dF])pC=pC+pI;if pI<pJ then if pI==0 then pE=pE+1 else pD=pD+1 end;if iS and#pH==0 then fT=vec3(b.getElementPositionById(ir[dF]))local hk=fT.x;local hl=fT.y;local hm=fT.z;table.insert(pH,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(pH,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(pH[2],0,0,90)table.insert(pH,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(pH,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(pH[4],90,90,0)table.insert(pH,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(pH,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(pH[6],90,-90,0)table.insert(pH,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(pH,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(pH[8],90,0,90)table.insert(pH,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(pH,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(pH[10],-90,0,90)table.insert(pH,ir[dF])end elseif iS and#pH>0 and pH[11]==ir[dF]then for jA in pairs(pH)do b.deleteSticker(pH[jA])end;pH={}end end;pA=math.ceil(pC/pB*100)if pA<100 then jO[#jO+1]=gJ(0,0,"","pbright txt")jG=bI(pA*2.55)jH=de("rgb(%d,%d,%d)",255-jG,jG,0)if pA<100 then jO[#jO+1]=gJ("50%",1035,"Elemental Integrity: "..pA.."%","txtbig txtmid","fill:"..jH)if pE>0 then jO[#jO+1]=gJ("50%",1055,"Disabled Modules: "..pE.." Damaged Modules: "..pD,"txtbig txtmid","fill:"..jH)elseif pD>0 then jO[#jO+1]=gJ("50%",1055,"Damaged Modules: "..pD,"txtbig txtmid","fill:"..jH)end end end end;local function pK()if ig then if iI==nil and(d3~=nil or bk)then _autoconf.displayCategoryPanel(ig,weapon_size,"Weapons","weapon",true)iI=_autoconf.panels[_autoconf.panels_size]elseif iI~=nil and d3==nil and not bk then gI(iI)iI=nil end end end;cY=b.getPlayersOnBoard()cZ=b.getDockedConstructs()local jO={}pw()if s then pz(jO)end;pK()cm.UpdatePipe()cm.ExtraData(jO)iQ=table.concat(jO,"")da=b.getMaxSpeed()end;function o7.AnimateTick()ct=true;cs=false;c2=0;c3=0;c.stopTimer("animateTick")end;function o7.MsgTick()local jO={}cm.DisplayMessage(jO,"empty")bX="empty"c.stopTimer("msgTick")bY=3 end;function o7.ButtonSetup()nH()nM()iu=iv end;if pL then for dF,dr in pairs(pL)do o7[dF]=dr end end;return o7 end;local function pM(d,b,c,a,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,pO,ih,de,fP)local pP={}local pQ=false;local pR=0;local pS=0;local pT=0;local pU=bH()local pV=0;local pW=0;local pX=0;local pY=0;local pZ=false;local p_=false;local q0=false;local q1=nil;local q2=0;local iE=55;local q3=nil;local q4=false;local q5=false;local q6=false;local q7=0;local q8=0;local q9=0;local qa=0;local qb=0;local qc={VectorToTarget=false}local qd=vec3(b.getConstructWorldOrientationUp())local qe=nil;local qf=0;local qg=-1;local qh=-1;local qi=false;local qj=false;local qk=0;local ql=false;local qm=false;local qn=false;local qo=false;local qp=""local qq=false;local qr=false;local qs=""local qt=false;local qu=0;local function qv(fl)local qw=bd;if not b1 then qw=0 end;local qx=bq;if c9 then if bs and bs>0 then qx=bs else return 0,0 end end;return ck.computeDistanceAndTime(fl,qw,cc,0,0,qx-bf*cc)end;local function qy(fl)local qw=bd;if not b1 then qw=0 end;return ck.computeDistanceAndTime(fl,qw,cc,d:maxForceForward(),a1,bq-bf*cc)end;local function qz(qA,qB,qC)qB=qB:project_on_plane(qA)qC=qC:project_on_plane(qA)return eP(qB:cross(qC):dot(qA),qB:dot(qC))end;local function qD()local function qE()local qF=-1;local qG=-1;if vBooster then qF=vBooster.getDistance()end;if hover then qG=hover.getDistance()end;if qF~=-1 and qG~=-1 then if qF<qG then return qF else return qG end elseif qF~=-1 then return qF elseif qG~=-1 then return qG else return-1 end end;local qH=qE()local qI=-1;if antigrav and antigrav.getState()==1 and not q and cG<iE then local qJ=eU(cb-antigrav.getBaseAltitude())if qJ<50 then return qJ end end;if pN then qI=pN.getDistance()end;if qH~=-1 and qI~=-1 then if qH<qI then return qH else return qI end elseif qH~=-1 then return qH else return qI end end;local function qK(j1,eG,qL)local function qM(qN,dR)local eM=vec3(dR)if qN.id==0 then return setmetatable({latitude=eM.x,longitude=eM.y,altitude=eM.z,id=0,systemId=qN.systemId},dT)end;local eN=eM-qN.center;local c4=eN:len()local dZ=c4-qN.radius;local dX=0;local dY=0;if not di(c4,0)then local eO=eP(eN.y,eN.x)dY=eO>=0 and eO or 2*math.pi+eO;dX=math.pi/2-math.acos(eN.z/c4)end;return setmetatable({latitude=math.deg(dX),longitude=math.deg(dY),altitude=dZ,id=qN.id,systemId=qN.systemId},dT)end;local qO=qM(j1,eG)qO="::pos{"..qO.systemId..","..qO.id..","..qO.latitude..","..qO.longitude..","..qO.altitude.."}"if qL then return qO else qn=qO;return true end end;local function qP(qQ,qR,qS)local function qT(qQ,ep)qQ=vec3(qQ)ep=vec3(ep):normalize()local dA=qQ*ep;return dA.x+dA.y+dA.z end;local qU=0.001;local qV=1;if not c9 or not cv or c8~=-1 or cG<iE then if qS==nil then qS=aQ end;if qR==nil then qR=qU end;qQ=vec3(qQ):normalize()local qW=vec3()-qQ;local qX=-qT(qW,b.getConstructWorldOrientationRight())*qV;local qY=-qT(qW,b.getConstructWorldOrientationUp())*qV;if pS==0 then pS=qX/2 end;if pT==0 then pT=qY/2 end;if eU(qX)<0.1 then q8=q8-qX*2 else q8=q8-(qX+(qX-pS)*qS)end;if eU(qY)<0.1 then q7=q7+qY*2 else q7=q7+qY+(qY-pT)*qS end;pS=qX;pT=qY;if eU(qX)<qR and eU(qY)<qR then return true end;return false elseif cv and c8==-1 then qQ=cF;if qS==nil then qS=aQ end;if qR==nil then qR=qU end;qQ=vec3(qQ):normalize()local qW=cC-qQ;local qX=-qT(qW,b.getConstructWorldOrientationRight())*qV;local qY=-qT(qW,b.getConstructWorldOrientationUp())*qV;if pS==0 then pS=qX/2 end;if pT==0 then pT=qY/2 end;if eU(qX)<0.1 then q8=q8-qX*5 else q8=q8-(qX+(qX-pS)*qS)end;if eU(qY)<0.1 then q7=q7+qY*5 else q7=q7+qY+(qY-pT)*qS end;pS=qX;pT=qY;if eU(qX)<qR and eU(qY)<qR then return true end;return false end end;function pP.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cS=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bV=false;q5=false;c5=false;c6=false;q6=false;cu=p;bo=false;b2=false;cd=false;br=nil;bx=false;d6=false;d7=nil end;function pP.GetAutopilotBrakeDistanceAndTime(fl)return qv(fl)end;function pP.GetAutopilotTBBrakeDistanceAndTime(fl)return qy(fl)end;function pP.showWayPoint(j1,eG,qL)return qK(j1,eG,qL)end;function pP.APTick()local qZ=a.getMouseWheel()if qZ>0 then co.changeSpd()elseif qZ<0 then co.changeSpd(true)else q4=true end;qk=il()if qn then a.setWaypoint(qn)qn=false end;if qq then antigrav.setBaseAltitude(qq)qq=false end;if qo then fO(qo,qp)qo=false;qp=""end;if qh~=-1 then co.cmdCruise(qh,qi)qi=false;qh=-1 end;if qe~=nil then if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ik:getTargetSpeed(axisCommandId.longitudinal)~=qe then ik:setTargetSpeedCommand(axisCommandId.longitudinal,qe)else qe=nil end end;if qg~=-1 then co.cmdThrottle(qg,qi)qi=false;qg=-1 end;if qj then cq.landingGear()qj=false end;if qr then co.ToggleAutopilot()end end;function pP.ToggleIntoOrbit()cz=false;pX=nil;pY=nil;q2=0;if not c9 then if bx then fQ("orOff","AP")bx=false;pZ=false;q1=nil;cu=p;if b3 then b3=false;b5=false end;qc.VectorToTarget=false;qc.AutopilotAlign=false;q0=false elseif cT then fQ("orOn","AP")bx=true;cu=true;if q1==nil then q1=j1 end;if b3 then b3=false;b5=false end else bX="Unable to engage auto-orbit, not near a planet"end else bx=false;pZ=false;q1=nil;cu=p;if b3 then b3=false end;qc.VectorToTarget=false;qc.AutopilotAlign=false;q0=false end end;function pP.ToggleVerticalTakeoff()b3=false;if b7 then lw=true;b6=false;b5=false;b4=true;cu=true;bU=0;if c9 and c8==-1 then b4=false;b3=true;bU=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qh=bI(cw)end else cz=false;bk=false;d.control.retractLandingGears()ik:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function pP.checkLOS(qQ)local lB,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,qQ,function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lC=eE;if eF~=nil and eE~=nil then lC=math.min(eF,eE)end;if lC~=nil then return lB,lC else return nil,nil end end;function pP.ToggleAutopilot()local function q_(bv)cU=false;bo=not bo;if bo then b2=false;if not b3 and not bv then co.ToggleAltitudeHold()end end;lF="Proceeding to Waypoint"end;local function r0(gu)if gu then for K,dF in pairs(cP)do if dF.name and dF.name==gu then return K end end else return 0 end end;local r1=false;if bK-pW<1.5 and c9 then if not cB then if c9 then b8=j1.spaceEngineMinAltitude-0.01*j1.noAtmosphericDensityAltitude;fQ("11","EP")pW=-1;if b1 or bo or bx then return end else bX="No space engines detected, Orbital Hop not supported"return end elseif j1.hasAtmosphere then if c9 then b8=j1.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pW=-1;if b1 or bo or bx then return end end else pW=bK end;r2=false;if(bj>0 or#bD>0)and not b1 and not bo and not c6 and not bx then if 0.5*d:maxForceForward()/b.g()<cc then bX="WARNING: Heavy Loads may affect autopilot performance."bY=5 end;if#bD>0 and not c7 then bj=r0(bD[1])cn.UpdateAutopilotTarget()bX="Route Autopilot in Progress"local qW=g1.position-cJ;local r3=qW:project_on_plane(cH):len()if r3>50000 and g1.planetname==j1.name then r1=true end end;cn.UpdateAutopilotTarget()co.showWayPoint(c1,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cL then co.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end elseif j1.name==g1.planetname then lw=true;if c9 then if not bo then fQ("vtt","AP")q_(bv)if r1 then b8=j1.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c1.name==j1.name and cb<gl*1.5)then cz=false;b1=true elseif not c9 then if bx then co.ToggleIntoOrbit()end;cy=j1.noAtmosphericDensityAltitude+T;q0=true;qc.AutopilotAlign=true;qc.VectorToTarget=true;pZ=false;if not bx then co.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if c9 then c6=true;co.ToggleAltitudeHold()else b1=true end end elseif not c9 then if g1==nil and(c1.name==j1.name and cT)and not bx then r4=false;cz=false;pZ=false;co.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bV=false;b3=false;b4=false;b6=false;b5=false;q5=false;br=nil;r4=false end else fQ("apP","AP")c6=true;co.ToggleAltitudeHold()end;qr=false else fQ("apOff","AP")co.ResetAutopilots(1)if qr==2 then qr=true end end end;function pP.routeWP(r5,r6,r7)if r7 then if r7==1 then bD={}bD=im(bD,bC)if#bD>0 then bX="Route Loaded"else bX="No Saved Route found on Databank"end;return bD else bC={}bC=im(bC,bD)bX="Route Saved"pO()return end end;if r5 then return bD end;if r6 then bD={}bX="Current Route Cleared"else bD[#bD+1]=g1.name;bX="Added "..g1.name.." to route. "end;return bD end;function pP.cmdThrottle(dG,r8)if ik:getAxisCommandType(0)~=axisCommandType.byThrottle and not r8 then d.control.cancelCurrentControlMasterMode()end;ik:setThrottleCommand(axisCommandId.longitudinal,dG)bL=df(fR(dG*100,0)/100,-1,1)qe=nil end;function pP.cmdCruise(dG,r8)if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r8 then d.control.cancelCurrentControlMasterMode()end;ik:setTargetSpeedCommand(axisCommandId.longitudinal,dG)qe=dG end;function pP.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bW then br=cN else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function pP.ToggleAltitudeHold()if bK-pV<1.5 then if j1.hasAtmosphere then if c9 then b8=j1.spaceEngineMinAltitude-0.01*j1.noAtmosphericDensityAltitude;fQ("11","EP")else if cT then b8=j1.noAtmosphericDensityAltitude+T;cy=b8;q0=true;if not bx then co.ToggleIntoOrbit()end;pZ=true end end;pV=-1;if b3 or bx or b7 then return end end else pV=bK end;if cT and not c9 then cy=cb;q0=true;pZ=true;co.ToggleIntoOrbit()if bx then pV=bK else pV=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bV=false;cu=true;br=nil;cz=false;if c8~=-1 and cG<20 then if bk then cq.landingGear()end;fQ("lfs","LS")b5=true;if pV>-1 then b8=cb+W end;aZ="ATO Hold"ik:setTargetGroundAltitude(X)if aY and cK then co.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pV>-1 then if cT then b8=cb end end;if b7 then co.ToggleVerticalTakeoff()end end;if cL and not q then local r9=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cb then b8=g1.agg elseif b5 then b8=r9 end;if eU(cb-r9)<100 and cG<20 then b8=r9;aZ="AGG Hold"qg=0 end end;if c6 then b8=200000 end else fQ("altOff","AH")if bx then co.ToggleIntoOrbit()end;if b7 then co.ToggleVerticalTakeoff()end;cu=p;b5=false;bo=false;pV=0 end end;function pP.ResetAutopilots(pP)if pP then c6=false;b1=false;ba=false;q5=false;b8=cb;r2=false;d6=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d7=nil;ra=false;cS=nil;d6=false;if not cL then b3=false;br=nil end;if b7 then co.ToggleVerticalTakeoff()end;if bx then co.ToggleIntoOrbit()end;cu=p;c5=false;c7=false;bU=0 end;function pP.BrakeToggle(rb)if not aZ then if rb then aZ=rb else aZ=true end else aZ=false end;if b4 then b4=false;cu=p;d6=false end;if aZ then fQ("bkOn","B",1)co.ResetAutopilots()else fQ("bkOff","B",1)end end;function pP.BeginReentry()if b6 then bX="Re-Entry cancelled"fQ("reOff","RE")b6=false;cu=p;b3=false elseif not j1.hasAtmosphere then bX="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bY=5 elseif not q6 then b6=true;if ik:getAxisCommandType(0)~=rc.cruise then d.control.cancelCurrentControlMasterMode()end;cu=true;aZ=false;bX="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cw;fQ("par","RE")else b6=true;b3=true;cu=true;aZ=false;b8=j1.surfaceMaxAltitude+Z;if b8>j1.spaceEngineMinAltitude then b8=j1.spaceEngineMinAltitude-0.01*j1.noAtmosphericDensityAltitude end;local rd=ip(b8)bX="Beginning Re-entry.  Target speed: "..cw.." Target Altitude: "..rd;fQ("glide","RE")qh=bI(cw)end;b5=false end;function pP.ToggleAntigrav()if antigrav and not q then if cL then fQ("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bt==nil then bt=cb end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pP.changeSpd(re)local rf=1;if re then rf=-1 end;if not bW then if t and not p7 and q4 then local rg=bL;bL=fR(df(bL+rf*aC/100,-1,1),2)if bL>=0 and rg<0 then bL=0;q4=false end elseif p7 then if c9 or b6 then cw=df(cw+rf*aC,0,U)elseif b1 then _=df(_+rf*aC/3.6*100,0,da-0.2)end else ik:updateCommandFromActionStart(axisCommandId.longitudinal,rf*aC/10)end else if b1 or bo or c6 or bx then cX=cX+1*rf*-1;if cX>#cP then cX=1 end;if cX<1 then cX=#cP end else if not re then rf=1 else rf=nil end;cn.adjustAutopilotTargetIndex(rf)end end end;function pP.TenthTick()local function rh(om,ri)if om==nil then om=b.g()end;om=fR(om,5)if ri~=nil and ri or(q3==nil or q3~=om)then local fl=cE:len()local rj=ih(c.getData()).maxBrake;if rj~=nil and rj>0 and c9 then rj=rj/df(fl/100,0.1,1)rj=rj/ca;if ca>0.10 then if bs then bs=(bs+rj)/2 else bs=rj end end end;if rj~=nil and rj>0 then bq=rj end;q3=om end end;rh(nil,true)end;function pP.SatNavTick()if not r then return end;qs=dbHud_1.getStringValue("SPBAutopilotTargetName")if qs~=nil and qs~=""and qs~="SatNavNotChanged"then local dA=ih(dbHud_1.getStringValue("SavedLocations"))if dA~=nil then bn=dA;local gs=-1;local gy;for dF,dr in pairs(bn)do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dF,dr in pairs(e[0])do if dr.name and dr.name=="SatNav Location"then gs=dF;break end end;if gs>-1 then e[0][gs]=gy end;cn.UpdateAtlasLocationsList()bX=gy.name.." position updated"end end;for K=1,#cP do if cP[K].name==qs then bj=K;a.print("Index = "..bj.." "..cP[K].name)cn.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pP.onFlush()local function rk(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=qd elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rv==nil then rv=pid.new(10,0,10.0)end;rv:inject(ru-rt)local rw=rv:get()local rx=(rw-rs-rq)*ro;return rx end;local function ry(rl,rm)local rn=vec3()local ro=vec3()if rl==axisCommandId.longitudinal then rn=vec3(b.getConstructOrientationForward())ro=cC elseif rl==axisCommandId.vertical then rn=vec3(b.getConstructOrientationUp())ro=qd elseif rl==axisCommandId.lateral then rn=vec3(b.getConstructOrientationRight())ro=cD else return vec3()end;local rp=vec3(b.getWorldGravity())local rq=rp:dot(ro)local rr=vec3(b.getWorldAirFrictionAcceleration())local rs=rr:dot(ro)local rt=cE:dot(rn)local ru=rm*constants.kph2m;if rz==nil then rz=pid.new(10,0,10.0)end;rz:inject(ru-rt)local rw=rz:get()local rx=(rw-rs-rq)*ro;return rx end;local function rA(rB,jR,fY)local rC=rB:cross(fY):normalize_inplace()local kC=math.acos(df(rC:dot(-jR),-1,1))*constants.rad2deg;if rC:cross(-jR):dot(fY)<0 then kC=-kC end;return kC end;local function rD()if cV and not b4 then local en=cV[1]local hJ,hK=cV[2],cV[3]local rE=math.min(hJ,hK or hJ)local rF=rE/cG;local rG=b5 and(cG<42 or c8~=-1)local rH=b3 or bo or br or b1;if rH and not rG and(b_*1.5>rE or rF<1)then aZ="Collision"bD={}qg=0;if b3 then co.ToggleAltitudeHold()end;if br then co.ToggleLockPitch()end;bX="Autopilot Cancelled due to possible collision"a.print(en.name.." COLLISION "..iq(rF).." / "..ip(rE,2))co.ResetAutopilots(1)lw=true;if c9 then b4=true end;cu=true end;if rF<11 then cU=en.name.." COLLISION "..iq(rF).." / "..ip(rE,2)else cU=en.name.." collision "..iq(rF)end;if rF<6 then fQ("alarm","AL",2)end else cU=false end end;if antigrav and not q then if not cL and antigrav.getBaseAltitude()~=bt then qq=bt end end;if d9 then d:setEngineForceCommand('hover',vec3(),1)d9=false end;cM=ik:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rI=df(bR+q7+a.getControlDeviceForwardInput(),-1,1)local rJ=df(bS+q9+a.getControlDeviceYawInput(),-1,1)local rK=df(bT+q8-a.getControlDeviceLeftRightInput(),-1,1)local rL=aZ and 1 or 0;cH=vec3(b.getWorldVertical())if cH==nil or cH:len()==0 then cH=(j1.center-cJ):normalize()end;qd=vec3(b.getConstructWorldOrientationUp())cC=vec3(b.getConstructWorldOrientationForward())cD=vec3(b.getConstructWorldOrientationRight())cF=vec3(b.getWorldVelocity())cE=vec3(b.getVelocity())cJ=vec3(b.getConstructWorldPos())cc=b.getConstructMass()cG=vec3(cF):len()cI=-cH:dot(cF)cO=getRoll(cH,cC,cD)local rM=cO/180*math.pi;local rN=math.cos(rM)local rO=math.sin(rM)cN=rA(cH,cC,cD*rN+qd*rO)local rP=cF:normalize()local rQ=eU(cO)local rR=utils.sign(cO)local rS=vec3(b.getWorldAngularVelocity())local rT=rI*aM*cD+rJ*aH*cC+rK*aN*qd;if cu==true and cH:len()>0.01 then local rU=eU(qa-cO)if((b0 or b6 or b4 or c5 or b3 or bx)and rU>0 or c9 and rU<aI and p)and rJ==0 and eU(cN)<85 then local rV=qa;local rW=aG;if not c9 then rW=rW/4;qa=0;rV=0 end;if rX==nil then rX=pid.new(rW*0.01,0,rW*0.1)end;rX:inject(rV-cO)local rY=rX:get()rT=rT+rY*cC end end;local rZ=1;local r_=0;local s0=1;bM=0;ca=bJ()c9=false or cb<j1.noAtmosphericDensityAltitude and ca>0.00001;cb=b.getAltitude()c8=qD()bK=bH()pU=bK;if bk and c8>-1 and c8-3<Y then if ik.targetGroundAltitudeActivated then ik:deactivateGroundEngineAltitudeStabilization()end end;if radar_1 then qt=not qt;if qt then cp.UpdateRadar()end;if E then rD()end end;if antigrav then cL=antigrav.getState()==1 end;local s1=1;local s2=1;local s3=bK-pU;local s4=-math.deg(qz(qd,cF,cC))local s5=math.deg(qz(cD,cF,cC))local gn=cH*-1;cv=c9 and s4<-L or s4>L or s5<-M or s5>M;local s6=a.getMouseDeltaX()local s7=a.getMouseDeltaY()if qu then local s8=bH()-qu;s6=s6*s8/0.016;s7=s7*s8/0.016 end;qu=bH()if o and not bW then s7=-s7 end;q8=0;q9=0;q7=0;fU=cj[0]j1=fU:closestBody(b.getConstructWorldPos())s9=cl(j1)fp=s9:orbitalParameters(b.getConstructWorldPos(),cF)if cb==0 then cb=(cJ-j1.center):len()-j1.radius end;cT=c.getClosestPlanetInfluence()>0 or cb>0 and cb<200000;local om=j1:getGravity(b.getConstructWorldPos()):len()*cc;qa=0;local sa=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if qk==0 then if ij()==1 and bW then if not cs then c2=df(c2+s6/2,-ce/2,ce/2)c3=df(c3+s7/2,-cf/2,cf/2)end else c2=0;c3=0 end else c2=df(c2+s6/2,-ce/2,ce/2)c3=df(c3+s7/2,-cf/2,cf/2)d8=dh(c2*c2+c3*c3)if not bW and ij()==0 then local kL,kM=1,1;if bF=="SCOPE"then kL,kM=d0/90,d0/90 end;if g=="virtual joystick"then if d8>aw then q8=q8-df(eU(c2)-aw,0,ce/2)*utils.sign(c2)*aE*kL;q7=q7-df(eU(c3)-aw,0,cf/2)*utils.sign(c3)*aF*kM end else c2=0;c3=0;if g=="mouse"then q7=(-utils.smoothstep(s7,-100,100)+0.5)*2*s1;q8=(-utils.smoothstep(s6,-100,100)+0.5)*2*s2 end end end end;local sb=cG>27777;if cG>V/3.6 and not c9 and not b1 and not sb then bX="Space Speed Engine Shutoff reached"qg=0 end;if not sb and sc then if not aZ then co.BrakeToggle()end;if b1 then co.ResetAutopilots(1)end;qg=0 end;sc=sb;if ca>0.09 then if cG>cw/3.6 and not t and not pQ then aZ="SpdLmt"pQ=true elseif not t and pQ then if cG<cw/3.6 then aZ=false;pQ=false end end end;if b0 then if c5 then aZ=false;local sd=false;if g1 and c5==true then sd=qP(g1.position-cJ,0.1)else sd=qP(vec3(cF),0.01)end;cu=true;if sd then qh=bI(cw)if(eU(cO)<2 or eU(cN)>85)and cG>=cw/3.6-1 then aZ=false;b0=false;if c5~=2 then q6=true end;if c5==true then c7=true end;c5=false;b1=false;co.BeginReentry()end elseif c9 and t then qg=1 end elseif cG>iE then qP(vec3(cF),0.01)end end;if a_ then if c9 then a_=false elseif cG>iE then qP(-vec3(cF))end end;if not b0 and c5 and not bx then if not c9 then if c5~=2 then q6=true end;co.BeginReentry()c5=false;c7=true else c5=false;if not qr then qr=true end end end;if c7 and g1 and(cb<b8+250 and cb>b8-250)and cG*3.6>cw-250 and eU(cI)<25 and ca>=0.1 and(g1.position-cJ):len()>2000+cb then if not qr then qr=true end;c7=false end;if b7 then cu=true;local se=b8;if cI<-30 then bX="Unable to achieve lift. Safety Landing."bU=0;cu=p;b7=false;b4=true elseif not q and cL or b8<j1.spaceEngineMinAltitude then if cL then se=antigrav.getBaseAltitude()end;if cb<se-100 then qb=0;bU=15;aZ=false elseif cI>0 then aZ="VTO Limit"bU=0 elseif cI<-30 then aZ="VTO Fall"bU=15 elseif cb>=se then if cL then if b1 or bo then co.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bX="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bX="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")co.ToggleVerticalTakeoff()end;bU=0 end else if ca>0.08 then qb=0;aZ=false;bU=20 elseif ca<0.08 and c9 then aZ=false;if cA then qb=0;bU=20 else bU=0;qb=36;qh=3500 end else cu=p;bx=true;cz=false;sf=false;pZ=false;pX=nil;pY=nil;if q1==nil then q1=j1 end;cy=se;q0=true;b7=false end end;if qb~=nil then if sg==nil then sg=pid.new(2*0.01,0,2*0.1)end;local sh=df(qb-cN,-M*0.80,M*0.80)sg:inject(sh)local si=df(sg:get(),-1,1)q7=si end end;if bx then local function sj()if fp.periapsis.altitude>=cy*0.99 and fp.apoapsis.altitude>=cy*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eU(cy-cb)<1000 then return true else return false end end;local qW;local sk=false;local sl=ip(cy)if q1==nil then q1=j1;if bo then q1=c1 end end;if not q0 then cy=bI(q1.radius+q1.surfaceMaxAltitude+T)if q1.hasAtmosphere then cy=bI(q1.radius+q1.noAtmosphericDensityAltitude+T)end;q0=true end;if qc.VectorToTarget and g1 then qW=g1.position-cJ end;local sm,sn=cl(q1):escapeAndOrbitalSpeed((cJ-q1.center):len()-q1.radius)local so=cO;if not pZ then local sp=false;local sq=false;qg=0;pY=0;cx="Aligning to orbital path - OrbitHeight: "..sl;if qc.VectorToTarget then qP(qW:normalize():project_on_plane(cH))sk=cC:dot(qW:project_on_plane(qd):normalize())>0.95 else qP(cF)sk=s4<0.5;if cG<150 then sk=true end end;q7=0;pX=0;if cN<=pX+2 and cN>=pX-2 then sp=true else sp=false end;if so<=pY+2 and so>=pY-2 then sq=true else sq=false end;if sp and sq and sk then pX=nil;pY=nil;pZ=true end else if qc.VectorToTarget then qP(qW:normalize():project_on_plane(cH))elseif cG>150 then qP(cF)end;q7=0;if qc.VectorToTarget and g1 then local b_,dK=ck.computeDistanceAndTime(cG,cw/3.6,cc,0,0,bq)if cz and qW:len()>15000+b_+cb then cx="Orbiting to Target"if cb-100<=q1.noAtmosphericDensityAltitude or lD>fp.timeToPeriapsis and fp.periapsis.altitude<q1.noAtmosphericDensityAltitude or not sj()and fp.eccentricity>0.1 then bX="Re-Aligning Orbit"cz=false end elseif cz or qW:len()<15000+b_+cb then bX="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;q6=true;c7=true;qc.VectorToTarget,qc.AutopilotAlign=false,false;co.ToggleIntoOrbit()co.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cb>cy*0.9 and cb<cy*1.4 then if fp.apoapsis~=nil then if sj()or cz then if cz then aZ=false;qg=0;pX=0;if not qc.VectorToTarget then bX="Orbit complete"fQ("orCom","OB")co.ToggleIntoOrbit()end else q2=q2+1;if q2>=2 then cz=true end end else cx="Adjusting Orbit - OrbitHeight: "..sl;p_=true;qh=sn*3.6+1;local sr=cy-cb;if ss==nil then ss=pid.new(0.1,0,1*0.1)end;ss:inject(sr-cI*df(utils.smoothstep(2000-sr,-2000,2000)^6*10,1,10))pX=df(ss:get(),-60,60)end end else local st=2.75;local su=eU(fR(sm*st))local oB=su%50;if oB>0 then su=su-oB+50 end;aZ=false;if cb<cy*0.8 then cx="Escaping planet gravity - OrbitHeight: "..sl;pX=utils.map(cI,200,0,-15,80)elseif cb>=cy*0.8 and cb<cy*1.15 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;pX=utils.map(cI,100,-100,-15,65)elseif cb>=cy*1.15 and cb<cy*1.5 then cx="Approaching orbital corridor - OrbitHeight: "..sl;su=su*0.75;if cI<0 or p_ then pX=utils.map(cb,cy*1.5,cy*1.01,-30,0)else pX=utils.map(cb,cy*0.99,cy*1.5,0,30)end elseif cb>cy*1.5 then cx="Reentering orbital corridor - OrbitHeight: "..sl;pX=-65;local sv=utils.map(cI,-150,-400,1,0.55)su=su*sv end;qh=bI(su)end end;if pX~=nil then if sw==nil then sw=pid.new(1*0.01,0,5*0.1)end;local sx=pX-cN;sw:inject(sx)local sy=df(sw:get(),-0.5,0.5)q7=sy end end;if b1 and not c9 and not c5 then local function sz(hW,fp)a.print(hW)aZ=false;bb=false;b1=false;r2=false;be="Aligning"qg=0;q5=false;bX=hW;fQ("apCom","AP")if fp or c5 then if fp and gl~=nil and not c5 then if not cb or cb==0 then return end;cy=cb;q0=true end;co.ToggleIntoOrbit()end end;local sA,sB=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not r2 then local sC=(g1.position-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()local sE=c1.center+sD*(c1.radius+gl)local sF=g1.position+(g1.position-c1.center):normalize()*(gl-c1:getAltitude(g1.position))if(cJ-sE):len()<(cJ-sF):len()then sA=sE else sA=sF;bd=0 end;bi=sA;co.showWayPoint(c1,bi)sB=true;r2=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not r2 then bf=0;sB=true;ba=true;r2=true;sA=g1.position+(cJ-g1.position):normalize()*R;bi=sA end elseif g1==nil then bf=0;if not r2 then local sC=(cJ+cF*100000-c1.center):normalize()local sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()if sD:len()<1 then sC=(cJ+cC*100000-c1.center):normalize()sD=sC:project_on_plane((c1.center-cJ):normalize()):normalize()end;sA=c1.center+sD*(c1.radius+gl)bi=sA;r2=true;sB=true;ba=true;co.showWayPoint(c1,bi)end end;pk=(vec3(sA)-cJ):len()local lB,eE,eF=cj:getPlanetarySystem(0):castIntersections(cJ,cF:normalize(),function(en)if en.noAtmosphericDensityAltitude>0 then return en.radius+en.noAtmosphericDensityAltitude else return en.radius+en.surfaceMaxAltitude*1.5 end end)local lC=eE;if eF~=nil and eE~=nil then lC=math.min(eF,eE)end;if lC~=nil and lC<pk and lB.name==c1.name then pk=lC end;local sd=true;local sG=(c1.center-(cJ+vec3(cF):normalize()*pk)):len()-c1.radius;local lo=ip(sG)qo=gd;qp='{"label": "Projected Altitude", "value": "'..lo..'"}'if cG>50 and b9 then local qW=vec3(sA)-cJ;local sH=df(math.deg(qz(qd,cF:normalize(),qW:normalize()))*cG/500,-90,90)local sI=df(math.deg(qz(cD,cF:normalize(),qW:normalize()))*cG/500,-90,90)if eU(sH)<20 and eU(sI)<20 then sH=sH*2;sI=sI*2 end;if eU(sH)<2 and eU(sI)<2 then sH=sH*2;sI=sI*2 end;local s4=-math.deg(qz(qd,cC,cF:normalize()))local s5=-math.deg(qz(cD,cC,cF:normalize()))if sJ==nil then sJ=pid.new(2*0.01,0,2*0.1)end;sJ:inject(sI-s5)local sK=df(sJ:get(),-1,1)q7=q7+sK;if sL==nil then sL=pid.new(2*0.01,0,2*0.1)end;sL:inject(sH-s4)local sM=df(sL:get(),-1,1)q8=q8+sM;sB=true;if eU(sH)>2 or eU(sI)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cG<=50 then qP((sA-cJ):normalize())end;if sG<gl*1.5 then bd=cw/3.6;if g1==nil then dK,bd=cl(c1):escapeAndOrbitalSpeed(sG)end end;local b_,c0;if not b2 then b_,c0=qv(cG)else b_,c0=qy(cG)end;if b1 and not b9 and not bc and not bb then local lB,lC=co.checkLOS((bi-cJ):normalize())if c1.name~=j1.name then if lB~=nil and c1.name~=lB.name and lC<pk then bX="Collision with "..lB.name.." in "..ip(lC).."\nClear LOS to continue."bY=5;ql=true else ql=false;bX=""end end end;if not ql then if not bc and not bb and not sB then sd=qP((sA-cJ):normalize())elseif b2 and(bb or bc)then sd=qP(-vec3(cF):normalize())end end;if b9 then if not q5 then aZ=false;qg=a0;bL=fR(a0,2)q5=true end;local pl=c.getThrottle()if t then pl=bL end;local sN=99999;local oz=-vec3(b.getWorldAcceleration()):dot(cF:normalize())local sO=df(cF:dot((sA-cJ):normalize()),0,cG)if sO>0 or oz>0 then sN=ck.computeTravelTime(sO,oz,pk-b_)end;if cE:len()>=_ or pl==0 and q5 or a1/4>sN then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;qg=0 end;local sP=pk;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pR and cR>2000 then co.ResetAutopilots(1)bX="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"pR=cR else pR=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;qg=0;q5=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then qg=1;qi=true end;local dK,sn=cl(c1):escapeAndOrbitalSpeed((cJ-j1.center):len()-j1.radius)local qW;if g1 then qW=g1.position-cJ end;if g1 and g1.planetname=="Space"and cG<50 then if#bD>0 then if not qr then table.remove(bD,1)end;if#bD>0 then aZ=false;if not qr then qr=2 end;return end end;sz("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cG<=sn and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sz("Autopilot complete, commencing reentry")bi=g1.position;c5=true;co.showWayPoint(c1,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cG<=sn then if g1 then if cF:normalize():dot(qW:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not r4 then aZ=false;co.showWayPoint(c1,g1.position)r4=true end else sz("Autopilot complete, proceeding with reentry")bi=g1.position;c5=true;co.showWayPoint(c1,g1.position)r4=false end else sz("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sz("Autopilot complete, fixing Orbit",true)end elseif bc then local sP=pk;if sP<=b_ or H and cR<=b_+10000 and cQ then if H and cR<=b_+10000 and cQ then if cR<pR and cR>2000 then if not qr then qr=true end;bX="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"pR=cR else pR=cR;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local pl=c.getThrottle()if t then pl=bL end;if pl>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if sd then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c5 then bi=vec3(c1.center)+(gl+c1.radius)*cD;sQ=qd;sR=cD end;ba=true elseif sd and not ql then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not q5 then qg=a0;qi=true;bL=fR(a0,2)q5=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and c9)then bX="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;r2=false;be="Aligning"qg=0;q5=false;b0=true;c5=true;co.showWayPoint(c1,g1.position)end;if bV then cu=true;local sI=0;local fr=cJ+vec3(c.getMasterPlayerRelativePosition())local sS=fr-cJ;local sT=vec3(sS):project_on(cC):len()local sU=vec3(sS):project_on(cD):len()local c4=dh(sT*sT+sU*sU)qP(sS:normalize())local mI=40;local sV=c4<mI;local sW=100;local rm=df((c4-mI)/2,10,sW)q7=0;local sd=eU(q8)<0.1;if sd and cG<rm and not sV then aZ=false;sI=-20 else aZ="Follow"sI=0 end;local sX=0;if eU(sI-cN)>sX then if sY==nil then sY=pid.new(2*0.01,0,2*0.1)end;sY:inject(sI-cN)local sK=sY:get()q7=sK end end;if b3 or b4 or b6 or bo or br~=nil then local sZ=bs;if sZ then sZ=sZ*df(cG/100,0.1,1)*ca else sZ=bq end;if not c9 then sZ=bq end;qf=cC:project_on_plane(cH):normalize():dot(cF)if qf>100 then b_,c0=ck.computeDistanceAndTime(qf,100,cc,0,0,sZ)local s_,t0=ck.computeDistanceAndTime(100,0,cc,0,0,sZ*0.55)b_=b_+s_ else b_,c0=ck.computeDistanceAndTime(qf,0,cc,0,0,sZ*0.55)end;local sr=b8-cb-cI;local t1=200+cG;if b6 or c5 then t2=2000+cG end;local t3=1;if b5 then t3=df(cG/100,0.1,1)end;local sI=(utils.smoothstep(sr,-t1,t1)-0.5)*2*O*t3;if not b6 and not c5 and not bo and cC:dot(cF:normalize())<0.99 then sI=(utils.smoothstep(sr,-t1*df(20-19*ca*10,1,20),t1*df(20-19*ca*10,1,20))-0.5)*2*O*df(2-ca*10,1,2)*t3 end;if not b3 then sI=0 end;if br~=nil then if cT and not bx then sI=br else br=nil end end;cu=true;local t4=q7;if b6 then local t5=bI(cw)local t6,t7=ck.computeDistanceAndTime(cG,t5/3.6,cc,0,0,bq-j1.gravity*9.8*cc)t6=t6==-1 and 5000 or t6;local r3=cb-(j1.noAtmosphericDensityAltitude+t6)local t8=cb>j1.noAtmosphericDensityAltitude+t6*1.35;if t8 then sI=P;if cG<=t5/3.6 and cG>t5/3.6-10 and eU(cF:normalize():dot(cC))>0.9 and not cM then bP=false;qg=1 end elseif(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)and not t8 and not c9 then qh=t5;qi=true end;if cM then if cG>t5/3.6 and not t8 then aZ="Reentry Limit"if bL>0 then qg=0 end else aZ=false end else aZ=false end;if cI>0 then aZ="Reentry vSpd"end;if not q6 then sI=-80;if cb<j1.surfaceMaxAltitude+(j1.atmosphereThickness-j1.surfaceMaxAltitude)*0.25 then bX="PARACHUTE DEPLOYED at "..fR(cb,0)b6=false;b4=true;lw=true;qg=0;sI=0;cu=p end elseif j1.noAtmosphericDensityAltitude>0 and t8 then cu=true elseif not t8 then if not c9 and(cM or ik:getTargetSpeed(axisCommandId.longitudinal)~=t5)then qh=t5 end;if cG<t5/3.6+1 then aZ=false;q6=false;b6=false;cu=true;qg=1 end end end;if cG>iE and not c6 and not bo and not b4 and u then qP(vec3(cF))end;if cS or(bo or c6)and bj>0 and c9 then local qW;if cS then if type(cS)=="table"then qW=cS elseif cS<3 and cS>0 then qW=-cH:cross(cF)*5000 elseif cS>=3 then qW=cH:cross(cF)*5000 elseif cS<0 then qW=cF*25000 end elseif g1~=nil then qW=g1.position-cJ else qW=c1.center-cJ end;local sH=math.deg(qz(cH:normalize(),cF,qW))*2;local mL=math.rad(eU(cO))if cG>aJ and c9 then local t9=1000+cG;local ta=(utils.smoothstep(sr-cI*10,-t9,t9)-0.5)*2*O;local tb=df(90-ta,0,180)qa=df(sH*2,-tb,tb)local tc=sH;sH=df(df(sH,-L*0.80,L*0.80)*math.cos(mL)+4*(cN-sI)*math.sin(math.rad(cO)),-L*0.80,L*0.80)local td=1;if qa~=0 then td=eU(mL/qa)end;td=(90-df(eU(qa-cO),0,90))/90;local te=sI;if eU(cO)>90 then te=-te end;sI=td*df(df(te*math.cos(mL),-M*0.8,M*0.8)+eU(df(eU(tc)*math.sin(mL),-M*0.80,M*0.80)),-M*0.80,M*0.80)else qa=0;sH=df(sH,-L*0.80,L*0.80)end;local tf=s4-sH;if cS and eU(tf)<=0.0001 and(type(cS)=="table"or type(cS)~="table"and cS<0 and eU(cO)<1)then if cS==-2 then co.ToggleAltitudeHold()end;cS=nil;fQ("180Off","BR")return end;if not cv and cG>aJ and c9 then if tg==nil then tg=pid.new(2*0.01,0,2*0.1)end;tg:inject(tf)local sM=df(tg:get(),-1,1)q8=q8+sM elseif c9 and c8>-1 or cG<aJ then qP(qW)elseif cv and c9 then if(s4<-L or s4>L)and c9 then qP(cF)end;if(s5<-M or s5>M)and c9 then sI=df(cN-s5,cN-M*0.80,cN+M*0.80)end end;if g1~=nil and not c6 then local se=j1:getAltitude(g1.position)local r3=qW:project_on_plane(cH):len()lw=true;if b8<j1.noAtmosphericDensityAltitude and not c6 and not b5 and not b6 and(r3<=b_ and qW:len()<j1.radius)and(cF:project_on_plane(cH):normalize():dot(qW:project_on_plane(cH):normalize())>0.99 or lF=="Finalizing Approach")then lF="Finalizing Approach"if#bD>0 then if not qr then table.remove(bD,1)end;if#bD>0 then if not qr then qr=2 end;return end end;qg=0;if b3 then co.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lF=="Finalizing Approach"and(qf<0.1 or r3<0.1 or th~=nil and th<r3)then fQ("bklOn","BL")b4=true;d6=true;if g1.heading then d7=g1.heading else d7=nil end;bo=false;lF="Proceeding to Waypoint"cU=false end;th=r3 end elseif bo and not c9 and b8>j1.noAtmosphericDensityAltitude and not(c6 or b6)then if g1~=nil and c1.name==j1.name then local qW=g1.position-cJ;local se=j1:getAltitude(g1.position)local r3=dh(qW:len()^2-(cb-se)^2)local sZ=bs;if sZ then b_,c0=ck.computeDistanceAndTime(cG,0,cc,0,0,sZ/2)lw=true;if r3<=b_+cG*s3/2 and cF:project_on_plane(cH):normalize():dot(qW:project_on_plane(cH):normalize())>0.99 then if j1.hasAtmosphere then aZ=false;b0=false;q6=true;c5=false;c7=true;b1=false;co.BeginReentry()end end;th=r3 end end end;if not c9 and(b3 and b8>j1.noAtmosphericDensityAltitude)and not(c6 or bx or b6)then if not cz and not bx then cy=b8;q0=true;if bo then qc.VectorToTarget=true end;co.ToggleIntoOrbit()bo=false;pZ=true end end;if cv and c9 and c8==-1 and cG>aJ and lF~="Finalizing Approach"then qP(cF)sI=df(cN-s5,cN-M*0.80,cN+M*0.80)end;q7=t4;local qI=-1;if b4 then if not qm then if not cM then qg=0 end;ik:setTargetGroundAltitude(500)ik:activateGroundEngineAltitudeStabilization(500)bz=true;qm=true end;sI=0;local ti=false;local tj=math.abs(qf)if not q and cL then ti=antigrav.getBaseAltitude()if ti<j1.surfaceMaxAltitude and g1==nil or g1~=nil and j1:getAltitude(g1.position)>ti then ti=false end else ti=false end;if d7 then if tj<0.05 then if cI>-N then aZ=false else aZ="BL Align BLR"end;if qP(d7,0.001)then d7=nil;cu=p else q7=0;cu=true end else aZ="BL Align Hzn"end;if ti and eU(cb-ti)<250 then aZ="AGG Align"end else local tk=false;local tl=30;if tj<10 and sa~=nil and sa>0 then local tm=df(ca,0.4,2)local sZ=bs*df(cG/100,0.1,1)*tm;local tn=sa*tm+sZ-om;local to=sZ/2-om;local tp=cG-dh(eU(to/2)*20/(0.5*cc))*utils.sign(to)if tp<0 then tp=0 end;local tq;if cG>100 then local tr,dK=ck.computeDistanceAndTime(cG,100,cc,0,0,sZ)local ts,dK=ck.computeDistanceAndTime(100,0,cc,0,0,dh(sZ))tq=tr+ts else tq=ck.computeDistanceAndTime(cG,0,cc,0,0,dh(sZ))end;if tq<20 then aZ=false else local tt=0;if tp>100 then local tu,dK=ck.computeDistanceAndTime(tp,100,cc,0,0,tn)local tv,dK=ck.computeDistanceAndTime(100,0,cc,0,0,sa*tm+dh(sZ)-om)tt=tu+tv else tt,dK=ck.computeDistanceAndTime(tp,0,cc,0,0,sa*tm+dh(sZ)-om)end;tt=(tt+15+cG*s3)*1.1;local tw=d6 and g1~=nil and j1:getAltitude(g1.position)>0 and g1.safe;local se=nil;if ti and ti<cb then se=ti elseif tw then se=j1:getAltitude(g1.position)+250 elseif cb>j1.surfaceMaxAltitude then se=j1.surfaceMaxAltitude end;if cV then local tx=j1:getAltitude(cV[1].center)if se then if tx>se then se=tx end else se=tx end end;if se~=nil then local ty=cb-se;tk=true;if ty<=tt or tt==-1 or tj>0.05 and d6 then if tj>0.05 and d6 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qI=c8;if qI>-1 then if(cG<1 or cF:normalize():dot(cH)<0)and not d7 then b4=false;b3=false;if not ti then qj=true;ik:setTargetGroundAltitude(Y)end;bU=0;aZ="BL Complete"cu=p;d6=false else aZ="BL Slowing"end elseif not tk then if lw and cF:normalize():dot(-gn)<0.999 then aZ="BL Strong"qP()elseif tj>10 or tj>0.05 and d6 then aZ="BL hSpd"elseif cI<-N then aZ="BL BLR"else aZ=false end end end else qm=false end;if b5 or c6 then local lB,eF,eE;if bi~=nil then lB,eF,eE=cj:getPlanetarySystem(0):castIntersections(cJ,(bi-cJ):normalize(),function(en)return en.radius+en.noAtmosphericDensityAltitude end)end;if cL and not c6 then if cb>=b8-50 and cG>iE then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"qg=0 end end elseif eU(sI)<15 and cb/b8>0.75 then b5=false;if not c6 then if cM and not t then d.control.cancelCurrentControlMasterMode()end elseif c6 and cG<iE then b1=true;c6=false;b3=false;b5=false;qg=0 elseif c6 then qg=0;aZ="ATO Space"end elseif c6 and not c9 and c1~=nil and(lB==nil or lB.name==c1.name)then b1=true;c6=false;b3=false;b5=false;if not cM then qg=0 end;b9=true end end;local tz=c8>-1;local tA=cN;if(bo or c6 or cS)and not tz and cG>aJ and c9 then local mL=math.rad(eU(cO))tA=cN*eU(math.cos(mL))+s5*math.sin(mL)end;local tB=df(sI-tA,-M*0.80,M*0.80)if not c9 and bo then tB=df(sI-tA,-85,O)elseif not c9 then tB=df(sI-tA,-O,O)end;if eU(cO)<5 or bo or cS or b4 or tz or b3 then if sY==nil then sY=pid.new(5*0.01,0,5*0.1)end;sY:inject(tB)local sK=sY:get()q7=q7+sK end end;if antigrav~=nil and(antigrav and not q and cb<200000)then if bt==nil or bt<1000 then bt=1000 end;if tC~=bt then tC=bt;qq=tC end end;if c9 and t and cM then if tD==nil then tD=pid.new(0.1,0,1)end;local tE=0;if aS>0 and not b6 and ca>0.005 and ca<0.1 and cI>-50 then tE=(0.1-ca)*cw*aS end;tD:inject(cw/3.6+tE-cF:dot(cC))local tF=tD:get()bO=df(tF,-1,1)if not d2 then if bO<bL and ca>0.005 then bN=true;d2=df(bO,0.01,1)else bN=false;d2=bL end end;if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-cw/3.6-tE)local tH=df(tG:get(),0,1)if c9 and cI<-80 or ca>0.005 then bM=tH end;if bM>0 then if bN and bO==0.01 and not d2 then d2=0 end else bO=df(bO,0.01,1)end;local tI=''local tJ=vec3()local tK=rk(axisCommandId.vertical,bU*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tK,r_)local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)local tO=ry(axisCommandId.lateral,bw*1000)tI=tI..' , '.."lateral airfoil , lateral ground "tJ=tJ+tO;if tJ:len()>constants.epsilon then d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end;d:setEngineForceCommand(tL,tN,rZ)local tP='thrust analog vertical fueled 'local tQ='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;if bA=="All"or bA=="Vertical"then tP=tP..aV end;if bU~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(tP,tK,rZ)else d:setEngineForceCommand(tP,vec3(),rZ)end;if bw~=0 then d:setEngineForceCommand(tQ,tO,rZ)else d:setEngineForceCommand(tQ,vec3(),rZ)end;if rL==0 then rL=bM end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)else if t then if not d2 then d2=bL end end;local rm=c.getAxisCommandValue(0)if not cM then if tG==nil then tG=pid.new(1*0.01,0,1*0.1)end;tG:inject(cF:len()-rm/3.6)local tH=df(tG:get(),0,1)rL=df(rL+tH,0,1)end;local tR=-rL*(aO*cF+aP*rP)d:setEngineForceCommand('brake',tR)local tI=''local tJ=vec3()local tS=false;local tL='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tL=tL..aT end;local tM=ik:getAxisCommandType(axisCommandId.longitudinal)if tM==axisCommandType.byThrottle then local tN=ik:composeAxisAccelerationFromThrottle(tL,axisCommandId.longitudinal)d:setEngineForceCommand(tL,tN,rZ)elseif tM==axisCommandType.byTargetSpeed then local tN=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tI=tI..' , '..tL;tJ=tJ+tN;if ik:getTargetSpeed(axisCommandId.longitudinal)==0 or ik:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ik:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then tS=true end end;local tQ='thrust analog lateral 'if bA=="All"or bA=="Lateral"then tQ=tQ..aU end;local tT=ik:getAxisCommandType(axisCommandId.lateral)if tT==axisCommandType.byThrottle then local tU=ik:composeAxisAccelerationFromThrottle(tQ,axisCommandId.lateral)d:setEngineForceCommand(tQ,tU,rZ)elseif tT==axisCommandType.byTargetSpeed then local tO=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tI=tI..' , '..tQ;tJ=tJ+tO end;local tP='thrust analog vertical 'if bA=="All"or bA=="Vertical"then tP=tP..aV end;local tV=ik:getAxisCommandType(axisCommandId.vertical)if tV==axisCommandType.byThrottle then local tK=ik:composeAxisAccelerationFromThrottle(tP,axisCommandId.vertical)if bU~=0 or b4 and aZ then d:setEngineForceCommand(tP,tK,rZ,'airfoil','ground','',s0)else d:setEngineForceCommand(tP,vec3(),rZ)d:setEngineForceCommand('airfoil vertical',tK,rZ,'airfoil','','',s0)d:setEngineForceCommand('ground vertical',tK,rZ,'ground','','',s0)end elseif tV==axisCommandType.byTargetSpeed then if bU<0 then d:setEngineForceCommand('hover',vec3(),rZ)end;local tW=ik:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tI=tI..' , '..tP;tJ=tJ+tW end;if tJ:len()>constants.epsilon then if rL~=0 or tS or eU(rP:dot(cC))<0.5 then tI=tI..', brake'end;d:setEngineForceCommand(tI,tJ,r_,'','','',s0)end end;local tX=aL*(rT-rS)local tY=vec3(b.getWorldAirFrictionAngularAcceleration())tX=tX-tY;d:setEngineTorqueCommand('torque',tX,rZ,'airfoil','','',s0)d:setBoosterCommand('rocket_engine')if bZ and not n then local fl=cE:len()local tZ=0.15;if not cM then local t_=ik:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>t_*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl*3.6<t_*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local pl=c.getThrottle()if t then pl=bL*100 end;local rm=pl/100;if not c9 then rm=rm*_;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end else local t5=bI(cw)rm=rm*t5/3.6;if fl>=rm*(1-tZ)and u0 then u0=false;d:toggleBoosters()elseif fl<rm*(1-tZ)and not u0 then u0=true;d:toggleBoosters()end end end end end;if u1 then for dF,dr in pairs(u1)do pP[dF]=dr end end;c8=qD()return pP end;local function u2(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dg,df,fQ,io,pO)local u5={}local u6=true;local u7=5;local u8=5;local u9=u7;local ua=u8;local ub=bK;function u5.landingGear()bk=not bk;if bk then bo=false;br=nil;co.cmdThrottle(0)if vBooster or hover then if c9 and c8==-1 then fQ("bklOn","BL")lw=true;b6=false;b5=false;b7=false;b3=false;if b4 then d6=not d6 end;b4=true;cu=true;bk=false else if bQ then fQ("grOut","LG",1)d.control.extendLandingGears()end;d6=false;ik:setTargetGroundAltitude(Y)if c9 then aZ="Landing"end end end;if bQ and not b4 and not(vBooster or hover)then fQ("grOut","LG",1)d.control.extendLandingGears()end else if bQ then fQ("grIn","LG",1)d.control.retractLandingGears()end;ik:activateGroundEngineAltitudeStabilization(uc)if bz then ik:setTargetGroundAltitude(X)end end end;function u5.startControl(ud)local function ue(re)local rf=1;local function uf(ug,re)local uh={j1.surfaceMaxAltitude+100,j1.spaceEngineMinAltitude-0.01*j1.noAtmosphericDensityAltitude,j1.noAtmosphericDensityAltitude+T,j1.radius*(S-1)+j1.noAtmosphericDensityAltitude}local ui=ug;for dK,dr in ipairs(uh)do if re and ui>dr then ug=dr elseif ug<dr and not re then ug=dr;break end end;return ug end;if re then rf=-1 end;if not q and cL then if bW and re then bt=1000 elseif bt~=nil then bt=bt+rf*u8;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tC+rf*100 end elseif b3 or b7 or bx then if bx then if bW then cy=uf(cy,re)else cy=cy+rf*u7 end;if cy<j1.noAtmosphericDensityAltitude then cy=j1.noAtmosphericDensityAltitude end else if bW and c9 then b8=uf(b8,re)else b8=b8+rf*u7 end end else if not re and c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:updateTargetGroundAltitudeFromActionStart(rf*1.0)end end;local function uj(uk)if not c9 then bX="Flight Assist in Atmo only"return end;local dn=type(uk)if cS==nil then if dn=="table"then if b1 or bo then co.ToggleAutopilot()end;fQ("180On","BR")elseif uk==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then co.ToggleAltitudeHold()if dn~="table"then uk=uk+1 end end;cS=uk else fQ("180Off","BR")cS=nil end end;if ud=="gear"then cq.landingGear()elseif ud=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ud=="forward"then if p7 and not c9 and not b1 then b0=not b0;a_=false else bR=bR-1 end elseif ud=="backward"then if p7 then if not c9 then if not b1 then a_=not a_;b0=false else b2=not b2 end else uj(-cF*5000)end else bR=bR+1 end elseif ud=="left"then if p7 then uj(1)else bS=bS-1 end elseif ud=="right"then if p7 then uj(3)else bS=bS+1 end elseif ud=="yawright"then bT=bT-1;d7=nil elseif ud=="yawleft"then bT=bT+1;d7=nil elseif ud=="straferight"then ik:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif ud=="strafeleft"then ik:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif ud=="up"then bU=bU+1;if c8-3<Y and cb>0 and bk then cq.landingGear()end;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ud=="down"then bU=bU-1;ik:deactivateGroundEngineAltitudeStabilization()ik:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ud=="groundaltitudeup"then ue()elseif ud=="groundaltitudedown"then ue(true)elseif ud=="option1"then ul=false;if p7 and bW then local um=""for K=1,#cY do um=um.."| Name: "..a.getPlayerName(cY[K]).." Mass: "..fR(b.getBoardedPlayerMass(cY[K])/1000,1).."t "end;a.print("Onboard: "..um)return end;cn.adjustAutopilotTargetIndex()elseif ud=="option2"then ul=false;if p7 and bW then for K=1,#cY do b.forceDeboard(cY[K])end;bX="Deboarded All Passengers"return end;cn.adjustAutopilotTargetIndex(1)elseif ud=="option3"then local function un()u6=not u6;if not u6 then fQ("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uo,atmofueltank_size,"Atmo Fuel","fuel_container")up=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uq,spacefueltank_size,"Space Fuel","fuel_container")ur=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(us,rocketfueltank_size,"Rocket Fuel","fuel_container")ut=_autoconf.panels[_autoconf.panels_size]end;uu=a.createWidgetPanel("Docking")uv=a.createWidget(uu,"parenting")a.addDataToWidget(c.getDataId(),uv)uw=a.createWidgetPanel("Core combat stress")ux=a.createWidget(uw,"core_stress")a.addDataToWidget(b.getDataId(),ux)if db~=nil then db.show()end else fQ("hud","DH")c.hide()b.hide()if up~=nil then gI(up)up=nil end;if uu~=nil then gI(uu)uu=nil end;if uw~=nil then gI(uw)uw=nil end;if ur~=nil then gI(ur)ur=nil end;if ut~=nil then gI(ut)ut=nil end;if db~=nil then db.hide()end end end;ul=false;if p7 and bW then local um=""for K=1,#cZ do um=um.."| ID: "..cZ[K].." Mass: "..fR(b.getDockedConstructMass(cZ[K])/1000,1).."t "end;a.print("Docked Ships: "..um)return end;if x then if w then w=false else w=true end end;un()elseif ud=="option4"then ul=false;if p7 and bW then for K=1,#cZ do b.forceUndock(cZ[K])end;bX="Undocked all ships"return end;cS=nil;co.ToggleAutopilot()elseif ud=="option5"then ul=false;co.ToggleLockPitch()elseif ud=="option6"then ul=false;if p7 and bW then if db then cr.ventShield()else bX="No shield found"end;return end;co.ToggleAltitudeHold()elseif ud=="option7"then ul=false;if p7 and bW then if db then db.toggle()return else bX="No shield found"return end end;E=not E;if E then bX="Collision System Enabled"else bX="Collision System Secured"end elseif ud=="option8"then ul=false;if p7 and bW then if bj>0 and g1~=nil then co.routeWP()else bX="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bX="DeCoupled Mode - Ground Stabilization off"ik:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bX="Coupled Mode - Ground Stabilization on"ik:activateGroundEngineAltitudeStabilization(uc)d9=true;fQ("gsOn","GS")end elseif ud=="option9"then ul=false;if p7 and bW then ik:resetCommand(axisCommandId.longitudinal)ik:resetCommand(axisCommandId.lateral)ik:resetCommand(axisCommandId.vertical)co.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()cd=gyro.getState()==1;if cd then fQ("gyOn","GA")else fQ("gyOff","GA")end else bX="No gyro found"end elseif ud=="lshift"then cW=false;if p7 then bW=true end;if il()==1 then bW=true;bg=il()u4(1)elseif ij()==1 and y then bW=true;ct=false;cs=false end elseif ud=="brake"then if aX or p7 then co.BrakeToggle("Manual")elseif not aZ then co.BrakeToggle("Manual")else aZ="Manual"end elseif ud=="lalt"then ul=true;p7=true;if ij()==0 and not i and g=="keyboard"then u4(1)end elseif ud=="booster"then if n then d:toggleBoosters()elseif not bZ then if not u0 then d:toggleBoosters()u0=true end;bZ=true else if u0 then d:toggleBoosters()u0=false end;bZ=false end elseif ud=="stopengines"then local function uy()if bK-ub<1.5 then fQ("clear","CA")co.clearAll()end end;uy()ub=bK;if ik:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ik:resetCommand(axisCommandId.longitudinal)co.cmdThrottle(0)else co.cmdThrottle(100)end else if ik:getTargetSpeed(axisCommandId.longitudinal)~=0 then ik:resetCommand(axisCommandId.longitudinal)else if c9 then co.cmdCruise(cw)else co.cmdCruise(_*3.6)end end end elseif ud=="speedup"then co.changeSpd()elseif ud=="speeddown"then co.changeSpd(true)elseif ud=="antigravity"and not q then if antigrav~=nil then co.ToggleAntigrav()else bX="No antigrav found"end end end;function u5.stopControl(ud)local function uz()if not q and cL then ua=u8 end;if b3 or b7 or bx then u9=u7 end end;if ud=="forward"then bR=0 elseif ud=="backward"then bR=0 elseif ud=="left"then if cS then if cS==2 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="right"then if cS then if cS==4 then cS=-2 else cS=-1 end end;bS=0 elseif ud=="yawright"then bT=0 elseif ud=="yawleft"then bT=0 elseif ud=="straferight"then ik:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif ud=="strafeleft"then ik:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif ud=="up"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="down"then bU=0;ik:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then ik:activateGroundEngineAltitudeStabilization(uc)d9=true end elseif ud=="groundaltitudeup"then uz()ul=false elseif ud=="groundaltitudedown"then uz()ul=false elseif ud=="lshift"then if il()==1 then c2=0;c3=0;u4(bg)elseif ij()==1 and y then ct=false;cs=false end;bW=false elseif ud=="brake"then if not aX and not p7 then if aZ then co.BrakeToggle()else aZ=false end end elseif ud=="lalt"then if ij()==0 and i then if ul then if il()==1 then u4(0)else u4(1)end else ul=true end elseif ij()==0 and not i and g=="keyboard"then u4(0)end;p7=false end end;function u5.loopControl(ud)local function uA(re)local rf=1;if re then rf=-1 end;if not q and cL then if bt~=nil then bt=bt+rf*ua;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;ua=df(ua*1.05,u8,50)else bt=tC+rf*100 end elseif b3 or b7 or bx then if bx then cy=cy+rf*u9;if cy<j1.noAtmosphericDensityAltitude then cy=j1.noAtmosphericDensityAltitude end else b8=b8+rf*u9 end;u9=df(u9*1.05,u7,50)else ik:updateTargetGroundAltitudeFromActionLoop(rf*1.0)end end;local function uB(re)local rf=1;if re then rf=-1 end;if not bW then if t and not p7 then bL=df(bL+rf*aD/100,-1,1)else ik:updateCommandFromActionLoop(axisCommandId.longitudinal,rf*aD)end end end;if ud=="groundaltitudeup"then if not bW then uA()end elseif ud=="groundaltitudedown"then if not bW then uA(true)end elseif ud=="speedup"then uB()elseif ud=="speeddown"then uB(true)end end;function u5.inputTextControl(rd)local function uC(uD,fr,gv)local function uE(fr)local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dy='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local dO,dP,dX,dY,dZ=d_(fr,dy)if dO=="0"and dP=="0"then return vec3(dg(dX),dg(dY),dg(dZ))end;dY=math.rad(dY)dX=math.rad(dX)local j1=e[dg(dO)][dg(dP)]local eQ=math.cos(dX)local uF=vec3(eQ*math.cos(dY),eQ*math.sin(dY),math.sin(dX))return j1.center+(j1.radius+dZ)*uF end;local fT=uE(fr)return cn.AddNewLocation(uD,fT,gv)end;local K;local uG,i7=nil,nil;local uH="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(rd," ")uG=rd;if K~=nil then uG=string.sub(rd,0,K-1)i7=string.sub(rd,K+1)end;if uG=="/help"or uG=="/commands"then for lx in string.gmatch(uH,"([^\n]+)")do a.print(lx)end;return elseif uG=="/setname"then if i7==nil or i7==""then bX="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then cn.UpdatePosition(i7)else bX="Select a saved target to rename first"end elseif db and uG=="/resist"then cr.setResist(i7)elseif uG=="/addlocation"or string.find(rd,"::pos")~=nil then local gv=false;local uD="0-Temp"if i7==nil or i7==""or uG~="/addlocation"then i7=uG;gv=true end;K=string.find(i7,"::")if not gv then uD=string.sub(i7,1,K-2)end;local fr=string.sub(i7,K)uC(uD,fr,gv)elseif uG=="/agg"then if i7==nil or i7==""then bX="Usage: /agg targetheight"return end;i7=dg(i7)if i7<1000 then i7=1000 end;bt=i7;bX="AGG Target Height set to "..i7 elseif uG=="/G"then if i7==nil or i7==""then bX="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if i7=="dump"then for dF,dr in pairs(io())do if type(dr.get())=="boolean"then if dr.get()==true then a.print(dF.." true")else a.print(dF.." false")end elseif dr.get()==nil then a.print(dF.." nil")else a.print(dF.." "..dr.get())end end;return end;K=string.find(i7," ")local uI=string.sub(i7,0,K-1)local uJ=string.sub(i7,K+1)for dF,dr in pairs(io())do if dF==uI then local uK=type(dr.get())if uK=="number"then uJ=dg(uJ)if dF=="AtmoSpeedLimit"then cw=uJ end end;bX="Variable "..uI.." changed to "..uJ;if dF=="MaxGameVelocity"then uJ=uJ/3.6;if uJ>da-0.2 then uJ=da-0.2;bX="Variable "..uI.." changed to "..fR(uJ*3.6,1)end end;if uK=="boolean"then if string.lower(uJ)=="true"then uJ=true else uJ=false end end;dr.set(uJ)return end end;bX="No such global variable: "..uI elseif uG=="/deletewp"then if bj>0 and g1~=nil then cn.ClearCurrentPosition()else bX="Select a custom wp to delete first in IPH"end elseif uG=="/copydatabank"then if dbHud_2 then pO(true)else bX="Spare Databank required to copy databank"end elseif uG=="/iphWP"then if bj>0 then a.print(co.showWayPoint(c1,bi,true))a.print(json.encode(bi))bX="::pos waypoint shown in lua chat in local and world format"else bX="No target selected in IPH"end elseif uG=="/createPrivate"then local uL="privatelocations = {\n"local uM=""if#d4>0 then for dF,dr in pairs(d4)do uL=uL.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uL=uL.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uL=uL.."safe = true},\n"else uL=uL.."safe = false},\n"end end end;uM=#d4 .."-Private "if i7=="all"then for dF,dr in pairs(bn)do uL=uL.."{position = {x = "..dr.position.x..", y = "..dr.position.y..", z = "..dr.position.z.."},\n ".."name = '*"..dr.name.."',\n planetname = '"..dr.planetname.."',\n gravity = "..dr.gravity..",\n"if dr.heading then uL=uL.."heading = {x = "..dr.heading.x..", y = "..dr.heading.y..", z = "..dr.heading.z.."},\n"end;if dr.safe then uL=uL.." safe = true},\n"else uL=uL.."safe = false},\n"end end;uM=uM..#bn.."-Public "end;uL=uL.."}\n return privatelocations"if u3 then u3.setHTML(uL)end;bX=uM.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bY=7 end end;function u5.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bX="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uN then for dF,dr in pairs(uN)do u5[dF]=dr end end;return u5 end;local function uO(d,b,c,a,library,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u3)local uP={}local de=string.format;local ih=json.decode;local uQ=json.encode;local pG=b.getElementMaxHitPointsById;local ii=b.getElementMassById;local ij=d.control.isRemoteControlled;local d_=string.match;local gI=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local u4=a.lockView;local il=a.isViewLocked;local dh=math.sqrt;local dg=tonumber;local eU=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eP=math.atan;local bH=a.getArkTime;local df=utils.clamp;local ik=d.axisCommandManager;local uR=Y;local gK=13;local ir=b.getElementIdList()local is=0;local function di(ex,ey)if ex==0 then return eU(ey)<1e-09 end;if ey==0 then return eU(ex)<1e-09 end;return eU(ex-ey)<math.max(eU(ex),eU(ey))*dw end;local function fR(dx,uS)local rf=10^(uS or 0)return bI(dx*rf+0.5)/rf end;local function im(uT,uU)for dF,dr in pairs(uU)do if type(dF)=="string"then uT[dF]=dr else uT[#uT+1]=uU[dF]end end;return uT end;local function io(uV)local uW={}if not uV then im(uW,J)im(uW,a8)im(uW,aB)im(uW,aW)return uW elseif uV=="boolean"then return J elseif uV=="handling"then return a8 elseif uV=="hud"then return aB elseif uV=="physics"then return aW end end;local function pO(uX)local function uY(uZ)for dF,dr in pairs(uZ)do dbHud_1.setStringValue(dF,uQ(dr.get()))if uX and dbHud_2 then dbHud_2.setStringValue(dF,uQ(dr.get()))end end end;if dbHud_1 then uY(bE)uY(io())a.print("Saved Variables to Datacore")if uX and dbHud_2 then bX="Databank copied.  Remove copy when ready."end end end;local function fQ(u_,v0,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..u_..".mp3")end;local function gJ(hk,hl,rd,jI,v1)if jI==nil then jI=""end;if v1==nil then v1=""end;return de([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hk,hl,v1,rd)end;local function ip(c4,v2)local v3=c4>100000;if v2==nil then v2=1 end;if v3 then return fR(c4/1000/200,v2).."SU"elseif c4<1000 then return fR(c4,v2).."M"else return fR(c4/1000,v2).."KM"end end;local function iq(v4)local v5=0;local v6=0;local v7=0;if v4<60 then v4=bI(v4)elseif v4<3600 then v5=bI(v4/60)v4=bI(v4%60)elseif v4<86400 then v6=bI(v4/3600)v5=bI(v4%3600/60)else v7=bI(v4/86400)v6=bI(v4%86400/3600)end;if v7>0 then return v7 .."d "..v6 .."h "elseif v6>0 then return v6 .."h "..v5 .."m "elseif v5>0 then return v5 .."m "..v4 .."s"elseif v4>0 then return v4 .."s"else return"0s"end end;function uP.onStart()local v8=false;local function v9()local function va(vb)local vc=dbHud_1.hasKey;for dF,dr in pairs(vb)do if vc(dF)then local dA=ih(dbHud_1.getStringValue(dF))if dA~=nil then dr.set(dA)v8=true end end end end;if dbHud_1 then if not f then va(io())coroutine.yield()va(bE)else va(bE)bX="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bY=5;v8=false end;coroutine.yield()if v8 then bX="Loaded Saved Variables"ce=a9;cf=aa;aX=j;g=string.lower(g)cu=p;cw=U elseif not f then bX="No Saved Variables Found - Exit HUD to save settings"end;if bB<1.500 then if T<2000 then bX="Updating LowOrbitHeight to new minimum default of 2000."T=2000 end end;bB=VERSION_NUMBER;if#bn>0 then d5=im(d5,bn)end else bX="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bu+180<bK then bs=0 end;bu=bK;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bX="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bY=7 end;if antigrav and not q then if bt==nil then bt=cb end;antigrav.setBaseAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d4>0 then d5=im(d5,d4)end end;lF="Proceeding to Waypoint"end;local function vd()local function ve(vf,vg)if vf>vg then vg=vf end;local vh,vi=0,0;if a5>0 then vh=a5*0.05 end;if a6>0 then vi=a6*0.05 end;vg=vg*(1-(vh+vi))return vg end;local vj=b.getElementNameById;local vk=aq~=0 and ar~=0;local vl=_G["atmofueltank_size"]local vm=_G["spacefueltank_size"]local vn=_G["rocketfueltank_size"]for dF in pairs(ir)do local type=b.getElementTypeById(ir[dF])if d_(type,'^.*Atmospheric Engine$')then if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')and b.getElementForwardById(ir[dF])[3]>0 then cK=true end end;if d_(type,'^.*Space Engine$')then cB=true;if d_(tostring(b.getElementTagsById(ir[dF])),'^.*vertical.*$')then local vo=b.getElementForwardById(ir[dF])if vo[3]<0 then vp=true else cA=true end end end;if type=="Landing Gear"then bQ=true end;if type=="Dynamic Core Unit"then local pI=pG(ir[dF])if pI>10000 then gK=110 elseif pI>1000 then gK=55 elseif pI>150 then gK=27 end end;is=is+pG(ir[dF])if vk and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pI=pG(ir[dF])local ov=ii(ir[dF])local vf=0;local jB=bH()if type=="Atmospheric Fuel Tank"then local vg=400;local vq=35.03;if pI>10000 then vg=51200;vq=5480 elseif pI>1300 then vg=6400;vq=988.67 elseif pI>150 then vg=1600;vq=182.67 end;vf=ov-vq;if a2>0 then vg=vg+vg*a2*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jz=0;for jA=1,vl do if gu==ih(c["atmofueltank_"..jA].getData()).name then jz=jA;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,jB,jz}cg[#cg+1]=vr end;if type=="Rocket Fuel Tank"then local vg=320;local vq=173.42;if pI>65000 then vg=40000;vq=25740 elseif pI>6000 then vg=5120;vq=4720 elseif pI>700 then vg=640;vq=886.72 end;vf=ov-vq;if a4>0 then vg=vg+vg*a4*0.1 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jz=0;for jA=1,vn do if gu==ih(c["rocketfueltank_"..jA].getData()).name then jz=jA;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,jB,jz}ci[#ci+1]=vr end;if type=="Space Fuel Tank"then local vg=600;local vq=35.03;if pI>10000 then vg=76800;vq=5480 elseif pI>1300 then vg=9600;vq=988.67 elseif pI>150 then vg=2400;vq=182.67 end;vf=ov-vq;if a3>0 then vg=vg+vg*a3*0.2 end;vg=ve(vf,vg)local gu=vj(ir[dF])local jz=0;for jA=1,vm do if gu==ih(c["spacefueltank_"..jA].getData()).name then jz=jA;break end end;local vr={ir[dF],string.sub(gu,1,12),vg,vq,vf,jB,jz}ch[#ch+1]=vr end end end;if not cK then b7,aY=false,false end end;local function vs()if gyro~=nil then cd=gyro.getState()==1 end;if not bz then ik:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then u4(1)else u4(0)end;if door and(c9 or not c9 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(c9 or not c9==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;if antigrav then cL=antigrav.getState()==1;if cL and not q then antigrav.show()end end;if ij()==1 and k then a.freeze(1)else a.freeze(0)end;if bQ then if c8~=-1 and not cL then d.control.extendLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearExtended()==1 or c8~=-1 and c8-3<Y;if c8~=-1 or not c9 and cE:len()<50 then aZ="Startup"else aZ=false end;ik:setTargetGroundAltitude(uR)pu=c9 end;local function vt()local vu={}local function vv()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vw={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vx={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vy,vz in pairs(e)do e[vy][0]=vv()e[vy][0].systemId=vy;vu[vy]={}for vA,j1 in pairs(e[vy])do j1.gravity=j1.gravity/9.8;j1.center=vec3(j1.center)j1.name=j1.name[1]j1.noAtmosphericDensityAltitude=vx[j1.id]or j1.atmosphereThickness or j1.atmosphereRadius-j1.radius;j1.spaceEngineMinAltitude=vw[j1.id]or 0.68377*j1.atmosphereThickness;j1.planetarySystemId=vy;j1.bodyId=j1.id;vu[vy][vA]=j1;if mx==nil or j1.center.x<mx then mx=j1.center.x end;if mw==nil or j1.center.x>mw then mw=j1.center.x end;if mA==nil or j1.center.y<mA then mA=j1.center.y end;if mz==nil or j1.center.y>mz then mz=j1.center.y end;if j1.center and j1.name~="Space"then c_[#c_+1]=j1 end end end;e9=dd(d,b,c,a,de,df,dg,dh,di)cj=e9(vu)ck=eT(d,b,c,a,dh,eU)cl=fn(d,b,c,a,de,df,dg,dh,di)cn=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,dg,dh,fQ,fR)j1=cj[0]:closestBody(b.getConstructWorldPos())end;vB=false;vC=coroutine.create(function()ik:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})v9()coroutine.yield()vd()coroutine.yield()co=pM(d,b,c,a,e,vBooster,hover,pN,antigrav,warpdrive,dbHud_1,radar_1,eU,bI,bJ,ij,eP,bH,df,ik,fO,il,dh,fR,fQ,im,di,ip,iq,pO,ih,de,fP)vs()coroutine.yield()vt()if radar_1 then cp=gH(b,a,c,library,radar_1,radar_2,eU,gI,dh,gJ,dg,gK,fQ)end;cm=ie(d,b,c,a,e,radar_1,radar_2,antigrav,hover,db,warpdrive,ig,eU,bI,de,ih,bJ,ii,ij,eP,bH,df,ik,fP,fO,gI,il,dh,fR,gJ,fQ,im,io,ip,iq,ir,is)cm.ButtonSetup()cq=u2(d,b,c,a,e,vBooster,hover,antigrav,db,dbHud_2,gyro,u3,ij,ik,il,u4,gI,fR,d_,dg,df,fQ,io,pO)if db then cr=hZ(db,d_,bI)end;coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)if u3 then u3.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if db then c.setTimer("shieldTick",0.0166667)end;if vD then vE.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vC)end;function uP.onUpdate()if not vB then local hQ=coroutine.status(vC)if hQ=="suspended"then local dG,hR=coroutine.resume(vC)if hR then a.print("ERROR STARTUP: "..hR)end elseif hQ=="dead"then vB=true end end;if vB then d:update()if c9 and t and cM then if cM and bP then co.cmdThrottle(0)bP=false elseif not cM and not bP then bL=0;bP=true end end;if d2 then ik:setThrottleCommand(axisCommandId.longitudinal,d2)d2=nil end;if not cs and p9~=vF then a.setScreen(p9)end;vF=p9;if vD then vE.ExtraOnUpdate()end end end;function uP.onFlush()if vB then co.onFlush()if vD then vE.ExtraOnFlush()end end end;function uP.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(door)do dr.toggle()end end;if switch then for dK,dr in pairs(switch)do dr.toggle()end end;if forcefield and(ca>0 or ca==0 and cb<10000)then for dK,dr in pairs(forcefield)do dr.toggle()end end;w=d1;pO()if o4 then o4.activate()end;if z then co.showWayPoint(j1,cJ)end;a.print(cm.FuelUsed("atmofueltank")..", "..cm.FuelUsed("spacefueltank")..", "..cm.FuelUsed("rocketfueltank"))if vD then vE.ExtraOnStop()end;fQ("stop","SU")end;function uP.controlStart(ud)if vB then cq.startControl(ud)end end;function uP.controlStop(ud)if vB then cq.stopControl(ud)end end;function uP.controlLoop(ud)if vB then cq.loopControl(ud)end end;function uP.controlInput(rd)if vB then cq.inputTextControl(rd)end end;function uP.radarEnter(dP)cp.onEnter(dP)end;function uP.radarLeave(dP)cp.onLeave(dP)end;function uP.onTick(vG)if vG=="tenthSecond"then co.TenthTick()cm.TenthTick()elseif vG=="oneSecond"then cm.OneSecondTick()elseif vG=="fiveSecond"then co.SatNavTick()elseif vG=="msgTick"then cm.MsgTick()elseif vG=="animateTick"then cm.AnimateTick()elseif vG=="hudTick"then cm.hudtick()elseif vG=="apTick"then co.APTick()elseif vG=="shieldTick"then cr.shieldTick()elseif vG=="tagTick"then cq.tagTick()elseif vG=="contact"then cp.ContactTick()end end;if vD then for dF,dr in pairs(vD)do uP[dF]=dr end end;return uP end;function script.onStart()vE.onStart()end;function script.onStop()vE.onStop()end;function script.onTick(vG)vE.onTick(vG)end;function script.onFlush()vE.onFlush()end;function script.onUpdate()vE.onUpdate()end;function script.onActionStart(ud)vE.controlStart(ud)end;function script.onActionStop(ud)vE.controlStop(ud)end;function script.onActionLoop(ud)vE.controlLoop(ud)end;function script.onInputText(rd)vE.controlInput(rd)end;function script.onEnter(dP)vE.radarEnter(dP)end;function script.onLeave(dP)vE.radarLeave(dP)end;bG(a,b,c,a.getArkTime,math.floor,c.getAtmosphereDensity)vE=uO(d,b,c,a,library,e,vBooster,hover,pN,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,db,gyro,warpdrive,ig,u3)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
