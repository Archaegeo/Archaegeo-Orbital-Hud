name: ArchHud - Archaegeo v1.158 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export: (Default: false)
        userControlScheme = "virtual joystick" --export: (Default: "virtual joystick") Set to "virtual joystick", "mouse", or "keyboard"
        freeLookToggle = true --export: (Default: true)
        BrakeToggleDefault = true --export: (Default: true)
        RemoteFreeze = false --export: (Default: false)
        RemoteHud = true --export: (Default: true)
        brightHud = false --export: (Default: false)
        VanillaRockets = false --export: (Default: false)
        InvertMouse = false --export: (Default: false)
        autoRollPreference = false --export: (Default: false)
        turnAssist = true --export: (Default: true)
        ExternalAGG = false --export: (Default: false)
        UseSatNav = false --export: (Default: false)
        ShouldCheckDamage = true --export: (Default: true)
        CalculateBrakeLandingSpeed = false --export: (Default: false)
        AtmoSpeedAssist = true --export: (Default: true)
        ForceAlignment = false --export: (Default: false)
        DisplayDeadZone = true --export: (Default: true)
        showHud = true --export: (Default: true) 
        ShowOdometer = true --export: (Default: true)
        hideHudOnToggleWidgets = true --export: (Default: true)
        ShiftShowsRemoteButtons = true --export: (Default: true)
        DisplayOrbit = true --export: (Default: true) 
        YawStallAngle = 35 --export: (Default: 35)
        PitchStallAngle = 35 --export: (Default: 35)
        brakeLandingRate = 30 --export: (Default: 30)
        MaxPitch = 30 --export: (Default: 30)
        TargetOrbitRadius = 1.4 --export: (Default: 1.4)
        LowOrbitHeight = 1000 --export: (Default: 1000)
        AtmoSpeedLimit = 1050 --export: (Default: 1050)
        SpaceSpeedLimit = 30000 --export: (Default: 30000).
        AutoTakeoffAltitude = 1000 --export: (Default: 1000)
        TargetHoverHeight = 50 --export: (Default: 50)
        LandingGearGroundHeight = 0 --export: (Default: 0)
        MaxGameVelocity = 8333.00 --export: (Default: 8333.00)
        AutopilotInterplanetaryThrottle = 1.0 --export: (Default: 1.0)
        warmup = 32 --export: (Default: 32)
        fuelTankHandlingAtmo = 0 --export: (Default: 0)
        fuelTankHandlingSpace = 0 --export: (Default: 0)
        fuelTankHandlingRocket = 0 --export: (Default: 0)
        ContainerOptimization = 0 --export: (Default: 0)
        FuelTankOptimization = 0 --export: (Default: 0)
        ResolutionX = 1920 --export: (Default: 1920)
        ResolutionY = 1080 --export: (Default: 1080) 
        circleRad = 400 --export: (Default: 400)
        SafeR = 130 --export: (Default: 130)
        SafeG = 224 --export: (Default: 224)
        SafeB = 255 --export: (Default: 255)
        PvPR = 255 --export: (Default: 255)
        PvPG = 0 --export: (Default: 0)
        PvPB = 0 --export: (Default: 0)
        centerX = 960 --export: (Default: 960)
        centerY = 540 --export: (Default: 540)
        throtPosX = 1300 --export: (Default: 1300)
        throtPosY = 540 --export: (Default: 540)
        vSpdMeterX = 1525  --export: (Default: 1525)
        vSpdMeterY = 325 --export: (Default: 325)
        altMeterX = 550  --export: (Default: 550)
        altMeterY = 540 --export: (Default: 540) 
        fuelX = 100 --export: (Default: 100)
        fuelY = 300 --export: (Default: 300)
        DeadZone = 50 --export: (Default: 50)
        OrbitMapSize = 250 --export: (Default: 250)
        OrbitMapX = 75 --export: (Default: 75)
        OrbitMapY = 0 --export: (Default: 0)
        speedChangeLarge = 5 --export: (Default: 5)
        speedChangeSmall = 1 --export: (Default: 1)
        MouseXSensitivity = 0.003 --export: (Default: 0.003)
        MouseYSensitivity = 0.003 --export: (Default: 0.003)
        autoRollFactor = 2 --export: (Default: 2)
        rollSpeedFactor = 1.5 --export: (Default: 1.5)
        autoRollRollThreshold = 0 --export: (Default: 0)
        minRollVelocity = 150 --export: (Default: 150)    
        turnAssistFactor = 2 --export: (Default: 2)
        TrajectoryAlignmentStrength = 0.002 --export: (Default: 0.002)
        torqueFactor = 2 --export: (Default: 2)
        pitchSpeedFactor = 0.8 --export: (Default: 0.8)
        yawSpeedFactor = 1 --export: (Default: 1)
        brakeSpeedFactor = 3 --export: (Default: 3)
        brakeFlatFactor = 1 --export: (Default: 1)
        DampingMultiplier = 40 --export: (Default: 40) 
        apTickRate = 0.0166667 --export: (Default: 0.0166667)  
        hudTickRate = 0.0666667 --export: (Default: 0.0666667)
        ExtraLongitudeTags = "none" --export: (Default: "none")
        ExtraLateralTags = "none" --export: (Default: "none")
        ExtraVerticalTags = "none" --export: (Default: "none")
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.158;SetWaypointOnExit=true;IntruderAlertSystem=false;AlwaysVSpd=false;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;showHelp=true;safeMass=0;local b={"showHelp","VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local tostring=tostring;local o=utils.round;local p=system.getTime;local vec3=vec3;local q=utils.clamp;local r=a.axisCommandManager;local s=system.destroyWidgetPanel;local t=system.updateData;local u=system.addDataToWidget;local v=system.lockView;local w=system.isViewLocked;local function x(y,z)local A=10^(z or 0)return d(y*A+0.5)/A end;local B=16;local C=SafeR;local D=SafeB;local E=SafeG;local F=0;local G=0;local H=false;local I=0;local J=false;local K=x(ResolutionX/2,0)local L=x(ResolutionY/2,0)local M=false;local N=55;local O=false;local P=false;local Q=0;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=false;local Y=false;local Z="empty"local a0=5;local a1=5;local a2=a0;local a3=a1;local a4=false;local a5,a6=0;local a7,a8=0;local a9=nil;local aa=0;local ab=0;local ac=false;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=""local ak=0;local al=false;local am=false;local an=false;local ao=-1;local ap=false;local aq=""local ar=j()>0;local as=j()local at=core.getAltitude()local au=core.getElementIdList()local av=p()local aw=core.getConstructMass()local ax=false;local ay=nil;local az=false;local aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]local aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local aC={}local aD=0;local aE=0;local aF=""local aG=true;local aH={}local aI={}local aJ={}local aK=ResolutionX;local aL=ResolutionY;local aM=false;local aN=false;local aO=nil;local aP={}local aQ={}local aR={}local aS=0;local aT=false;local aU={}local aV={}local aW=d(1/apTickRate)*2;local aX={}local aY={}local aZ={}local a_={}local b0=false;local b1=0;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=nil;local b7=nil;local b8=nil;local b9=nil;local ba=nil;local bb=nil;local bc=nil;local bd=nil;local be=false;local bf=false;local bg=autoRollPreference;local bh=LandingGearGroundHeight;local bi=false;local bj=p()local bk=0;local bl=0;local bm=0;local bn=AtmoSpeedLimit;local bo=0;local bp=nil;local bq=0;local br=0;local bs=false;local bt=false;local bu={VectorToTarget=false}local bv=false;local bw=0;local bx=nil;local by=false;local bz=false;local bA=false;local bB=false;local bC=0;local bD=p()local bE=vec3(core.getConstructWorldOrientationUp())local bF=vec3(core.getConstructWorldOrientationForward())local bG=vec3(core.getConstructWorldOrientationRight())local bH=vec3(core.getWorldVelocity())local bI=vec3(bH):len()local bJ=vec3(core.getWorldVertical())local bK=-bJ:dot(bH)local bL=vec3(core.getConstructWorldPos())local bM=nil;local bN=0;local bO=false;local bP=false;local bQ=nil;local bR=true;local bS=0;local bT=0;local bU=false;local bV={}local bW=showHud;local bX={}local function bY(bZ,b_)for i=1,#b_ do bZ[#bZ+1]=b_[i]end;return bZ end;local function c0(c1)local c2={}local c3={"userControlScheme","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd"}local c4={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local c5={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY"}local c6={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c1 then bY(c2,c3)bY(c2,c4)bY(c2,c5)bY(c2,c6)return c2 elseif c1=="boolean"then return c3 elseif c1=="handling"then return c4 elseif c1=="hud"then return c5 elseif c1=="physics"then return c6 end end;local function c7(c8,c9,ca,cb,cc)if cb==nil then cb=""end;if cc==nil then cc=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cb,c8,c9,cc,ca)end;local function cd(ce,cf)if r:getAxisCommandType(0)~=axisCommandType.byThrottle and not cf then a.control.cancelCurrentControlMasterMode()end;r:setThrottleCommand(axisCommandId.longitudinal,ce)F=q(x(ce*100,0)/100,-1,1)end;local function cg(ce,cf)if r:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cf then a.control.cancelCurrentControlMasterMode()end;r:setTargetSpeedCommand(axisCommandId.longitudinal,ce)bQ=ce end;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*epsilon end;local function ck(ah,cl)local cm=ah>100000;local cn,co=""if cl==nil then cl=1 end;if cm then cn,co=x(ah/1000/200,cl),"SU"elseif ah<1000 then cn,co=x(ah,cl),"M"else cn,co=x(ah/1000,cl),"KM"end;return cn,co end;local function cp()if VertTakeOff then AltitudeHold=false;StrongBrakes=true;Reentry=false;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=true;VertTakeOff=false;bg=true;ad=0;if ar and ao==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cg(d(bn))end else VertTakeOff=true;AltitudeHold=false;by=false;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end end;local function cq()by=false;bq=nil;br=nil;bC=0;if as==0 then if IntoOrbit then IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false elseif unit.getClosestPlanetInfluence()>0 then IntoOrbit=true;bg=true;if bx==nil then bx=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else Z="Unable to engage orbiting, not near planet"end else IntoOrbit=false;bs=false;bx=nil;bg=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bu.VectorToTarget=false;bu.AutopilotAlign=false;bv=false end end;local function cr()if bD-bl<1.5 then if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.spaceEngineMinAltitude-50 else if unit.getClosestPlanetInfluence()>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bw=HoldAltitude;bv=true;if not IntoOrbit then cq()end;bs=true end end;bl=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bl=bD end;if unit.getClosestPlanetInfluence()>0 and as==0 then bw=at;bv=true;bs=true;cq()if IntoOrbit then bl=bD else bl=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;X=false;bg=true;LockPitch=nil;by=false;if ao==-1 then AutoTakeoff=false;if bl>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=at end end;if VertTakeOff then cp()end else AutoTakeoff=true;if bl>-1 then HoldAltitude=at+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;r:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bO then cp()end end;if am then HoldAltitude=100000 end else if IntoOrbit then cq()end;if VertTakeOff then cp()end;bg=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bl=0 end end;local function cs()if l()==1 then X=not X;if X then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()r:setTargetGroundAltitude(TargetHoverHeight)else BrakeIsOn=true;bg=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end else Z="Follow Mode only works with Remote controller"X=false end end;local function ct()local function cu(SpaceTarget)VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cr()end end;VectorStatus="Proceeding to Waypoint"end;if bD-bm<1.5 and as>0 then if not bB then Z="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if as>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end;bm=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else bm=bD end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then bc.UpdateAutopilotTarget()bd.showWayPoint(a9,AutopilotTargetCoords)local cv=unit.getClosestPlanetInfluence()>0;if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then if as~=0 then am=true;cr()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if as>0 then if not VectorToTarget then cu(SpaceTarget)end else if not(a9.name==planet.name and cv)then by=false;Autopilot=true elseif not ar then if IntoOrbit then cq()end;bw=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bv=true;bu.AutopilotAlign=true;bu.VectorToTarget=true;bs=false;if not IntoOrbit then cq()end end end else RetrogradeIsOn=false;ProgradeIsOn=false;if as~=0 then am=true;cr()else Autopilot=true end end elseif as==0 then if CustomTarget==nil and(a9.name==planet.name and cv)and not IntoOrbit then WaypointSet=false;by=false;bs=false;cq()else Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;X=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;M=false;LockPitch=nil;WaypointSet=false end else am=true;cr()end else am=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;M=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=at;TargetSet=false;Reentry=false;if IntoOrbit then cq()end end end;local function cw(cx)local cy=-1;local cz;cy=bc.findAtlasIndex(SavedLocations)if cy~=-1 then local cA;if cx~=nil then cz={position=SavedLocations[cy].position,name=cx,atmosphere=SavedLocations[cy].atmosphere,planetname=SavedLocations[cy].planetname,gravity=SavedLocations[cy].gravity}else cz={position=bL,name=SavedLocations[cy].name,atmosphere=as,planetname=planet.name,gravity=unit.getClosestPlanetInfluence(),safe=true}end;SavedLocations[cy]=cz;cy=-1;cy=bc.findAtlasIndex(b2[0])if cy>-1 then b2[0][cy]=cz end;bc.UpdateAtlasLocationsList()Z=CustomTarget.name.." position updated"bc.UpdateAutopilotTarget()else Z="Name Not Found"end end;local function cB()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;bg=autoRollPreference end;if BrakeIsOn then AltitudeHold=false;VectorToTarget=false;AutoTakeoff=false;VertTakeOff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;AltitudeHold=false;if VertTakeOff then cp()end;if IntoOrbit then cq()end;LockPitch=nil;bg=autoRollPreference;al=false;an=false;ad=0 end end;local function cC(cD,cE,cF)local function cG(cD,cH)cD=vec3(cD)cH=vec3(cH):normalize()local cn=cD*cH;return cn.x+cn.y+cn.z end;local cI=0.001;local cJ=1;if not ar or not bi or ao~=-1 or bI<N then local cK=cF;if cK==nil then cK=DampingMultiplier end;if cE==nil then cE=cI end;cD=vec3(cD):normalize()local cL=vec3()-cD;local cM=-cG(cL,core.getConstructWorldOrientationRight())*cJ;local cN=-cG(cL,core.getConstructWorldOrientationUp())*cJ;if aD==0 then aD=cM/2 end;if aE==0 then aE=cN/2 end;if c(cM)<0.1 then S=S-cM*2 else S=S-(cM+(cM-aD)*cK)end;if c(cN)<0.1 then R=R+cN*2 else R=R+cN+(cN-aE)*cK end;aD=cM;aE=cN;if c(cM)<cE and c(cN)<cE then return true end;return false elseif bi and ao==-1 then cD=bH;local cK=cF;if cK==nil then cK=DampingMultiplier end;if cE==nil then cE=cI end;cD=vec3(cD):normalize()local cL=bF-cD;local cM=-cG(cL,core.getConstructWorldOrientationRight())*cJ;local cN=-cG(cL,core.getConstructWorldOrientationUp())*cJ;if aD==0 then aD=cM/2 end;if aE==0 then aE=cN/2 end;if c(cM)<0.1 then S=S-cM*5 else S=S-(cM+(cM-aD)*cK)end;if c(cN)<0.1 then R=R+cN*5 else R=R+cN+(cN-aE)*cK end;aD=cM;aE=cN;if c(cM)<cE and c(cN)<cE then return true end;return false end end;local function cO()if Reentry then Z="Re-Entry cancelled"Reentry=false;bg=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then Z="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not O then StrongBrakes=planet.gravity*9.80665*aw<LastMaxBrakeInAtmo;if not StrongBrakes then Z="WARNING: Insufficient Brakes for Parachute Re-Entry"else Reentry=true;if r:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;bg=true;BrakeIsOn=false;Z="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bn end else Reentry=true;AltitudeHold=true;bg=true;BrakeIsOn=false;HoldAltitude=planet.spaceEngineMinAltitude-50;local ca,cP=ck(HoldAltitude)Z="Beginning Re-entry.  Target speed: "..bn.." Target Altitude: "..ca..cP;cg(d(bn))end;AutoTakeoff=false end;local function cQ()if antigrav and not ExternalAGG then if bP then antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;antigrav.activate()antigrav.show()end end end;local function cR(cS)local cT=0;local cU=0;local cV=0;if cS<60 then cS=d(cS)elseif cS<3600 then cT=d(cS/60)cS=d(cS%60)elseif cS<86400 then cU=d(cS/3600)cT=d(cS%3600/60)else cV=d(cS/86400)cU=d(cS%86400/3600)end;if cV>0 then return cV.."d "..cU.."h "elseif cU>0 then return cU.."h "..cT.."m "elseif cT>0 then return cT.."m "..cS.."s"elseif cS>0 then return cS.."s"else return"0s"end end;local function cW(cX)local function cY(cZ)for c_,d0 in pairs(cZ)do dbHud_1.setStringValue(d0,g(_G[d0]))if cX and dbHud_2 then dbHud_2.setStringValue(d0,g(_G[d0]))end end end;if dbHud_1 then if not ac then cY(b)cY(c0())system.print("Saved Variables to Datacore")if cX and dbHud_2 then Z="Databank copied.  Remove copy when ready."end end end end;local function d1()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function d2()local function d3(d4)return type(d4)=='number'end;local function d5(d4)return type(tonumber(d4))=='number'end;local function d6(d7)return type(d7)=='table'end;local function d8(d9)return type(d9)=='string'end;local function da(d0)return d6(d0)and d3(d0.x and d0.y and d0.z)end;local function db(dc)return d6(dc)and d3(dc.latitude and dc.longitude and dc.altitude and dc.bodyId and dc.systemId)end;local dd=math.pi/180;local de=180/math.pi;local epsilon=1e-10;local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local df='::pos{'..y..','..y..','..y..','..y..','..y..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local dg=q;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*epsilon end;local function dh(d4)local cn=string.gsub(string.reverse(e('%.4f',d4)),'^0*%.?','')return cn==''and'0'or string.reverse(cn)end;local function di(dj)if da(dj)then return e('{x=%.3f,y=%.3f,z=%.3f}',dj.x,dj.y,dj.z)end;if d6(dj)and not getmetatable(dj)then local dk={}local dl=next(dj)if type(dl)=='nil'or dl==1 then dk=dj else for c_,d0 in pairs(dj)do local ce=di(d0)if type(c_)=='number'then table.insert(dk,e('[%s]=%s',c_,ce))else table.insert(dk,e('%s=%s',c_,ce))end end end;return e('{%s}',table.concat(dk,','))end;if d8(dj)then return e("'%s'",dj:gsub("'",[[\']]))end;return tostring(dj)end;local dm={}dm.__index=dm;dm.__tostring=function(dj,dn)local dp={}for c_ in pairs(dj)do table.insert(dp,c_)end;table.sort(dp)local dk={}for _,c_ in ipairs(dp)do local ce=di(dj[c_])if type(c_)=='number'then table.insert(dk,e('[%s]=%s',c_,ce))else table.insert(dk,e('%s=%s',c_,ce))end end;if dn then return e('%s%s',dn,table.concat(dk,',\n'..dn))end;return e('{%s}',table.concat(dk,','))end;dm.__eq=function(dq,dr)return dq.planetarySystemId==dr.planetarySystemId and dq.bodyId==dr.bodyId and ch(dq.radius,dr.radius)and ch(dq.center.x,dr.center.x)and ch(dq.center.y,dr.center.y)and ch(dq.center.z,dr.center.z)and ch(dq.GM,dr.GM)end;local function ds(dt,du,dv,dw,dx)assert(d5(dt),'Argument 1 (planetarySystemId) must be a number:'..type(dt))assert(d5(du),'Argument 2 (bodyId) must be a number:'..type(du))assert(d5(dv),'Argument 3 (radius) must be a number:'..type(dv))assert(d6(dw),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dw))assert(d5(dx),'Argument 5 (GM) must be a number:'..type(dx))return setmetatable({planetarySystemId=tonumber(dt),bodyId=tonumber(du),radius=tonumber(dv),center=vec3(dw),GM=tonumber(dx)},dm)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dy)return e('::pos{%d,%d,%s,%s,%s}',dy.systemId,dy.bodyId,dh(dy.latitude*de),dh(dy.longitude*de),dh(dy.altitude))end;MapPosition.__eq=function(dq,dr)return dq.bodyId==dr.bodyId and dq.systemId==dr.systemId and ch(dq.latitude,dr.latitude)and ch(dq.altitude,dr.altitude)and(ch(dq.longitude,dr.longitude)or ch(dq.latitude,math.pi/2)or ch(dq.latitude,-math.pi/2))end;local function dz(dA,du,dB,dC,dD)local dt=dA;if d8(dA)and not dC and not dD and not du and not dB then dt,du,dB,dC,dD=n(dA,df)assert(dt,'Argument 1 (position string) is malformed.')else assert(d5(dt),'Argument 1 (systemId) must be a number:'..type(dt))assert(d5(du),'Argument 2 (bodyId) must be a number:'..type(du))assert(d5(dB),'Argument 3 (latitude) must be in degrees:'..type(dB))assert(d5(dC),'Argument 4 (longitude) must be in degrees:'..type(dC))assert(d5(dD),'Argument 5 (altitude) must be in meters:'..type(dD))end;dt=tonumber(dt)du=tonumber(du)dB=tonumber(dB)dC=tonumber(dC)dD=tonumber(dD)if du==0 then return setmetatable({latitude=dB,longitude=dC,altitude=dD,bodyId=du,systemId=dt},MapPosition)end;return setmetatable({latitude=dd*dg(dB,-90,90),longitude=dd*(dC%360),altitude=dD,bodyId=du,systemId=dt},MapPosition)end;local dE={}dE.__index=dE;dE.__tostring=function(dj,dn)local dF=dn and dn..'  'local dG={}local dp={}for c_ in pairs(dj)do table.insert(dp,c_)end;table.sort(dp)for _,dH in ipairs(dp)do bdy=dj[dH]local dI=dm.__tostring(bdy,dF)if dn then table.insert(dG,e('[%s]={\n%s\n%s}',dH,dI,dn))else table.insert(dG,e('  [%s]=%s',dH,dI))end end;if dn then return e('\n%s%s%s',dn,table.concat(dG,',\n'..dn),dn)end;return e('{\n%s\n}',table.concat(dG,',\n'))end;local function dJ(dK)local b2={}local pid;for _,d0 in pairs(dK)do local dL=d0.planetarySystemId;if type(dL)~='number'then error('Invalid planetary system ID: '..tostring(dL))elseif pid and dL~=pid then error('Mistringmatch planetary system IDs: '..dL..' and '..pid)end;local dM=d0.bodyId;if type(dM)~='number'then error('Invalid body ID: '..tostring(dM))elseif b2[dM]then error('Duplicate body ID: '..tostring(dM))end;setmetatable(d0.center,getmetatable(vec3.unit_x))b2[dM]=setmetatable(d0,dm)pid=dL end;return setmetatable(b2,dE)end;b6={}local function dN(dK)return setmetatable({galaxyAtlas=dK or{}},b6)end;b6.__index=function(d7,i)if type(i)=='number'then local system=d7.galaxyAtlas[i]return dJ(system)end;return rawget(b6,i)end;b6.__pairs=function(dj)return function(d7,c_)local dO,nv=next(d7,c_)return dO,nv and dJ(nv)end,dj.galaxyAtlas,nil end;b6.__tostring=function(dj)local dP={}for _,dQ in pairs(dj or{})do local dR=dQ:getPlanetarySystemId()local dS=dE.__tostring(dQ,'    ')table.insert(dP,e('  [%s]={%s\n  }',dR,dS))end;return e('{\n%s\n}\n',table.concat(dP,',\n'))end;b6.BodyParameters=ds;b6.MapPosition=dz;b6.PlanetarySystem=dJ;function b6.createBodyParameters(dT,du,dU,dV,dW,dX,dY)assert(d5(dT),'Argument 1 (planetarySystemId) must be a number:'..type(dT))assert(d5(du),'Argument 2 (bodyId) must be a number:'..type(du))assert(d5(dU),'Argument 3 (surfaceArea) must be a number:'..type(dU))assert(d6(dV),'Argument 4 (aPosition) must be an array or vec3:'..type(dV))assert(d6(dW),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dW))assert(d5(dX),'Argument 6 (altitude) must be in meters:'..type(dX))assert(d5(dY),'Argument 7 (gravityAtPosition) must be number:'..type(dY))local dv=math.sqrt(dU/4/math.pi)local ah=dv+dX;local dZ=vec3(dV)+ah*vec3(dW)local dx=dY*ah*ah;return ds(dT,du,dv,dZ,dx)end;b6.isMapPosition=db;function b6:getPlanetarySystem(dA)if i==nil then i=0 end;if nv==nil then nv=0 end;local dT=dA;if db(dA)then dT=dA.systemId end;if type(dT)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dE then system=dJ(system)end;return system end end end;function dE:castIntersections(d_,cH,e0,e1)local e0=e0 or function(e2)return 1.05*e2.radius end;local e3={}if e1 then for _,i in ipairs(e1)do e3[i]=self[i]end else e1={}for c_,e2 in pairs(self)do table.insert(e1,c_)e3[c_]=e2 end end;local function e4(e5,e6)local e7=e3[e5].center-d_;local e8=e3[e6].center-d_;return e7:len()<e8:len()end;table.sort(e1,e4)local e9=cH:normalize()for i,dL in ipairs(e1)do local e2=e3[dL]local ea=e2.center-d_;local dv=e0(e2)local eb=ea:dot(e9)local ec=eb^2-(ea:len2()-dv^2)if ec>=0 then local ed=math.sqrt(ec)local ee=eb+ed;local ef=eb-ed;if ef>0 then return e2,ee,ef elseif ee>0 then return e2,ee,nil end end end;return nil,nil,nil end;function dE:closestBody(eg)assert(type(eg)=='table','Invalid coordinates.')local eh,e2;local ei=vec3(eg)for _,ej in pairs(self)do local ek=(ej.center-ei):len2()if(not e2 or ek<eh)and ej.name~="Space"then e2=ej;eh=ek end end;return e2 end;function dE:convertToBodyIdAndWorldCoordinates(dA)local el=dA;if d8(dA)then el=dz(dA)end;if el.bodyId==0 then return 0,vec3(el.latitude,el.longitude,el.altitude)end;local ej=self:getBodyParameters(el)if ej then return el.bodyId,ej:convertToWorldCoordinates(el)end end;function dE:getBodyParameters(dA)local du=dA;if db(dA)then du=dA.bodyId end;assert(d5(du),'Argument 1 (bodyId) must be a number:'..type(du))return self[du]end;function dE:getPlanetarySystemId()local _,d0=next(self)return d0 and d0.planetarySystemId end;function dm:convertToMapPosition(dw)assert(d6(dw),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dw))local em=vec3(dw)if self.bodyId==0 then return setmetatable({latitude=em.x,longitude=em.y,altitude=em.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local en=em-self.center;local ah=en:len()local dD=ah-self.radius;local dB=0;local dC=0;if not ch(ah,0)then local eo=m(en.y,en.x)dC=eo>=0 and eo or 2*math.pi+eo;dB=math.pi/2-math.acos(en.z/ah)end;return setmetatable({latitude=dB,longitude=dC,altitude=dD,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dm:convertToWorldCoordinates(dA)local el=d8(dA)and dz(dA)or dA;if el.bodyId==0 then return vec3(el.latitude,el.longitude,el.altitude)end;assert(db(el),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(el.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(el.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local ep=math.cos(el.latitude)return self.center+(self.radius+el.altitude)*vec3(ep*math.cos(el.longitude),ep*math.sin(el.longitude),math.sin(el.latitude))end;function dm:getAltitude(dw)return(vec3(dw)-self.center):len()-self.radius end;function dm:getDistance(dw)return(vec3(dw)-self.center):len()end;function dm:getGravity(dw)local eq=self.center-vec3(dw)local er=eq:len2()return self.GM/er*eq/math.sqrt(er)end;return setmetatable(b6,{__call=function(_,...)return dN(...)end})end;local function es()local b8={}local et=30000000/3600;local eu=et*et;local ev=100;local function ew(d0)return 1/math.sqrt(1-d0*d0/eu)end;function b8.computeAccelerationTime(ex,ey,ez)local eA=et*math.asin(ex/et)return(et*math.asin(ez/et)-eA)/ey end;function b8.computeDistanceAndTime(ex,ez,eB,eC,eD,eE)eD=eD or 0;eE=eE or 0;local eF=ex<=ez;local eG=eC*(eF and 1 or-1)/eB;local eH=-eE/eB;local eI=eG+eH;if eF and eI<=0 or not eF and eI>=0 then return-1,-1 end;local eJ,eK=0,0;if eG~=0 and eD>0 then local eA=math.asin(ex/et)local eL=math.pi*(eG/2+eH)local eM=eG*eD;local eN=et*math.pi;local d0=function(d7)local eO=(eL*d7-eM*math.sin(math.pi*d7/2/eD)+eN*eA)/eN;local eP=math.tan(eO)return et*eP/math.sqrt(eP*eP+1)end;local eQ=eF and function(d9)return d9>=ez end or function(d9)return d9<=ez end;eK=2*eD;if eQ(d0(eK))then local eR=0;while c(eK-eR)>0.5 do local d7=(eK+eR)/2;if eQ(d0(d7))then eK=d7 else eR=d7 end end end;local eS=ex;local eT=eK/ev;for eU=1,ev do local eV=d0(eU*eT)eJ=eJ+(eV+eS)*eT/2;eS=eV end;if eK<2*eD then return eJ,eK end;ex=eS end;local eA=et*math.asin(ex/et)local bD=(et*math.asin(ez/et)-eA)/eI;local eW=eu*math.cos(eA/et)/eI;local ah=eW-eu*math.cos((eI*bD+eA)/et)/eI;return ah+eJ,bD+eK end;function b8.computeTravelTime(ex,ey,ah)if ah==0 then return 0 end;if ey>0 then local eA=et*math.asin(ex/et)local eW=eu*math.cos(eA/et)/ey;return(et*math.acos(ey*(eW-ah)/eu)-eA)/ey end;if ex==0 then return-1 end;assert(ex>0,'Acceleration and initial speed are both zero.')return ah/ex end;function b8.lorentz(d0)return ew(d0)end;return b8 end;local function eX()local vec3=require('cpml.vec3')local d2=d2()local function d8(d9)return type(d9)=='string'end;local function d6(d7)return type(d7)=='table'end;local function ch(ci,cj)if ci==0 then return c(cj)<1e-09 end;if cj==0 then return c(ci)<1e-09 end;return c(ci-cj)<math.max(c(ci),c(cj))*constants.epsilon end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dD)assert(self.body)local ah=dD+self.body.radius;if not ch(ah,0)then local orbit=math.sqrt(self.body.GM/ah)return math.sqrt(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dA,eY)assert(self.body)assert(d6(dA)or d8(dA))assert(d6(eY))local eZ=(d8(dA)or d2.isMapPosition(dA))and self.body:convertToWorldCoordinates(dA)or vec3(dA)local d0=vec3(eY)local e_=eZ-self.body.center;local e8=d0:len2()local f0=e_:len()local f1=self.body.GM;local f2=((e8-f1/f0)*e_-e_:dot(d0)*d0)/f1;local ci=f1/(2*f1/f0-e8)local f3=f2:len()local e9=f2:normalize()local f4=ci*(1-f3)local f5=ci*(1+f3)local f6=f4*e9+self.body.center;local f7=f3<=1 and-f5*e9+self.body.center or nil;local f8=math.sqrt(ci*f1*(1-f3*f3))local f9=f7 and 2*math.pi*math.sqrt(ci^3/f1)local fa=math.acos(f2:dot(e_)/(f3*f0))if e_:dot(d0)<0 then fa=-(fa-2*math.pi)end;local fb=math.acos((math.cos(fa)+f3)/(1+f3*math.cos(fa)))local fc=fb;if fc<0 then fc=fc+2*math.pi end;local fd=fc-f3*math.sin(fc)local fe=0;local ff=0;local fg=0;if f9~=nil then fe=fd/(2*math.pi/f9)ff=f9-fe;fg=ff+f9/2;if fa-math.pi>0 then ff=fe;fg=ff+f9/2 end;if fg>f9 then fg=fg-f9 end end;return{periapsis={position=f6,speed=f8/f4,circularOrbitSpeed=math.sqrt(f1/f4),altitude=f4-self.body.radius},apoapsis=f7 and{position=f7,speed=f8/f5,circularOrbitSpeed=math.sqrt(f1/f5),altitude=f5-self.body.radius},currentVelocity=d0,currentPosition=eZ,eccentricity=f3,period=f9,eccentricAnomaly=fb,meanAnomaly=fd,timeToPeriapsis=ff,timeToApoapsis=fg}end;local function fh(fi)local ej=d2.BodyParameters(fi.planetarySystemId,fi.bodyId,fi.radius,fi.center,fi.GM)return setmetatable({body=ej},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return fh(...)end})end;local function fj()local fk=false;local fl=0;local function fm(fn)local dv=500000;local fo,fp,fq=math.huge;local fr=false;local fs=vec3({13771471,7435803,-128971})local ft=18000000;fo=vec3(fn):dist(fs)if fo<ft then return true,c(fo-ft),"Safe Zone",0 end;fp=vec3(fn):dist(vec3(planet.center))if fp<dv then fr=true end;if c(fp-dv)<c(fo-ft)then return fr,c(fp-dv),planet.name,planet.bodyId else return fr,c(fo-ft),"Safe Zone",0 end end;local function fu(d0)if aK==1920 then return d0 else return x(aK*d0/1920,0)end end;local function fv(d0)if aL==1080 then return d0 else return x(aL*d0/1080,0)end end;local function fw()return w()==0 and userControlScheme~="keyboard"and l()==0 end;local function fx()local fy="TRAVEL"if not bR then fy="CRUISE"end;if Autopilot then fy="AUTOPILOT"end;return fy end;local function fz(fA,b0,c8,fB,fC,fD,fE,fF)local fG=1;local fH=2;local fI=3;local fJ=4;local fK=5;local fL=6;local fM=""local fN=0;local fO=fuelY;local fP=fuelY+10;if l()==1 and not RemoteHud then fO=fO-50;fP=fP-50 end;if fC=="ATMO"then fM="atmofueltank"elseif fC=="SPACE"then fM="spacefueltank"else fM="rocketfueltank"end;fN=_G[fM.."_size"]if#fD>0 then for i=1,#fD do local fQ=string.sub(fD[i][fH],1,12)local fR=0;for fS=1,fN do if fD[i][fH]==f(unit[fM.."_"..fS].getData()).name then fR=fS;break end end;if b0 or fE[i]==nil or fF[i]==nil then local fT=0;local fU=0;local fV=0;local fW=0;local fX=p()if fR~=0 then fF[i]=f(unit[fM.."_"..fR].getData()).percentage;fE[i]=f(unit[fM.."_"..fR].getData()).timeLeft;if fE[i]=="n/a"then fE[i]=0 end else fV=k(fD[i][fG])-fD[i][fJ]fT=fD[i][fI]fF[i]=d(0.5+fV*100/fT)fU=fD[i][fK]fW=fD[i][fL]if fU<=fV then fE[i]=0 else fE[i]=d(0.5+fV/((fU-fV)/(fX-fW)))end;fD[i][fK]=fV;fD[i][fL]=fX end end;if fQ==fB then fQ=e("%s %d",fC,i)end;if fR==0 then fQ=fQ.." *"end;local fY;if fE[i]==0 then fY="n/a"else fY=cR(fE[i])end;if fF[i]~=nil then local fZ=d(fF[i]*2.55)local f_=e("rgb(%d,%d,%d)",255-fZ,fZ,0)local cb=""if fY~="n/a"and fE[i]<120 or fF[i]<5 then if b0 then cb=[[class="red"]]end end;fA[#fA+1]=c7(c8,fO,fQ,cb.." pdim txtfuel")fA[#fA+1]=c7(c8,fP,e("%d%% %s",fF[i],fY),"pdim txtfuel","fill:"..f_)fO=fO+30;fP=fP+30 end end end end;local function g0(fA,dD)if dD<200000 and not ar or dD and ar then local g1=0;if c(bK)>1 then g1=45*math.log(c(bK),10)if bK<0 then g1=-g1 end end;fA[#fA+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="31" y="-41">1000</text>
                                        <text x="-10" y="-65">100</text>
                                        <text x="-54" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-56" y="52">-10</text>
                                        <text x="-14" y="72">-100</text>
                                        <text x="29" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bK),d(g1))end;return fA end;local function g2(g3)local g4=-bJ;g3=g3-g3:project_on(g4)local g5=vec3(0,0,1)g5=g5-g5:project_on(g4)local g6=g5:cross(g4)local g1=g5:angle_between(g3)*constants.rad2deg;if g3:dot(g6)<0 then g1=360-g1 end;return g1 end;local function g7(fA,centerX,centerY,g8,g9,cv)local ga=circleRad;local gb=20;local gc=d(g8)if cv then for i=-45,45,5 do local gd=i;fA[#fA+1]=e([[<g transform="rotate(%f,%d,%d)">]],gd,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;fA[#fA+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+ga+gb-len,centerX,centerY+ga+gb)end;fA[#fA+1]=c7(centerX,centerY+ga+gb-35,g9,"pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY+ga+gb-25,gc.." deg","pdim txt txtmid")fA[#fA+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g8,centerX,centerY)fA[#fA+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+ga+gb-20,centerX+5,centerY+ga+gb-20,centerX,centerY+ga+gb-15)fA[#fA+1]="</g>"end;local ge=gc;if cv then ge=g2(bF)end;local gf=20;local gg=d(ge)local gh=0;local gi=centerY+ga+gb+20;local gj=centerX;if g9~="YAW"then gi=fv(130)gj=fu(960)end;local gk=[[<path class="txttick line" d="]]local gl=d(gg-(gf+10)-gg%5+0.5)for i=gl+60,gl,-5 do local c8=gj-(-i*5+ge*5)if i%10==0 then gh=10;local y=i;if y==360 then y=0 elseif y>360 then y=y-360 elseif y<0 then y=y+360 end;fA[#fA+1]=c7(c8+5,gi-12,y)elseif i%5==0 then gh=5 end;if gh==10 then gk=e([[%s M %f %f v %d]],gk,c8,gi-5,gh)else gk=e([[%s M %f %f v %d]],gk,c8,gi-2.5,gh)end end;fA[#fA+1]=gk..[["/>]]fA[#fA+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],gj-5,gi+10,gj+5,gi+10,gj,gi+5)if cv then g9="HDG"end;fA[#fA+1]=c7(gj,gi+25,gg.."deg","pdim txt txtmid","")fA[#fA+1]=c7(gj,gi+35,g9,"pdim txt txtmid","")end;local function gm(fA,gn,g8,centerX,centerY,cv,go,eV)local ga=circleRad;local gp=d(ga*3/5)if ga>0 then local gq=d(gn)local len=0;local gk=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*g8,centerX,centerY)if not ar then gk=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;fA[#fA+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],ga-1,centerX,centerY)fA[#fA+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(gq-30-gq%5+0.5),d(gq+30+gq%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local c9=centerY+-i*5+gn*5;if len==30 then gk=e([[%s M %d %f h %d]],gk,centerX-gp-len,c9,len)if ar then fA[#fA+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g8,centerX,centerY,centerX-gp+10,c9,i)fA[#fA+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*g8,centerX,centerY,centerX+gp-10,c9,i)if i==0 or i==180 or i==-180 then fA[#fA+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g8,centerX,centerY,centerX-gp+20,c9,gp*2-40)end else fA[#fA+1]=c7(centerX-gp+10,c9,i,"pdim txt txtmid")fA[#fA+1]=c7(centerX+gp-10,c9,i,"pdim txt txtmid")end;gk=e([[%s M %d %f h %d]],gk,centerX+gp,c9,len)else gk=e([[%s M %d %f h %d]],gk,centerX-gp-len,c9,len)gk=e([[%s M %d %f h %d]],gk,centerX+gp,c9,len)end end;fA[#fA+1]=gk..[["/>]]local gr="PITCH"if not cv then gr="REL PITCH"end;if gn>90 and not ar then gn=90-(gn-90)elseif gn<-90 and not ar then gn=-90-(gn+90)end;if ga>200 then if ar then if eV>N then fA[#fA+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY+20,go,"pdim txt txtmid")end;fA[#fA+1]=e([[<g transform="rotate(%f,%d,%d)">]],-g8,centerX,centerY)else fA[#fA+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;fA[#fA+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-gp+25,centerY-5,centerX-gp+20,centerY,centerX-gp+25,centerY+5,centerX-gp+50,centerY+4,gq)fA[#fA+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+gp-25,centerY-5,centerX+gp-20,centerY,centerX+gp-25,centerY+5,centerX+gp-30,centerY+4,gq)fA[#fA+1]="</g>"end;local gs=d(ga/3)fA[#fA+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-gs,centerY,ga-gs)if not ar and cv then fA[#fA+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*g8,centerX,centerY,centerX-gp+10,centerY,gp*2-20)end;fA[#fA+1]="</g>"if ga<200 then if ar and eV>N then fA[#fA+1]=c7(centerX,centerY-ga,gr,"pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY-ga+10,gq,"pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY-15,"Yaw","pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY+20,go,"pdim txt txtmid")else fA[#fA+1]=c7(centerX,centerY-ga,gr,"pdim txt txtmid")fA[#fA+1]=c7(centerX,centerY-ga+15,gq,"pdim txt txtmid")end end end end;local function gt(fA,dD,cv)local gu=altMeterX;local gv=altMeterY;local gw=78;local gx=19;local gy=ao;if ao~=-1 then fA[#fA+1]=c7(gu+gw,gv+gx+20,e("AGL: %.1fm",ao),"pdim altsm txtend")end;if cv and(dD<200000 and not ar or dD and ar)then table.insert(fA,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],gu-1,gv-4,gw+2,gx+6,gu+1,gv-1,gw-4,gx))local cy=0;local gz=1;local gA=0;local gB=dD<0;local gC=9;if gB then gC=0 end;local dD=c(dD)while cy<6 do local gD=11;local gE=16;local gF=9;local gG=14;local cb="altsm"if cy>2 then gE=gE+3;gD=gD+2;gG=gG+2;gF=gF-6;cb="altbig"end;if gB then cb=cb.." red"end;local gH=dD/gz%10;local gI=d(gH)local gJ=d((gI+1)%10)local gK=gA;if cy==0 then gK=gH-gI;if gB then gK=1-gK end end;if gB and(cy==0 or gA~=0)then local gL=gJ;gJ=gI;gI=gL end;local gM=gE*(gK-1)local gN=gM+gE;local c8=gu+gF+(6-cy)*gD;local c9=gv+gG;fA[#fA+1]=c7(c8,c9+gM,gJ,cb)fA[#fA+1]=c7(c8,c9+gN,gI,cb)cy=cy+1;gz=gz*10;if gI==gC then gA=gK else gA=0 end end;table.insert(fA,[[</g></g>]])end end;local function gO(eY)eY=vec3(eY)local gP=-math.deg(m(eY.y,eY.z))+180;gP=gP-90;if gP<0 then gP=360+gP end;if gP>180 then gP=-180+gP-180 end;return-gP end;local function gQ(eY)eY=vec3(eY)local ge=math.deg(m(eY.y,eY.x))-90;if ge<-180 then ge=360+ge end;return ge end;local function gR(fA,eY,eV,centerX,centerY)if eV>5 and not ar or eV>N then local ga=circleRad;local gS=20;local gT=20;local gU=vec3(eY)local gV=gO(gU)local gW=gQ(gU)local gX=14;local gY=gX/2;local gZ=-gW/gT*ga;local g_=gV/gS*ga;local c8=centerX+gZ;local c9=centerY+g_;local ah=math.sqrt(gZ^2+g_^2)local h0=[[<circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..gY/gX..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..c8 ..[["
                            cy="]]..c9 ..[["
                            r="]]..gY..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..c8-gX..[[,]]..c9 ..[[ h ]]..gY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8+gY..[[,]]..c9 ..[[ h ]]..gY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..c8 ..[[,]]..c9-gX..[[ v ]]..gY..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<ga then fA[#fA+1]=h0 else local g1=m(g_,gZ)local h1=4;local h2=centerX+ga*math.cos(g1)local h3=centerY+ga*math.sin(g1)fA[#fA+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',g1*180/math.pi,h2,h3,h2-h1,h3-h1/2,h1*2,h1,h2+h1,h3-h1,h1,h1,-h1,h1)end;if not ar then gV=gO(-gU)gW=gQ(-gU)gZ=-gW/gT*ga;g_=gV/gS*ga;c8=centerX+gZ;c9=centerY+g_;ah=math.sqrt(gZ^2+g_^2)if ah<ga then local h4=[[<circle
                                    cx="]]..c8 ..[["
                                    cy="]]..c9 ..[["
                                    r="]]..gY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..c8 ..[[,]]..c9-gX..[[ v ]]..gY..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..c8 ..[[,]]..c9 ..[[)" />
                                <path
                                    d="M ]]..c8-gY..[[,]]..c9 ..[[ h ]]..gX..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..c8 ..[[,]]..c9 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..c8 ..[[,]]..c9 ..[[)"/>]]fA[#fA+1]=h4 end end end end;local function h5(fA,fy,h6,h7)h6=d(h6+0.5)local fO=throtPosY+10;local fP=throtPosY+20;if l()==1 and not RemoteHud then fO=55;fP=65 end;local h8="CRUISE"local unit="km/h"local ce=h7;if fy=="TRAVEL"or fy=="AUTOPILOT"then h8="THROT"unit="%"ce=h6;local h9="dim"if h6<0 then h9="red"end;fA[#fA+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],h9,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(h6),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;fA[#fA+1]=c7(throtPosX+10,fO,h8,"pbright txtstart")fA[#fA+1]=c7(throtPosX+10,fP,e("%.0f %s",ce,unit),"pbright txtstart")if ar and AtmoSpeedAssist and bR and H then h6=d(I*100+0.5)local h9="red"if h6<0 then h9="red"end;fA[#fA+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],h9,1-c(h6),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)fA[#fA+1]=c7(throtPosX+10,fO+40,"LIMIT","pbright txtstart")fA[#fA+1]=c7(throtPosX+10,fP+40,h6 .."%","pbright txtstart")end;if ar and AtmoSpeedAssist or Reentry then fA[#fA+1]=c7(throtPosX+10,fO-40,"LIMIT: "..bn.." km/h","dim txtstart")elseif not ar and Autopilot then fA[#fA+1]=c7(throtPosX+10,fO-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function ha(fA,hb)local hc=throtPosY-10;local hd=throtPosX+10;fA[#fA+1]=c7(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then hc=75 end;fA[#fA+1]=c7(hd,hc,d(hb).." km/h","pbright txtbig txtstart")end;local function he(fA)fA[#fA+1]=c7(fu(1900),fv(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")fA[#fA+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then fA[#fA+1]=c7(fu(960),fv(550),"Warning: Invalid Control Scheme Detected","warnings")fA[#fA+1]=c7(fu(960),fv(600),"Keyboard Scheme must be selected","warnings")fA[#fA+1]=c7(fu(960),fv(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local hf=fu(960)local hg=fv(860)local hh=fv(880)local hi=fv(900)local hj=fv(960)local hk=fv(200)local hl=fv(250)local hm=fv(960)if l()==1 and not RemoteHud then hg=fv(135)hh=fv(155)hi=fv(175)hk=fv(115)hl=fv(95)end;if BrakeIsOn then fA[#fA+1]=c7(hf,hg,"Brake Engaged","warnings")elseif G>0 then fA[#fA+1]=c7(hf,hg,"Auto-Brake Engaged","warnings","opacity:"..G)end;if ar and bi and ao==-1 then fA[#fA+1]=c7(hf,hk+50,"** STALL WARNING **","warnings")end;if ay then fA[#fA+1]=c7(hf,hm,"Gyro Enabled","warnings")end;if GearExtended then if P then fA[#fA+1]=c7(hf,hh,"Gear Extended","warn")else fA[#fA+1]=c7(hf,hh,"Landed (G: Takeoff)","warnings")end;local hn,co=ck(a:getTargetGroundAltitude())fA[#fA+1]=c7(hf,hi,"Hover Height: "..hn..co,"warn")end;if a4 then fA[#fA+1]=c7(hf,hj+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bP and AntigravTargetAltitude~=nil then if c(at-antigrav.getBaseAltitude())<501 then fA[#fA+1]=c7(hf,hk+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else fA[#fA+1]=c7(hf,hk+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then fA[#fA+1]=c7(hf,hk+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then fA[#fA+1]=c7(hf,hk+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif X then fA[#fA+1]=c7(hf,hk+20,"Follow Mode Engaged","warn")elseif Reentry then fA[#fA+1]=c7(hf,hk+20,"Re-entry in Progress","warn")end;local ho,ee,ef=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(e2)if e2.noAtmosphericDensityAltitude>0 then return e2.radius+e2.noAtmosphericDensityAltitude else return e2.radius+e2.surfaceMaxAltitude*1.5 end end)local hp=ee;if ef~=nil and ee~=nil then hp=math.min(ef,ee)end;if AltitudeHold or VertTakeOff then local hn,co=ck(HoldAltitude,2)if VertTakeOff then if bP then hn,co=ck(antigrav.getBaseAltitude(),2)end;fA[#fA+1]=c7(hf,hk,"AGG VTO to "..hn..co,"warn")elseif AutoTakeoff and not IntoOrbit then if am then fA[#fA+1]=c7(hf,hk,"Takeoff to "..AutopilotTargetName,"warn")else fA[#fA+1]=c7(hf,hk,"Takeoff to "..hn..co,"warn")end;if BrakeIsOn and not VertTakeOff then fA[#fA+1]=c7(hf,hk+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else fA[#fA+1]=c7(hf,hk,"Altitude Hold: "..hn..co,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if as>0.1 then fA[#fA+1]=c7(hf,hk+20,"Beginning ascent","warn")elseif as<0.09 and as>0.05 then fA[#fA+1]=c7(hf,hk+20,"Aligning trajectory","warn")elseif as<0.05 then fA[#fA+1]=c7(hf,hk+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bp~=nil then fA[#fA+1]=c7(hf,hk,bp,"warn")end end;if IntruderAlertSystem and safeMass==-1 then fA[#fA+1]=c7(hf,hk+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bN.."kg DETECTED","warnings")end;if BrakeLanding then if StrongBrakes then fA[#fA+1]=c7(hf,hk,"Brake-Landing","warnings")else fA[#fA+1]=c7(hf,hk,"Coast-Landing","warnings")end end;if ProgradeIsOn then fA[#fA+1]=c7(hf,hk,"Prograde Alignment","crit")end;if RetrogradeIsOn then fA[#fA+1]=c7(hf,hk,"Retrograde Alignment","crit")end;if hp~=nil and as==0 then local hn,co=ck(hp)local travelTime=b8.computeTravelTime(bI,0,hp)local hq="Collision"if ho.noAtmosphericDensityAltitude>0 then hq="Atmosphere"end;fA[#fA+1]=c7(hf,hl+20,ho.name.." "..hq.." "..cR(travelTime).." In "..hn..co,"crit")end;if VectorToTarget and not IntoOrbit then fA[#fA+1]=c7(hf,hk+35,VectorStatus,"warn")end;fA[#fA+1]="</g>"return fA end;local function hr(eV)return d(x(eV*3.6,0)+0.5).." km/h"end;local function hs(fA)local ht=OrbitMapX;local hu=OrbitMapY;local hv=OrbitMapSize;local hw=4;local hx=15;local c8=0;local c9=0;local hy,hz,hA,hB;local function hC(type)local hD,bD,eV,hE;if type=="Periapsis"then hD=orbit.periapsis.altitude;bD=orbit.timeToPeriapsis;eV=orbit.periapsis.speed;hE=35 else hD=orbit.apoapsis.altitude;bD=orbit.timeToApoapsis;eV=orbit.apoapsis.speed;hE=-35 end;fA[#fA+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],c8+hE,c9-5,ht+hv/2-hy+hB,c9-5)fA[#fA+1]=c7(c8,c9,type)c9=c9+hx;local hn,co=ck(hD)fA[#fA+1]=c7(c8,c9,hn..co)c9=c9+hx;fA[#fA+1]=c7(c8,c9,cR(bD))c9=c9+hx;fA[#fA+1]=c7(c8,c9,hr(eV))end;if orbit~=nil and as<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then hu=hu+hw;c8=ht+hv+ht/2+hw;c9=hu+hv/2+5+hw;hy=hv/4;hB=0;fA[#fA+1]=[[<g class="pbright txtorb txtmid">]]fA[#fA+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',hv+ht*2,hv+hu,hw,hw)if orbit.periapsis~=nil and orbit.apoapsis~=nil then hA=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(hy*2)hz=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/hA*(1-orbit.eccentricity)hB=hy-orbit.periapsis.altitude/hA-planet.radius/hA;local hF=""if orbit.periapsis.altitude<=0 then hF='redout'end;fA[#fA+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],hF,ht+hv/2+hB+hw,hu+hv/2+hw,hy,hz)fA[#fA+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ht+hv/2+hw,hu+hv/2+hw,planet.radius/hA)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then hC("Apoapsis")end;c9=hu+hv/2+5+hw;c8=ht-ht/2+10+hw;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then hC("Periapsis")end;fA[#fA+1]=c7(ht+hv/2+hw,planet.name,20+hw,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local hG=orbit.timeToApoapsis/orbit.period*2*math.pi;local hH=hy*math.cos(hG)local hI=hz*math.sin(hG)fA[#fA+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ht+hv/2+hH+hB+hw,hu+hv/2+hI+hw)end;fA[#fA+1]=[[</g>]]return fA else return fA end end;local function hJ()if radarPanelID~=nil and ak==0 then s(radarPanelID)radarPanelID=nil;if perisPanelID~=nil then s(perisPanelID)perisPanelID=nil end else if ak==1 then s(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")perisPanelID=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;ak=0 end end;local function hK(fA)local c8=50;local c9=525;local hL={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local hM={"Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to +1k over atmosphere and orbit to target","Alt-5: Lock Pitch at current pitch","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-9: Activate Gyroscope"}local hN={"Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at 1k over atmosphere","Alt-9: Activate Gyroscope"}local hO={"CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ar then bY(hL,hM)table.insert(hL,"---------------------------------------")if VertTakeOff then table.insert(hL,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if ao~=-1 then if antigrav then if bP then table.insert(hL,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(hL,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(hL,"Alt-6: Begins Vertical Takeoff.")else table.insert(hL,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(hL,"G: Begin BrakeLanding or Land")end else bY(hL,hN)end;if AltitudeHold then table.insert(hL,"Alt-Spacebar/Alt-C will raise/lower target height")end;table.insert(hL,"---------------------------------------")bY(hL,hO)for i=1,#hL do c9=c9+12;fA[#fA+1]=c7(c8,c9,hL[i],"pdim txttick txtstart")end end;local hP={}function hP.HUDPrologue(fA)if not fk then C=PvPR;E=PvPG;D=PvPB else C=SafeR;E=SafeG;D=SafeB end;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]local hQ=aA;local hR=aB;local hS=aA;local hT=aB;if fw()and not brightHud then hQ=[[rgb(]]..d(C*0.4+0.5)..","..d(E*0.4+0.5)..","..d(D*0.3+0.5)..[[)]]hR=[[rgb(]]..d(C*0.3+0.5)..","..d(E*0.3+0.5)..","..d(D*0.2+0.5)..[[)]]end;fA[#fA+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],hQ,hQ,hS,hS,hR,hR,hT,hT,aK,aL)return fA end;function hP.DrawVerticalSpeed(fA,dD)g0(fA,dD)end;function hP.UpdateHud(fA)local dD=at;local eY=core.getVelocity()local eV=vec3(eY):len()local gP=bS;local hU=bT;local g8=hU;local gn=bS;local h6=d(unit.getThrottle())local hb=eV*3.6;local h7=unit.getAxisCommandValue(0)local hV=fu(1770)local hW=fv(310)if AtmoSpeedAssist and bR then h7=F;h6=F*100 end;local fy=fx()local g9="ROLL"local cv=unit.getClosestPlanetInfluence()>0;if h6==nil then h6=0 end;if not cv then if eV>5 then gP=gO(eY)hU=gQ(eY)else gP=0;hU=0 end;g9="YAW"end;if not ar then fk,fl,_,_=fm(bL)else fk=true end;if fl>50000 and not ar then local hX;if fl>200000 then hX=x(fl/200000,2).." su"else hX=x(fl/1000,1).." km"end;fA[#fA+1]=c7(hV,hW,"PvP Boundary: "..hX,"pbright txtbig txtmid")end;fA[#fA+1]=aj;fA[#fA+1]=aF;fA[#fA+1]=ai;if b1%aW==0 then b0=true end;if fuelX~=0 and fuelY~=0 then fz(fA,b0,fuelX,"Atmospheric ","ATMO",aP,aZ,a_)fz(fA,b0,fuelX+100,"Space fuel t","SPACE",aQ,aX,aY)fz(fA,b0,fuelX+200,"Rocket fuel ","ROCKET",aR,aU,aV)end;if b0 then b0=false;b1=0 end;b1=b1+1;g0(fA,dD)if l()==0 or RemoteHud then if not fw()or brightHud then if cv then g7(fA,centerX,centerY,g8,g9,cv)gm(fA,gn,g8,centerX,centerY,cv,d(gQ(eY)),eV)else g7(fA,centerX,centerY,hU,g9,cv)gm(fA,gP,hU,centerX,centerY,cv,d(hU),eV)end;gt(fA,dD,cv)gR(fA,eY,eV,centerX,centerY)end end;h5(fA,fy,h6,h7)ha(fA,hb)he(fA)hs(fA)if showHelp then hK(fA)end;return fA end;function hP.HUDEpilogue(fA)fA[#fA+1]="</svg>"return fA end;function hP.ExtraData(fA)local hY=fu(1240)local hZ=fv(55)local h_=hZ+10;local i0;local i1=0;local fy=fx()if VertTakeOffEngine then fy=fy.."-VERTICAL"end;if TurnBurn then fy="TB-"..fy end;local i2=vec3(core.getWorldAcceleration()):len()/9.80665;i0=core.g()fA[#fA+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then hY=fu(1120)hZ=fv(55)h_=hZ+10 elseif ar then local i3=fu(770)fA[#fA+1]=c7(i3,hZ,"ATMOSPHERE","pdim txt txtend")fA[#fA+1]=c7(i3,h_,e("%.2f",as),"pdim txt txtend","")end;fA[#fA+1]=c7(hY,hZ,"GRAVITY","pdim txt txtend")fA[#fA+1]=c7(hY,h_,e("%.2f",i0/9.80665),"pdim txt txtend")fA[#fA+1]=c7(hY,hZ+20,"ACCEL","pdim txt txtend")fA[#fA+1]=c7(hY,h_+20,e("%.2f",i2),"pdim txt txtend")fA[#fA+1]=c7(fu(960),fv(180),fy,"txtbig txtmid")end;function hP.DrawOdometer(fA,aa,TotalDistanceTravelled,ab)local i0;local i4=0;local i5=0;local i1=0;if ar then i1=LastMaxBrakeInAtmo else i1=LastMaxBrake end;maxThrust=a:maxForceForward()i0=core.g()if i0>0.1 then i5=aw*i0;i4=maxThrust/i0 end;fA[#fA+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],fu(660),fu(700),fv(35),fu(960),fv(55),fu(1240),fv(35),fu(1280))if l()==0 or RemoteHud then fA[#fA+1]=c7(fu(700),fv(20),e("Trip: %.2f km",aa),"txtstart")fA[#fA+1]=c7(fu(700),fv(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")fA[#fA+1]=c7(fu(830),fv(20),"Trip Time: "..cR(ab),"txtstart")fA[#fA+1]=c7(fu(830),fv(30),"Total Time: "..cR(TotalFlightTime),"txtstart")fA[#fA+1]=c7(fu(970),fv(20),e("Mass: %.2f Tons",aw/1000),"txtstart")fA[#fA+1]=c7(fu(1240),fv(10),e("Max Brake: %.2f kN",i1/1000),"txtend")fA[#fA+1]=c7(fu(1240),fv(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if i0>0.1 then fA[#fA+1]=c7(fu(970),fv(30),e("Max Mass: %.2f Tons",i4/1000),"txtstart")fA[#fA+1]=c7(fu(1240),fv(20),e("Req Thrust: %.2f kN",i5/1000),"txtend")else fA[#fA+1]=c7(fu(970),fv(30),"Max Mass: n/a","txtstart")fA[#fA+1]=c7(fu(1240),fv(20),"Req Thrust: n/a","txtend")end end;fA[#fA+1]="</g>"return fA end;function hP.DrawWarnings(fA)return he(fA)end;function hP.DisplayOrbitScreen(fA)return hs(fA)end;function hP.DisplayMessage(fA,hn)if hn~="empty"then local c9=310;for i6 in string.gmatch(hn,"([^\n]+)")do c9=c9+35;fA[#fA+1]=c7("50%",c9,i6,"msg")end end;if ag~=0 then unit.setTimer("msgTick",ag)ag=0 end end;function hP.DrawDeadZone(fA)fA[#fA+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function hP.UpdateRadar()if radar_1 then local i7=radar_1.getEntries()local i8=radar_1.getData()local i9=fu(1770)local ia=fv(330)if#i7>0 then local ib=i8:find('identifiedConstructs":%[%]')if ib==nil and perisPanelID==nil then ak=1;hJ()end;if ib~=nil and perisPanelID~=nil then hJ()end;if radarPanelID==nil then hJ()end;ai=c7(i9,ia,"Radar: "..#i7 .." contacts","pbright txtbig txtmid")local ic={}for c_,d0 in pairs(i7)do if radar_1.hasMatchingTransponder(d0)==1 then table.insert(ic,d0)end end;if#ic>0 then local c9=fv(15)local c8=fu(1370)ai=ai..c7(c8,c9,"Friendlies In Range","pbright txtbig txtmid")for c_,d0 in pairs(ic)do c9=c9+20;ai=ai..c7(c8,c9,radar_1.getConstructName(d0),"pdim txtmid")end end else local id;id=i8:find('worksInEnvironment":false')if id then ai=c7(i9,ia,"Radar: Jammed","pbright txtbig txtmid")else ai=c7(i9,ia,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then ak=0;hJ()end end end end;function hP.DrawSettings(fA)if#bV>0 then local c8=fu(640)local c9=fv(200)fA[#fA+1]=[[<g class="pbright txtvspd txtstart">]]for c_,d0 in pairs(bV)do fA[#fA+1]=c7(c8,c9,d0 ..": ".._G[d0])c9=c9+20;if c_%12==0 then c8=c8+fu(350)c9=fv(200)end end;fA[#fA+1]=c7(fu(640),fv(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")fA[#fA+1]="</g>"end;return fA end;return hP end;local function ie()local function ig()local function ih(ii,ij)return ii.name<ij.name end;bX={}for c_,d0 in pairs(b2[0])do bX[#bX+1]={name=d0.name,index=c_}end;table.sort(bX,ih)end;local d1={}function d1.UpdateAtlasLocationsList()ig()end;function d1.UpdateAutopilotTarget()if AutopilotTargetIndex==0 then AutopilotTargetName="None"a9=nil;CustomTarget=nil;return true end;local ik=bX[AutopilotTargetIndex].index;local il=b2[0][ik]if il.center then AutopilotTargetName=il.name;a9=b7[0][ik]if CustomTarget~=nil then if as==0 then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end;if t(widgetTargetOrbitText,widgetTargetOrbit)~=1 then u(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=il;for _,d0 in pairs(b7[0])do if d0.name==CustomTarget.planetname then a9=d0;AutopilotTargetName=CustomTarget.name;break end end;if t(widgetMaxMassText,widgetMaxMass)~=1 then u(widgetMaxMassText,widgetMaxMass)end;if t(widgetTravelTimeText,widgetTravelTime)~=1 then u(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(a9.center)else AutopilotTargetCoords=CustomTarget.position end;if a9.planetname~="Space"then if a9.hasAtmosphere then AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(a9.radius*(TargetOrbitRadius-1)+a9.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=ba(a9):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;function d1.adjustAutopilotTargetIndex(g4)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if g4==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bX then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bX end end;if AutopilotTargetIndex==0 then bc.UpdateAutopilotTarget()else local ik=bX[AutopilotTargetIndex].index;local il=b2[0][ik]if il.name=="Space"then if g4==nil then bc.adjustAutopilotTargetIndex()else bc.adjustAutopilotTargetIndex(1)end else bc.UpdateAutopilotTarget()end end else Z="Disengage autopilot before changing Interplanetary Helper"end end;function d1.findAtlasIndex(im)for c_,d0 in pairs(im)do if d0.name and d0.name==CustomTarget.name then return c_ end end;return-1 end;for c_,d0 in pairs(SavedLocations)do table.insert(b2[0],d0)end;ig()d1.UpdateAutopilotTarget()return d1 end;local function io()local ip={}local function iq(eV)local ir=AutopilotEndSpeed;if not Autopilot then ir=0 end;if not ar then return b8.computeDistanceAndTime(eV,ir,aw,0,0,LastMaxBrake-AutopilotPlanetGravity*aw)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return b8.computeDistanceAndTime(eV,ir,aw,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*aw)else return 0,0 end end end;local function is(eV)local ir=AutopilotEndSpeed;if not Autopilot then ir=0 end;return b8.computeDistanceAndTime(eV,ir,aw,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*aw)end;function ip.GetAutopilotBrakeDistanceAndTime(eV)return iq(eV)end;function ip.GetAutopilotTBBrakeDistanceAndTime(eV)return is(eV)end;local function it(iu,iv,iw)iv=iv:project_on_plane(iu)iw=iw:project_on_plane(iu)return m(iv:cross(iw):dot(iu),iv:dot(iw))end;local function ix()local function iy()local iz=-1;local iA=-1;if vBooster then iz=vBooster.distance()end;if hover then iA=hover.distance()end;if iz~=-1 and iA~=-1 then if iz<iA then return iz else return iA end elseif iz~=-1 then return iz elseif iA~=-1 then return iA else return-1 end end;local iB=iy()local iC=-1;if telemeter_1 then iC=telemeter_1.getDistance()end;if iB~=-1 and iC~=-1 then if iB<iC then return iB else return iC end elseif iB~=-1 then return iB else return iC end end;local function iD(planet,eg,iE)local function iF(iG,dw)local em=vec3(dw)if iG.bodyId==0 then return setmetatable({latitude=em.x,longitude=em.y,altitude=em.z,bodyId=0,systemId=iG.planetarySystemId},MapPosition)end;local en=em-iG.center;local ah=en:len()local dD=ah-iG.radius;local dB=0;local dC=0;if not ch(ah,0)then local eo=m(en.y,en.x)dC=eo>=0 and eo or 2*math.pi+eo;dB=math.pi/2-math.acos(en.z/ah)end;return setmetatable({latitude=math.deg(dB),longitude=math.deg(dC),altitude=dD,bodyId=iG.bodyId,systemId=iG.planetarySystemId},MapPosition)end;local iH=iF(planet,eg)iH="::pos{"..iH.systemId..","..iH.bodyId..","..iH.latitude..","..iH.longitude..","..iH.altitude.."}"if bN==0 and not iE then bM=iH end;if iE then return iH else system.setWaypoint(iH)return true end end;function ip.showWayPoint(planet,eg,iE)return iD(planet,eg,iE)end;function ip.APTick()ar=j()>0;as=j()at=core.getAltitude()ao=ix()bD=p()bj=bD;if antigrav then bP=antigrav.getState()==1 end;local iI=1;local iJ=1;local iK=bD-bj;local iL=-math.deg(it(bE,bH,bF))local iM=math.deg(it(bG,bH,bF))local g4=bJ*-1;bi=ar and iL<-YawStallAngle or iL>YawStallAngle or iM<-PitchStallAngle or iM>PitchStallAngle;local iN=system.getMouseDeltaX()local iO=system.getMouseDeltaY()if InvertMouse and not Y then iO=-iO end;S=0;W=0;R=0;sys=b7[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=ba(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),bH)if at==0 then at=(bL-planet.center):len()-planet.radius end;local i0=planet:getGravity(core.getConstructWorldPos()):len()*aw;bk=0;b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if w()==0 then if l()==1 and Y then if not be then ae=ae+iN;af=af+iO end else ae=0;af=0 end else ae=ae+iN;af=af+iO;ah=math.sqrt(ae*ae+af*af)if not Y and l()==0 then if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then S=S-(ae-DeadZone)*MouseXSensitivity elseif ae<0 and ae<DeadZone*-1 then S=S-(ae+DeadZone)*MouseXSensitivity else S=0 end;if af>0 and af>DeadZone then R=R-(af-DeadZone)*MouseYSensitivity elseif af<0 and af<DeadZone*-1 then R=R-(af+DeadZone)*MouseYSensitivity else R=0 end else ae=0;af=0;if userControlScheme=="mouse"then R=(-utils.smoothstep(iO,-100,100)+0.5)*2*iI;S=(-utils.smoothstep(iN,-100,100)+0.5)*2*iJ end end end end;local iP=bI>8334;if bI>SpaceSpeedLimit/3.6 and not ar and not Autopilot and not iP then Z="Space Speed Engine Shutoff reached"cd(0)end;if not iP and LastIsWarping then if not BrakeIsOn then cB()end;if Autopilot then ct()end end;LastIsWarping=iP;if ar and as>0.09 then if bI>bn/3.6 and not AtmoSpeedAssist and not az then BrakeIsOn=true;az=true elseif not AtmoSpeedAssist and az then if bI<bn/3.6 then BrakeIsOn=false;az=false end end end;if BrakeIsOn then V=1 else V=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local iQ=false;if CustomTarget~=nil then iQ=cC(CustomTarget.position-bL,0.01)else iQ=cC(vec3(bH),0.01)end;bg=true;if iQ and(c(bT)<2 or c(bS)>85)and bI>=bn/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;O=true;al=false;an=true;Autopilot=false;cO()elseif ar and AtmoSpeedAssist then cd(1)else cg(d(bn))end elseif bI>N then cC(vec3(bH),0.01)end end;if RetrogradeIsOn then if ar then RetrogradeIsOn=false elseif bI>N then cC(-vec3(bH))end end;if not ProgradeIsOn and al and not IntoOrbit then if as==0 then O=true;cO()al=false;an=true else al=false;ct()end end;if an and CustomTarget~=nil and(at<HoldAltitude+200 and at>HoldAltitude-200)and bI*3.6>bn-100 and c(bK)<20 and as>=0.1 and(CustomTarget.position-bL):len()>2000+at then ct()an=false end;if VertTakeOff then bg=true;local iR=HoldAltitude;if bK<-30 then Z="Unable to achieve lift. Safety Landing."ad=0;bg=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bP or HoldAltitude<planet.spaceEngineMinAltitude then if bP then iR=antigrav.getBaseAltitude()end;if at<iR-100 then bo=0;ad=15;BrakeIsOn=false elseif bK>0 then BrakeIsOn=true;ad=0 elseif bK<-30 then BrakeIsOn=true;ad=15 elseif at>=iR then if bP then if Autopilot or VectorToTarget then cp()else BrakeIsOn=true;VertTakeOff=false end;Z="Takeoff complete. Singularity engaged"else BrakeIsOn=false;Z="VTO complete. Engaging Horizontal Flight"cp()end;ad=0 end else if as>0.08 then bo=0;BrakeIsOn=false;ad=20 elseif as<0.08 and as>0 then BrakeIsOn=false;if bA then bo=0;ad=20 else ad=0;bo=36;cg(3500)end else bg=autoRollPreference;IntoOrbit=true;by=false;CancelIntoOrbit=false;bs=false;bq=nil;br=nil;if bx==nil then bx=planet end;bw=iR;bv=true;VertTakeOff=false end end;if bo~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local iS=q(bo-bS,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(iS)local iT=q(vTpitchPID:get(),-1,1)R=iT end end;if IntoOrbit then local cL;local iU=false;local iV,iW=ck(bw)local iX=iV..iW;if bx==nil then bx=planet;if VectorToTarget then bx=a9 end end;if not bv then bw=math.floor(bx.radius+bx.surfaceMaxAltitude+LowOrbitHeight)if bx.hasAtmosphere then bw=math.floor(bx.radius+bx.noAtmosphericDensityAltitude+LowOrbitHeight)end;bv=true end;if bu.VectorToTarget then cL=CustomTarget.position-bL end;local iY,iZ=ba(bx):escapeAndOrbitalSpeed((bL-bx.center):len()-bx.radius)local i_=bT;if not bs then local j0=false;local j1=false;cd(0)br=0;bp="Aligning to orbital path - OrbitHeight: "..iX;if bu.VectorToTarget then cC(cL:normalize():project_on_plane(bJ))iU=bF:dot(cL:project_on_plane(bE):normalize())>0.95 else cC(bH)iU=iL<0.5;if bI<150 then iU=true end end;R=0;bq=0;if bS<=bq+1 and bS>=bq-1 then j0=true else j0=false end;if i_<=br+1 and i_>=br-1 then j1=true else j1=false end;if j0 and j1 and iU then bq=nil;br=nil;bs=true end else if bu.VectorToTarget then cC(cL:normalize():project_on_plane(bJ))elseif bI>150 then cC(bH)end;R=0;if bu.VectorToTarget then local a5,_=b8.computeDistanceAndTime(bI,bn/3.6,aw,0,0,LastMaxBrake)if by and cL:len()>15000+a5+at then bp="Orbiting to Target"if at-100<=bx.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bx.noAtmosphericDensityAltitude then by=false end elseif by or cL:len()<15000+a5+at then Z="Orbit complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;O=true;an=true;bu.VectorToTarget,bu.AutopilotAlign=false,false;cq()cO()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and at>bw*0.9 and at<bw*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bw*0.99 and orbit.apoapsis.altitude>=bw*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or by then if by then BrakeIsOn=false;cd(0)bq=0;if not bu.VectorToTarget then Z="Orbit complete"cq()end else bC=bC+1;if bC>=2 then by=true end end else bp="Adjusting Orbit - OrbitHeight: "..iX;bt=true;cg(iZ*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local j2=bK;local j3=at-bw;local j4=c(j3)if bK<10 and c(bS)<10 and j4<100 then j2=bK*2 end;if j2<10 and c(bS)<10 and j4<100 then j2=j2*2 end;if j2<5 and c(bS)<5 and j4<100 then j2=j2*4 end;VSpdPID:inject(j2)bq=q(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(j3)bq=q(bq-q(OrbitAltPID:get(),-15,15),-90,90)end end else local j5=2.75;local j6=c(o(iY*j5))local j7=j6%50;if j7>0 then j6=j6-j7+50 end;BrakeIsOn=false;if at<bw*0.8 then bp="Escaping planet gravity - OrbitHeight: "..iX;bq=utils.map(bK,200,0,-15,80)elseif at>=bw*0.8 and at<bw*1.15 then bp="Approaching orbital corridor - OrbitHeight: "..iX;j6=j6*0.75;bq=utils.map(bK,100,-100,-15,65)elseif at>=bw*1.15 and at<bw*1.5 then bp="Approaching orbital corridor - OrbitHeight: "..iX;j6=j6*0.75;if bK<0 or bt then bq=utils.map(at,bw*1.5,bw*1.01,-30,0)else bq=utils.map(at,bw*0.99,bw*1.5,0,30)end elseif at>bw*1.5 then bp="Reentering orbital corridor - OrbitHeight: "..iX;bq=-65;local j8=utils.map(bK,-150,-400,1,0.55)j6=j6*j8 end;cg(d(j6))end end;if bq~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local j9=bq-bS;OrbitPitchPID:inject(j9)local ja=q(OrbitPitchPID:get(),-0.5,0.5)R=ja end end;if Autopilot and as==0 and not al then local jb,jc=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local jd=(CustomTarget.position-a9.center):normalize()local je=jd:project_on_plane((a9.center-bL):normalize()):normalize()local jf=a9.center+je*(a9.radius+AutopilotTargetOrbit)local jg=CustomTarget.position+(CustomTarget.position-a9.center):normalize()*(AutopilotTargetOrbit-a9:getAltitude(CustomTarget.position))if(bL-jf):len()<(bL-jg):len()then jb=jf else jb=CustomTarget.position+(CustomTarget.position-a9.center):normalize()*(AutopilotTargetOrbit-a9:getAltitude(CustomTarget.position))AutopilotEndSpeed=0 end;AutopilotTargetCoords=jb;bd.showWayPoint(a9,AutopilotTargetCoords)jc=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;jc=true;TargetSet=true;AutopilotRealigned=true;jb=CustomTarget.position+(bL-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local jd=(bL+bH*100000-a9.center):normalize()local je=jd:project_on_plane((a9.center-bL):normalize()):normalize()if je:len()<1 then jd=(bL+bF*100000-a9.center):normalize()je=jd:project_on_plane((a9.center-bL):normalize()):normalize()end;jb=a9.center+je*(a9.radius+AutopilotTargetOrbit)AutopilotTargetCoords=jb;TargetSet=true;jc=true;AutopilotRealigned=true;bd.showWayPoint(a9,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(jb)-bL):len()local ho,ee,ef=b7:getPlanetarySystem(0):castIntersections(bL,bH:normalize(),function(e2)if e2.noAtmosphericDensityAltitude>0 then return e2.radius+e2.noAtmosphericDensityAltitude else return e2.radius+e2.surfaceMaxAltitude*1.5 end end)local hp=ee;if ef~=nil and ee~=nil then hp=math.min(ef,ee)end;if hp~=nil and hp<AutopilotDistance and ho.name==a9.name then AutopilotDistance=hp end;local iQ=true;local jh=(a9.center-(bL+vec3(bH):normalize()*AutopilotDistance)):len()-a9.radius;local hn,co=ck(jh)t(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..hn..'", "unit":"'..co..'"}')local a5,a6;if not TurnBurn then a5,a6=iq(bI)else a5,a6=is(bI)end;if bI>300 and AutopilotAccelerating then local cL=vec3(jb)-bL;local ji=q(math.deg(it(bE,bH:normalize(),cL:normalize()))*bI/500,-90,90)local jj=q(math.deg(it(bG,bH:normalize(),cL:normalize()))*bI/500,-90,90)if c(ji)<20 and c(jj)<20 then ji=ji*2;jj=jj*2 end;if c(ji)<2 and c(jj)<2 then ji=ji*2;jj=jj*2 end;local iL=-math.deg(it(bE,bF,bH:normalize()))local iM=-math.deg(it(bG,bF,bH:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(jj-iM)local jk=q(apPitchPID:get(),-1,1)R=R+jk;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(ji-iL)local jl=q(apYawPID:get(),-1,1)S=S+jl;jc=true;if c(ji)>2 or c(jj)>2 then AutopilotStatus="Adjusting Trajectory"else AutopilotStatus="Accelerating"end end;if jh<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=ba(a9):escapeAndOrbitalSpeed(jh)end end;if not AutopilotCruising and not AutopilotBraking and not jc then iQ=cC((jb-bL):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then iQ=cC(-vec3(bH):normalize())end;if AutopilotAccelerating then if not M then BrakeIsOn=false;cd(AutopilotInterplanetaryThrottle)F=x(AutopilotInterplanetaryThrottle,2)M=true end;local jm=unit.getThrottle()if AtmoSpeedAssist then jm=F end;if vec3(core.getVelocity()):len()>=MaxGameVelocity or jm==0 and M then AutopilotAccelerating=false;AutopilotStatus="Cruising"AutopilotCruising=true;cd(0)end;if AutopilotDistance<=a5 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true;cd(0)M=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;V=1 end;if TurnBurn then cd(1,true)end;local _,iZ=ba(a9):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)local cL;if CustomTarget~=nil then cL=CustomTarget.position-bL end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bI<50 then Z="Autopilot complete, arrived at space location"AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bI<=iZ and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cd(0)M=false;ProgradeIsOn=true;al=true;bd.showWayPoint(a9,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 then AutopilotStatus="Circularizing"local _,iZ=ba(a9):escapeAndOrbitalSpeed((bL-planet.center):len()-planet.radius)if bI<=iZ then if CustomTarget~=nil then if bH:normalize():dot(cL:normalize())>0.4 then AutopilotStatus="Orbiting to Target"if not WaypointSet then BrakeIsOn=false;bd.showWayPoint(a9,CustomTarget.position)WaypointSet=true end else Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cd(0)M=false;ProgradeIsOn=true;al=true;BrakeIsOn=false;bd.showWayPoint(a9,CustomTarget.position)WaypointSet=false end else BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Z="Autopilot completed, orbit established"V=0;cd(0)M=false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then ProgradeIsOn=true;al=true end end end end elseif AutopilotCruising then if AutopilotDistance<=a5 then AutopilotAccelerating=false;AutopilotStatus="Braking"AutopilotBraking=true end;local jm=unit.getThrottle()if AtmoSpeedAssist then jm=F end;if jm>0 then AutopilotAccelerating=true;AutopilotStatus="Accelerating"AutopilotCruising=false end else if iQ then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(a9.center)+(AutopilotTargetOrbit+a9.radius)*bG;AutopilotShipUp=bE;AutopilotShipRight=bG end;AutopilotRealigned=true elseif iQ then AutopilotAccelerating=true;AutopilotStatus="Accelerating"if not M then cd(AutopilotInterplanetaryThrottle,true)F=x(AutopilotInterplanetaryThrottle,2)M=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and as>0)then Z="Autopilot complete, proceeding with reentry"AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"V=0;cd(0)M=false;ProgradeIsOn=true;al=true;bd.showWayPoint(a9,CustomTarget.position)end;if X then bg=true;local jj=0;local eZ=bL+vec3(unit.getMasterPlayerRelativePosition())local jn=eZ-bL;local jo=vec3(jn):project_on(bF):len()local jp=vec3(jn):project_on(bG):len()local ah=math.sqrt(jo*jo+jp*jp)cC(jn:normalize())local jq=40;local jr=ah<jq;local js=100;local jt=q((ah-jq)/2,10,js)R=0;local iQ=c(S)<0.1;if iQ and bI<jt and not jr then BrakeIsOn=false;jj=-20 else BrakeIsOn=true;jj=0 end;local ju=0;if c(jj-bS)>ju then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(jj-bS)local jk=pitchPID:get()R=jk end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local cv=unit.getClosestPlanetInfluence()>0;local jv=HoldAltitude-at;local jw=500+bI;local jx=1;if AutoTakeoff then jx=q(bI/100,0.1,1)end;local jj=(utils.smoothstep(jv,-jw,jw)-0.5)*2*MaxPitch*jx;if not Reentry and not al and not VectorToTarget and bF:dot(bH:normalize())<0.99 then jj=(utils.smoothstep(jv,-jw*q(20-19*as*10,1,20),jw*q(20-19*as*10,1,20))-0.5)*2*MaxPitch*q(2-as*10,1,2)*jx end;if not AltitudeHold then jj=0 end;if LockPitch~=nil then if cv and not IntoOrbit then jj=LockPitch else LockPitch=nil end end;bg=true;local jy=R;if Reentry then local jz=d(bn)local jA,jB=b8.computeDistanceAndTime(bI,jz/3.6,aw,0,0,LastMaxBrake-planet.gravity*9.8*aw)local jC=at-(planet.noAtmosphericDensityAltitude+5000)if not bR and at>planet.noAtmosphericDensityAltitude+5000 and bI<=jz/3.6 and bI>jz/3.6-10 and c(bH:normalize():dot(bF))>0.9 then cd(0)elseif bR and(jA>-1 and jC<=jA or at<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cg(jz,true)if not O then jj=-80;if as>0.02 then Z="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;jj=0;bg=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and at>planet.noAtmosphericDensityAltitude+5000 then bg=true elseif at<=planet.noAtmosphericDensityAltitude+5000 then cg(jz)if not bR and r:getTargetSpeed(axisCommandId.longitudinal)==bn then O=false;Reentry=false;bg=true end end end;if bI>N and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then cC(vec3(bH))end;if(VectorToTarget or am)and AutopilotTargetIndex>0 and as>0.01 then local cL;if CustomTarget~=nil then cL=CustomTarget.position-bL else cL=a9.center-bL end;local ji=math.deg(it(bJ:normalize(),bH,cL))*2;local jD=math.rad(c(bT))if bI>minRollVelocity and as>0.01 then local jE=q(90-jj*2,-90,90)bk=q(ji*2,-jE,jE)local jF=ji;ji=q(q(ji,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(jD)+4*(bS-jj)*math.sin(math.rad(bT)),-YawStallAngle*0.80,YawStallAngle*0.80)jj=q(q(jj*math.cos(jD),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(q(c(jF)*math.sin(jD),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bk=0;ji=q(ji,-YawStallAngle*0.80,YawStallAngle*0.80)end;local jG=iL-ji;if not bi and bI>minRollVelocity and as>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(jG)local jl=q(yawPID:get(),-1,1)S=S+jl elseif ar and ao>-1 or bI<minRollVelocity then cC(cL)elseif bi and as>0.01 then if(iL<-YawStallAngle or iL>YawStallAngle)and as>0.01 then cC(bH)end;if(iM<-PitchStallAngle or iM>PitchStallAngle)and as>0.01 then jj=q(bS-iM,bS-PitchStallAngle*0.80,bS+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local iR=planet:getAltitude(CustomTarget.position)local jC=math.sqrt(cL:len()^2-(at-iR)^2)local jH=LastMaxBrakeInAtmo;if jH then jH=jH*q(bI/100,0.1,1)*as else jH=LastMaxBrake end;if as<0.01 then jH=LastMaxBrake end;local jI=bH:len()-c(bK)local jJ=vec3(core.getWorldAirFrictionAcceleration())local jK=math.sqrt(jJ:len()-jJ:project_on(g4):len())*aw;if bI>100 then a5,a6=b8.computeDistanceAndTime(bI,100,aw,0,0,jH+jK)local jL,jM=b8.computeDistanceAndTime(100,0,aw,0,0,jH/2)a5=a5+jL else a5,a6=b8.computeDistanceAndTime(bI,0,aw,0,0,jH/2)end;StrongBrakes=true;if not am and not Reentry and jC<=a5+bI*iK/2 and(bH:project_on_plane(bJ):normalize():dot(cL:project_on_plane(bJ):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cd(0)if AltitudeHold then cr()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(jI<0.1 or jC<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<jC)then if not bP then BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"end;LastDistanceToTarget=jC end elseif VectorToTarget and as==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and a9.name==planet.name then local cL=CustomTarget.position-bL;local iR=planet:getAltitude(CustomTarget.position)local jC=math.sqrt(cL:len()^2-(at-iR)^2)local jH=LastMaxBrakeInAtmo;if jH then a5,a6=b8.computeDistanceAndTime(bI,0,aw,0,0,jH/2)StrongBrakes=true;if jC<=a5+bI*iK/2 and bH:project_on_plane(bJ):normalize():dot(cL:project_on_plane(bJ):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;O=true;al=false;an=true;Autopilot=false;cO()end end;LastDistanceToTarget=jC end end end;if as==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not by and not IntoOrbit then bw=HoldAltitude;bv=true;if VectorToTarget then bu.VectorToTarget=true end;cq()VectorToTarget=false;bs=true end end;if bi and as>0.01 and ao==-1 and bI>minRollVelocity and VectorStatus~="Finalizing Approach"then cC(bH)jj=q(bS-iM,bS-PitchStallAngle*0.80,bS+PitchStallAngle*0.80)end;R=jy;local iC=-1;if BrakeLanding then jj=0;local jN=false;local jO=30;if b9~=nil and b9>0 then local jK=0;local jP=q(as,0.4,2)local jH=LastMaxBrakeInAtmo*q(bI/100,0.1,1)*jP;local jQ=b9*jP+jH+jK-i0;local jR=jH/2+jK-i0;local jS=bI-math.sqrt(c(jR/2)*20/(0.5*aw))*utils.sign(jR)if jS<0 then jS=0 end;local jT;if bI>100 then local jU,_=b8.computeDistanceAndTime(bI,100,aw,0,0,jH)local jV,_=b8.computeDistanceAndTime(100,0,aw,0,0,math.sqrt(jH))jT=jU+jV else jT=b8.computeDistanceAndTime(bI,0,aw,0,0,math.sqrt(jH))end;if jT<20 then BrakeIsOn=false else local jW=0;if jS>100 then local jX,_=b8.computeDistanceAndTime(jS,100,aw,0,0,jQ)local jY,_=b8.computeDistanceAndTime(100,0,aw,0,0,b9*jP+math.sqrt(jH)+jK-i0)jW=jX+jY else jW,_=b8.computeDistanceAndTime(jS,0,aw,0,0,b9*jP+math.sqrt(jH)+jK-i0)end;jW=(jW+15+bI*iK)*1.1;local jZ=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if jZ then local iR=planet:getAltitude(CustomTarget.position)local j_=at-iR-100;local cL=CustomTarget.position-bL;local k0=math.sqrt(cL:len()^2-(at-iR)^2)if k0>100 then jZ=false elseif j_<=jW or jW==-1 then BrakeIsOn=true;jN=true else BrakeIsOn=false;jN=true end end;if not jZ and CalculateBrakeLandingSpeed then if jW>=jO then BrakeIsOn=true else BrakeIsOn=false end;jN=true end end end;if not bR then cd(0)end;r:setTargetGroundAltitude(500)r:activateGroundEngineAltitudeStabilization(500)iC=ao;if iC>-1 then bg=autoRollPreference;if bI<1 or bH:normalize():dot(bJ)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and bH:normalize():dot(-g4)<0.999 then BrakeIsOn=true elseif bK<-brakeLandingRate and not jN then BrakeIsOn=true elseif not jN then BrakeIsOn=false end end;if AutoTakeoff or am then local ho,ef,ee;if AutopilotTargetCoords~=nil then ho,ef,ee=b7:getPlanetarySystem(0):castIntersections(bL,(AutopilotTargetCoords-bL):normalize(),function(e2)return e2.radius+e2.noAtmosphericDensityAltitude end)end;if bP then if at>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cd(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(jj)<15 and at/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bR and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bI<N then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cd(0)elseif am then cd(0)BrakeIsOn=true end elseif am and as==0 and a9~=nil and(ho==nil or ho.name==a9.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bR then cd(0)end;AutopilotAccelerating=true end end;local k1=ao>-1;local k2=bS;if(VectorToTarget or am)and not k1 and bI>minRollVelocity and as>0.01 then local jD=math.rad(c(bT))k2=bS*c(math.cos(jD))+iM*math.sin(jD)end;local k3=q(jj-k2,-PitchStallAngle*0.80,PitchStallAngle*0.80)if as<0.01 and VectorToTarget then k3=q(jj-k2,-85,MaxPitch)elseif as<0.01 then k3=q(jj-k2,-MaxPitch,MaxPitch)end;if c(bT)<5 or VectorToTarget or BrakeLanding or k1 or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(k3)local jk=pitchPID:get()R=R+jk end end;if antigrav~=nil and(antigrav and not ExternalAGG and at<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=ix()return ip end;function script.onStart()local function k4()local function k5(k6)local k7=dbHud_1.hasKey;for c_,d0 in pairs(k6)do if k7(d0)then local cn=f(dbHud_1.getStringValue(d0))if cn~=nil then _G[d0]=cn;aM=true end end end end;if dbHud_1 then local k7=dbHud_1.hasKey;if not useTheseSettings then k5(c0())coroutine.yield()k5(b)else k5(b)Z="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;aM=false end;coroutine.yield()if aM then Z="Loaded Saved Variables"K=x(ResolutionX/2,0)L=x(ResolutionY/2,0)aK=ResolutionX;aL=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)bg=autoRollPreference;bn=AtmoSpeedLimit;aA=[[rgb(]]..d(C+0.5)..","..d(E+0.5)..","..d(D+0.5)..[[)]]aB=[[rgb(]]..d(C*0.9+0.5)..","..d(E*0.9+0.5)..","..d(D*0.9+0.5)..[[)]]elseif not useTheseSettings then Z="No Saved Variables Found - Exit HUD to save settings"end else Z="No databank found. Attach one to control unit and rerun the autoconfigure to save preferences and locations"end;if LastStartTime+180<bD then LastMaxBrakeInAtmo=0 end;LastStartTime=bD;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then Z="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=at end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=aw end end;local function k8()local function k9(ka,kb)if ka>kb then kb=ka end;if ContainerOptimization>0 then kb=kb-kb*ContainerOptimization*0.05 end;if FuelTankOptimization>0 then kb=kb-kb*FuelTankOptimization*0.05 end;return kb end;local kc=core.getElementNameById;local kd=fuelX~=0 and fuelY~=0;for c_ in pairs(au)do local type=core.getElementTypeById(au[c_])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(au[c_])),'^.*vertical.*$')then bO=true end end;if n(type,'^.*Space Engine$')then bB=true;if n(tostring(core.getElementTagsById(au[c_])),'^.*vertical.*$')then local ke=core.getElementRotationById(au[c_])if ke[4]<0 then if o(-ke[4],0.1)==0.5 then bz=true end else if o(ke[4],0.1)==0.5 then bA=true end end end end;if type=="Landing Gear"then P=true end;if type=="Dynamic Core Unit"then local kf=h(au[c_])if kf>10000 then B=128 elseif kf>1000 then B=64 elseif kf>150 then B=32 end end;aS=aS+h(au[c_])if kd and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local kf=h(au[c_])local kg=k(au[c_])local ka=0;local fX=p()if type=="Atmospheric Fuel Tank"then local kb=400;local kh=35.03;if kf>10000 then kb=51200;kh=5480 elseif kf>1300 then kb=6400;kh=988.67 elseif kf>150 then kb=1600;kh=182.67 end;ka=kg-kh;if fuelTankHandlingAtmo>0 then kb=kb+kb*fuelTankHandlingAtmo*0.2 end;kb=k9(ka,kb)aP[#aP+1]={au[c_],kc(au[c_]),kb,kh,ka,fX}end;if type=="Rocket Fuel Tank"then local kb=320;local kh=173.42;if kf>65000 then kb=40000;kh=25740 elseif kf>6000 then kb=5120;kh=4720 elseif kf>700 then kb=640;kh=886.72 end;ka=kg-kh;if fuelTankHandlingRocket>0 then kb=kb+kb*fuelTankHandlingRocket*0.1 end;kb=k9(ka,kb)aR[#aR+1]={au[c_],kc(au[c_]),kb,kh,ka,fX}end;if type=="Space Fuel Tank"then local kb=2400;local kh=182.67;if kf>10000 then kb=76800;kh=5480 elseif kf>1300 then kb=9600;kh=988.67 end;ka=kg-kh;if fuelTankHandlingSpace>0 then kb=kb+kb*fuelTankHandlingSpace*0.2 end;kb=k9(ka,kb)aQ[#aQ+1]={au[c_],kc(au[c_]),kb,kh,ka,fX}end end end;if not bO then VertTakeOff,VertTakeOffEngine=false,false end end;local function ki()if gyro~=nil then ay=gyro.getState()==1 end;if userControlScheme~="keyboard"then v(1)else v(0)end;if door and(ar or not ar and at<10000)then for _,d0 in pairs(door)do d0.toggle()end end;if switch then for _,d0 in pairs(switch)do d0.toggle()end end;if forcefield and(ar or not ar==0 and at<10000)then for _,d0 in pairs(forcefield)do d0.toggle()end end;if antigrav then bP=antigrav.getState()==1;if bP and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if P then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not ar and vec3(core.getVelocity()):len()<50 then BrakeIsOn=true;if not P then GearExtended=true end else BrakeIsOn=false end;if bh~=nil then r:setTargetGroundAltitude(bh)if bh==0 and not P then GearExtended=true;BrakeIsOn=true end else bh=a:getTargetGroundAltitude()if GearExtended then r:setTargetGroundAltitude(LandingGearGroundHeight)else r:setTargetGroundAltitude(TargetHoverHeight)end end;if ar and ao~=-1 then b9=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ar end;local function kj(kk,kl,km,kn,c8,c9,ko,kp,kq,kr)local ks={enableName=kk,disableName=kl,width=km,height=kn,x=c8,y=c9,toggleVar=ko,toggleFunction=kp,drawCondition=kq,hovered=false}if kr then table.insert(aJ,ks)else table.insert(aI,ks)end;return ks end;local function kt(ku)if not bU then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif ku=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif ku=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif ku=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bV=c0(ku)showHud=false else bV={}showHud=true end end;local function kv()bU=not bU;if bU then aH=aJ;Z="Hold SHIFT to see Settings"bW=showHud else aH=aI;Z="Hold SHIFT to see Control Buttons"kt()showHud=bW end end;local function kw(d0)_G[d0]=not _G[d0]if _G[d0]then Z=d0 .." set to true"else Z=d0 .." set to false"end;if d0=="showHud"then bW=_G[d0]elseif d0=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function kx()local ky=50;local kz=340;local c8=500;local c9=aL/2-400;local kA=0;for c_,d0 in pairs(c0("boolean"))do if type(_G[d0])=="boolean"then kj(d0,d0,kz,ky,c8,c9,function()return _G[d0]end,function()kw(d0)end,function()return true end,true)c9=c9+ky+20;if kA==7 then c8=c8+kz+20;c9=aL/2-400;kA=0 else kA=kA+1 end end end;kj("Control View","Control View",kz,ky,10,aL/2-500,function()return true end,kv,function()return true end,true)kj("View Handling Settings",'Hide Handling Settings',kz,ky,10,aL/2-(500-ky),function()return showHandlingVariables end,function()kt("handling")end,function()return true end,true)kj("View Hud Settings",'Hide Hud Settings',kz,ky,10,aL/2-(500-ky*2),function()return showHudVariables end,function()kt("hud")end,function()return true end,true)kj("View Physics Settings",'Hide Physics Settings',kz,ky,10,aL/2-(500-ky*3),function()return showPhysicsVariables end,function()kt("physics")end,function()return true end,true)end;local function kB()local function kC()if dbHud_1 then local position=bL;local fQ=planet.name..". "..#SavedLocations;if radar_1 then local dL,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dL~=nil and dL~=""then fQ=fQ.." "..radar_1.getConstructName(dL)end end;local cz={}cz={position=position,name=fQ,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity,safe=true}SavedLocations[#SavedLocations+1]=cz;table.insert(b2[0],cz)bc.UpdateAtlasLocationsList()Z="Location saved as "..fQ else Z="Databank must be installed to save locations"end end;local function kD()TurnBurn=not TurnBurn end;local function kE(kF)if kF==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;X=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function kG()kE(1)end;local function kH()local cy=-1;cy=bc.findAtlasIndex(b2[0])if cy>-1 then table.remove(b2[0],cy)end;cy=-1;cy=bc.findAtlasIndex(SavedLocations)if cy~=-1 then Z=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cy)end;bc.adjustAutopilotTargetIndex()bc.UpdateAtlasLocationsList()end;local function kI()local fQ=AutopilotTargetName;if fQ==nil then local hn,co=ck((bL-CustomTarget.position):len())fQ=CustomTarget.name.." "..hn..co end;if fQ==nil then fQ="None"end;return"Engage Autopilot: "..fQ end;local function kJ()local fQ=AutopilotTargetName;if fQ==nil then fQ=CustomTarget.name end;if fQ==nil then fQ="None"end;return"Disable Autopilot: "..fQ end;local function kK()if safeMass>0 then Z="Safe Mass set to "..x(aw,2).." kg"else Z="Intruder Detection reset\nSafe Mass set to "..x(aw,2).." kg"ag=5;bN=0;if bM then system.setWaypoint(bM)end end;safeMass=aw end;local ky=50;local kz=260;local kL=kj("Enable Brake Toggle","Disable Brake Toggle",kz,ky,aK/2-kz/2,aL/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then Z="Brakes in Toggle Mode"else Z="Brakes in Default Mode"end end)kj("Align Prograde","Disable Prograde",kz,ky,aK/2-kz/2-50-kL.width,aL/2-ky+380,function()return ProgradeIsOn end,kG)kj("Align Retrograde","Disable Retrograde",kz,ky,aK/2-kz/2+kL.width+50,aL/2-ky+380,function()return RetrogradeIsOn end,kE,function()return as==0 end)local kM=kj(kI,kJ,600,60,aK/2-600/2,aL/2-60/2-400,function()return Autopilot end,ct)kj("Save Position","Save Position",200,kM.height,kM.x+kM.width+30,kM.y,function()return false end,kC,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)kj("Update Position","Update Position",200,kM.height,kM.x+kM.width+30,kM.y,function()return false end,cw,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)kj("Clear Position","Clear Position",200,kM.height,kM.x-200-30,kM.y,function()return true end,kH,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ky=60;kz=300;local c8=10;local c9=aL/2-500;kj("Show Help","Hide Help",kz,ky,c8,c9,function()return showHelp end,function()showHelp=not showHelp end)c9=c9+ky+20;kj("View Settings","View Settings",kz,ky,c8,c9,function()return true end,kv)local c9=aL/2-300;kj("Enable Turn and Burn","Disable Turn and Burn",kz,ky,c8,c9,function()return TurnBurn end,kD)kj("Horizontal Takeoff Mode","Vertical Takeoff Mode",kz,ky,c8+kz+20,c9,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then Z="Vertical Takeoff Mode"else Z="Horizontal Takeoff Mode"end end,function()return bO end)c9=c9+ky+20;kj("Show Orbit Display","Hide Orbit Display",kz,ky,c8,c9,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then Z="Orbit Display Enabled"else Z="Orbit Display Disabled"end end)kj("Engage Orbiting","Cancel Orbiting",kz,ky,c8+kz+20,c9,function()return IntoOrbit end,cq,function()return as==0 and unit.getClosestPlanetInfluence()>0 end)c9=c9+ky+20;kj("Glide Re-Entry","Cancel Glide Re-Entry",kz,ky,c8,c9,function()return Reentry end,function()al=true;kG()end,function()return planet.hasAtmosphere and not ar end)kj("Parachute Re-Entry","Cancel Parachute Re-Entry",kz,ky,c8+kz+20,c9,function()return Reentry end,cO,function()return planet.hasAtmosphere and not ar end)c9=c9+ky+20;kj("Engage Follow Mode","Disable Follow Mode",kz,ky,c8,c9,function()return X end,cs,function()return l()==1 end)kj("Enable Repair Arrows","Disable Repair Arrows",kz,ky,c8+kz+20,c9,function()return aT end,function()aT=not aT;if aT then Z="Repair Arrows Enabled"else Z="Repair Arrows Diabled"end end,function()return l()==1 end)c9=c9+ky+20;if not ExternalAGG then kj("Enable AGG","Disable AGG",kz,ky,c8,c9,function()return bP end,cQ,function()return antigrav~=nil end)end;kj("Reset Intruder Alert","Set Safe Mass",kz,ky,c8+kz+20,c9,function()return safeMass>0 end,kK,function()return IntruderAlertSystem end)c9=c9+ky+20;kj(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,kz*2,ky,c8,c9,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end end)end;SetupComplete=false;beginSetup=coroutine.create(function()r:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})k4()coroutine.yield()k8()coroutine.yield()bd=io()ki()kx()kB()aH=aI;coroutine.yield()b2=d1()b6=d2()b7=b6(d1())b8=es()ba=eX()bb=fj()bc=ie()bd=io()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)if UseSatNav then unit.setTimer("fiveSecond",5)end end)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(as>0 or as==0 and at<10000)then for _,d0 in pairs(door)do d0.toggle()end end;if switch then for _,d0 in pairs(switch)do d0.toggle()end end;if forcefield and(as>0 or as==0 and at<10000)then for _,d0 in pairs(forcefield)do d0.toggle()end end;safeMass=aw;cW()if button then button.activate()end;if SetWaypointOnExit then bd.showWayPoint(planet,bL)end end;function script.onTick(kN)if kN=="tenthSecond"then local function kO()local kP=system.createData;local kQ=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=kQ(panelInterplanetary,"value")interplanetaryHeaderText=kP('{"label": "Target Planet", "value": "N/A", "unit":""}')u(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=kQ(panelInterplanetary,"value")widgetDistanceText=kP('{"label": "distance", "value": "N/A", "unit":""}')u(widgetDistanceText,widgetDistance)widgetTravelTime=kQ(panelInterplanetary,"value")widgetTravelTimeText=kP('{"label": "Travel Time", "value": "N/A", "unit":""}')u(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=kQ(panelInterplanetary,"value")widgetMaxMassText=kP('{"label": "Maximum Mass", "value": "N/A", "unit":""}')u(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=kQ(panelInterplanetary,"value")widgetTargetOrbitText=kP('{"label": "Target Altitude", "value": "N/A", "unit":""}')u(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=kQ(panelInterplanetary,"value")widgetCurBrakeDistanceText=kP('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=kQ(panelInterplanetary,"value")widgetCurBrakeTimeText=kP('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=kQ(panelInterplanetary,"value")widgetMaxBrakeDistanceText=kP('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=kQ(panelInterplanetary,"value")widgetMaxBrakeTimeText=kP('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=kQ(panelInterplanetary,"value")widgetTrajectoryAltitudeText=kP('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ar then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)u(widgetCurBrakeTimeText,widgetCurBrakeTime)u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function kR()s(panelInterplanetary)panelInterplanetary=nil end;local function kS()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(a9.center-bL):len()else AutopilotDistance=(CustomTarget.position-bL):len()end end;local eV=bI;local jm=unit.getThrottle()/100;if AtmoSpeedAssist then jm=F end;local kT,kU=b8.computeDistanceAndTime(bI,MaxGameVelocity,aw,a:maxForceForward()*jm,warmup,0)local a5,a6;if not TurnBurn then a5,a6=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,kV;if not TurnBurn and eV>0 then _,kV=bd.GetAutopilotBrakeDistanceAndTime(eV)else _,kV=bd.GetAutopilotTBBrakeDistanceAndTime(eV)end;local kW=0;local kX=0;if AutopilotCruising or not Autopilot and eV>5 then kX=b8.computeTravelTime(eV,0,AutopilotDistance)elseif a5+kT<AutopilotDistance then kW=AutopilotDistance-(a5+kT)kX=b8.computeTravelTime(8333.0556,0,kW)else local kY=(AutopilotDistance-a5)/kT;kT=AutopilotDistance-a5;kU=kU*kY end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return kX elseif AutopilotBraking then return kV elseif AutopilotCruising then return kX+kV else return kU+a6+kX end end;if as>0 and not WasInAtmo then if not bR and AtmoSpeedAssist and(AltitudeHold or Reentry)then cd(1)J=false end end;if bQ~=nil then if r:getTargetSpeed(axisCommandId.longitudinal)~=bQ then cg(bQ,TRUE)else bQ=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then kO()end;if AutopilotTargetName~=nil then local kZ=CustomTarget~=nil;planetMaxMass=LastMaxBrakeInAtmo/a9:getGravity(a9.center+vec3(0,0,1)*a9.radius):len()t(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=kS()if kZ and not Autopilot then ah=(bL-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bL):len()end;if not TurnBurn then a5,a6=bd.GetAutopilotBrakeDistanceAndTime(bI)a7,a8=bd.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a5,a6=bd.GetAutopilotTBBrakeDistanceAndTime(bI)a7,a8=bd.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local hn,co=ck(ah)t(widgetDistanceText,'{"label": "distance", "value": "'..hn..'", "unit":"'..co..'"}')t(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cR(travelTime)..'", "unit":""}')hn,co=ck(a5)t(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..hn..'", "unit":"'..co..'"}')t(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cR(a6)..'", "unit":""}')hn,co=ck(a7)t(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..hn..'", "unit":"'..co..'"}')t(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cR(a8)..'", "unit":""}')t(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",planetMaxMass/1000)..'", "unit":" Tons"}')hn,co=ck(AutopilotTargetOrbit)t(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..e("%.2f",hn)..'", "unit":"'..co..'"}')if as>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if as==0 and WasInAtmo then if t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if t(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then u(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else kR()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;if bN>0 then system.setWaypoint(system.getWaypointFromPlayerPos())end elseif kN=="oneSecond"then local function k_(i0,l0)if i0==nil then i0=core.g()end;i0=x(i0,5)if l0~=nil and l0 or(aO==nil or aO~=i0)then local eY=core.getVelocity()local eV=vec3(eY):len()local l1=f(unit.getData()).maxBrake;if l1~=nil and l1>0 and ar then l1=l1/q(eV/100,0.1,1)l1=l1/as;if as>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+l1)/2 else LastMaxBrakeInAtmo=l1 end end end;if l1~=nil and l1>0 then LastMaxBrake=l1 end;aO=i0 end end;local function l2(fA)local l3=0;aF=""local l4=aS;local l5=0;local l6=0;local l7=0;local fZ=0;local f_=""local l8=core.getElementHitPointsById;for c_ in pairs(au)do local kf=0;local l9=0;l9=h(au[c_])kf=l8(au[c_])l5=l5+kf;if kf<l9 then if kf==0 then l7=l7+1 else l6=l6+1 end;if aT and#aC==0 then position=vec3(core.getElementPositionById(au[c_]))local c8=position.x-B;local c9=position.y-B;local la=position.z-B;table.insert(aC,core.spawnArrowSticker(c8,c9,la+1,"down"))table.insert(aC,core.spawnArrowSticker(c8,c9,la+1,"down"))core.rotateSticker(aC[2],0,0,90)table.insert(aC,core.spawnArrowSticker(c8+1,c9,la,"north"))table.insert(aC,core.spawnArrowSticker(c8+1,c9,la,"north"))core.rotateSticker(aC[4],90,90,0)table.insert(aC,core.spawnArrowSticker(c8-1,c9,la,"south"))table.insert(aC,core.spawnArrowSticker(c8-1,c9,la,"south"))core.rotateSticker(aC[6],90,-90,0)table.insert(aC,core.spawnArrowSticker(c8,c9-1,la,"east"))table.insert(aC,core.spawnArrowSticker(c8,c9-1,la,"east"))core.rotateSticker(aC[8],90,0,90)table.insert(aC,core.spawnArrowSticker(c8,c9+1,la,"west"))table.insert(aC,core.spawnArrowSticker(c8,c9+1,la,"west"))core.rotateSticker(aC[10],-90,0,90)table.insert(aC,au[c_])end elseif aT and#aC>0 and aC[11]==au[c_]then for fS in pairs(aC)do core.deleteSticker(aC[fS])end;aC={}end end;l3=d(l5/l4*100)if l3<100 then fA[#fA+1]=c7(0,0,"","pbright txt")fZ=d(l3*2.55)f_=e("rgb(%d,%d,%d)",255-fZ,fZ,0)if l3<100 then fA[#fA+1]=c7("50%",1035,"Elemental Integrity: "..l3 .."%","txtbig txtmid","fill:"..f_)if l7>0 then fA[#fA+1]=c7("50%",1055,"Disabled Modules: "..l7 .." Damaged Modules: "..l6,"txtbig txtmid","fill:"..f_)elseif l6>0 then fA[#fA+1]=c7("50%",1055,"Damaged Modules: "..l6,"txtbig txtmid","fill:"..f_)end end end end;local function lb()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then s(WeaponPanelID)WeaponPanelID=nil end end end;local function lc()local fX=p()local hb=bI;local ld=fX-av;if hb>1.38889 then hb=hb/1000;local le=hb*(fX-av)TotalDistanceTravelled=TotalDistanceTravelled+le;aa=aa+le end;ab=ab+ld;TotalFlightTime=TotalFlightTime+ld;av=fX end;local function lf()if safeMass>0 then if aw>safeMass+50 then bN=d(aw-safeMass)safeMass=-1 elseif aw<safeMass then safeMass=aw end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;ap=false;k_(nil,true)if IntruderAlertSystem then lf()end;lc()bb.UpdateRadar()lb()local fA={}bb.ExtraData(fA)if ShowOdometer then fA=bb.DrawOdometer(fA,aa,TotalDistanceTravelled,ab)end;if ShouldCheckDamage then l2(fA)end;aj=table.concat(fA,"")collectgarbage("collect")elseif kN=="fiveSecond"then aq=dbHud_1.getStringValue("SPBAutopilotTargetName")if aq~=nil and aq~=""and aq~="SatNavNotChanged"then local cn=f(dbHud_1.getStringValue("SavedLocations"))if cn~=nil then _G["SavedLocations"]=cn;local cy=-1;local cz;for c_,d0 in pairs(SavedLocations)do if d0.name and d0.name=="SatNav Location"then cy=c_;break end end;if cy~=-1 then cz=SavedLocations[cy]cy=-1;for c_,d0 in pairs(b2[0])do if d0.name and d0.name=="SatNav Location"then cy=c_;break end end;if cy>-1 then b2[0][cy]=cz end;bc.UpdateAtlasLocationsList()Z=cz.name.." position updated"end end;for i=1,#bX do if bX[i].name==aq then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bX[i].name)bc.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif kN=="msgTick"then local fA={}bb.DisplayMessage(fA,"empty")Z="empty"unit.stopTimer("msgTick")ag=3 elseif kN=="animateTick"then bf=true;be=false;ae=0;af=0;unit.stopTimer("animateTick")elseif kN=="hudTick"then local function lg(fA)local lh=d(q(ah/(aK/4)*255,0,255))fA[#fA+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,d(C+0.5)+lh,d(E+0.5)-lh,d(D+0.5)-lh)end;local function li()for _,d0 in pairs(aH)do if d0.hovered then if not d0.drawCondition or d0.drawCondition()then d0.toggleFunction()end;d0.hovered=false end end end;local function lj()local function lk(ll,lm,c8,c9,km,kn)if ll>c8 and ll<c8+km and lm>c9 and lm<c9+kn then return true else return false end end;local c8=ae+aK/2;local c9=af+aL/2;for _,d0 in pairs(aH)do d0.hovered=lk(c8,c9,d0.x,d0.y,d0.width,d0.height)end end;local function ln(fA)local function lo(fA,lp,hover,c8,c9,eO,lq,lr,ls,lt,lu)if type(lt)=="function"then lt=lt()end;if type(lu)=="function"then lu=lu()end;fA[#fA+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",c8,c9,eO,lq)if lp then fA[#fA+1]=e("%s'",lr)else fA[#fA+1]=ls end;if hover then fA[#fA+1]=" style='stroke:white; stroke-width:2'"else fA[#fA+1]=" style='stroke:black; stroke-width:1'"end;fA[#fA+1]="></rect>"fA[#fA+1]=e("<text x='%f' y='%f' font-size='24' fill='",c8+eO/2,c9+lq/2+5)if lp then fA[#fA+1]="black"else fA[#fA+1]="white"end;fA[#fA+1]="' text-anchor='middle' font-family='Montserrat'>"if lp then fA[#fA+1]=e("%s</text>",lt)else fA[#fA+1]=e("%s</text>",lu)end end;local lv="rgb(50,50,50)'"local lw="rgb(210,200,200)"local lx=lo;for _,d0 in pairs(aH)do local kl=d0.disableName;local kk=d0.enableName;if type(kl)=="function"then kl=kl()end;if type(kk)=="function"then kk=kk()end;if not d0.drawCondition or d0.drawCondition()then lx(fA,d0.toggleVar(),d0.hovered,d0.x,d0.y,d0.width,d0.height,lw,lv,kl,kk)end end end;local fA={}bb.HUDPrologue(fA)if showHud then bb.UpdateHud(fA)else if AlwaysVSpd then bb.DrawVerticalSpeed(fA,at)end;bb.DisplayOrbitScreen(fA)bb.DrawWarnings(fA)end;if bU and bV~={}then bb.DrawSettings(fA)end;bb.HUDEpilogue(fA)fA[#fA+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aK,aL)if Z~="empty"then bb.DisplayMessage(fA,Z)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then bb.DrawDeadZone(fA)end end;if w()==0 then if l()==1 and Y then lj()ln(fA)if not be and not bf then local ly=table.concat(fA,"")fA={}fA[#fA+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fA[#fA+1]=ly;fA[#fA+1]="</body>"be=true;fA[#fA+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(fA,"")system.setScreen(content)elseif bf then local ly=table.concat(fA,"")fA={}fA[#fA+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aK,aL)fA[#fA+1]=ly;fA[#fA+1]="</body>"end;if not be then fA[#fA+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],K,L,ae,af)end else li()end else if not Y and l()==0 then li()if ah>DeadZone then if DisplayDeadZone then lg(fA)end end else lj()ln(fA)end;fA[#fA+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],K,L,ae,af)end;fA[#fA+1]=[[</svg></body>]]content=table.concat(fA,"")if not DidLogOutput then system.logInfo(LastContent)DidLogOutput=true end elseif kN=="apTick"then bd.APTick()end end;function script.onFlush()local function lz(lA,jt)local lB=vec3()local lC=vec3()if lA==axisCommandId.longitudinal then lB=vec3(core.getConstructOrientationForward())lC=bF elseif lA==axisCommandId.vertical then lB=vec3(core.getConstructOrientationUp())lC=bE elseif lA==axisCommandId.lateral then lB=vec3(core.getConstructOrientationRight())lC=bG else return vec3()end;local lD=vec3(core.getWorldGravity())local lE=lD:dot(lC)local lF=vec3(core.getWorldAirFrictionAcceleration())local lG=lF:dot(lC)local lH=vec3(core.getVelocity())local lI=lH:dot(lB)local lJ=jt*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(lJ-lI)local lK=targetSpeedPID2:get()local lL=(lK-lG-lE)*lC;return lL end;local function lM(lA,jt)local lB=vec3()local lC=vec3()if lA==axisCommandId.longitudinal then lB=vec3(core.getConstructOrientationForward())lC=bF elseif lA==axisCommandId.vertical then lB=vec3(core.getConstructOrientationUp())lC=bE elseif lA==axisCommandId.lateral then lB=vec3(core.getConstructOrientationRight())lC=bG else return vec3()end;local lD=vec3(core.getWorldGravity())local lE=lD:dot(lC)local lF=vec3(core.getWorldAirFrictionAcceleration())local lG=lF:dot(lC)local lH=vec3(core.getVelocity())local lI=lH:dot(lB)local lJ=jt*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(lJ-lI)local lK=targetSpeedPID:get()local lL=(lK-lG-lE)*lC;return lL end;local function lN(lO,g3,ij)local lP=lO:cross(ij):normalize_inplace()local gP=math.acos(q(lP:dot(-g3),-1,1))*constants.rad2deg;if lP:cross(-g3):dot(ij)<0 then gP=-gP end;return gP end;if antigrav and not ExternalAGG then if not bP and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bR=r:getAxisCommandType(0)==axisCommandType.byThrottle;if bR and J then cd(0)J=false elseif not bR and not J then F=0;J=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local lQ=q(Q+R+system.getControlDeviceForwardInput(),-1,1)local lR=q(T+W+system.getControlDeviceYawInput(),-1,1)local lS=q(U+S-system.getControlDeviceLeftRightInput(),-1,1)local lT=V;bJ=vec3(core.getWorldVertical())if bJ==nil or bJ:len()==0 then bJ=(planet.center-bL):normalize()end;bL=vec3(core.getConstructWorldPos())bE=vec3(core.getConstructWorldOrientationUp())bF=vec3(core.getConstructWorldOrientationForward())bG=vec3(core.getConstructWorldOrientationRight())bH=vec3(core.getWorldVelocity())aw=core.getConstructMass()bI=vec3(bH):len()bK=-bJ:dot(bH)bT=getRoll(bJ,bF,bG)local lU=bT/180*math.pi;local lV=math.cos(lU)local lW=math.sin(lU)bS=lN(bJ,bF,bG*lV+bE*lW)local lX=bH:normalize()local lY=getRoll(bJ,bF,bG)local lZ=c(lY)local l_=utils.sign(lY)local m0=vec3(core.getWorldAngularVelocity())local m1=lQ*pitchSpeedFactor*bG+lR*rollSpeedFactor*bF+lS*yawSpeedFactor*bE;if bJ:len()>0.01 and(as>0.0 or ProgradeIsOn or Reentry or al or AltitudeHold or IntoOrbit)then if bg==true and c(bk-lY)>autoRollRollThreshold and lR==0 and c(bS)<85 then local m2=bk;local m3=autoRollFactor;if as==0 then m3=m3/4;bk=0;m2=0 end;if rollPID==nil then rollPID=pid.new(m3*0.01,0,m3*0.1)end;rollPID:inject(m2-lY)local m4=rollPID:get()m1=m1+m4*bF end end;if bJ:len()>0.01 and as>0.0 then local m5=20.0;if turnAssist==true and lZ>m5 and lQ==0 and lS==0 then local m6=turnAssistFactor*0.1;local m7=turnAssistFactor*0.025;local m8=(lZ-m5)/(180-m5)*180;local m9=0;if m8<90 then m9=m8/90 elseif m8<180 then m9=(180-m8)/90 end;m9=m9*m9;local ma=-l_*m7*(1.0-m9)local mb=m6*m9;m1=m1+mb*bG+ma*bE end end;local mc=1;local md=0;local me=1;if system.getMouseWheel()>0 then if AltIsOn then if as>0 or Reentry then bn=q(bn+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local mf=F;F=x(q(F+speedChangeLarge/100,-1,1),2)if F>=0 and mf<0 then F=0;ax=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if as>0 or Reentry then bn=q(bn-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=q(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif ax then local mf=F;F=x(q(F-speedChangeLarge/100,-1,1),2)if F<=0 and mf>0 then F=0;ax=false end end else ax=true end;G=0;if ar and AtmoSpeedAssist and bR then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bn/3.6-bH:dot(bF))local mg=throttlePID:get()I=q(mg,-1,1)if I<F and as>0.005 then H=true;r:setThrottleCommand(axisCommandId.longitudinal,q(I,0.01,1))else H=false;r:setThrottleCommand(axisCommandId.longitudinal,F)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-bn/3.6)local mh=q(brakePID:get(),0,1)if as>0 and bK<-80 or as>0.005 then G=mh end;if G>0 then if H and I==0.01 then r:setThrottleCommand(axisCommandId.longitudinal,0)end else I=q(I,0.01,1)end;local mi=''local mj=vec3()local mk=lz(axisCommandId.vertical,ad*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",mk,md)local ml='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then ml=ml..ExtraLongitudeTags end;local mm=r:getAxisCommandType(axisCommandId.longitudinal)local mn=r:composeAxisAccelerationFromThrottle(ml,axisCommandId.longitudinal)local mo=lM(axisCommandId.lateral,LeftAmount*1000)mi=mi..' , '.."lateral airfoil , lateral ground "mj=mj+mo;if mj:len()>constants.epsilon then a:setEngineForceCommand(mi,mj,md,'','','',me)end;a:setEngineForceCommand(ml,mn,mc)local mp='thrust analog vertical fueled 'local mq='thrust analog lateral fueled 'if ExtraLateralTags~="none"then mq=mq..ExtraLateralTags end;if ExtraVerticalTags~="none"then mp=mp..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mp,mk,mc)else a:setEngineForceCommand(mp,vec3(),mc)end;if LeftAmount~=0 then a:setEngineForceCommand(mq,mo,mc)else a:setEngineForceCommand(mq,vec3(),mc)end;if lT==0 then lT=G end;local mr=-lT*(brakeSpeedFactor*bH+brakeFlatFactor*lX)a:setEngineForceCommand('brake',mr)else if AtmoSpeedAssist then r:setThrottleCommand(axisCommandId.longitudinal,F)end;local jt=unit.getAxisCommandValue(0)if not bR then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(bH:len()-jt/3.6)local mh=q(brakePID:get(),0,1)lT=q(lT+mh,0,1)end;local mr=-lT*(brakeSpeedFactor*bH+brakeFlatFactor*lX)a:setEngineForceCommand('brake',mr)local mi=''local mj=vec3()local ms=false;local ml='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then ml=ml..ExtraLongitudeTags end;local mm=r:getAxisCommandType(axisCommandId.longitudinal)if mm==axisCommandType.byThrottle then local mn=r:composeAxisAccelerationFromThrottle(ml,axisCommandId.longitudinal)a:setEngineForceCommand(ml,mn,mc)elseif mm==axisCommandType.byTargetSpeed then local mn=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)mi=mi..' , '..ml;mj=mj+mn;if r:getTargetSpeed(axisCommandId.longitudinal)==0 or r:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-r:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ms=true end end;local mq='thrust analog lateral 'if ExtraLateralTags~="none"then mq=mq..ExtraLateralTags end;local mt=r:getAxisCommandType(axisCommandId.lateral)if mt==axisCommandType.byThrottle then local mu=r:composeAxisAccelerationFromThrottle(mq,axisCommandId.lateral)a:setEngineForceCommand(mq,mu,mc)elseif mt==axisCommandType.byTargetSpeed then local mo=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)mi=mi..' , '..mq;mj=mj+mo end;local mp='thrust analog vertical 'if ExtraVerticalTags~="none"then mp=mp..ExtraVerticalTags end;local mv=r:getAxisCommandType(axisCommandId.vertical)if mv==axisCommandType.byThrottle then local mk=r:composeAxisAccelerationFromThrottle(mp,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(mp,mk,mc,'airfoil','ground','',me)else a:setEngineForceCommand(mp,vec3(),mc)a:setEngineForceCommand('airfoil vertical',mk,mc,'airfoil','','',me)a:setEngineForceCommand('ground vertical',mk,mc,'ground','','',me)end elseif mv==axisCommandType.byTargetSpeed then if ad<0 then a:setEngineForceCommand('hover',vec3(),mc)end;local mw=r:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)mi=mi..' , '..mp;mj=mj+mw end;if mj:len()>constants.epsilon then if V~=0 or ms or c(lX:dot(bF))<0.8 then mi=mi..', brake'end;a:setEngineForceCommand(mi,mj,md,'','','',me)end end;local mx=torqueFactor*(m1-m0)local my=vec3(core.getWorldAirFrictionAngularAcceleration())mx=mx-my;a:setEngineTorqueCommand('torque',mx,mc,'airfoil','','',me)a:setBoosterCommand('rocket_engine')if a4 and not VanillaRockets then local eV=vec3(core.getVelocity()):len()local mz=0.15;if not bR then local mA=r:getTargetSpeed(axisCommandId.longitudinal)if eV*3.6>mA*(1-mz)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eV*3.6<mA*(1-mz)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jm=unit.getThrottle()if AtmoSpeedAssist then jm=F*100 end;local jt=jm/100;if j==0 then jt=jt*MaxGameVelocity;if eV>=jt*(1-mz)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eV<jt*(1-mz)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local jz=d(bn)jt=jt*jz/3.6;if eV>=jt*(1-mz)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eV<jt*(1-mz)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local _,cn=coroutine.resume(beginSetup)if cn then SetupComplete=true end else a:update()if not be and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(mB)local A=1;local function mC(mD)if mD then A=-1 end;if not ExternalAGG and bP then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+A*a1;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+A*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+A*a0;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+A*a0 end else r:updateTargetGroundAltitudeFromActionStart(A*1.0)end end;local function mE(mD)if mD then A=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then F=q(F+A*speedChangeLarge/100,-1,1)else r:updateCommandFromActionStart(axisCommandId.longitudinal,A*speedChangeLarge)end else if mD then A=1 else A=nil end;bc.adjustAutopilotTargetIndex(A)end end;if mB=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cd(0)if vBooster or hover then if ar and ao==-1 then StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;bg=true;GearExtended=false elseif ar then BrakeIsOn=true;a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)else a.control.extendLandingGears()r:setTargetGroundAltitude(LandingGearGroundHeight)end end;if P and not BrakeLanding then a.control.extendLandingGears()end else if P then a.control.retractLandingGears()end;r:setTargetGroundAltitude(TargetHoverHeight)end elseif mB=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif mB=="forward"then Q=Q-1 elseif mB=="backward"then Q=Q+1 elseif mB=="left"then T=T-1 elseif mB=="right"then T=T+1 elseif mB=="yawright"then U=U-1 elseif mB=="yawleft"then U=U+1 elseif mB=="straferight"then r:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif mB=="strafeleft"then r:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif mB=="up"then ad=ad+1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif mB=="down"then ad=ad-1;r:deactivateGroundEngineAltitudeStabilization()r:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif mB=="groundaltitudeup"then mC()elseif mB=="groundaltitudedown"then mC(true)elseif mB=="option1"then bc.adjustAutopilotTargetIndex()toggleView=false elseif mB=="option2"then bc.adjustAutopilotTargetIndex(1)toggleView=false elseif mB=="option3"then local function mF()aG=not aG;if not aG then unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else unit.hide()core.hide()if fuelPanelID~=nil then s(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then s(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then s(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;mF()toggleView=false elseif mB=="option4"then ct()toggleView=false elseif mB=="option5"then local function mG()if LockPitch==nil then LockPitch=bS;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else LockPitch=nil end end;mG()toggleView=false elseif mB=="option6"then cr()toggleView=false elseif mB=="option7"then toggleView=false elseif mB=="option8"then cs()toggleView=false elseif mB=="option9"then if gyro~=nil then gyro.toggle()ay=gyro.getState()==1 end;toggleView=false elseif mB=="lshift"then if w()==1 then Y=true;PrevViewLock=w()v(1)elseif l()==1 and ShiftShowsRemoteButtons then Y=true;bf=false;be=false end elseif mB=="brake"then if BrakeToggleStatus then cB()elseif not BrakeIsOn then cB()else BrakeIsOn=true end elseif mB=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(1)end elseif mB=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a4 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a4=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a4=false end elseif mB=="stopengines"then local function mH()if ap then ap=false;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;X=false;M=false;al=false;am=false;O=false;bg=autoRollPreference;VectorToTarget=false;TurnBurn=false;ay=false;LockPitch=nil;IntoOrbit=false else ap=true end end;r:resetCommand(axisCommandId.longitudinal)mH()F=0 elseif mB=="speedup"then mE()elseif mB=="speeddown"then mE(true)elseif mB=="antigravity"and not ExternalAGG then if antigrav~=nil then cQ()end end end;function script.onActionStop(mB)local function mI()if not ExternalAGG and bP then a3=a1 end;if AltitudeHold or VertTakeOff or IntoOrbit then a2=a0 end end;if mB=="forward"then Q=0 elseif mB=="backward"then Q=0 elseif mB=="left"then T=0 elseif mB=="right"then T=0 elseif mB=="yawright"then U=0 elseif mB=="yawleft"then U=0 elseif mB=="straferight"then r:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif mB=="strafeleft"then r:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif mB=="up"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,-1.0)r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mB=="down"then ad=0;r:updateCommandFromActionStop(axisCommandId.vertical,1.0)r:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)elseif mB=="groundaltitudeup"then mI()toggleView=false elseif mB=="groundaltitudedown"then mI()toggleView=false elseif mB=="lshift"then if w()==1 then Y=false;ae=0;af=0;v(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then Y=false;bf=false;be=false end elseif mB=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cB()else BrakeIsOn=false end end elseif mB=="lalt"then if l()==0 and freeLookToggle then if toggleView then if w()==1 then v(0)else v(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then v(0)end;AltIsOn=false end end;function script.onActionLoop(mB)local A=1;local function mJ(mD)if mD then A=-1 end;if not ExternalAGG and bP then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+A*a3;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a3=a3*1.05;BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+A*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bw=bw+A*a2;if bw<planet.noAtmosphericDensityAltitude then bw=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+A*a2 end;a2=a2*1.05 else r:updateTargetGroundAltitudeFromActionLoop(A*1.0)end end;local function mK(mD)if mD then A=-1 end;if not Y then if AtmoSpeedAssist and not AltIsOn then F=q(F+A*speedChangeSmall/100,-1,1)else r:updateCommandFromActionLoop(axisCommandId.longitudinal,A*speedChangeSmall)end end end;if mB=="groundaltitudeup"then mJ()elseif mB=="groundaltitudedown"then mJ(true)elseif mB=="speedup"then mK()elseif mB=="speeddown"then mK(true)end end;function script.onInputText(ca)local function mL()for c_,d0 in pairs(c0())do dbHud_1.setStringValue(d0,g(nil))end;for c_,d0 in pairs(b)do if d0~="SavedLocations"then dbHud_1.setStringValue(d0,g(nil))end end;Z="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ag=5;aM=false;ac=true end;local function mM(mN,planet,eZ)local function mO(eZ)local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local df='::pos{'..y..','..y..','..y..','..y..','..y..'}'local dt,du,dB,dC,dD=n(eZ,df)if dt=="0"and du=="0"then return vec3(tonumber(dB),tonumber(dC),tonumber(dD))end;dC=math.rad(dC)dB=math.rad(dB)local planet=b2[tonumber(dt)][tonumber(du)]local ep=math.cos(dB)local mP=vec3(ep*math.cos(dC),ep*math.sin(dC),math.sin(dB))return planet.center+(planet.radius+dD)*mP end;if dbHud_1 then local cz={}local position=mO(eZ)if planet.name=="Space"then cz={position=position,name=mN,atmosphere=0,planetname=planet.name,gravity=planet.gravity}else cz={position=position,name=mN,atmosphere=planet.atmosphericDensityAboveSurface,planetname=planet.name,gravity=planet.gravity}end;SavedLocations[#SavedLocations+1]=cz;table.insert(b2[0],cz)bc.UpdateAtlasLocationsList()else Z="Databank must be installed to save locations"end end;local i;local mQ="/commands /setname /G /agg /addlocation /copydatabank /wipedatabank /posWP"local mR,mS=nil,nil;local mT="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all updatable variables with /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572} - adds a saved location by waypoint, not as accurate as making one at location\n".."/copydatabank - copies dbHud databank to a blank databank\n/wipedatabank - wipes the databank of all hud variables but not save variables\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(ca," ")mR=ca;if i~=nil then mR=string.sub(ca,0,i-1)mS=string.sub(ca,i+1)end;if mR=="/help"or mR=="/commands"then for i6 in string.gmatch(mT,"([^\n]+)")do system.print(i6)end;return elseif mR=="/setname"then if mS==nil or mS==""then Z="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then cw(mS)else Z="Select a saved target to rename first"end elseif mR=="/addlocation"then if mS==nil or mS==""or string.find(mS,"::")==nil then Z="Usage: ah-addlocation savename ::pos{0,2,46.4596,-155.1799,22.6572}"return end;i=string.find(mS,"::")local mN=string.sub(mS,1,i-2)local eZ=string.sub(mS,i)local y=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local df='::pos{'..y..','..y..','..y..','..y..','..y..'}'local dt,du,dB,dC,dD=n(eZ,df)local planet=b2[tonumber(dt)][tonumber(du)]mM(mN,planet,eZ)Z="Added "..mN.." to saved locations,\nplanet "..planet.name.." at "..eZ;ag=5 elseif mR=="/agg"then if mS==nil or mS==""then Z="Usage: ah-agg targetheight"return end;mS=tonumber(mS)if mS<1000 then mS=1000 end;AntigravTargetAltitude=mS;Z="AGG Target Height set to "..mS elseif mR=="/G"then if mS==nil or mS==""then Z="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if mS=="dump"then for c_,d0 in pairs(c0())do if type(_G[d0])=="boolean"then if _G[d0]==true then system.print(d0 .." true")else system.print(d0 .." false")end elseif _G[d0]==nil then system.print(d0 .." nil")else system.print(d0 .." ".._G[d0])end end;return end;i=string.find(mS," ")local mU=string.sub(mS,0,i-1)local mV=string.sub(mS,i+1)for c_,d0 in pairs(c0())do if d0==mU then Z="Variable "..mU.." changed to "..mV;local mW=type(_G[d0])if mW=="number"then mV=tonumber(mV)elseif mW=="boolean"then if string.lower(mV)=="true"then mV=true else mV=false end end;_G[d0]=mV;return end end;Z="No such global variable: "..mU elseif mR=="/copydatabank"then if dbHud_2 then cW(true)else Z="Spare Databank required to copy databank"end elseif mR=="/wipedatabank"then if dbHud_1 then mL()else Z="No databank found."end elseif mR=="/iphWP"then if AutopilotTargetIndex>0 then system.print(bd.showWayPoint(a9,AutopilotTargetCoords,true))Z="::pos waypoint shown in lua chat"else Z="No target selected in IPH"end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
