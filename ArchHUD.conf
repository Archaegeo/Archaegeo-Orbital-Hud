name: ArchHud - Archaegeo v1.705 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        require("autoconf/custom/archhud/globals")local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")require("autoconf/custom/archhud/hudclass")require("autoconf/custom/archhud/apclass")require("autoconf/custom/archhud/radarclass")require("autoconf/custom/archhud/controlclass")script={}VERSION_NUMBER=1.705;local f=math.abs;local g=math.floor;local h=string.format;local j=json.decode;local k=json.encode;local l=b.getElementMaxHitPointsById;local m=c.getAtmosphereDensity;local n=b.getElementMassById;local o=d.control.isRemoteControlled;local q=math.atan;local r=string.match;local s=a.getTime;local t=utils.clamp;local u=d.axisCommandManager;local v=a.destroyWidgetPanel;local w=a.updateData;local x=a.addDataToWidget;local y=a.lockView;local z=a.isViewLocked;local A=math.sqrt;local B=tonumber;local function C(D,E)local F=10^(E or 0)return g(D*F+0.5)/F end;time=s()clearAllCheck=s()local G=13;PrimaryR=SafeR;PrimaryB=SafeB;PrimaryG=SafeG;PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;apThrottleSet=false;minAutopilotSpeed=55;reentryMode=false;hasGear=false;pitchInput=0;pitchInput2=0;yawInput2=0;rollInput=0;yawInput=0;brakeInput=0;rollInput2=0;followMode=false;holdingShift=false;msgText="empty"isBoosting=false;brakeDistance=0;brakeTime=0;local H=0;local I=0;autopilotTargetPlanet=nil;totalDistanceTrip=0;flightTime=0;upAmount=0;simulatedX=0;simulatedY=0;msgTimer=3;distance=0;lastOdometerOutput=""spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;local J=""inAtmo=m()>0;atmosDensity=m()coreAltitude=b.getAltitude()local K=b.getElementIdList()lastTravelTime=s()coreMass=b.getConstructMass()mousePause=false;gyroIsOn=nil;rgb=[[rgb(]]..g(PrimaryR+0.5)..","..g(PrimaryG+0.5)..","..g(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..g(PrimaryR*0.9+0.5)..","..g(PrimaryG*0.9+0.5)..","..g(PrimaryB*0.9+0.5)..[[)]]local L={}damageMessage=""resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;atmoTanks={}spaceTanks={}rocketTanks={}local M=0;repairArrows=false;local N=nil;galaxyReference=nil;Kinematic=nil;maxKinematicUp=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;CONTROL=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;local O=LandingGearGroundHeight;stalling=false;targetRoll=0;adjustedAtmoSpeedLimit=AtmoSpeedLimit;VtPitch=0;orbitMsg=nil;orbitalParams={VectorToTarget=false}OrbitTargetOrbit=0;OrbitAchieved=false;local P=false;SpaceEngineVertDn=false;SpaceEngines=false;constructUp=vec3(b.getConstructWorldOrientationUp())constructForward=vec3(b.getConstructWorldOrientationForward())constructRight=vec3(b.getConstructWorldOrientationRight())coreVelocity=vec3(b.getVelocity())constructVelocity=vec3(b.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(b.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(b.getConstructWorldPos())UpVertAtmoEngine=false;antigravOn=false;setCruiseSpeed=nil;throttleMode=true;adjustedPitch=0;adjustedRoll=0;AtlasOrdered={}notPvPZone=false;pvpDist=50000;ReversalIsOn=nil;contacts={}nearPlanet=c.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;apButtonsHovered=false;apScrollIndex=0;passengers=nil;ships=nil;planetAtlas={}scopeFOV=90;oldShowHud=showHud;function p(Q)a.print(time..": "..Q)end;function play(R,S,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..R.."|"..S.."|"..soundVolume)else a.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..R.."|"..S.."|"..soundVolume)end else a.logInfo("sound_q|audiopacks/"..soundFolder.."/"..R.."|"..S.."|"..soundVolume)end end;function addTable(T,U)for i=1,#U do T[#T+1]=U[i]end;return T end;function saveableVariables(V)local W={}if not V then addTable(W,saveableVariablesBoolean)addTable(W,savableVariablesHandling)addTable(W,savableVariablesHud)addTable(W,savableVariablesPhysics)return W elseif V=="boolean"then return saveableVariablesBoolean elseif V=="handling"then return savableVariablesHandling elseif V=="hud"then return savableVariablesHud elseif V=="physics"then return savableVariablesPhysics end end;local function X(Y,Z,a0,a1,a2)if a1==nil then a1=""end;if a2==nil then a2=""end;return h([[<text class="%s" x=%s y=%s style="%s">%s</text>]],a1,Y,Z,a2,a0)end;function float_eq(a3,a4)if a3==0 then return f(a4)<1e-09 end;if a4==0 then return f(a3)<1e-09 end;return f(a3-a4)<math.max(f(a3),f(a4))*epsilon end;function getDistanceDisplayString(distance,a5)local a6=distance>100000;if a5==nil then a5=1 end;if a6 then return C(distance/1000/200,a5).."SU"elseif distance<1000 then return C(distance,a5).."M"else return C(distance/1000,a5).."KM"end end;function FormatTimeString(a7)local a8=0;local a9=0;local aa=0;if a7<60 then a7=g(a7)elseif a7<3600 then a8=g(a7/60)a7=g(a7%60)elseif a7<86400 then a9=g(a7/3600)a8=g(a7%3600/60)else aa=g(a7/86400)a9=g(a7%86400/3600)end;if aa>0 then return aa.."d "..a9 .."h "elseif a9>0 then return a9 .."h "..a8 .."m "elseif a8>0 then return a8 .."m "..a7 .."s"elseif a7>0 then return a7 .."s"else return"0s"end end;function SaveDataBank(ab)local function ac(ad)for ae,af in pairs(ad)do dbHud_1.setStringValue(af,k(_G[af]))if ab and dbHud_2 then dbHud_2.setStringValue(af,k(_G[af]))end end end;if dbHud_1 then ac(autoVariables)ac(saveableVariables())a.print("Saved Variables to Datacore")if ab and dbHud_2 then msgText="Databank copied.  Remove copy when ready."end end end;local function ag()local function ah(ai)return type(ai)=='number'end;local function aj(ai)return type(B(ai))=='number'end;local function ak(al)return type(al)=='table'end;local function am(a)return type(a)=='string'end;local function an(af)return ak(af)and ah(af.x and af.y and af.z)end;local function ao(ap)return ak(ap)and ah(ap.latitude and ap.longitude and ap.altitude and ap.id and ap.systemId)end;local aq=math.pi/180;local ar=180/math.pi;local epsilon=1e-10;local D=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local as='::pos{'..D..','..D..','..D..','..D..','..D..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function at(ai)local au=string.gsub(string.reverse(h('%.4f',ai)),'^0*%.?','')return au==''and'0'or string.reverse(au)end;local function av(aw)if an(aw)then return h('{x=%.3f,y=%.3f,z=%.3f}',aw.x,aw.y,aw.z)end;if ak(aw)and not getmetatable(aw)then local ax={}local ay=next(aw)if type(ay)=='nil'or ay==1 then ax=aw else for ae,af in pairs(aw)do local az=av(af)if type(ae)=='number'then table.insert(ax,h('[%s]=%s',ae,az))else table.insert(ax,h('%s=%s',ae,az))end end end;return h('{%s}',table.concat(ax,','))end;if am(aw)then return h("'%s'",aw:gsub("'",[[\']]))end;return tostring(aw)end;local aA={}aA.__index=aA;aA.__tostring=function(aw,aB)local aC={}for ae in pairs(aw)do table.insert(aC,ae)end;table.sort(aC)local ax={}for _,ae in ipairs(aC)do local az=av(aw[ae])if type(ae)=='number'then table.insert(ax,h('[%s]=%s',ae,az))else table.insert(ax,h('%s=%s',ae,az))end end;if aB then return h('%s%s',aB,table.concat(ax,',\n'..aB))end;return h('{%s}',table.concat(ax,','))end;aA.__eq=function(aD,aE)return aD.systemId==aE.systemId and aD.id==aE.id and float_eq(aD.radius,aE.radius)and float_eq(aD.center.x,aE.center.x)and float_eq(aD.center.y,aE.center.y)and float_eq(aD.center.z,aE.center.z)and float_eq(aD.GM,aE.GM)end;local function aF(aG,aH,aI,aJ,aK)assert(aj(aG),'Argument 1 (systemId) must be a number:'..type(aG))assert(aj(aH),'Argument 2 (id) must be a number:'..type(aH))assert(aj(aI),'Argument 3 (radius) must be a number:'..type(aI))assert(ak(aJ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(aJ))assert(aj(aK),'Argument 5 (GM) must be a number:'..type(aK))return setmetatable({systemId=B(aG),id=B(aH),radius=B(aI),center=vec3(aJ),GM=B(aK)},aA)end;local aL={}aL.__index=aL;aL.__tostring=function(p)return h('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,at(p.latitude*ar),at(p.longitude*ar),at(p.altitude))end;aL.__eq=function(aD,aE)return aD.id==aE.id and aD.systemId==aE.systemId and float_eq(aD.latitude,aE.latitude)and float_eq(aD.altitude,aE.altitude)and(float_eq(aD.longitude,aE.longitude)or float_eq(aD.latitude,math.pi/2)or float_eq(aD.latitude,-math.pi/2))end;local function aM(aN,aH,aO,aP,aQ)local aG=aN;if am(aN)and not aP and not aQ and not aH and not aO then aG,aH,aO,aP,aQ=r(aN,as)assert(aG,'Argument 1 (position string) is malformed.')else assert(aj(aG),'Argument 1 (systemId) must be a number:'..type(aG))assert(aj(aH),'Argument 2 (id) must be a number:'..type(aH))assert(aj(aO),'Argument 3 (latitude) must be in degrees:'..type(aO))assert(aj(aP),'Argument 4 (longitude) must be in degrees:'..type(aP))assert(aj(aQ),'Argument 5 (altitude) must be in meters:'..type(aQ))end;aG=B(aG)aH=B(aH)aO=B(aO)aP=B(aP)aQ=B(aQ)if aH==0 then return setmetatable({latitude=aO,longitude=aP,altitude=aQ,id=aH,systemId=aG},aL)end;return setmetatable({latitude=aq*t(aO,-90,90),longitude=aq*(aP%360),altitude=aQ,id=aH,systemId=aG},aL)end;local aR={}aR.__index=aR;aR.__tostring=function(aw,aB)local aS=aB and aB..'  'local aT={}local aC={}for ae in pairs(aw)do table.insert(aC,ae)end;table.sort(aC)for _,aU in ipairs(aC)do bdy=aw[aU]local aV=aA.__tostring(bdy,aS)if aB then table.insert(aT,h('[%s]={\n%s\n%s}',aU,aV,aB))else table.insert(aT,h('  [%s]=%s',aU,aV))end end;if aB then return h('\n%s%s%s',aB,table.concat(aT,',\n'..aB),aB)end;return h('{\n%s\n}',table.concat(aT,',\n'))end;local function aW(aX)local e={}local pid;for _,af in pairs(aX)do local aH=af.planetarySystemId;if type(aH)~='number'then error('Invalid planetary s ID: '..tostring(aH))elseif pid and aH~=pid then error('Mistringmatch planetary s IDs: '..aH..' and '..pid)end;local aY=af.bodyId;if type(aY)~='number'then error('Invalid body ID: '..tostring(aY))elseif e[aY]then error('Duplicate body ID: '..tostring(aY))end;setmetatable(af.center,getmetatable(vec3.unit_x))e[aY]=setmetatable(af,aA)pid=aH end;return setmetatable(e,aR)end;N={}local function aZ(aX)return setmetatable({galaxyAtlas=aX or{}},N)end;N.__index=function(al,i)if type(i)=='number'then local a=al.galaxyAtlas[i]return aW(a)end;return rawget(N,i)end;N.__pairs=function(aw)return function(al,ae)local a_,nv=next(al,ae)return a_,nv and aW(nv)end,aw.galaxyAtlas,nil end;N.__tostring=function(aw)local b0={}for _,b1 in pairs(aw or{})do local b2=b1:getPlanetarySystemId()local b3=aR.__tostring(b1,'    ')table.insert(b0,h('  [%s]={%s\n  }',b2,b3))end;return h('{\n%s\n}\n',table.concat(b0,',\n'))end;N.BodyParameters=aF;N.MapPosition=aM;N.PlanetarySystem=aW;function N.createBodyParameters(aG,aH,b4,b5,b6,b7,b8)assert(aj(aG),'Argument 1 (systemId) must be a number:'..type(aG))assert(aj(aH),'Argument 2 (id) must be a number:'..type(aH))assert(aj(b4),'Argument 3 (surfaceArea) must be a number:'..type(b4))assert(ak(b5),'Argument 4 (aPosition) must be an array or vec3:'..type(b5))assert(ak(b6),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(b6))assert(aj(b7),'Argument 6 (altitude) must be in meters:'..type(b7))assert(aj(b8),'Argument 7 (gravityAtPosition) must be number:'..type(b8))local aI=A(b4/4/math.pi)local distance=aI+b7;local b9=vec3(b5)+distance*vec3(b6)local aK=b8*distance*distance;return aF(aG,aH,aI,b9,aK)end;N.isMapPosition=ao;function N:getPlanetarySystem(aN)if i==nil then i=0 end;if nv==nil then nv=0 end;local aG=aN;if ao(aN)then aG=aN.systemId end;if type(aG)=='number'then local a=self.galaxyAtlas[i]if a then if getmetatable(nv)~=aR then a=aW(a)end;return a end end end;function aR:sizeCalculator(ba)return 1.05*ba.radius end;function aR:castIntersections(bb,bc,bd,be,bf,bg)local bh={}if bf then for _,ba in pairs(bf)do table.insert(bh,ba)end else bh=planetAtlas end;if not bg then table.sort(bh,function(bi,bj)local a3=bi.center;local a4=bj.center;return(a3.x-bb.x)^2+(a3.y-bb.y)^2+(a3.z-bb.z)^2<(a4.x-bb.x)^2+(a4.y-bb.y)^2+(a4.z-bb.z)^2 end)end;local bk=bc:normalize()for _,ba in ipairs(bh)do local bl=ba.center-bb;local aI=self:sizeCalculator(ba)local bm=bl:dot(bk)local bn=bm^2-(bl:len2()-aI^2)if bn>=0 then local bo=A(bn)local bp=bm+bo;local bq=bm-bo;if bq>0 then return ba,bp,bq elseif bp>0 then return ba,bp,nil end end end;return nil,nil,nil end;function aR:closestBody(br)assert(type(br)=='table','Invalid coordinates.')local bs,ba;local bt=vec3(br)for _,bu in pairs(self)do local bv=(bu.center-bt):len2()if(not ba or bv<bs)and bu.name~="Space"then ba=bu;bs=bv end end;return ba end;function aR:convertToBodyIdAndWorldCoordinates(aN)local bw=aN;if am(aN)then bw=aM(aN)end;if bw.id==0 then return 0,vec3(bw.latitude,bw.longitude,bw.altitude)end;local bu=self:getBodyParameters(bw)if bu then return bw.id,bu:convertToWorldCoordinates(bw)end end;function aR:getBodyParameters(aN)local aH=aN;if ao(aN)then aH=aN.id end;assert(aj(aH),'Argument 1 (id) must be a number:'..type(aH))return self[aH]end;function aR:getPlanetarySystemId()local _,af=next(self)return af and af.systemId end;function aA:convertToMapPosition(aJ)assert(ak(aJ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(aJ))local bx=vec3(aJ)if self.id==0 then return setmetatable({latitude=bx.x,longitude=bx.y,altitude=bx.z,id=0,systemId=self.systemId},aL)end;local by=bx-self.center;local distance=by:len()local aQ=distance-self.radius;local aO=0;local aP=0;if not float_eq(distance,0)then local bz=q(by.y,by.x)aP=bz>=0 and bz or 2*math.pi+bz;aO=math.pi/2-math.acos(by.z/distance)end;return setmetatable({latitude=aO,longitude=aP,altitude=aQ,id=self.id,systemId=self.systemId},aL)end;function aA:convertToWorldCoordinates(aN)local bw=am(aN)and aM(aN)or aN;if bw.id==0 then return vec3(bw.latitude,bw.longitude,bw.altitude)end;assert(ao(bw),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(bw.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(bw.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local bA=math.cos(bw.latitude)return self.center+(self.radius+bw.altitude)*vec3(bA*math.cos(bw.longitude),bA*math.sin(bw.longitude),math.sin(bw.latitude))end;function aA:getAltitude(aJ)return(vec3(aJ)-self.center):len()-self.radius end;function aA:getDistance(aJ)return(vec3(aJ)-self.center):len()end;function aA:getGravity(aJ)local bB=self.center-vec3(aJ)local bC=bB:len2()return self.GM/bC*bB/A(bC)end;return setmetatable(N,{__call=function(_,...)return aZ(...)end})end;local function bD()local Kinematic={}local bE=30000000/3600;local bF=bE*bE;local bG=100;function Kinematic.computeAccelerationTime(bH,bI,bJ)local bK=bE*math.asin(bH/bE)return(bE*math.asin(bJ/bE)-bK)/bI end;function Kinematic.computeDistanceAndTime(bH,bJ,bL,bM,bN,bO)bN=bN or 0;bO=bO or 0;local bP=bH<=bJ;local bQ=bM*(bP and 1 or-1)/bL;local bR=-bO/bL;local bS=bQ+bR;if bP and bS<=0 or not bP and bS>=0 then return-1,-1 end;local bT,bU=0,0;if bQ~=0 and bN>0 then local bK=math.asin(bH/bE)local bV=math.pi*(bQ/2+bR)local bW=bQ*bN;local bX=bE*math.pi;local af=function(al)local bY=(bV*al-bW*math.sin(math.pi*al/2/bN)+bX*bK)/bX;local bZ=math.tan(bY)return bE*bZ/A(bZ*bZ+1)end;local b_=bP and function(a)return a>=bJ end or function(a)return a<=bJ end;bU=2*bN;if b_(af(bU))then local c0=0;while f(bU-c0)>0.5 do local al=(bU+c0)/2;if b_(af(al))then bU=al else c0=al end end end;local c1=bH;local c2=bU/bG;for c3=1,bG do local c4=af(c3*c2)bT=bT+(c4+c1)*c2/2;c1=c4 end;if bU<2*bN then return bT,bU end;bH=c1 end;local bK=bE*math.asin(bH/bE)local time=(bE*math.asin(bJ/bE)-bK)/bS;local c5=bF*math.cos(bK/bE)/bS;local distance=c5-bF*math.cos((bS*time+bK)/bE)/bS;return distance+bT,time+bU end;function Kinematic.computeTravelTime(bH,bI,distance)if distance==0 then return 0 end;if bI>0 then local bK=bE*math.asin(bH/bE)local c5=bF*math.cos(bK/bE)/bI;return(bE*math.acos(bI*(c5-distance)/bF)-bK)/bI end;if bH==0 then return-1 end;assert(bH>0,'Acceleration and initial speed are both zero.')return distance/bH end;return Kinematic end;local function c6()local vec3=require('cpml.vec3')local ag=ag()local function am(a)return type(a)=='string'end;local function ak(al)return type(al)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(aQ)assert(self.body)local distance=aQ+self.body.radius;if not float_eq(distance,0)then local c7=A(self.body.GM/distance)return A(2)*c7,c7 end;return nil,nil end;function Kepler:orbitalParameters(aN,c8)assert(self.body)assert(ak(aN)or am(aN))assert(ak(c8))local c9=(am(aN)or ag.isMapPosition(aN))and self.body:convertToWorldCoordinates(aN)or vec3(aN)local af=vec3(c8)local ca=c9-self.body.center;local cb=af:len2()local cc=ca:len()local cd=self.body.GM;local ce=((cb-cd/cc)*ca-ca:dot(af)*af)/cd;local a3=cd/(2*cd/cc-cb)local cf=ce:len()local bk=ce:normalize()local cg=a3*(1-cf)local ch=a3*(1+cf)local ci=cg*bk+self.body.center;local cj=cf<=1 and-ch*bk+self.body.center or nil;local ck=A(a3*cd*(1-cf*cf))local cl=cj and 2*math.pi*A(a3^3/cd)local cm=math.acos(ce:dot(ca)/(cf*cc))if ca:dot(af)<0 then cm=-(cm-2*math.pi)end;local cn=math.acos((math.cos(cm)+cf)/(1+cf*math.cos(cm)))local co=cn;if co<0 then co=co+2*math.pi end;local cp=co-cf*math.sin(co)local cq=0;local cr=0;local cs=0;if cl~=nil then cq=cp/(2*math.pi/cl)cr=cl-cq;cs=cr+cl/2;if cm-math.pi>0 then cr=cq;cs=cr+cl/2 end;if cs>cl then cs=cs-cl end end;return{periapsis={position=ci,speed=ck/cg,circularOrbitSpeed=A(cd/cg),altitude=cg-self.body.radius},apoapsis=cj and{position=cj,speed=ck/ch,circularOrbitSpeed=A(cd/ch),altitude=ch-self.body.radius},currentVelocity=af,currentPosition=c9,eccentricity=cf,period=cl,eccentricAnomaly=cn,meanAnomaly=cp,timeToPeriapsis=cr,timeToApoapsis=cs,trueAnomaly=cm}end;local function ct(cu)local bu=ag.BodyParameters(cu.systemId,cu.id,cu.radius,cu.center,cu.GM)return setmetatable({body=bu},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return ct(...)end})end;local function cv()local function cw(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=e[0][0]end;return p end;local function cx()local function cy(cz,cA)return cz.name<cA.name end;AtlasOrdered={}for ae,af in pairs(e[0])do AtlasOrdered[#AtlasOrdered+1]={name=af.name,index=ae}end;table.sort(AtlasOrdered,cy)end;local function cB(cC)for ae,af in pairs(cC)do if af.name and af.name==CustomTarget.name then return ae end end;return-1 end;local function cD()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local cE=AtlasOrdered[AutopilotTargetIndex].index;local cF=e[0][cE]if cF.center then AutopilotTargetName=cF.name;autopilotTargetPlanet=galaxyReference[0][cE]if CustomTarget~=nil then if atmosDensity==0 then if w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if w(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then x(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if w(widgetMaxMassText,widgetMaxMass)~=1 then x(widgetMaxMassText,widgetMaxMass)end;if w(widgetTravelTimeText,widgetTravelTime)~=1 then x(widgetTravelTimeText,widgetTravelTime)end;if w(widgetTargetOrbitText,widgetTargetOrbit)~=1 then x(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=cF;for _,af in pairs(galaxyReference[0])do if af.name==CustomTarget.planetname then autopilotTargetPlanet=af;AutopilotTargetName=CustomTarget.name;break end end;if w(widgetMaxMassText,widgetMaxMass)~=1 then x(widgetMaxMassText,widgetMaxMass)end;if w(widgetTravelTimeText,widgetTravelTime)~=1 then x(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=g(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=g(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function cG(cH)if not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then if cH==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then cD()else local cE=AtlasOrdered[AutopilotTargetIndex].index;local cF=e[0][cE]if cF~=nil and cF.name=="Space"or iphCondition=="Custom Only"and cF.center or iphCondition=="No Moons"and string.find(cF.name,"Moon")~=nil then if cH==nil then cG()else cG(1)end else cD()end end else msgText="Disengage autopilot before changing Interplanetary Helper"play("iph","AP")end end;local function cI()local cJ=-1;cJ=cB(e[0])if cJ>-1 then table.remove(e[0],cJ)end;cJ=-1;cJ=cB(SavedLocations)if cJ~=-1 then msgText=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,cJ)end;cG()cx()end;local function cK(cL,position,cM,cN)if dbHud_1 or cM then local p=cw(position)local cO=p.gravity;if cN then cO=c.getClosestPlanetInfluence()end;local cP={position=position,name=cL,planetname=p.name,gravity=cO,safe=cN}if not cM then SavedLocations[#SavedLocations+1]=cP else for ae,af in pairs(e[0])do if af.name and cL==af.name then table.remove(e[0],ae)end end end;table.insert(e[0],cP)cx()cD()msgText="Location saved as "..cL.."("..p.name..")"else msgText="Databank must be installed to save permanent locations"end end;local cQ={}function cQ.UpdateAtlasLocationsList()cx()end;function cQ.UpdateAutopilotTarget()cD()end;function cQ.adjustAutopilotTargetIndex(cH)cG(cH)end;function cQ.findAtlasIndex(cC)cB(cC)end;function cQ.UpdatePosition(cR)local cJ=cB(SavedLocations)if cJ~=-1 then if cR~=nil then SavedLocations[cJ].name=cR;AutopilotTargetIndex=AutopilotTargetIndex-1;cG()else local cS=SavedLocations[cJ]cS.gravity=c.getClosestPlanetInfluence()cS.position=worldPos;cS.safe=true end;msgText=SavedLocations[cJ].name.." position updated ("..SavedLocations[cJ].planetname..")"else msgText="Name Not Found"end end;function cQ.AddNewLocation(cL,position,cM,cN)cK(cL,position,cM,cN)end;function cQ.ClearCurrentPosition()cI()end;for ae,af in pairs(SavedLocations)do table.insert(e[0],af)end;cx()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;cQ.UpdateAutopilotTarget()return cQ end;function script.onStart()local cT=false;local function cU()local function cV(cW)local cX=dbHud_1.hasKey;for ae,af in pairs(cW)do if cX(af)then local au=j(dbHud_1.getStringValue(af))if au~=nil then _G[af]=au;cT=true end end end end;if dbHud_1 then if not useTheseSettings then cV(saveableVariables())coroutine.yield()cV(autoVariables)else cV(autoVariables)msgText="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"msgTimer=5;cT=false end;coroutine.yield()if cT then msgText="Loaded Saved Variables"resolutionWidth=ResolutionX;resolutionHeight=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;rgb=[[rgb(]]..g(PrimaryR+0.5)..","..g(PrimaryG+0.5)..","..g(PrimaryB+0.5)..[[)]]rgbdim=[[rgb(]]..g(PrimaryR*0.9+0.5)..","..g(PrimaryG*0.9+0.5)..","..g(PrimaryB*0.9+0.5)..[[)]]elseif not useTheseSettings then msgText="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then msgText="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else msgText="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then msgText="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function cY()local function cZ(c_,d0)if c_>d0 then d0=c_ end;local d1,d2=0,0;if ContainerOptimization>0 then d1=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then d2=FuelTankOptimization*0.05 end;d0=d0*(1-(d1+d2))return d0 end;local d3=b.getElementNameById;local d4=fuelX~=0 and fuelY~=0;for ae in pairs(K)do local type=b.getElementTypeById(K[ae])if r(type,'^.*Atmospheric Engine$')then if r(tostring(b.getElementTagsById(K[ae])),'^.*vertical.*$')and b.getElementForwardById(K[ae])[3]>0 then UpVertAtmoEngine=true end end;if r(type,'^.*Space Engine$')then SpaceEngines=true;if r(tostring(b.getElementTagsById(K[ae])),'^.*vertical.*$')then local d5=b.getElementForwardById(K[ae])if d5[3]<0 then P=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local d6=l(K[ae])if d6>10000 then G=110 elseif d6>1000 then G=55 elseif d6>150 then G=27 end end;M=M+l(K[ae])if d4 and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local d6=l(K[ae])local d7=n(K[ae])local c_=0;local d8=s()if type=="Atmospheric Fuel Tank"then local d0=400;local d9=35.03;if d6>10000 then d0=51200;d9=5480 elseif d6>1300 then d0=6400;d9=988.67 elseif d6>150 then d0=1600;d9=182.67 end;c_=d7-d9;if fuelTankHandlingAtmo>0 then d0=d0+d0*fuelTankHandlingAtmo*0.2 end;d0=cZ(c_,d0)atmoTanks[#atmoTanks+1]={K[ae],d3(K[ae]),d0,d9,c_,d8}end;if type=="Rocket Fuel Tank"then local d0=320;local d9=173.42;if d6>65000 then d0=40000;d9=25740 elseif d6>6000 then d0=5120;d9=4720 elseif d6>700 then d0=640;d9=886.72 end;c_=d7-d9;if fuelTankHandlingRocket>0 then d0=d0+d0*fuelTankHandlingRocket*0.1 end;d0=cZ(c_,d0)rocketTanks[#rocketTanks+1]={K[ae],d3(K[ae]),d0,d9,c_,d8}end;if type=="Space Fuel Tank"then local d0=600;local d9=35.03;if d6>10000 then d0=76800;d9=5480 elseif d6>1300 then d0=9600;d9=988.67 elseif d6>150 then d0=2400;d9=182.67 end;c_=d7-d9;if fuelTankHandlingSpace>0 then d0=d0+d0*fuelTankHandlingSpace*0.2 end;d0=cZ(c_,d0)spaceTanks[#spaceTanks+1]={K[ae],d3(K[ae]),d0,d9,c_,d8}end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function da()if gyro~=nil then gyroIsOn=gyro.getState()==1 end;if not stablized then u:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then y(1)else y(0)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,af in pairs(door)do af.toggle()end end;if switch then for _,af in pairs(switch)do af.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,af in pairs(forcefield)do af.toggle()end end;if antigrav then antigravOn=antigrav.getState()==1;if antigravOn and not ExternalAGG then antigrav.show()end end;if o()==1 and RemoteFreeze then a.freeze(1)else a.freeze(0)end;if hasGear then GearExtended=d.control.isAnyLandingGearExtended()==1;if GearExtended then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if abvGndDet~=-1 or not inAtmo and coreVelocity:len()<50 then BrakeIsOn=true;GearExtended=true;if hasGear then d.control.extendLandingGears()end else BrakeIsOn=false end;u:setTargetGroundAltitude(O)if inAtmo and abvGndDet~=-1 then maxKinematicUp=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;WasInAtmo=inAtmo end;local function db()local dc={}local function dd()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local de={[1]=4480,[6]=4480,[7]=6270}for df,dg in pairs(e)do e[df][0]=dd()e[df][0].systemId=df;dc[df]={}for dh,planet in pairs(e[df])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=de[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=df;planet.bodyId=planet.id;dc[df][dh]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then planetAtlas[#planetAtlas+1]=planet end end end;N=ag()galaxyReference=N(dc)Kinematic=bD()Kep=c6()ATLAS=cv()end;SetupComplete=false;beginSetup=coroutine.create(function()u:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})cU()coroutine.yield()cY()coroutine.yield()AP=APClass(d,b,c,a,e,vBooster,hover,telemeter_1,antigrav,f,g,m,o,q,s,t,u,w,z,A,C)da()coroutine.yield()db()RADAR=RadarClass(b,a,library,radar_1,radar_2,f,v,A,X,B,G)HUD=HudClass(d,b,c,a,e,radar_1,radar_2,antigrav,hover,shield_1,f,g,h,j,m,n,o,q,s,t,u,v,z,A,C,X)HUD.ButtonSetup()CONTROL=ControlClass(d,b,c,a,e,vBooster,hover,antigrav,shield_1,dbHud_2,o,u,z,y,v,C,r,B,t)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",apTickRate)c.setTimer("radarTick",apTickRate)c.setTimer("hudTick",hudTickRate)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)play("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,af in pairs(door)do af.toggle()end end;if switch then for _,af in pairs(switch)do af.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,af in pairs(forcefield)do af.toggle()end end;showHud=oldShowHud;SaveDataBank()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;play("stop","SU")end;function script.onTick(di)local dj=nil;if di=="contact"then if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then msgText="Radar Contact"play("rdrCon","RC")contactTimer=time end;c.stopTimer("contact")elseif di=="tenthSecond"then local function dk()local dl=a.createData;local dm=a.createWidget;panelInterplanetary=a.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=dm(panelInterplanetary,"value")interplanetaryHeaderText=dl('{"label": "Target Planet", "value": "N/A", "u":""}')x(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=dm(panelInterplanetary,"value")widgetDistanceText=dl('{"label": "distance", "value": "N/A", "u":""}')x(widgetDistanceText,widgetDistance)widgetTravelTime=dm(panelInterplanetary,"value")widgetTravelTimeText=dl('{"label": "Travel Time", "value": "N/A", "u":""}')x(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=dm(panelInterplanetary,"value")widgetMaxMassText=dl('{"label": "Maximum Mass", "value": "N/A", "u":""}')x(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=dm(panelInterplanetary,"value")widgetTargetOrbitText=dl('{"label": "Target Altitude", "value": "N/A", "u":""}')x(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=dm(panelInterplanetary,"value")widgetCurBrakeDistanceText=dl('{"label": "Cur Brake distance", "value": "N/A", "u":""}')widgetCurBrakeTime=dm(panelInterplanetary,"value")widgetCurBrakeTimeText=dl('{"label": "Cur Brake Time", "value": "N/A", "u":""}')widgetMaxBrakeDistance=dm(panelInterplanetary,"value")widgetMaxBrakeDistanceText=dl('{"label": "Max Brake distance", "value": "N/A", "u":""}')widgetMaxBrakeTime=dm(panelInterplanetary,"value")widgetMaxBrakeTimeText=dl('{"label": "Max Brake Time", "value": "N/A", "u":""}')widgetTrajectoryAltitude=dm(panelInterplanetary,"value")widgetTrajectoryAltitudeText=dl('{"label": "Projected Altitude", "value": "N/A", "u":""}')if not inAtmo then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)x(widgetCurBrakeTimeText,widgetCurBrakeTime)x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function dn()v(panelInterplanetary)panelInterplanetary=nil end;local function dp()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local c4=velMag;local dq=c.getThrottle()/100;if AtmoSpeedAssist then dq=PlayerThrottle end;local dr,ds=Kinematic.computeDistanceAndTime(velMag,MaxGameVelocity,coreMass,d:maxForceForward()*dq,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,dt;if not TurnBurn and c4>0 then _,dt=AP.GetAutopilotBrakeDistanceAndTime(c4)else _,dt=AP.GetAutopilotTBBrakeDistanceAndTime(c4)end;local du=0;local dv=0;if AutopilotCruising or not Autopilot and c4>5 then dv=Kinematic.computeTravelTime(c4,0,AutopilotDistance)elseif brakeDistance+dr<AutopilotDistance then du=AutopilotDistance-(brakeDistance+dr)dv=Kinematic.computeTravelTime(8333.0556,0,du)else local dw=(AutopilotDistance-brakeDistance)/dr;dr=AutopilotDistance-brakeDistance;ds=ds*dw end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return dv elseif AutopilotBraking then return dt elseif AutopilotCruising then return dv+dt else return ds+brakeTime+dv end end;local function dx(cO,dy)if cO==nil then cO=b.g()end;cO=C(cO,5)if dy~=nil and dy or(dj==nil or dj~=cO)then local c4=coreVelocity:len()local dz=j(c.getData()).maxBrake;if dz~=nil and dz>0 and inAtmo then dz=dz/t(c4/100,0.1,1)dz=dz/atmosDensity;if atmosDensity>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+dz)/2 else LastMaxBrakeInAtmo=dz end end end;if dz~=nil and dz>0 then LastMaxBrake=dz end;dj=cO end end;dx(nil,true)if setCruiseSpeed~=nil then if u:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or u:getTargetSpeed(axisCommandId.longitudinal)~=setCruiseSpeed then AP.cmdCruise(setCruiseSpeed)else setCruiseSpeed=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then dk()end;if AutopilotTargetName~=nil then local dA=CustomTarget~=nil;local dB=0.5*LastMaxBrakeInAtmo/autopilotTargetPlanet:getGravity(autopilotTargetPlanet.center+vec3(0,0,1)*autopilotTargetPlanet.radius):len()dB=dB>1000000 and C(dB/1000000,2).." kTons"or C(dB/1000,2).." Tons"w(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "u":""}')travelTime=dp()if dA and not Autopilot then distance=(worldPos-CustomTarget.position):len()else distance=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)H,I=AP.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)H,I=AP.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local dC=getDistanceDisplayString(distance)w(widgetDistanceText,'{"label": "distance", "value": "'..dC..'"}')w(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..FormatTimeString(travelTime)..'", "u":""}')dC=getDistanceDisplayString(brakeDistance)w(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..dC..'"}')w(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..FormatTimeString(brakeTime)..'", "u":""}')dC=getDistanceDisplayString(H)w(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..dC..'"}')w(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..FormatTimeString(I)..'", "u":""}')w(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..h("%s",dB)..'", "u":""}')dC=getDistanceDisplayString(AutopilotTargetOrbit)w(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..dC..'"}')if atmosDensity>0 and not WasInAtmo then a.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)a.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)a.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)a.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)a.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then AP.cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if atmosDensity==0 and WasInAtmo then if w(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then x(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if w(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then x(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if w(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then x(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if w(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then x(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if w(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then x(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else dn()end;if warpdrive~=nil then if j(warpdrive.getData()).destination~="Unknown"and j(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;HUD.TenthTick()elseif di=="oneSecond"then local function dD(dE)local dF=0;damageMessage=""local dG=M;local dH=0;local dI=0;local dJ=0;local dK=0;local dL=""local dM=b.getElementHitPointsById;for ae in pairs(K)do local d6=0;local dN=0;dN=l(K[ae])d6=dM(K[ae])dH=dH+d6;if d6<dN then if d6==0 then dJ=dJ+1 else dI=dI+1 end;if repairArrows and#L==0 then position=vec3(b.getElementPositionById(K[ae]))local Y=position.x;local Z=position.y;local dO=position.z;table.insert(L,b.spawnArrowSticker(Y,Z,dO+1,"down"))table.insert(L,b.spawnArrowSticker(Y,Z,dO+1,"down"))b.rotateSticker(L[2],0,0,90)table.insert(L,b.spawnArrowSticker(Y+1,Z,dO,"north"))table.insert(L,b.spawnArrowSticker(Y+1,Z,dO,"north"))b.rotateSticker(L[4],90,90,0)table.insert(L,b.spawnArrowSticker(Y-1,Z,dO,"south"))table.insert(L,b.spawnArrowSticker(Y-1,Z,dO,"south"))b.rotateSticker(L[6],90,-90,0)table.insert(L,b.spawnArrowSticker(Y,Z-1,dO,"east"))table.insert(L,b.spawnArrowSticker(Y,Z-1,dO,"east"))b.rotateSticker(L[8],90,0,90)table.insert(L,b.spawnArrowSticker(Y,Z+1,dO,"west"))table.insert(L,b.spawnArrowSticker(Y,Z+1,dO,"west"))b.rotateSticker(L[10],-90,0,90)table.insert(L,K[ae])end elseif repairArrows and#L>0 and L[11]==K[ae]then for dP in pairs(L)do b.deleteSticker(L[dP])end;L={}end end;dF=g(dH/dG*100)if dF<100 then dE[#dE+1]=X(0,0,"","pbright txt")dK=g(dF*2.55)dL=h("rgb(%d,%d,%d)",255-dK,dK,0)if dF<100 then dE[#dE+1]=X("50%",1035,"Elemental Integrity: "..dF.."%","txtbig txtmid","fill:"..dL)if dJ>0 then dE[#dE+1]=X("50%",1055,"Disabled Modules: "..dJ.." Damaged Modules: "..dI,"txtbig txtmid","fill:"..dL)elseif dI>0 then dE[#dE+1]=X("50%",1055,"Damaged Modules: "..dI,"txtbig txtmid","fill:"..dL)end end end end;local function dQ()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,"Weapons","weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then v(WeaponPanelID)WeaponPanelID=nil end end end;local function dR()local d8=s()local dS=velMag;local dT=d8-lastTravelTime;if dS>1.38889 then dS=dS/1000;local dU=dS*(d8-lastTravelTime)TotalDistanceTravelled=TotalDistanceTravelled+dU;totalDistanceTrip=totalDistanceTrip+dU end;flightTime=flightTime+dT;TotalFlightTime=TotalFlightTime+dT;lastTravelTime=d8 end;dR()passengers=b.getPlayersOnBoard()ships=b.getDockedConstructs()dQ()local dE={}HUD.OneSecond(dE)if ShouldCheckDamage then dD(dE)end;lastOdometerOutput=table.concat(dE,"")collectgarbage("collect")elseif di=="fiveSecond"then if not UseSatNav then return end;J=dbHud_1.getStringValue("SPBAutopilotTargetName")if J~=nil and J~=""and J~="SatNavNotChanged"then local au=j(dbHud_1.getStringValue("SavedLocations"))if au~=nil then _G["SavedLocations"]=au;local cJ=-1;local cP;for ae,af in pairs(SavedLocations)do if af.name and af.name=="SatNav Location"then cJ=ae;break end end;if cJ~=-1 then cP=SavedLocations[cJ]cJ=-1;for ae,af in pairs(e[0])do if af.name and af.name=="SatNav Location"then cJ=ae;break end end;if cJ>-1 then e[0][cJ]=cP end;ATLAS.UpdateAtlasLocationsList()msgText=cP.name.." position updated"end end;for i=1,#AtlasOrdered do if AtlasOrdered[i].name==J then AutopilotTargetIndex=i;a.print("Index = "..AutopilotTargetIndex.." "..AtlasOrdered[i].name)ATLAS.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif di=="msgTick"then local dE={}HUD.DisplayMessage(dE,"empty")msgText="empty"c.stopTimer("msgTick")msgTimer=3 elseif di=="animateTick"then Animated=true;Animating=false;simulatedX=0;simulatedY=0;c.stopTimer("animateTick")elseif di=="hudTick"then HUD.hudtick()elseif di=="apTick"then AP.APTick()elseif di=="radarTick"then RADAR.UpdateRadar()elseif di=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;msgText="Extra Engine Tags: "..UseExtra;c.stopTimer("tagTick")end end;function script.onFlush()local function dV(dW,dX)local dY=vec3()local dZ=vec3()if dW==axisCommandId.longitudinal then dY=vec3(b.getConstructOrientationForward())dZ=constructForward elseif dW==axisCommandId.vertical then dY=vec3(b.getConstructOrientationUp())dZ=constructUp elseif dW==axisCommandId.lateral then dY=vec3(b.getConstructOrientationRight())dZ=constructRight else return vec3()end;local d_=vec3(b.getWorldGravity())local e0=d_:dot(dZ)local e1=vec3(b.getWorldAirFrictionAcceleration())local e2=e1:dot(dZ)local e3=coreVelocity:dot(dY)local e4=dX*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(e4-e3)local e5=targetSpeedPID2:get()local e6=(e5-e2-e0)*dZ;return e6 end;local function e7(dW,dX)local dY=vec3()local dZ=vec3()if dW==axisCommandId.longitudinal then dY=vec3(b.getConstructOrientationForward())dZ=constructForward elseif dW==axisCommandId.vertical then dY=vec3(b.getConstructOrientationUp())dZ=constructUp elseif dW==axisCommandId.lateral then dY=vec3(b.getConstructOrientationRight())dZ=constructRight else return vec3()end;local d_=vec3(b.getWorldGravity())local e0=d_:dot(dZ)local e1=vec3(b.getWorldAirFrictionAcceleration())local e2=e1:dot(dZ)local e3=coreVelocity:dot(dY)local e4=dX*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(e4-e3)local e5=targetSpeedPID:get()local e6=(e5-e2-e0)*dZ;return e6 end;local function e8(e9,ea,cA)local eb=e9:cross(cA):normalize_inplace()local ec=math.acos(t(eb:dot(-ea),-1,1))*constants.rad2deg;if eb:cross(-ea):dot(cA)<0 then ec=-ec end;return ec end;if antigrav and not ExternalAGG then if not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;throttleMode=u:getAxisCommandType(0)==axisCommandType.byThrottle;if throttleMode and WasInCruise then AP.cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local ed=t(pitchInput+pitchInput2+a.getControlDeviceForwardInput(),-1,1)local ee=t(rollInput+rollInput2+a.getControlDeviceYawInput(),-1,1)local ef=t(yawInput+yawInput2-a.getControlDeviceLeftRightInput(),-1,1)local eg=brakeInput;worldVertical=vec3(b.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end;constructUp=vec3(b.getConstructWorldOrientationUp())constructForward=vec3(b.getConstructWorldOrientationForward())constructRight=vec3(b.getConstructWorldOrientationRight())constructVelocity=vec3(b.getWorldVelocity())coreVelocity=vec3(b.getVelocity())worldPos=vec3(b.getConstructWorldPos())coreMass=b.getConstructMass()velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local eh=adjustedRoll/180*math.pi;local ei=math.cos(eh)local ej=math.sin(eh)adjustedPitch=e8(worldVertical,constructForward,constructRight*ei+constructUp*ej)local ek=constructVelocity:normalize()local el=f(adjustedRoll)local em=utils.sign(adjustedRoll)local en=vec3(b.getWorldAngularVelocity())local eo=ed*pitchSpeedFactor*constructRight+ee*rollSpeedFactor*constructForward+ef*yawSpeedFactor*constructUp;if autoRoll==true and worldVertical:len()>0.01 then local ep=f(targetRoll-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and ep>0 or atmosDensity>0.0 and ep<autoRollRollThreshold and autoRollPreference)and ee==0 and f(adjustedPitch)<85 then local eq=targetRoll;local er=autoRollFactor;if atmosDensity==0 then er=er/4;targetRoll=0;eq=0 end;if rollPID==nil then rollPID=pid.new(er*0.01,0,er*0.1)end;rollPID:inject(eq-adjustedRoll)local es=rollPID:get()eo=eo+es*constructForward end end;local et=1;local eu=0;local ev=1;local ew=a.getMouseWheel()if ew>0 then p("HERE1")AP.changeSpd()elseif ew<0 then AP.changeSpd(true)else mousePause=true end;brakeInput2=0;if inAtmo and AtmoSpeedAssist and throttleMode then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(adjustedAtmoSpeedLimit/3.6-constructVelocity:dot(constructForward))local ex=throttlePID:get()calculatedThrottle=t(ex,-1,1)if calculatedThrottle<PlayerThrottle and atmosDensity>0.005 then ThrottleLimited=true;u:setThrottleCommand(axisCommandId.longitudinal,t(calculatedThrottle,0.01,1))else ThrottleLimited=false;u:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6)local ey=t(brakePID:get(),0,1)if atmosDensity>0 and vSpd<-80 or atmosDensity>0.005 then brakeInput2=ey end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 then u:setThrottleCommand(axisCommandId.longitudinal,0)end else calculatedThrottle=t(calculatedThrottle,0.01,1)end;local ez=''local eA=vec3()local eB=dV(axisCommandId.vertical,upAmount*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",eB,eu)local eC='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then eC=eC..ExtraLongitudeTags end;local eD=u:getAxisCommandType(axisCommandId.longitudinal)local eE=u:composeAxisAccelerationFromThrottle(eC,axisCommandId.longitudinal)local eF=e7(axisCommandId.lateral,LeftAmount*1000)ez=ez..' , '.."lateral airfoil , lateral ground "eA=eA+eF;if eA:len()>constants.epsilon then d:setEngineForceCommand(ez,eA,eu,'','','',ev)end;d:setEngineForceCommand(eC,eE,et)local eG='thrust analog vertical fueled 'local eH='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then eH=eH..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then eG=eG..ExtraVerticalTags end;if upAmount~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then d:setEngineForceCommand(eG,eB,et)else d:setEngineForceCommand(eG,vec3(),et)end;if LeftAmount~=0 then d:setEngineForceCommand(eH,eF,et)else d:setEngineForceCommand(eH,vec3(),et)end;if eg==0 then eg=brakeInput2 end;local eI=-eg*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*ek)d:setEngineForceCommand('brake',eI)else if AtmoSpeedAssist then u:setThrottleCommand(axisCommandId.longitudinal,PlayerThrottle)end;local dX=c.getAxisCommandValue(0)if not throttleMode then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(constructVelocity:len()-dX/3.6)local ey=t(brakePID:get(),0,1)eg=t(eg+ey,0,1)end;local eI=-eg*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*ek)d:setEngineForceCommand('brake',eI)local ez=''local eA=vec3()local eJ=false;local eC='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then eC=eC..ExtraLongitudeTags end;local eD=u:getAxisCommandType(axisCommandId.longitudinal)if eD==axisCommandType.byThrottle then local eE=u:composeAxisAccelerationFromThrottle(eC,axisCommandId.longitudinal)d:setEngineForceCommand(eC,eE,et)elseif eD==axisCommandType.byTargetSpeed then local eE=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ez=ez..' , '..eC;eA=eA+eE;if u:getTargetSpeed(axisCommandId.longitudinal)==0 or u:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-u:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then eJ=true end end;local eH='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then eH=eH..ExtraLateralTags end;local eK=u:getAxisCommandType(axisCommandId.lateral)if eK==axisCommandType.byThrottle then local eL=u:composeAxisAccelerationFromThrottle(eH,axisCommandId.lateral)d:setEngineForceCommand(eH,eL,et)elseif eK==axisCommandType.byTargetSpeed then local eF=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ez=ez..' , '..eH;eA=eA+eF end;local eG='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then eG=eG..ExtraVerticalTags end;local eM=u:getAxisCommandType(axisCommandId.vertical)if eM==axisCommandType.byThrottle then local eB=u:composeAxisAccelerationFromThrottle(eG,axisCommandId.vertical)if upAmount~=0 or BrakeLanding and BrakeIsOn then d:setEngineForceCommand(eG,eB,et,'airfoil','ground','',ev)else d:setEngineForceCommand(eG,vec3(),et)d:setEngineForceCommand('airfoil vertical',eB,et,'airfoil','','',ev)d:setEngineForceCommand('ground vertical',eB,et,'ground','','',ev)end elseif eM==axisCommandType.byTargetSpeed then if upAmount<0 then d:setEngineForceCommand('hover',vec3(),et)end;local eN=u:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ez=ez..' , '..eG;eA=eA+eN end;if eA:len()>constants.epsilon then if brakeInput~=0 or eJ or f(ek:dot(constructForward))<0.5 then ez=ez..', brake'end;d:setEngineForceCommand(ez,eA,eu,'','','',ev)end end;local eO=torqueFactor*(eo-en)local eP=vec3(b.getWorldAirFrictionAngularAcceleration())eO=eO-eP;d:setEngineTorqueCommand('torque',eO,et,'airfoil','','',ev)d:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local c4=coreVelocity:len()local eQ=0.15;if not throttleMode then local eR=u:getTargetSpeed(axisCommandId.longitudinal)if c4*3.6>eR*(1-eQ)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif c4*3.6<eR*(1-eQ)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local dq=c.getThrottle()if AtmoSpeedAssist then dq=PlayerThrottle*100 end;local dX=dq/100;if m==0 then dX=dX*MaxGameVelocity;if c4>=dX*(1-eQ)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif c4<dX*(1-eQ)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local eS=g(adjustedAtmoSpeedLimit)dX=dX*eS/3.6;if c4>=dX*(1-eQ)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif c4<dX*(1-eQ)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local eT=coroutine.status(beginSetup)if eT=="suspended"then local az,eU=coroutine.resume(beginSetup)if eU then a.print("ERROR STARTUP: "..eU)end elseif eT=="dead"then SetupComplete=true end end;if SetupComplete then d:update()if not Animating and content~=LastContent then a.setScreen(content)end;LastContent=content end end;function script.onActionStart(eV)CONTROL.startControl(eV)end;function script.onActionStop(eV)CONTROL.stopControl(eV)end;function script.onActionLoop(eV)CONTROL.loopControl(eV)end;function script.onInputText(a0)CONTROL.inputTextControl(a0)end;function script.onEnter(aH)if radar_1 and not inAtmo and not notPvPZone then c.setTimer("contact",0.1)end end;function script.onLeave(aH)if radar_1 and CollisionSystem then if#contacts>650 then aH=tostring(aH)contacts[aH]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
