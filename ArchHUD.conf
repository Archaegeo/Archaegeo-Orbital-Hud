name: ArchHud - Archaegeo v1.5161 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 0 --export:
        OrbitMapY = 25 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.5161;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"local bR=false;local bS=0;local bT={}local bU=nil;local bV=nil;function p(bW)system.print(E..": "..bW)end;local function bX(bY)local D=1;if bY then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bZ=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bZ<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then b7=r(b7+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bS=bS+1*D*-1;if bS>#bG then bS=1 end;if bS<1 then bS=#bG end else if not bY then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end end;local function b_(c0,c1,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c0 .."|"..c1 .."|"..soundVolume)end end;local function c2(c3,c4)for i=1,#c4 do c3[#c3+1]=c4[i]end;return c3 end;local function c5(c6)local c7={}local c8={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local c9={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local ca={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cb={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not c6 then c2(c7,c8)c2(c7,c9)c2(c7,ca)c2(c7,cb)return c7 elseif c6=="boolean"then return c8 elseif c6=="handling"then return c9 elseif c6=="hud"then return ca elseif c6=="physics"then return cb end end;local function cc(cd,ce,cf,cg,ch)if cg==nil then cg=""end;if ch==nil then ch=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cg,cd,ce,ch,cf)end;local function ci(cj,ck)if cj==0 then return d(ck)<1e-09 end;if ck==0 then return d(cj)<1e-09 end;return d(cj-ck)<math.max(d(cj),d(ck))*epsilon end;local function cl(aj,cm)local cn=aj>100000;if cm==nil then cm=1 end;if cn then return A(aj/1000/200,cm).."SU"elseif aj<1000 then return A(aj,cm).."M"else return A(aj/1000,cm).."KM"end end;local function co(cp)local cq=0;local cr=0;local cs=0;if cp<60 then cp=e(cp)elseif cp<3600 then cq=e(cp/60)cp=e(cp%60)elseif cp<86400 then cr=e(cp/3600)cq=e(cp%3600/60)else cs=e(cp/86400)cr=e(cp%86400/3600)end;if cs>0 then return cs.."d "..cr.."h "elseif cr>0 then return cr.."h "..cq.."m "elseif cq>0 then return cq.."m "..cp.."s"elseif cp>0 then return cp.."s"else return"0s"end end;local function ct(cu)local function cv(cw)for cx,cy in pairs(cw)do dbHud_1.setStringValue(cy,h(_G[cy]))if cu and dbHud_2 then dbHud_2.setStringValue(cy,h(_G[cy]))end end end;if dbHud_1 then cv(c)cv(c5())system.print("Saved Variables to Datacore")if cu and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cz(cy)if aG==1920 then return cy else return A(aG*cy/1920,0)end end;local function cA(cy)if aH==1080 then return cy else return A(aH*cy/1080,0)end end;local function cB()local function cC(cD)return type(cD)=='number'end;local function cE(cD)return type(z(cD))=='number'end;local function cF(cG)return type(cG)=='table'end;local function cH(cI)return type(cI)=='string'end;local function cJ(cy)return cF(cy)and cC(cy.x and cy.y and cy.z)end;local function cK(cL)return cF(cL)and cC(cL.latitude and cL.longitude and cL.altitude and cL.id and cL.systemId)end;local cM=math.pi/180;local cN=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cO='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function cP(cD)local cQ=string.gsub(string.reverse(f('%.4f',cD)),'^0*%.?','')return cQ==''and'0'or string.reverse(cQ)end;local function cR(cS)if cJ(cS)then return f('{x=%.3f,y=%.3f,z=%.3f}',cS.x,cS.y,cS.z)end;if cF(cS)and not getmetatable(cS)then local cT={}local cU=next(cS)if type(cU)=='nil'or cU==1 then cT=cS else for cx,cy in pairs(cS)do local cV=cR(cy)if type(cx)=='number'then table.insert(cT,f('[%s]=%s',cx,cV))else table.insert(cT,f('%s=%s',cx,cV))end end end;return f('{%s}',table.concat(cT,','))end;if cH(cS)then return f("'%s'",cS:gsub("'",[[\']]))end;return tostring(cS)end;local cW={}cW.__index=cW;cW.__tostring=function(cS,cX)local cY={}for cx in pairs(cS)do table.insert(cY,cx)end;table.sort(cY)local cT={}for _,cx in ipairs(cY)do local cV=cR(cS[cx])if type(cx)=='number'then table.insert(cT,f('[%s]=%s',cx,cV))else table.insert(cT,f('%s=%s',cx,cV))end end;if cX then return f('%s%s',cX,table.concat(cT,',\n'..cX))end;return f('{%s}',table.concat(cT,','))end;cW.__eq=function(cZ,c_)return cZ.systemId==c_.systemId and cZ.id==c_.id and ci(cZ.radius,c_.radius)and ci(cZ.center.x,c_.center.x)and ci(cZ.center.y,c_.center.y)and ci(cZ.center.z,c_.center.z)and ci(cZ.GM,c_.GM)end;local function d0(d1,d2,d3,d4,d5)assert(cE(d1),'Argument 1 (systemId) must be a number:'..type(d1))assert(cE(d2),'Argument 2 (id) must be a number:'..type(d2))assert(cE(d3),'Argument 3 (radius) must be a number:'..type(d3))assert(cF(d4),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(d4))assert(cE(d5),'Argument 5 (GM) must be a number:'..type(d5))return setmetatable({systemId=z(d1),id=z(d2),radius=z(d3),center=vec3(d4),GM=z(d5)},cW)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,cP(p.latitude*cN),cP(p.longitude*cN),cP(p.altitude))end;MapPosition.__eq=function(cZ,c_)return cZ.id==c_.id and cZ.systemId==c_.systemId and ci(cZ.latitude,c_.latitude)and ci(cZ.altitude,c_.altitude)and(ci(cZ.longitude,c_.longitude)or ci(cZ.latitude,math.pi/2)or ci(cZ.latitude,-math.pi/2))end;local function d6(d7,d2,d8,d9,da)local d1=d7;if cH(d7)and not d9 and not da and not d2 and not d8 then d1,d2,d8,d9,da=o(d7,cO)assert(d1,'Argument 1 (position string) is malformed.')else assert(cE(d1),'Argument 1 (systemId) must be a number:'..type(d1))assert(cE(d2),'Argument 2 (id) must be a number:'..type(d2))assert(cE(d8),'Argument 3 (latitude) must be in degrees:'..type(d8))assert(cE(d9),'Argument 4 (longitude) must be in degrees:'..type(d9))assert(cE(da),'Argument 5 (altitude) must be in meters:'..type(da))end;d1=z(d1)d2=z(d2)d8=z(d8)d9=z(d9)da=z(da)if d2==0 then return setmetatable({latitude=d8,longitude=d9,altitude=da,id=d2,systemId=d1},MapPosition)end;return setmetatable({latitude=cM*r(d8,-90,90),longitude=cM*(d9%360),altitude=da,id=d2,systemId=d1},MapPosition)end;local db={}db.__index=db;db.__tostring=function(cS,cX)local dc=cX and cX..'  'local dd={}local cY={}for cx in pairs(cS)do table.insert(cY,cx)end;table.sort(cY)for _,de in ipairs(cY)do bdy=cS[de]local df=cW.__tostring(bdy,dc)if cX then table.insert(dd,f('[%s]={\n%s\n%s}',de,df,cX))else table.insert(dd,f('  [%s]=%s',de,df))end end;if cX then return f('\n%s%s%s',cX,table.concat(dd,',\n'..cX),cX)end;return f('{\n%s\n}',table.concat(dd,',\n'))end;local function dg(dh)local b={}local pid;for _,cy in pairs(dh)do local d2=cy.planetarySystemId;if type(d2)~='number'then error('Invalid planetary system ID: '..tostring(d2))elseif pid and d2~=pid then error('Mistringmatch planetary system IDs: '..d2 ..' and '..pid)end;local di=cy.bodyId;if type(di)~='number'then error('Invalid body ID: '..tostring(di))elseif b[di]then error('Duplicate body ID: '..tostring(di))end;setmetatable(cy.center,getmetatable(vec3.unit_x))b[di]=setmetatable(cy,cW)pid=d2 end;return setmetatable(b,db)end;aQ={}local function dj(dh)return setmetatable({galaxyAtlas=dh or{}},aQ)end;aQ.__index=function(cG,i)if type(i)=='number'then local system=cG.galaxyAtlas[i]return dg(system)end;return rawget(aQ,i)end;aQ.__pairs=function(cS)return function(cG,cx)local dk,nv=next(cG,cx)return dk,nv and dg(nv)end,cS.galaxyAtlas,nil end;aQ.__tostring=function(cS)local dl={}for _,dm in pairs(cS or{})do local dn=dm:getPlanetarySystemId()local dp=db.__tostring(dm,'    ')table.insert(dl,f('  [%s]={%s\n  }',dn,dp))end;return f('{\n%s\n}\n',table.concat(dl,',\n'))end;aQ.BodyParameters=d0;aQ.MapPosition=d6;aQ.PlanetarySystem=dg;function aQ.createBodyParameters(d1,d2,dq,dr,ds,dt,du)assert(cE(d1),'Argument 1 (systemId) must be a number:'..type(d1))assert(cE(d2),'Argument 2 (id) must be a number:'..type(d2))assert(cE(dq),'Argument 3 (surfaceArea) must be a number:'..type(dq))assert(cF(dr),'Argument 4 (aPosition) must be an array or vec3:'..type(dr))assert(cF(ds),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ds))assert(cE(dt),'Argument 6 (altitude) must be in meters:'..type(dt))assert(cE(du),'Argument 7 (gravityAtPosition) must be number:'..type(du))local d3=y(dq/4/math.pi)local aj=d3+dt;local dv=vec3(dr)+aj*vec3(ds)local d5=du*aj*aj;return d0(d1,d2,d3,dv,d5)end;aQ.isMapPosition=cK;function aQ:getPlanetarySystem(d7)if i==nil then i=0 end;if nv==nil then nv=0 end;local d1=d7;if cK(d7)then d1=d7.systemId end;if type(d1)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=db then system=dg(system)end;return system end end end;function db:sizeCalculator(dw)return 1.05*dw.radius end;function db:castIntersections(dx,dy,dz,dA,dB,dC)local dD={}local dE=dB or self;for _,dw in pairs(dE)do table.insert(dD,dw)end;if not dC then table.sort(dD,function(dF,dG)return(dF.center-dx):len()<(dG.center-dx):len()end)end;local dH=dy:normalize()for _,dw in ipairs(dD)do local dI=dw.center-dx;local d3=self:sizeCalculator(dw)local dJ=dI:dot(dH)local dK=dJ^2-(dI:len2()-d3^2)if dK>=0 then local dL=y(dK)local dM=dJ+dL;local dN=dJ-dL;if dN>0 then return dw,dM,dN elseif dM>0 then return dw,dM,nil end end end;return nil,nil,nil end;function db:closestBody(dO)assert(type(dO)=='table','Invalid coordinates.')local dP,dw;local dQ=vec3(dO)for _,dR in pairs(self)do local dS=(dR.center-dQ):len2()if(not dw or dS<dP)and dR.name~="Space"then dw=dR;dP=dS end end;return dw end;function db:convertToBodyIdAndWorldCoordinates(d7)local dT=d7;if cH(d7)then dT=d6(d7)end;if dT.id==0 then return 0,vec3(dT.latitude,dT.longitude,dT.altitude)end;local dR=self:getBodyParameters(dT)if dR then return dT.id,dR:convertToWorldCoordinates(dT)end end;function db:getBodyParameters(d7)local d2=d7;if cK(d7)then d2=d7.id end;assert(cE(d2),'Argument 1 (id) must be a number:'..type(d2))return self[d2]end;function db:getPlanetarySystemId()local _,cy=next(self)return cy and cy.systemId end;function cW:convertToMapPosition(d4)assert(cF(d4),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(d4))local dU=vec3(d4)if self.id==0 then return setmetatable({latitude=dU.x,longitude=dU.y,altitude=dU.z,id=0,systemId=self.systemId},MapPosition)end;local dV=dU-self.center;local aj=dV:len()local da=aj-self.radius;local d8=0;local d9=0;if not ci(aj,0)then local dW=n(dV.y,dV.x)d9=dW>=0 and dW or 2*math.pi+dW;d8=math.pi/2-math.acos(dV.z/aj)end;return setmetatable({latitude=d8,longitude=d9,altitude=da,id=self.id,systemId=self.systemId},MapPosition)end;function cW:convertToWorldCoordinates(d7)local dT=cH(d7)and d6(d7)or d7;if dT.id==0 then return vec3(dT.latitude,dT.longitude,dT.altitude)end;assert(cK(dT),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(dT.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(dT.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local dX=math.cos(dT.latitude)return self.center+(self.radius+dT.altitude)*vec3(dX*math.cos(dT.longitude),dX*math.sin(dT.longitude),math.sin(dT.latitude))end;function cW:getAltitude(d4)return(vec3(d4)-self.center):len()-self.radius end;function cW:getDistance(d4)return(vec3(d4)-self.center):len()end;function cW:getGravity(d4)local dY=self.center-vec3(d4)local dZ=dY:len2()return self.GM/dZ*dY/y(dZ)end;return setmetatable(aQ,{__call=function(_,...)return dj(...)end})end;local function d_()local aS={}local e0=30000000/3600;local e1=e0*e0;local e2=100;function aS.computeAccelerationTime(e3,e4,e5)local e6=e0*math.asin(e3/e0)return(e0*math.asin(e5/e0)-e6)/e4 end;function aS.computeDistanceAndTime(e3,e5,e7,e8,e9,ea)e9=e9 or 0;ea=ea or 0;local eb=e3<=e5;local ec=e8*(eb and 1 or-1)/e7;local ed=-ea/e7;local ee=ec+ed;if eb and ee<=0 or not eb and ee>=0 then return-1,-1 end;local ef,eg=0,0;if ec~=0 and e9>0 then local e6=math.asin(e3/e0)local eh=math.pi*(ec/2+ed)local ei=ec*e9;local ej=e0*math.pi;local cy=function(cG)local ek=(eh*cG-ei*math.sin(math.pi*cG/2/e9)+ej*e6)/ej;local el=math.tan(ek)return e0*el/y(el*el+1)end;local em=eb and function(cI)return cI>=e5 end or function(cI)return cI<=e5 end;eg=2*e9;if em(cy(eg))then local en=0;while d(eg-en)>0.5 do local cG=(eg+en)/2;if em(cy(cG))then eg=cG else en=cG end end end;local eo=e3;local ep=eg/e2;for eq=1,e2 do local er=cy(eq*ep)ef=ef+(er+eo)*ep/2;eo=er end;if eg<2*e9 then return ef,eg end;e3=eo end;local e6=e0*math.asin(e3/e0)local E=(e0*math.asin(e5/e0)-e6)/ee;local es=e1*math.cos(e6/e0)/ee;local aj=es-e1*math.cos((ee*E+e6)/e0)/ee;return aj+ef,E+eg end;function aS.computeTravelTime(e3,e4,aj)if aj==0 then return 0 end;if e4>0 then local e6=e0*math.asin(e3/e0)local es=e1*math.cos(e6/e0)/e4;return(e0*math.acos(e4*(es-aj)/e1)-e6)/e4 end;if e3==0 then return-1 end;assert(e3>0,'Acceleration and initial speed are both zero.')return aj/e3 end;return aS end;local function et()local vec3=require('cpml.vec3')local cB=cB()local function cH(cI)return type(cI)=='string'end;local function cF(cG)return type(cG)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(da)assert(self.body)local aj=da+self.body.radius;if not ci(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(d7,eu)assert(self.body)assert(cF(d7)or cH(d7))assert(cF(eu))local ev=(cH(d7)or cB.isMapPosition(d7))and self.body:convertToWorldCoordinates(d7)or vec3(d7)local cy=vec3(eu)local ew=ev-self.body.center;local ex=cy:len2()local ey=ew:len()local ez=self.body.GM;local eA=((ex-ez/ey)*ew-ew:dot(cy)*cy)/ez;local cj=ez/(2*ez/ey-ex)local eB=eA:len()local dH=eA:normalize()local eC=cj*(1-eB)local eD=cj*(1+eB)local eE=eC*dH+self.body.center;local eF=eB<=1 and-eD*dH+self.body.center or nil;local eG=y(cj*ez*(1-eB*eB))local eH=eF and 2*math.pi*y(cj^3/ez)local eI=math.acos(eA:dot(ew)/(eB*ey))if ew:dot(cy)<0 then eI=-(eI-2*math.pi)end;local eJ=math.acos((math.cos(eI)+eB)/(1+eB*math.cos(eI)))local eK=eJ;if eK<0 then eK=eK+2*math.pi end;local eL=eK-eB*math.sin(eK)local eM=0;local eN=0;local eO=0;if eH~=nil then eM=eL/(2*math.pi/eH)eN=eH-eM;eO=eN+eH/2;if eI-math.pi>0 then eN=eM;eO=eN+eH/2 end;if eO>eH then eO=eO-eH end end;return{periapsis={position=eE,speed=eG/eC,circularOrbitSpeed=y(ez/eC),altitude=eC-self.body.radius},apoapsis=eF and{position=eF,speed=eG/eD,circularOrbitSpeed=y(ez/eD),altitude=eD-self.body.radius},currentVelocity=cy,currentPosition=ev,eccentricity=eB,period=eH,eccentricAnomaly=eJ,meanAnomaly=eL,timeToPeriapsis=eN,timeToApoapsis=eO,trueAnomaly=eI}end;local function eP(eQ)local dR=cB.BodyParameters(eQ.systemId,eQ.id,eQ.radius,eQ.center,eQ.GM)return setmetatable({body=dR},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return eP(...)end})end;local function eR()local eS={}local eT={}local eU={XS=13,S=27,M=55,L=110,XL=221}local eV={}local eW;local eX;local eY;local eZ;local e_;local function f0()local function f1(f2,f3,f4,f5,f6,f7,f8,f9)f3,f5,f7,f9=vec3(f3),vec3(f5),vec3(f7),vec3(f9)local fa,fb,fc=f2*f2,f4*f4,f6*f6;local ex=f5-f3;local fd=ex:normalize()local fe=ex:len()local ff=f7-f3;local fg=(ff-ff:project_on(fd)):normalize()local fh,fi=ff:dot(fd),ff:dot(fg)local fj=fh*fh+fi*fi;local fk=fd:cross(fg)local cd=(fa-fb+fe*fe)/(2*fe)local ce=(fa-fc+fj-2*fh*cd)/(2*fi)local cL=fa-cd^2-ce^2;local fl=y(cL)local fm=f3+fd*cd+fg*ce+fk*fl;local fn=f3+fd*cd+fg*ce-fk*fl;if d((f9-fm):len()-f8)<d((f9-fn):len()-f8)then return fm else return fn end end;local function fo()local function fp()local fq=core.getConstructWorldOrientationRight()local ex=core.getConstructWorldOrientationForward()local ff=core.getConstructWorldOrientationUp()local fr=library.systemResolution3(fq,ex,ff,{1,0,0})local fs=library.systemResolution3(fq,ex,ff,{0,1,0})local ft=library.systemResolution3(fq,ex,ff,{0,0,1})return function(fu)return library.systemResolution3(fr,fs,ft,fu)end end;local fv=fp()local fw=core.getConstructWorldPos()local ev=core.getElementPositionById(1)local fx={ev[1],ev[2],ev[3]}local fy=fv(fx)local fz={fw[1]-fy[1],fw[2]-fy[2],fw[3]-fy[3]}return fz end;local function fA(fB,ey,fC)local fD=fB.pts;local fE=#fD;local fF=fB.ref;if fE>3 then local fG,fH,fI,fJ=fD[fE],fD[fE-1],fD[fE-2],fD[fE-3]fB.ref=fC;local ev=f1(fG[1],fG[2],fH[1],fH[2],fI[1],fI[2],fJ[1],fJ[2])local cd,ce,fl=ev.x,ev.y,ev.z;if cd==cd and ce==ce and fl==fl then cd=cd+fF[1]ce=ce+fF[2]fl=fl+fF[3]local fK=vec3(cd,ce,fl)if not fB.lastPos then fB.center=fK elseif(fB.lastPos-fK):len()<2 then fB.center=fK;fB.skipCalc=true end;fB.lastPos=fK end;fB.pts={}else local fL={fC[1]-fF[1],fC[2]-fF[2],fC[3]-fF[3]}fD[fE+1]={ey,fL}end end;if bP[1]then eW=#bP[1].getConstructIds()local fM=bP[1].getData()local fN=fM:gmatch('{"constructId[^}]*}[^}]*}')if eW>0 then local fC=fo()local fO,fP=0,0;e_,eZ=0,0;for cy in fN do local d2,aj,fQ=cy:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local fR=eU[fQ]aj=z(aj)if bP[1].hasMatchingTransponder(d2)==1 then table.insert(eT,d2)end;local fS=bP[1].getConstructType(d2)if CollisionSystem then if fR>27 or fS=="static"or fS=="space"then e_=e_+1;local fT=bP[1].getConstructName(d2)local fB=bL[d2]if fB==nil then fR=fR+G;bL[d2]={pts={},ref=fC,name=fT,i=0,radius=fR,skipCalc=false}fB=bL[d2]end;if not fB.skipCalc then fA(fB,aj,fC)fP=fP+1 end;if fB.center then table.insert(eV,fB)end end;fO=fO+1;if bM and fO>700 or fP>70 or(not bM and fO>300 or fP>30)then coroutine.yield()fO,fP=0,0 end end end;eZ=#eV;if eZ>0 and bs>20 then local dw,fU,fV,fW;local fX=0;local fY=aR:getPlanetarySystem(0)fW=br:normalize()while fX<eZ do coroutine.yield()local fZ={table.unpack(eV,fX,math.min(fX+75,eZ))}dw,fU,fV=fY:castIntersections(bv,fW,nil,nil,fZ,true)if dw and fV then bO={dw,fU,fV}break end;fX=fX+75 end;if not dw then bO=nil end else bO=nil end;eV={}eX=fM:find('identifiedConstructs":%[%]')else eY=fM:find('worksInEnvironment":false')end end end;local function f_()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function eS.pickType()f_()end;function eS.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then f_()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then f_()end end end;function eS.UpdateRadar()local g0=coroutine.status(UpdateRadarCoroutine)if g0=="suspended"then local cV,g1=coroutine.resume(UpdateRadarCoroutine)if g1 then system.print("ERROR UPDATE RADAR: "..g1)end elseif g0=="dead"then UpdateRadarCoroutine=coroutine.create(f0)local cV,g1=coroutine.resume(UpdateRadarCoroutine)end end;function eS.GetRadarHud()local g2=eT;eT={}return eX,eY,eW,eZ,e_,g2 end;UpdateRadarCoroutine=coroutine.create(f0)return eS end;local function g3()local g4=9.80665;local g5={}local g6={}local g7=vec3({13771471,7435803,-128971})local g8=18000000;local g9=500000;local ga,gb=math.huge;local gc;local function gd(ge)ga=vec3(ge):dist(g7)if ga<g8 then return true,d(ga-g8)end;gb=vec3(ge):dist(vec3(planet.center))if gb<g9 then gc=true else gc=false end;if d(gb-g9)<d(ga-g8)then return gc,d(gb-g9)else return gc,d(ga-g8)end end;local function cz(cy)if aG==1920 then return cy else return A(aG*cy/1920,0)end end;local function cA(cy)if aH==1080 then return cy else return A(aH*cy/1080,0)end end;local function gf()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gg()local gh="TRAVEL"if not bA then gh="CRUISE"end;if Autopilot then gh="AUTOPILOT"end;return gh end;local gi={Generic_Moon="assets.prod.novaquark.com/20368/f410e727-9d4d-4eab-98bf-22994b3fbdcf.png",Sun="assets.prod.novaquark.com/20368/0936494e-9b3d-4d60-9ea0-d93a3f3e29cd.png",Alioth="assets.prod.novaquark.com/20368/954f3adb-3369-4ea9-854d-a14606334152.png",Alioth_bis="assets.prod.novaquark.com/20368/b83225ed-fb96-404c-8c91-86ac15dfbbec.png",Sanctuary="assets.prod.novaquark.com/20368/1a70dbff-24bc-44cb-905c-6d375d9613b8.png",Feli="assets.prod.novaquark.com/20368/da91066c-b3fd-41f4-8c01-26131b0a7841.png",Ion="assets.prod.novaquark.com/20368/91d10712-dc51-4b73-9fc0-6f07d96605a6.png",Madis="assets.prod.novaquark.com/20368/46d57ef4-40ee-46ca-8cc5-5aee1504bbfe.png",Jago="assets.prod.novaquark.com/20368/7fca8389-6b70-4198-a9c3-4875d15edb38.png",Lacobus="assets.prod.novaquark.com/20368/cb67a6a4-933c-4688-a637-898c89eb5b94.png",Sicari="assets.prod.novaquark.com/20368/f6e2f801-075f-4ccd-ab94-46d060517e8f.png",Sinnen="assets.prod.novaquark.com/20368/54a99084-7c2b-461b-ab1f-ae4229b3b821.png",Symeon="assets.prod.novaquark.com/20368/97940324-f194-4e03-808d-d71733ad545a.png",Talemai="assets.prod.novaquark.com/20368/f68628d9-3245-4d76-968e-ad9c63a19c19.png",Teoma="assets.prod.novaquark.com/20368/5a01dd8c-3cf8-4151-99a2-83b22f1e7249.png",Thades="assets.prod.novaquark.com/20368/59f997a2-bcca-45cf-aa35-26e0e41ed5c1.png"}local gj=""local gk=""local gl=""local gm=1;local gn=2;local go=3;local gp=4;local gq=5;local gr=6;local gs=""local gt=0;local gu=e(1/apTickRate)*2*hudTickRate;local gv={}local gw={}local gx={}local gy={}local gz={}local gA={}local function gB(cd,gC,gD,gE,gF,gG)local gH=tankY;local gI=tankY+5;if not BarFuelDisplay then gI=gI+5 end;if m()==1 and not RemoteHud then gH=gH-50;gI=gI-50 end;if gD=="ATMO"then gs="atmofueltank"elseif gD=="SPACE"then gs="spacefueltank"else gs="rocketfueltank"end;gt=_G[gs.."_size"]if#gE>0 then for i=1,#gE do local fT=string.sub(gE[i][gn],1,12)local gJ=0;for gK=1,gt do if gE[i][gn]==g(unit[gs.."_"..gK].getData()).name then gJ=gK;break end end;local gL=q()if gF[i]==nil or gG[i]==nil or gL-gE[i][gr]>gu then local gM;local gN=0;if gJ~=0 then gG[i]=g(unit[gs.."_"..gJ].getData()).percentage;gF[i]=g(unit[gs.."_"..gJ].getData()).timeLeft;if gF[i]=="n/a"then gF[i]=0 end else gN=l(gE[i][gm])-gE[i][gp]gG[i]=e(0.5+gN*100/gE[i][go])gM=gE[i][gq]if gM<=gN then gF[i]=0 else gF[i]=e(0.5+gN/((gM-gN)/(gL-gE[i][gr])))end;gE[i][gq]=gN;gE[i][gr]=gL end end;if fT==gC then fT=f("%s %d",gD,i)end;if gJ==0 then fT=fT.." *"end;local gO;if gF[i]==0 then gO=""else gO=co(gF[i])end;if gG[i]~=nil then local gP=e(gG[i]*2.55)local gQ=f("rgb(%d,%d,%d)",255-gP,gP,0)local cg=""if gO~=""and gF[i]<120 or gG[i]<5 then cg="red "end;local gR=f("rgb(%d,%d,%d)",r(e((255-gP)/2.55),50,100),r(e(gP/2.55),0,50),50)local gS="rgb(196,0,255)"if gD=="ATMO"then gS="rgb(0,188,255)"elseif gD=="SPACE"then gS="rgb(239,255,0)"end;local gT=false;if previous~=gS then gT=true end;previous=gS;if BarFuelDisplay then if gT then gH=gH-5;gI=gI-5 end;gk=gk..f([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],gR,gS,cd,gI,gQ,e(gG[i]*1.7+0.5),cd,gI,cd+5,gI+14,fT,gG[i],gO)gH=gH-22;gI=gI-22 else gk=gk..cc(cd,gH,fT,cg.."pdim txtfuel")gk=gk..cc(cd,gI,f("%d%% %s",gG[i],gO),"pdim txtfuel","fill:"..gQ)gH=gH+30;gI=gI+30 end end end end;tankY=gH end;local function gU(gV,da)if da<200000 and not aq or da and aq then local gW=0;if d(bu)>1 then gW=45*math.log(d(bu),10)if bu<0 then gW=-gW end end;gV[#gV+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(gW))end;return gV end;local function gX(gY)local gZ=-bt;gY=gY-gY:project_on(gZ)local g_=vec3(0,0,1)g_=g_-g_:project_on(gZ)local h0=g_:cross(gZ)local gW=g_:angle_between(gY)*constants.rad2deg;if gY:dot(h0)<0 then gW=360-gW end;return gW end;local function h1(gV,centerX,centerY,h2,h3,bM)local h4=circleRad;local h5=20;local h6=e(h2)if bM then for i=-45,45,5 do local h7=i;gV[#gV+1]=f([[<g transform="rotate(%f,%d,%d)">]],h7,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gV[#gV+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h4+h5-len,centerX,centerY+h4+h5)end;gV[#gV+1]=cc(centerX,centerY+h4+h5-35,h3,"pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY+h4+h5-25,h6 .." deg","pdim txt txtmid")gV[#gV+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h2,centerX,centerY)gV[#gV+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h4+h5-20,centerX+5,centerY+h4+h5-20,centerX,centerY+h4+h5-15)gV[#gV+1]="</g>"end;gV[#gV+1]=[[<g style="clip-path: url(#headingClip);">]]local h8=h6;if bM then h8=gX(bo)end;local h9=20;local ha=e(h8)local hb=0;local hc=centerY+h4+h5+20;local hd=centerX;if h3~="YAW"then hc=cA(130)hd=cz(960)end;local he=[[<path class="txttick line" d="]]local hf=e(ha-(h9+10)-ha%5+0.5)for i=hf+70,hf,-5 do local cd=hd-(-i*5+h8*5)if i%10==0 then hb=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;gV[#gV+1]=cc(cd,hc+15,B,"txtmid bright")elseif i%5==0 then hb=5 end;if hb==10 then he=f([[%s M %f %f v %d]],he,cd,hc-5,hb)else he=f([[%s M %f %f v %d]],he,cd,hc-2.5,hb)end end;gV[#gV+1]=he..[["/>]]gV[#gV+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],hd-5,hc-20,hd+5,hc-20,hd,hc-10)if bM then h3="HDG"end;gV[#gV+1]=cc(cz(960),cA(100),ha.."Â°","dim txt txtmid size14","")gV[#gV+1]=cc(cz(960),cA(85),h3,"dim txt txtmid size20","")gV[#gV+1]=[[</g>]]end;local function hg(gV,hh,h2,centerX,centerY,bM,hi,er)local h4=circleRad;local hj=e(h4*3/5)if h4>0 then local hk=e(hh)local len=0;local he=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h2,centerX,centerY)if not aq then he=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gV[#gV+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h4-1,centerX,centerY)gV[#gV+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(hk-30-hk%5+0.5),e(hk+30+hk%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local ce=centerY+-i*5+hh*5;if len==30 then he=f([[%s M %d %f h %d]],he,centerX-hj-len,ce,len)if aq then gV[#gV+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h2,centerX,centerY,centerX-hj+10,ce+4,i)gV[#gV+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h2,centerX,centerY,centerX+hj-10,ce+4,i)if i==0 or i==180 or i==-180 then gV[#gV+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h2,centerX,centerY,centerX-hj+20,ce,hj*2-40)end else gV[#gV+1]=cc(centerX-hj+10,ce,i,"pdim txt txtmid")gV[#gV+1]=cc(centerX+hj-10,ce,i,"pdim txt txtmid")end;he=f([[%s M %d %f h %d]],he,centerX+hj,ce,len)else he=f([[%s M %d %f h %d]],he,centerX-hj-len,ce,len)he=f([[%s M %d %f h %d]],he,centerX+hj,ce,len)end end;gV[#gV+1]=he..[["/>]]local hl="PITCH"if not bM then hl="REL PITCH"end;if hh>90 and not aq then hh=90-(hh-90)elseif hh<-90 and not aq then hh=-90-(hh+90)end;if h4>200 then if aq then if er>Q then gV[#gV+1]=cc(centerX,centerY-15,"Yaw","pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY+20,hi,"pdim txt txtmid")end;gV[#gV+1]=f([[<g transform="rotate(%f,%d,%d)">]],-h2,centerX,centerY)else gV[#gV+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gV[#gV+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hj+25,centerY-5,centerX-hj+20,centerY,centerX-hj+25,centerY+5,centerX-hj+50,centerY+4,hk)gV[#gV+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hj-25,centerY-5,centerX+hj-20,centerY,centerX+hj-25,centerY+5,centerX+hj-30,centerY+4,hk)gV[#gV+1]="</g>"end;local hm=e(h4/3)gV[#gV+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hm,centerY,h4-hm)if not aq and bM then gV[#gV+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h2,centerX,centerY,centerX-hj+10,centerY,hj*2-20)end;gV[#gV+1]="</g>"if h4<200 then if aq and er>Q then gV[#gV+1]=cc(centerX,centerY-h4,hl,"pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY-h4+10,hk,"pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY-15,"Yaw","pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY+20,hi,"pdim txt txtmid")else gV[#gV+1]=cc(centerX,centerY-h4,hl,"pdim txt txtmid")gV[#gV+1]=cc(centerX,centerY-h4+15,hk,"pdim txt txtmid")end end end end;local function hn(gV,da,bM)local ho=altMeterX;local hp=altMeterY;local hq=78;local hr=19;local hs=ao;if ao~=-1 then gV[#gV+1]=cc(ho+hq,hp+hr+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(da<200000 and not aq or da and aq)then table.insert(gV,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],ho-1,hp-4,hq+2,hr+6,ho+1,hp-1,hq-4,hr))local fE=0;local ht=1;local hu=0;local hv=da<0;local hw=da<planet.surfaceMaxAltitude;local hx=9;if hv then hx=0 end;local da=d(da)while fE<6 do local hy=11;local hz=16;local hA=9;local hB=14;local cg="altsm"if fE>2 then hz=hz+3;hy=hy+2;hB=hB+2;hA=hA-6;cg="altbig"end;if hv then cg=cg.." red"elseif hw then cg=cg.." orange"end;local hC=da/ht%10;local hD=e(hC)local hE=e((hD+1)%10)local hF=hu;if fE==0 then hF=hC-hD;if hv then hF=1-hF end end;if hv and(fE==0 or hu~=0)then local hG=hE;hE=hD;hD=hG end;local hH=hz*(hF-1)local hI=hH+hz;local cd=ho+hA+(6-fE)*hy;local ce=hp+hB;gV[#gV+1]=cc(cd,ce+hH,hE,cg)gV[#gV+1]=cc(cd,ce+hI,hD,cg)fE=fE+1;ht=ht*10;if hD==hx then hu=hF else hu=0 end end;table.insert(gV,[[</g></g>]])end end;local function hJ(eu)local hK=-math.deg(n(eu.y,eu.z))+180;hK=hK-90;if hK<0 then hK=360+hK end;if hK>180 then hK=-180+hK-180 end;return-hK end;local function hL(eu)local h8=math.deg(n(eu.y,eu.x))-90;if h8<-180 then h8=360+h8 end;return h8 end;local function hM(gV,eu,er,centerX,centerY)if er>5 and not aq or er>Q then local h4=circleRad;local hN=20;local hO=20;local hP=hJ(eu)local hQ=hL(eu)local hR=14;local hS=hR/2;local hT=-hQ/hO*h4;local hU=hP/hN*h4;local cd=centerX+hT;local ce=centerY+hU;local aj=y(hT^2+hU^2)local hV=[[<circle
                            cx="]]..cd..[["
                            cy="]]..ce..[["
                            r="]]..hS/hR..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cd..[["
                            cy="]]..ce..[["
                            r="]]..hS..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cd-hR..[[,]]..ce..[[ h ]]..hS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cd+hS..[[,]]..ce..[[ h ]]..hS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cd..[[,]]..ce-hR..[[ v ]]..hS..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<h4 then gV[#gV+1]=hV else local gW=n(hU,hT)local hW=4;local hX=centerX+h4*math.cos(gW)local hY=centerY+h4*math.sin(gW)gV[#gV+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gW*180/math.pi,hX,hY,hX-hW,hY-hW/2,hW*2,hW,hX+hW,hY-hW,hW,hW,-hW,hW)end;if not aq then local hZ=vec3(eu)hP=hJ(-hZ)hQ=hL(-hZ)hT=-hQ/hO*h4;hU=hP/hN*h4;cd=centerX+hT;ce=centerY+hU;aj=y(hT^2+hU^2)if aj<h4 then local h_=[[<circle
                                    cx="]]..cd..[["
                                    cy="]]..ce..[["
                                    r="]]..hS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cd..[[,]]..ce-hR..[[ v ]]..hS..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cd..[[,]]..ce..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cd..[[,]]..ce..[[)" />
                                <path
                                    d="M ]]..cd-hS..[[,]]..ce..[[ h ]]..hR..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cd..[[,]]..ce..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cd..[[,]]..ce..[[)"/>]]gV[#gV+1]=h_ end end end end;local function i0(gV,gh,i1,i2)i1=e(i1+0.5)local gH=throtPosY+10;local gI=throtPosY+20;if m()==1 and not RemoteHud then gH=55;gI=65 end;local i3="CRUISE"local unit="km/h"local cV=i2;if gh=="TRAVEL"or gh=="AUTOPILOT"then i3="THROT"unit="%"cV=i1;local i4="dim"if i1<0 then i4="red"end;gV[#gV+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i4,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(i1),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gV[#gV+1]=cc(throtPosX+10,gH,i3,"pbright txtstart")gV[#gV+1]=cc(throtPosX+10,gI,f("%.0f %s",cV,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then i1=e(N*100+0.5)local i4="red"if i1<0 then i4="red"end;gV[#gV+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i4,1-d(i1),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gV[#gV+1]=cc(throtPosX+10,gH+40,"LIMIT","pbright txtstart")gV[#gV+1]=cc(throtPosX+10,gI+40,i1 .."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then gV[#gV+1]=cc(throtPosX+10,gH-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then gV[#gV+1]=cc(throtPosX+10,gH-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i5(gV,i6)local i7=throtPosY-10;local i8=throtPosX+10;gV[#gV+1]=cc(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then i7=75 end;gV[#gV+1]=cc(i8,i7,e(i6).." km/h","pbright txtbig txtstart")end;local function i9(gV)gV[#gV+1]=cc(cz(1900),cA(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gV[#gV+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gV[#gV+1]=cc(cz(960),cA(550),"Warning: Invalid Control Scheme Detected","warnings")gV[#gV+1]=cc(cz(960),cA(600),"Keyboard Scheme must be selected","warnings")gV[#gV+1]=cc(cz(960),cA(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ia=cz(960)local ib=cA(860)local ic=cA(880)local id=cA(900)local ie=cA(960)local ig=cA(200)local ih=cA(250)local ii=cA(960)if m()==1 and not RemoteHud then ib=cA(135)ic=cA(155)id=cA(175)ig=cA(115)ih=cA(95)end;local ij="#222222"local ik="white"local il="dimmer"local im="pbright"local io="#110000"local ip=ij;local iq=il;if BrakeIsOn then gV[#gV+1]=cc(ia,ib,"Brake Engaged","warnings")io="#440000"ip=ik;iq=im elseif L>0 then gV[#gV+1]=cc(ia,ib,"Auto-Brake Engaged","warnings","opacity:"..L)end;local ir="#110000"local is=ij;local it=il;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then gV[#gV+1]=cc(ia,ig+50,"** STALL WARNING **","warnings")ir="#ff0000"is=ik;it=im;b_("stall","SW",2)end end;if bK then gV[#gV+1]=cc(ia,ig+90,"Flight Assist in Progress","warnings")end;if ax then gV[#gV+1]=cc(ia,ii,"Gyro Enabled","warnings")end;local iu="#111100"local iv=ij;local iw=il;if GearExtended then iu="#775500"iv=ik;iw=im;if S then gV[#gV+1]=cc(ia,ic,"Gear Extended","warn")else gV[#gV+1]=cc(ia,ic,"Landed (G: Takeoff)","warnings")end;local ix=cl(a:getTargetGroundAltitude())gV[#gV+1]=cc(ia,id,"Hover Height: "..ix,"warn")end;local iy="#000011"local iz=ij;local iA=il;if a7 then iy="#0000DD"iz=ik;iA=im;gV[#gV+1]=cc(ia,ie+20,"ROCKET BOOST ENABLED","warn")end;local iB="#001100"local iC=ij;local iD=il;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then iB="#00DD00"iC=ik;iD=im;if d(as-antigrav.getBaseAltitude())<501 then gV[#gV+1]=cc(ia,ig+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else gV[#gV+1]=cc(ia,ig+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gV[#gV+1]=cc(ia,ig+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gV[#gV+1]=cc(ia,ig+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then gV[#gV+1]=cc(ia,ig+20,"Follow Mode Engaged","warn")elseif Reentry or an then gV[#gV+1]=cc(ia,ig+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ix=cl(HoldAltitude,2)if VertTakeOff then if by then ix=cl(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gV[#gV+1]=cc(ia,ig,"VTO to "..ix,"warn")elseif AutoTakeoff and not IntoOrbit then if am then gV[#gV+1]=cc(ia,ig,"Takeoff to "..AutopilotTargetName,"warn")else gV[#gV+1]=cc(ia,ig,"Takeoff to "..ix,"warn")end;if BrakeIsOn and not VertTakeOff then gV[#gV+1]=cc(ia,ig+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gV[#gV+1]=cc(ia,ig,"Altitude Hold: "..ix,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then gV[#gV+1]=cc(ia,ig+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then gV[#gV+1]=cc(ia,ig+20,"Aligning trajectory","warn")elseif ar<0.05 then gV[#gV+1]=cc(ia,ig+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then gV[#gV+1]=cc(ia,ig,b9,"warn")end end;if BrakeLanding then if StrongBrakes then gV[#gV+1]=cc(ia,ig,"Brake-Landing","warnings")else gV[#gV+1]=cc(ia,ig,"Coast-Landing","warnings")end end;if ProgradeIsOn then gV[#gV+1]=cc(ia,ig,"Prograde Alignment","crit")end;if RetrogradeIsOn then gV[#gV+1]=cc(ia,ig,"Retrograde Alignment","crit")end;local iE="#110000"local iF=ij;local iG=il;if bN then iE="#FF0000"iF=ik;iG=im;local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;gV[#gV+1]=cc(ia,ih+20,bN,type)elseif ar==0 then local iH,iI=aX.checkLOS(br:normalize())if iI~=nil then iG=im;iE="#FF0000"iF=ik;local ix=cl(iI)local travelTime=aS.computeTravelTime(bs,0,iI)local iJ="Collision"if iH.noAtmosphericDensityAltitude>0 then iJ="Atmosphere"end;gV[#gV+1]=cc(ia,ih+20,iH.name.." "..iJ.." "..co(travelTime).." In "..ix,"crit")end end;if VectorToTarget and not IntoOrbit then gV[#gV+1]=cc(ia,ig+35,VectorStatus,"warn")end;local iK="#111100"local iL=ij;local iM=il;if bU and#bU>1 then iK="#DDDD00"iL=ik;iM=im end;local iN=cz;local iO=cA;local il="topButton"local iP="topButtonActive"local iQ=il;if Autopilot or VectorToTarget or am or IntoOrbit then iQ=iP end;local iR=il;if ProgradeIsOn then iR=iP end;local iS=il;if BrakeLanding or GearExtended then iS=iP end;local iT=il;if AltitudeHold or VectorToTarget then iT=iP end;local iU=il;if RetrogradeIsOn then iU=iP end;local iV=il;if IntoOrbit or bi and Autopilot then iV=iP end;local iW=iO(30)gV[#gV+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iQ,iN(960),iO(54),iO(-53),iN(-120),iN(25),iO(50))gV[#gV+1]=cc(iN(910),iW,"AUTOPILOT")gV[#gV+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iR,iN(865),iO(51),iN(-25),iO(-50),iN(-110),iN(25),iO(46))gV[#gV+1]=cc(iN(800),iW,"PROGRADE")gV[#gV+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iS,iN(755),iO(47),iN(-25),iO(-46),iN(-98),iN(44),iO(44))gV[#gV+1]=cc(iN(700),iW,"LAND")gV[#gV+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iT,iN(960),iO(54),iO(-53),iN(120),iN(-25),iO(50))gV[#gV+1]=cc(iN(1010),iW,"ALT HOLD")gV[#gV+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iU,iN(1055),iO(51),iN(25),iO(-50),iN(110),iN(-25),iO(46))gV[#gV+1]=cc(iN(1122),iW,"RETROGRADE")gV[#gV+1]=f([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iV,iN(1165),iO(47),iN(25),iO(-46),iN(98),iN(-44),iO(44))gV[#gV+1]=cc(iN(1220),iW,"ORBIT")gV[#gV+1]=[[
                                </g>
                            </g>]]gV[#gV+1]="</g>"return gV end;local function iX(er)return e(A(er*3.6,0)+0.5).." km/h"end;local function iY(gV)local cd=OrbitMapX+10;local ce=OrbitMapY+20;local iZ={}local i_={"Alt-4: AutoTakeoff to Target"}local j0={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local j1={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local j2={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(iZ,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then c2(iZ,i_)if ac and planet and ac.name==planet.name then table.insert(iZ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(iZ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iZ,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iZ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(iZ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(iZ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(iZ,"G: Takeoff to hover height, raise gear")else table.insert(iZ,"G: Lowergear and Land")end else c2(iZ,j0)table.insert(iZ,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(iZ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c2(iZ,j1)if shield_1 then table.insert(iZ,"Alt-Shift-5: Toggle shield off and on")table.insert(iZ,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(iZ,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(iZ,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(iZ,"Alt-Spacebar/C will raise/lower target height")table.insert(iZ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(iZ,"LALT+Mousewheel will lower/raise speed limit")end;c2(iZ,j2)for i=1,#iZ do ce=ce+12;gV[#gV+1]=cc(cd,ce,iZ[i],"pdim txtbig txtstart")end end;local function j3(gV)local j4=cz(OrbitMapX)local j5=cA(OrbitMapY)local j6=OrbitMapSize;local j7=4;local j8=15;local cd=0;local ce=0;local j9,ja,jb,jc;local jd;local function je(type)local jf,E,er,jg,cg,jh;if type=="Periapsis"then jf=jd.periapsis.altitude;E=jd.timeToPeriapsis;er=jd.periapsis.speed;cg="txtend"jg=12;jh=math.min(cd,j4+j6-planet.radius/jb-j7*2)else jf=jd.apoapsis.altitude;E=jd.timeToApoapsis;er=jd.apoapsis.speed;jg=-12;cg="txtstart"jh=cd end;if bs<1 then E=0 end;gV[#gV+1]=f([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],jh+jg,ce-5,cd,ce-5)gV[#gV+1]=f([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],jh-jg*4,ce+2,cd,ce+2)gV[#gV+1]=cc(jh,ce,type,cg)cd=jh-jg*2;ce=ce+j8;local ix=cl(jf)gV[#gV+1]=cc(cd,ce,ix,cg)ce=ce+j8;gV[#gV+1]=cc(cd,ce,co(E),cg)ce=ce+j8;gV[#gV+1]=cc(cd,ce,iX(er),cg)end;local ji=j6*1.5;if SelectedTab=="INFO"then ji=25*7 end;if SelectedTab~="HIDE"then gV[#gV+1]=[[<g class="pbright txtorb txtmid">]]gV[#gV+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',j6*2,ji,j4,j5)gV[#gV+1]=f([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],j6*2,ji,j4,j5)end;if SelectedTab=="ORBIT"then j5=j5+j7;j9=j6/2;jc=0;jd={}jd.periapsis={}jd.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then jd.periapsis.altitude=orbit.periapsis.altitude;jd.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then jd.apoapsis.altitude=orbit.apoapsis.altitude;jd.apoapsis.speed=orbit.apoapsis.speed end;jd.period=orbit.period;jd.eccentricity=orbit.eccentricity;jd.timeToApoapsis=orbit.timeToApoapsis;jd.timeToPeriapsis=orbit.timeToPeriapsis;jd.eccentricAnomaly=orbit.eccentricAnomaly;jd.trueAnomaly=orbit.trueAnomaly end;if jd.periapsis==nil then jd.periapsis={}jd.periapsis.altitude=-planet.radius;jd.periapsis.speed=MaxGameVelocity end;if jd.eccentricity==nil then jd.eccentricity=1 end;if jd.apoapsis==nil then jd.apoapsis={}jd.apoapsis.altitude=as;jd.apoapsis.speed=0 end;if bs<1 then jd.apoapsis.altitude=as;jd.apoapsis.speed=0 end;if jd.apoapsis.altitude then jb=(jd.apoapsis.altitude+jd.periapsis.altitude+planet.radius*2)/(j9*2)ja=(planet.radius+jd.apoapsis.altitude)/jb*(1-jd.eccentricity)jc=j9-jd.periapsis.altitude/jb-planet.radius/jb;local jj=math.pi;if jd.period~=nil and jd.period>0 and jd.timeToApoapsis~=nil then jj=jd.eccentricAnomaly;if jd.timeToPeriapsis<jd.timeToApoapsis then jj=2*math.pi-jj end end;if bs<1 or jj~=jj then jj=math.pi end;local jk=-j9*math.cos(jj)+j4+j6+j7;local jl=ja*math.sin(jj)+j5+j6*1.5/2+j7;local jm=""gV[#gV+1]='<g clip-path="url(#orbitRect)">'gV[#gV+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jm,j4+j6+j7,j5+j6*1.5/2+j7,j9,ja)if ja<1 then gV[#gV+1]=f([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],j4+j6+j7-jc,j5+j6*1.5/2+j7,jk,jl)end;gV[#gV+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',j4+j6+j7-jc,j5+j6*1.5/2+j7,(planet.radius+planet.noAtmosphericDensityAltitude)/jb)gV[#gV+1]=f('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',j4+j6+j7-jc,j5+j6*1.5/2+j7,(planet.radius+planet.noAtmosphericDensityAltitude)/jb)gV[#gV+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",j4+j6+j7,j5+j6*1.5/2+j7,j9,ja)gV[#gV+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',j4+j6+j7-jc,j5+j6*1.5/2+j7,planet.radius/jb)gV[#gV+1]='</g>'local jn=math.floor(planet.radius/jb+0.5)local jo=gi.Generic_Moon;if gi[planet.name]then jo=gi[planet.name]end;cd=j4+j6+j7*4+j9;ce=j5+j6*1.5/2+5+j7;if jd.apoapsis~=nil and jd.apoapsis.speed<MaxGameVelocity then je("Apoapsis")end;ce=j5+j6*1.5/2+5+j7;cd=j4+j6-j7*2-j9;if jd.periapsis~=nil and jd.periapsis.speed<MaxGameVelocity and jd.periapsis.altitude>0 then je("Periapsis")end;gV[#gV+1]=cc(j4+j6+j7,j5+20+j7,planet.name,"txtorbbig")gV[#gV+1]=f('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',jk,jl)gV[#gV+1]=[[</g>]]return gV else gV[#gV+1]='<g clip-path="url(#orbitRect)">'local jp=""local jq=1.2*(maxAtlasX-minAtlasX)/(j6*2)local jr=1.4*(maxAtlasY-minAtlasY)/(j6*1.5)for cx,cy in pairs(b[0])do if cy.center then local cd=j4+j6+cy.center.x/jq;local ce=j5+j6*1.5/2+cy.center.y/jr;jp=jp..'<circle cx="'..cd..'" cy="'..ce..'" r="'..cy.radius/jq*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(cy.name,"Moon")and not string.match(cy.name,"Sanctuary")and not string.match(cy.name,"Space")then jp=jp.."<text x='"..cd.."' y='"..ce+cy.radius/jq*30+20 .."' font-size='12' fill="..ay.." text-anchor='middle' font-family='Montserrat'>"..cy.name.."</text>"end end end;local ev=vec3(core.getConstructWorldPos())local cd=j4+j6+ev.x/jq;local ce=j5+j6*1.5/2+ev.y/jr;jp=jp..'<circle cx="'..cd..'" cy="'..ce..'" r="2" stroke="white" stroke-width="1" fill="red"/>'jp=jp.."<text x='"..cd.."' y='"..ce-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"aN=jq;aO=jr;local js=ev+br*1000000;local jt=j4+j6+js.x/jq;local gI=j5+j6*1.5/2+js.y/jr;jp=jp..'<line x1="'..cd..'" y1="'..ce..'" x2="'..jt..'" y2="'..gI..'" stroke="purple" stroke-width="1"/>'gV[#gV+1]=jp;gV[#gV+1]='</g>'end elseif SelectedTab=="INFO"then gV=aV.DrawOdometer(gV,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then gV=iY(gV)else return gV end end;local function ju(jv,jw)local jx;local jy=(jw-jv):normalize()local ew=(bv-jv):dot(jy)/jy:dot(jy)if ew<=0.then return(bv-jv):len()elseif ew>=(jw-jv):len()then return(bv-jw):len()end;local jz=jv+ew*jy;jx=(jz-bv):len()return jx end;local function jA()local jx;local jB=nil;local jC=nil;local jD=nil;for cx,jE in pairs(b[0])do if jE.hasAtmosphere then local aj=ju(planet.center,jE.center)if jB==nil or aj<jB then jC=jE;jB=aj;jD=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local dS=ju(ac.center,jE.center)if dS<jB then jC=jE;jB=dS;jD=ac end end end end;local jF=cz(1770)local jG=cA(330)if jB then local jH="txttick "local jI=500000;if jB<jC.radius+jI or jB<jD.radius+jI then if bH then jH="txttick red "else jH="txttick orange "end end;jx=cl(jB,2)bJ=cc(jF,jG,"Pipe ("..jD.name.."--"..jC.name.."): "..jx,jH.."pbright txtmid")end end;local function jJ(cd,ce,jK,jL,i3)local jM={x=cd,y=ce,width=jK,height=jL,label=i3}bT[i3]=jM;return jM end;local function jN(jO,jP,jK,jL,cd,ce,jQ,jR,jS,jT)local jM={enableName=jO,disableName=jP,width=jK,height=jL,x=cd,y=ce,toggleVar=jQ,toggleFunction=jR,drawCondition=jS,hovered=false}if jT then table.insert(g6,jM)else table.insert(g5,jM)end;return jM end;local function jU(jV)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif jV=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif jV=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif jV=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=c5(jV)showHud=false else bE={}showHud=true end end;local function jW()bD=not bD;if bD then aF=g6;a2="Hold SHIFT to see Settings"bF=showHud else aF=g5;a2="Hold SHIFT to see Control Buttons"jU()showHud=bF end end;local function jX()local function jY(cy)_G[cy]=not _G[cy]if _G[cy]then a2=cy.." set to true"else a2=cy.." set to false"end;if cy=="showHud"then bF=_G[cy]elseif cy=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local jZ=50;local j_=340;local cd=500;local ce=aH/2-400;local k0=0;for cx,cy in pairs(c5("boolean"))do if type(_G[cy])=="boolean"then jN(cy,cy,j_,jZ,cd,ce,function()return _G[cy]end,function()jY(cy)end,function()return true end,true)ce=ce+jZ+20;if k0==9 then cd=cd+j_+20;ce=aH/2-400;k0=0 else k0=k0+1 end end end;jN("Control View","Control View",j_,jZ,10,aH/2-500,function()return true end,jW,function()return true end,true)jN("View Handling Settings",'Hide Handling Settings',j_,jZ,10,aH/2-(500-jZ),function()return showHandlingVariables end,function()jU("handling")end,function()return true end,true)jN("View Hud Settings",'Hide Hud Settings',j_,jZ,10,aH/2-(500-jZ*2),function()return showHudVariables end,function()jU("hud")end,function()return true end,true)jN("View Physics Settings",'Hide Physics Settings',j_,jZ,10,aH/2-(500-jZ*3),function()return showPhysicsVariables end,function()jU("physics")end,function()return true end,true)end;local function k1()local function k2()local position=bv;local fT=planet.name..". "..#SavedLocations;if bP[1]then local d2,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d2~=nil and d2~=""then fT=fT.." "..bP[1].getConstructName(d2)end end;return aW.AddNewLocation(fT,position,false,true)end;local function k3()TurnBurn=not TurnBurn end;local function k4(k5)if k5==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function k6()aW.UpdatePosition()end;local function k7()aW.ClearCurrentPosition()end;local function k8(fE)local fT=AutopilotTargetName;if fE~=nil and type(fE)=="number"then if fE==0 then return"None"end;fT=bG[fE].name end;if fT==nil then fT=CustomTarget.name end;if fT==nil then fT="None"end;return fT end;local function k9(fE)return"Engage Autopilot: "..k8(fE)end;local function ka(fE)return"Disable Autopilot: "..k8(fE)end;local function kb()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)b_("folOn","F")else b_("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local jZ=50;local j_=260;local kc=jN("Enable Brake Toggle","Disable Brake Toggle",j_,jZ,aG/2-j_/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)jN("Align Prograde","Disable Prograde",j_,jZ,aG/2-j_/2-50-kc.width,aH/2-jZ+380,function()return ProgradeIsOn end,function()k4(1)end)jN("Align Retrograde","Disable Retrograde",j_,jZ,aG/2-j_/2+kc.width+50,aH/2-jZ+380,function()return RetrogradeIsOn end,k4,function()return ar==0 end)apbutton=jN(k9,ka,600,60,aG/2-600/2,aH/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function kd(ke)local fE=bS+ke;if fE>#bG then fE=fE-#bG-1 end;if fE<0 then fE=#bG+fE end;return fE end;apExtraButtons={}for i=0,10 do local button=jN(function(ck)local fE=kd(ck.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..k8(fE)end;return k9(fE)end,function(ck)local fE=kd(ck.apExtraIndex)return ka(fE)end,600,60,aG/2-600/2,aH/2-60/2-330+60*i,function(ck)local fE=kd(ck.apExtraIndex)return fE==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(ck)local fE=kd(ck.apExtraIndex)local kf=AutopilotTargetIndex==fE;AutopilotTargetIndex=fE;aW.UpdateAutopilotTarget()aX.ToggleAutopilot()if not kf and not(Autopilot or VectorToTarget or am or IntoOrbit)then aX.ToggleAutopilot()end end,function()return bR end)button.apExtraIndex=i;apExtraButtons[i]=button end;jN("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,k2,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)jN("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,k6,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)jN("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,k7,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)jZ=60;j_=300;local cd=0;local ce=aH/2-150;jN("View Settings","View Settings",j_,jZ,cd,ce,function()return true end,jW)ce=ce+jZ+20;jN("Enable Turn and Burn","Disable Turn and Burn",j_,jZ,cd,ce,function()return TurnBurn end,k3)cd=10;ce=aH/2-300;jN("Horizontal Takeoff Mode","Vertical Takeoff Mode",j_,jZ,cd+j_+20,ce,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)ce=ce+jZ+20;jN("Engage Orbiting","Cancel Orbiting",j_,jZ,cd+j_+20,ce,function()return IntoOrbit end,aX.ToggleIntoOrbit,function()return ar==0 and bM end)ce=ce+jZ+20;jN("Glide Re-Entry","Cancel Glide Re-Entry",j_,jZ,cd,ce,function()return Reentry end,function()al=1;k4(1)end,function()return planet.hasAtmosphere and not aq end)jN("Parachute Re-Entry","Cancel Parachute Re-Entry",j_,jZ,cd+j_+20,ce,function()return Reentry end,aX.BeginReentry,function()return planet.hasAtmosphere and not aq end)ce=ce+jZ+20;jN("Engage Follow Mode","Disable Follow Mode",j_,jZ,cd,ce,function()return a0 end,kb,function()return m()==1 end)jN("Enable Repair Arrows","Disable Repair Arrows",j_,jZ,cd+j_+20,ce,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)ce=ce+jZ+20;if not ExternalAGG then jN("Enable AGG","Disable AGG",j_,jZ,cd,ce,function()return by end,aX.ToggleAntigrav,function()return antigrav~=nil end)end;jN(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,j_*2,jZ,cd,ce,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)ce=ce+jZ+20;jN(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,j_*2,jZ,cd,ce,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local kg=cA(20)local button=jJ(0,0,cz(70),kg,"INFO")button=jJ(button.x+button.width,button.y,cz(80),kg,"ORBIT")button=jJ(button.x+button.width,button.y,cz(70),kg,"HELP")jJ(button.x+button.width,button.y,cz(70),kg,"HIDE")end;local kh={}local ki=nil;function kh.HUDPrologue(gV)bH,bI=gd(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local kj=ay;local kk=az;local kl=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.3+0.5)..[[)]]local km=ay;local kn=az;if gf()and not brightHud then kj=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]kk=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iN=cz;local iO=cA;gV[#gV+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],kj,kj,kj,km,km,kk,kk,kn,kn,kk,kj,kl,kn,kj,kj,kl,kl,kl,aG,aH,kk,kk,kk,kk,kk,km,kk)if not ki then ki=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iN(630),iO(0),iN(675),iO(45),iN(960),iO(55),iN(1245),iO(45),iN(1290),iO(0),iN(1000),iO(105),iN(1040),iO(59),iN(1250),iO(51),iN(1300),iO(0),iN(1920),iO(0),iN(1920),iO(20),iN(1400),iO(20),iN(1300),iO(105),iN(920),iO(105),iN(880),iO(59),iN(670),iO(51),iN(620),iO(0),iN(0),iO(0),iN(0),iO(20),iN(520),iO(20),iN(620),iO(105),iN(890),iO(59),iN(960),iO(62),iN(1030),iO(59),iN(985),iO(112),iN(1150),iO(112),iN(1100),iO(152),iN(820),iO(152),iN(780),iO(112),iN(935),iO(112),iN(890),iO(59),iN(960),iO(62),iN(1030),iO(59),iN(985),iO(112),iN(1150),iO(112),iN(1100),iO(152),iN(820),iO(152),iN(780),iO(112),iN(935),iO(112))end;gV[#gV+1]=ki;return gV end;function kh.DrawVerticalSpeed(gV,da)gU(gV,da)end;function kh.UpdateHud(gV)local hK=bB;local ko=bC;local h2=ko;local hh=hK;local i1=e(unit.getThrottle())local i6=bs*3.6;local i2=unit.getAxisCommandValue(0)local kp=cz(1770)local kq=cA(310)if AtmoSpeedAssist and bA then i2=K;i1=K*100 end;local gh=gg()local h3="ROLL"if i1==nil then i1=0 end;if not bM then if bs>5 then hK=hJ(bq)ko=hL(bq)else hK=0;ko=0 end;h3="YAW"end;if bI>50000 and not aq then local kr;kr=cl(bI)gV[#gV+1]=cc(kp,kq,"PvP Boundary: "..kr,"pbright txtbig txtmid")end;gV[#gV+1]=ak;gV[#gV+1]=aD;gV[#gV+1]=gj;if bJ~=""then gV[#gV+1]=bJ end;if gk~=""then gV[#gV+1]=gk end;if gl~=""then gV[#gV+1]=gl end;gU(gV,as)if m()==0 or RemoteHud then if bM then h1(gV,centerX,centerY,h2,h3,bM)else h1(gV,centerX,centerY,ko,h3,bM)end;if not gf()or brightHud then if bM then h1(gV,centerX,centerY,h2,h3,bM)hg(gV,hh,h2,centerX,centerY,bM,e(hL(bq)),bs)else h1(gV,centerX,centerY,ko,h3,bM)hg(gV,hK,ko,centerX,centerY,bM,e(ko),bs)end;hn(gV,as,bM)hM(gV,bq,bs,centerX,centerY)end end;i0(gV,gh,i1,i2)i5(gV,i6)i9(gV)j3(gV)return gV end;function kh.HUDEpilogue(gV)gV[#gV+1]="</svg>"return gV end;function kh.ExtraData(gV)local ks=cz(1240)local kt=cA(55)local ku=kt+10;local kv;local iN=cz;local iO=cA;local kw=0;local gh=gg()local kx=iO(99)local ky=iO(80)local kz=iO(85)local kA=iO(31)local kB=0;local kC=0;local kD=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then kw=LastMaxBrakeInAtmo else kw=LastMaxBrake end;local kE,kF=aS.computeDistanceAndTime(bs,0,av,0,0,kw)if kE<0 then kE=0 end;kw=A(kw/(av*g4),2).."g"local kG=a:maxForceForward()kv=core.g()if kv>0.1 then kC=av*kv;kC=A(kC/(av*g4),2).."g"kB=0.5*kG/kv;kB=kB>1000000 and A(kB/1000000,2).."kT"or A(kB/1000,2).."T"end;kG=A(kG/(av*g4),2).."g"local kH=vec3(core.getWorldAcceleration()):len()/9.80665;kv=core.g()gV[#gV+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then ks=cz(1120)kt=cA(55)ku=kt+10 elseif aq then local kI=cz(770)gV[#gV+1]=cc(iN(895),kx,"ATMO","")gV[#gV+1]=f([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],iN(895),kz,iN(-80))gV[#gV+1]=cc(iN(815),ky,f("%.1f%%",ar*100),"txtstart size20")end;gV[#gV+1]=cc(iN(1025),kx,"GRAVITY","txtstart")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(1025),kz,iN(80))gV[#gV+1]=cc(iN(1105),ky,f("%.2fg",kv/9.80665),"size20")gV[#gV+1]=cc(iN(1125),kx,"ACCEL","txtstart")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(1125),kz,iN(80))gV[#gV+1]=cc(iN(1205),ky,f("%.2fg",kH),"size20")gV[#gV+1]=cc(iN(695),kx,"BRK TIME","")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(695),kz,iN(-80))gV[#gV+1]=cc(iN(615),ky,f("%s",co(kF)),"txtstart size20")gV[#gV+1]=cc(iN(635),iO(45),"TRIP","")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(635),iO(31),iN(-90))if travelTime then gV[#gV+1]=cc(iN(532),iO(23),f("%s",co(travelTime)),"txtstart size20")end;gV[#gV+1]=cc(iN(795),kx,"BRK DIST","")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(795),kz,iN(-80))gV[#gV+1]=cc(iN(715),ky,f("%s",cl(kE)),"txtstart size20")gV[#gV+1]=cc(iN(1285),iO(45),"MASS","txtstart")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(1285),iO(31),iN(90))gV[#gV+1]=cc(iN(1388),iO(23),f("%s",kD),"size20")gV[#gV+1]=cc(iN(1220),kx,"THRUST","txtstart")gV[#gV+1]=f([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],iN(1220),kz,iN(80))gV[#gV+1]=cc(iN(1300),ky,f("%s",kG),"size20")gV[#gV+1]=cc(cz(960),cA(175),gh,"pbright txtbig txtmid size20")gV[#gV+1]="</g>"end;function kh.DrawOdometer(gV,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return gV end;local kv;local kB=0;local kC=0;local kw=0;local kD=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then kw=LastMaxBrakeInAtmo else kw=LastMaxBrake end;local kE,kF=aS.computeDistanceAndTime(bs,0,av,0,0,kw)kw=A(kw/(av*g4),2).." g"local kG=a:maxForceForward()kv=core.g()if kv>0.1 then kC=av*kv;kC=A(kC/(av*g4),2).." g"kB=0.5*kG/kv;kB=kB>1000000 and A(kB/1000000,2).." kTons"or A(kB/1000,2).." Tons"end;kG=A(kG/(av*g4),2).." g"if m()==0 or RemoteHud then local kJ=cz(OrbitMapX+10)local kK=cA(OrbitMapY+20)local kL=cz(OrbitMapX+10+OrbitMapSize/1.25)local jL=25;gV[#gV+1]="<g class='txtstart size14 bright'>"gV[#gV+1]=cc(kJ,kK,f("BrkTime: %s",co(kF)))gV[#gV+1]=cc(kL,kK,f("Trip: %.2f km",ad))gV[#gV+1]=cc(kJ,kK+jL,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))gV[#gV+1]=cc(kL,kK+jL,f("BrkDist: %s",cl(kE)))gV[#gV+1]=cc(kJ,kK+jL*2,"Trip Time: "..co(ae))gV[#gV+1]=cc(kL,kK+jL*2,"Total Time: "..co(TotalFlightTime))gV[#gV+1]=cc(kJ,kK+jL*3,f("Mass: %s",kD))gV[#gV+1]=cc(kL,kK+jL*3,f("Max Brake: %s",kw))gV[#gV+1]=cc(kJ,kK+jL*4,f("Max Thrust: %s",kG))if kv>0.1 then gV[#gV+1]=cc(kL,kK+jL*4,f("Max Thrust Mass: %s",kB))gV[#gV+1]=cc(kJ,kK+jL*5,f("Req Thrust: %s",kC))else gV[#gV+1]=cc(kL,kK+jL*5,"Max Mass: n/a")gV[#gV+1]=cc(kJ,kK+jL*6,"Req Thrust: n/a")end end;gV[#gV+1]="</g></g>"return gV end;function kh.DrawWarnings(gV)return i9(gV)end;function kh.DisplayOrbitScreen(gV)return j3(gV)end;function kh.DisplayMessage(gV,ix)if ix~="empty"then local ce=310;for kM in string.gmatch(ix,"([^\n]+)")do ce=ce+35;gV[#gV+1]=cc("50%",ce,kM,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function kh.DrawDeadZone(gV)gV[#gV+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function kh.UpdatePipe()if aq then bJ=""return end;jA()end;function kh.DrawSettings(gV)if#bE>0 then local cd=cz(640)local ce=cA(200)gV[#gV+1]=[[<g class="pbright txtvspd txtstart">]]for cx,cy in pairs(bE)do gV[#gV+1]=cc(cd,ce,cy..": ".._G[cy])ce=ce+20;if cx%12==0 then cd=cd+cz(350)ce=cA(200)end end;gV[#gV+1]=cc(cz(640),cA(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gV[#gV+1]="</g>"end;return gV end;local kN;local kO=cz(1770)local kP=cA(350)local kQ=cA(15)local kR=cz(1370)local bW,kS;local kT=0;function kh.DrawRadarInfo()local function kU()if radarPanelID~=nil and kT==0 then t(radarPanelID)radarPanelID=nil;if kN~=nil then t(kN)kN=nil end else if kT==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,"Periscope","periscope")kN=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,"Radar","radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kT=0 end end;local eX,eY,eW,eZ,e_,eT=aY.GetRadarHud()local B=eZ or 0;if eW>0 then if CollisionSystem then bW=B.."/"..e_.." Plotted : "..eW-e_.." Ignored"else bW="Radar Contacts: "..eW end;gj=cc(kO,kP,bW,"pbright txtbig txtmid")if#eT>0 then gj=gj..cc(kR,kQ,"Friendlies In Range","pbright txtbig txtmid")for cx,cy in pairs(eT)do kQ=kQ+20;gj=gj..cc(kR,kQ,bP[1].getConstructName(cy),"pdim txtmid")end end;if eX==nil and kN==nil then kT=1;kU()end;if eX~=nil and kN~=nil then kU()end;if radarPanelID==nil then kU()end else if eY then gj=cc(kO,kP,bQ.." Radar: Jammed","pbright txtbig txtmid")else gj=cc(kO,kP,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kT=0;kU()end end end;function kh.DrawTanks()if fuelX~=0 and fuelY~=0 then gk=cc(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gB(fuelX,"Atmospheric ","ATMO",aI,gz,gA)gB(fuelX,"Space Fuel T","SPACE",aJ,gx,gy)gB(fuelX,"Rocket Fuel ","ROCKET",aK,gv,gw)end end;function kh.DrawShield()local kV=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local kW=core.getPvPTimer()local kX=shield_1.getResistances()local kY="A: "..10+kX[1]*100 .."% / E: "..10+kX[2]*100 .."% / K:"..10+kX[3]*100 .."% / T: "..10+kX[4]*100 .."%"local cd,ce=shieldX-60,shieldY+30;local kZ=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local gP=e(kZ*2.55)local gQ=f("rgb(%d,%d,%d)",255-gP,gP,0)local cg=""gl=cc(cd,ce,"","txtmid pdim txtfuel")if kZ<10 and kV~="Shield Disabled"then cg="red "end;kW=kW>0 and"   PvPTime: "..co(kW)or""gl=gl..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],cd,ce,gQ,kZ*2,cd,ce,cd+2,ce+10,kZ,kW)gl=gl..cc(cd,ce-5,kV,cg.."txtstart pbright txtbig")gl=gl..cc(cd,ce+30,kY,cg.."txtstart pbright txtsmall")end;function kh.hudtick()if not planet then return end;local function k_(gV)local gS=e(r(aj/(aG/4)*255,0,255))gV[#gV+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+gS,e(J+0.5)-gS,e(I+0.5)-gS)end;local function l0()for _,cy in pairs(aF)do if cy.hovered then if not cy.drawCondition or cy.drawCondition(cy)then cy.toggleFunction(cy)end;cy.hovered=false end end;for _,cy in pairs(bT)do if cy.hovered then SelectedTab=cy.label;cy.hovered=false end end end;local function l1()local function l2(l3,l4,cd,ce,jK,jL)if l3>=cd and l3<=cd+jK and l4>=ce and l4<=ce+jL then return true else return false end end;local cd=ag+aG/2;local ce=ah+aH/2;for _,cy in pairs(aF)do cy.hovered=l2(cd,ce,cy.x,cy.y,cy.width,cy.height)end;for _,cy in pairs(bT)do cy.hovered=l2(cd,ce,cy.x,cy.y,cy.width,cy.height)end;if bR then local l5=false;for _,ck in ipairs(apExtraButtons)do if ck.hovered then l5=true;break end end;if apbutton.hovered then l5=true end;bR=l5 else bR=apbutton.hovered;if not bR then bS=AutopilotTargetIndex end end end;local function l6(gV)if not SelectedTab or SelectedTab==""then SelectedTab="HELP"end;for cx,cy in pairs(bT)do local cg="dim brightstroke"local l7=0.2;if SelectedTab==cx then cg="pbright dimstroke"l7=0.6 end;local l8=""if cy.hovered then l7=0.8;l8=";stroke:white"end;gV[#gV+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cy.width,cy.height,cy.x,cy.y,cg,l7,l8)gV[#gV+1]=cc(cy.x+cy.width/2,cy.y+cy.height/2+5,cy.label,"txt txtmid pdim")end end;local function l9(gV)local function la(gV,lb,hover,cd,ce,ek,lc,ld,le,lf,lg,button)if type(lf)=="function"then lf=lf(button)end;if type(lg)=="function"then lg=lg(button)end;gV[#gV+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",cd,ce,ek,lc)if lb then gV[#gV+1]=f("%s'",ld)else gV[#gV+1]=le end;if hover then gV[#gV+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else gV[#gV+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;gV[#gV+1]=" rx='5'></rect>"gV[#gV+1]=f("<text x='%f' y='%f' font-size='24' fill='",cd+ek/2,ce+lc/2+5)if lb then gV[#gV+1]="black"else gV[#gV+1]="white"end;gV[#gV+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if lb then gV[#gV+1]=f("%s</text>",lf)else gV[#gV+1]=f("%s</text>",lg)end end;local lh=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local li=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local lj=la;for _,cy in pairs(aF)do local jP=cy.disableName;local jO=cy.enableName;if type(jP)=="function"then jP=jP(cy)end;if type(jO)=="function"then jO=jO(cy)end;if not cy.drawCondition or cy.drawCondition(cy)then lj(gV,cy.toggleVar(cy),cy.hovered,cy.x,cy.y,cy.width,cy.height,li,lh,jP,jO,cy)end end end;local lk=A(ResolutionX/2,0)local ll=A(ResolutionY/2,0)local gV={}aV.HUDPrologue(gV)if showHud then aV.UpdateHud(gV)else if AlwaysVSpd then aV.DrawVerticalSpeed(gV,as)end;aV.DisplayOrbitScreen(gV)aV.DrawWarnings(gV)end;if bD and bE~={}then aV.DrawSettings(gV)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(gV)gV[#gV+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(gV,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(gV)end end;l6(gV)if x()==0 then if m()==1 and a1 then if not AltIsOn then l1()l9(gV)end;if not aZ and not a_ then local lm=table.concat(gV,"")gV={}gV[#gV+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gV[#gV+1]=lm;gV[#gV+1]="</body>"aZ=true;gV[#gV+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gV,"")system.setScreen(content)elseif a_ then local lm=table.concat(gV,"")gV={}gV[#gV+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)gV[#gV+1]=lm;gV[#gV+1]="</body>"end;if not aZ then gV[#gV+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lk,ll,ag,ah)end else l0()end else if not a1 and m()==0 then l0()if aj>DeadZone then if DisplayDeadZone then k_(gV)end end elseif a1 and(not AltIsOn or not freeLookToggle)then l1()l9(gV)end;gV[#gV+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],lk,ll,ag,ah)end;gV[#gV+1]=[[</svg></body>]]content=table.concat(gV,"")end;function kh.TenthTick()aV.DrawTanks()if shield_1 then aV.DrawShield()end end;function kh.OneSecond(gV)local function ln()local gL=q()local i6=bs;local lo=gL-au;if i6>1.38889 then i6=i6/1000;local lp=i6*(gL-au)TotalDistanceTravelled=TotalDistanceTravelled+lp;ad=ad+lp end;ae=ae+lo;TotalFlightTime=TotalFlightTime+lo;au=gL end;ln()aV.UpdatePipe()aV.ExtraData(gV)end;function kh.ButtonSetup()jX()k1()aF=g5 end;return kh end;local function lq()local function lr(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function ls()local function lt(lu,lv)return lu.name<lv.name end;bG={}for cx,cy in pairs(b[0])do bG[#bG+1]={name=cy.name,index=cx}end;table.sort(bG,lt)end;local function lw(lx)for cx,cy in pairs(lx)do if cy.name and cy.name==CustomTarget.name then return cx end end;return-1 end;local function ly()bS=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local lz=bG[AutopilotTargetIndex].index;local lA=b[0][lz]if lA.center then AutopilotTargetName=lA.name;ac=aR[0][lz]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=lA;for _,cy in pairs(aR[0])do if cy.name==CustomTarget.planetname then ac=cy;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function lB(gZ)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if gZ==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then ly()else local lz=bG[AutopilotTargetIndex].index;local lA=b[0][lz]if lA~=nil and lA.name=="Space"or iphCondition=="Custom Only"and lA.center or iphCondition=="No Moons"and string.find(lA.name,"Moon")~=nil then if gZ==nil then lB()else lB(1)end else ly()end end else a2="Disengage autopilot before changing Interplanetary Helper"b_("iph","AP")end end;local function k7()local fE=-1;fE=lw(b[0])if fE>-1 then table.remove(b[0],fE)end;fE=-1;fE=lw(SavedLocations)if fE~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fE)end;lB()ls()end;local function k2(fT,position,hG,lC)if dbHud_1 or hG then local p=lr(position)local kv=p.gravity;if lC then kv=unit.getClosestPlanetInfluence()end;local lD={position=position,name=fT,planetname=p.name,gravity=kv,safe=lC}if not hG then SavedLocations[#SavedLocations+1]=lD else for cx,cy in pairs(b[0])do if cy.name and fT==cy.name then table.remove(b[0],cx)end end end;table.insert(b[0],lD)ls()ly()a2="Location saved as "..fT.."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local lE={}function lE.UpdateAtlasLocationsList()ls()end;function lE.UpdateAutopilotTarget()ly()end;function lE.adjustAutopilotTargetIndex(gZ)lB(gZ)end;function lE.findAtlasIndex(lx)lw(lx)end;function lE.UpdatePosition(lF)local fE=lw(SavedLocations)if fE~=-1 then if lF~=nil then SavedLocations[fE].name=lF;AutopilotTargetIndex=AutopilotTargetIndex-1;lB()else local lG=SavedLocations[fE]lG.gravity=unit.getClosestPlanetInfluence()lG.position=bv;lG.safe=true end;a2=SavedLocations[fE].name.." position updated ("..SavedLocations[fE].planetname..")"else a2="Name Not Found"end end;function lE.AddNewLocation(fT,position,hG,lC)k2(fT,position,hG,lC)end;function lE.ClearCurrentPosition()k7()end;for cx,cy in pairs(SavedLocations)do table.insert(b[0],cy)end;ls()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;lE.UpdateAutopilotTarget()return lE end;local function lH()local lI={}local function lJ(er)local lK=AutopilotEndSpeed;if not Autopilot then lK=0 end;if not aq then return aS.computeDistanceAndTime(er,lK,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(er,lK,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function lL(er)local lK=AutopilotEndSpeed;if not Autopilot then lK=0 end;return aS.computeDistanceAndTime(er,lK,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local lM=false;local lN=0;function lI.GetAutopilotBrakeDistanceAndTime(er)return lJ(er)end;function lI.GetAutopilotTBBrakeDistanceAndTime(er)return lL(er)end;local function lO(lP,lQ,lR)lQ=lQ:project_on_plane(lP)lR=lR:project_on_plane(lP)return n(lQ:cross(lR):dot(lP),lQ:dot(lR))end;local function lS()local function lT()local lU=-1;local lV=-1;if vBooster then lU=vBooster.getDistance()end;if hover then lV=hover.getDistance()end;if lU~=-1 and lV~=-1 then if lU<lV then return lU else return lV end elseif lU~=-1 then return lU elseif lV~=-1 then return lV else return-1 end end;local lW=lT()local lX=-1;if telemeter_1 then lX=telemeter_1.getDistance()end;if lW~=-1 and lX~=-1 then if lW<lX then return lW else return lX end elseif lW~=-1 then return lW else return lX end end;local function lY(planet,dO,lZ)local function l_(m0,d4)local dU=vec3(d4)if m0.id==0 then return setmetatable({latitude=dU.x,longitude=dU.y,altitude=dU.z,id=0,systemId=m0.systemId},MapPosition)end;local dV=dU-m0.center;local aj=dV:len()local da=aj-m0.radius;local d8=0;local d9=0;if not ci(aj,0)then local dW=n(dV.y,dV.x)d9=dW>=0 and dW or 2*math.pi+dW;d8=math.pi/2-math.acos(dV.z/aj)end;return setmetatable({latitude=math.deg(d8),longitude=math.deg(d9),altitude=da,id=m0.id,systemId=m0.systemId},MapPosition)end;local m1=l_(planet,dO)m1="::pos{"..m1.systemId..","..m1.id..","..m1.latitude..","..m1.longitude..","..m1.altitude.."}"if lZ then return m1 else system.setWaypoint(m1)return true end end;local m2=false;function lI.showWayPoint(planet,dO,lZ)return lY(planet,dO,lZ)end;function lI.APTick()local function m3()if bO and not BrakeLanding then local dw=bO[1]local fU,fV=bO[2],bO[3]local m4=math.min(fU,fV or fU)local m5=m4/bs;local m6=AutoTakeoff and(bs<42 or ao~=-1)local m7=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if m7 and not m6 and(a8*1.5>m4 or m5<1)then BrakeIsOn=true;aX.cmdThrottle(0)if AltitudeHold then aX.ToggleAltitudeHold()end;if LockPitch then aX.ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then aX.ToggleAutopilot()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if m5<11 then bN=dw.name.." COLLISION "..co(m5).." / "..cl(m4,2)else bN=dw.name.." collision "..co(m5)end;if m5<6 then b_("alarm","AL",2)end else bN=false end end;local function m8(m9,ma,mb)local function mc(m9,dy)m9=vec3(m9)dy=vec3(dy):normalize()local cQ=m9*dy;return cQ.x+cQ.y+cQ.z end;local md=0.001;local me=1;if not aq or not b2 or ao~=-1 or bs<Q then if mb==nil then mb=DampingMultiplier end;if ma==nil then ma=md end;m9=vec3(m9):normalize()local mf=vec3()-m9;local mg=-mc(mf,core.getConstructWorldOrientationRight())*me;local mh=-mc(mf,core.getConstructWorldOrientationUp())*me;if aB==0 then aB=mg/2 end;if aC==0 then aC=mh/2 end;if d(mg)<0.1 then V=V-mg*2 else V=V-(mg+(mg-aB)*mb)end;if d(mh)<0.1 then U=U+mh*2 else U=U+mh+(mh-aC)*mb end;aB=mg;aC=mh;if d(mg)<ma and d(mh)<ma then return true end;return false elseif b2 and ao==-1 then m9=br;if mb==nil then mb=DampingMultiplier end;if ma==nil then ma=md end;m9=vec3(m9):normalize()local mf=bo-m9;local mg=-mc(mf,core.getConstructWorldOrientationRight())*me;local mh=-mc(mf,core.getConstructWorldOrientationUp())*me;if aB==0 then aB=mg/2 end;if aC==0 then aC=mh/2 end;if d(mg)<0.1 then V=V-mg*5 else V=V-(mg+(mg-aB)*mb)end;if d(mh)<0.1 then U=U+mh*5 else U=U+mh+(mh-aC)*mb end;aB=mg;aC=mh;if d(mg)<ma and d(mh)<ma then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=lS()E=q()b3=E;if CollisionSystem then m3()end;if antigrav then by=antigrav.getState()==1 end;local mi=1;local mj=1;local mk=E-b3;local ml=-math.deg(lO(bn,br,bo))local mm=math.deg(lO(bp,br,bo))local gZ=bt*-1;b2=aq and ml<-YawStallAngle or ml>YawStallAngle or mm<-PitchStallAngle or mm>PitchStallAngle;local mn=system.getMouseDeltaX()local mo=system.getMouseDeltaY()if InvertMouse and not a1 then mo=-mo end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local kv=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=r(ag+mn,-aG/2,aG/2)ah=r(ah+mo,-aH/2,aH/2)end else ag=0;ah=0 end else ag=r(ag+mn,-aG/2,aG/2)ah=r(ah+mo,-aH/2,aH/2)aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(mo,-100,100)+0.5)*2*mi;V=(-utils.smoothstep(mn,-100,100)+0.5)*2*mj end end end end;local mp=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not mp then a2="Space Speed Engine Shutoff reached"aX.cmdThrottle(0)end;if not mp and LastIsWarping then if not BrakeIsOn then aX.BrakeToggle()end;if Autopilot then aX.ToggleAutopilot()end end;LastIsWarping=mp;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not lM then BrakeIsOn=true;lM=true elseif not AtmoSpeedAssist and lM then if bs<b7/3.6 then BrakeIsOn=false;lM=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local mq=false;if CustomTarget and al~=1 then mq=m8(CustomTarget.position-bv,0.1)else mq=m8(vec3(br),0.01)end;b0=true;if mq then aX.cmdCruise(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;aX.BeginReentry()end elseif aq and AtmoSpeedAssist then aX.cmdThrottle(1)end elseif bs>Q then m8(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then m8(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;aX.BeginReentry()al=false;an=true else al=false;aX.ToggleAutopilot()end end;if an and CustomTarget and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then aX.ToggleAutopilot()an=false end;if VertTakeOff then b0=true;local mr=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then mr=antigrav.getBaseAltitude()end;if as<mr-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=mr then if by then if Autopilot or VectorToTarget then aX.ToggleVerticalTakeoff()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"b_("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"b_("vtoc","VT")aX.ToggleVerticalTakeoff()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;aX.cmdCruise(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=mr;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ms=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ms)local mt=r(vTpitchPID:get(),-1,1)U=mt end end;if IntoOrbit then local mf;local mu=false;local mv=cl(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget and CustomTarget then mf=CustomTarget.position-bv end;local mw,mx=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local my=bC;if not bc then local mz=false;local mA=false;aX.cmdThrottle(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..mv;if be.VectorToTarget then m8(mf:normalize():project_on_plane(bt))mu=bo:dot(mf:project_on_plane(bn):normalize())>0.95 else m8(br)mu=ml<0.5;if bs<150 then mu=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then mz=true else mz=false end;if my<=bb+1 and my>=bb-1 then mA=true else mA=false end;if mz and mA and mu then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then m8(mf:normalize():project_on_plane(bt))elseif bs>150 then m8(br)end;U=0;if be.VectorToTarget and CustomTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and mf:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or mf:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"b_("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;aX.ToggleIntoOrbit()aX.BeginReentry()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;aX.cmdThrottle(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"b_("orCom","OB")aX.ToggleIntoOrbit()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..mv;bd=true;aX.cmdCruise(mx*3.6+1)local mB=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(mB-bu*r(utils.smoothstep(2000-mB,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local mC=2.75;local mD=d(A(mw*mC))local mE=mD%50;if mE>0 then mD=mD-mE+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..mv;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..mv;mD=mD*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..mv;mD=mD*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..mv;ba=-65;local mF=utils.map(bu,-150,-400,1,0.55)mD=mD*mF end;aX.cmdCruise(e(mD))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local mG=ba-bB;OrbitPitchPID:inject(mG)local mH=r(OrbitPitchPID:get(),-0.5,0.5)U=mH end end;if Autopilot and ar==0 and not al then local function mI(bW,orbit)system.print(bW)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"aX.cmdThrottle(0)P=false;a2=bW;b_("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;aX.ToggleIntoOrbit()end end;local mJ,mK=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local mL=(CustomTarget.position-ac.center):normalize()local mM=mL:project_on_plane((ac.center-bv):normalize()):normalize()local mN=ac.center+mM*(ac.radius+AutopilotTargetOrbit)local mO=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-mN):len()<(bv-mO):len()then mJ=mN else mJ=mO;AutopilotEndSpeed=0 end;AutopilotTargetCoords=mJ;aX.showWayPoint(ac,AutopilotTargetCoords)mK=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;mK=true;AutopilotRealigned=true;TargetSet=true;mJ=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=mJ end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local mL=(bv+br*100000-ac.center):normalize()local mM=mL:project_on_plane((ac.center-bv):normalize()):normalize()if mM:len()<1 then mL=(bv+bo*100000-ac.center):normalize()mM=mL:project_on_plane((ac.center-bv):normalize()):normalize()end;mJ=ac.center+mM*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=mJ;TargetSet=true;mK=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(mJ)-bv):len()local iH,dM,dN=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(dw)if dw.noAtmosphericDensityAltitude>0 then return dw.radius+dw.noAtmosphericDensityAltitude else return dw.radius+dw.surfaceMaxAltitude*1.5 end end)local iI=dM;if dN~=nil and dM~=nil then iI=math.min(dN,dM)end;if iI~=nil and iI<AutopilotDistance and iH.name==ac.name then AutopilotDistance=iI end;local mq=true;local mP=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local ix=cl(mP)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ix..'"}')local a8,a9;if not TurnBurn then a8,a9=lJ(bs)else a8,a9=lL(bs)end;if bs>50 and AutopilotAccelerating then local mf=vec3(mJ)-bv;local mQ=r(math.deg(lO(bn,br:normalize(),mf:normalize()))*bs/500,-90,90)local mR=r(math.deg(lO(bp,br:normalize(),mf:normalize()))*bs/500,-90,90)if d(mQ)<20 and d(mR)<20 then mQ=mQ*2;mR=mR*2 end;if d(mQ)<2 and d(mR)<2 then mQ=mQ*2;mR=mR*2 end;local ml=-math.deg(lO(bn,bo,br:normalize()))local mm=-math.deg(lO(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(mR-mm)local mS=r(apPitchPID:get(),-1,1)U=U+mS;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(mQ-ml)local mT=r(apYawPID:get(),-1,1)V=V+mT;mK=true;if d(mQ)>2 or d(mR)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"b_("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then m8((mJ-bv):normalize())end;if mP<AutopilotTargetOrbit*1.5 then if CustomTarget and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(mP)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local iH,iI=aX.checkLOS((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if iH~=nil and ac.name~=iH.name and iI<AutopilotDistance then a2="Collision with "..iH.name.." in "..cl(iI).."\nClear LOS to continue."ai=5;m2=true else m2=false;a2=""end end end;if not m2 then if not AutopilotCruising and not AutopilotBraking and not mK then mq=m8((mJ-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then mq=m8(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;aX.cmdThrottle(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local mU=unit.getThrottle()if AtmoSpeedAssist then mU=K end;local mV=99999;local kH=-vec3(core.getWorldAcceleration()):dot(br:normalize())local mW=r(br:dot((mJ-bv):normalize()),0,bs)if mW>0 or kH>0 then mV=aS.computeTravelTime(mW,kH,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or mU==0 and P or warmup/4>mV then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then b_("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;aX.cmdThrottle(0)end;local mX=AutopilotDistance;if mX<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lN and bI>2000 then aX.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lN=bI else lN=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then b_("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;aX.cmdThrottle(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then aX.cmdThrottle(1,true)end;local _,mx=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local mf;if CustomTarget then mf=CustomTarget.position-bv end;if CustomTarget and CustomTarget.planetname=="Space"and bs<50 then mI("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget and CustomTarget.planetname~="Space"and bs<=mx and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then mI("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then b_("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=mx then if CustomTarget then if br:normalize():dot(mf:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then b_("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else mI("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else mI("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then mI("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local mX=AutopilotDistance;if mX<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<lN and bI>2000 then aX.ToggleAutopilot()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;lN=bI else lN=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then b_("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local mU=unit.getThrottle()if AtmoSpeedAssist then mU=K end;if mU>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end;AutopilotCruising=false end else if mq then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif mq and not m2 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"b_("apAcc","AP")end;if not P then aX.cmdThrottle(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"b_("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;aX.cmdThrottle(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local mR=0;local ev=bv+vec3(unit.getMasterPlayerRelativePosition())local mY=ev-bv;local mZ=vec3(mY):project_on(bo):len()local m_=vec3(mY):project_on(bp):len()local aj=y(mZ*mZ+m_*m_)m8(mY:normalize())local n0=40;local n1=aj<n0;local n2=100;local n3=r((aj-n0)/2,10,n2)U=0;local mq=d(V)<0.1;if mq and bs<n3 and not n1 then BrakeIsOn=false;mR=-20 else BrakeIsOn=true;mR=0 end;local n4=0;if d(mR-bB)>n4 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(mR-bB)local mS=pitchPID:get()U=mS end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local n5=LastMaxBrakeInAtmo;if n5 then n5=n5*r(bs/100,0.1,1)*ar else n5=LastMaxBrake end;if ar<0.01 then n5=LastMaxBrake end;local n6=bo:project_on_plane(bt):normalize():dot(br)local n7=vec3(core.getWorldAirFrictionAcceleration())local n8=n7:len()*av;if n6>100 then a8,a9=aS.computeDistanceAndTime(n6,100,av,0,0,n5)local n9,na=aS.computeDistanceAndTime(100,0,av,0,0,n5*0.55)a8=a8+n9 else a8,a9=aS.computeDistanceAndTime(n6,0,av,0,0,n5*0.55)end;local mB=HoldAltitude-as-bu;local nb=200+bs;if Reentry or al then minMax=2000+bs end;local nc=1;if AutoTakeoff then nc=r(bs/100,0.1,1)end;local mR=(utils.smoothstep(mB,-nb,nb)-0.5)*2*MaxPitch*nc;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then mR=(utils.smoothstep(mB,-nb*r(20-19*ar*10,1,20),nb*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*nc end;if not AltitudeHold then mR=0 end;if LockPitch~=nil then if bM and not IntoOrbit then mR=LockPitch else LockPitch=nil end end;b0=true;local nd=U;if Reentry then local ne=e(b7)local nf,ng=aS.computeDistanceAndTime(bs,ne/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)nf=nf==-1 and 5000 or nf;local nh=as-(planet.noAtmosphericDensityAltitude+nf)local ni=as>planet.noAtmosphericDensityAltitude+nf*1.35;if ni then mR=ReEntryPitch;if bs<=ne/3.6 and bs>ne/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;aX.cmdThrottle(1)end elseif bA and not ni and not aq then aX.cmdCruise(ne,true)end;if bA then if bs>ne/3.6 and not ni then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then mR=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;mR=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and ni then b0=true elseif not ni then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=ne)then aX.cmdCruise(ne)end;if bs<ne/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then m8(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local mf;if bK then if type(bK)=="table"then mf=bK elseif bK<3 and bK>0 then mf=-bt:cross(br)*5000 elseif bK>=3 then mf=bt:cross(br)*5000 elseif bK<0 then mf=br*25000 end elseif CustomTarget~=nil then mf=CustomTarget.position-bv else mf=ac.center-bv end;local mQ=math.deg(lO(bt:normalize(),br,mf))*2;local nj=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local nk=1000+bs;local nl=(utils.smoothstep(mB-bu*10,-nk,nk)-0.5)*2*MaxPitch;local nm=r(90-nl,0,180)b4=r(mQ*2,-nm,nm)local nn=mQ;mQ=r(r(mQ,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(nj)+4*(bB-mR)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local no=1;if b4~=0 then no=d(nj/b4)end;no=(90-r(d(b4-bC),0,90))/90;local np=mR;if d(bC)>90 then np=-np end;mR=no*r(r(np*math.cos(nj),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(nn)*math.sin(nj),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;mQ=r(mQ,-YawStallAngle*0.80,YawStallAngle*0.80)end;local nq=ml-mQ;if bK and d(nq)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then aX.ToggleAltitudeHold()end;bK=nil;b_("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(nq)local mT=r(yawPID:get(),-1,1)V=V+mT elseif aq and ao>-1 or bs<minRollVelocity then m8(mf)elseif b2 and ar>0.01 then if(ml<-YawStallAngle or ml>YawStallAngle)and ar>0.01 then m8(br)end;if(mm<-PitchStallAngle or mm>PitchStallAngle)and ar>0.01 then mR=r(bB-mm,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local mr=planet:getAltitude(CustomTarget.position)local nh=mf:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and nh<=a8 and(br:project_on_plane(bt):normalize():dot(mf:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"aX.cmdThrottle(0)if AltitudeHold then aX.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(n6<0.1 or nh<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<nh)then if not by then b_("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=nh end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local mf=CustomTarget.position-bv;local mr=planet:getAltitude(CustomTarget.position)local nh=y(mf:len()^2-(as-mr)^2)local n5=LastMaxBrakeInAtmo;if n5 then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,n5/2)StrongBrakes=true;if nh<=a8+bs*mk/2 and br:project_on_plane(bt):normalize():dot(mf:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;aX.BeginReentry()end end;LastDistanceToTarget=nh end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;aX.ToggleIntoOrbit()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then m8(br)mR=r(bB-mm,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=nd;local lX=-1;if BrakeLanding then mR=0;local nr=false;local ns=30;if aT~=nil and aT>0 then local nt=r(ar,0.4,2)local n5=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*nt;local nu=aT*nt+n5-kv;local nw=n5/2-kv;local nx=bs-y(d(nw/2)*20/(0.5*av))*utils.sign(nw)if nx<0 then nx=0 end;local ny;if bs>100 then local nz,_=aS.computeDistanceAndTime(bs,100,av,0,0,n5)local nA,_=aS.computeDistanceAndTime(100,0,av,0,0,y(n5))ny=nz+nA else ny=aS.computeDistanceAndTime(bs,0,av,0,0,y(n5))end;if ny<20 then BrakeIsOn=false else local nB=0;if nx>100 then local nC,_=aS.computeDistanceAndTime(nx,100,av,0,0,nu)local nD,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*nt+y(n5)-kv)nB=nC+nD else nB,_=aS.computeDistanceAndTime(nx,0,av,0,0,aT*nt+y(n5)-kv)end;nB=(nB+15+bs*mk)*1.1;local nE=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if nE then local mr=planet:getAltitude(CustomTarget.position)local nF=as-mr-100;local mf=CustomTarget.position-bv;local nG=y(mf:len()^2-(as-mr)^2)if nG>100 then nE=false elseif nF<=nB or nB==-1 then BrakeIsOn=true;nr=true else BrakeIsOn=false;nr=true end end;if not nE and CalculateBrakeLandingSpeed then if nB>=ns then BrakeIsOn=true else BrakeIsOn=false end;nr=true end end end;if not bA then aX.cmdThrottle(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;lX=ao;if lX>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()b_("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-gZ)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not nr then BrakeIsOn=true elseif not nr then BrakeIsOn=false end end;if AutoTakeoff or am then local iH,dN,dM;if AutopilotTargetCoords~=nil then iH,dN,dM=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(dw)return dw.radius+dw.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;aX.cmdThrottle(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(mR)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;aX.cmdThrottle(0)elseif am then aX.cmdThrottle(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(iH==nil or iH.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then aX.cmdThrottle(0)end;AutopilotAccelerating=true end end;local nH=ao>-1;local nI=bB;if(VectorToTarget or am or bK)and not nH and bs>minRollVelocity and ar>0.01 then local nj=math.rad(d(bC))nI=bB*d(math.cos(nj))+mm*math.sin(nj)end;local nJ=r(mR-nI,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then nJ=r(mR-nI,-85,MaxPitch)elseif ar<0.01 then nJ=r(mR-nI,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or nH or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(nJ)local mS=pitchPID:get()U=U+mS end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;function lI.ToggleIntoOrbit()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then b_("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then b_("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;function lI.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)aX.cmdCruise(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;function lI.checkLOS(m9)local iH,dM,dN=aR:getPlanetarySystem(0):castIntersections(bv,m9,function(dw)if dw.noAtmosphericDensityAltitude>0 then return dw.radius+dw.noAtmosphericDensityAltitude else return dw.radius+dw.surfaceMaxAltitude*1.5 end end)local iI=dM;if dN~=nil and dM~=nil then iI=math.min(dN,dM)end;if iI~=nil then return iH,iI else return nil,nil end end;function lI.ToggleAutopilot()local function nK(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then aX.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;b_("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then b_("apSpc","AP")if ar~=0 then am=true;aX.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then b_("vtt","AP")nK(SpaceTarget)end else b_("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then aX.ToggleIntoOrbit()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then aX.ToggleIntoOrbit()end end end else b_("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;aX.ToggleAltitudeHold()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;aX.ToggleIntoOrbit()else b_("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else b_("apP","AP")am=true;aX.ToggleAltitudeHold()end else b_("apOff","AP")aX.ResetAutopilots(1)end end;function lI.cmdThrottle(cV,nL)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not nL then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,cV)K=r(A(cV*100,0)/100,-1,1)bz=nil end;function lI.cmdCruise(cV,nL)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not nL then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,cV)bz=cV end;function lI.ToggleLockPitch()if LockPitch==nil then b_("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else b_("lkPOff","LP")LockPitch=nil end end;function lI.ToggleAltitudeHold()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;b_("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then aX.ToggleIntoOrbit()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;aX.ToggleIntoOrbit()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then b_("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then aX.ToggleVerticalTakeoff()end else b_("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then aX.ToggleVerticalTakeoff()end end;if am then HoldAltitude=100000 end else b_("altOff","AH")if IntoOrbit then aX.ToggleIntoOrbit()end;if VertTakeOff then aX.ToggleVerticalTakeoff()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;function lI.ResetAutopilots(lI)if lI then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then aX.ToggleVerticalTakeoff()end;if IntoOrbit then aX.ToggleIntoOrbit()end;b0=autoRollPreference;al=false;an=false;af=0 end;function lI.BrakeToggle()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then b_("bkOn","B",1)aX.ResetAutopilots()else b_("bkOff","B",1)end end;function lI.BeginReentry()if Reentry then a2="Re-Entry cancelled"b_("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;b_("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local cf=cl(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..cf;b_("glide","RE")aX.cmdCruise(e(b7))end;AutoTakeoff=false end;function lI.ToggleAntigrav()if antigrav and not ExternalAGG then if by then b_("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;b_("aggOn","AG")antigrav.activate()antigrav.show()end end end;ao=lS()return lI end;function script.onStart()local nM=false;local function nN()local function nO(nP)local nQ=dbHud_1.hasKey;for cx,cy in pairs(nP)do if nQ(cy)then local cQ=g(dbHud_1.getStringValue(cy))if cQ~=nil then _G[cy]=cQ;nM=true end end end end;if dbHud_1 then if not useTheseSettings then nO(c5())coroutine.yield()nO(c)else nO(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;nM=false end;coroutine.yield()if nM then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function nR()local function nS(nT,nU)if nT>nU then nU=nT end;local nV,nW=0,0;if ContainerOptimization>0 then nV=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then nW=FuelTankOptimization*0.05 end;nU=nU*(1-(nV+nW))return nU end;local nX=core.getElementNameById;local nY=fuelX~=0 and fuelY~=0;for cx in pairs(at)do local type=core.getElementTypeById(at[cx])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cx])),'^.*vertical.*$')and core.getElementForwardById(at[cx])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cx])),'^.*vertical.*$')then local nZ=core.getElementForwardById(at[cx])if nZ[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local n_=j(at[cx])if n_>10000 then G=110 elseif n_>1000 then G=55 elseif n_>150 then G=27 end end;aL=aL+j(at[cx])if nY and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local n_=j(at[cx])local kD=l(at[cx])local nT=0;local gL=q()if type=="Atmospheric Fuel Tank"then local nU=400;local o0=35.03;if n_>10000 then nU=51200;o0=5480 elseif n_>1300 then nU=6400;o0=988.67 elseif n_>150 then nU=1600;o0=182.67 end;nT=kD-o0;if fuelTankHandlingAtmo>0 then nU=nU+nU*fuelTankHandlingAtmo*0.2 end;nU=nS(nT,nU)aI[#aI+1]={at[cx],nX(at[cx]),nU,o0,nT,gL}end;if type=="Rocket Fuel Tank"then local nU=320;local o0=173.42;if n_>65000 then nU=40000;o0=25740 elseif n_>6000 then nU=5120;o0=4720 elseif n_>700 then nU=640;o0=886.72 end;nT=kD-o0;if fuelTankHandlingRocket>0 then nU=nU+nU*fuelTankHandlingRocket*0.1 end;nU=nS(nT,nU)aK[#aK+1]={at[cx],nX(at[cx]),nU,o0,nT,gL}end;if type=="Space Fuel Tank"then local nU=600;local o0=35.03;if n_>10000 then nU=76800;o0=5480 elseif n_>1300 then nU=9600;o0=988.67 elseif n_>150 then nU=2400;o0=182.67 end;nT=kD-o0;if fuelTankHandlingSpace>0 then nU=nU+nU*fuelTankHandlingSpace*0.2 end;nU=nS(nT,nU)aJ[#aJ+1]={at[cx],nX(at[cx]),nU,o0,nT,gL}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function o1()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cy in pairs(door)do cy.toggle()end end;if switch then for _,cy in pairs(switch)do cy.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cy in pairs(forcefield)do cy.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function o2()local o3={}local function o4()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local o5={[1]=4480,[6]=4480,[7]=6270}for o6,o7 in pairs(b)do b[o6][0]=o4()b[o6][0].systemId=o6;o3[o6]={}for o8,planet in pairs(b[o6])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=o5[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=o6;planet.bodyId=planet.id;o3[o6][o8]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end end end;aQ=cB()aR=aQ(o3)aS=d_()aU=et()aW=lq()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})nN()coroutine.yield()nR()coroutine.yield()aX=lH()o1()coroutine.yield()o2()aY=eR()aV=g3()aV.ButtonSetup()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;b_("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cy in pairs(door)do cy.toggle()end end;if switch then for _,cy in pairs(switch)do cy.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cy in pairs(forcefield)do cy.toggle()end end;ct()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;b_("stop","SU")end;function script.onTick(o9)local oa=nil;if o9=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"b_("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif o9=="tenthSecond"then local function ob()local oc=system.createData;local od=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=od(panelInterplanetary,"value")interplanetaryHeaderText=oc('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=od(panelInterplanetary,"value")widgetDistanceText=oc('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=od(panelInterplanetary,"value")widgetTravelTimeText=oc('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=od(panelInterplanetary,"value")widgetMaxMassText=oc('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=od(panelInterplanetary,"value")widgetTargetOrbitText=oc('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=od(panelInterplanetary,"value")widgetCurBrakeDistanceText=oc('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=od(panelInterplanetary,"value")widgetCurBrakeTimeText=oc('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=od(panelInterplanetary,"value")widgetMaxBrakeDistanceText=oc('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=od(panelInterplanetary,"value")widgetMaxBrakeTimeText=oc('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=od(panelInterplanetary,"value")widgetTrajectoryAltitudeText=oc('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function oe()t(panelInterplanetary)panelInterplanetary=nil end;local function of()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local er=bs;local mU=unit.getThrottle()/100;if AtmoSpeedAssist then mU=K end;local og,oh=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*mU,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,oi;if not TurnBurn and er>0 then _,oi=aX.GetAutopilotBrakeDistanceAndTime(er)else _,oi=aX.GetAutopilotTBBrakeDistanceAndTime(er)end;local oj=0;local ok=0;if AutopilotCruising or not Autopilot and er>5 then ok=aS.computeTravelTime(er,0,AutopilotDistance)elseif a8+og<AutopilotDistance then oj=AutopilotDistance-(a8+og)ok=aS.computeTravelTime(8333.0556,0,oj)else local ol=(AutopilotDistance-a8)/og;og=AutopilotDistance-a8;oh=oh*ol end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return ok elseif AutopilotBraking then return oi elseif AutopilotCruising then return ok+oi else return oh+a9+ok end end;local function om(kv,on)if kv==nil then kv=core.g()end;kv=A(kv,5)if on~=nil and on or(oa==nil or oa~=kv)then local er=bq:len()local oo=g(unit.getData()).maxBrake;if oo~=nil and oo>0 and aq then oo=oo/r(er/100,0.1,1)oo=oo/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+oo)/2 else LastMaxBrakeInAtmo=oo end end end;if oo~=nil and oo>0 then LastMaxBrake=oo end;oa=kv end end;om(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then aX.cmdCruise(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then ob()end;if AutopilotTargetName~=nil then local op=CustomTarget~=nil;local oq=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()oq=oq>1000000 and A(oq/1000000,2).." kTons"or A(oq/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=of()if op and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ix=cl(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..ix..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..co(travelTime)..'", "unit":""}')ix=cl(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ix..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..co(a9)..'", "unit":""}')ix=cl(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ix..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..co(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",oq)..'", "unit":""}')ix=cl(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ix..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then aX.cmdThrottle(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else oe()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.TenthTick()elseif o9=="oneSecond"then local function os(gV)local ot=0;aD=""local ou=aL;local ov=0;local ow=0;local ox=0;local gP=0;local gQ=""local oy=core.getElementHitPointsById;for cx in pairs(at)do local n_=0;local oz=0;oz=j(at[cx])n_=oy(at[cx])ov=ov+n_;if n_<oz then if n_==0 then ox=ox+1 else ow=ow+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cx]))local cd=position.x;local ce=position.y;local fl=position.z;table.insert(aA,core.spawnArrowSticker(cd,ce,fl+1,"down"))table.insert(aA,core.spawnArrowSticker(cd,ce,fl+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(cd+1,ce,fl,"north"))table.insert(aA,core.spawnArrowSticker(cd+1,ce,fl,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(cd-1,ce,fl,"south"))table.insert(aA,core.spawnArrowSticker(cd-1,ce,fl,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(cd,ce-1,fl,"east"))table.insert(aA,core.spawnArrowSticker(cd,ce-1,fl,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(cd,ce+1,fl,"west"))table.insert(aA,core.spawnArrowSticker(cd,ce+1,fl,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cx])end elseif aM and#aA>0 and aA[11]==at[cx]then for gK in pairs(aA)do core.deleteSticker(aA[gK])end;aA={}end end;ot=e(ov/ou*100)if ot<100 then gV[#gV+1]=cc(0,0,"","pbright txt")gP=e(ot*2.55)gQ=f("rgb(%d,%d,%d)",255-gP,gP,0)if ot<100 then gV[#gV+1]=cc("50%",1035,"Elemental Integrity: "..ot.."%","txtbig txtmid","fill:"..gQ)if ox>0 then gV[#gV+1]=cc("50%",1055,"Disabled Modules: "..ox.." Damaged Modules: "..ow,"txtbig txtmid","fill:"..gQ)elseif ow>0 then gV[#gV+1]=cc("50%",1055,"Damaged Modules: "..ow,"txtbig txtmid","fill:"..gQ)end end end end;local function oA()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;bU=core.getPlayersOnBoard()bV=core.getDockedConstructs()oA()local gV={}aV.OneSecond(gV)if ShouldCheckDamage then os(gV)end;ak=table.concat(gV,"")collectgarbage("collect")elseif o9=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local cQ=g(dbHud_1.getStringValue("SavedLocations"))if cQ~=nil then _G["SavedLocations"]=cQ;local fE=-1;local lD;for cx,cy in pairs(SavedLocations)do if cy.name and cy.name=="SatNav Location"then fE=cx;break end end;if fE~=-1 then lD=SavedLocations[fE]fE=-1;for cx,cy in pairs(b[0])do if cy.name and cy.name=="SatNav Location"then fE=cx;break end end;if fE>-1 then b[0][fE]=lD end;aW.UpdateAtlasLocationsList()a2=lD.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif o9=="msgTick"then local gV={}aV.DisplayMessage(gV,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif o9=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif o9=="hudTick"then aV.hudtick()elseif o9=="apTick"then aX.APTick()elseif o9=="radarTick"then aY.UpdateRadar()elseif o9=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oB(oC,n3)local oD=vec3()local oE=vec3()if oC==axisCommandId.longitudinal then oD=vec3(core.getConstructOrientationForward())oE=bo elseif oC==axisCommandId.vertical then oD=vec3(core.getConstructOrientationUp())oE=bn elseif oC==axisCommandId.lateral then oD=vec3(core.getConstructOrientationRight())oE=bp else return vec3()end;local oF=vec3(core.getWorldGravity())local oG=oF:dot(oE)local oH=vec3(core.getWorldAirFrictionAcceleration())local oI=oH:dot(oE)local oJ=bq:dot(oD)local oK=n3*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(oK-oJ)local oL=targetSpeedPID2:get()local oM=(oL-oI-oG)*oE;return oM end;local function oN(oC,n3)local oD=vec3()local oE=vec3()if oC==axisCommandId.longitudinal then oD=vec3(core.getConstructOrientationForward())oE=bo elseif oC==axisCommandId.vertical then oD=vec3(core.getConstructOrientationUp())oE=bn elseif oC==axisCommandId.lateral then oD=vec3(core.getConstructOrientationRight())oE=bp else return vec3()end;local oF=vec3(core.getWorldGravity())local oG=oF:dot(oE)local oH=vec3(core.getWorldAirFrictionAcceleration())local oI=oH:dot(oE)local oJ=bq:dot(oD)local oK=n3*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(oK-oJ)local oL=targetSpeedPID:get()local oM=(oL-oI-oG)*oE;return oM end;local function oO(oP,gY,lv)local oQ=oP:cross(lv):normalize_inplace()local hK=math.acos(r(oQ:dot(-gY),-1,1))*constants.rad2deg;if oQ:cross(-gY):dot(lv)<0 then hK=-hK end;return hK end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then aX.cmdThrottle(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local oR=r(T+U+system.getControlDeviceForwardInput(),-1,1)local oS=r(W+Z+system.getControlDeviceYawInput(),-1,1)local oT=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local oU=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local oV=bC/180*math.pi;local oW=math.cos(oV)local oX=math.sin(oV)bB=oO(bt,bo,bp*oW+bn*oX)local oY=br:normalize()local oZ=d(bC)local o_=utils.sign(bC)local p0=vec3(core.getWorldAngularVelocity())local p1=oR*pitchSpeedFactor*bp+oS*rollSpeedFactor*bo+oT*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local p2=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and p2>0 or ar>0.0 and p2<autoRollRollThreshold and autoRollPreference)and oS==0 and d(bB)<85 then local p3=b4;local p4=autoRollFactor;if ar==0 then p4=p4/4;b4=0;p3=0 end;if rollPID==nil then rollPID=pid.new(p4*0.01,0,p4*0.1)end;rollPID:inject(p3-bC)local p5=rollPID:get()p1=p1+p5*bo end end;local p6=1;local p7=0;local p8=1;local p9=system.getMouseWheel()if p9>0 then bX()elseif p9<0 then bX(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local pa=throttlePID:get()N=r(pa,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local pb=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=pb end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pc=''local pd=vec3()local pe=oB(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pe,p7)local pf='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pf=pf..ExtraLongitudeTags end;local pg=s:getAxisCommandType(axisCommandId.longitudinal)local ph=s:composeAxisAccelerationFromThrottle(pf,axisCommandId.longitudinal)local pi=oN(axisCommandId.lateral,LeftAmount*1000)pc=pc..' , '.."lateral airfoil , lateral ground "pd=pd+pi;if pd:len()>constants.epsilon then a:setEngineForceCommand(pc,pd,p7,'','','',p8)end;a:setEngineForceCommand(pf,ph,p6)local pj='thrust analog vertical fueled 'local pk='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pk=pk..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then pj=pj..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(pj,pe,p6)else a:setEngineForceCommand(pj,vec3(),p6)end;if LeftAmount~=0 then a:setEngineForceCommand(pk,pi,p6)else a:setEngineForceCommand(pk,vec3(),p6)end;if oU==0 then oU=L end;local pl=-oU*(brakeSpeedFactor*br+brakeFlatFactor*oY)a:setEngineForceCommand('brake',pl)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local n3=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-n3/3.6)local pb=r(brakePID:get(),0,1)oU=r(oU+pb,0,1)end;local pl=-oU*(brakeSpeedFactor*br+brakeFlatFactor*oY)a:setEngineForceCommand('brake',pl)local pc=''local pd=vec3()local pm=false;local pf='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pf=pf..ExtraLongitudeTags end;local pg=s:getAxisCommandType(axisCommandId.longitudinal)if pg==axisCommandType.byThrottle then local ph=s:composeAxisAccelerationFromThrottle(pf,axisCommandId.longitudinal)a:setEngineForceCommand(pf,ph,p6)elseif pg==axisCommandType.byTargetSpeed then local ph=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pc=pc..' , '..pf;pd=pd+ph;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pm=true end end;local pk='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pk=pk..ExtraLateralTags end;local pn=s:getAxisCommandType(axisCommandId.lateral)if pn==axisCommandType.byThrottle then local po=s:composeAxisAccelerationFromThrottle(pk,axisCommandId.lateral)a:setEngineForceCommand(pk,po,p6)elseif pn==axisCommandType.byTargetSpeed then local pi=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pc=pc..' , '..pk;pd=pd+pi end;local pj='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then pj=pj..ExtraVerticalTags end;local pp=s:getAxisCommandType(axisCommandId.vertical)if pp==axisCommandType.byThrottle then local pe=s:composeAxisAccelerationFromThrottle(pj,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(pj,pe,p6,'airfoil','ground','',p8)else a:setEngineForceCommand(pj,vec3(),p6)a:setEngineForceCommand('airfoil vertical',pe,p6,'airfoil','','',p8)a:setEngineForceCommand('ground vertical',pe,p6,'ground','','',p8)end elseif pp==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),p6)end;local pq=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pc=pc..' , '..pj;pd=pd+pq end;if pd:len()>constants.epsilon then if Y~=0 or pm or d(oY:dot(bo))<0.5 then pc=pc..', brake'end;a:setEngineForceCommand(pc,pd,p7,'','','',p8)end end;local pr=torqueFactor*(p1-p0)local ps=vec3(core.getWorldAirFrictionAngularAcceleration())pr=pr-ps;a:setEngineTorqueCommand('torque',pr,p6,'airfoil','','',p8)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local er=bq:len()local pt=0.15;if not bA then local pu=s:getTargetSpeed(axisCommandId.longitudinal)if er*3.6>pu*(1-pt)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif er*3.6<pu*(1-pt)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local mU=unit.getThrottle()if AtmoSpeedAssist then mU=K*100 end;local n3=mU/100;if k==0 then n3=n3*MaxGameVelocity;if er>=n3*(1-pt)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif er<n3*(1-pt)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local ne=e(b7)n3=n3*ne/3.6;if er>=n3*(1-pt)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif er<n3*(1-pt)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local g0=coroutine.status(beginSetup)if g0=="suspended"then local cV,g1=coroutine.resume(beginSetup)if g1 then system.print("ERROR STARTUP: "..g1)end elseif g0=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pv)local function pw(bY)local D=1;local function px(py,bY)local pz={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local pA=py;for _,cy in ipairs(pz)do if bY and pA>cy then py=cy elseif py<cy and not bY then py=cy;break end end;return py end;if bY then D=-1 end;if not ExternalAGG and by then if a1 and bY then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=px(bg,bY)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=px(HoldAltitude,bY)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function pB(pC)if not aq then a2="Flight Assist in Atmo only"return end;local cG=type(pC)if bK==nil then if cG=="table"then if Autopilot or VectorToTarget then aX.ToggleAutopilot()end;b_("180On","BR")elseif pC==1 then b_("bnkLft","BR")else b_("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then aX.ToggleAltitudeHold()if cG~="table"then pC=pC+1 end end;bK=pC else b_("180Off","BR")bK=nil end end;if pv=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;aX.cmdThrottle(0)if vBooster or hover then if aq and ao==-1 then b_("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then b_("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then b_("grOut","LG",1)a.control.extendLandingGears()end else if S then b_("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pv=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pv=="forward"then T=T-1 elseif pv=="backward"then if AltIsOn then pB(-br*5000)else T=T+1 end elseif pv=="left"then if AltIsOn then pB(1)else W=W-1 end elseif pv=="right"then if AltIsOn then pB(3)else W=W+1 end elseif pv=="yawright"then X=X-1 elseif pv=="yawleft"then X=X+1 elseif pv=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pv=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pv=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pv=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pv=="groundaltitudeup"then pw()elseif pv=="groundaltitudedown"then pw(true)elseif pv=="option1"then toggleView=false;if AltIsOn and a1 then local pD=""for i=1,#bU do pD=pD.."| Name: "..system.getPlayerName(bU[i]).." Mass: "..A(core.getBoardedPlayerMass(bU[i])/1000,1).."t "end;system.print("Onboard: "..pD)return end;aW.adjustAutopilotTargetIndex()elseif pv=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#bU do core.forceDeboard(bU[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif pv=="option3"then local function pE()aE=not aE;if not aE then b_("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else b_("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local pD=""for i=1,#bV do pD=pD.."| ID: "..bV[i].." Mass: "..A(core.getDockedConstructMass(bV[i])/1000,1).."t "end;system.print("Docked Ships: "..pD)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;pE()toggleView=false elseif pv=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#bV do core.forceUndock(bV[i])end;a2="Undocked all ships"return end;bK=nil;aX.ToggleAutopilot()elseif pv=="option5"then toggleView=false;aX.ToggleLockPitch()elseif pv=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local pF=shield_1.getVentingCooldown()if pF>0 then a2="Cannot vent again for "..pF.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;aX.ToggleAltitudeHold()elseif pv=="option7"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end elseif pv=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()b_("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)b_("gsOn","GS")end;toggleView=false elseif pv=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)aX.cmdThrottle(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then b_("gyOn","GA")else b_("gyOff","GA")end end;toggleView=false elseif pv=="lshift"then bR=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif pv=="brake"then if BrakeToggleStatus or AltIsOn then aX.BrakeToggle()elseif not BrakeIsOn then aX.BrakeToggle()else BrakeIsOn=true end elseif pv=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pv=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif pv=="stopengines"then local function pG()if E-F<1.5 then b_("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;pG()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)aX.cmdThrottle(0)else aX.cmdThrottle(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then aX.cmdCruise(AtmoSpeedLimit)else aX.cmdCruise(MaxGameVelocity*3.6)end end end elseif pv=="speedup"then bX()elseif pv=="speeddown"then bX(true)elseif pv=="antigravity"and not ExternalAGG then if antigrav~=nil then aX.ToggleAntigrav()end end end;function script.onActionStop(pv)local function pH()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if pv=="forward"then T=0 elseif pv=="backward"then T=0 elseif pv=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif pv=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif pv=="yawright"then X=0 elseif pv=="yawleft"then X=0 elseif pv=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pv=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pv=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pv=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pv=="groundaltitudeup"then pH()toggleView=false elseif pv=="groundaltitudedown"then pH()toggleView=false elseif pv=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif pv=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then aX.BrakeToggle()else BrakeIsOn=false end end elseif pv=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pv)local function pI(bY)local D=1;if bY then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function pJ(bY)local D=1;if bY then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if pv=="groundaltitudeup"then if not a1 then pI()end elseif pv=="groundaltitudedown"then if not a1 then pI(true)end elseif pv=="speedup"then pJ()elseif pv=="speeddown"then pJ(true)end end;function script.onInputText(cf)local function pK(pL,ev,hG)local function pM(ev)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cO='::pos{'..B..','..B..','..B..','..B..','..B..'}'local d1,d2,d8,d9,da=o(ev,cO)if d1=="0"and d2=="0"then return vec3(z(d8),z(d9),z(da))end;d9=math.rad(d9)d8=math.rad(d8)local planet=b[z(d1)][z(d2)]local dX=math.cos(d8)local pN=vec3(dX*math.cos(d9),dX*math.sin(d9),math.sin(d8))return planet.center+(planet.radius+da)*pN end;local position=pM(ev)return aW.AddNewLocation(pL,position,hG)end;local i;local pO,pP=nil,nil;local pQ="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(cf," ")pO=cf;if i~=nil then pO=string.sub(cf,0,i-1)pP=string.sub(cf,i+1)end;if pO=="/help"or pO=="/commands"then for kM in string.gmatch(pQ,"([^\n]+)")do system.print(kM)end;return elseif pO=="/setname"then if pP==nil or pP==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(pP)else a2="Select a saved target to rename first"end elseif shield_1 and pO=="/resist"then if pP==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local cO=B..', '..B..', '..B..', '..B;local pR,pS,pT,pU=o(pP,cO)if pU==nil or pR+pS+pT+pU>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(pR,pS,pT,pU)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif pO=="/addlocation"or string.find(cf,"::pos")~=nil then local hG=false;local pL="0-Temp"if pP==nil or pP==""then pP=pO;hG=true end;i=string.find(pP,"::")if not hG then pL=string.sub(pP,1,i-2)end;local ev=string.sub(pP,i)pK(pL,ev,hG)elseif pO=="/agg"then if pP==nil or pP==""then a2="Usage: /agg targetheight"return end;pP=z(pP)if pP<1000 then pP=1000 end;AntigravTargetAltitude=pP;a2="AGG Target Height set to "..pP elseif pO=="/G"then if pP==nil or pP==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pP=="dump"then for cx,cy in pairs(c5())do if type(_G[cy])=="boolean"then if _G[cy]==true then system.print(cy.." true")else system.print(cy.." false")end elseif _G[cy]==nil then system.print(cy.." nil")else system.print(cy.." ".._G[cy])end end;return end;i=string.find(pP," ")local pV=string.sub(pP,0,i-1)local pW=string.sub(pP,i+1)for cx,cy in pairs(c5())do if cy==pV then a2="Variable "..pV.." changed to "..pW;local pX=type(_G[cy])if pX=="number"then pW=z(pW)if cy=="AtmoSpeedLimit"then b7=pW end elseif pX=="boolean"then if string.lower(pW)=="true"then pW=true else pW=false end end;_G[cy]=pW;return end end;a2="No such global variable: "..pV elseif pO=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif pO=="/copydatabank"then if dbHud_2 then ct(true)else a2="Spare Databank required to copy databank"end elseif pO=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(d2)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(d2)if bP[1]and CollisionSystem then if#bL>650 then d2=tostring(d2)bL[d2]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
