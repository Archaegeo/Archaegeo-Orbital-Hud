name: ArchHud - Archaegeo v1.359 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        turnAssist = true --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        IntruderAlertSystem = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        Cockpit = false --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        LockPitchTarget = 0 --export:
        TargetOrbitRadius = 1.4 --export:
        LowOrbitHeight = 1000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 5000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        turnAssistFactor = 2 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)script={}VERSION_NUMBER=1.359;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;safeMass=0;iphCondition="All"stablized=true;local b={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","safeMass","iphCondition","stablized"}local c=math.abs;local d=math.floor;local e=string.format;local f=json.decode;local g=json.encode;local h=core.getElementMaxHitPointsById;local j=unit.getAtmosphereDensity;local k=core.getElementMassById;local l=a.control.isRemoteControlled;local m=math.atan;local n=string.match;local o=system.getTime;local vec3=vec3;local p=utils.clamp;local q=a.axisCommandManager;local r=system.destroyWidgetPanel;local s=system.updateData;local t=system.addDataToWidget;local u=system.lockView;local v=system.isViewLocked;local w=math.sqrt;local x=tonumber;local core=core;local function y(z,A)local mult=10^(A or 0)return d(z*mult+0.5)/mult end;local B=o()local C=o()local D=16;local E=13;local F=SafeR;local G=SafeB;local H=SafeG;local I=0;local J=0;local K=false;local L=0;local M=false;local N=false;local O=55;local P=false;local Q=false;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=false;local Z=false;local a0="empty"local a1=5;local a2=5;local a3=a1;local a4=a2;local a5=false;local a6,a7=0;local a8,a9=0;local aa=nil;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=3;local ah=0;local ai=""local aj=false;local ak=false;local al=false;local am=-1;local an=""local ao=j()>0;local ap=j()local aq=core.getAltitude()local ar=core.getElementIdList()local as=o()local at=core.getConstructMass()local au=false;local av=nil;local aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]local ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]local ay={}local az=0;local aA=0;local aB=""local aC=true;local aD={}local aE=ResolutionX;local aF=ResolutionY;local aG={}local aH={}local aI={}local aJ=0;local aK=false;local aL={}local aM={}local aN=d(1/apTickRate)*2;local aO={}local aP={}local aQ={}local aR={}local aS=false;local aT=0;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=nil;local a_=nil;local b0=nil;local b1=nil;local b2=nil;local b3=nil;local b4=nil;local b5=nil;local b6=false;local b7=false;local b8=autoRollPreference;local b9=LandingGearGroundHeight;local ba=false;local bb=o()local bc=0;local bd=0;local be=0;local bf=AtmoSpeedLimit;local bg=0;local bh=nil;local bi=0;local bj=0;local bk=false;local bl=false;local bm={VectorToTarget=false}local bn=false;local bo=0;local bp=nil;local bq=false;local br=false;local bs=false;local bt=false;local bu=0;local bv=vec3(core.getConstructWorldOrientationUp())local bw=vec3(core.getConstructWorldOrientationForward())local bx=vec3(core.getConstructWorldOrientationRight())local by=vec3(core.getWorldVelocity())local bz=vec3(by):len()local bA=vec3(core.getWorldVertical())local bB=-bA:dot(by)local bC=vec3(core.getConstructWorldPos())local bD=0;local bE=false;local bF=false;local bG=nil;local bH=true;local bI=0;local bJ=0;local bK=false;local bL={}local bM=showHud;local bN={}local bO=false;local bP=""local bQ=""local bR=nil;local bS={}local bT=unit.getClosestPlanetInfluence()>0;local bU=false;local bV=nil;function Log(bW,bX)local self={}self.Name=bW or'Log'self.Value=bX=='number'and 0 or{}self.Type=bX or'mean'function self.Update(bY)if self.Type=='number'then self.Value=bY else self.Value[#self.Value]=bY end end;function self.getString()if self.Type=='number'then return tostring(self.Value)elseif self.Type=='time'then return utils.round(self.getMean()*1000,0.0001)..'ms ('..#self.Value..")"elseif self.Type=='mean'then return tostring(utils.round(self.getMean(),0.01))end end;function self.getValue()if self.Type=='number'then return self.value else return self.getMean()end end;function self.addValue(bY)if self.Type=='number'then return end;table.insert(self.Value,1,bY)if#self.Value>1000 then self.Value[1001]=nil end end;function self.getMean()local bZ=0;for i=1,#self.Value do bZ=bZ+self.Value[i]end;return bZ/#self.Value end;return self end;function Logger()local self={}self.Logs={}function self.CreateLog(bW,type)local b_=Log(bW,type)Register(b_)return b_ end;function self.getLogs()local c0={}for _,c1 in pairs(self.Logs)do c0[#c0+1]=c1.Name..': '..c1.getString()end;return c0 end;function Register(b_)self.Logs[#self.Logs+1]=b_ end;return self end;local function c2(c3)local c4,c5,c6=aZ:getPlanetarySystem(0):castIntersections(bC,c3,function(c7)if c7.noAtmosphericDensityAltitude>0 then return c7.radius+c7.noAtmosphericDensityAltitude else return c7.radius+c7.surfaceMaxAltitude*1.5 end end)local c8=c5;if c6~=nil and c5~=nil then c8=math.min(c6,c5)end;if c8~=nil then return c4,c8 else return nil,nil end end;local function c9(ca,cb,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..ca.."|"..cb.."|"..soundVolume)end end;local function cc(cd,ce)for i=1,#ce do cd[#cd+1]=ce[i]end;return cd end;local function cf(cg)local ch={}local ci={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","turnAssist","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","IntruderAlertSystem","AlwaysVSpd","BarFuelDisplay","showHelp","Cockpit","voices","alerts","CollisionSystem"}local cj={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","LockPitchTarget","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization"}local ck={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cl={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","turnAssistFactor","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not cg then cc(ch,ci)cc(ch,cj)cc(ch,ck)cc(ch,cl)return ch elseif cg=="boolean"then return ci elseif cg=="handling"then return cj elseif cg=="hud"then return ck elseif cg=="physics"then return cl end end;local function cm(cn,co,cp,cq,cr)if cq==nil then cq=""end;if cr==nil then cr=""end;return e([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cq,cn,co,cr,cp)end;local function cs(ct,cu)if q:getAxisCommandType(0)~=axisCommandType.byThrottle and not cu then a.control.cancelCurrentControlMasterMode()end;q:setThrottleCommand(axisCommandId.longitudinal,ct)I=p(y(ct*100,0)/100,-1,1)end;local function cv(ct,cu)if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cu then a.control.cancelCurrentControlMasterMode()end;q:setTargetSpeedCommand(axisCommandId.longitudinal,ct)bG=ct end;local function cw(cx,cy)if cx==0 then return c(cy)<1e-09 end;if cy==0 then return c(cx)<1e-09 end;return c(cx-cy)<math.max(c(cx),c(cy))*epsilon end;local function cz(ah,cA)local cB=ah>100000;if cA==nil then cA=1 end;if cB then return y(ah/1000/200,cA).."SU"elseif ah<1000 then return y(ah,cA).."M"else return y(ah/1000,cA).."KM"end end;local function cC()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b8=true;ad=0;if ao and am==-1 then BrakeLanding=false;AltitudeHold=true;ad=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cv(d(bf))end else bq=false;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cD()bq=false;bi=nil;bj=nil;bu=0;if ap==0 then if IntoOrbit then c9("orOff","AP")IntoOrbit=false;bk=false;bp=nil;b8=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;bm.VectorToTarget=false;bm.AutopilotAlign=false;bn=false elseif bT then c9("orOn","AP")IntoOrbit=true;b8=true;if bp==nil then bp=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a0="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bk=false;bp=nil;b8=autoRollPreference;if AltitudeHold then AltitudeHold=false end;bm.VectorToTarget=false;bm.AutopilotAlign=false;bn=false end end;local function cE()if B-bd<1.5 then if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.spaceEngineMinAltitude-50;c9("11","EP")else if bT then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bo=HoldAltitude;bn=true;if not IntoOrbit then cD()end;bk=true end end;bd=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else bd=B end;if bT and ap==0 then bo=aq;bn=true;bk=true;cD()if IntoOrbit then bd=B else bd=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;Y=false;b8=true;LockPitch=nil;bq=false;if am==-1 then c9("altOn","AH")AutoTakeoff=false;if bd>-1 then if unit.getClosestPlanetInfluence()>0 then HoldAltitude=aq end end;if VertTakeOff then cC()end else c9("lfs","LS")AutoTakeoff=true;if bd>-1 then HoldAltitude=aq+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;q:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bE then cC()end end;if ak then HoldAltitude=100000 end else c9("altOff","AH")if IntoOrbit then cD()end;if VertTakeOff then cC()end;b8=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;bd=0 end end;local function cF()local function cG(SpaceTarget)bU=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cE()end end;VectorStatus="Proceeding to Waypoint"end;if B-be<1.5 and ap>0 then if not bt then a0="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ap>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c9("orH","OH")end;be=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else be=B end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not ak and not IntoOrbit then b3.UpdateAutopilotTarget()b4.showWayPoint(aa,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c9("apSpc","AP")if ap~=0 then ak=true;cE()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ap>0 then if not VectorToTarget then c9("vtt","AP")cG(SpaceTarget)end else c9("apOn","AP")if not(aa.name==planet.name and bT)then bq=false;Autopilot=true elseif not ao then if IntoOrbit then cD()end;bo=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bn=true;bm.AutopilotAlign=true;bm.VectorToTarget=true;bk=false;if not IntoOrbit then cD()end end end else c9("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ap~=0 then ak=true;cE()else Autopilot=true end end elseif ap==0 then if CustomTarget==nil and(aa.name==planet.name and bT)and not IntoOrbit then WaypointSet=false;bq=false;bk=false;cD()else c9("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;Y=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;N=false;LockPitch=nil;WaypointSet=false end else c9("apP","AP")ak=true;cE()end else c9("apOff","AP")ak=false;Autopilot=false;AutopilotRealigned=false;VectorToTarget=false;N=false;AutoTakeoff=false;AltitudeHold=false;VectorToTarget=false;HoldAltitude=aq;TargetSet=false;Reentry=false;if IntoOrbit then cD()end end end;local function cH()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b8=autoRollPreference end;if BrakeIsOn then c9("bkOn","B",1)VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bR=nil;if not bF then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cC()end;if IntoOrbit then cD()end;b8=autoRollPreference;aj=false;al=false;ad=0 else c9("bkOff","B",1)end end;local function cI()if Reentry then a0="Re-Entry cancelled"c9("reOff","RE")Reentry=false;b8=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a0="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ag=5 elseif not P then Reentry=true;if q:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b8=true;BrakeIsOn=false;a0="Beginning Parachute Re-Entry - Strap In.  Target speed: "..bf;c9("par","RE")else Reentry=true;AltitudeHold=true;b8=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-planet.spaceEngineMinAltitude/10 end;local cp=cz(HoldAltitude)a0="Beginning Re-entry.  Target speed: "..bf.." Target Altitude: "..cp;c9("glide","RE")cv(d(bf))end;AutoTakeoff=false end;local function cJ()if antigrav and not ExternalAGG then if bF then c9("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c9("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cK(cL)local cM=0;local cN=0;local cO=0;if cL<60 then cL=d(cL)elseif cL<3600 then cM=d(cL/60)cL=d(cL%60)elseif cL<86400 then cN=d(cL/3600)cM=d(cL%3600/60)else cO=d(cL/86400)cN=d(cL%86400/3600)end;if cO>0 then return cO.."d "..cN.."h "elseif cN>0 then return cN.."h "..cM.."m "elseif cM>0 then return cM.."m "..cL.."s"elseif cL>0 then return cL.."s"else return"0s"end end;local function cP(cQ)local function cR(cS)for cT,bY in pairs(cS)do dbHud_1.setStringValue(bY,g(_G[bY]))if cQ and dbHud_2 then dbHud_2.setStringValue(bY,g(_G[bY]))end end end;if dbHud_1 then cR(b)cR(cf())system.print("Saved Variables to Datacore")if cQ and dbHud_2 then a0="Databank copied.  Remove copy when ready."end end end;local function cU()return{[0]={[0]={GM=0,bodyId=0,center={x=0,y=0,z=0},name='Space',planetarySystemId=0,radius=0,hasAtmosphere=false,gravity=0,noAtmosphericDensityAltitude=0,surfaceMaxAltitude=0},[2]={name="Alioth",description="Alioth is the planet selected by the arkship for landfall; it is a typical goldilocks planet where humanity may rebuild in the coming decades. The arkship geological survey reports mountainous regions alongside deep seas and lush forests. This is where it all starts.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9401,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=2,GM=157470826617,gravity=1.0082568597356114,fullAtmosphericDensityMaxAltitude=-10,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6272,numSatellites=2,positionFromSun=2,center={x=-8,y=-8,z=-126303},radius=126067.8984375,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=3410,surfaceArea=199718780928,surfaceAverageAltitude=200,surfaceMaxAltitude=1100,surfaceMinAltitude=-330,systemZone="High",territories=259472,type="Planet",waterLevel=0,planetarySystemId=0},[21]={name="Alioth Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=21,GM=2118960000,gravity=0.24006116402380084,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=457933,y=-1509011,z=115524},radius=30000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=11309733888,surfaceAverageAltitude=140,surfaceMaxAltitude=200,surfaceMinAltitude=10,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[22]={name="Alioth Moon 4",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=22,GM=2165833514,gravity=0.2427018259886451,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-1692694,y=729681,z=-411464},radius=30330,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=11559916544,surfaceAverageAltitude=-15,surfaceMaxAltitude=-5,surfaceMinAltitude=-50,systemZone=nil,territories=14522,type="",waterLevel=nil,planetarySystemId=0},[5]={name="Feli",description="Feli is easily identified by its massive and deep crater. Outside of the crater, the arkship geological survey reports a fairly bland and uniform planet, it also cannot explain the existence of the crater. Feli is particular for having an extremely small atmosphere, allowing life to develop in the deeper areas of its crater but limiting it drastically on the actual surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.5488,atmosphericEngineMaxAltitude=66725,biosphere="Barren",classification="Mesoplanet",bodyId=5,GM=16951680000,gravity=0.4801223280476017,fullAtmosphericDensityMaxAltitude=30,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=78500,numSatellites=1,positionFromSun=5,center={x=-43534464,y=22565536,z=-48934464},radius=41800,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=42800,surfaceArea=21956466688,surfaceAverageAltitude=18300,surfaceMaxAltitude=18500,surfaceMinAltitude=46,systemZone="Low",territories=27002,type="Planet",waterLevel=nil,planetarySystemId=0},[50]={name="Feli Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=50,GM=499917600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-43902841.78,y=22261034.7,z=-48862386},radius=14000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=800,surfaceMaxAltitude=900,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[120]={name="Ion",description="Ion is nothing more than an oversized ice cube frozen through and through. It is a largely inhospitable planet due to its extremely low temperatures. The arkship geological survey reports extremely rough mountainous terrain with little habitable land.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9522,atmosphericEngineMaxAltitude=10480,biosphere="Ice",classification="Hypopsychroplanet",bodyId=120,GM=7135606629,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=-30,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=17700,numSatellites=2,positionFromSun=12,center={x=2865536.7,y=-99034464,z=-934462.02},radius=44950,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=6410,surfaceArea=25390383104,surfaceAverageAltitude=500,surfaceMaxAltitude=1300,surfaceMinAltitude=250,systemZone="Average",territories=32672,type="Planet",waterLevel=nil,planetarySystemId=0},[121]={name="Ion Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=121,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2472916.8,y=-99133747,z=-1133582.8},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=100,surfaceMaxAltitude=200,surfaceMinAltitude=3,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[122]={name="Ion Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=122,GM=176580000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=2995424.5,y=-99275010,z=-1378480.7},radius=15000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=-1900,surfaceMaxAltitude=-1400,surfaceMinAltitude=-2100,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[9]={name="Jago",description="Jago is a water planet. The large majority of the planet&apos;s surface is covered by large oceans dotted by small areas of landmass across the planet. The arkship geological survey reports deep seas across the majority of the planet with sub 15 percent coverage of solid ground.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9835,atmosphericEngineMaxAltitude=9695,biosphere="Water",classification="Mesoplanet",bodyId=9,GM=18606274330,gravity=0.5041284298678057,fullAtmosphericDensityMaxAltitude=-90,habitability="Very High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10900,numSatellites=0,positionFromSun=9,center={x=-94134462,y=12765534,z=-3634464},radius=61590,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=5900,surfaceArea=47668367360,surfaceAverageAltitude=0,surfaceMaxAltitude=1200,surfaceMinAltitude=-500,systemZone="Very High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[100]={name="Lacobus",description="Lacobus is an ice planet that also features large bodies of water. The arkship geological survey reports deep oceans alongside a frozen and rough mountainous environment. Lacobus seems to feature regional geothermal activity allowing for the presence of water on the surface.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7571,atmosphericEngineMaxAltitude=11120,biosphere="Ice",classification="Psychroplanet",bodyId=100,GM=13975172474,gravity=0.45611622622739767,fullAtmosphericDensityMaxAltitude=-20,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=12510,numSatellites=3,positionFromSun=10,center={x=98865536,y=-13534464,z=-934461.99},radius=55650,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=6790,surfaceArea=38917074944,surfaceAverageAltitude=800,surfaceMaxAltitude=1660,surfaceMinAltitude=250,systemZone="Average",territories=50432,type="Planet",waterLevel=0,planetarySystemId=0},[102]={name="Lacobus Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=102,GM=444981600,gravity=0.14403669598391783,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99180968,y=-13783862,z=-926156.4},radius=18000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=4071504128,surfaceAverageAltitude=150,surfaceMaxAltitude=300,surfaceMinAltitude=10,systemZone=nil,territories=5072,type="",waterLevel=nil,planetarySystemId=0},[103]={name="Lacobus Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=103,GM=211503600,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=99250052,y=-13629215,z=-1059341.4},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=-1380,surfaceMaxAltitude=-1280,surfaceMinAltitude=-1880,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[101]={name="Lacobus Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=101,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=98905288.17,y=-13950921.1,z=-647589.53},radius=15000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=500,surfaceMaxAltitude=820,surfaceMinAltitude=3,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[1]={name="Madis",description="Madis is a barren wasteland of a rock; it sits closest to the sun and temperatures reach extreme highs during the day. The arkship geological survey reports long rocky valleys intermittently separated by small ravines.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8629,atmosphericEngineMaxAltitude=7165,biosphere="Barren",classification="hyperthermoplanet",bodyId=1,GM=6930729684,gravity=0.36009174603570127,fullAtmosphericDensityMaxAltitude=220,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8050,numSatellites=3,positionFromSun=1,center={x=17465536,y=22665536,z=-34464},radius=44300,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=4480,surfaceArea=24661377024,surfaceAverageAltitude=750,surfaceMaxAltitude=850,surfaceMinAltitude=670,systemZone="Low",territories=30722,type="Planet",waterLevel=nil,planetarySystemId=0},[10]={name="Madis Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=10,GM=78480000,gravity=0.08002039003323584,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17448118.224,y=22966846.286,z=143078.82},radius=10000,safeAreaEdgeAltitude=500000,size="XL",spaceEngineMinAltitude=0,surfaceArea=1256637056,surfaceAverageAltitude=210,surfaceMaxAltitude=420,surfaceMinAltitude=0,systemZone=nil,territories=1472,type="",waterLevel=nil,planetarySystemId=0},[11]={name="Madis Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=11,GM=237402000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17194626,y=22243633.88,z=-214962.81},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=-700,surfaceMaxAltitude=300,surfaceMinAltitude=-2900,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[12]={name="Madis Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=12,GM=265046609,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=17520614,y=22184730,z=-309989.99},radius=15000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[26]={name="Sanctuary",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9666,atmosphericEngineMaxAltitude=6935,biosphere="",classification="",bodyId=26,GM=68234043600,gravity=1.0000000427743831,fullAtmosphericDensityMaxAltitude=-30,habitability="",hasAtmosphere=true,isSanctuary=true,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=0,center={x=-1404835,y=562655,z=-285074},radius=83400,safeAreaEdgeAltitude=0,size="L",spaceEngineMinAltitude=4230,surfaceArea=87406149632,surfaceAverageAltitude=80,surfaceMaxAltitude=500,surfaceMinAltitude=-60,systemZone=nil,territories=111632,type="",waterLevel=0,planetarySystemId=0},[6]={name="Sicari",description="Sicari is a typical desert planet; it has survived for millenniums and will continue to endure. While not the most habitable of environments it remains a relatively untouched and livable planet of the Alioth sector. The arkship geological survey reports large flatlands alongside steep plateaus.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.897,atmosphericEngineMaxAltitude=7725,biosphere="Desert",classification="Mesoplanet",bodyId=6,GM=10502547741,gravity=0.4081039739797361,fullAtmosphericDensityMaxAltitude=-625,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=8770,numSatellites=0,positionFromSun=6,center={x=52765536,y=27165538,z=52065535},radius=51100,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=4480,surfaceArea=32813432832,surfaceAverageAltitude=130,surfaceMaxAltitude=220,surfaceMinAltitude=50,systemZone="Average",territories=41072,type="Planet",waterLevel=nil,planetarySystemId=0},[7]={name="Sinnen",description="Sinnen is a an empty and rocky hell. With no atmosphere to speak of it is one of the least hospitable planets in the sector. The arkship geological survey reports mostly flatlands alongside deep ravines which look to have once been riverbeds. This planet simply looks to have dried up and died, likely from solar winds.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9226,atmosphericEngineMaxAltitude=10335,biosphere="Desert",classification="Mesoplanet",bodyId=7,GM=13033380591,gravity=0.4401121421448438,fullAtmosphericDensityMaxAltitude=-120,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=11620,numSatellites=1,positionFromSun=7,center={x=58665538,y=29665535,z=58165535},radius=54950,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=6270,surfaceArea=37944188928,surfaceAverageAltitude=317,surfaceMaxAltitude=360,surfaceMinAltitude=23,systemZone="Average",territories=48002,type="Planet",waterLevel=nil,planetarySystemId=0},[70]={name="Sinnen Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=70,GM=396912600,gravity=0.1360346539426409,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=58969616,y=29797945,z=57969449},radius=17000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=3631681280,surfaceAverageAltitude=-2050,surfaceMaxAltitude=-1950,surfaceMinAltitude=-2150,systemZone=nil,territories=4322,type="",waterLevel=nil,planetarySystemId=0},[110]={name="Symeon",description="Symeon is an ice planet mysteriously split at the equator by a band of solid desert. Exactly how this phenomenon is possible is unclear but some sort of weather anomaly may be responsible. The arkship geological survey reports a fairly diverse mix of flat-lands alongside mountainous formations.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.9559,atmosphericEngineMaxAltitude=6920,biosphere="Ice, Desert",classification="Hybrid",bodyId=110,GM=9204742375,gravity=0.3920998898971822,fullAtmosphericDensityMaxAltitude=-30,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=7800,numSatellites=0,positionFromSun=11,center={x=14165536,y=-85634465,z=-934464.3},radius=49050,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=4230,surfaceArea=30233462784,surfaceAverageAltitude=39,surfaceMaxAltitude=450,surfaceMinAltitude=126,systemZone="High",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[4]={name="Talemai",description="Talemai is a planet in the final stages of an Ice Age. It seems likely that the planet was thrown into tumult by a cataclysmic volcanic event which resulted in its current state. The arkship geological survey reports large mountainous regions across the entire planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.8776,atmosphericEngineMaxAltitude=9685,biosphere="Barren",classification="Psychroplanet",bodyId=4,GM=14893847582,gravity=0.4641182439650478,fullAtmosphericDensityMaxAltitude=-78,habitability="Average",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=10890,numSatellites=3,positionFromSun=4,center={x=-13234464,y=55765536,z=465536},radius=57500,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=5890,surfaceArea=41547563008,surfaceAverageAltitude=580,surfaceMaxAltitude=610,surfaceMinAltitude=520,systemZone="Average",territories=52922,type="Planet",waterLevel=nil,planetarySystemId=0},[42]={name="Talemai Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=42,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13058408,y=55781856,z=740177.76},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=720,surfaceMaxAltitude=850,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0},[40]={name="Talemai Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=40,GM=141264000,gravity=0.09602446196397631,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-13503090,y=55594325,z=769838.64},radius=12000,safeAreaEdgeAltitude=500000,size="S",spaceEngineMinAltitude=0,surfaceArea=1809557376,surfaceAverageAltitude=250,surfaceMaxAltitude=450,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[41]={name="Talemai Moon 3",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=41,GM=106830900,gravity=0.08802242599860607,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=-12800515,y=55700259,z=325207.84},radius=11000,safeAreaEdgeAltitude=500000,size="XS",spaceEngineMinAltitude=0,surfaceArea=1520530944,surfaceAverageAltitude=190,surfaceMaxAltitude=400,surfaceMinAltitude=0,systemZone=nil,territories=1922,type="",waterLevel=nil,planetarySystemId=0},[8]={name="Teoma",description="[REDACTED] The arkship geological survey [REDACTED]. This planet should not be here.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.7834,atmosphericEngineMaxAltitude=5580,biosphere="Forest",classification="Mesoplanet",bodyId=8,GM=18477723600,gravity=0.48812434578525177,fullAtmosphericDensityMaxAltitude=15,habitability="High",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=6280,numSatellites=0,positionFromSun=8,center={x=80865538,y=54665536,z=-934463.94},radius=62000,safeAreaEdgeAltitude=500000,size="L",spaceEngineMinAltitude=3420,surfaceArea=48305131520,surfaceAverageAltitude=700,surfaceMaxAltitude=1100,surfaceMinAltitude=-200,systemZone="High",territories=60752,type="Planet",waterLevel=0,planetarySystemId=0},[3]={name="Thades",description="Thades is a scorched desert planet. Perhaps it was once teaming with life but now all that remains is ash and dust. The arkship geological survey reports a rocky mountainous planet bisected by a massive unnatural ravine; something happened to this planet.",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0.03552,atmosphericEngineMaxAltitude=32180,biosphere="Desert",classification="Thermoplanet",bodyId=3,GM=11776905000,gravity=0.49612641213015557,fullAtmosphericDensityMaxAltitude=150,habitability="Low",hasAtmosphere=true,isSanctuary=false,noAtmosphericDensityAltitude=32800,numSatellites=2,positionFromSun=3,center={x=29165536,y=10865536,z=65536},radius=49000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=21400,surfaceArea=30171856896,surfaceAverageAltitude=13640,surfaceMaxAltitude=13690,surfaceMinAltitude=370,systemZone="Low",territories=38882,type="Planet",waterLevel=nil,planetarySystemId=0},[30]={name="Thades Moon 1",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=30,GM=211564034,gravity=0.11202853997062348,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29214402,y=10907080.695,z=433858.2},radius=14000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2463008768,surfaceAverageAltitude=60,surfaceMaxAltitude=300,surfaceMinAltitude=0,systemZone=nil,territories=3002,type="",waterLevel=nil,planetarySystemId=0},[31]={name="Thades Moon 2",description="",antiGravMinAltitude=1000,atmosphericDensityAboveSurface=0,atmosphericEngineMaxAltitude=0,biosphere="",classification="",bodyId=31,GM=264870000,gravity=0.12003058201190042,fullAtmosphericDensityMaxAltitude=0,habitability="",hasAtmosphere=false,isSanctuary=false,noAtmosphericDensityAltitude=0,numSatellites=0,positionFromSun=0,center={x=29404193,y=10432768,z=19554.131},radius=15000,safeAreaEdgeAltitude=500000,size="M",spaceEngineMinAltitude=0,surfaceArea=2827433472,surfaceAverageAltitude=70,surfaceMaxAltitude=350,surfaceMinAltitude=0,systemZone=nil,territories=3632,type="",waterLevel=nil,planetarySystemId=0}}}end;local function cV()local function cW(cX)return type(cX)=='number'end;local function cY(cX)return type(x(cX))=='number'end;local function cZ(c_)return type(c_)=='table'end;local function d0(d1)return type(d1)=='string'end;local function d2(bY)return cZ(bY)and cW(bY.x and bY.y and bY.z)end;local function d3(bZ)return cZ(bZ)and cW(bZ.latitude and bZ.longitude and bZ.altitude and bZ.bodyId and bZ.systemId)end;local d4=math.pi/180;local d5=180/math.pi;local epsilon=1e-10;local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d6='::pos{'..z..','..z..','..z..','..z..','..z..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d7(cX)local d8=string.gsub(string.reverse(e('%.4f',cX)),'^0*%.?','')return d8==''and'0'or string.reverse(d8)end;local function d9(da)if d2(da)then return e('{x=%.3f,y=%.3f,z=%.3f}',da.x,da.y,da.z)end;if cZ(da)and not getmetatable(da)then local db={}local dc=next(da)if type(dc)=='nil'or dc==1 then db=da else for cT,bY in pairs(da)do local ct=d9(bY)if type(cT)=='number'then table.insert(db,e('[%s]=%s',cT,ct))else table.insert(db,e('%s=%s',cT,ct))end end end;return e('{%s}',table.concat(db,','))end;if d0(da)then return e("'%s'",da:gsub("'",[[\']]))end;return tostring(da)end;local dd={}dd.__index=dd;dd.__tostring=function(da,de)local df={}for cT in pairs(da)do table.insert(df,cT)end;table.sort(df)local db={}for _,cT in ipairs(df)do local ct=d9(da[cT])if type(cT)=='number'then table.insert(db,e('[%s]=%s',cT,ct))else table.insert(db,e('%s=%s',cT,ct))end end;if de then return e('%s%s',de,table.concat(db,',\n'..de))end;return e('{%s}',table.concat(db,','))end;dd.__eq=function(dg,dh)return dg.planetarySystemId==dh.planetarySystemId and dg.bodyId==dh.bodyId and cw(dg.radius,dh.radius)and cw(dg.center.x,dh.center.x)and cw(dg.center.y,dh.center.y)and cw(dg.center.z,dh.center.z)and cw(dg.GM,dh.GM)end;local function di(dj,dk,dl,dm,dn)assert(cY(dj),'Argument 1 (planetarySystemId) must be a number:'..type(dj))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(dl),'Argument 3 (radius) must be a number:'..type(dl))assert(cZ(dm),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dm))assert(cY(dn),'Argument 5 (GM) must be a number:'..type(dn))return setmetatable({planetarySystemId=x(dj),bodyId=x(dk),radius=x(dl),center=vec3(dm),GM=x(dn)},dd)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(dp)return e('::pos{%d,%d,%s,%s,%s}',dp.systemId,dp.bodyId,d7(dp.latitude*d5),d7(dp.longitude*d5),d7(dp.altitude))end;MapPosition.__eq=function(dg,dh)return dg.bodyId==dh.bodyId and dg.systemId==dh.systemId and cw(dg.latitude,dh.latitude)and cw(dg.altitude,dh.altitude)and(cw(dg.longitude,dh.longitude)or cw(dg.latitude,math.pi/2)or cw(dg.latitude,-math.pi/2))end;local function dq(dr,dk,ds,dt,du)local dj=dr;if d0(dr)and not dt and not du and not dk and not ds then dj,dk,ds,dt,du=n(dr,d6)assert(dj,'Argument 1 (position string) is malformed.')else assert(cY(dj),'Argument 1 (systemId) must be a number:'..type(dj))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(ds),'Argument 3 (latitude) must be in degrees:'..type(ds))assert(cY(dt),'Argument 4 (longitude) must be in degrees:'..type(dt))assert(cY(du),'Argument 5 (altitude) must be in meters:'..type(du))end;dj=x(dj)dk=x(dk)ds=x(ds)dt=x(dt)du=x(du)if dk==0 then return setmetatable({latitude=ds,longitude=dt,altitude=du,bodyId=dk,systemId=dj},MapPosition)end;return setmetatable({latitude=d4*p(ds,-90,90),longitude=d4*(dt%360),altitude=du,bodyId=dk,systemId=dj},MapPosition)end;local dv={}dv.__index=dv;dv.__tostring=function(da,de)local dw=de and de..'  'local dx={}local df={}for cT in pairs(da)do table.insert(df,cT)end;table.sort(df)for _,dy in ipairs(df)do bdy=da[dy]local dz=dd.__tostring(bdy,dw)if de then table.insert(dx,e('[%s]={\n%s\n%s}',dy,dz,de))else table.insert(dx,e('  [%s]=%s',dy,dz))end end;if de then return e('\n%s%s%s',de,table.concat(dx,',\n'..de),de)end;return e('{\n%s\n}',table.concat(dx,',\n'))end;local function dA(dB)local aU={}local pid;for _,bY in pairs(dB)do local dC=bY.planetarySystemId;if type(dC)~='number'then error('Invalid planetary system ID: '..tostring(dC))elseif pid and dC~=pid then error('Mistringmatch planetary system IDs: '..dC..' and '..pid)end;local dD=bY.bodyId;if type(dD)~='number'then error('Invalid body ID: '..tostring(dD))elseif aU[dD]then error('Duplicate body ID: '..tostring(dD))end;setmetatable(bY.center,getmetatable(vec3.unit_x))aU[dD]=setmetatable(bY,dd)pid=dC end;return setmetatable(aU,dv)end;aY={}local function dE(dB)return setmetatable({galaxyAtlas=dB or{}},aY)end;aY.__index=function(c_,i)if type(i)=='number'then local system=c_.galaxyAtlas[i]return dA(system)end;return rawget(aY,i)end;aY.__pairs=function(da)return function(c_,cT)local dF,nv=next(c_,cT)return dF,nv and dA(nv)end,da.galaxyAtlas,nil end;aY.__tostring=function(da)local dG={}for _,dH in pairs(da or{})do local dI=dH:getPlanetarySystemId()local dJ=dv.__tostring(dH,'    ')table.insert(dG,e('  [%s]={%s\n  }',dI,dJ))end;return e('{\n%s\n}\n',table.concat(dG,',\n'))end;aY.BodyParameters=di;aY.MapPosition=dq;aY.PlanetarySystem=dA;function aY.createBodyParameters(dK,dk,dL,dM,dN,dO,dP)assert(cY(dK),'Argument 1 (planetarySystemId) must be a number:'..type(dK))assert(cY(dk),'Argument 2 (bodyId) must be a number:'..type(dk))assert(cY(dL),'Argument 3 (surfaceArea) must be a number:'..type(dL))assert(cZ(dM),'Argument 4 (aPosition) must be an array or vec3:'..type(dM))assert(cZ(dN),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dN))assert(cY(dO),'Argument 6 (altitude) must be in meters:'..type(dO))assert(cY(dP),'Argument 7 (gravityAtPosition) must be number:'..type(dP))local dl=w(dL/4/math.pi)local ah=dl+dO;local dQ=vec3(dM)+ah*vec3(dN)local dn=dP*ah*ah;return di(dK,dk,dl,dQ,dn)end;aY.isMapPosition=d3;function aY:getPlanetarySystem(dr)if i==nil then i=0 end;if nv==nil then nv=0 end;local dK=dr;if d3(dr)then dK=dr.systemId end;if type(dK)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=dv then system=dA(system)end;return system end end end;function dv:sizeCalculator(c7)return 1.05*c7.radius end;function dv:castIntersections(dR,dS,dT,dU,dV,dW)local dX={}local dY=dV or self;for _,c7 in pairs(dY)do table.insert(dX,c7)end;if not dW then table.sort(dX,function(dZ,d_)return(dZ.center-dR):len()<(d_.center-dR):len()end)end;local e0=dS:normalize()for _,c7 in ipairs(dX)do local e1=c7.center-dR;local dl=self:sizeCalculator(c7)local e2=e1:dot(e0)local e3=e2^2-(e1:len2()-dl^2)if e3>=0 then local e4=w(e3)local c5=e2+e4;local c6=e2-e4;if c6>0 then return c7,c5,c6 elseif c5>0 then return c7,c5,nil end end end;return nil,nil,nil end;function dv:closestBody(e5)assert(type(e5)=='table','Invalid coordinates.')local e6,c7;local e7=vec3(e5)for _,e8 in pairs(self)do local e9=(e8.center-e7):len2()if(not c7 or e9<e6)and e8.name~="Space"then c7=e8;e6=e9 end end;return c7 end;function dv:convertToBodyIdAndWorldCoordinates(dr)local ea=dr;if d0(dr)then ea=dq(dr)end;if ea.bodyId==0 then return 0,vec3(ea.latitude,ea.longitude,ea.altitude)end;local e8=self:getBodyParameters(ea)if e8 then return ea.bodyId,e8:convertToWorldCoordinates(ea)end end;function dv:getBodyParameters(dr)local dk=dr;if d3(dr)then dk=dr.bodyId end;assert(cY(dk),'Argument 1 (bodyId) must be a number:'..type(dk))return self[dk]end;function dv:getPlanetarySystemId()local _,bY=next(self)return bY and bY.planetarySystemId end;function dd:convertToMapPosition(dm)assert(cZ(dm),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dm))local eb=vec3(dm)if self.bodyId==0 then return setmetatable({latitude=eb.x,longitude=eb.y,altitude=eb.z,bodyId=0,systemId=self.planetarySystemId},MapPosition)end;local ec=eb-self.center;local ah=ec:len()local du=ah-self.radius;local ds=0;local dt=0;if not cw(ah,0)then local ed=m(ec.y,ec.x)dt=ed>=0 and ed or 2*math.pi+ed;ds=math.pi/2-math.acos(ec.z/ah)end;return setmetatable({latitude=ds,longitude=dt,altitude=du,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)end;function dd:convertToWorldCoordinates(dr)local ea=d0(dr)and dq(dr)or dr;if ea.bodyId==0 then return vec3(ea.latitude,ea.longitude,ea.altitude)end;assert(d3(ea),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(ea.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(ea.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')local ee=math.cos(ea.latitude)return self.center+(self.radius+ea.altitude)*vec3(ee*math.cos(ea.longitude),ee*math.sin(ea.longitude),math.sin(ea.latitude))end;function dd:getAltitude(dm)return(vec3(dm)-self.center):len()-self.radius end;function dd:getDistance(dm)return(vec3(dm)-self.center):len()end;function dd:getGravity(dm)local ef=self.center-vec3(dm)local eg=ef:len2()return self.GM/eg*ef/w(eg)end;return setmetatable(aY,{__call=function(_,...)return dE(...)end})end;local function eh()local a_={}local ei=30000000/3600;local ej=ei*ei;local ek=100;local function el(bY)return 1/w(1-bY*bY/ej)end;function a_.computeAccelerationTime(em,en,eo)local ep=ei*math.asin(em/ei)return(ei*math.asin(eo/ei)-ep)/en end;function a_.computeDistanceAndTime(em,eo,eq,er,es,et)es=es or 0;et=et or 0;local eu=em<=eo;local ev=er*(eu and 1 or-1)/eq;local ew=-et/eq;local ex=ev+ew;if eu and ex<=0 or not eu and ex>=0 then return-1,-1 end;local ey,ez=0,0;if ev~=0 and es>0 then local ep=math.asin(em/ei)local eA=math.pi*(ev/2+ew)local eB=ev*es;local eC=ei*math.pi;local bY=function(c_)local eD=(eA*c_-eB*math.sin(math.pi*c_/2/es)+eC*ep)/eC;local eE=math.tan(eD)return ei*eE/w(eE*eE+1)end;local eF=eu and function(d1)return d1>=eo end or function(d1)return d1<=eo end;ez=2*es;if eF(bY(ez))then local eG=0;while c(ez-eG)>0.5 do local c_=(ez+eG)/2;if eF(bY(c_))then ez=c_ else eG=c_ end end end;local eH=em;local eI=ez/ek;for eJ=1,ek do local eK=bY(eJ*eI)ey=ey+(eK+eH)*eI/2;eH=eK end;if ez<2*es then return ey,ez end;em=eH end;local ep=ei*math.asin(em/ei)local B=(ei*math.asin(eo/ei)-ep)/ex;local eL=ej*math.cos(ep/ei)/ex;local ah=eL-ej*math.cos((ex*B+ep)/ei)/ex;return ah+ey,B+ez end;function a_.computeTravelTime(em,en,ah)if ah==0 then return 0 end;if en>0 then local ep=ei*math.asin(em/ei)local eL=ej*math.cos(ep/ei)/en;return(ei*math.acos(en*(eL-ah)/ej)-ep)/en end;if em==0 then return-1 end;assert(em>0,'Acceleration and initial speed are both zero.')return ah/em end;function a_.lorentz(bY)return el(bY)end;return a_ end;local function eM()local vec3=require('cpml.vec3')local cV=cV()local function d0(d1)return type(d1)=='string'end;local function cZ(c_)return type(c_)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(du)assert(self.body)local ah=du+self.body.radius;if not cw(ah,0)then local orbit=w(self.body.GM/ah)return w(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dr,eN)assert(self.body)assert(cZ(dr)or d0(dr))assert(cZ(eN))local eO=(d0(dr)or cV.isMapPosition(dr))and self.body:convertToWorldCoordinates(dr)or vec3(dr)local bY=by;local eP=eO-self.body.center;local eQ=bY:len2()local eR=eP:len()local eS=self.body.GM;local eT=((eQ-eS/eR)*eP-eP:dot(bY)*bY)/eS;local cx=eS/(2*eS/eR-eQ)local eU=eT:len()local e0=eT:normalize()local eV=cx*(1-eU)local eW=cx*(1+eU)local eX=eV*e0+self.body.center;local eY=eU<=1 and-eW*e0+self.body.center or nil;local eZ=w(cx*eS*(1-eU*eU))local e_=eY and 2*math.pi*w(cx^3/eS)local f0=math.acos(eT:dot(eP)/(eU*eR))if eP:dot(bY)<0 then f0=-(f0-2*math.pi)end;local f1=math.acos((math.cos(f0)+eU)/(1+eU*math.cos(f0)))local f2=f1;if f2<0 then f2=f2+2*math.pi end;local f3=f2-eU*math.sin(f2)local f4=0;local f5=0;local f6=0;if e_~=nil then f4=f3/(2*math.pi/e_)f5=e_-f4;f6=f5+e_/2;if f0-math.pi>0 then f5=f4;f6=f5+e_/2 end;if f6>e_ then f6=f6-e_ end end;return{periapsis={position=eX,speed=eZ/eV,circularOrbitSpeed=w(eS/eV),altitude=eV-self.body.radius},apoapsis=eY and{position=eY,speed=eZ/eW,circularOrbitSpeed=w(eS/eW),altitude=eW-self.body.radius},currentVelocity=bY,currentPosition=eO,eccentricity=eU,period=e_,eccentricAnomaly=f1,meanAnomaly=f3,timeToPeriapsis=f5,timeToApoapsis=f6}end;local function f7(f8)local e8=cV.BodyParameters(f8.planetarySystemId,f8.bodyId,f8.radius,f8.center,f8.GM)return setmetatable({body=e8},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f7(...)end})end;local function f9()local fa={}local fb={}local fc={XS=13,S=27,M=55,L=110,XL=221}local fd={}local fe;local ff;local fg;local fh;local fi;local function fj()local function fk(fl,fm,fn,fo,fp,fq,fr,fs)fm,fo,fq,fs=vec3(fm),vec3(fo),vec3(fq),vec3(fs)local ft,fu,fv=fl*fl,fn*fn,fp*fp;local eQ=fo-fm;local fw=eQ:normalize()local fx=eQ:len()local fy=fq-fm;local fz=(fy-fy:project_on(fw)):normalize()local fA,fB=fy:dot(fw),fy:dot(fz)local fC=fA*fA+fB*fB;local fD=fw:cross(fz)local cn=(ft-fu+fx*fx)/(2*fx)local co=(ft-fv+fC-2*fA*cn)/(2*fB)local bZ=ft-cn^2-co^2;local fE=w(bZ)local fF=fm+fw*cn+fz*co+fD*fE;local fG=fm+fw*cn+fz*co-fD*fE;if c((fs-fF):len()-fr)<c((fs-fG):len()-fr)then return fF else return fG end end;local function fH()local function fI()local fJ=core.getConstructWorldOrientationRight()local eQ=core.getConstructWorldOrientationForward()local fy=core.getConstructWorldOrientationUp()local fK=library.systemResolution3(fJ,eQ,fy,{1,0,0})local fL=library.systemResolution3(fJ,eQ,fy,{0,1,0})local fM=library.systemResolution3(fJ,eQ,fy,{0,0,1})return function(fN)return library.systemResolution3(fK,fL,fM,fN)end end;local fO=fI()local fP=core.getConstructWorldPos()local eO=core.getElementPositionById(1)local fQ={eO[1]-D,eO[2]-D,eO[3]-D}local fR=fO(fQ)local fS={fP[1]-fR[1],fP[2]-fR[2],fP[3]-fR[3]}return fS end;local function fT(fU,eR,fV)local fW=fU.pts;local fX=#fW;local fY=fU.ref;if fX>3 then local fZ,f_,g0,g1=fW[fX],fW[fX-1],fW[fX-2],fW[fX-3]fU.ref=fV;local eO=fk(fZ[1],fZ[2],f_[1],f_[2],g0[1],g0[2],g1[1],g1[2])local cn,co,fE=eO.x,eO.y,eO.z;if cn==cn and co==co and fE==fE then cn=cn+fY[1]co=co+fY[2]fE=fE+fY[3]local g2=vec3(cn,co,fE)if not fU.lastPos then fU.center=g2 elseif(fU.lastPos-g2):len()<2 then fU.center=g2;fU.skipCalc=true end;fU.lastPos=g2 end;fU.pts={}else local g3={fV[1]-fY[1],fV[2]-fY[2],fV[3]-fY[3]}fW[fX+1]={eR,g3}end end;if radar_1 then fe=#radar_1.getEntries()local g4=radar_1.getData()local g5=g4:gmatch('{"constructId[^}]*}[^}]*}')if fe>0 then local fV=fH()local g6,g7=0,0;fi=0;for bY in g5 do local dC,ah,g8=bY:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g9=fc[g8]ah=x(ah)if radar_1.hasMatchingTransponder(dC)==1 then table.insert(fb,dC)end;local ga=radar_1.getConstructType(dC)if CollisionSystem then if g9>27 or ga=="static"or ga=="space"then fi=fi+1;local bW=radar_1.getConstructName(dC)local fU=bS[dC]if fU==nil then g9=g9+E;bS[dC]={pts={},ref=fV,name=bW,i=0,radius=g9,skipCalc=false}fU=bS[dC]end;if not fU.skipCalc then fT(fU,ah,fV)g7=g7+1 end;if fU.center then table.insert(fd,fU)end end;g6=g6+1;if bT and g6>700 or g7>70 or(not bT and g6>300 or g7>30)then coroutine.yield()g6,g7=0,0 end end end;fh=#fd;if fh>0 and bz>20 then local c7,gb,gc,gd;local ge=0;local gf=aZ:getPlanetarySystem(0)gd=by:normalize()while ge<fh do coroutine.yield()local gg={table.unpack(fd,ge,math.min(ge+75,fh))}c7,gb,gc=gf:castIntersections(bC,gd,nil,nil,gg,true)if c7 and gc then bV={c7,gb,gc}break end;ge=ge+75 end;if not c7 then bV=nil end else bV=nil end;fd={}ff=g4:find('identifiedConstructs":%[%]')else fg=g4:find('worksInEnvironment":false')end end end;function fa.UpdateRadar()local gh=coroutine.status(UpdateRadarCoroutine)if gh=="suspended"then local ct,gi=coroutine.resume(UpdateRadarCoroutine)if gi then system.print("ERROR UPDATE RADAR: "..gi)end elseif gh=="dead"then UpdateRadarCoroutine=coroutine.create(fj)local ct,gi=coroutine.resume(UpdateRadarCoroutine)end end;function fa.GetRadarHud()return ff,fg,fe,fh,fi,fb end;UpdateRadarCoroutine=coroutine.create(fj)return fa end;local function gj()local gk=0;local gl=vec3({13771471,7435803,-128971})local gm=18000000;local gn=500000;local go,gp=math.huge;local gq;local function gr(gs)go=vec3(gs):dist(gl)if go<gm then return true,c(go-gm)end;gp=vec3(gs):dist(vec3(planet.center))if gp<gn then gq=true else gq=false end;if c(gp-gn)<c(go-gm)then return gq,c(gp-gn)else return gq,c(go-gm)end end;local function gt(bY)if aE==1920 then return bY else return y(aE*bY/1920,0)end end;local function gu(bY)if aF==1080 then return bY else return y(aF*bY/1080,0)end end;local function gv()return v()==0 and userControlScheme~="keyboard"and l()==0 end;local function gw()local gx="TRAVEL"if not bH then gx="CRUISE"end;if Autopilot then gx="AUTOPILOT"end;return gx end;local gy=1;local gz=2;local gA=3;local gB=4;local gC=5;local gD=6;local gE=""local gF=0;local function gG(gH,aS,cn,gI,gJ,gK,gL,gM)local gN=fuelY;local gO=fuelY+5;if not BarFuelDisplay then gO=gO+5 end;if l()==1 and not RemoteHud then gN=gN-50;gO=gO-50 end;if gJ=="ATMO"then gE="atmofueltank"elseif gJ=="SPACE"then gE="spacefueltank"else gE="rocketfueltank"end;gF=_G[gE.."_size"]if#gK>0 then for i=1,#gK do local bW=string.sub(gK[i][gz],1,12)local gP=0;for gQ=1,gF do if gK[i][gz]==f(unit[gE.."_"..gQ].getData()).name then gP=gQ;break end end;if aS or gL[i]==nil or gM[i]==nil then local gR;local gS=0;local gT=o()if gP~=0 then gM[i]=f(unit[gE.."_"..gP].getData()).percentage;gL[i]=f(unit[gE.."_"..gP].getData()).timeLeft;if gL[i]=="n/a"then gL[i]=0 end else gS=k(gK[i][gy])-gK[i][gB]gM[i]=d(0.5+gS*100/gK[i][gA])gR=gK[i][gC]if gR<=gS then gL[i]=0 else gL[i]=d(0.5+gS/((gR-gS)/(gT-gK[i][gD])))end;gK[i][gC]=gS;gK[i][gD]=gT end end;if bW==gI then bW=e("%s %d",gJ,i)end;if gP==0 then bW=bW.." *"end;local gU;if gL[i]==0 then gU=""else gU=cK(gL[i])end;if gM[i]~=nil then local gV=d(gM[i]*2.55)local gW=e("rgb(%d,%d,%d)",255-gV,gV,0)local cq=""if gU~=""and gL[i]<120 or gM[i]<5 then if aS then cq=[[class="red"]]end end;if BarFuelDisplay then table.insert(gH,e([[
                                            <g class="pdim">                        
                                            <rect fill=grey class="bar" x="%d" y="%d" width="100" height="13"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                            <text fill=black x="%d" y="%d">%s%% %s</text>
                                            </g>]],cn,gO,gW,gM[i],cn,gO,cn+2,gO+10,gM[i],gU))gH[#gH+1]=cm(cn,gN,bW,cq.."txtstart pdim txtfuel")gN=gN-30;gO=gO-30 else gH[#gH+1]=cm(cn,gN,bW,cq.." pdim txtfuel")gH[#gH+1]=cm(cn,gO,e("%d%% %s",gM[i],gU),"pdim txtfuel","fill:"..gW)gN=gN+30;gO=gO+30 end end end end end;local function gX(gH,du)if du<200000 and not ao or du and ao then local gY=0;if c(bB)>1 then gY=45*math.log(c(bB),10)if bB<0 then gY=-gY end end;gH[#gH+1]=e([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,d(bB),d(gY))end;return gH end;local function gZ(g_)local h0=-bA;g_=g_-g_:project_on(h0)local h1=vec3(0,0,1)h1=h1-h1:project_on(h0)local h2=h1:cross(h0)local gY=h1:angle_between(g_)*constants.rad2deg;if g_:dot(h2)<0 then gY=360-gY end;return gY end;local function h3(gH,centerX,centerY,h4,h5,bT)local h6=circleRad;local h7=20;local h8=d(h4)if bT then for i=-45,45,5 do local h9=i;gH[#gH+1]=e([[<g transform="rotate(%f,%d,%d)">]],h9,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;gH[#gH+1]=e([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+h6+h7-len,centerX,centerY+h6+h7)end;gH[#gH+1]=cm(centerX,centerY+h6+h7-35,h5,"pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY+h6+h7-25,h8 .." deg","pdim txt txtmid")gH[#gH+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h4,centerX,centerY)gH[#gH+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+h6+h7-20,centerX+5,centerY+h6+h7-20,centerX,centerY+h6+h7-15)gH[#gH+1]="</g>"end;local ha=h8;if bT then ha=gZ(bw)end;local hb=20;local hc=d(ha)local hd=0;local he=centerY+h6+h7+20;local hf=centerX;if h5~="YAW"then he=gu(130)hf=gt(960)end;local hg=[[<path class="txttick line" d="]]local hh=d(hc-(hb+10)-hc%5+0.5)for i=hh+60,hh,-5 do local cn=hf-(-i*5+ha*5)if i%10==0 then hd=10;local z=i;if z==360 then z=0 elseif z>360 then z=z-360 elseif z<0 then z=z+360 end;gH[#gH+1]=cm(cn+5,he-12,z)elseif i%5==0 then hd=5 end;if hd==10 then hg=e([[%s M %f %f v %d]],hg,cn,he-5,hd)else hg=e([[%s M %f %f v %d]],hg,cn,he-2.5,hd)end end;gH[#gH+1]=hg..[["/>]]gH[#gH+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/>]],hf-5,he+10,hf+5,he+10,hf,he+5)if bT then h5="HDG"end;gH[#gH+1]=cm(hf,he+25,hc.."deg","pdim txt txtmid","")gH[#gH+1]=cm(hf,he+35,h5,"pdim txt txtmid","")end;local function hi(gH,hj,h4,centerX,centerY,bT,hk,eK)local h6=circleRad;local hl=d(h6*3/5)if h6>0 then local hm=d(hj)local len=0;local hg=e([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*h4,centerX,centerY)if not ao then hg=e([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;gH[#gH+1]=e([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],h6-1,centerX,centerY)gH[#gH+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=d(hm-30-hm%5+0.5),d(hm+30+hm%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local co=centerY+-i*5+hj*5;if len==30 then hg=e([[%s M %d %f h %d]],hg,centerX-hl-len,co,len)if ao then gH[#gH+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h4,centerX,centerY,centerX-hl+10,co,i)gH[#gH+1]=e([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*h4,centerX,centerY,centerX+hl-10,co,i)if i==0 or i==180 or i==-180 then gH[#gH+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h4,centerX,centerY,centerX-hl+20,co,hl*2-40)end else gH[#gH+1]=cm(centerX-hl+10,co,i,"pdim txt txtmid")gH[#gH+1]=cm(centerX+hl-10,co,i,"pdim txt txtmid")end;hg=e([[%s M %d %f h %d]],hg,centerX+hl,co,len)else hg=e([[%s M %d %f h %d]],hg,centerX-hl-len,co,len)hg=e([[%s M %d %f h %d]],hg,centerX+hl,co,len)end end;gH[#gH+1]=hg..[["/>]]local hn="PITCH"if not bT then hn="REL PITCH"end;if hj>90 and not ao then hj=90-(hj-90)elseif hj<-90 and not ao then hj=-90-(hj+90)end;if h6>200 then if ao then if eK>O then gH[#gH+1]=cm(centerX,centerY-15,"Yaw","pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY+20,hk,"pdim txt txtmid")end;gH[#gH+1]=e([[<g transform="rotate(%f,%d,%d)">]],-h4,centerX,centerY)else gH[#gH+1]=e([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;gH[#gH+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hl+25,centerY-5,centerX-hl+20,centerY,centerX-hl+25,centerY+5,centerX-hl+50,centerY+4,hm)gH[#gH+1]=e([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hl-25,centerY-5,centerX+hl-20,centerY,centerX+hl-25,centerY+5,centerX+hl-30,centerY+4,hm)gH[#gH+1]="</g>"end;local ho=d(h6/3)gH[#gH+1]=e([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-ho,centerY,h6-ho)if not ao and bT then gH[#gH+1]=e([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*h4,centerX,centerY,centerX-hl+10,centerY,hl*2-20)end;gH[#gH+1]="</g>"if h6<200 then if ao and eK>O then gH[#gH+1]=cm(centerX,centerY-h6,hn,"pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY-h6+10,hm,"pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY-15,"Yaw","pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY+20,hk,"pdim txt txtmid")else gH[#gH+1]=cm(centerX,centerY-h6,hn,"pdim txt txtmid")gH[#gH+1]=cm(centerX,centerY-h6+15,hm,"pdim txt txtmid")end end end end;local function hp(gH,du,bT)local hq=altMeterX;local hr=altMeterY;local hs=78;local ht=19;local hu=am;if am~=-1 then gH[#gH+1]=cm(hq+hs,hr+ht+20,e("AGL: %.1fm",am),"pdim altsm txtend")end;if bT and(du<200000 and not ao or du and ao)then table.insert(gH,e([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hq-1,hr-4,hs+2,ht+6,hq+1,hr-1,hs-4,ht))local fX=0;local hv=1;local hw=0;local hx=du<0;local hy=du<planet.surfaceMaxAltitude;local hz=9;if hx then hz=0 end;local du=c(du)while fX<6 do local hA=11;local hB=16;local hC=9;local hD=14;local cq="altsm"if fX>2 then hB=hB+3;hA=hA+2;hD=hD+2;hC=hC-6;cq="altbig"end;if hx then cq=cq.." red"elseif hy then cq=cq.." orange"end;local hE=du/hv%10;local hF=d(hE)local hG=d((hF+1)%10)local hH=hw;if fX==0 then hH=hE-hF;if hx then hH=1-hH end end;if hx and(fX==0 or hw~=0)then local hI=hG;hG=hF;hF=hI end;local hJ=hB*(hH-1)local hK=hJ+hB;local cn=hq+hC+(6-fX)*hA;local co=hr+hD;gH[#gH+1]=cm(cn,co+hJ,hG,cq)gH[#gH+1]=cm(cn,co+hK,hF,cq)fX=fX+1;hv=hv*10;if hF==hz then hw=hH else hw=0 end end;table.insert(gH,[[</g></g>]])end end;local function hL(eN)local hM=-math.deg(m(eN.y,eN.z))+180;hM=hM-90;if hM<0 then hM=360+hM end;if hM>180 then hM=-180+hM-180 end;return-hM end;local function hN(eN)local ha=math.deg(m(eN.y,eN.x))-90;if ha<-180 then ha=360+ha end;return ha end;local function hO(gH,eN,eK,centerX,centerY)if eK>5 and not ao or eK>O then local h6=circleRad;local hP=20;local hQ=20;local hR=hL(eN)local hS=hN(eN)local hT=14;local hU=hT/2;local hV=-hS/hQ*h6;local hW=hR/hP*h6;local cn=centerX+hV;local co=centerY+hW;local ah=w(hV^2+hW^2)local hX=[[<circle
                            cx="]]..cn..[["
                            cy="]]..co..[["
                            r="]]..hU/hT..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..cn..[["
                            cy="]]..co..[["
                            r="]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..cn-hT..[[,]]..co..[[ h ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cn+hU..[[,]]..co..[[ h ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..cn..[[,]]..co-hT..[[ v ]]..hU..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if ah<h6 then gH[#gH+1]=hX else local gY=m(hW,hV)local hY=4;local hZ=centerX+h6*math.cos(gY)local h_=centerY+h6*math.sin(gY)gH[#gH+1]=e('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',gY*180/math.pi,hZ,h_,hZ-hY,h_-hY/2,hY*2,hY,hZ+hY,h_-hY,hY,hY,-hY,hY)end;if not ao then hR=hL(-by)hS=hN(-by)hV=-hS/hQ*h6;hW=hR/hP*h6;cn=centerX+hV;co=centerY+hW;ah=w(hV^2+hW^2)if ah<h6 then local i0=[[<circle
                                    cx="]]..cn..[["
                                    cy="]]..co..[["
                                    r="]]..hU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..cn..[[,]]..co-hT..[[ v ]]..hU..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..cn..[[,]]..co..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..cn..[[,]]..co..[[)" />
                                <path
                                    d="M ]]..cn-hU..[[,]]..co..[[ h ]]..hT..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..cn..[[,]]..co..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..cn..[[,]]..co..[[)"/>]]gH[#gH+1]=i0 end end end end;local function i1(gH,gx,i2,i3)i2=d(i2+0.5)local gN=throtPosY+10;local gO=throtPosY+20;if l()==1 and not RemoteHud then gN=55;gO=65 end;local i4="CRUISE"local unit="km/h"local ct=i3;if gx=="TRAVEL"or gx=="AUTOPILOT"then i4="THROT"unit="%"ct=i2;local i5="dim"if i2<0 then i5="red"end;gH[#gH+1]=e([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],i5,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-c(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;gH[#gH+1]=cm(throtPosX+10,gN,i4,"pbright txtstart")gH[#gH+1]=cm(throtPosX+10,gO,e("%.0f %s",ct,unit),"pbright txtstart")if ao and AtmoSpeedAssist and bH and K then i2=d(L*100+0.5)local i5="red"if i2<0 then i5="red"end;gH[#gH+1]=e([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],i5,1-c(i2),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)gH[#gH+1]=cm(throtPosX+10,gN+40,"LIMIT","pbright txtstart")gH[#gH+1]=cm(throtPosX+10,gO+40,i2 .."%","pbright txtstart")end;if ao and AtmoSpeedAssist or Reentry then gH[#gH+1]=cm(throtPosX+10,gN-40,"LIMIT: "..bf.." km/h","dim txtstart")elseif not ao and Autopilot then gH[#gH+1]=cm(throtPosX+10,gN-40,"LIMIT: "..d(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function i6(gH,i7)local i8=throtPosY-10;local i9=throtPosX+10;gH[#gH+1]=cm(0,0,"","pdim txt txtend")if l()==1 and not RemoteHud then i8=75 end;gH[#gH+1]=cm(i9,i8,d(i7).." km/h","pbright txtbig txtstart")end;local function ia(gH)gH[#gH+1]=cm(gt(1900),gu(1070),e("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")gH[#gH+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then gH[#gH+1]=cm(gt(960),gu(550),"Warning: Invalid Control Scheme Detected","warnings")gH[#gH+1]=cm(gt(960),gu(600),"Keyboard Scheme must be selected","warnings")gH[#gH+1]=cm(gt(960),gu(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ib=gt(960)local ic=gu(860)local id=gu(880)local ie=gu(900)local ig=gu(960)local ih=gu(200)local ii=gu(250)local ij=gu(960)if l()==1 and not RemoteHud then ic=gu(135)id=gu(155)ie=gu(175)ih=gu(115)ii=gu(95)end;if BrakeIsOn then gH[#gH+1]=cm(ib,ic,"Brake Engaged","warnings")elseif J>0 then gH[#gH+1]=cm(ib,ic,"Auto-Brake Engaged","warnings","opacity:"..J)end;if ao and ba and am==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not bF and not VertTakeOff and not AutoTakeoff then gH[#gH+1]=cm(ib,ih+50,"** STALL WARNING **","warnings")c9("stall","SW",2)end end;if bR then gH[#gH+1]=cm(ib,ih+90,"Flight Assist in Progress","warnings")end;if av then gH[#gH+1]=cm(ib,ij,"Gyro Enabled","warnings")end;if GearExtended then if Q then gH[#gH+1]=cm(ib,id,"Gear Extended","warn")else gH[#gH+1]=cm(ib,id,"Landed (G: Takeoff)","warnings")end;local ik=cz(a:getTargetGroundAltitude())gH[#gH+1]=cm(ib,ie,"Hover Height: "..ik,"warn")end;if a5 then gH[#gH+1]=cm(ib,ig+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and bF and AntigravTargetAltitude~=nil then if c(aq-antigrav.getBaseAltitude())<501 then gH[#gH+1]=cm(ib,ih+15,e("AGG On - Target Altitude: %d Singularity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warn")else gH[#gH+1]=cm(ib,ih+15,e("AGG On - Target Altitude: %d Singluarity Altitude: %d",d(AntigravTargetAltitude),d(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then gH[#gH+1]=cm(ib,ih+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then gH[#gH+1]=cm(ib,ih+20,e("LockedPitch: %d",d(LockPitch)),"warn")elseif Y then gH[#gH+1]=cm(ib,ih+20,"Follow Mode Engaged","warn")elseif Reentry then gH[#gH+1]=cm(ib,ih+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local ik=cz(HoldAltitude,2)if VertTakeOff then if bF then ik=cz(antigrav.getBaseAltitude(),2).." AGG singularity height"end;gH[#gH+1]=cm(ib,ih,"VTO to "..ik,"warn")elseif AutoTakeoff and not IntoOrbit then if ak then gH[#gH+1]=cm(ib,ih,"Takeoff to "..AutopilotTargetName,"warn")else gH[#gH+1]=cm(ib,ih,"Takeoff to "..ik,"warn")end;if BrakeIsOn and not VertTakeOff then gH[#gH+1]=cm(ib,ih+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else gH[#gH+1]=cm(ib,ih,"Altitude Hold: "..ik,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ap>0.1 then gH[#gH+1]=cm(ib,ih+20,"Beginning ascent","warn")elseif ap<0.09 and ap>0.05 then gH[#gH+1]=cm(ib,ih+20,"Aligning trajectory","warn")elseif ap<0.05 then gH[#gH+1]=cm(ib,ih+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if bh~=nil then gH[#gH+1]=cm(ib,ih,bh,"warn")end end;if IntruderAlertSystem and safeMass==-1 then gH[#gH+1]=cm(ib,ih+70,"POSSIBLE INTRUDER ALERT - MASS GAIN OF "..bD.."kg DETECTED","warnings")c9("alarm","AL",2)end;if BrakeLanding then if StrongBrakes then gH[#gH+1]=cm(ib,ih,"Brake-Landing","warnings")else gH[#gH+1]=cm(ib,ih,"Coast-Landing","warnings")end end;if ProgradeIsOn then gH[#gH+1]=cm(ib,ih,"Prograde Alignment","crit")end;if RetrogradeIsOn then gH[#gH+1]=cm(ib,ih,"Retrograde Alignment","crit")end;if bU then local type;if string.find(bU,"COLLISION")then type="warnings"else type="crit"end;gH[#gH+1]=cm(ib,ii+20,bU,type)elseif ap==0 then local c4,c8=c2(by:normalize())if c8~=nil then local ik=cz(c8)local travelTime=a_.computeTravelTime(bz,0,c8)local il="Collision"if c4.noAtmosphericDensityAltitude>0 then il="Atmosphere"end;gH[#gH+1]=cm(ib,ii+20,c4.name.." "..il.." "..cK(travelTime).." In "..ik,"crit")end end;if VectorToTarget and not IntoOrbit then gH[#gH+1]=cm(ib,ih+35,VectorStatus,"warn")end;gH[#gH+1]="</g>"return gH end;local function im(eK)return d(y(eK*3.6,0)+0.5).." km/h"end;local function io(gH)local ip=OrbitMapX;local iq=OrbitMapY;local ir=OrbitMapSize;local is=4;local it=15;local cn=0;local co=0;local iu,iv,iw,ix;local function iy(type)local iz,B,eK,iA;if type=="Periapsis"then iz=orbit.periapsis.altitude;B=orbit.timeToPeriapsis;eK=orbit.periapsis.speed;iA=35 else iz=orbit.apoapsis.altitude;B=orbit.timeToApoapsis;eK=orbit.apoapsis.speed;iA=-35 end;gH[#gH+1]=e([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],cn+iA,co-5,ip+ir/2-iu+ix,co-5)gH[#gH+1]=cm(cn,co,type)co=co+it;local ik=cz(iz)gH[#gH+1]=cm(cn,co,ik)co=co+it;gH[#gH+1]=cm(cn,co,cK(B))co=co+it;gH[#gH+1]=cm(cn,co,im(eK))end;if orbit~=nil and ap<0.2 and planet~=nil and orbit.apoapsis~=nil and orbit.periapsis~=nil and orbit.period~=nil and orbit.apoapsis.speed>5 and DisplayOrbit then iq=iq+is;cn=ip+ir+ip/2+is;co=iq+ir/2+5+is;iu=ir/4;ix=0;gH[#gH+1]=[[<g class="pbright txtorb txtmid">]]gH[#gH+1]=e('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />',ir+ip*2,ir+iq,is,is)if orbit.periapsis~=nil and orbit.apoapsis~=nil then iw=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(iu*2)iv=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/iw*(1-orbit.eccentricity)ix=iu-orbit.periapsis.altitude/iw-planet.radius/iw;local iB=""if orbit.periapsis.altitude<=0 then iB='redout'end;gH[#gH+1]=e([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],iB,ip+ir/2+ix+is,iq+ir/2+is,iu,iv)gH[#gH+1]=e('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',ip+ir/2+is,iq+ir/2+is,planet.radius/iw)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then iy("Apoapsis")end;co=iq+ir/2+5+is;cn=ip-ip/2+10+is;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then iy("Periapsis")end;gH[#gH+1]=cm(ip+ir/2+is,planet.name,20+is,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local iC=orbit.timeToApoapsis/orbit.period*2*math.pi;local iD=iu*math.cos(iC)local iE=iv*math.sin(iC)gH[#gH+1]=e('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',ip+ir/2+iD+ix+is,iq+ir/2+iE+is)end;gH[#gH+1]=[[</g>]]return gH else return gH end end;local function iF(gH)local cn=30;local co=275;local iG={"Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view"}local iH={"","------------------IN ATMO-----------------","Alt-4: Autopilot in atmo to target","Alt-4-4: Autopilot to LowOrbitHeight over atmosphere and orbit to target","Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local iI={"","------------------NO ATMO-----------------","Alt-4 (Alt < 100k): Autopilot to Orbit and land","Alt-4 (Alt > 100k): Autopilot to target","Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local iJ={"","------------------ALWAYS--------------------","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and offset","Alt-8: Toggle ground stabilization (underwater flight)","Alt-9: Activate Gyroscope","","CTRL: Toggle Brakes on and off, cancels active AP","LeftAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}if ao then cc(iG,iH)table.insert(iG,"--------------CONDITIONAL-----------------")if VertTakeOff then table.insert(iG,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end;if am~=-1 then if antigrav then if bF then table.insert(iG,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(iG,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(iG,"Alt-6: Begins Vertical Takeoff.")else table.insert(iG,"Alt-4/Alt-6: Autotakeoff if below hoverheight")end else table.insert(iG,"G: Begin BrakeLanding or Land")end else cc(iG,iI)end;if AltitudeHold then table.insert(iG,"Alt-Spacebar/Alt-C will raise/lower target height")end;cc(iG,iJ)for i=1,#iG do co=co+12;gH[#gH+1]=cm(cn,co,iG[i],"pdim txttick txtstart")end end;local function iK(iL,iM)local iN;local iO=(iM-iL):normalize()local eP=(bC-iL):dot(iO)/iO:dot(iO)if eP<=0.then return(bC-iL):len()elseif eP>=(iM-iL):len()then return(bC-iM):len()end;local iP=iL+eP*iO;iN=(iP-bC):len()return iN end;local function iQ()local iN;local iR=nil;local iS=nil;local iT=nil;for cT,iU in pairs(aU[0])do if iU.hasAtmosphere then local ah=iK(planet.center,iU.center)if iR==nil or ah<iR then iS=iU;iR=ah;iT=planet end;if aa and aa.hasAtmosphere and aa.name~=planet.name then local e9=iK(aa.center,iU.center)if e9<iR then iS=iU;iR=e9;iT=aa end end end end;local iV=gt(1770)local iW=gu(330)if iR then local iX="txttick "local iY=500000;if iR<iS.radius+iY or iR<iT.radius+iY then if bO then iX="txttick red "else iX="txttick orange "end end;iN=cz(iR,2)bQ=cm(iV,iW,"Pipe ("..iT.name.."--"..iS.name.."): "..iN,iX.."pbright txtmid")end end;local iZ={}function iZ.HUDPrologue(gH)bO,gk=gr(bC)if not bO then F=PvPR;H=PvPG;G=PvPB else F=SafeR;H=SafeG;G=SafeB end;aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]local i_=aw;local j0=ax;local j1=aw;local j2=ax;if gv()and not brightHud then i_=[[rgb(]]..d(F*0.4+0.5)..","..d(H*0.4+0.5)..","..d(G*0.3+0.5)..[[)]]j0=[[rgb(]]..d(F*0.3+0.5)..","..d(H*0.3+0.5)..","..d(G*0.2+0.5)..[[)]]end;gH[#gH+1]=e([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none}
                                .linethick {stroke-width:3px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank}
                                .warn {fill:orange;font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                .pbright {fill:%s;stroke:%s}
                                .dim {fill:%s;stroke:%s}
                                .pdim {fill:%s;stroke:%s}
                                .red {fill:red;stroke:red}
                                .orange {fill:orange;stroke:orange}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                            ]],i_,i_,j1,j1,j0,j0,j2,j2,aE,aF)return gH end;function iZ.DrawVerticalSpeed(gH,du)gX(gH,du)end;function iZ.UpdateHud(gH)local hM=bI;local j3=bJ;local h4=j3;local hj=hM;local i2=d(unit.getThrottle())local i7=bz*3.6;local i3=unit.getAxisCommandValue(0)local j4=gt(1770)local j5=gu(310)if AtmoSpeedAssist and bH then i3=I;i2=I*100 end;local gx=gw()local h5="ROLL"if i2==nil then i2=0 end;if not bT then if bz>5 then hM=hL(by)j3=hN(by)else hM=0;j3=0 end;h5="YAW"end;if gk>50000 and not ao then local j6;j6=cz(gk)gH[#gH+1]=cm(j4,j5,"PvP Boundary: "..j6,"pbright txtbig txtmid")end;gH[#gH+1]=ai;gH[#gH+1]=aB;gH[#gH+1]=bP;if bQ~=""then gH[#gH+1]=bQ end;if aT%aN==0 then aS=true end;if fuelX~=0 and fuelY~=0 then gG(gH,aS,fuelX,"Atmospheric ","ATMO",aG,aQ,aR)gG(gH,aS,fuelX+120,"Space fuel t","SPACE",aH,aO,aP)gG(gH,aS,fuelX+240,"Rocket fuel ","ROCKET",aI,aL,aM)end;if aS then aS=false;aT=0 end;aT=aT+1;gX(gH,aq)if l()==0 or RemoteHud then if not gv()or brightHud then if bT then h3(gH,centerX,centerY,h4,h5,bT)hi(gH,hj,h4,centerX,centerY,bT,d(hN(by)),bz)else h3(gH,centerX,centerY,j3,h5,bT)hi(gH,hM,j3,centerX,centerY,bT,d(j3),bz)end;hp(gH,aq,bT)hO(gH,by,bz,centerX,centerY)end end;i1(gH,gx,i2,i3)i6(gH,i7)ia(gH)io(gH)if showHelp then iF(gH)end;return gH end;function iZ.HUDEpilogue(gH)gH[#gH+1]="</svg>"return gH end;function iZ.ExtraData(gH)local j7=gt(1240)local j8=gu(55)local j9=j8+10;local ja;local jb=0;local gx=gw()if VertTakeOffEngine then gx=gx.."-VERTICAL"end;if CollisionSystem and not AutoTakeoff and not BrakeLanding and bz>20 then gx=gx.."-COLLISION ON"end;if TurnBurn then gx="TB-"..gx end;if not stablized then gx=gx.."-DeCoupled"end;local jc=vec3(core.getWorldAcceleration()):len()/9.80665;ja=core.g()gH[#gH+1]=[[<g class="pdim txt txtend">]]if l()==1 and not RemoteHud then j7=gt(1120)j8=gu(55)j9=j8+10 elseif ao then local jd=gt(770)gH[#gH+1]=cm(jd,j8,"ATMOSPHERE","pdim txt txtend")gH[#gH+1]=cm(jd,j9,e("%.2f",ap),"pdim txt txtend","")end;gH[#gH+1]=cm(j7,j8,"GRAVITY","pdim txt txtend")gH[#gH+1]=cm(j7,j9,e("%.2f",ja/9.80665),"pdim txt txtend")gH[#gH+1]=cm(j7,j8+20,"ACCEL","pdim txt txtend")gH[#gH+1]=cm(j7,j9+20,e("%.2f",jc),"pdim txt txtend")gH[#gH+1]=cm(gt(960),gu(180),gx,"txtbig txtmid")end;function iZ.DrawOdometer(gH,ab,TotalDistanceTravelled,ac)local ja;local je=0;local jf=0;local jb=0;if ao then jb=LastMaxBrakeInAtmo else jb=LastMaxBrake end;maxThrust=a:maxForceForward()ja=core.g()if ja>0.1 then jf=at*ja;je=maxThrust/ja end;gH[#gH+1]=e([[
                        <g class="pbright txt">
                        <path class="linethick" d="M %d 0 L %d %d Q %d %d %d %d L %d 0"/>]],gt(660),gt(700),gu(35),gt(960),gu(55),gt(1240),gu(35),gt(1280))if l()==0 or RemoteHud then gH[#gH+1]=cm(gt(700),gu(20),e("Trip: %.2f km",ab),"txtstart")gH[#gH+1]=cm(gt(700),gu(30),e("Lifetime: %.2f kSU",TotalDistanceTravelled/200000),"txtstart")gH[#gH+1]=cm(gt(830),gu(20),"Trip Time: "..cK(ac),"txtstart")gH[#gH+1]=cm(gt(830),gu(30),"Total Time: "..cK(TotalFlightTime),"txtstart")gH[#gH+1]=cm(gt(970),gu(20),e("Mass: %.2f Tons",at/1000),"txtstart")gH[#gH+1]=cm(gt(1240),gu(10),e("Max Brake: %.2f kN",jb/1000),"txtend")gH[#gH+1]=cm(gt(1240),gu(30),e("Max Thrust: %.2f kN",maxThrust/1000),"txtend")if ja>0.1 then gH[#gH+1]=cm(gt(970),gu(30),e("Max Mass: %.2f Tons",je/1000),"txtstart")gH[#gH+1]=cm(gt(1240),gu(20),e("Req Thrust: %.2f kN",jf/1000),"txtend")else gH[#gH+1]=cm(gt(970),gu(30),"Max Mass: n/a","txtstart")gH[#gH+1]=cm(gt(1240),gu(20),"Req Thrust: n/a","txtend")end end;gH[#gH+1]="</g>"return gH end;function iZ.DrawWarnings(gH)return ia(gH)end;function iZ.DisplayOrbitScreen(gH)return io(gH)end;function iZ.DisplayMessage(gH,ik)if ik~="empty"then local co=310;for jg in string.gmatch(ik,"([^\n]+)")do co=co+35;gH[#gH+1]=cm("50%",co,jg,"msg")end end;if ag~=0 then unit.setTimer("msgTick",ag)ag=0 end end;function iZ.DrawDeadZone(gH)gH[#gH+1]=e([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function iZ.UpdatePipe()if ao then bQ=""return end;iQ()end;function iZ.DrawSettings(gH)if#bL>0 then local cn=gt(640)local co=gu(200)gH[#gH+1]=[[<g class="pbright txtvspd txtstart">]]for cT,bY in pairs(bL)do gH[#gH+1]=cm(cn,co,bY..": ".._G[bY])co=co+20;if cT%12==0 then cn=cn+gt(350)co=gu(200)end end;gH[#gH+1]=cm(gt(640),gu(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")gH[#gH+1]="</g>"end;return gH end;local jh;local ji=gt(1770)local jj=gu(350)local jk=gu(15)local jl=gt(1370)local jm,jn;local jo=0;function iZ.DrawRadarInfo()local function jp()if radarPanelID~=nil and jo==0 then r(radarPanelID)radarPanelID=nil;if jh~=nil then r(jh)jh=nil end else if jo==1 then r(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")jh=_autoconf.panels[_autoconf.panels_size]end;placeRadar=true;if radarPanelID==nil and placeRadar then _autoconf.displayCategoryPanel(radar,radar_size,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]placeRadar=false end;jo=0 end end;local ff,fg,fe,fh,fi,fb=b5.GetRadarHud()if fe>0 then if CollisionSystem then jm=fh.."/"..fi.." Plotted : "..fe-fi.." Ignored"else jm="Radar Contacts: "..fe end;bP=cm(ji,jj,jm,"pbright txtbig txtmid")if#fb>0 then bP=bP..cm(jl,jk,"Friendlies In Range","pbright txtbig txtmid")for cT,bY in pairs(fb)do jk=jk+20;bP=bP..cm(jl,jk,radar_1.getConstructName(bY),"pdim txtmid")end;fb={}end;if ff==nil and jh==nil then jo=1;jp()end;if ff~=nil and jh~=nil then jp()end;if radarPanelID==nil then jp()end else if fg then bP=cm(ji,jj,"Radar: Jammed","pbright txtbig txtmid")else bP=cm(ji,jj,"Radar: No Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then jo=0;jp()end end end;return iZ end;local function jq()local function jr(position)local dp=sys:closestBody(position)if(position-dp.center):len()>dp.radius+dp.noAtmosphericDensityAltitude then dp=aU[0][0]end;return dp end;local function js()local function jt(ju,jv)return ju.name<jv.name end;bN={}for cT,bY in pairs(aU[0])do bN[#bN+1]={name=bY.name,index=cT}end;table.sort(bN,jt)end;local function jw(jx)for cT,bY in pairs(jx)do if bY.name and bY.name==CustomTarget.name then return cT end end;return-1 end;local function jy()if AutopilotTargetIndex==0 then AutopilotTargetName="None"aa=nil;CustomTarget=nil;return true end;local jz=bN[AutopilotTargetIndex].index;local jA=aU[0][jz]if jA.center then AutopilotTargetName=jA.name;aa=aZ[0][jz]if CustomTarget~=nil then if ap==0 then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end;if s(widgetTargetOrbitText,widgetTargetOrbit)~=1 then t(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=jA;for _,bY in pairs(aZ[0])do if bY.name==CustomTarget.planetname then aa=bY;AutopilotTargetName=CustomTarget.name;break end end;if s(widgetMaxMassText,widgetMaxMass)~=1 then t(widgetMaxMassText,widgetMaxMass)end;if s(widgetTravelTimeText,widgetTravelTime)~=1 then t(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(aa.center)else AutopilotTargetCoords=CustomTarget.position end;if aa.planetname~="Space"then if aa.hasAtmosphere then AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=d(aa.radius*(TargetOrbitRadius-1)+aa.surfaceMaxAltitude)end else AutopilotTargetOrbit=1000 end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=b1(aa):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function jB(h0)if not Autopilot and not VectorToTarget and not ak and not IntoOrbit then if h0==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bN then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bN end end;if AutopilotTargetIndex==0 then jy()else local jz=bN[AutopilotTargetIndex].index;local jA=aU[0][jz]if jA.name=="Space"or iphCondition=="Custom Only"and jA.center or iphCondition=="No Moons"and string.find(jA.name,"Moon")~=nil then if h0==nil then jB()else jB(1)end else jy()end end else a0="Disengage autopilot before changing Interplanetary Helper"c9("iph","AP")end end;local function jC()local fX=-1;fX=jw(aU[0])if fX>-1 then table.remove(aU[0],fX)end;fX=-1;fX=jw(SavedLocations)if fX~=-1 then a0=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fX)end;jB()js()end;local function jD(bW,position,hI,jE)if dbHud_1 or hI then local dp=jr(position)local ja=dp.gravity;local jF=dp.atmosphericDensityAboveSurface;if jE then jF=ap;ja=unit.getClosestPlanetInfluence()end;local jG={position=position,name=bW,atmosphere=jF,planetname=dp.name,gravity=ja,safe=jE}if not hI then SavedLocations[#SavedLocations+1]=jG else for cT,bY in pairs(aU[0])do if bY.name and bW==bY.name then table.remove(aU[0],cT)end end end;table.insert(aU[0],jG)js()jy()a0="Location saved as "..bW.."("..dp.name..")"else a0="Databank must be installed to save permanent locations"end end;local cU={}function cU.UpdateAtlasLocationsList()js()end;function cU.UpdateAutopilotTarget()jy()end;function cU.adjustAutopilotTargetIndex(h0)jB(h0)end;function cU.findAtlasIndex(jx)jw(jx)end;function cU.UpdatePosition(jH)local fX=jw(SavedLocations)if fX~=-1 then if jH~=nil then SavedLocations[fX].name=jH else local jI=SavedLocations[fX]jC()jD(jI.name,bC,false,true)end;a0=SavedLocations[fX].name.." position updated ("..SavedLocations[fX].planetname..")"else a0="Name Not Found"end end;function cU.AddNewLocation(bW,position,hI,jE)jD(bW,position,hI,jE)end;function cU.ClearCurrentPosition()jC()end;for cT,bY in pairs(SavedLocations)do table.insert(aU[0],bY)end;js()cU.UpdateAutopilotTarget()return cU end;local function jJ()local jK={}local function jL(eK)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;if not ao then return a_.computeDistanceAndTime(eK,jM,at,0,0,LastMaxBrake-AutopilotPlanetGravity*at)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return a_.computeDistanceAndTime(eK,jM,at,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*at)else return 0,0 end end end;local function jN(eK)local jM=AutopilotEndSpeed;if not Autopilot then jM=0 end;return a_.computeDistanceAndTime(eK,jM,at,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*at)end;local jO=false;function jK.GetAutopilotBrakeDistanceAndTime(eK)return jL(eK)end;function jK.GetAutopilotTBBrakeDistanceAndTime(eK)return jN(eK)end;local function jP(jQ,jR,jS)jR=jR:project_on_plane(jQ)jS=jS:project_on_plane(jQ)return m(jR:cross(jS):dot(jQ),jR:dot(jS))end;local function jT()local function jU()local jV=-1;local jW=-1;if vBooster then jV=vBooster.distance()end;if hover then jW=hover.distance()end;if jV~=-1 and jW~=-1 then if jV<jW then return jV else return jW end elseif jV~=-1 then return jV elseif jW~=-1 then return jW else return-1 end end;local jX=jU()local jY=-1;if telemeter_1 then jY=telemeter_1.getDistance()end;if jX~=-1 and jY~=-1 then if jX<jY then return jX else return jY end elseif jX~=-1 then return jX else return jY end end;local function jZ(planet,e5,j_)local function k0(k1,dm)local eb=vec3(dm)if k1.bodyId==0 then return setmetatable({latitude=eb.x,longitude=eb.y,altitude=eb.z,bodyId=0,systemId=k1.planetarySystemId},MapPosition)end;local ec=eb-k1.center;local ah=ec:len()local du=ah-k1.radius;local ds=0;local dt=0;if not cw(ah,0)then local ed=m(ec.y,ec.x)dt=ed>=0 and ed or 2*math.pi+ed;ds=math.pi/2-math.acos(ec.z/ah)end;return setmetatable({latitude=math.deg(ds),longitude=math.deg(dt),altitude=du,bodyId=k1.bodyId,systemId=k1.planetarySystemId},MapPosition)end;local k2=k0(planet,e5)k2="::pos{"..k2.systemId..","..k2.bodyId..","..k2.latitude..","..k2.longitude..","..k2.altitude.."}"if j_ then return k2 else system.setWaypoint(k2)return true end end;local k3=false;function jK.showWayPoint(planet,e5,j_)return jZ(planet,e5,j_)end;function jK.APTick()local function k4()if bV and not BrakeLanding then local c7=bV[1]local gb,gc=bV[2],bV[3]local k5=math.min(gb,gc or gb)local k6=k5/bz;local k7=AutoTakeoff and(bz<42 or am~=-1)local k8=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if k8 and not k7 and(a6*1.5>k5 or k6<1)then BrakeIsOn=true;cs(0)if AltitudeHold then cE()end;if LockPitch then ToggleLockPitch()end;a0="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cF()end;StrongBrakes=true;BrakeLanding=true;b8=true end;if k6<11 then bU=c7.name.." COLLISION "..cK(k6).." / "..cz(k5,2)else bU=c7.name.." collision "..cK(k6)end;if k6<6 then c9("alarm","AL",2)end else bU=false end end;local function k9(c3,ka,kb)local function kc(c3,dS)c3=vec3(c3)dS=vec3(dS):normalize()local d8=c3*dS;return d8.x+d8.y+d8.z end;local kd=0.001;local ke=1;if not ao or not ba or am~=-1 or bz<O then if kb==nil then kb=DampingMultiplier end;if ka==nil then ka=kd end;c3=vec3(c3):normalize()local kf=vec3()-c3;local kg=-kc(kf,core.getConstructWorldOrientationRight())*ke;local kh=-kc(kf,core.getConstructWorldOrientationUp())*ke;if az==0 then az=kg/2 end;if aA==0 then aA=kh/2 end;if c(kg)<0.1 then T=T-kg*2 else T=T-(kg+(kg-az)*kb)end;if c(kh)<0.1 then S=S+kh*2 else S=S+kh+(kh-aA)*kb end;az=kg;aA=kh;if c(kg)<ka and c(kh)<ka then return true end;return false elseif ba and am==-1 then c3=by;if kb==nil then kb=DampingMultiplier end;if ka==nil then ka=kd end;c3=vec3(c3):normalize()local kf=bw-c3;local kg=-kc(kf,core.getConstructWorldOrientationRight())*ke;local kh=-kc(kf,core.getConstructWorldOrientationUp())*ke;if az==0 then az=kg/2 end;if aA==0 then aA=kh/2 end;if c(kg)<0.1 then T=T-kg*5 else T=T-(kg+(kg-az)*kb)end;if c(kh)<0.1 then S=S+kh*5 else S=S+kh+(kh-aA)*kb end;az=kg;aA=kh;if c(kg)<ka and c(kh)<ka then return true end;return false end end;ao=j()>0;ap=j()aq=core.getAltitude()am=jT()B=o()bb=B;bT=unit.getClosestPlanetInfluence()>0;if CollisionSystem then k4()end;if antigrav then bF=antigrav.getState()==1 end;local ki=1;local kj=1;local kk=B-bb;local kl=-math.deg(jP(bv,by,bw))local km=math.deg(jP(bx,by,bw))local h0=bA*-1;ba=ao and kl<-YawStallAngle or kl>YawStallAngle or km<-PitchStallAngle or km>PitchStallAngle;local kn=system.getMouseDeltaX()local ko=system.getMouseDeltaY()if InvertMouse and not Z then ko=-ko end;T=0;X=0;S=0;sys=aZ[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=b1(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),by)if aq==0 then aq=(bC-planet.center):len()-planet.radius end;local ja=planet:getGravity(core.getConstructWorldPos()):len()*at;bc=0;b0=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if v()==0 then if l()==1 and Z then if not b6 then ae=ae+kn;af=af+ko end else ae=0;af=0 end else ae=ae+kn;af=af+ko;ah=w(ae*ae+af*af)if not Z and l()==0 then if userControlScheme=="virtual joystick"then if ae>0 and ae>DeadZone then T=T-(ae-DeadZone)*MouseXSensitivity elseif ae<0 and ae<DeadZone*-1 then T=T-(ae+DeadZone)*MouseXSensitivity else T=0 end;if af>0 and af>DeadZone then S=S-(af-DeadZone)*MouseYSensitivity elseif af<0 and af<DeadZone*-1 then S=S-(af+DeadZone)*MouseYSensitivity else S=0 end else ae=0;af=0;if userControlScheme=="mouse"then S=(-utils.smoothstep(ko,-100,100)+0.5)*2*ki;T=(-utils.smoothstep(kn,-100,100)+0.5)*2*kj end end end end;local kp=bz>8334;if bz>SpaceSpeedLimit/3.6 and not ao and not Autopilot and not kp then a0="Space Speed Engine Shutoff reached"cs(0)end;if not kp and LastIsWarping then if not BrakeIsOn then cH()end;if Autopilot then cF()end end;LastIsWarping=kp;if ao and ap>0.09 then if bz>bf/3.6 and not AtmoSpeedAssist and not jO then BrakeIsOn=true;jO=true elseif not AtmoSpeedAssist and jO then if bz<bf/3.6 then BrakeIsOn=false;jO=false end end end;if BrakeIsOn then W=1 else W=0 end;if ProgradeIsOn then if aj then BrakeIsOn=false;local kq=false;if CustomTarget~=nil then kq=k9(CustomTarget.position-bC,0.1)else kq=k9(vec3(by),0.01)end;b8=true;if kq then cv(d(bf))if(c(bJ)<2 or c(bI)>85)and bz>=bf/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;P=true;aj=false;al=true;Autopilot=false;cI()end elseif ao and AtmoSpeedAssist then cs(1)end elseif bz>O then k9(vec3(by),0.01)end end;if RetrogradeIsOn then if ao then RetrogradeIsOn=false elseif bz>O then k9(-vec3(by))end end;if not ProgradeIsOn and aj and not IntoOrbit then if ap==0 then P=true;cI()aj=false;al=true else aj=false;cF()end end;if al and CustomTarget~=nil and(aq<HoldAltitude+250 and aq>HoldAltitude-250)and bz*3.6>bf-250 and c(bB)<25 and ap>=0.1 and(CustomTarget.position-bC):len()>2000+aq then cF()al=false end;if VertTakeOff then b8=true;local kr=HoldAltitude;if bB<-30 then a0="Unable to achieve lift. Safety Landing."ad=0;b8=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and bF or HoldAltitude<planet.spaceEngineMinAltitude then if bF then kr=antigrav.getBaseAltitude()end;if aq<kr-100 then bg=0;ad=15;BrakeIsOn=false elseif bB>0 then BrakeIsOn=true;ad=0 elseif bB<-30 then BrakeIsOn=true;ad=15 elseif aq>=kr then if bF then if Autopilot or VectorToTarget then cC()else BrakeIsOn=true;VertTakeOff=false end;a0="Takeoff complete. Singularity engaged"c9("aggLk","AG")else BrakeIsOn=false;a0="VTO complete. Engaging Horizontal Flight"c9("vtoc","VT")cC()end;ad=0 end else if ap>0.08 then bg=0;BrakeIsOn=false;ad=20 elseif ap<0.08 and ap>0 then BrakeIsOn=false;if bs then bg=0;ad=20 else ad=0;bg=36;cv(3500)end else b8=autoRollPreference;IntoOrbit=true;bq=false;CancelIntoOrbit=false;bk=false;bi=nil;bj=nil;if bp==nil then bp=planet end;bo=kr;bn=true;VertTakeOff=false end end;if bg~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ks=p(bg-bI,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ks)local kt=p(vTpitchPID:get(),-1,1)S=kt end end;if IntoOrbit then local kf;local ku=false;local kv=cz(bo)if bp==nil then bp=planet;if VectorToTarget then bp=aa end end;if not bn then bo=d(bp.radius+bp.surfaceMaxAltitude+LowOrbitHeight)if bp.hasAtmosphere then bo=d(bp.radius+bp.noAtmosphericDensityAltitude+LowOrbitHeight)end;bn=true end;if bm.VectorToTarget then kf=CustomTarget.position-bC end;local kw,kx=b1(bp):escapeAndOrbitalSpeed((bC-bp.center):len()-bp.radius)local ky=bJ;if not bk then local kz=false;local kA=false;cs(0)bj=0;bh="Aligning to orbital path - OrbitHeight: "..kv;if bm.VectorToTarget then k9(kf:normalize():project_on_plane(bA))ku=bw:dot(kf:project_on_plane(bv):normalize())>0.95 else k9(by)ku=kl<0.5;if bz<150 then ku=true end end;S=0;bi=0;if bI<=bi+1 and bI>=bi-1 then kz=true else kz=false end;if ky<=bj+1 and ky>=bj-1 then kA=true else kA=false end;if kz and kA and ku then bi=nil;bj=nil;bk=true end else if bm.VectorToTarget then k9(kf:normalize():project_on_plane(bA))elseif bz>150 then k9(by)end;S=0;if bm.VectorToTarget then local a6,_=a_.computeDistanceAndTime(bz,bf/3.6,at,0,0,LastMaxBrake)if bq and kf:len()>15000+a6+aq then bh="Orbiting to Target"if aq-100<=bp.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bp.noAtmosphericDensityAltitude then bq=false end elseif bq or kf:len()<15000+a6+aq then a0="Orbit complete, proceeding with reentry"c9("orCom","OB")AutopilotTargetCoords=CustomTarget.position;P=true;al=true;bm.VectorToTarget,bm.AutopilotAlign=false,false;cD()cI()end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and aq>bo*0.9 and aq<bo*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bo*0.99 and orbit.apoapsis.altitude>=bo*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bq then if bq then BrakeIsOn=false;cs(0)bi=0;if not bm.VectorToTarget then a0="Orbit complete"c9("orCom","OB")cD()end else bu=bu+1;if bu>=2 then bq=true end end else bh="Adjusting Orbit - OrbitHeight: "..kv;bl=true;cv(kx*3.6+1)if VSpdPID==nil then VSpdPID=pid.new(0.5,0,10*0.1)end;local kB=bB;local kC=aq-bo;local kD=c(kC)if bB<10 and c(bI)<10 and kD<100 then kB=bB*2 end;if kB<10 and c(bI)<10 and kD<100 then kB=kB*2 end;if kB<5 and c(bI)<5 and kD<100 then kB=kB*4 end;VSpdPID:inject(kB)bi=p(-VSpdPID:get(),-90,90)if OrbitAltPID==nil then OrbitAltPID=pid.new(0.15,0,5*0.1)end;OrbitAltPID:inject(kC)bi=p(bi-p(OrbitAltPID:get(),-15,15),-90,90)end end else local kE=2.75;local kF=c(y(kw*kE))local kG=kF%50;if kG>0 then kF=kF-kG+50 end;BrakeIsOn=false;if aq<bo*0.8 then bh="Escaping planet gravity - OrbitHeight: "..kv;bi=utils.map(bB,200,0,-15,80)elseif aq>=bo*0.8 and aq<bo*1.15 then bh="Approaching orbital corridor - OrbitHeight: "..kv;kF=kF*0.75;bi=utils.map(bB,100,-100,-15,65)elseif aq>=bo*1.15 and aq<bo*1.5 then bh="Approaching orbital corridor - OrbitHeight: "..kv;kF=kF*0.75;if bB<0 or bl then bi=utils.map(aq,bo*1.5,bo*1.01,-30,0)else bi=utils.map(aq,bo*0.99,bo*1.5,0,30)end elseif aq>bo*1.5 then bh="Reentering orbital corridor - OrbitHeight: "..kv;bi=-65;local kH=utils.map(bB,-150,-400,1,0.55)kF=kF*kH end;cv(d(kF))end end;if bi~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local kI=bi-bI;OrbitPitchPID:inject(kI)local kJ=p(OrbitPitchPID:get(),-0.5,0.5)S=kJ end end;if Autopilot and ap==0 and not aj then local function kK(jm,orbit)system.print(jm)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cs(0)N=false;a0=jm;c9("apCom","AP")if orbit or aj then if orbit and AutopilotTargetOrbit~=nil and not aj then if not aq or aq==0 then return end;bo=aq;bn=true end;cD()end end;local kL,kM=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local kN=(CustomTarget.position-aa.center):normalize()local kO=kN:project_on_plane((aa.center-bC):normalize()):normalize()local kP=aa.center+kO*(aa.radius+AutopilotTargetOrbit)local kQ=CustomTarget.position+(CustomTarget.position-aa.center):normalize()*(AutopilotTargetOrbit-aa:getAltitude(CustomTarget.position))if(bC-kP):len()<(bC-kQ):len()then kL=kP else kL=kQ;AutopilotEndSpeed=0 end;AutopilotTargetCoords=kL;b4.showWayPoint(aa,AutopilotTargetCoords)kM=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotPlanetGravity=0;kM=true;TargetSet=true;AutopilotRealigned=true;kL=CustomTarget.position+(bC-CustomTarget.position)*AutopilotTargetOrbit elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local kN=(bC+by*100000-aa.center):normalize()local kO=kN:project_on_plane((aa.center-bC):normalize()):normalize()if kO:len()<1 then kN=(bC+bw*100000-aa.center):normalize()kO=kN:project_on_plane((aa.center-bC):normalize()):normalize()end;kL=aa.center+kO*(aa.radius+AutopilotTargetOrbit)AutopilotTargetCoords=kL;TargetSet=true;kM=true;AutopilotRealigned=true;b4.showWayPoint(aa,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(kL)-bC):len()local c4,c5,c6=aZ:getPlanetarySystem(0):castIntersections(bC,by:normalize(),function(c7)if c7.noAtmosphericDensityAltitude>0 then return c7.radius+c7.noAtmosphericDensityAltitude else return c7.radius+c7.surfaceMaxAltitude*1.5 end end)local c8=c5;if c6~=nil and c5~=nil then c8=math.min(c6,c5)end;if c8~=nil and c8<AutopilotDistance and c4.name==aa.name then AutopilotDistance=c8 end;local kq=true;local kR=(aa.center-(bC+vec3(by):normalize()*AutopilotDistance)):len()-aa.radius;local ik=cz(kR)s(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..ik..'"}')local a6,a7;if not TurnBurn then a6,a7=jL(bz)else a6,a7=jN(bz)end;if bz>300 and AutopilotAccelerating then local kf=vec3(kL)-bC;local kS=p(math.deg(jP(bv,by:normalize(),kf:normalize()))*bz/500,-90,90)local kT=p(math.deg(jP(bx,by:normalize(),kf:normalize()))*bz/500,-90,90)if c(kS)<20 and c(kT)<20 then kS=kS*2;kT=kT*2 end;if c(kS)<2 and c(kT)<2 then kS=kS*2;kT=kT*2 end;local kl=-math.deg(jP(bv,bw,by:normalize()))local km=-math.deg(jP(bx,bw,by:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(kT-km)local kU=p(apPitchPID:get(),-1,1)S=S+kU;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(kS-kl)local kV=p(apYawPID:get(),-1,1)T=T+kV;kM=true;if c(kS)>2 or c(kT)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c9("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end end end;if kR<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=b1(aa):escapeAndOrbitalSpeed(kR)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local c4,c8=c2((AutopilotTargetCoords-bC):normalize())if aa.name~=planet.name then if c4~=nil then a0="Collision with "..c4.name.." in "..cz(c8).."\nClear LOS to continue."ag=5;k3=true else k3=false;a0=""end end end;if not k3 then if not AutopilotCruising and not AutopilotBraking and not kM then kq=k9((kL-bC):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then kq=k9(-vec3(by):normalize())end end;if AutopilotAccelerating then if not N then BrakeIsOn=false;cs(AutopilotInterplanetaryThrottle)I=y(AutopilotInterplanetaryThrottle,2)N=true end;local kW=unit.getThrottle()if AtmoSpeedAssist then kW=I end;if by:len()>=MaxGameVelocity or kW==0 and N then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c9("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cs(0)end;if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c9("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cs(0)N=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;W=1 end;if TurnBurn then cs(1,true)end;local _,kx=b1(aa):escapeAndOrbitalSpeed((bC-planet.center):len()-planet.radius)local kf;if CustomTarget~=nil then kf=CustomTarget.position-bC end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bz<50 then kK("Autopilot complete, arrived at space location")BrakeIsOn=true;W=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bz<=kx and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then kK("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;b4.showWayPoint(aa,AutopilotTargetCoords)elseif orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c9("apCir","AP")AutopilotStatus="Circularizing"end;if bz<=kx then if CustomTarget~=nil then if by:normalize():dot(kf:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c9("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;b4.showWayPoint(aa,CustomTarget.position)WaypointSet=true end else kK("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;aj=true;b4.showWayPoint(aa,CustomTarget.position)WaypointSet=false end else kK("Autopilot completed, setting orbit",true)W=0 end end elseif AutopilotStatus=="Circularizing"then kK("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then if AutopilotDistance<=a6 then AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c9("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local kW=unit.getThrottle()if AtmoSpeedAssist then kW=I end;if kW>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end;AutopilotCruising=false end else if kq then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not aj then AutopilotTargetCoords=vec3(aa.center)+(AutopilotTargetOrbit+aa.radius)*bx;AutopilotShipUp=bv;AutopilotShipRight=bx end;AutopilotRealigned=true elseif kq and not k3 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c9("apAcc","AP")end;if not N then cs(AutopilotInterplanetaryThrottle,true)I=y(AutopilotInterplanetaryThrottle,2)N=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ap>0)then a0="Autopilot complete, proceeding with reentry"c9("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"W=0;cs(0)N=false;ProgradeIsOn=true;aj=true;b4.showWayPoint(aa,CustomTarget.position)end;if Y then b8=true;local kT=0;local eO=bC+vec3(unit.getMasterPlayerRelativePosition())local kX=eO-bC;local kY=vec3(kX):project_on(bw):len()local kZ=vec3(kX):project_on(bx):len()local ah=w(kY*kY+kZ*kZ)k9(kX:normalize())local k_=40;local l0=ah<k_;local l1=100;local l2=p((ah-k_)/2,10,l1)S=0;local kq=c(T)<0.1;if kq and bz<l2 and not l0 then BrakeIsOn=false;kT=-20 else BrakeIsOn=true;kT=0 end;local l3=0;if c(kT-bI)>l3 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(kT-bI)local kU=pitchPID:get()S=kU end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local l4=LastMaxBrakeInAtmo;if l4 then l4=l4*p(bz/100,0.1,1)*ap else l4=LastMaxBrake end;if ap<0.01 then l4=LastMaxBrake end;local l5=vec3(core.getWorldAirFrictionAcceleration())local l6=w(l5:len()-l5:project_on(h0):len())*at;if bz>100 then a6,a7=a_.computeDistanceAndTime(bz,100,at,0,0,l4+l6)local l7,l8=a_.computeDistanceAndTime(100,0,at,0,0,l4/2)a6=a6+l7 else a6,a7=a_.computeDistanceAndTime(bz,0,at,0,0,l4/2)end;local l9=HoldAltitude-aq;local la=500+bz;local lb=1;if AutoTakeoff then lb=p(bz/100,0.1,1)end;local kT=(utils.smoothstep(l9,-la,la)-0.5)*2*MaxPitch*lb;if not Reentry and not aj and not VectorToTarget and bw:dot(by:normalize())<0.99 then kT=(utils.smoothstep(l9,-la*p(20-19*ap*10,1,20),la*p(20-19*ap*10,1,20))-0.5)*2*MaxPitch*p(2-ap*10,1,2)*lb end;if not AltitudeHold then kT=0 end;if LockPitch~=nil then if bT and not IntoOrbit then kT=LockPitch else LockPitch=nil end end;b8=true;local lc=S;if Reentry then local ld=d(bf)local le,lf=a_.computeDistanceAndTime(bz,ld/3.6,at,0,0,LastMaxBrake-planet.gravity*9.8*at)local lg=aq-(planet.noAtmosphericDensityAltitude+5000)if not bH and aq>planet.noAtmosphericDensityAltitude+5000 and bz<=ld/3.6 and bz>ld/3.6-10 and c(by:normalize():dot(bw))>0.9 then cs(0)elseif bH and bz>ld/3.6 and(le>-1 and lg<=le or aq<=planet.noAtmosphericDensityAltitude+5000)then BrakeIsOn=true else BrakeIsOn=false end;cv(ld,true)if not P then kT=-80;if ap>0.02 then a0="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;kT=0;b8=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and aq>planet.noAtmosphericDensityAltitude+5000 then b8=true elseif aq<=planet.noAtmosphericDensityAltitude+5000 then cv(ld)if not bH and q:getTargetSpeed(axisCommandId.longitudinal)==bf then P=false;Reentry=false;b8=true end end end;if bz>O and not ak and not VectorToTarget and not BrakeLanding and ForceAlignment then k9(vec3(by))end;if bR or(VectorToTarget or ak)and AutopilotTargetIndex>0 and ap>0.01 then local kf;if bR then if type(bR)=="table"then kf=bR elseif bR<3 and bR>0 then kf=-bA:cross(by)*5000 elseif bR>=3 then kf=bA:cross(by)*5000 elseif bR<0 then kf=by*25000 end elseif CustomTarget~=nil then kf=CustomTarget.position-bC else kf=aa.center-bC end;local kS=math.deg(jP(bA:normalize(),by,kf))*2;local lh=math.rad(c(bJ))if bz>minRollVelocity and ap>0.01 then local li=p(90-kT*2,-90,90)bc=p(kS*2,-li,li)local lj=kS;kS=p(p(kS,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(lh)+4*(bI-kT)*math.sin(math.rad(bJ)),-YawStallAngle*0.80,YawStallAngle*0.80)kT=p(p(kT*math.cos(lh),-PitchStallAngle*0.80,PitchStallAngle*0.80)+c(p(c(lj)*math.sin(lh),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else bc=0;kS=p(kS,-YawStallAngle*0.80,YawStallAngle*0.80)end;local lk=kl-kS;if bR and c(lk)<=0.0001 and(type(bR)=="table"or type(bR)~="table"and bR<0 and c(bJ)<1)then if bR==-2 then cE()end;bR=nil;c9("180Off","BR")return end;if not ba and bz>minRollVelocity and ap>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(lk)local kV=p(yawPID:get(),-1,1)T=T+kV elseif ao and am>-1 or bz<minRollVelocity then k9(kf)elseif ba and ap>0.01 then if(kl<-YawStallAngle or kl>YawStallAngle)and ap>0.01 then k9(by)end;if(km<-PitchStallAngle or km>PitchStallAngle)and ap>0.01 then kT=p(bI-km,bI-PitchStallAngle*0.80,bI+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not ak then local kr=planet:getAltitude(CustomTarget.position)local lg=w(kf:len()^2-(aq-kr)^2)local ll=by:len()-c(bB)StrongBrakes=true;if not ak and not Reentry and lg<=a6+bz*kk/2 and(by:project_on_plane(bA):normalize():dot(kf:project_on_plane(bA):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cs(0)if AltitudeHold then cE()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(ll<0.1 or lg<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<lg)then if not bF then c9("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bU=false end;LastDistanceToTarget=lg end elseif VectorToTarget and ap==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(ak or Reentry)then if CustomTarget~=nil and aa.name==planet.name then local kf=CustomTarget.position-bC;local kr=planet:getAltitude(CustomTarget.position)local lg=w(kf:len()^2-(aq-kr)^2)local l4=LastMaxBrakeInAtmo;if l4 then a6,a7=a_.computeDistanceAndTime(bz,0,at,0,0,l4/2)StrongBrakes=true;if lg<=a6+bz*kk/2 and by:project_on_plane(bA):normalize():dot(kf:project_on_plane(bA):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;P=true;aj=false;al=true;Autopilot=false;cI()end end;LastDistanceToTarget=lg end end end;if ap==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(ak or IntoOrbit or Reentry)then if not bq and not IntoOrbit then bo=HoldAltitude;bn=true;if VectorToTarget then bm.VectorToTarget=true end;cD()VectorToTarget=false;bk=true end end;if ba and ap>0.01 and am==-1 and bz>minRollVelocity and VectorStatus~="Finalizing Approach"then k9(by)kT=p(bI-km,bI-PitchStallAngle*0.80,bI+PitchStallAngle*0.80)end;S=lc;local jY=-1;if BrakeLanding then kT=0;local lm=false;local ln=30;if b0~=nil and b0>0 then local lo=p(ap,0.4,2)local l4=LastMaxBrakeInAtmo*p(bz/100,0.1,1)*lo;local lp=b0*lo+l4-ja;local lq=l4/2-ja;local lr=bz-w(c(lq/2)*20/(0.5*at))*utils.sign(lq)if lr<0 then lr=0 end;local ls;if bz>100 then local lt,_=a_.computeDistanceAndTime(bz,100,at,0,0,l4)local lu,_=a_.computeDistanceAndTime(100,0,at,0,0,w(l4))ls=lt+lu else ls=a_.computeDistanceAndTime(bz,0,at,0,0,w(l4))end;if ls<20 then BrakeIsOn=false else local lv=0;if lr>100 then local lw,_=a_.computeDistanceAndTime(lr,100,at,0,0,lp)local lx,_=a_.computeDistanceAndTime(100,0,at,0,0,b0*lo+w(l4)-ja)lv=lw+lx else lv,_=a_.computeDistanceAndTime(lr,0,at,0,0,b0*lo+w(l4)-ja)end;lv=(lv+15+bz*kk)*1.1;local ly=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if ly then local kr=planet:getAltitude(CustomTarget.position)local lz=aq-kr-100;local kf=CustomTarget.position-bC;local lA=w(kf:len()^2-(aq-kr)^2)if lA>100 then ly=false elseif lz<=lv or lv==-1 then BrakeIsOn=true;lm=true else BrakeIsOn=false;lm=true end end;if not ly and CalculateBrakeLandingSpeed then if lv>=ln then BrakeIsOn=true else BrakeIsOn=false end;lm=true end end end;if not bH then cs(0)end;q:setTargetGroundAltitude(500)q:activateGroundEngineAltitudeStabilization(500)stablized=true;jY=am;if jY>-1 then b8=autoRollPreference;if bz<1 or by:normalize():dot(bA)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if Q then a.control.extendLandingGears()c9("grOut","LG",1)end;q:setTargetGroundAltitude(LandingGearGroundHeight)ad=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and by:normalize():dot(-h0)<0.999 then BrakeIsOn=true elseif bB<-brakeLandingRate and not lm then BrakeIsOn=true elseif not lm then BrakeIsOn=false end end;if AutoTakeoff or ak then local c4,c6,c5;if AutopilotTargetCoords~=nil then c4,c6,c5=aZ:getPlanetarySystem(0):castIntersections(bC,(AutopilotTargetCoords-bC):normalize(),function(c7)return c7.radius+c7.noAtmosphericDensityAltitude end)end;if bF then if aq>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cs(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif c(kT)<15 and aq/HoldAltitude>0.75 then AutoTakeoff=false;if not ak then if bH and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif ak and bz<O then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;cs(0)elseif ak then cs(0)BrakeIsOn=true end elseif ak and ap==0 and aa~=nil and(c4==nil or c4.name==aa.name)then Autopilot=true;ak=false;AltitudeHold=false;AutoTakeoff=false;if not bH then cs(0)end;AutopilotAccelerating=true end end;local lB=am>-1;local lC=bI;if(VectorToTarget or ak or bR)and not lB and bz>minRollVelocity and ap>0.01 then local lh=math.rad(c(bJ))lC=bI*c(math.cos(lh))+km*math.sin(lh)end;local lD=p(kT-lC,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ap<0.01 and VectorToTarget then lD=p(kT-lC,-85,MaxPitch)elseif ap<0.01 then lD=p(kT-lC,-MaxPitch,MaxPitch)end;if c(bJ)<5 or VectorToTarget or bR or BrakeLanding or lB or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(lD)local kU=pitchPID:get()S=S+kU end end;if antigrav~=nil and(antigrav and not ExternalAGG and aq<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;am=jT()return jK end;function script.onStart()local lE={}local lF={}local lG=false;local function lH()local function lI(lJ)local lK=dbHud_1.hasKey;for cT,bY in pairs(lJ)do if lK(bY)then local d8=f(dbHud_1.getStringValue(bY))if d8~=nil then _G[bY]=d8;lG=true end end end end;if dbHud_1 then if not useTheseSettings then lI(cf())coroutine.yield()lI(b)else lI(b)a0="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ag=5;lG=false end;coroutine.yield()if lG then a0="Loaded Saved Variables"aE=ResolutionX;aF=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b8=autoRollPreference;bf=AtmoSpeedLimit;aw=[[rgb(]]..d(F+0.5)..","..d(H+0.5)..","..d(G+0.5)..[[)]]ax=[[rgb(]]..d(F*0.9+0.5)..","..d(H*0.9+0.5)..","..d(G*0.9+0.5)..[[)]]elseif not useTheseSettings then a0="No Saved Variables Found - Exit HUD to save settings"end else a0="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<B then LastMaxBrakeInAtmo=0 end;LastStartTime=B;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a0="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ag=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=aq end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;if safeMass==0 then safeMass=at end;VectorStatus="Proceeding to Waypoint"end;local function lL()local function lM(lN,lO)if lN>lO then lO=lN end;local lP,lQ=0,0;if ContainerOptimization>0 then lP=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then lQ=FuelTankOptimization*0.05 end;lO=lO*(1-(lP+lQ))return lO end;local lR=core.getElementNameById;local lS=fuelX~=0 and fuelY~=0;for cT in pairs(ar)do local type=core.getElementTypeById(ar[cT])if n(type,'^.*Atmospheric Engine$')then if n(tostring(core.getElementTagsById(ar[cT])),'^.*vertical.*$')then bE=true end end;if n(type,'^.*Space Engine$')then bt=true;if n(tostring(core.getElementTagsById(ar[cT])),'^.*vertical.*$')then local lT=core.getElementRotationById(ar[cT])if lT[4]<0 then if y(-lT[4],0.1)==0.5 then br=true end else if y(lT[4],0.1)==0.5 then bs=true end end end end;if type=="Landing Gear"then Q=true end;if type=="Dynamic Core Unit"then local lU=h(ar[cT])if lU>10000 then D=128;E=110 elseif lU>1000 then D=64;E=55 elseif lU>150 then D=32;E=27 end end;aJ=aJ+h(ar[cT])if lS and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local lU=h(ar[cT])local lV=k(ar[cT])local lN=0;local gT=o()if type=="Atmospheric Fuel Tank"then local lO=400;local lW=35.03;if lU>10000 then lO=51200;lW=5480 elseif lU>1300 then lO=6400;lW=988.67 elseif lU>150 then lO=1600;lW=182.67 end;lN=lV-lW;if fuelTankHandlingAtmo>0 then lO=lO+lO*fuelTankHandlingAtmo*0.2 end;lO=lM(lN,lO)aG[#aG+1]={ar[cT],lR(ar[cT]),lO,lW,lN,gT}end;if type=="Rocket Fuel Tank"then local lO=320;local lW=173.42;if lU>65000 then lO=40000;lW=25740 elseif lU>6000 then lO=5120;lW=4720 elseif lU>700 then lO=640;lW=886.72 end;lN=lV-lW;if fuelTankHandlingRocket>0 then lO=lO+lO*fuelTankHandlingRocket*0.1 end;lO=lM(lN,lO)aI[#aI+1]={ar[cT],lR(ar[cT]),lO,lW,lN,gT}end;if type=="Space Fuel Tank"then local lO=2400;local lW=182.67;if lU>10000 then lO=76800;lW=5480 elseif lU>1300 then lO=9600;lW=988.67 end;lN=lV-lW;if fuelTankHandlingSpace>0 then lO=lO+lO*fuelTankHandlingSpace*0.2 end;lO=lM(lN,lO)aH[#aH+1]={ar[cT],lR(ar[cT]),lO,lW,lN,gT}end end end;if not bE then VertTakeOff,VertTakeOffEngine=false,false end end;local function lX()if gyro~=nil then av=gyro.getState()==1 end;if not stablized then q:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then u(1)else u(0)end;if door and(ao or not ao and aq<10000)then for _,bY in pairs(door)do bY.toggle()end end;if switch then for _,bY in pairs(switch)do bY.toggle()end end;if forcefield and(ao or not ao==0 and aq<10000)then for _,bY in pairs(forcefield)do bY.toggle()end end;if antigrav then bF=antigrav.getState()==1;if bF and not ExternalAGG then antigrav.show()end end;if l()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if Q then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if am~=-1 or not ao and by:len()<50 then BrakeIsOn=true;GearExtended=true;if Q then a.control.extendLandingGears()end else BrakeIsOn=false end;q:setTargetGroundAltitude(b9)if ao and am~=-1 then b0=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=ao end;local function lY(lZ,l_,m0,m1,cn,co,m2,m3,m4,m5)local m6={enableName=lZ,disableName=l_,width=m0,height=m1,x=cn,y=co,toggleVar=m2,toggleFunction=m3,drawCondition=m4,hovered=false}if m5 then table.insert(lF,m6)else table.insert(lE,m6)end;return m6 end;local function m7(m8)if not bK then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif m8=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif m8=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif m8=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bL=cf(m8)showHud=false else bL={}showHud=true end end;local function m9()bK=not bK;if bK then aD=lF;a0="Hold SHIFT to see Settings"bM=showHud else aD=lE;a0="Hold SHIFT to see Control Buttons"m7()showHud=bM end end;local function ma(bY)_G[bY]=not _G[bY]if _G[bY]then a0=bY.." set to true"else a0=bY.." set to false"end;if bY=="showHud"then bM=_G[bY]elseif bY=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault elseif bY=="Cockpit"then system.showScreen(0)dbHud_1.setStringValue("content","")end end;local function mb()local mc=50;local md=340;local cn=500;local co=aF/2-400;local me=0;for cT,bY in pairs(cf("boolean"))do if type(_G[bY])=="boolean"then lY(bY,bY,md,mc,cn,co,function()return _G[bY]end,function()ma(bY)end,function()return true end,true)co=co+mc+20;if me==9 then cn=cn+md+20;co=aF/2-400;me=0 else me=me+1 end end end;lY("Control View","Control View",md,mc,10,aF/2-500,function()return true end,m9,function()return true end,true)lY("View Handling Settings",'Hide Handling Settings',md,mc,10,aF/2-(500-mc),function()return showHandlingVariables end,function()m7("handling")end,function()return true end,true)lY("View Hud Settings",'Hide Hud Settings',md,mc,10,aF/2-(500-mc*2),function()return showHudVariables end,function()m7("hud")end,function()return true end,true)lY("View Physics Settings",'Hide Physics Settings',md,mc,10,aF/2-(500-mc*3),function()return showPhysicsVariables end,function()m7("physics")end,function()return true end,true)end;local function mf()local function jD()local position=bC;local bW=planet.name..". "..#SavedLocations;if radar_1 then local dC,_=radar_1.getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dC~=nil and dC~=""then bW=bW.." "..radar_1.getConstructName(dC)end end;return b3.AddNewLocation(bW,position,false,true)end;local function mg()TurnBurn=not TurnBurn end;local function mh(mi)if mi==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;Y=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function mj()mh(1)end;local function mk()b3.UpdatePosition()end;local function jC()b3.ClearCurrentPosition()end;local function ml()local bW=AutopilotTargetName;if bW==nil then local ik=cz((bC-CustomTarget.position):len())bW=CustomTarget.name.." "..ik end;if bW==nil then bW="None"end;return"Engage Autopilot: "..bW end;local function mm()local bW=AutopilotTargetName;if bW==nil then bW=CustomTarget.name end;if bW==nil then bW="None"end;return"Disable Autopilot: "..bW end;local function mn()if safeMass>0 then a0="Safe Mass set to "..y(at,2).." kg"else a0="Intruder Detection reset\nSafe Mass set to "..y(at,2).." kg"ag=5;bD=0 end;safeMass=at end;local function mo()if l()==1 then Y=not Y;if Y then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()q:setTargetGroundAltitude(TargetHoverHeight)c9("folOn","F")else c9("folOff","F")BrakeIsOn=true;b8=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()q:setTargetGroundAltitude(LandingGearGroundHeight)end end else a0="Follow Mode only works with Remote controller"Y=false end end;local mc=50;local md=260;local mp=lY("Enable Brake Toggle","Disable Brake Toggle",md,mc,aE/2-md/2,aF/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a0="Brakes in Toggle Mode"else a0="Brakes in Default Mode"end end)lY("Align Prograde","Disable Prograde",md,mc,aE/2-md/2-50-mp.width,aF/2-mc+380,function()return ProgradeIsOn end,mj)lY("Align Retrograde","Disable Retrograde",md,mc,aE/2-md/2+mp.width+50,aF/2-mc+380,function()return RetrogradeIsOn end,mh,function()return ap==0 end)local mq=lY(ml,mm,600,60,aE/2-600/2,aF/2-60/2-400,function()return Autopilot end,cF)lY("Save Position","Save Position",200,mq.height,mq.x+mq.width+30,mq.y,function()return false end,jD,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)lY("Update Position","Update Position",200,mq.height,mq.x+mq.width+30,mq.y,function()return false end,mk,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)lY("Clear Position","Clear Position",200,mq.height,mq.x-200-30,mq.y,function()return true end,jC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)mc=60;md=300;local cn=10;local co=aF/2-500;lY("Show Help","Hide Help",md,mc,cn,co,function()return showHelp end,function()showHelp=not showHelp end)co=co+mc+20;lY("View Settings","View Settings",md,mc,cn,co,function()return true end,m9)local co=aF/2-300;lY("Enable Turn and Burn","Disable Turn and Burn",md,mc,cn,co,function()return TurnBurn end,mg)lY("Horizontal Takeoff Mode","Vertical Takeoff Mode",md,mc,cn+md+20,co,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a0="Vertical Takeoff Mode"else a0="Horizontal Takeoff Mode"end end,function()return bE end)co=co+mc+20;lY("Show Orbit Display","Hide Orbit Display",md,mc,cn,co,function()return DisplayOrbit end,function()DisplayOrbit=not DisplayOrbit;if DisplayOrbit then a0="Orbit Display Enabled"else a0="Orbit Display Disabled"end end)lY("Engage Orbiting","Cancel Orbiting",md,mc,cn+md+20,co,function()return IntoOrbit end,cD,function()return ap==0 and bT end)co=co+mc+20;lY("Glide Re-Entry","Cancel Glide Re-Entry",md,mc,cn,co,function()return Reentry end,function()aj=true;mj()end,function()return planet.hasAtmosphere and not ao end)lY("Parachute Re-Entry","Cancel Parachute Re-Entry",md,mc,cn+md+20,co,function()return Reentry end,cI,function()return planet.hasAtmosphere and not ao end)co=co+mc+20;lY("Engage Follow Mode","Disable Follow Mode",md,mc,cn,co,function()return Y end,mo,function()return l()==1 end)lY("Enable Repair Arrows","Disable Repair Arrows",md,mc,cn+md+20,co,function()return aK end,function()aK=not aK;if aK then a0="Repair Arrows Enabled"else a0="Repair Arrows Diabled"end end,function()return l()==1 end)co=co+mc+20;if not ExternalAGG then lY("Enable AGG","Disable AGG",md,mc,cn,co,function()return bF end,cJ,function()return antigrav~=nil end)end;lY("Reset Intruder Alert","Set Safe Mass",md,mc,cn+md+20,co,function()return safeMass>0 end,mn,function()return IntruderAlertSystem end)co=co+mc+20;lY(function()return e("Switch IPH Mode - Current: %s",iphCondition)end,function()return e("IPH Mode: %s",iphCondition)end,md*2,mc,cn,co,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a0="IPH Mode: "..iphCondition end)co=co+mc+20;lY(function()return e("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return e("Control Scheme: %s",userControlScheme)end,md*2,mc,cn,co,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a0="New Control Scheme: "..userControlScheme end)end;SetupComplete=false;beginSetup=coroutine.create(function()Logs=Logger()_logCompute=Logs.CreateLog("Computation","time")q:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})lH()coroutine.yield()lL()coroutine.yield()b4=jJ()lX()mb()mf()aD=lE;coroutine.yield()aU=cU()aY=cV()aZ=aY(cU())a_=eh()b1=eM()b5=f9()b2=gj()b3=jq()coroutine.yield()unit.hide()system.showScreen(1)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)c9("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ap>0 or ap==0 and aq<10000)then for _,bY in pairs(door)do bY.toggle()end end;if switch then for _,bY in pairs(switch)do bY.toggle()end end;if forcefield and(ap>0 or ap==0 and aq<10000)then for _,bY in pairs(forcefield)do bY.toggle()end end;safeMass=at;cP()if button then button.activate()end;if SetWaypointOnExit then b4.showWayPoint(planet,bC)end;c9("stop","SU")for _,d1 in pairs(Logs.getLogs())do system.print(d1)end end;function script.onTick(mr)local ms=nil;if mr=="contact"then if not contactTimer then contactTimer=0 end;if B>contactTimer+10 then a0="Radar Contact"c9("rdrCon","RC")contactTimer=B end;unit.stopTimer("contact")elseif mr=="tenthSecond"then local function mt()local mu=system.createData;local mv=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=mv(panelInterplanetary,"value")interplanetaryHeaderText=mu('{"label": "Target Planet", "value": "N/A", "unit":""}')t(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=mv(panelInterplanetary,"value")widgetDistanceText=mu('{"label": "distance", "value": "N/A", "unit":""}')t(widgetDistanceText,widgetDistance)widgetTravelTime=mv(panelInterplanetary,"value")widgetTravelTimeText=mu('{"label": "Travel Time", "value": "N/A", "unit":""}')t(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=mv(panelInterplanetary,"value")widgetMaxMassText=mu('{"label": "Maximum Mass", "value": "N/A", "unit":""}')t(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=mv(panelInterplanetary,"value")widgetTargetOrbitText=mu('{"label": "Target Altitude", "value": "N/A", "unit":""}')t(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=mv(panelInterplanetary,"value")widgetCurBrakeDistanceText=mu('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=mv(panelInterplanetary,"value")widgetCurBrakeTimeText=mu('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=mv(panelInterplanetary,"value")widgetMaxBrakeDistanceText=mu('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=mv(panelInterplanetary,"value")widgetMaxBrakeTimeText=mu('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=mv(panelInterplanetary,"value")widgetTrajectoryAltitudeText=mu('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ao then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)t(widgetCurBrakeTimeText,widgetCurBrakeTime)t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function mw()r(panelInterplanetary)panelInterplanetary=nil end;local function mx()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(aa.center-bC):len()else AutopilotDistance=(CustomTarget.position-bC):len()end end;local eK=bz;local kW=unit.getThrottle()/100;if AtmoSpeedAssist then kW=I end;local my,mz=a_.computeDistanceAndTime(bz,MaxGameVelocity,at,a:maxForceForward()*kW,warmup,0)local a6,a7;if not TurnBurn then a6,a7=b4.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=b4.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,mA;if not TurnBurn and eK>0 then _,mA=b4.GetAutopilotBrakeDistanceAndTime(eK)else _,mA=b4.GetAutopilotTBBrakeDistanceAndTime(eK)end;local mB=0;local mC=0;if AutopilotCruising or not Autopilot and eK>5 then mC=a_.computeTravelTime(eK,0,AutopilotDistance)elseif a6+my<AutopilotDistance then mB=AutopilotDistance-(a6+my)mC=a_.computeTravelTime(8333.0556,0,mB)else local mD=(AutopilotDistance-a6)/my;my=AutopilotDistance-a6;mz=mz*mD end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mC elseif AutopilotBraking then return mA elseif AutopilotCruising then return mC+mA else return mz+a7+mC end end;local function mE(ja,mF)if ja==nil then ja=core.g()end;ja=y(ja,5)if mF~=nil and mF or(ms==nil or ms~=ja)then local eK=by:len()local mG=f(unit.getData()).maxBrake;if mG~=nil and mG>0 and ao then mG=mG/p(eK/100,0.1,1)mG=mG/ap;if ap>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+mG)/2 else LastMaxBrakeInAtmo=mG end end end;if mG~=nil and mG>0 then LastMaxBrake=mG end;ms=ja end end;mE(nil,true)if ap>0 and not WasInAtmo then if not bH and AtmoSpeedAssist and(AltitudeHold or Reentry)then cs(1)M=false end end;if bG~=nil then if q:getTargetSpeed(axisCommandId.longitudinal)~=bG then cv(bG,TRUE)else bG=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then mt()end;if AutopilotTargetName~=nil then local mH=CustomTarget~=nil;local mI=LastMaxBrakeInAtmo/aa:getGravity(aa.center+vec3(0,0,1)*aa.radius):len()s(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=mx()if mH and not Autopilot then ah=(bC-CustomTarget.position):len()else ah=(AutopilotTargetCoords-bC):len()end;if not TurnBurn then a6,a7=b4.GetAutopilotBrakeDistanceAndTime(bz)a8,a9=b4.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a6,a7=b4.GetAutopilotTBBrakeDistanceAndTime(bz)a8,a9=b4.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local ik=cz(ah)s(widgetDistanceText,'{"label": "distance", "value": "'..ik..'"}')s(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cK(travelTime)..'", "unit":""}')ik=cz(a6)s(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..ik..'"}')s(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cK(a7)..'", "unit":""}')ik=cz(a8)s(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..ik..'"}')s(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cK(a9)..'", "unit":""}')s(widgetMaxMassText,'{"label": "Maximum Mass", "value": "'..e("%.2f",mI/1000)..'", "unit":" Tons"}')ik=cz(AutopilotTargetOrbit)s(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..ik..'"}')if ap>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true end;if ap==0 and WasInAtmo then if s(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then t(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if s(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then t(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if s(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then t(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if s(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then t(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if s(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then t(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else mw()end;if warpdrive~=nil then if f(warpdrive.getData()).destination~="Unknown"and f(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end elseif mr=="oneSecond"then local function mJ(gH)local mK=0;aB=""local mL=aJ;local mM=0;local mN=0;local mO=0;local gV=0;local gW=""local mP=core.getElementHitPointsById;for cT in pairs(ar)do local lU=0;local mQ=0;mQ=h(ar[cT])lU=mP(ar[cT])mM=mM+lU;if lU<mQ then if lU==0 then mO=mO+1 else mN=mN+1 end;if aK and#ay==0 then position=vec3(core.getElementPositionById(ar[cT]))local cn=position.x-D;local co=position.y-D;local fE=position.z-D;table.insert(ay,core.spawnArrowSticker(cn,co,fE+1,"down"))table.insert(ay,core.spawnArrowSticker(cn,co,fE+1,"down"))core.rotateSticker(ay[2],0,0,90)table.insert(ay,core.spawnArrowSticker(cn+1,co,fE,"north"))table.insert(ay,core.spawnArrowSticker(cn+1,co,fE,"north"))core.rotateSticker(ay[4],90,90,0)table.insert(ay,core.spawnArrowSticker(cn-1,co,fE,"south"))table.insert(ay,core.spawnArrowSticker(cn-1,co,fE,"south"))core.rotateSticker(ay[6],90,-90,0)table.insert(ay,core.spawnArrowSticker(cn,co-1,fE,"east"))table.insert(ay,core.spawnArrowSticker(cn,co-1,fE,"east"))core.rotateSticker(ay[8],90,0,90)table.insert(ay,core.spawnArrowSticker(cn,co+1,fE,"west"))table.insert(ay,core.spawnArrowSticker(cn,co+1,fE,"west"))core.rotateSticker(ay[10],-90,0,90)table.insert(ay,ar[cT])end elseif aK and#ay>0 and ay[11]==ar[cT]then for gQ in pairs(ay)do core.deleteSticker(ay[gQ])end;ay={}end end;mK=d(mM/mL*100)if mK<100 then gH[#gH+1]=cm(0,0,"","pbright txt")gV=d(mK*2.55)gW=e("rgb(%d,%d,%d)",255-gV,gV,0)if mK<100 then gH[#gH+1]=cm("50%",1035,"Elemental Integrity: "..mK.."%","txtbig txtmid","fill:"..gW)if mO>0 then gH[#gH+1]=cm("50%",1055,"Disabled Modules: "..mO.." Damaged Modules: "..mN,"txtbig txtmid","fill:"..gW)elseif mN>0 then gH[#gH+1]=cm("50%",1055,"Damaged Modules: "..mN,"txtbig txtmid","fill:"..gW)end end end end;local function mR()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then r(WeaponPanelID)WeaponPanelID=nil end end end;local function mS()local gT=o()local i7=bz;local mT=gT-as;if i7>1.38889 then i7=i7/1000;local mU=i7*(gT-as)TotalDistanceTravelled=TotalDistanceTravelled+mU;ab=ab+mU end;ac=ac+mT;TotalFlightTime=TotalFlightTime+mT;as=gT end;local function mV()if safeMass>0 then if at>safeMass+50 then bD=d(at-safeMass)safeMass=-1 elseif at<safeMass then safeMass=at end elseif safeMass==-1 then safeMass=-2 else safeMass=-1 end end;if IntruderAlertSystem then mV()end;mS()b2.UpdatePipe()mR()local gH={}b2.ExtraData(gH)if ShowOdometer then gH=b2.DrawOdometer(gH,ab,TotalDistanceTravelled,ac)end;if ShouldCheckDamage then mJ(gH)end;ai=table.concat(gH,"")collectgarbage("collect")elseif mr=="fiveSecond"then if not UseSatNav then return end;an=dbHud_1.getStringValue("SPBAutopilotTargetName")if an~=nil and an~=""and an~="SatNavNotChanged"then local d8=f(dbHud_1.getStringValue("SavedLocations"))if d8~=nil then _G["SavedLocations"]=d8;local fX=-1;local jG;for cT,bY in pairs(SavedLocations)do if bY.name and bY.name=="SatNav Location"then fX=cT;break end end;if fX~=-1 then jG=SavedLocations[fX]fX=-1;for cT,bY in pairs(aU[0])do if bY.name and bY.name=="SatNav Location"then fX=cT;break end end;if fX>-1 then aU[0][fX]=jG end;b3.UpdateAtlasLocationsList()a0=jG.name.." position updated"end end;for i=1,#bN do if bN[i].name==an then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bN[i].name)b3.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif mr=="msgTick"then local gH={}b2.DisplayMessage(gH,"empty")a0="empty"unit.stopTimer("msgTick")ag=3 elseif mr=="animateTick"then b7=true;b6=false;ae=0;af=0;unit.stopTimer("animateTick")elseif mr=="hudTick"then local function mW(gH)local mX=d(p(ah/(aE/4)*255,0,255))gH[#gH+1]=e("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ae,af,d(F+0.5)+mX,d(H+0.5)-mX,d(G+0.5)-mX)end;local function mY()for _,bY in pairs(aD)do if bY.hovered then if not bY.drawCondition or bY.drawCondition()then bY.toggleFunction()end;bY.hovered=false end end end;local function mZ()local function m_(n0,n1,cn,co,m0,m1)if n0>cn and n0<cn+m0 and n1>co and n1<co+m1 then return true else return false end end;local cn=ae+aE/2;local co=af+aF/2;for _,bY in pairs(aD)do bY.hovered=m_(cn,co,bY.x,bY.y,bY.width,bY.height)end end;local function n2(gH)local function n3(gH,n4,hover,cn,co,eD,n5,n6,n7,n8,n9)if type(n8)=="function"then n8=n8()end;if type(n9)=="function"then n9=n9()end;gH[#gH+1]=e("<rect x='%f' y='%f' width='%f' height='%f' fill='",cn,co,eD,n5)if n4 then gH[#gH+1]=e("%s'",n6)else gH[#gH+1]=n7 end;if hover then gH[#gH+1]=" style='stroke:white; stroke-width:2'"else gH[#gH+1]=" style='stroke:black; stroke-width:1'"end;gH[#gH+1]="></rect>"gH[#gH+1]=e("<text x='%f' y='%f' font-size='24' fill='",cn+eD/2,co+n5/2+5)if n4 then gH[#gH+1]="black"else gH[#gH+1]="white"end;gH[#gH+1]="' text-anchor='middle' font-family='Montserrat'>"if n4 then gH[#gH+1]=e("%s</text>",n8)else gH[#gH+1]=e("%s</text>",n9)end end;local na="rgb(50,50,50)'"local nb="rgb(210,200,200)"local nc=n3;for _,bY in pairs(aD)do local l_=bY.disableName;local lZ=bY.enableName;if type(l_)=="function"then l_=l_()end;if type(lZ)=="function"then lZ=lZ()end;if not bY.drawCondition or bY.drawCondition()then nc(gH,bY.toggleVar(),bY.hovered,bY.x,bY.y,bY.width,bY.height,nb,na,l_,lZ)end end end;local nd=y(ResolutionX/2,0)local ne=y(ResolutionY/2,0)local gH={}local nf=system.getTime()b2.HUDPrologue(gH)if showHud then local nf=system.getTime()b2.UpdateHud(gH)_logCompute.addValue(system.getTime()-nf)else if AlwaysVSpd then b2.DrawVerticalSpeed(gH,aq)end;b2.DisplayOrbitScreen(gH)b2.DrawWarnings(gH)end;if bK and bL~={}then b2.DrawSettings(gH)end;b2.DrawRadarInfo()b2.HUDEpilogue(gH)gH[#gH+1]=e([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aE,aF)if a0~="empty"then b2.DisplayMessage(gH,a0)end;if l()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then b2.DrawDeadZone(gH)end end;if v()==0 then if l()==1 and Z then if not AltIsOn then mZ()n2(gH)end;if not b6 and not b7 then local ng=table.concat(gH,"")gH={}gH[#gH+1]=e("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aE,aF)gH[#gH+1]=ng;gH[#gH+1]="</body>"b6=true;gH[#gH+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(gH,"")system.setScreen(content)elseif b7 then local ng=table.concat(gH,"")gH={}gH[#gH+1]=e("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aE,aF)gH[#gH+1]=ng;gH[#gH+1]="</body>"end;if not b6 then gH[#gH+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nd,ne,ae,af)end else mY()end else if not Z and l()==0 then mY()if ah>DeadZone then if DisplayDeadZone then mW(gH)end end elseif not AltIsOn or AltIsOn and Z then mZ()n2(gH)end;gH[#gH+1]=e([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],nd,ne,ae,af)end;gH[#gH+1]=[[</svg></body>]]content=table.concat(gH,"")elseif mr=="apTick"then b4.APTick()elseif mr=="radarTick"then b5.UpdateRadar()end end;function script.onFlush()local function nh(ni,l2)local nj=vec3()local nk=vec3()if ni==axisCommandId.longitudinal then nj=vec3(core.getConstructOrientationForward())nk=bw elseif ni==axisCommandId.vertical then nj=vec3(core.getConstructOrientationUp())nk=bv elseif ni==axisCommandId.lateral then nj=vec3(core.getConstructOrientationRight())nk=bx else return vec3()end;local nl=vec3(core.getWorldGravity())local nm=nl:dot(nk)local nn=vec3(core.getWorldAirFrictionAcceleration())local no=nn:dot(nk)local np=by;local nq=np:dot(nj)local nr=l2*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(nr-nq)local ns=targetSpeedPID2:get()local nt=(ns-no-nm)*nk;return nt end;local function nu(ni,l2)local nj=vec3()local nk=vec3()if ni==axisCommandId.longitudinal then nj=vec3(core.getConstructOrientationForward())nk=bw elseif ni==axisCommandId.vertical then nj=vec3(core.getConstructOrientationUp())nk=bv elseif ni==axisCommandId.lateral then nj=vec3(core.getConstructOrientationRight())nk=bx else return vec3()end;local nl=vec3(core.getWorldGravity())local nm=nl:dot(nk)local nn=vec3(core.getWorldAirFrictionAcceleration())local no=nn:dot(nk)local np=by;local nq=np:dot(nj)local nr=l2*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(nr-nq)local ns=targetSpeedPID:get()local nt=(ns-no-nm)*nk;return nt end;local function nw(nx,g_,jv)local ny=nx:cross(jv):normalize_inplace()local hM=math.acos(p(ny:dot(-g_),-1,1))*constants.rad2deg;if ny:cross(-g_):dot(jv)<0 then hM=-hM end;return hM end;if antigrav and not ExternalAGG then if not bF and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bH=q:getAxisCommandType(0)==axisCommandType.byThrottle;if bH and M then cs(0)M=false elseif not bH and not M then I=0;M=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)turnAssistFactor=math.max(turnAssistFactor,0.01)local nz=p(R+S+system.getControlDeviceForwardInput(),-1,1)local nA=p(U+X+system.getControlDeviceYawInput(),-1,1)local nB=p(V+T-system.getControlDeviceLeftRightInput(),-1,1)local nC=W;bA=vec3(core.getWorldVertical())if bA==nil or bA:len()==0 then bA=(planet.center-bC):normalize()end;bv=vec3(core.getConstructWorldOrientationUp())bw=vec3(core.getConstructWorldOrientationForward())bx=vec3(core.getConstructWorldOrientationRight())by=vec3(core.getWorldVelocity())bC=vec3(core.getConstructWorldPos())at=core.getConstructMass()bz=vec3(by):len()bB=-bA:dot(by)bJ=getRoll(bA,bw,bx)local nD=bJ/180*math.pi;local nE=math.cos(nD)local nF=math.sin(nD)bI=nw(bA,bw,bx*nE+bv*nF)local nG=by:normalize()local nH=c(bJ)local nI=utils.sign(bJ)local nJ=vec3(core.getWorldAngularVelocity())local nK=nz*pitchSpeedFactor*bx+nA*rollSpeedFactor*bw+nB*yawSpeedFactor*bv;if b8==true and bA:len()>0.01 then local nL=c(bc-bJ)if((ProgradeIsOn or Reentry or BrakeLanding or aj or AltitudeHold or IntoOrbit)and nL>0 or ap>0.0 and nL<autoRollRollThreshold and autoRollPreference)and nA==0 and c(bI)<85 then local nM=bc;local nN=autoRollFactor;if ap==0 then nN=nN/4;bc=0;nM=0 end;if rollPID==nil then rollPID=pid.new(nN*0.01,0,nN*0.1)end;rollPID:inject(nM-bJ)local nO=rollPID:get()nK=nK+nO*bw end end;if bA:len()>0.01 and ap>0.0 then local nP=20.0;if turnAssist==true and nH>nP and nz==0 and nB==0 then local nQ=turnAssistFactor*0.1;local nR=turnAssistFactor*0.025;local nS=(nH-nP)/(180-nP)*180;local nT=0;if nS<90 then nT=nS/90 elseif nS<180 then nT=(180-nS)/90 end;nT=nT*nT;local nU=-nI*nR*(1.0-nT)local nV=nQ*nT;nK=nK+nV*bx+nU*bv end end;local nW=1;local nX=0;local nY=1;if system.getMouseWheel()>0 then if AltIsOn then if ap>0 or Reentry then bf=p(bf+speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity+speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nZ=I;I=y(p(I+speedChangeLarge/100,-1,1),2)if I>=0 and nZ<0 then I=0;au=false end end elseif system.getMouseWheel()<0 then if AltIsOn then if ap>0 or Reentry then bf=p(bf-speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=p(MaxGameVelocity-speedChangeLarge/3.6*100,0,8333.00)end elseif au then local nZ=I;I=y(p(I-speedChangeLarge/100,-1,1),2)if I<=0 and nZ>0 then I=0;au=false end end else au=true end;J=0;if ao and AtmoSpeedAssist and bH then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(bf/3.6-by:dot(bw))local n_=throttlePID:get()L=p(n_,-1,1)if L<I and ap>0.005 then K=true;q:setThrottleCommand(axisCommandId.longitudinal,p(L,0.01,1))else K=false;q:setThrottleCommand(axisCommandId.longitudinal,I)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(by:len()-bf/3.6)local o0=p(brakePID:get(),0,1)if ap>0 and bB<-80 or ap>0.005 then J=o0 end;if J>0 then if K and L==0.01 then q:setThrottleCommand(axisCommandId.longitudinal,0)end else L=p(L,0.01,1)end;local o1=''local o2=vec3()local o3=nh(axisCommandId.vertical,ad*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",o3,nX)local o4='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o4=o4 ..ExtraLongitudeTags end;local o5=q:getAxisCommandType(axisCommandId.longitudinal)local o6=q:composeAxisAccelerationFromThrottle(o4,axisCommandId.longitudinal)local o7=nu(axisCommandId.lateral,LeftAmount*1000)o1=o1 ..' , '.."lateral airfoil , lateral ground "o2=o2+o7;if o2:len()>constants.epsilon then a:setEngineForceCommand(o1,o2,nX,'','','',nY)end;a:setEngineForceCommand(o4,o6,nW)local o8='thrust analog vertical fueled 'local o9='thrust analog lateral fueled 'if ExtraLateralTags~="none"then o9=o9 ..ExtraLateralTags end;if ExtraVerticalTags~="none"then o8=o8 ..ExtraVerticalTags end;if ad~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(o8,o3,nW)else a:setEngineForceCommand(o8,vec3(),nW)end;if LeftAmount~=0 then a:setEngineForceCommand(o9,o7,nW)else a:setEngineForceCommand(o9,vec3(),nW)end;if nC==0 then nC=J end;local oa=-nC*(brakeSpeedFactor*by+brakeFlatFactor*nG)a:setEngineForceCommand('brake',oa)else if AtmoSpeedAssist then q:setThrottleCommand(axisCommandId.longitudinal,I)end;local l2=unit.getAxisCommandValue(0)if not bH then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(by:len()-l2/3.6)local o0=p(brakePID:get(),0,1)nC=p(nC+o0,0,1)end;local oa=-nC*(brakeSpeedFactor*by+brakeFlatFactor*nG)a:setEngineForceCommand('brake',oa)local o1=''local o2=vec3()local ob=false;local o4='thrust analog longitudinal 'if ExtraLongitudeTags~="none"then o4=o4 ..ExtraLongitudeTags end;local o5=q:getAxisCommandType(axisCommandId.longitudinal)if o5==axisCommandType.byThrottle then local o6=q:composeAxisAccelerationFromThrottle(o4,axisCommandId.longitudinal)a:setEngineForceCommand(o4,o6,nW)elseif o5==axisCommandType.byTargetSpeed then local o6=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)o1=o1 ..' , '..o4;o2=o2+o6;if q:getTargetSpeed(axisCommandId.longitudinal)==0 or q:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-q:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ob=true end end;local o9='thrust analog lateral 'if ExtraLateralTags~="none"then o9=o9 ..ExtraLateralTags end;local oc=q:getAxisCommandType(axisCommandId.lateral)if oc==axisCommandType.byThrottle then local od=q:composeAxisAccelerationFromThrottle(o9,axisCommandId.lateral)a:setEngineForceCommand(o9,od,nW)elseif oc==axisCommandType.byTargetSpeed then local o7=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)o1=o1 ..' , '..o9;o2=o2+o7 end;local o8='thrust analog vertical 'if ExtraVerticalTags~="none"then o8=o8 ..ExtraVerticalTags end;local oe=q:getAxisCommandType(axisCommandId.vertical)if oe==axisCommandType.byThrottle then local o3=q:composeAxisAccelerationFromThrottle(o8,axisCommandId.vertical)if ad~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(o8,o3,nW,'airfoil','ground','',nY)else a:setEngineForceCommand(o8,vec3(),nW)a:setEngineForceCommand('airfoil vertical',o3,nW,'airfoil','','',nY)a:setEngineForceCommand('ground vertical',o3,nW,'ground','','',nY)end elseif oe==axisCommandType.byTargetSpeed then if ad<0 then a:setEngineForceCommand('hover',vec3(),nW)end;local of=q:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)o1=o1 ..' , '..o8;o2=o2+of end;if o2:len()>constants.epsilon then if W~=0 or ob or c(nG:dot(bw))<0.8 then o1=o1 ..', brake'end;a:setEngineForceCommand(o1,o2,nX,'','','',nY)end end;local og=torqueFactor*(nK-nJ)local oh=vec3(core.getWorldAirFrictionAngularAcceleration())og=og-oh;a:setEngineTorqueCommand('torque',og,nW,'airfoil','','',nY)a:setBoosterCommand('rocket_engine')if a5 and not VanillaRockets then local eK=core:len()local oi=0.15;if not bH then local oj=q:getTargetSpeed(axisCommandId.longitudinal)if eK*3.6>oj*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eK*3.6<oj*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local kW=unit.getThrottle()if AtmoSpeedAssist then kW=I*100 end;local l2=kW/100;if j==0 then l2=l2*MaxGameVelocity;if eK>=l2*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eK<l2*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local ld=d(bf)l2=l2*ld/3.6;if eK>=l2*(1-oi)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eK<l2*(1-oi)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gh=coroutine.status(beginSetup)if gh=="suspended"then local ct,gi=coroutine.resume(beginSetup)if gi then system.print("ERROR STARTUP: "..gi)end elseif gh=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not b6 and content~=LastContent then if not Cockpit then system.setScreen(content)else dbHud_1.setStringValue("content",content)end end;LastContent=content end end;function script.onActionStart(ok)local mult=1;local function ol(om)local function on(oo,om)local op={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-50,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local oq=oo;for _,bY in ipairs(op)do if om and oq>bY then oo=bY elseif oo<bY and not om then oo=bY;break end end;return oo end;if om then mult=-1 end;if not ExternalAGG and bF then if Z and om then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a2;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+mult*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if Z then bo=on(bo,om)else bo=bo+mult*a1 end;if bo<planet.noAtmosphericDensityAltitude then bo=planet.noAtmosphericDensityAltitude end else if Z and ao then HoldAltitude=on(HoldAltitude,om)else HoldAltitude=HoldAltitude+mult*a1 end end else q:updateTargetGroundAltitudeFromActionStart(mult*1.0)end end;local function os(om)if om then mult=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then I=p(I+mult*speedChangeLarge/100,-1,1)else q:updateCommandFromActionStart(axisCommandId.longitudinal,mult*speedChangeLarge)end else if om then mult=1 else mult=nil end;b3.adjustAutopilotTargetIndex(mult)end end;local function ot(ou)if not ao then a0="Flight Assist in Atmo only"return end;local c_=type(ou)if bR==nil then if c_=="table"then if Autopilot or VectorToTarget then cF()end;c9("180On","BR")elseif ou==1 then c9("bnkLft","BR")else c9("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cE()if c_~="table"then ou=ou+1 end end;bR=ou else c9("180Off","BR")bR=nil end end;if ok=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cs(0)if vBooster or hover then if ao and am==-1 then c9("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b8=true;GearExtended=false else if Q then c9("grOut","LG",1)a.control.extendLandingGears()end;q:setTargetGroundAltitude(LandingGearGroundHeight)if ao then BrakeIsOn=true end end end;if Q and not BrakeLanding and not(vBooster or hover)then c9("grOut","LG",1)a.control.extendLandingGears()end else if Q then c9("grIn","LG",1)a.control.retractLandingGears()end;q:setTargetGroundAltitude(TargetHoverHeight)end elseif ok=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif ok=="forward"then R=R-1 elseif ok=="backward"then if AltIsOn then ot(-by*5000)else R=R+1 end elseif ok=="left"then if AltIsOn then ot(1)else U=U-1 end elseif ok=="right"then if AltIsOn then ot(3)else U=U+1 end elseif ok=="yawright"then V=V-1 elseif ok=="yawleft"then V=V+1 elseif ok=="straferight"then q:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ok=="strafeleft"then q:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ok=="up"then ad=ad+1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif ok=="down"then ad=ad-1;q:deactivateGroundEngineAltitudeStabilization()q:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif ok=="groundaltitudeup"then ol()elseif ok=="groundaltitudedown"then ol(true)elseif ok=="option1"then b3.adjustAutopilotTargetIndex()toggleView=false elseif ok=="option2"then b3.adjustAutopilotTargetIndex(1)toggleView=false elseif ok=="option3"then local function ov()aC=not aC;if not aC then c9("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end else c9("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then r(fuelPanelID)fuelPanelID=nil end;if spacefuelPanelID~=nil then r(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then r(rocketfuelPanelID)rocketfuelPanelID=nil end end end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;ov()toggleView=false elseif ok=="option4"then bR=nil;cF()toggleView=false elseif ok=="option5"then function ToggleLockPitch()if LockPitch==nil then c9("lkPOn","LP")if not Z then LockPitch=bI else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c9("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()toggleView=false elseif ok=="option6"then cE()toggleView=false elseif ok=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a0="Collision System Enabled"else a0="Collision System Secured"end;toggleView=false elseif ok=="option8"then stablized=not stablized;if not stablized then a0="DeCoupled Mode - Ground Stabilization off"q:deactivateGroundEngineAltitudeStabilization()c9("gsOff","GS")else a0="Coupled Mode - Ground Stabilization on"q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c9("gsOn","GS")end;toggleView=false elseif ok=="option9"then if gyro~=nil then gyro.toggle()av=gyro.getState()==1;if av then c9("gyOn","GA")else c9("gyOff","GA")end end;toggleView=false elseif ok=="lshift"then if AltIsOn then Z=true end;if v()==1 then Z=true;PrevViewLock=v()u(1)elseif l()==1 and ShiftShowsRemoteButtons then Z=true;b7=false;b6=false end elseif ok=="brake"then if BrakeToggleStatus then cH()elseif not BrakeIsOn then cH()else BrakeIsOn=true end elseif ok=="lalt"then toggleView=true;AltIsOn=true;if l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(1)end elseif ok=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a5 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a5=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a5=false end elseif ok=="stopengines"then local function ow()if B-C<1.5 then c9("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bR=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;Y=false;N=false;aj=false;ak=false;P=false;b8=autoRollPreference;VectorToTarget=false;TurnBurn=false;av=false;LockPitch=nil;IntoOrbit=false end end;ow()C=B;if q:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if I~=0 then q:resetCommand(axisCommandId.longitudinal)cs(0)else cs(100)end else if q:getTargetSpeed(axisCommandId.longitudinal)~=0 then q:resetCommand(axisCommandId.longitudinal)else if ao then cv(AtmoSpeedLimit)else cv(MaxGameVelocity*3.6)end end end elseif ok=="speedup"then os()elseif ok=="speeddown"then os(true)elseif ok=="antigravity"and not ExternalAGG then if antigrav~=nil then cJ()end end end;function script.onActionStop(ok)local function ox()if not ExternalAGG and bF then a4=a2 end;if AltitudeHold or VertTakeOff or IntoOrbit then a3=a1 end end;if ok=="forward"then R=0 elseif ok=="backward"then R=0 elseif ok=="left"then if bR then if bR==2 then bR=-2 else bR=-1 end end;U=0 elseif ok=="right"then if bR then if bR==4 then bR=-2 else bR=-1 end end;U=0 elseif ok=="yawright"then V=0 elseif ok=="yawleft"then V=0 elseif ok=="straferight"then q:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ok=="strafeleft"then q:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ok=="up"then ad=0;q:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ok=="down"then ad=0;q:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then q:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif ok=="groundaltitudeup"then ox()toggleView=false elseif ok=="groundaltitudedown"then ox()toggleView=false elseif ok=="lshift"then if v()==1 then ae=0;af=0;u(PrevViewLock)elseif l()==1 and ShiftShowsRemoteButtons then b7=false;b6=false end;Z=false elseif ok=="brake"then if not BrakeToggleStatus then if BrakeIsOn then cH()else BrakeIsOn=false end end elseif ok=="lalt"then if l()==0 and freeLookToggle then if toggleView then if v()==1 then u(0)else u(1)end else toggleView=true end elseif l()==0 and not freeLookToggle and userControlScheme=="keyboard"then u(0)end;AltIsOn=false end end;function script.onActionLoop(ok)local function oy(om)local mult=1;if om then mult=-1 end;if not ExternalAGG and bF then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+mult*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a4=p(a4*1.05,a2,500)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+mult*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bo=bo+mult*a3;if bo<planet.noAtmosphericDensityAltitude then bo=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+mult*a3 end;a3=p(a3*1.05,a1,500)else q:updateTargetGroundAltitudeFromActionLoop(mult*1.0)end end;local function oz(om)if om then mult=-1 end;if not Z then if AtmoSpeedAssist and not AltIsOn then I=p(I+mult*speedChangeSmall/100,-1,1)else q:updateCommandFromActionLoop(axisCommandId.longitudinal,mult*speedChangeSmall)end end end;if ok=="groundaltitudeup"then if not Z then oy()end elseif ok=="groundaltitudedown"then if not Z then oy(true)end elseif ok=="speedup"then oz()elseif ok=="speeddown"then oz(true)end end;function script.onInputText(cp)local function oA()for cT,bY in pairs(cf())do dbHud_1.setStringValue(bY,g(nil))end;for cT,bY in pairs(b)do if bY~="SavedLocations"then dbHud_1.setStringValue(bY,g(nil))end end;a0="Databank wiped except Save Locations. New variables will save after re-enter seat and exit"ag=5 end;local function oB(oC,eO,hI)local function oD(eO)local z=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d6='::pos{'..z..','..z..','..z..','..z..','..z..'}'local dj,dk,ds,dt,du=n(eO,d6)if dj=="0"and dk=="0"then return vec3(x(ds),x(dt),x(du))end;dt=math.rad(dt)ds=math.rad(ds)local planet=aU[x(dj)][x(dk)]local ee=math.cos(ds)local oE=vec3(ee*math.cos(dt),ee*math.sin(dt),math.sin(ds))return planet.center+(planet.radius+du)*oE end;local position=oD(eO)return b3.AddNewLocation(oC,position,hI)end;local i;local oF,oG=nil,nil;local oH="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat"i=string.find(cp," ")oF=cp;if i~=nil then oF=string.sub(cp,0,i-1)oG=string.sub(cp,i+1)end;if oF=="/help"or oF=="/commands"then for jg in string.gmatch(oH,"([^\n]+)")do system.print(jg)end;return elseif oF=="/setname"then if oG==nil or oG==""then a0="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then b3.UpdatePosition(oG)else a0="Select a saved target to rename first"end elseif oF=="/addlocation"or string.find(cp,"::pos")~=nil then local hI=false;local oC="0-Temp"if oG==nil or oG==""then oG=oF;hI=true end;i=string.find(oG,"::")if not hI then oC=string.sub(oG,1,i-2)end;local eO=string.sub(oG,i)oB(oC,eO,hI)elseif oF=="/agg"then if oG==nil or oG==""then a0="Usage: /agg targetheight"return end;oG=x(oG)if oG<1000 then oG=1000 end;AntigravTargetAltitude=oG;a0="AGG Target Height set to "..oG elseif oF=="/G"then if oG==nil or oG==""then a0="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if oG=="dump"then for cT,bY in pairs(cf())do if type(_G[bY])=="boolean"then if _G[bY]==true then system.print(bY.." true")else system.print(bY.." false")end elseif _G[bY]==nil then system.print(bY.." nil")else system.print(bY.." ".._G[bY])end end;return end;i=string.find(oG," ")local oI=string.sub(oG,0,i-1)local oJ=string.sub(oG,i+1)for cT,bY in pairs(cf())do if bY==oI then a0="Variable "..oI.." changed to "..oJ;local oK=type(_G[bY])if oK=="number"then oJ=x(oJ)elseif oK=="boolean"then if string.lower(oJ)=="true"then oJ=true else oJ=false end end;_G[bY]=oJ;return end end;a0="No such global variable: "..oI elseif oF=="/copydatabank"then if dbHud_2 then cP(true)else a0="Spare Databank required to copy databank"end elseif oF=="/iphWP"then if AutopilotTargetIndex>0 then system.print(b4.showWayPoint(aa,AutopilotTargetCoords,true))a0="::pos waypoint shown in lua chat"else a0="No target selected in IPH"end end end;function script.onEnter(dC)if radar_1 and not ao and not bO then unit.setTimer("contact",0.1)end end;function script.onLeave(dC)if radar_1 and CollisionSystem then if#bS>650 then dC=tostring(dC)bS[dC]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
