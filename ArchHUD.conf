name: ArchHud - Archaegeo v1.7061 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
          Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() package.preload['ArchHUD:Modules/globals']=function(...)a=false;b="virtual joystick"c="archHUD"d=true;e=true;f=false;g=false;h=false;i=false;j=false;k=false;l=false;m=false;n=true;o=false;p=true;q=false;r=true;s=true;t=true;u=true;v=false;w=false;x=true;y=true;z=true;A=true;B=true;C=true;D=true;E={userControlScheme={set=function(F)b=F end,get=function()return b end},soundFolder={set=function(F)c=F end,get=function()return c end},freeLookToggle={set=function(F)d=F end,get=function()return d end},BrakeToggleDefault={set=function(F)e=F end,get=function()return e end},RemoteFreeze={set=function(F)f=F end,get=function()return f end},brightHud={set=function(F)h=F end,get=function()return h end},RemoteHud={set=function(F)g=F end,get=function()return g end},VanillaRockets={set=function(F)i=F end,get=function()return i end},InvertMouse={set=function(F)j=F end,get=function()return j end},autoRollPreference={set=function(F)k=F end,get=function()return k end},ExternalAGG={set=function(F)l=F end,get=function()return l end},UseSatNav={set=function(F)m=F end,get=function()return m end},ShouldCheckDamage={set=function(F)n=F end,get=function()return n end},CalculateBrakeLandingSpeed={set=function(F)o=F end,get=function()return o end},AtmoSpeedAssist={set=function(F)p=F end,get=function()return p end},ForceAlignment={set=function(F)q=F end,get=function()return q end},DisplayDeadZone={set=function(F)r=F end,get=function()return r end},showHud={set=function(F)s=F end,get=function()return s end},hideHudOnToggleWidgets={set=function(F)t=F end,get=function()return t end},ShiftShowsRemoteButtons={set=function(F)u=F end,get=function()return u end},SetWaypointOnExit={set=function(F)v=F end,get=function()return v end},AlwaysVSpd={set=function(F)w=F end,get=function()return w end},BarFuelDisplay={set=function(F)x=F end,get=function()return x end},voices={set=function(F)y=F end,get=function()return y end},alerts={set=function(F)z=F end,get=function()return z end},CollisionSystem={set=function(F)A=F end,get=function()return A end},AutoShieldToggle={set=function(F)B=F end,get=function()return B end},PreventPvP={set=function(F)C=F end,get=function()return C end},DisplayOdometer={set=function(F)D=F end,get=function()return D end}}G=35;H=35;I=30;J=30;K=-30;L=0;M=5000;N=1.2;O=2000;P=1050;Q=30000;R=1000;S=50;T=0;U=100000;V=8333.00;W=1.0;X=32;Y=0;Z=0;_=0;a0=0;a1=0;a2={YawStallAngle={set=function(F)G=F end,get=function()return G end},PitchStallAngle={set=function(F)H=F end,get=function()return H end},brakeLandingRate={set=function(F)I=F end,get=function()return I end},MaxPitch={set=function(F)J=F end,get=function()return J end},ReEntryPitch={set=function(F)K=F end,get=function()return K end},LockPitchTarget={set=function(F)L=F end,get=function()return L end},AutopilotSpaceDistance={set=function(F)M=F end,get=function()return M end},TargetOrbitRadius={set=function(F)N=F end,get=function()return N end},LowOrbitHeight={set=function(F)O=F end,get=function()return O end},AtmoSpeedLimit={set=function(F)P=F end,get=function()return P end},SpaceSpeedLimit={set=function(F)Q=F end,get=function()return Q end},AutoTakeoffAltitude={set=function(F)R=F end,get=function()return R end},TargetHoverHeight={set=function(F)S=F end,get=function()return S end},LandingGearGroundHeight={set=function(F)T=F end,get=function()return T end},ReEntryHeight={set=function(F)U=F end,get=function()return U end},MaxGameVelocity={set=function(F)V=F end,get=function()return V end},AutopilotInterplanetaryThrottle={set=function(F)W=F end,get=function()return W end},warmup={set=function(F)X=F end,get=function()return X end},fuelTankHandlingAtmo={set=function(F)Y=F end,get=function()return Y end},fuelTankHandlingSpace={set=function(F)Z=F end,get=function()return Z end},fuelTankHandlingRocket={set=function(F)_=F end,get=function()return _ end},ContainerOptimization={set=function(F)a0=F end,get=function()return a0 end},FuelTankOptimization={set=function(F)a1=F end,get=function()return a1 end}}a3=1920;a4=1080;a5=400;a6=130;a7=224;a8=255;a9=255;aa=0;ab=0;ac=960;ad=540;ae=1300;af=540;ag=1525;ah=325;ai=550;aj=540;ak=30;al=700;am=1750;an=250;ao=50;ap=250;aq=0;ar=30;as=100;at={ResolutionX={set=function(F)a3=F end,get=function()return a3 end},ResolutionY={set=function(F)a4=F end,get=function()return a4 end},circleRad={set=function(F)a5=F end,get=function()return a5 end},SafeR={set=function(F)a6=F end,get=function()return a6 end},SafeG={set=function(F)a7=F end,get=function()return a7 end},SafeB={set=function(F)a8=F end,get=function()return a8 end},PvPR={set=function(F)a9=F end,get=function()return a9 end},PvPG={set=function(F)aa=F end,get=function()return aa end},PvPB={set=function(F)ab=F end,get=function()return ab end},centerX={set=function(F)ac=F end,get=function()return ac end},centerY={set=function(F)ad=F end,get=function()return ad end},throtPosX={set=function(F)ae=F end,get=function()return ae end},throtPosY={set=function(F)af=F end,get=function()return af end},vSpdMeterX={set=function(F)ag=F end,get=function()return ag end},vSpdMeterY={set=function(F)ah=F end,get=function()return ah end},altMeterX={set=function(F)ai=F end,get=function()return ai end},altMeterY={set=function(F)aj=F end,get=function()return aj end},fuelX={set=function(F)ak=F end,get=function()return ak end},fuelY={set=function(F)al=F end,get=function()return al end},shieldX={set=function(F)am=F end,get=function()return am end},shieldY={set=function(F)an=F end,get=function()return an end},DeadZone={set=function(F)ao=F end,get=function()return ao end},OrbitMapSize={set=function(F)ap=F end,get=function()return ap end},OrbitMapX={set=function(F)aq=F end,get=function()return aq end},OrbitMapY={set=function(F)ar=F end,get=function()return ar end},soundVolume={set=function(F)as=F end,get=function()return as end}}au=5;av=1;aw=0.003;ax=0.003;ay=2;az=1.5;aA=180;aB=150;aC=0.002;aD=2;aE=0.8;aF=1;aG=3;aH=1;aI=40;aJ=0.0166667;aK=0.0666667;aL="none"aM="none"aN="none"aO={speedChangeLarge={set=function(F)au=F end,get=function()return au end},speedChangeSmall={set=function(F)av=F end,get=function()return av end},MouseXSensitivity={set=function(F)aw=F end,get=function()return aw end},MouseYSensitivity={set=function(F)ax=F end,get=function()return ax end},autoRollFactor={set=function(F)ay=F end,get=function()return ay end},rollSpeedFactor={set=function(F)az=F end,get=function()return az end},autoRollRollThreshold={set=function(F)aA=F end,get=function()return aA end},minRollVelocity={set=function(F)aB=F end,get=function()return aB end},TrajectoryAlignmentStrength={set=function(F)aC=F end,get=function()return aC end},torqueFactor={set=function(F)aD=F end,get=function()return aD end},pitchSpeedFactor={set=function(F)aE=F end,get=function()return aE end},yawSpeedFactor={set=function(F)aF=F end,get=function()return aF end},brakeSpeedFactor={set=function(F)aG=F end,get=function()return aG end},brakeFlatFactor={set=function(F)aH=F end,get=function()return aH end},DampingMultiplier={set=function(F)aI=F end,get=function()return aI end},apTickRate={set=function(F)aJ=F end,get=function()return aJ end},hudTickRate={set=function(F)aK=F end,get=function()return aK end},ExtraLongitudeTags={set=function(F)aL=F end,get=function()return aL end},ExtraLateralTags={set=function(F)aM=F end,get=function()return aM end},ExtraVerticalTags={set=function(F)aN=F end,get=function()return aN end}}aP=e;aQ=false;aR=false;aS=false;aT=false;aU=false;aV=false;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=1000;b1=false;b2=false;b3=false;b4=false;b5=0;b6="Aligning"b7=0;b8=1;b9="None"ba=nil;bb=0;bc=nil;bd=0.0;be=0;bf={}bg=false;bh=0;bi=0;bj=nil;bk=0;bl=1000;bm=0;bn=false;bo=0;bp=false;bq="All"br=true;bs="Off"bt=0.000;bu={}bv={VertTakeOff={set=function(F)a_=F end,get=function()return a_ end},VertTakeOffEngine={set=function(F)aQ=F end,get=function()return aQ end},SpaceTarget={set=function(F)bn=F end,get=function()return bn end},BrakeToggleStatus={set=function(F)aP=F end,get=function()return aP end},BrakeIsOn={set=function(F)aR=F end,get=function()return aR end},RetrogradeIsOn={set=function(F)aS=F end,get=function()return aS end},ProgradeIsOn={set=function(F)aT=F end,get=function()return aT end},Autopilot={set=function(F)aU=F end,get=function()return aU end},TurnBurn={set=function(F)aV=F end,get=function()return aV end},AltitudeHold={set=function(F)aW=F end,get=function()return aW end},BrakeLanding={set=function(F)aX=F end,get=function()return aX end},Reentry={set=function(F)aZ=F end,get=function()return aZ end},AutoTakeoff={set=function(F)aY=F end,get=function()return aY end},HoldAltitude={set=function(F)b0=F end,get=function()return b0 end},AutopilotAccelerating={set=function(F)b1=F end,get=function()return b1 end},AutopilotBraking={set=function(F)b3=F end,get=function()return b3 end},AutopilotCruising={set=function(F)b4=F end,get=function()return b4 end},AutopilotRealigned={set=function(F)b2=F end,get=function()return b2 end},AutopilotEndSpeed={set=function(F)b5=F end,get=function()return b5 end},AutopilotStatus={set=function(F)b6=F end,get=function()return b6 end},AutopilotPlanetGravity={set=function(F)b7=F end,get=function()return b7 end},PrevViewLock={set=function(F)b8=F end,get=function()return b8 end},AutopilotTargetName={set=function(F)b9=F end,get=function()return b9 end},AutopilotTargetCoords={set=function(F)ba=F end,get=function()return ba end},AutopilotTargetIndex={set=function(F)bb=F end,get=function()return bb end},TotalDistanceTravelled={set=function(F)bd=F end,get=function()return bd end},TotalFlightTime={set=function(F)be=F end,get=function()return be end},SavedLocations={set=function(F)bf=F end,get=function()return bf end},VectorToTarget={set=function(F)bg=F end,get=function()return bg end},LocationIndex={set=function(F)bh=F end,get=function()return bh end},LastMaxBrake={set=function(F)bi=F end,get=function()return bi end},LockPitch={set=function(F)bj=F end,get=function()return bj end},LastMaxBrakeInAtmo={set=function(F)bk=F end,get=function()return bk end},AntigravTargetAltitude={set=function(F)bl=F end,get=function()return bl end},LastStartTime={set=function(F)bm=F end,get=function()return bm end},iphCondition={set=function(F)bq=F end,get=function()return bq end},stablized={set=function(F)br=F end,get=function()return br end},UseExtra={set=function(F)bs=F end,get=function()return bs end},SelectedTab={set=function(F)bw=F end,get=function()return bw end},saveRoute={set=function(F)bu=F end,get=function()return bu end}}end;package.preload['ArchHUD:Modules/hudclass']=function(...)function bx(by,bz,bA,bB,bC,radar_1,radar_2,antigrav,hover,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT)local bU=9.80665;local bV={}local bW={}local bX={}local bY={}local bZ=nil;local b_=nil;local c0=nil;local c1=false;local c2="none"local c3=""local c4=vec3({13771471,7435803,-128971})local c5=18000000;local c6=500000;local c7,c8=math.huge;local c9;local function ca(cb)c7=vec3(cb):dist(c4)if c7<c5 then return true,bE(c7-c5)end;c8=vec3(cb):dist(vec3(cc.center))if c8<c6 then c9=true else c9=false end;if bE(c8-c6)<bE(c7-c5)then return c9,bE(c8-c6)else return c9,bE(c7-c5)end end;local function cd(ce)if cf==1920 then return ce else return bS(cf*ce/1920,0)end end;local function cg(ce)if ch==1080 then return ce else return bS(ch*ce/1080,0)end end;local function ci()return bQ()==0 and b~="keyboard"and bK()==0 end;local function cj()local ck="TRAVEL"if not cl then ck="CRUISE"end;if aU then ck="AUTOPILOT"end;return ck end;local cm=""local cn=""local co=""local cp=1;local cq=2;local cr=3;local cs=4;local ct=5;local cu=6;local cv=""local cw=0;local cx=bF(1/aJ)*2*aK;local cy={}local cz={}local cA={}local cB={}local cC={}local cD={}local function cE(cF,cG,cH,cI,cJ,cK)local cL=cM;local cN=cM+5;if not x then cN=cN+5 end;if bK()==1 and not g then cL=cL-50;cN=cN-50 end;if cH=="ATMO"then cv="atmofueltank"elseif cH=="SPACE"then cv="spacefueltank"else cv="rocketfueltank"end;cw=_G[cv.."_size"]if#cI>0 then for F=1,#cI do local cO=string.sub(cI[F][cq],1,12)local cP=0;for cQ=1,cw do if cI[F][cq]==bH(bA[cv.."_"..cQ].getData()).name then cP=cQ;break end end;local cR=bM()if cJ[F]==nil or cK[F]==nil or cR-cI[F][cu]>cx then local cS;local cT=0;if cP~=0 then cK[F]=bH(bA[cv.."_"..cP].getData()).percentage;cJ[F]=bH(bA[cv.."_"..cP].getData()).timeLeft;if cJ[F]=="n/a"then cJ[F]=0 end else cT=bJ(cI[F][cp])-cI[F][cs]cK[F]=bF(0.5+cT*100/cI[F][cr])cS=cI[F][ct]if cS<=cT then cJ[F]=0 else cJ[F]=bF(0.5+cT/((cS-cT)/(cR-cI[F][cu])))end;cI[F][ct]=cT;cI[F][cu]=cR end end;if cO==cG then cO=bG("%s %d",cH,F)end;if cP==0 then cO=cO.." *"end;local cU;if cJ[F]==0 then cU=""else cU=cV(cJ[F])end;if cK[F]~=nil then local cW=bF(cK[F]*2.55)local cX=bG("rgb(%d,%d,%d)",255-cW,cW,0)local cY=""if cU~=""and cJ[F]<120 or cK[F]<5 then cY="red "end;local cZ=bG("rgb(%d,%d,%d)",bN(bF((255-cW)/2.55),50,100),bN(bF(cW/2.55),0,50),50)local c_="rgb(196,0,255)"if cH=="ATMO"then c_="rgb(0,188,255)"elseif cH=="SPACE"then c_="rgb(239,255,0)"end;local d0=false;if d1~=c_ then d0=true end;d1=c_;if x then if d0 then cL=cL-5;cN=cN-5 end;cn=cn..bG([[
                                        <g class="pdim">                        
                                        <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                        <g class="bar txtstart">
                                        <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                        <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                        </g>]],cZ,c_,cF,cN,cX,bF(cK[F]*1.7+0.5)-2,cF+1,cN+1,cF+5,cN+14,cO,cK[F],cU)cL=cL-22;cN=cN-22 else cn=cn..bT(cF,cL,cO,cY.."pdim txtfuel")cn=cn..bT(cF,cN,bG("%d%% %s",cK[F],cU),"pdim txtfuel","fill:"..cX)cL=cL+30;cN=cN+30 end end end end;cM=cL end;local function d2(d3,d4)if ag==0 and ah==0 then return end;if d4<200000 and not d5 or d4 and d5 then local d6=0;if bE(d7)>1 then d6=45*math.log(bE(d7),10)if d7<0 then d6=-d6 end end;d3[#d3+1]=bG([[
                            <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                    <text x="55" y="-41">1000</text>
                                    <text x="10" y="-65">100</text>
                                    <text x="-45" y="-45">10</text>
                                    <text x="-73" y="3">O</text>
                                    <text x="-45" y="52">-10</text>
                                    <text x="10" y="72">-100</text>
                                    <text x="55" y="50">-1000</text>
                                    <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                <g class="linethick">
                                    <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                    <circle r="90" />
                                </g>
                                <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                            </g>
                        ]],ag,ah,bF(d7),bF(d6))end;return d3 end;local function d8(d9)local da=-db;d9=d9-d9:project_on(da)local dc=vec3(0,0,1)dc=dc-dc:project_on(da)local dd=dc:cross(da)local d6=dc:angle_between(d9)*constants.rad2deg;if d9:dot(dd)<0 then d6=360-d6 end;return d6 end;local function de(d3,ac,ad,df,dg,dh)if a5==0 then return end;local di=a5;local dj=20;local dk=bF(df)if dh then for F=-45,45,5 do local dl=F;d3[#d3+1]=bG([[<g transform="rotate(%f,%d,%d)">]],dl,ac,ad)dm=5;if F%15==0 then dm=15 elseif F%10==0 then dm=10 end;d3[#d3+1]=bG([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ac,ad+di+dj-dm,ac,ad+di+dj)end;d3[#d3+1]=bT(ac,ad+di+dj-35,dg,"pdim txt txtmid")d3[#d3+1]=bT(ac,ad+di+dj-25,dk.." deg","pdim txt txtmid")d3[#d3+1]=bG([[<g transform="rotate(%f,%d,%d)">]],-df,ac,ad)d3[#d3+1]=bG([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ac-5,ad+di+dj-20,ac+5,ad+di+dj-20,ac,ad+di+dj-15)d3[#d3+1]="</g>"end;d3[#d3+1]=[[<g style="clip-path: url(#headingClip);">]]local dn=dk;if dh then dn=d8(dp)end;local dq=20;local dr=bF(dn)local ds=0;local dt=ad+di+dj+20;local du=ac;if dg~="YAW"then dt=cg(130)du=cd(960)end;local dv=[[<path class="txttick line" d="]]local dw=bF(dr-(dq+10)-dr%5+0.5)for F=dw+70,dw,-5 do local cF=du-(-F*5+dn*5)if F%10==0 then ds=10;local dx=F;if dx==360 then dx=0 elseif dx>360 then dx=dx-360 elseif dx<0 then dx=dx+360 end;d3[#d3+1]=bT(cF,dt+15,dx,"txtmid bright")elseif F%5==0 then ds=5 end;if ds==10 then dv=bG([[%s M %f %f v %d]],dv,cF,dt-5,ds)else dv=bG([[%s M %f %f v %d]],dv,cF,dt-2.5,ds)end end;d3[#d3+1]=dv..[["/>]]d3[#d3+1]=bG([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],du-5,dt-20,du+5,dt-20,du,dt-10)if D then if dh then dg="HDG"end;d3[#d3+1]=bT(cd(960),cg(100),dr.."Â°","dim txt txtmid size14","")d3[#d3+1]=bT(cd(960),cg(85),dg,"dim txt txtmid size20","")end;d3[#d3+1]=[[</g>]]end;local function dy(d3,dz,df,ac,ad,dh,dA,dB)if a5==0 then return end;local di=a5;local dC=bF(di*3/5)if di>0 then local dD=bF(dz)local dm=0;local dv=bG([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*df,ac,ad)if not d5 then dv=bG([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ac,ad)end;d3[#d3+1]=bG([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],di-1,ac,ad)d3[#d3+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for F=bF(dD-30-dD%5+0.5),bF(dD+30+dD%5+0.5),5 do if F%10==0 then dm=30 elseif F%5==0 then dm=20 end;local dE=ad+-F*5+dz*5;if dm==30 then dv=bG([[%s M %d %f h %d]],dv,ac-dC-dm,dE,dm)if d5 then d3[#d3+1]=bG([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*df,ac,ad,ac-dC+10,dE+4,F)d3[#d3+1]=bG([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*df,ac,ad,ac+dC-10,dE+4,F)if F==0 or F==180 or F==-180 then d3[#d3+1]=bG([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*df,ac,ad,ac-dC+20,dE,dC*2-40)end else d3[#d3+1]=bT(ac-dC+10,dE,F,"pdim txt txtmid")d3[#d3+1]=bT(ac+dC-10,dE,F,"pdim txt txtmid")end;dv=bG([[%s M %d %f h %d]],dv,ac+dC,dE,dm)else dv=bG([[%s M %d %f h %d]],dv,ac-dC-dm,dE,dm)dv=bG([[%s M %d %f h %d]],dv,ac+dC,dE,dm)end end;d3[#d3+1]=dv..[["/>]]local dF="PITCH"if not dh then dF="REL PITCH"end;if dz>90 and not d5 then dz=90-(dz-90)elseif dz<-90 and not d5 then dz=-90-(dz+90)end;if di>200 then if d5 then if dB>dG then d3[#d3+1]=bT(ac,ad-15,"Yaw","pdim txt txtmid")d3[#d3+1]=bT(ac,ad+20,dA,"pdim txt txtmid")end;d3[#d3+1]=bG([[<g transform="rotate(%f,%d,%d)">]],-df,ac,ad)else d3[#d3+1]=bG([[<g transform="rotate(0,%d,%d)">]],ac,ad)end;d3[#d3+1]=bG([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ac-dC+25,ad-5,ac-dC+20,ad,ac-dC+25,ad+5,ac-dC+50,ad+4,dD)d3[#d3+1]=bG([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ac+dC-25,ad-5,ac+dC-20,ad,ac+dC-25,ad+5,ac+dC-30,ad+4,dD)d3[#d3+1]="</g>"end;local dH=bF(di/3)d3[#d3+1]=bG([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ac-dH,ad,di-dH)if not d5 and dh then d3[#d3+1]=bG([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*df,ac,ad,ac-dC+10,ad,dC*2-20)end;d3[#d3+1]="</g>"if di<200 then if d5 and dB>dG then d3[#d3+1]=bT(ac,ad-di,dF,"pdim txt txtmid")d3[#d3+1]=bT(ac,ad-di+10,dD,"pdim txt txtmid")d3[#d3+1]=bT(ac,ad-15,"Yaw","pdim txt txtmid")d3[#d3+1]=bT(ac,ad+20,dA,"pdim txt txtmid")else d3[#d3+1]=bT(ac,ad-di,dF,"pdim txt txtmid")d3[#d3+1]=bT(ac,ad-di+15,dD,"pdim txt txtmid")end end end end;local function dI(d3,d4,dh)local dJ=ai;local dK=aj;if dJ==0 and dK==0 then return end;local dL=78;local dM=19;local dN=dO;if dO~=-1 then d3[#d3+1]=bT(dJ+dL,dK+dM+20,bG("AGL: %.1fm",dO),"pdim altsm txtend")end;if dh and(d4<200000 and not d5 or d4 and d5)then table.insert(d3,bG([[
                            <g class="pdim">                        
                                <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                <g clip-path="url(#alt)">]],dJ-1,dK-4,dL+2,dM+6,dJ+1,dK-1,dL-4,dM))local dP=0;local dQ=1;local dR=0;local dS=d4<0;local dT=d4<cc.surfaceMaxAltitude;local dU=9;if dS then dU=0 end;local d4=bE(d4)while dP<6 do local dV=11;local dW=16;local dX=9;local dY=14;local cY="altsm"if dP>2 then dW=dW+3;dV=dV+2;dY=dY+2;dX=dX-6;cY="altbig"end;if dS then cY=cY.." red"elseif dT then cY=cY.." orange"end;local dZ=d4/dQ%10;local d_=bF(dZ)local e0=bF((d_+1)%10)local e1=dR;if dP==0 then e1=dZ-d_;if dS then e1=1-e1 end end;if dS and(dP==0 or dR~=0)then local e2=e0;e0=d_;d_=e2 end;local e3=dW*(e1-1)local e4=e3+dW;local cF=dJ+dX+(6-dP)*dV;local dE=dK+dY;d3[#d3+1]=bT(cF,dE+e3,e0,cY)d3[#d3+1]=bT(cF,dE+e4,d_,cY)dP=dP+1;dQ=dQ*10;if d_==dU then dR=e1 else dR=0 end end;table.insert(d3,[[</g></g>]])end end;local function e5(e6)local e7=-math.deg(bL(e6.y,e6.z))+180;e7=e7-90;if e7<0 then e7=360+e7 end;if e7>180 then e7=-180+e7-180 end;return-e7 end;local function e8(e6)local dn=math.deg(bL(e6.y,e6.x))-90;if dn<-180 then dn=360+dn end;return dn end;local function e9(d3,e6,dB,ac,ad)if dB>5 and not d5 or dB>dG then local di=a5;local ea=20;local eb=20;local ec=e5(e6)local ed=e8(e6)local ee=14;local ef=ee/2;local eg=-ed/eb*di;local eh=ec/ea*di;local cF=ac+eg;local dE=ad+eh;local ei=bR(eg^2+eh^2)local ej=[[<circle
                        cx="]]..cF..[["
                        cy="]]..dE..[["
                        r="]]..ef/ee..[["
                        style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                    <circle
                        cx="]]..cF..[["
                        cy="]]..dE..[["
                        r="]]..ef..[["
                        style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                    <path
                        d="M ]]..cF-ee..[[,]]..dE..[[ h ]]..ef..[["
                        style="stroke:#d7fe00;stroke-opacity:1" />
                    <path
                        d="M ]]..cF+ef..[[,]]..dE..[[ h ]]..ef..[["
                        style="stroke:#d7fe00;stroke-opacity:1" />
                    <path
                        d="M ]]..cF..[[,]]..dE-ee..[[ v ]]..ef..[["
                        style="stroke:#d7fe00;stroke-opacity:1" />]]if ei<di then d3[#d3+1]=ej else local d6=bL(eh,eg)local ek=4;local el=ac+di*math.cos(d6)local em=ad+di*math.sin(d6)d3[#d3+1]=bG('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',d6*180/math.pi,el,em,el-ek,em-ek/2,ek*2,ek,el+ek,em-ek,ek,ek,-ek,ek)end;if not d5 then local en=vec3(e6)ec=e5(-en)ed=e8(-en)eg=-ed/eb*di;eh=ec/ea*di;cF=ac+eg;dE=ad+eh;ei=bR(eg^2+eh^2)if ei<di then local eo=[[<circle
                                cx="]]..cF..[["
                                cy="]]..dE..[["
                                r="]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                            <path
                                d="M ]]..cF..[[,]]..dE-ee..[[ v ]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                            <use
                                xlink:href="#l"
                                transform="rotate(120,]]..cF..[[,]]..dE..[[)" />
                            <use
                                xlink:href="#l"
                                transform="rotate(-120,]]..cF..[[,]]..dE..[[)" />
                            <path
                                d="M ]]..cF-ef..[[,]]..dE..[[ h ]]..ee..[["
                                style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                transform="rotate(-45,]]..cF..[[,]]..dE..[[)" id="c"/>
                            <use
                                xlink:href="#c"
                                transform="rotate(-90,]]..cF..[[,]]..dE..[[)"/>]]d3[#d3+1]=eo end end end end;local function ep(d3,ck,eq,er)if ae==0 and af==0 then return end;eq=bF(eq+0.5)local cL=af+10;local cN=af+20;if bK()==1 and not g then cL=55;cN=65 end;local es="CRUISE"local bA="km/h"local et=er;if ck=="TRAVEL"or ck=="AUTOPILOT"then es="THROT"bA="%"et=eq;local eu="dim"if eq<0 then eu="red"end;d3[#d3+1]=bG([[<g class="%s">
                            <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                            <g transform="translate(0 %.0f)">
                                <polygon points="%d,%d %d,%d %d,%d"/>
                            </g>]],eu,ae-7,af-50,ae,af-50,ae,af+50,ae-7,af+50,1-bE(eq),ae-10,af+50,ae-15,af+53,ae-15,af+47)end;d3[#d3+1]=bT(ae+10,cL,es,"pbright txtstart")d3[#d3+1]=bT(ae+10,cN,bG("%.0f %s",et,bA),"pbright txtstart")if d5 and p and cl and ev then eq=bF(ew*100+0.5)local eu="red"if eq<0 then eu="red"end;d3[#d3+1]=bG([[<g class="%s">
                            <g transform="translate(0 %d)">
                                <polygon points="%d,%d %d,%d %d,%d"/>
                            </g></g>]],eu,1-bE(eq),ae-10,af+50,ae-15,af+53,ae-15,af+47)d3[#d3+1]=bT(ae+10,cL+40,"LIMIT","pbright txtstart")d3[#d3+1]=bT(ae+10,cN+40,eq.."%","pbright txtstart")end;if d5 and p or aZ then d3[#d3+1]=bT(ae+10,cL-40,"LIMIT: "..ex.." km/h","dim txtstart")elseif not d5 and aU then d3[#d3+1]=bT(ae+10,cL-40,"LIMIT: "..bF(V*3.6+0.5).." km/h","dim txtstart")end end;local function ey(d3,ez)if ae==0 and af==0 then return end;local eA=af-10;local eB=ae+10;d3[#d3+1]=bT(0,0,"","pdim txt txtend")if bK()==1 and not g then eA=75 end;d3[#d3+1]=bT(eB,eA,bF(ez).." km/h","pbright txtbig txtstart")end;local function eC(d3)d3[#d3+1]=bT(cd(1900),cg(1070),bG("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")d3[#d3+1]=[[<g class="warnings">]]if bA.isMouseControlActivated()==1 then d3[#d3+1]=bT(cd(960),cg(550),"Warning: Invalid Control Scheme Detected","warnings")d3[#d3+1]=bT(cd(960),cg(600),"Keyboard Scheme must be selected","warnings")d3[#d3+1]=bT(cd(960),cg(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local eD=cd(960)local eE=cg(860)local eF=cg(880)local eG=cg(900)local eH=cg(960)local eI=cg(200)local eJ=cg(250)local eK=cg(960)if bK()==1 and not g then eE=cg(135)eF=cg(155)eG=cg(175)eI=cg(115)eJ=cg(95)end;local eL="#222222"local eM="white"local eN="dimmer"local eO="pbright"local eP="#110000"local eQ=eL;local eR=eN;if aR then d3[#d3+1]=bT(eD,eE,"Brake Engaged","warnings")eP="#440000"eQ=eM;eR=eO elseif eS>0 then d3[#d3+1]=bT(eD,eE,"Auto-Brake Engaged","warnings","opacity:"..eS)end;local eT="#110000"local eU=eL;local eV=eN;if d5 and eW and dO==-1 then if not aU and not bg and not aX and not eX and not a_ and not aY then d3[#d3+1]=bT(eD,eI+50,"** STALL WARNING **","warnings")eT="#ff0000"eU=eM;eV=eO;eY("stall","SW",2)end end;if eZ then d3[#d3+1]=bT(eD,eI+90,"Flight Assist in Progress","warnings")end;if e_ then d3[#d3+1]=bT(eD,eK,"Gyro Enabled","warnings")end;local f0="#111100"local f1=eL;local f2=eN;if bc then f0="#775500"f1=eM;f2=eO;if f3 then d3[#d3+1]=bT(eD,eF,"Gear Extended","warn")else d3[#d3+1]=bT(eD,eF,"Landed (G: Takeoff)","warnings")end;local f4=f5(by:getTargetGroundAltitude())d3[#d3+1]=bT(eD,eG,"Hover Height: "..f4,"warn")end;local f6="#000011"local f7=eL;local f8=eN;if f9 then f6="#0000DD"f7=eM;f8=eO;d3[#d3+1]=bT(eD,eH+20,"ROCKET BOOST ENABLED","warn")end;local fa="#001100"local fb=eL;local fc=eN;if antigrav and not l and eX and bl~=nil then fa="#00DD00"fb=eM;fc=eO;if bE(fd-antigrav.getBaseAltitude())<501 then d3[#d3+1]=bT(eD,eI+15,bG("Target Altitude: %d Singularity Altitude: %d",bF(bl),bF(antigrav.getBaseAltitude())),"warn")else d3[#d3+1]=bT(eD,eI+15,bG("Target Altitude: %d Singluarity Altitude: %d",bF(bl),bF(antigrav.getBaseAltitude())),"warnings")end elseif aU and b9~="None"then d3[#d3+1]=bT(eD,eI+20,"Autopilot "..b6,"warn")elseif bj~=nil then d3[#d3+1]=bT(eD,eI+20,bG("LockedPitch: %d",bF(bj)),"warn")elseif fe then d3[#d3+1]=bT(eD,eI+20,"Follow Mode Engaged","warn")elseif aZ or ff then d3[#d3+1]=bT(eD,eI+20,"Re-entry in Progress","warn")end;if aW or a_ then local f4=f5(b0,2)if a_ then if eX then f4=f5(antigrav.getBaseAltitude(),2).." AGG singularity height"end;d3[#d3+1]=bT(eD,eI,"VTO to "..f4,"warn")elseif aY and not bp then if fg then d3[#d3+1]=bT(eD,eI,"Takeoff to "..b9,"warn")else d3[#d3+1]=bT(eD,eI,"Takeoff to "..f4,"warn")end;if aR and not a_ then d3[#d3+1]=bT(eD,eI+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else d3[#d3+1]=bT(eD,eI,"Altitude Hold: "..f4,"warn")end end;if a_ and(antigrav~=nil and antigrav)then if fh>0.1 then d3[#d3+1]=bT(eD,eI+20,"Beginning ascent","warn")elseif fh<0.09 and fh>0.05 then d3[#d3+1]=bT(eD,eI+20,"Aligning trajectory","warn")elseif fh<0.05 then d3[#d3+1]=bT(eD,eI+20,"Leaving atmosphere","warn")end end;if bp then if fi~=nil then d3[#d3+1]=bT(eD,eI,fi,"warn")end end;if aX then if fj then d3[#d3+1]=bT(eD,eI,"Brake-Landing","warnings")else d3[#d3+1]=bT(eD,eI,"Coast-Landing","warnings")end end;if aT then d3[#d3+1]=bT(eD,eI,"Prograde Alignment","crit")end;if aS then d3[#d3+1]=bT(eD,eI,"Retrograde Alignment","crit")end;local fk="#110000"local fl=eL;local fm=eN;if fn then fk="#FF0000"fl=eM;fm=eO;local type;if string.find(fn,"COLLISION")then type="warnings"else type="crit"end;d3[#d3+1]=bT(eD,eJ+20,fn,type)elseif fh==0 then local fo,fp=fq.checkLOS(fr:normalize())if fp~=nil then fm=eO;fk="#FF0000"fl=eM;local f4=f5(fp)local fs=ft.computeTravelTime(fu,0,fp)local fv="Collision"if fo.noAtmosphericDensityAltitude>0 then fv="Atmosphere"end;d3[#d3+1]=bT(eD,eJ+20,fo.name.." "..fv.." "..cV(fs).." In "..f4,"crit")end end;if bg and not bp then d3[#d3+1]=bT(eD,eI+35,fw,"warn")end;local fx="#111100"local fy=eL;local fz=eN;if fA and#fA>1 then fx="#DDDD00"fy=eM;fz=eO end;local fB=cd;local fC=cg;local eN="topButton"local fD="topButtonActive"local fE=eN;if aU or bg or fg or bp then fE=fD end;local fF=eN;if aT then fF=fD end;local fG=eN;if aX or bc then fG=fD end;local fH=eN;if aW or bg then fH=fD end;local fI=eN;if aS then fI=fD end;local fJ=eN;if bp or fK and aU then fJ=fD end;if s and D then local fL=fC(30)d3[#d3+1]=bG([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],fE,fB(960),fC(54),fC(-53),fB(-120),fB(25),fC(50))d3[#d3+1]=bT(fB(910),fL,"AUTOPILOT")d3[#d3+1]=bG([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],fF,fB(865),fC(51),fB(-25),fC(-50),fB(-110),fB(25),fC(46))d3[#d3+1]=bT(fB(800),fL,"PROGRADE")d3[#d3+1]=bG([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],fG,fB(755),fC(47),fB(-25),fC(-46),fB(-98),fB(44),fC(44))d3[#d3+1]=bT(fB(700),fL,"LAND")d3[#d3+1]=bG([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],fH,fB(960),fC(54),fC(-53),fB(120),fB(-25),fC(50))d3[#d3+1]=bT(fB(1010),fL,"ALT HOLD")d3[#d3+1]=bG([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],fI,fB(1055),fC(51),fB(25),fC(-50),fB(110),fB(-25),fC(46))d3[#d3+1]=bT(fB(1122),fL,"RETROGRADE")d3[#d3+1]=bG([[
                                </g>
            
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],fJ,fB(1165),fC(47),fB(25),fC(-46),fB(98),fB(-44),fC(44))d3[#d3+1]=bT(fB(1220),fL,"ORBIT")d3[#d3+1]=[[
                                </g>
                            </g>]]d3[#d3+1]="</g>"end;return d3 end;local function fM(dB)return bF(bS(dB*3.6,0)+0.5).." km/h"end;local function fN(dP)local cO=b9;if dP~=nil and type(dP)=="number"then if dP==0 then return"None"end;cO=fO[dP].name end;if cO==nil then cO=fP.name end;if cO==nil then cO="None"end;return cO end;local function fQ(d3)local fR=fq.routeWP(true)if not fR or#fR==0 then return end;local cF=cd(750)local dE=cg(360)if aU or bg then d3[#d3+1]=bT(cF,dE,"REMAINING ROUTE","pdim txtstart size20")else d3[#d3+1]=bT(cF,dE,"LOADED ROUTE","pdim txtstart size20")end;for fS,F in pairs(fR)do dE=dE+20;d3[#d3+1]=bT(cF,dE,fS..". "..fN(fR[fS]),"pdim txtstart size20")end end;local function fT(d3)local cF=aq+10;local dE=ar+20;local fU={}local fV={"Alt-4: AutoTakeoff to Target"}local fW={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local fX={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local fY={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(fU,"--------------DYNAMIC-----------------")if d5 then if dO~=-1 then fZ(fU,fV)if f_ and cc and f_.name==cc.name then table.insert(fU,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aQ then if antigrav then if eX then table.insert(fU,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(fU,"Turn on AGG to takeoff to AGG Height")end end;if aQ then table.insert(fU,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(fU,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(fU,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bc then table.insert(fU,"G: Takeoff to hover height, raise gear")else table.insert(fU,"G: Lowergear and Land")end else fZ(fU,fW)table.insert(fU,"G: Begin BrakeLanding or Land")end;if a_ then table.insert(fU,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else fZ(fU,fX)if bD then table.insert(fU,"Alt-Shift-5: Toggle shield off and on")table.insert(fU,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(fU,"Alt-9: Activate Gyroscope")end;if aM~="none"or aL~="none"or aN~="none"then table.insert(fU,"Alt-Shift-9: Cycles engines with Extra tags")end;if aW then table.insert(fU,"Alt-Spacebar/C will raise/lower target height")table.insert(fU,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if p or not d5 then table.insert(fU,"LALT+Mousewheel will lower/raise speed limit")end;fZ(fU,fY)for F=1,#fU do dE=dE+12;d3[#d3+1]=bT(cF,dE,fU[F],"pdim txtbig txtstart")end end;local function g0(d3)local g1=aq;local g2=ar;local g3=ap;local g4=4;local g5=15;local cF=0;local dE=0;local g6,g7,g8,g9;local ga;local function gb(type)local gc,gd,dB,ge,cY,gf;if type=="Periapsis"then gc=ga.periapsis.altitude;gd=ga.timeToPeriapsis;dB=ga.periapsis.speed;cY="txtend"ge=12;gf=math.min(cF,g1+g3-cc.radius/g8-g4*2)else gc=ga.apoapsis.altitude;gd=ga.timeToApoapsis;dB=ga.apoapsis.speed;ge=-12;cY="txtstart"gf=cF end;if fu<1 then gd=0 end;d3[#d3+1]=bG([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],gf+ge,dE-5,cF,dE-5)d3[#d3+1]=bG([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],gf-ge*4,dE+2,cF,dE+2)d3[#d3+1]=bT(gf,dE,type,cY)cF=gf-ge*2;dE=dE+g5;local f4=f5(gc)d3[#d3+1]=bT(cF,dE,f4,cY)dE=dE+g5;d3[#d3+1]=bT(cF,dE,cV(gd),cY)dE=dE+g5;d3[#d3+1]=bT(cF,dE,fM(dB),cY)end;local gg=g3*1.5;if bw=="INFO"then gg=25*7 end;if bw~="HIDE"then d3[#d3+1]=[[<g class="pbright txtorb txtmid">]]d3[#d3+1]=bG('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',g3*2,gg,g1,g2)d3[#d3+1]=bG([[<clippath id="orbitRect">
                                                    <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                    </clippath>]],g3*2,gg,g1,g2)end;local gh=g3*1.5;local gi=g3*2;local gj=gh/2;local gk=g3;local gl=g1+gk;local gm=g2+gj;local gn=g1+gi;local go=g2+gh;if bw=="ORBIT"then g2=g2+g4;g6=g3/2;g9=0;ga={}ga.periapsis={}ga.apoapsis={}if gp~=nil then if gp.periapsis~=nil then ga.periapsis.altitude=gp.periapsis.altitude;ga.periapsis.speed=gp.periapsis.speed end;if gp.apoapsis~=nil then ga.apoapsis.altitude=gp.apoapsis.altitude;ga.apoapsis.speed=gp.apoapsis.speed end;ga.period=gp.period;ga.eccentricity=gp.eccentricity;ga.timeToApoapsis=gp.timeToApoapsis;ga.timeToPeriapsis=gp.timeToPeriapsis;ga.eccentricAnomaly=gp.eccentricAnomaly;ga.trueAnomaly=gp.trueAnomaly end;if ga.periapsis==nil then ga.periapsis={}ga.periapsis.altitude=-cc.radius;ga.periapsis.speed=V end;if ga.eccentricity==nil then ga.eccentricity=1 end;if ga.apoapsis==nil then ga.apoapsis={}ga.apoapsis.altitude=fd;ga.apoapsis.speed=0 end;if fu<1 then ga.apoapsis.altitude=fd;ga.apoapsis.speed=0 end;if ga.apoapsis.altitude then g8=(ga.apoapsis.altitude+ga.periapsis.altitude+cc.radius*2)/(g6*2)g7=(cc.radius+ga.apoapsis.altitude)/g8*(1-ga.eccentricity)g9=g6-ga.periapsis.altitude/g8-cc.radius/g8;local gq=math.pi;if ga.period~=nil and ga.period>0 and ga.timeToApoapsis~=nil then gq=ga.eccentricAnomaly;if ga.timeToPeriapsis<ga.timeToApoapsis then gq=2*math.pi-gq end end;if fu<1 or gq~=gq then gq=math.pi end;local gr=-g6*math.cos(gq)+g1+gk+g4;local gs=g7*math.sin(gq)+g2+gj+g4;local gt=""d3[#d3+1]='<g clip-path="url(#orbitRect)">'d3[#d3+1]=bG([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],gt,g1+g3+g4,g2+g3*1.5/2+g4,g6,g7)if g7<1 then d3[#d3+1]=bG([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],g1+g3+g4-g9,g2+g3*1.5/2+g4,gr,gs)end;d3[#d3+1]=bG('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',g1+g3+g4-g9,g2+g3*1.5/2+g4,(cc.radius+cc.noAtmosphericDensityAltitude)/g8)d3[#d3+1]=bG('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',g1+g3+g4-g9,g2+g3*1.5/2+g4,(cc.radius+cc.noAtmosphericDensityAltitude)/g8)d3[#d3+1]=bG([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",g1+g3+g4,g2+g3*1.5/2+g4,g6,g7)d3[#d3+1]=bG('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',g1+g3+g4-g9,g2+g3*1.5/2+g4,cc.radius/g8)d3[#d3+1]='</g>'local gu=math.floor(cc.radius/g8+0.5)cF=g1+g3+g4*4+g6;dE=g2+g3*1.5/2+5+g4;if ga.apoapsis~=nil and ga.apoapsis.speed<V then gb("Apoapsis")end;dE=g2+g3*1.5/2+5+g4;cF=g1+g3-g4*2-g6;if ga.periapsis~=nil and ga.periapsis.speed<V and ga.periapsis.altitude>0 then gb("Periapsis")end;d3[#d3+1]=bT(g1+g3+g4,g2+20+g4,cc.name,"txtorbbig")d3[#d3+1]=bG('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',gr,gs)d3[#d3+1]=[[</g>]]return d3 else d3[#d3+1]='<g clip-path="url(#orbitRect)">'local gv=""local gw=1.2*(gx-gy)/(g3*2)local gz=1.4*(gA-gB)/(g3*1.5)for fS,ce in pairs(bC[0])do if ce.center then local cF=g1+g3+ce.center.x/gw;local dE=g2+g3*1.5/2+ce.center.y/gz;gv=gv..'<circle cx="'..cF..'" cy="'..dE..'" r="'..ce.radius/gw*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(ce.name,"Moon")and not string.match(ce.name,"Sanctuary")and not string.match(ce.name,"Space")then gv=gv.."<text x='"..cF.."' y='"..dE+ce.radius/gw*30+20 .."' font-size='12' fill="..gC.." text-anchor='middle' font-family='Montserrat'>"..ce.name.."</text>"end end end;local gD=vec3(bz.getConstructWorldPos())local cF=g1+g3+gD.x/gw;local dE=g2+g3*1.5/2+gD.y/gz;gv=gv..'<circle cx="'..cF..'" cy="'..dE..'" r="2" stroke="white" stroke-width="1" fill="red"/>'gv=gv.."<text x='"..cF.."' y='"..dE-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"bZ=gw;b_=gz;local gE=gD+fr*1000000;local gF=g1+g3+gE.x/gw;local cN=g2+g3*1.5/2+gE.y/gz;gv=gv..'<line x1="'..cF..'" y1="'..dE..'" x2="'..gF..'" y2="'..cN..'" stroke="purple" stroke-width="1"/>'d3[#d3+1]=gv;d3[#d3+1]='</g>'end elseif bw=="INFO"then d3=gG.DrawOdometer(d3,gH,bd,gI)elseif bw=="HELP"then d3=fT(d3)elseif bw=="SCOPE"then d3[#d3+1]='<g clip-path="url(#orbitRect)">'local gJ=gK;if fh>0 then table.sort(gL,function(gM,gN)local gO,gP=gM.center,gN.center;return(gO.x-gQ.x)^2+(gO.y-gQ.y)^2+(gO.z-gQ.z)^2<(gP.x-gQ.x)^2+(gP.y-gQ.y)^2+(gP.z-gQ.z)^2 end)end;local gR={}local gS={}local gT=120;local gU=nil;local gV=nil;for F,ce in ipairs(gL)do local gW=ce.center-gQ;local gX=gW:len()local gY=gW:normalize()local gZ=gW:cross(dp):normalize()local g_=math.acos(gZ:dot(h0))if g_~=g_ then g_=0 end;if gZ:cross(h0):dot(dp)<0 then g_=-g_ end;local h1=gW:project_on_plane(dp):len()local h2=math.sin(g_)*math.asin(h1/gX)*constants.rad2deg;local h3=math.cos(g_)*math.asin(h1/gX)*constants.rad2deg;if gY:dot(dp)<0 then h3=90*math.cos(g_)+90*math.cos(g_)-h3;h2=90*math.sin(g_)+90*math.sin(g_)-h2 end;local cF=gl+h2/gJ*gh;local dE=gm+h3/gJ*gh;local h4=(cF-gl)*(cF-gl)+(dE-gm)*(dE-gm)local h5=math.asin((ce.radius+ce.surfaceMaxAltitude)/gX)*constants.rad2deg;if h5~=h5 then h5=gJ end;local h6=h5/gJ*gh;local h7=math.asin(ce.atmosphereRadius/gX)*constants.rad2deg;if h7~=h7 then h7=h5 end;local h8=h7/gJ*gh;local ei=f5(gX,1)local h9=ce.name;local ha=false;if dE>g2 then if dE>go then if dE-h8<=go then ha=true end else ha=true end else if dE+h8>=g2 then ha=true end end;local hb=false;local hc=cF;if ce.systemId==0 then hc=cF+gT else hc=cF-gT end;if hc+gT>g1 then if hc+gT>gn then if hc-h8-gT<=gn then hb=true end else hb=true end else if hc+h8+gT>=g1 then hb=true end end;local hd={}hd.x=cF;hd.y=dE;hd.planet=ce;hd.atmoSize=h8;if not gU or h4<gU then gU=h4;gV=hd end;if hb and ha then local he=math.max(h8,5)if h4<he*he then h9=h9 .." - "..ei end;hd.size=h6;hd.i=F;hd.displayString=h9;hd.distance=ei;hd.visible=true;gS[#gS+1]=hd else hd.visible=false end end;local hf=false;table.sort(gS,function(gO,gP)return gO.y<gP.y end)for fS,hg in ipairs(gS)do local ce,h6,F,h8,cF,dE,h9,ei=hg.planet,hg.size,hg.i,hg.atmoSize,hg.x,hg.y,hg.displayString,hg.distance;local gf,hh,hi,hj;local hk=15;local cY="pdim"if ce.systemId~=0 then hi=cd(string.len(h9)*5)hk=-(15+hi)hj=cg(10)cY="pdimfill"else hi=cd(string.len(h9)*9)hj=cg(15)end;if h6*2>hi then gf=bN(cF,g1+hi/2,gn-hi/2)hh=bN(dE,g2+hj,go-5)gf=bN(gf,cF-h6+hi/2,cF+h6-hi/2)hh=bN(hh,dE-h6+hj,dE+h6)else gf=cF+hk;hh=dE end;for hl,hg in pairs(gR)do local hm=hg.textPositions;local hn=hm.y-hh;if hl~=F and bE(hn)<hm.height and hm.x+hm.width>gf and hm.x<gf+hi then if h6>hi then hh=bN(hh+hj,g2+15,go-5)else hh=hm.y+hm.height+1 end end end;local ho=h9~=ce.name or gf<=gl and gf+hi>=gl and hh-hj<=gm and hh>=gm;hg.hovered=ho;local hp=1;if ho then hp=2;if h6*2<hi then hp=10 end;if h9==ce.name then h9=h9 .." - "..ei end;cY="pbright"if ce.systemId~=0 then hi=cd(string.len(h9)*5)hk=-(15+hi)else hi=cd(string.len(h9)*7)end;if h6*2>hi then gf=bN(cF,g1+hi/2,gn-hi/2)gf=bN(gf,cF-h6+hi/2,cF+h6-hi/2)else gf=cF+hk end end;gR[F]={}gR[F].textPositions={}gR[F].textPositions.y=hh;gR[F].textPositions.x=gf;gR[F].textPositions.width=hi;gR[F].textPositions.height=hj;gR[F].output=""if h6*2>hi then cY=cY.." txtmid"else cY=cY.." txtstart"end;if h8-h6>2 then gR[F].output=bG('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',cF,dE,h8,hq,0.1*hp)end;gR[F].output=gR[F].output..bG('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',cF,dE,h6,hq,0.2*hp)if ce.systemId==0 then gR[F].output=gR[F].output..bG([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],gf,hh,gC,cY,h9)if h6*2<=hi then gR[F].output=gR[F].output..bG("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",gf+hi,hh+2,gf,hh+2,cF,dE)end else gR[F].output=gR[F].output..bG([[<text x='%f' y='%f'
                                        font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],gf,hh,hq,cY,h9)if h6*2<=hi then gR[F].output=gR[F].output..bG("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",gf,hh+2,gf+hi,hh+2,cF,dE)end end end;for fS=#gL,1,-1 do if gR[fS]then d3[#d3+1]=gR[fS].output end end;if gV~=nil and gK<90 and not gV.hovered then local hr=gV.planet.atmosphereRadius/gV.atmoSize;local hs=bR(gU)*hr;local ht=f5(hs,1)local hi=cd(math.max(string.len(ht)*7,string.len(gV.planet.name)*7))local hj=cg(12)local gf=bN(gV.x+(gl-gV.x)/2,g1+hi/2,gn-hi/2)local hh=bN(gV.y+(gm-gV.y)/2,g2+hj*2,go-5)d3[#d3+1]=bG("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",gV.x,gV.y,gl,gm)d3[#d3+1]=bG([[<text x='%f' y='%f'
                                    font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],gf,hh,"white",ht)if not gV.visible then d3[#d3+1]=bG([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],gf,hh-hj,"white",gV.planet.name)end end;if fu>1 then local gW=fr;local gY=gW:normalize()local h1=gW:project_on_plane(dp):len()local gZ=gW:cross(dp):normalize()local g_=math.acos(gZ:dot(h0))if g_~=g_ then g_=0 end;if gZ:cross(h0):dot(dp)<0 then g_=-g_ end;local h2=math.sin(g_)*math.asin(h1/gW:len())*constants.rad2deg;local h3=math.cos(g_)*math.asin(h1/gW:len())*constants.rad2deg;if gY:dot(dp)<0 then h3=90*math.cos(g_)+90*math.cos(g_)-h3;h2=90*math.sin(g_)+90*math.sin(g_)-h2 end;local cF=gl+h2/gJ*gh;local dE=gm+h3/gJ*gh;local ee=14;local ef=ee/2;local ej=[[<circle
                                cx="]]..cF..[["
                                cy="]]..dE..[["
                                r="]]..ef/ee..[["
                                style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                            <circle
                                cx="]]..cF..[["
                                cy="]]..dE..[["
                                r="]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                            <path
                                d="M ]]..cF-ee..[[,]]..dE..[[ h ]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1" />
                            <path
                                d="M ]]..cF+ef..[[,]]..dE..[[ h ]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1" />
                            <path
                                d="M ]]..cF..[[,]]..dE-ee..[[ v ]]..ef..[["
                                style="stroke:#d7fe00;stroke-opacity:1" />]]d3[#d3+1]=ej end;d3[#d3+1]=bG("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",gl,gm-10,gl,gm+10)d3[#d3+1]=bG("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",gl-10,gm,gl+10,gm)d3[#d3+1]='</g>'else return d3 end end;local function hu(hv,hw)local hx;local hy=(hw-hv):normalize()local hz=(gQ-hv):dot(hy)/hy:dot(hy)if hz<=0. then return(gQ-hv):len()elseif hz>=(hw-hv):len()then return(gQ-hw):len()end;local hA=hv+hz*hy;hx=(hA-gQ):len()return hx end;local function hB()local hx;local hC=nil;local hD=nil;local hE=nil;for fS,hF in pairs(bC[0])do if hF.hasAtmosphere then local ei=hu(cc.center,hF.center)if hC==nil or ei<hC then hD=hF;hC=ei;hE=cc end;if f_ and f_.hasAtmosphere and f_.name~=cc.name then local hG=hu(f_.center,hF.center)if hG<hC then hD=hF;hC=hG;hE=f_ end end end end;local hH=cd(1770)local hI=cg(330)if hC then local hJ="txttick "local hK=500000;if hC<hD.radius+hK or hC<hE.radius+hK then if hL then hJ="txttick red "else hJ="txttick orange "end end;hx=f5(hC,2)c3=bT(hH,hI,"Pipe ("..hE.name.."--"..hD.name.."): "..hx,hJ.."pbright txtmid")end end;local function hM(cF,dE,hN,hO,es)local hP={x=cF,y=dE,width=hN,height=hO,label=es}bY[es]=hP;return hP end;local function hQ(hR,hS,hN,hO,cF,dE,hT,hU,hV,hW,cY)local hP={enableName=hR,disableName=hS,width=hN,height=hO,x=cF,y=dE,toggleVar=hT,toggleFunction=hU,drawCondition=hV,hovered=false,class=cY}if hW then table.insert(bX,hP)else table.insert(bW,hP)end;return hP end;local function hX(hY)if not c1 then hZ=false;h_=false;i0=false;s=true;return elseif hY=="handling"then hZ=not hZ;h_=false;i0=false elseif hY=="hud"then h_=not h_;hZ=false;i0=false elseif hY=="physics"then i0=not i0;hZ=false;h_=false end;if i0 or h_ or hZ then c2=i1(hY)s=false else c2="none"s=true end end;local function i2()c1=not c1;if c1 then bV=bX;i3="Hold SHIFT to see Settings"i4=s else bV=bW;i3="Hold SHIFT to see Control Buttons"hX()s=i4 end end;local function i5()local function i6(ce,fS)ce.set(not ce.get())if ce.get()then i3=fS.." set to true"else i3=fS.." set to false"end;if fS=="showHud"then i4=ce.get()elseif fS=="BrakeToggleDefault"then aP=e end end;local i7=50;local i8=340;local cF=500;local dE=ch/2-400;local i9=0;for fS,ce in pairs(i1("boolean"))do if type(ce.get())=="boolean"then hQ(fS,fS,i8,i7,cF,dE,function()return ce.get()end,function()i6(ce,fS)end,function()return true end,true)dE=dE+i7+20;if i9==9 then cF=cF+i8+20;dE=ch/2-400;i9=0 else i9=i9+1 end end end;hQ("Control View","Control View",i8,i7,10,ch/2-500,function()return true end,i2,function()return true end,true)hQ("View Handling Settings",'Hide Handling Settings',i8,i7,10,ch/2-(500-i7),function()return hZ end,function()hX("handling")end,function()return true end,true)hQ("View Hud Settings",'Hide Hud Settings',i8,i7,10,ch/2-(500-i7*2),function()return h_ end,function()hX("hud")end,function()return true end,true)hQ("View Physics Settings",'Hide Physics Settings',i8,i7,10,ch/2-(500-i7*3),function()return i0 end,function()hX("physics")end,function()return true end,true)end;local function ia()local function ib()local ic=gQ;local cO=cc.name..". "..#bf;if radar_1 then cO=id.GetClosestName(cO)end;return ie.AddNewLocation(cO,ic,false,true)end;local function ig()aV=not aV end;local function ih(ii)if ii==1 then aT=not aT;aS=false else aS=not aS;aT=false end;aU=false;aW=false;fe=false;aX=false;bj=nil;aZ=false;aY=false end;local function ij()ie.UpdatePosition()end;local function ik()ie.ClearCurrentPosition()end;local function il(dP)local fR=fq.routeWP(true)if fR and#fR>0 then return"Engage Route: "..fN(fR[1])end;return"Engage Autopilot: "..fN(dP)end;local function im(dP)local fR=fq.routeWP(true)if fR and#fR>0 then return"Next Route Point: "..fN(fR[1])end;return"Disable Autopilot: "..fN(dP)end;local function io()if bK()==1 then fe=not fe;if fe then aU=false;aS=false;aT=false;aW=false;aZ=false;aX=false;aY=false;ip=bc;bc=false;by.control.retractLandingGears()bO:setTargetGroundAltitude(S)eY("folOn","F")else eY("folOff","F")aR=true;iq=k;bc=ip;if bc then by.control.extendLandingGears()bO:setTargetGroundAltitude(T)end end else i3="Follow Mode only works with Remote controller"fe=false end end;local i7=50;local i8=260;local ir=cd(30)local is=aq+ap*2+2;local it=ar+1;hQ("+","+",ir,ir,is,it+ir+1,function()return false end,function()gK=gK/8 end,function()return bw=="SCOPE"end,nil,"ZoomButton")hQ("-","-",ir,ir,is,it,function()return false end,function()gK=math.min(gK*8,90)end,function()return bw=="SCOPE"end,nil,"ZoomButton")hQ("0","0",ir,ir,is,it+ir*2+2,function()return false end,function()gK=90 end,function()return bw=="SCOPE"and gK~=90 end,nil,"ZoomButton")local iu=hQ("Enable Brake Toggle","Disable Brake Toggle",i8,i7,cf/2-i8/2,ch/2+350,function()return aP end,function()aP=not aP;if aP then i3="Brakes in Toggle Mode"else i3="Brakes in Default Mode"end end)hQ("Align Prograde","Disable Prograde",i8,i7,cf/2-i8/2-50-iu.width,ch/2-i7+380,function()return aT end,function()ih(1)end)hQ("Align Retrograde","Disable Retrograde",i8,i7,cf/2-i8/2+iu.width+50,ch/2-i7+380,function()return aS end,ih,function()return fh==0 end)iv=hQ(il,im,600,60,cf/2-600/2,ch/2-60/2-330,function()return aU or bg or fg or bp end,function()end)local F;local function iw(ix)local fR=fq.routeWP(true)if fR and#fR>0 then return fR[1]end;local dP=iy+ix;if dP>#fO then dP=dP-#fO-1 end;if dP<0 then dP=#fO+dP end;return dP end;iz={}for F=0,10 do local iA=hQ(function(gP)local dP=iw(gP.apExtraIndex)if aU or bg or fg or bp then return"Redirect: "..fN(dP)end;return il(dP)end,function(gP)local dP=iw(gP.apExtraIndex)return im(dP)end,600,60,cf/2-600/2,ch/2-60/2-330+60*F,function(gP)local dP=iw(gP.apExtraIndex)return dP==bb and(aU or bg or fg or bp)end,function(gP)local dP=iw(gP.apExtraIndex)local iB=bb==dP;bb=dP;ie.UpdateAutopilotTarget()fq.ToggleAutopilot()if not iB and not(aU or bg or fg or bp)then fq.ToggleAutopilot()end end,function()return iC and(#fq.routeWP(true)==0 or F==0)end)iA.apExtraIndex=F;iz[F]=iA end;hQ("Save Position","Save Position",200,iv.height,iv.x+iv.width+30,iv.y,function()return false end,ib,function()return bb==0 or fP==nil end)hQ("Update Position","Update Position",200,iv.height,iv.x+iv.width+30,iv.y,function()return false end,ij,function()return bb>0 and fP~=nil end)hQ("Clear Position","Clear Position",200,iv.height,iv.x-200-30,iv.y,function()return true end,ik,function()return bb>0 and fP~=nil end)hQ("Save Route","Save Route",200,iv.height,iv.x+iv.width+30,iv.y+iv.height+20,function()return false end,function()fq.routeWP(false,false,2)end,function()return#fq.routeWP(true)>0 end)hQ("Load Route","Clear Route",200,iv.height,iv.x-200-30,iv.y+iv.height+20,function()return#fq.routeWP(true)>0 end,function()if#fq.routeWP(true)>0 then fq.routeWP(false,true)elseif aU or bg then i3="Disable Autopilot before loading route"return else fq.routeWP(false,false,1)end end,function()return true end)i7=60;i8=300;local cF=0;local dE=ch/2-150;hQ("View Settings","View Settings",i8,i7,cF,dE,function()return true end,i2)dE=dE+i7+20;hQ("Enable Turn and Burn","Disable Turn and Burn",i8,i7,cF,dE,function()return aV end,ig)cF=10;dE=ch/2-300;hQ("Horizontal Takeoff Mode","Vertical Takeoff Mode",i8,i7,cF+i8+20,dE,function()return aQ end,function()aQ=not aQ;if aQ then i3="Vertical Takeoff Mode"else i3="Horizontal Takeoff Mode"end end,function()return iD end)dE=dE+i7+20;hQ("Engage Orbiting","Cancel Orbiting",i8,i7,cF+i8+20,dE,function()return bp end,fq.ToggleIntoOrbit,function()return fh==0 and dh end)dE=ch/2-150;hQ("Glide Re-Entry","Cancel Glide Re-Entry",i8,i7,cF+i8+20,dE,function()return aZ end,function()iE=1;ih(1)end,function()return cc.hasAtmosphere and not d5 end)dE=dE+i7+20;hQ("Parachute Re-Entry","Cancel Parachute Re-Entry",i8,i7,cF+i8+20,dE,function()return aZ end,fq.BeginReentry,function()return cc.hasAtmosphere and not d5 end)dE=dE+i7+20;hQ("Engage Follow Mode","Disable Follow Mode",i8,i7,cF,dE,function()return fe end,io,function()return bK()==1 end)hQ("Enable Repair Arrows","Disable Repair Arrows",i8,i7,cF+i8+20,dE,function()return iF end,function()iF=not iF;if iF then i3="Repair Arrows Enabled"else i3="Repair Arrows Diabled"end end,function()return bK()==1 end)dE=dE+i7+20;if not l then hQ("Enable AGG","Disable AGG",i8,i7,cF,dE,function()return eX end,fq.ToggleAntigrav,function()return antigrav~=nil end)end;hQ(function()return bG("Switch IPH Mode - Current: %s",bq)end,function()return bG("IPH Mode: %s",bq)end,i8*2,i7,cF,dE,function()return false end,function()if bq=="All"then bq="Custom Only"elseif bq=="Custom Only"then bq="No Moons"else bq="All"end;i3="IPH Mode: "..bq end)dE=dE+i7+20;hQ(function()return bG("Toggle Control Scheme - Current: %s",b)end,function()return bG("Control Scheme: %s",b)end,i8*2,i7,cF,dE,function()return false end,function()if b=="keyboard"then b="mouse"elseif b=="mouse"then b="virtual joystick"else b="keyboard"end;i3="New Control Scheme: "..b end)local iG=cg(20)local iA=hM(0,0,cd(70),iG,"HELP")iA=hM(iA.x+iA.width,iA.y,cd(80),iG,"INFO")iA=hM(iA.x+iA.width,iA.y,cd(70),iG,"ORBIT")iA=hM(iA.x+iA.width,iA.y,cd(70),iG,"SCOPE")hM(iA.x+iA.width,iA.y,cd(70),iG,"HIDE")end;local iH={}local iI=nil;function iH.HUDPrologue(d3)hL,iJ=ca(gQ)if not hL then iK=a9;iL=aa;iM=ab;if bD and B and bD.getState()==0 then bD.toggle()end else iK=a6;iL=a7;iM=a8;if bD and B and bD.getState()==1 then bD.toggle()end end;gC=[[rgb(]]..bF(iK+0.6)..","..bF(iL+0.6)..","..bF(iM+0.6)..[[)]]hq=[[rgb(]]..bF(iK*0.8+0.5)..","..bF(iL*0.8+0.5)..","..bF(iM*0.8+0.5)..[[)]]local iN=gC;local iO=hq;local iP=[[rgb(]]..bF(iK*0.4+0.5)..","..bF(iL*0.4+0.5)..","..bF(iM*0.4+0.5)..[[)]]local iQ=gC;local iR=hq;local iS=iP;if ci()and not h then iN=[[rgb(]]..bF(iK*0.5+0.5)..","..bF(iL*0.5+0.5)..","..bF(iM*0.5+0.5)..[[)]]iO=[[rgb(]]..bF(iK*0.3+0.5)..","..bF(iL*0.3+0.5)..","..bF(iM*0.2+0.5)..[[)]]iP=[[rgb(]]..bF(iK*0.2+0.5)..","..bF(iL*0.2+0.5)..","..bF(iM*0.2+0.5)..[[)]]end;local fB=cd;local fC=cg;d3[#d3+1]=bG([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],iN,iN,iN,iQ,iQ,iO,iO,iR,iR,iO,iN,iP,iR,iN,iN,iP,iP,iS,iP,cf,ch,iO,iO,iO,iO,iO,iQ,iO,iR,iS,iR,iR,iS)if not iI then iI=bG([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                    <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                    
                    <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                    
                    <clipPath id="headingClip">
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                    </clipPath>
                    <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],fB(630),fC(0),fB(675),fC(45),fB(960),fC(55),fB(1245),fC(45),fB(1290),fC(0),fB(1000),fC(105),fB(1040),fC(59),fB(1250),fC(51),fB(1300),fC(0),fB(1920),fC(0),fB(1920),fC(20),fB(1400),fC(20),fB(1300),fC(105),fB(920),fC(105),fB(880),fC(59),fB(670),fC(51),fB(620),fC(0),fB(0),fC(0),fB(0),fC(20),fB(520),fC(20),fB(620),fC(105),fB(890),fC(59),fB(960),fC(62),fB(1030),fC(59),fB(985),fC(112),fB(1150),fC(112),fB(1100),fC(152),fB(820),fC(152),fB(780),fC(112),fB(935),fC(112),fB(890),fC(59),fB(960),fC(62),fB(1030),fC(59),fB(985),fC(112),fB(1150),fC(112),fB(1100),fC(152),fB(820),fC(152),fB(780),fC(112),fB(935),fC(112))end;if s and D then d3[#d3+1]=iI end;return d3 end;function iH.DrawVerticalSpeed(d3,d4)d2(d3,d4)end;function iH.UpdateHud(d3)local e7=iT;local iU=iV;local df=iU;local dz=e7;local eq=bF(bA.getThrottle())local ez=fu*3.6;local er=bA.getAxisCommandValue(0)local iW=cd(1770)local iX=cg(310)if p and cl then er=iY;eq=iY*100 end;local ck=cj()local dg="ROLL"if eq==nil then eq=0 end;if not dh then if fu>5 then e7=e5(iZ)iU=e8(iZ)else e7=0;iU=0 end;dg="YAW"end;if iJ>50000 and not d5 then local i_;i_=f5(iJ)d3[#d3+1]=bT(iW,iX,"PvP Boundary: "..i_,"pbright txtbig txtmid")end;d3[#d3+1]=j0;d3[#d3+1]=j1;d3[#d3+1]=cm;if c3~=""then d3[#d3+1]=c3 end;if cn~=""then d3[#d3+1]=cn end;if co~=""then d3[#d3+1]=co end;d2(d3,fd)if bK()==0 or g then if dh then de(d3,ac,ad,df,dg,dh)else de(d3,ac,ad,iU,dg,dh)end;if not ci()or h then if dh then de(d3,ac,ad,df,dg,dh)dy(d3,dz,df,ac,ad,dh,bF(e8(iZ)),fu)else de(d3,ac,ad,iU,dg,dh)dy(d3,e7,iU,ac,ad,dh,bF(iU),fu)end;dI(d3,fd,dh)e9(d3,iZ,fu,ac,ad)end end;ep(d3,ck,eq,er)ey(d3,ez)eC(d3)g0(d3)if not c1 and j2 then fQ(d3)end;return d3 end;function iH.HUDEpilogue(d3)d3[#d3+1]="</svg>"return d3 end;function iH.ExtraData(d3)local j3=cd(1240)local j4=cg(55)local j5=j4+10;local j6;local fB=cd;local fC=cg;local j7=0;local ck=cj()if aQ then ck=ck.."-VERTICAL"end;if A and not aY and not aX and fu>20 then ck=ck.."-COLLISION ON"end;if bs~="Off"then ck="("..bs..")-"..ck end;if aV then ck="TB-"..ck end;if not br then ck=ck.."-DeCoupled"end;local j8=fC(99)local j9=fC(80)local ja=fC(85)local jb=fC(31)local jc=0;local jd=0;local je=jf>1000000 and bS(jf/1000000,2).."kT"or bS(jf/1000,2).."T"if d5 then j7=bk else j7=bi end;local jg,jh=ft.computeDistanceAndTime(fu,0,jf,0,0,j7)if jg<0 then jg=0 end;j7=bS(j7/(jf*bU),2).."g"local ji=by:maxForceForward()j6=bz.g()if j6>0.1 then jd=jf*j6;jd=bS(jd/(jf*bU),2).."g"jc=0.5*ji/j6;jc=jc>1000000 and bS(jc/1000000,2).."kT"or bS(jc/1000,2).."T"end;ji=bS(ji/(jf*bU),2).."g"local jj=vec3(bz.getWorldAcceleration()):len()/9.80665;j6=bz.g()d3[#d3+1]=[[<g class="dim txt txtend size14">]]if bK()==1 and not g then j3=cd(1120)j4=cg(55)j5=j4+10 elseif d5 and D then local jk=cd(770)d3[#d3+1]=bT(fB(895),j8,"ATMO","")d3[#d3+1]=bG([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],fB(895),ja,fB(-80))d3[#d3+1]=bT(fB(815),j9,bG("%.1f%%",fh*100),"txtstart size20")end;if D then d3[#d3+1]=bT(fB(1025),j8,"GRAVITY","txtstart")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(1025),ja,fB(80))d3[#d3+1]=bT(fB(1105),j9,bG("%.2fg",j6/9.80665),"size20")d3[#d3+1]=bT(fB(1125),j8,"ACCEL","txtstart")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(1125),ja,fB(80))d3[#d3+1]=bT(fB(1205),j9,bG("%.2fg",jj),"size20")d3[#d3+1]=bT(fB(695),j8,"BRK TIME","")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(695),ja,fB(-80))d3[#d3+1]=bT(fB(615),j9,bG("%s",cV(jh)),"txtstart size20")d3[#d3+1]=bT(fB(635),fC(45),"TRIP","")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(635),fC(31),fB(-90))if fs then d3[#d3+1]=bT(fB(532),fC(23),bG("%s",cV(fs)),"txtstart size20")end;d3[#d3+1]=bT(fB(795),j8,"BRK DIST","")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(795),ja,fB(-80))d3[#d3+1]=bT(fB(715),j9,bG("%s",f5(jg)),"txtstart size20")d3[#d3+1]=bT(fB(1285),fC(45),"MASS","txtstart")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(1285),fC(31),fB(90))d3[#d3+1]=bT(fB(1388),fC(23),bG("%s",je),"size20")d3[#d3+1]=bT(fB(1220),j8,"THRUST","txtstart")d3[#d3+1]=bG([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],fB(1220),ja,fB(80))d3[#d3+1]=bT(fB(1300),j9,bG("%s",ji),"size20")d3[#d3+1]=bT(cd(960),cg(175),ck,"pbright txtbig txtmid size20")end;d3[#d3+1]="</g>"end;function iH.DrawOdometer(d3,gH,bd,gI)if bw~="INFO"then return d3 end;local j6;local jc=0;local jd=0;local j7=0;local je=jf>1000000 and bS(jf/1000000,2).." kTons"or bS(jf/1000,2).." Tons"if d5 then j7=bk else j7=bi end;local jg,jh=ft.computeDistanceAndTime(fu,0,jf,0,0,j7)j7=bS(j7/(jf*bU),2).." g"local ji=by:maxForceForward()j6=bz.g()if j6>0.1 then jd=jf*j6;jd=bS(jd/(jf*bU),2).." g"jc=0.5*ji/j6;jc=jc>1000000 and bS(jc/1000000,2).." kTons"or bS(jc/1000,2).." Tons"end;ji=bS(ji/(jf*bU),2).." g"if bK()==0 or g then local jl=cd(aq+10)local jm=cg(ar+20)local jn=cd(aq+10+ap/1.25)local hO=25;d3[#d3+1]="<g class='txtstart size14 bright'>"d3[#d3+1]=bT(jl,jm,bG("BrkTime: %s",cV(jh)))d3[#d3+1]=bT(jn,jm,bG("Trip: %.2f km",gH))d3[#d3+1]=bT(jl,jm+hO,bG("Lifetime: %.2f kSU",bd/200000))d3[#d3+1]=bT(jn,jm+hO,bG("BrkDist: %s",f5(jg)))d3[#d3+1]=bT(jl,jm+hO*2,"Trip Time: "..cV(gI))d3[#d3+1]=bT(jn,jm+hO*2,"Total Time: "..cV(be))d3[#d3+1]=bT(jl,jm+hO*3,bG("Mass: %s",je))d3[#d3+1]=bT(jn,jm+hO*3,bG("Max Brake: %s",j7))d3[#d3+1]=bT(jl,jm+hO*4,bG("Max Thrust: %s",ji))if j6>0.1 then d3[#d3+1]=bT(jn,jm+hO*4,bG("Max Thrust Mass: %s",jc))d3[#d3+1]=bT(jl,jm+hO*5,bG("Req Thrust: %s",jd))else d3[#d3+1]=bT(jn,jm+hO*5,"Max Mass: n/a")d3[#d3+1]=bT(jl,jm+hO*6,"Req Thrust: n/a")end end;d3[#d3+1]="</g></g>"return d3 end;function iH.DrawWarnings(d3)return eC(d3)end;function iH.DisplayOrbitScreen(d3)return g0(d3)end;function iH.DisplayMessage(d3,f4)if f4~="empty"then local dE=310;for jo in string.gmatch(f4,"([^\n]+)")do dE=dE+35;d3[#d3+1]=bT("50%",dE,jo,"msg")end end;if jp~=0 then bA.setTimer("msgTick",jp)jp=0 end end;function iH.DrawDeadZone(d3)d3[#d3+1]=bG([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],ao)end;function iH.UpdatePipe()if d5 then c3=""return end;hB()end;function iH.DrawSettings(d3)local cF=cd(640)local dE=cg(200)d3[#d3+1]=[[<g class="pbright txtvspd txtstart">]]local jq=0;for fS,ce in pairs(c2)do jq=jq+1;d3[#d3+1]=bT(cF,dE,fS..": "..ce.get())dE=dE+20;if jq%12==0 then cF=cF+cd(350)dE=cg(200)end end;d3[#d3+1]=bT(cd(640),cg(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")d3[#d3+1]="</g>"return d3 end;local jr;local js=cd(1770)local jt=cg(350)local ju=cg(15)local jv=cd(1370)local jw,jx;local jy=0;function iH.DrawRadarInfo()cm=id.GetRadarHud(jv,ju,js,jt)end;function iH.DrawTanks()if ak~=0 and al~=0 then cn=bT(ak,al,"","txtstart pdim txtfuel")cM=al;cE(ak,"Atmospheric ","ATMO",jz,cC,cD)cE(ak,"Space Fuel T","SPACE",jA,cA,cB)cE(ak,"Rocket Fuel ","ROCKET",jB,cy,cz)end end;function iH.DrawShield()local jC=bD.getState()==1 and"Shield Active"or"Shield Disabled"local jD=bz.getPvPTimer()local jE=bD.getResistances()local jF="A: "..10+jE[1]*100 .."% / E: "..10+jE[2]*100 .."% / K:"..10+jE[3]*100 .."% / T: "..10+jE[4]*100 .."%"local cF,dE=am-60,an+30;local jG=bF(0.5+bD.getShieldHitpoints()*100/bD.getMaxShieldHitpoints())local cW=bF(jG*2.55)local cX=bG("rgb(%d,%d,%d)",255-cW,cW,0)local cY=""co=bT(cF,dE,"","txtmid pdim txtfuel")if jG<10 and jC~="Shield Disabled"then cY="red "end;jD=jD>0 and"   PvPTime: "..cV(jD)or""co=co..bG([[
                    <g class="pdim">                        
                    <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                    <g class="bar txtstart">
                    <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                    <text fill=black x="%d" y="%d">%s%%%s</text>
                    </g>]],cF,dE,cX,jG*2,cF,dE,cF+2,dE+10,jG,jD)co=co..bT(cF,dE-5,jC,cY.."txtstart pbright txtbig")co=co..bT(cF,dE+30,jF,cY.."txtstart pbright txtsmall")end;function iH.hudtick()if not cc then return end;local function jH(d3)local c_=bF(bN(ei/(cf/4)*255,0,255))d3[#d3+1]=bG("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",jI,jJ,bF(iK+0.5)+c_,bF(iL+0.5)-c_,bF(iM+0.5)-c_)end;local function jK()for jL,ce in pairs(bV)do if ce.hovered then if not ce.drawCondition or ce.drawCondition(ce)then ce.toggleFunction(ce)end;ce.hovered=false end end;for jL,ce in pairs(bY)do if ce.hovered then bw=ce.label;ce.hovered=false end end end;local function jM()local function jN(jO,jP,cF,dE,hN,hO)if jO>=cF and jO<=cF+hN and jP>=dE and jP<=dE+hO then return true else return false end end;local cF=jI+cf/2;local dE=jJ+ch/2;for jL,ce in pairs(bV)do ce.hovered=jN(cF,dE,ce.x,ce.y,ce.width,ce.height)end;for jL,ce in pairs(bY)do ce.hovered=jN(cF,dE,ce.x,ce.y,ce.width,ce.height)end;if iC then local ho=false;for jL,gP in ipairs(iz)do if gP.hovered then ho=true;break end end;if iv.hovered then ho=true end;iC=ho else iC=iv.hovered;if not iC then iy=bb end end end;local function jQ(d3)if not bw or bw==""then bw="HELP"end;if s then for fS,ce in pairs(bY)do local cY="dim brightstroke"local jR=0.2;if bw==fS then cY="pbright dimstroke"jR=0.6 end;local jS=""if ce.hovered then jR=0.8;jS=";stroke:white"end;d3[#d3+1]=bG([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],ce.width,ce.height,ce.x,ce.y,cY,jR,jS)d3[#d3+1]=bT(ce.x+ce.width/2,ce.y+ce.height/2+5,ce.label,"txt txtmid pdim")end end end;local function jT(d3)local function jU(d3,jV,hover,cF,dE,jW,jX,jY,jZ,j_,k0,iA)if type(j_)=="function"then j_=j_(iA)end;if type(k0)=="function"then k0=k0(iA)end;d3[#d3+1]=bG("<rect x='%f' y='%f' width='%f' height='%f' fill='",cF,dE,jW,jX)if jV then d3[#d3+1]=bG("%s'",jY)else d3[#d3+1]=jZ end;if hover then d3[#d3+1]=bG(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",a6,a7,a8)else d3[#d3+1]=bG(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",bS(a6*0.5,0),bS(a7*0.5,0),bS(a8*0.5,0))end;d3[#d3+1]=" rx='5'></rect>"d3[#d3+1]=bG("<text x='%f' y='%f' font-size='24' fill='",cF+jW/2,dE+jX/2+5)if jV then d3[#d3+1]="black"else d3[#d3+1]="white"end;d3[#d3+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if jV then d3[#d3+1]=bG("%s</text>",j_)else d3[#d3+1]=bG("%s</text>",k0)end end;local k1=bG("rgb(%d,%d,%d)'",bS(a6*0.1,0),bS(a7*0.1,0),bS(a8*0.1,0))local k2=bG("rgb(%d,%d,%d)",bS(a6*0.8,0),bS(a7*0.8,0),bS(a8*0.8,0))local k3=jU;for jL,ce in pairs(bV)do local hS=ce.disableName;local hR=ce.enableName;if type(hS)=="function"then hS=hS(ce)end;if type(hR)=="function"then hR=hR(ce)end;if not ce.drawCondition or ce.drawCondition(ce)then k3(d3,ce.toggleVar(ce),ce.hovered,ce.x,ce.y,ce.width,ce.height,k2,k1,hS,hR,ce)end end end;local k4=bS(cf/2,0)local k5=bS(ch/2,0)local d3={}gG.HUDPrologue(d3)if s then gG.UpdateHud(d3)else if w then gG.DrawVerticalSpeed(d3,fd)end;gG.DrawWarnings(d3)end;if c1 and c2~="none"then gG.DrawSettings(d3)end;if radar_1 then gG.DrawRadarInfo()end;gG.HUDEpilogue(d3)d3[#d3+1]=bG([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cf,ch)if i3~="empty"then gG.DisplayMessage(d3,i3)end;if bK()==0 and b=="virtual joystick"then if r then gG.DrawDeadZone(d3)end end;jQ(d3)if bQ()==0 then if bK()==1 and j2 then if not k6 then jM()jT(d3)end;if not k7 and not k8 then local k9=table.concat(d3,"")d3={}d3[#d3+1]=bG("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cf,ch)d3[#d3+1]=k9;d3[#d3+1]="</body>"k7=true;d3[#d3+1]=[[</svg></body>]]bA.setTimer("animateTick",0.5)local ka=table.concat(d3,"")bB.setScreen(ka)elseif k8 then local k9=table.concat(d3,"")d3={}d3[#d3+1]=bG("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cf,ch)d3[#d3+1]=k9;d3[#d3+1]="</body>"end;if not k7 then d3[#d3+1]=bG([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],k4,k5,jI,jJ)end else jK()end else if not j2 and bK()==0 then jK()if ei>ao then if r then jH(d3)end end elseif j2 and(not k6 or not d)then jM()jT(d3)end;d3[#d3+1]=bG([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],k4,k5,jI,jJ)end;d3[#d3+1]=[[</svg></body>]]ka=table.concat(d3,"")end;function iH.TenthTick()gG.DrawTanks()if bD then gG.DrawShield()end end;function iH.OneSecond(d3)local function kb()local cR=bM()local ez=fu;local kc=cR-kd;if ez>1.38889 then ez=ez/1000;local ke=ez*(cR-kd)bd=bd+ke;gH=gH+ke end;gI=gI+kc;be=be+kc;kd=cR end;kb()gG.UpdatePipe()gG.ExtraData(d3)end;function iH.ButtonSetup()i5()ia()bV=bW end;return iH end end;package.preload['ArchHUD:Modules/apclass']=function(...)function kf(by,bz,bA,bB,bC,vBooster,hover,kg,antigrav,bE,bF,bI,bK,bL,bM,bN,bO,kh,bQ,bR,bS)local ki={}local function kj(dB)local kk=b5;if not aU then kk=0 end;if not d5 then return ft.computeDistanceAndTime(dB,kk,jf,0,0,bi-b7*jf)else if bk and bk>0 then return ft.computeDistanceAndTime(dB,kk,jf,0,0,bk-b7*jf)else return 0,0 end end end;local function kl(dB)local kk=b5;if not aU then kk=0 end;return ft.computeDistanceAndTime(dB,kk,jf,by:maxForceForward(),X,bi-b7*jf)end;local km=false;local kn=0;local ko=0;local kp=0;local kq=bM()local kr=0;local ks=0;local kt=0;local ku=0;local kv=false;local kw=false;local kx=false;local ky=nil;local kz=0;local kA={}function ki.GetAutopilotBrakeDistanceAndTime(dB)return kj(dB)end;function ki.GetAutopilotTBBrakeDistanceAndTime(dB)return kl(dB)end;local function kB(kC,kD,kE)kD=kD:project_on_plane(kC)kE=kE:project_on_plane(kC)return bL(kD:cross(kE):dot(kC),kD:dot(kE))end;local function kF()local function kG()local kH=-1;local kI=-1;if vBooster then kH=vBooster.getDistance()end;if hover then kI=hover.getDistance()end;if kH~=-1 and kI~=-1 then if kH<kI then return kH else return kI end elseif kH~=-1 then return kH elseif kI~=-1 then return kI else return-1 end end;local kJ=kG()local kK=-1;if kg then kK=kg.getDistance()end;if kJ~=-1 and kK~=-1 then if kJ<kK then return kJ else return kK end elseif kJ~=-1 then return kJ else return kK end end;local function kL(cc,kM,kN)local function kO(kP,kQ)local kR=vec3(kQ)if kP.id==0 then return setmetatable({latitude=kR.x,longitude=kR.y,altitude=kR.z,id=0,systemId=kP.systemId},kS)end;local kT=kR-kP.center;local ei=kT:len()local d4=ei-kP.radius;local kU=0;local kV=0;if not kW(ei,0)then local kX=bL(kT.y,kT.x)kV=kX>=0 and kX or 2*math.pi+kX;kU=math.pi/2-math.acos(kT.z/ei)end;return setmetatable({latitude=math.deg(kU),longitude=math.deg(kV),altitude=d4,id=kP.id,systemId=kP.systemId},kS)end;local kY=kO(cc,kM)kY="::pos{"..kY.systemId..","..kY.id..","..kY.latitude..","..kY.longitude..","..kY.altitude.."}"if kN then return kY else bB.setWaypoint(kY)return true end end;local kZ=false;function ki.showWayPoint(cc,kM,kN)return kL(cc,kM,kN)end;function ki.APTick()local function k_()if l0 and not aX then local l1=l0[1]local l2,l3=l0[2],l0[3]local l4=math.min(l2,l3 or l2)local l5=l4/fu;local l6=aY and(fu<42 or dO~=-1)local l7=aW or bg or bj or aU;if l7 and not l6 and(l8*1.5>l4 or l5<1)then aR=true;kA={}fq.cmdThrottle(0)if aW then fq.ToggleAltitudeHold()end;if bj then l9()end;i3="Autopilot Cancelled due to possible collision"if bg or aU then fq.ToggleAutopilot()end;fj=true;aX=true;iq=true end;if l5<11 then fn=l1.name.." COLLISION "..cV(l5).." / "..f5(l4,2)else fn=l1.name.." collision "..cV(l5)end;if l5<6 then eY("alarm","AL",2)end else fn=false end end;local function la(lb,lc,ld)local function le(lb,lf)lb=vec3(lb)lf=vec3(lf):normalize()local lg=lb*lf;return lg.x+lg.y+lg.z end;local lh=0.001;local li=1;if not d5 or not eW or dO~=-1 or fu<dG then if ld==nil then ld=aI end;if lc==nil then lc=lh end;lb=vec3(lb):normalize()local lj=vec3()-lb;local lk=-le(lj,bz.getConstructWorldOrientationRight())*li;local ll=-le(lj,bz.getConstructWorldOrientationUp())*li;if ko==0 then ko=lk/2 end;if kp==0 then kp=ll/2 end;if bE(lk)<0.1 then lm=lm-lk*2 else lm=lm-(lk+(lk-ko)*ld)end;if bE(ll)<0.1 then ln=ln+ll*2 else ln=ln+ll+(ll-kp)*ld end;ko=lk;kp=ll;if bE(lk)<lc and bE(ll)<lc then return true end;return false elseif eW and dO==-1 then lb=fr;if ld==nil then ld=aI end;if lc==nil then lc=lh end;lb=vec3(lb):normalize()local lj=dp-lb;local lk=-le(lj,bz.getConstructWorldOrientationRight())*li;local ll=-le(lj,bz.getConstructWorldOrientationUp())*li;if ko==0 then ko=lk/2 end;if kp==0 then kp=ll/2 end;if bE(lk)<0.1 then lm=lm-lk*5 else lm=lm-(lk+(lk-ko)*ld)end;if bE(ll)<0.1 then ln=ln+ll*5 else ln=ln+ll+(ll-kp)*ld end;ko=lk;kp=ll;if bE(lk)<lc and bE(ll)<lc then return true end;return false end end;d5=bI()>0;fh=bI()fd=bz.getAltitude()dO=kF()gd=bM()kq=gd;if A then k_()end;if antigrav then eX=antigrav.getState()==1 end;local lo=1;local lp=1;local lq=gd-kq;local lr=-math.deg(kB(ls,fr,dp))local lt=math.deg(kB(h0,fr,dp))local da=db*-1;eW=d5 and lr<-G or lr>G or lt<-H or lt>H;local lu=bB.getMouseDeltaX()local lv=bB.getMouseDeltaY()if j and not j2 then lv=-lv end;lm=0;lw=0;ln=0;lx=ly[0]cc=lx:closestBody(bz.getConstructWorldPos())lz=lA(cc)gp=lz:orbitalParameters(bz.getConstructWorldPos(),fr)if fd==0 then fd=(gQ-cc.center):len()-cc.radius end;dh=bA.getClosestPlanetInfluence()>0 or fd>0 and fd<200000;local j6=cc:getGravity(bz.getConstructWorldPos()):len()*jf;lB=0;lC=bz.getMaxKinematicsParametersAlongAxis("ground",bz.getConstructOrientationUp())[1]if bQ()==0 then if bK()==1 and j2 then if not k7 then jI=bN(jI+lu,-cf/2,cf/2)jJ=bN(jJ+lv,-ch/2,ch/2)end else jI=0;jJ=0 end else jI=bN(jI+lu,-cf/2,cf/2)jJ=bN(jJ+lv,-ch/2,ch/2)ei=bR(jI*jI+jJ*jJ)if not j2 and bK()==0 then local eg,eh=1,1;if bw=="SCOPE"then eg,eh=gK/90,gK/90 end;if b=="virtual joystick"then if jI>0 and jI>ao then lm=lm-(jI-ao)*aw*eg elseif jI<0 and jI<ao*-1 then lm=lm-(jI+ao)*aw*eg else lm=0 end;if jJ>0 and jJ>ao then ln=ln-(jJ-ao)*ax*eh elseif jJ<0 and jJ<ao*-1 then ln=ln-(jJ+ao)*ax*eh else ln=0 end else jI=0;jJ=0;if b=="mouse"then ln=(-utils.smoothstep(lv,-100,100)+0.5)*2*lo;lm=(-utils.smoothstep(lu,-100,100)+0.5)*2*lp end end end end;local lD=fu>8334;if fu>Q/3.6 and not d5 and not aU and not lD then i3="Space Speed Engine Shutoff reached"fq.cmdThrottle(0)end;if not lD and lE then if not aR then fq.BrakeToggle()end;if aU then fq.ToggleAutopilot()end end;lE=lD;if d5 and fh>0.09 then if fu>ex/3.6 and not p and not km then aR=true;km=true elseif not p and km then if fu<ex/3.6 then aR=false;km=false end end end;if aR then lF=1 else lF=0 end;if aT then if iE then aR=false;local lG=false;if fP and iE~=1 then lG=la(fP.position-gQ,0.1)else lG=la(vec3(fr),0.01)end;iq=true;if lG then fq.cmdCruise(bF(ex))if(bE(iV)<2 or bE(iT)>85)and fu>=ex/3.6-1 then aR=false;aT=false;lH=true;if iE~=1 then ff=true end;iE=false;aU=false;fq.BeginReentry()end elseif d5 and p then fq.cmdThrottle(1)end elseif fu>dG then la(vec3(fr),0.01)end end;if aS then if d5 then aS=false elseif fu>dG then la(-vec3(fr))end end;if not aT and iE and not bp then if fh==0 then lH=true;fq.BeginReentry()iE=false;ff=true else iE=false;fq.ToggleAutopilot()end end;if ff and fP and(fd<b0+250 and fd>b0-250)and fu*3.6>ex-250 and bE(d7)<25 and fh>=0.1 and(fP.position-gQ):len()>2000+fd then fq.ToggleAutopilot()ff=false end;if a_ then iq=true;local lI=b0;if d7<-30 then i3="Unable to achieve lift. Safety Landing."lJ=0;iq=k;a_=false;aX=true elseif not l and eX or b0<cc.spaceEngineMinAltitude then if eX then lI=antigrav.getBaseAltitude()end;if fd<lI-100 then lK=0;lJ=15;aR=false elseif d7>0 then aR=true;lJ=0 elseif d7<-30 then aR=true;lJ=15 elseif fd>=lI then if eX then if aU or bg then fq.ToggleVerticalTakeoff()else aR=true;a_=false end;i3="Takeoff complete. Singularity engaged"eY("aggLk","AG")else aR=false;i3="VTO complete. Engaging Horizontal Flight"eY("vtoc","VT")fq.ToggleVerticalTakeoff()end;lJ=0 end else if fh>0.08 then lK=0;aR=false;lJ=20 elseif fh<0.08 and fh>0 then aR=false;if lL then lK=0;lJ=20 else lJ=0;lK=36;fq.cmdCruise(3500)end else iq=k;bp=true;fK=false;lM=false;kv=false;kt=nil;ku=nil;if ky==nil then ky=cc end;lN=lI;kx=true;a_=false end end;if lK~=nil then if lO==nil then lO=pid.new(2*0.01,0,2*0.1)end;local lP=bN(lK-iT,-H*0.80,H*0.80)lO:inject(lP)local lQ=bN(lO:get(),-1,1)ln=lQ end end;if bp then local lj;local lR=false;local lS=f5(lN)if ky==nil then ky=cc;if bg then ky=f_ end end;if not kx then lN=bF(ky.radius+ky.surfaceMaxAltitude+O)if ky.hasAtmosphere then lN=bF(ky.radius+ky.noAtmosphericDensityAltitude+O)end;kx=true end;if lT.VectorToTarget and fP then lj=fP.position-gQ end;local lU,lV=lA(ky):escapeAndOrbitalSpeed((gQ-ky.center):len()-ky.radius)local lW=iV;if not kv then local lX=false;local lY=false;fq.cmdThrottle(0)ku=0;fi="Aligning to orbital path - OrbitHeight: "..lS;if lT.VectorToTarget then la(lj:normalize():project_on_plane(db))lR=dp:dot(lj:project_on_plane(ls):normalize())>0.95 else la(fr)lR=lr<0.5;if fu<150 then lR=true end end;ln=0;kt=0;if iT<=kt+1 and iT>=kt-1 then lX=true else lX=false end;if lW<=ku+1 and lW>=ku-1 then lY=true else lY=false end;if lX and lY and lR then kt=nil;ku=nil;kv=true end else if lT.VectorToTarget then la(lj:normalize():project_on_plane(db))elseif fu>150 then la(fr)end;ln=0;if lT.VectorToTarget and fP then local l8,jL=ft.computeDistanceAndTime(fu,ex/3.6,jf,0,0,bi)if fK and lj:len()>15000+l8+fd then fi="Orbiting to Target"if fd-100<=ky.noAtmosphericDensityAltitude or fs>gp.timeToPeriapsis and gp.periapsis.altitude<ky.noAtmosphericDensityAltitude then fK=false end elseif fK or lj:len()<15000+l8+fd then i3="Orbit complete, proceeding with reentry"eY("orCom","OB")ba=fP.position;lH=true;ff=true;lT.VectorToTarget,lT.AutopilotAlign=false,false;fq.ToggleIntoOrbit()fq.BeginReentry()return end end;if gp.periapsis~=nil and gp.apoapsis~=nil and gp.eccentricity<1 and fd>lN*0.9 and fd<lN*1.4 then if gp.apoapsis~=nil then if gp.periapsis.altitude>=lN*0.99 and gp.apoapsis.altitude>=lN*0.99 and gp.periapsis.altitude<gp.apoapsis.altitude and gp.periapsis.altitude*1.05>=gp.apoapsis.altitude or fK then if fK then aR=false;fq.cmdThrottle(0)kt=0;if not lT.VectorToTarget then i3="Orbit complete"eY("orCom","OB")fq.ToggleIntoOrbit()end else kz=kz+1;if kz>=2 then fK=true end end else fi="Adjusting Orbit - OrbitHeight: "..lS;kw=true;fq.cmdCruise(lV*3.6+1)local lZ=lN-fd;if l_==nil then l_=pid.new(0.1,0,1*0.1)end;l_:inject(lZ-d7*bN(utils.smoothstep(2000-lZ,-2000,2000)^6*10,1,10))kt=bN(l_:get(),-60,60)end end else local m0=2.75;local m1=bE(bS(lU*m0))local m2=m1%50;if m2>0 then m1=m1-m2+50 end;aR=false;if fd<lN*0.8 then fi="Escaping planet gravity - OrbitHeight: "..lS;kt=utils.map(d7,200,0,-15,80)elseif fd>=lN*0.8 and fd<lN*1.15 then fi="Approaching orbital corridor - OrbitHeight: "..lS;m1=m1*0.75;kt=utils.map(d7,100,-100,-15,65)elseif fd>=lN*1.15 and fd<lN*1.5 then fi="Approaching orbital corridor - OrbitHeight: "..lS;m1=m1*0.75;if d7<0 or kw then kt=utils.map(fd,lN*1.5,lN*1.01,-30,0)else kt=utils.map(fd,lN*0.99,lN*1.5,0,30)end elseif fd>lN*1.5 then fi="Reentering orbital corridor - OrbitHeight: "..lS;kt=-65;local m3=utils.map(d7,-150,-400,1,0.55)m1=m1*m3 end;fq.cmdCruise(bF(m1))end end;if kt~=nil then if m4==nil then m4=pid.new(1*0.01,0,5*0.1)end;local m5=kt-iT;m4:inject(m5)local m6=bN(m4:get(),-0.5,0.5)ln=m6 end end;if aU and fh==0 and not iE then local function m7(jw,gp)bB.print(jw)aR=false;b3=false;aU=false;m8=false;b6="Aligning"fq.cmdThrottle(0)m9=false;i3=jw;eY("apCom","AP")if gp or iE then if gp and ma~=nil and not iE then if not fd or fd==0 then return end;lN=fd;kx=true end;fq.ToggleIntoOrbit()end end;local mb,mc=ba,false;if fP and fP.planetname~="Space"then b2=true;if not m8 then local md=(fP.position-f_.center):normalize()local me=md:project_on_plane((f_.center-gQ):normalize()):normalize()local mf=f_.center+me*(f_.radius+ma)local mg=fP.position+(fP.position-f_.center):normalize()*(ma-f_:getAltitude(fP.position))if(gQ-mf):len()<(gQ-mg):len()then mb=mf else mb=mg;b5=0 end;ba=mb;fq.showWayPoint(f_,ba)mc=true;m8=true end;b7=0 elseif fP and fP.planetname=="Space"then if not m8 then b7=0;mc=true;b2=true;m8=true;mb=fP.position+(gQ-fP.position):normalize()*M;ba=mb end elseif fP==nil then b7=0;if not m8 then local md=(gQ+fr*100000-f_.center):normalize()local me=md:project_on_plane((f_.center-gQ):normalize()):normalize()if me:len()<1 then md=(gQ+dp*100000-f_.center):normalize()me=md:project_on_plane((f_.center-gQ):normalize()):normalize()end;mb=f_.center+me*(f_.radius+ma)ba=mb;m8=true;mc=true;b2=true;fq.showWayPoint(f_,ba)end end;mh=(vec3(mb)-gQ):len()local fo,mi,mj=ly:getPlanetarySystem(0):castIntersections(gQ,fr:normalize(),function(l1)if l1.noAtmosphericDensityAltitude>0 then return l1.radius+l1.noAtmosphericDensityAltitude else return l1.radius+l1.surfaceMaxAltitude*1.5 end end)local fp=mi;if mj~=nil and mi~=nil then fp=math.min(mj,mi)end;if fp~=nil and fp<mh and fo.name==f_.name then mh=fp end;local lG=true;local mk=(f_.center-(gQ+vec3(fr):normalize()*mh)):len()-f_.radius;local f4=f5(mk)kh(ml,'{"label": "Projected Altitude", "value": "'..f4 ..'"}')local l8,mm;if not aV then l8,mm=kj(fu)else l8,mm=kl(fu)end;if fu>50 and b1 then local lj=vec3(mb)-gQ;local mn=bN(math.deg(kB(ls,fr:normalize(),lj:normalize()))*fu/500,-90,90)local mo=bN(math.deg(kB(h0,fr:normalize(),lj:normalize()))*fu/500,-90,90)if bE(mn)<20 and bE(mo)<20 then mn=mn*2;mo=mo*2 end;if bE(mn)<2 and bE(mo)<2 then mn=mn*2;mo=mo*2 end;local lr=-math.deg(kB(ls,dp,fr:normalize()))local lt=-math.deg(kB(h0,dp,fr:normalize()))if mp==nil then mp=pid.new(2*0.01,0,2*0.1)end;mp:inject(mo-lt)local mq=bN(mp:get(),-1,1)ln=ln+mq;if mr==nil then mr=pid.new(2*0.01,0,2*0.1)end;mr:inject(mn-lr)local ms=bN(mr:get(),-1,1)lm=lm+ms;mc=true;if bE(mn)>2 or bE(mo)>2 then if b6~="Adjusting Trajectory"then b6="Adjusting Trajectory"eY("apAdj","AP")end else if b6~="Accelerating"then b6="Accelerating"eY("apAcc","AP")end end elseif b1 and fu<=50 then la((mb-gQ):normalize())end;if mk<ma*1.5 then if fP and fP.planetname=="Space"then b5=0 elseif fP==nil then jL,b5=lA(f_):escapeAndOrbitalSpeed(mk)end end;if aU and not b1 and not b4 and not b3 then local fo,fp=fq.checkLOS((ba-gQ):normalize())if f_.name~=cc.name then if fo~=nil and f_.name~=fo.name and fp<mh then i3="Collision with "..fo.name.." in "..f5(fp).."\nClear LOS to continue."jp=5;kZ=true else kZ=false;i3=""end end end;if not kZ then if not b4 and not b3 and not mc then lG=la((mb-gQ):normalize())elseif aV and(b3 or b4)then lG=la(-vec3(fr):normalize())end end;if b1 then if not m9 then aR=false;fq.cmdThrottle(W)iY=bS(W,2)m9=true end;local mt=bA.getThrottle()if p then mt=iY end;local mu=99999;local jj=-vec3(bz.getWorldAcceleration()):dot(fr:normalize())local mv=bN(fr:dot((mb-gQ):normalize()),0,fu)if mv>0 or jj>0 then mu=ft.computeTravelTime(mv,jj,mh-l8)end;if iZ:len()>=V or mt==0 and m9 or X/4>mu then b1=false;if b6~="Cruising"then eY("apCru","AP")b6="Cruising"end;b4=true;fq.cmdThrottle(0)end;local mw=mh;if mw<=l8 or C and iJ<=l8+10000 and hL then if C and iJ<=l8+10000 and hL then if iJ<kn and iJ>2000 then fq.ToggleAutopilot()i3="Autopilot cancelled to prevent crossing PvP Line"aR=true;kn=iJ else kn=iJ;return end end;b1=false;if b6~="Braking"then eY("apBrk","AP")b6="Braking"end;b3=true;fq.cmdThrottle(0)m9=false end elseif b3 then if b6~="Orbiting to Target"then aR=true;lF=1 end;if aV then fq.cmdThrottle(1,true)end;local jL,lV=lA(f_):escapeAndOrbitalSpeed((gQ-cc.center):len()-cc.radius)local lj;if fP then lj=fP.position-gQ end;if fP and fP.planetname=="Space"and fu<50 then if#kA>0 then aR=false;fq.ToggleAutopilot()fq.ToggleAutopilot()return end;m7("Autopilot complete, arrived at space location")aR=true;lF=1 elseif fP and fP.planetname~="Space"and fu<=lV and(gp.apoapsis==nil or gp.periapsis==nil or gp.apoapsis.altitude<=0 or gp.periapsis.altitude<=0)then m7("Autopilot complete, commencing reentry")ba=fP.position;iE=true;fq.showWayPoint(f_,ba)elseif(fP and fP.planetname~="Space"or fP==nil)and gp.periapsis~=nil and gp.periapsis.altitude>0 and gp.eccentricity<1 or b6=="Circularizing"then if b6~="Circularizing"then eY("apCir","AP")b6="Circularizing"end;if fu<=lV then if fP then if fr:normalize():dot(lj:normalize())>0.4 then if b6~="Orbiting to Target"then eY("apOrb","OB")b6="Orbiting to Target"end;if not mx then aR=false;fq.showWayPoint(f_,fP.position)mx=true end else m7("Autopilot complete, proceeding with reentry")ba=fP.position;iE=true;fq.showWayPoint(f_,fP.position)mx=false end else m7("Autopilot completed, setting orbit",true)lF=0 end end elseif b6=="Circularizing"then m7("Autopilot complete, fixing Orbit",true)end elseif b4 then local mw=mh;if mw<=l8 or C and iJ<=l8+10000 and hL then if C and iJ<=l8+10000 and hL then if iJ<kn and iJ>2000 then fq.ToggleAutopilot()i3="Autopilot cancelled to prevent crossing PvP Line"aR=true;kn=iJ else kn=iJ;return end end;b1=false;if b6~="Braking"then eY("apBrk","AP")b6="Braking"end;b3=true end;local mt=bA.getThrottle()if p then mt=iY end;if mt>0 then b1=true;if b6~="Accelerating"then b6="Accelerating"eY("apAcc","AP")end;b4=false end else if lG then if not b2 and fP==nil or not b2 and fP and fP.planetname~="Space"then if not iE then ba=vec3(f_.center)+(ma+f_.radius)*h0;my=ls;mz=h0 end;b2=true elseif lG and not kZ then b1=true;if b6~="Accelerating"then b6="Accelerating"eY("apAcc","AP")end;if not m9 then fq.cmdThrottle(W,true)iY=bS(W,2)m9=true;aR=false end end end end elseif aU and(fP~=nil and fP.planetname~="Space"and fh>0)then i3="Autopilot complete, starting reentry"eY("apCom","AP")ba=fP.position;aR=false;b3=false;aU=false;m8=false;b6="Aligning"lF=0;fq.cmdThrottle(0)m9=false;aT=true;iE=true;fq.showWayPoint(f_,fP.position)end;if fe then iq=true;local mo=0;local gD=gQ+vec3(bA.getMasterPlayerRelativePosition())local mA=gD-gQ;local mB=vec3(mA):project_on(dp):len()local mC=vec3(mA):project_on(h0):len()local ei=bR(mB*mB+mC*mC)la(mA:normalize())local gX=40;local mD=ei<gX;local mE=100;local mF=bN((ei-gX)/2,10,mE)ln=0;local lG=bE(lm)<0.1;if lG and fu<mF and not mD then aR=false;mo=-20 else aR=true;mo=0 end;local mG=0;if bE(mo-iT)>mG then if mH==nil then mH=pid.new(2*0.01,0,2*0.1)end;mH:inject(mo-iT)local mq=mH:get()ln=mq end end;if aW or aX or aZ or bg or bj~=nil then local mI=bk;if mI then mI=mI*bN(fu/100,0.1,1)*fh else mI=bi end;if fh<0.01 then mI=bi end;local mJ=dp:project_on_plane(db):normalize():dot(fr)local mK=vec3(bz.getWorldAirFrictionAcceleration())local mL=mK:len()*jf;if mJ>100 then l8,mm=ft.computeDistanceAndTime(mJ,100,jf,0,0,mI)local mM,mN=ft.computeDistanceAndTime(100,0,jf,0,0,mI*0.55)l8=l8+mM else l8,mm=ft.computeDistanceAndTime(mJ,0,jf,0,0,mI*0.55)end;local lZ=b0-fd-d7;local mO=200+fu;if aZ or iE then mP=2000+fu end;local mQ=1;if aY then mQ=bN(fu/100,0.1,1)end;local mo=(utils.smoothstep(lZ,-mO,mO)-0.5)*2*J*mQ;if not aZ and not iE and not bg and dp:dot(fr:normalize())<0.99 then mo=(utils.smoothstep(lZ,-mO*bN(20-19*fh*10,1,20),mO*bN(20-19*fh*10,1,20))-0.5)*2*J*bN(2-fh*10,1,2)*mQ end;if not aW then mo=0 end;if bj~=nil then if dh and not bp then mo=bj else bj=nil end end;iq=true;local mR=ln;if aZ then local mS=bF(ex)local mT,mU=ft.computeDistanceAndTime(fu,mS/3.6,jf,0,0,bi-cc.gravity*9.8*jf)mT=mT==-1 and 5000 or mT;local mV=fd-(cc.noAtmosphericDensityAltitude+mT)local mW=fd>cc.noAtmosphericDensityAltitude+mT*1.35;if mW then mo=K;if fu<=mS/3.6 and fu>mS/3.6-10 and bE(fr:normalize():dot(dp))>0.9 and not cl then mX=false;fq.cmdThrottle(1)end elseif cl and not mW and not d5 then fq.cmdCruise(mS,true)end;if cl then if fu>mS/3.6 and not mW then aR=true else aR=false end else aR=false end;if d7>0 then aR=true end;if not lH then mo=-80;if fh>0.02 then i3="PARACHUTE DEPLOYED"aZ=false;aX=true;mo=0;iq=k end elseif cc.noAtmosphericDensityAltitude>0 and mW then iq=true elseif not mW then if not d5 and(cl or bO:getTargetSpeed(axisCommandId.longitudinal)~=mS)then fq.cmdCruise(mS)end;if fu<mS/3.6+1 then aR=false;lH=false;aZ=false;iq=true end end end;if fu>dG and not fg and not bg and not aX and q then la(vec3(fr))end;if eZ or(bg or fg)and bb>0 and fh>0.01 then local lj;if eZ then if type(eZ)=="table"then lj=eZ elseif eZ<3 and eZ>0 then lj=-db:cross(fr)*5000 elseif eZ>=3 then lj=db:cross(fr)*5000 elseif eZ<0 then lj=fr*25000 end elseif fP~=nil then lj=fP.position-gQ else lj=f_.center-gQ end;local mn=math.deg(kB(db:normalize(),fr,lj))*2;local g_=math.rad(bE(iV))if fu>aB and fh>0.01 then local mY=1000+fu;local mZ=(utils.smoothstep(lZ-d7*10,-mY,mY)-0.5)*2*J;local m_=bN(90-mZ,0,180)lB=bN(mn*2,-m_,m_)local n0=mn;mn=bN(bN(mn,-G*0.80,G*0.80)*math.cos(g_)+4*(iT-mo)*math.sin(math.rad(iV)),-G*0.80,G*0.80)local n1=1;if lB~=0 then n1=bE(g_/lB)end;n1=(90-bN(bE(lB-iV),0,90))/90;local n2=mo;if bE(iV)>90 then n2=-n2 end;mo=n1*bN(bN(n2*math.cos(g_),-H*0.8,H*0.8)+bE(bN(bE(n0)*math.sin(g_),-H*0.80,H*0.80)),-H*0.80,H*0.80)else lB=0;mn=bN(mn,-G*0.80,G*0.80)end;local n3=lr-mn;if eZ and bE(n3)<=0.0001 and(type(eZ)=="table"or type(eZ)~="table"and eZ<0 and bE(iV)<1)then if eZ==-2 then fq.ToggleAltitudeHold()end;eZ=nil;eY("180Off","BR")return end;if not eW and fu>aB and fh>0.01 then if n4==nil then n4=pid.new(2*0.01,0,2*0.1)end;n4:inject(n3)local ms=bN(n4:get(),-1,1)lm=lm+ms elseif d5 and dO>-1 or fu<aB then la(lj)elseif eW and fh>0.01 then if(lr<-G or lr>G)and fh>0.01 then la(fr)end;if(lt<-H or lt>H)and fh>0.01 then mo=bN(iT-lt,iT-H*0.80,iT+H*0.80)end end;if fP~=nil and not fg then local lI=cc:getAltitude(fP.position)local mV=lj:project_on_plane(db):len()fj=true;if not fg and not aZ and mV<=l8 and(fr:project_on_plane(db):normalize():dot(lj:project_on_plane(db):normalize())>0.99 or fw=="Finalizing Approach")then fw="Finalizing Approach"if#kA>0 then fq.ToggleAutopilot()fq.ToggleAutopilot()return end;fq.cmdThrottle(0)if aW then fq.ToggleAltitudeHold()bg=true end;aR=true elseif not aY then aR=false end;if fw=="Finalizing Approach"and(mJ<0.1 or mV<0.1 or n5~=nil and n5<mV)then if not eX then eY("bklOn","BL")aX=true end;bg=false;fw="Proceeding to Waypoint"fn=false end;n5=mV end elseif bg and fh==0 and b0>cc.noAtmosphericDensityAltitude and not(fg or aZ)then if fP~=nil and f_.name==cc.name then local lj=fP.position-gQ;local lI=cc:getAltitude(fP.position)local mV=bR(lj:len()^2-(fd-lI)^2)local mI=bk;if mI then l8,mm=ft.computeDistanceAndTime(fu,0,jf,0,0,mI/2)fj=true;if mV<=l8+fu*lq/2 and fr:project_on_plane(db):normalize():dot(lj:project_on_plane(db):normalize())>0.99 then if cc.hasAtmosphere then aR=false;aT=false;lH=true;iE=false;ff=true;aU=false;fq.BeginReentry()end end;n5=mV end end end;if fh==0 and(aW and b0>cc.noAtmosphericDensityAltitude)and not(fg or bp or aZ)then if not fK and not bp then lN=b0;kx=true;if bg then lT.VectorToTarget=true end;fq.ToggleIntoOrbit()bg=false;kv=true end end;if eW and fh>0.01 and dO==-1 and fu>aB and fw~="Finalizing Approach"then la(fr)mo=bN(iT-lt,iT-H*0.80,iT+H*0.80)end;ln=mR;local kK=-1;if aX then mo=0;local n6=false;local n7=30;if lC~=nil and lC>0 then local n8=bN(fh,0.4,2)local mI=bk*bN(fu/100,0.1,1)*n8;local n9=lC*n8+mI-j6;local na=mI/2-j6;local nb=fu-bR(bE(na/2)*20/(0.5*jf))*utils.sign(na)if nb<0 then nb=0 end;local nc;if fu>100 then local nd,jL=ft.computeDistanceAndTime(fu,100,jf,0,0,mI)local ne,jL=ft.computeDistanceAndTime(100,0,jf,0,0,bR(mI))nc=nd+ne else nc=ft.computeDistanceAndTime(fu,0,jf,0,0,bR(mI))end;if nc<20 then aR=false else local nf=0;if nb>100 then local ng,jL=ft.computeDistanceAndTime(nb,100,jf,0,0,n9)local nh,jL=ft.computeDistanceAndTime(100,0,jf,0,0,lC*n8+bR(mI)-j6)nf=ng+nh else nf,jL=ft.computeDistanceAndTime(nb,0,jf,0,0,lC*n8+bR(mI)-j6)end;nf=(nf+15+fu*lq)*1.1;local ni=fP~=nil and cc:getAltitude(fP.position)>0 and fP.safe;if ni then local lI=cc:getAltitude(fP.position)local nj=fd-lI-100;local lj=fP.position-gQ;local nk=bR(lj:len()^2-(fd-lI)^2)if nk>100 then ni=false elseif nj<=nf or nf==-1 then aR=true;n6=true else aR=false;n6=true end end;if not ni and o then if nf>=n7 then aR=true else aR=false end;n6=true end end end;if not cl then fq.cmdThrottle(0)end;bO:setTargetGroundAltitude(500)bO:activateGroundEngineAltitudeStabilization(500)br=true;kK=dO;if kK>-1 then iq=k;if fu<1 or fr:normalize():dot(db)<0 then aX=false;aW=false;bc=true;if f3 then by.control.extendLandingGears()eY("grOut","LG",1)end;bO:setTargetGroundAltitude(T)lJ=0;aR=true else aR=true end elseif fj and fr:normalize():dot(-da)<0.999 then aR=true elseif d7<-I and not n6 then aR=true elseif not n6 then aR=false end end;if aY or fg then local fo,mj,mi;if ba~=nil then fo,mj,mi=ly:getPlanetarySystem(0):castIntersections(gQ,(ba-gQ):normalize(),function(l1)return l1.radius+l1.noAtmosphericDensityAltitude end)end;if eX then if fd>=b0-50 then aY=false;if not aU and not bg then aR=true;fq.cmdThrottle(0)end else b0=antigrav.getBaseAltitude()end elseif bE(mo)<15 and fd/b0>0.75 then aY=false;if not fg then if cl and not p then by.control.cancelCurrentControlMasterMode()end elseif fg and fu<dG then aU=true;fg=false;aW=false;aY=false;fq.cmdThrottle(0)elseif fg then fq.cmdThrottle(0)aR=true end elseif fg and fh==0 and f_~=nil and(fo==nil or fo.name==f_.name)then aU=true;fg=false;aW=false;aY=false;if not cl then fq.cmdThrottle(0)end;b1=true end end;local nl=dO>-1;local nm=iT;if(bg or fg or eZ)and not nl and fu>aB and fh>0.01 then local g_=math.rad(bE(iV))nm=iT*bE(math.cos(g_))+lt*math.sin(g_)end;local nn=bN(mo-nm,-H*0.80,H*0.80)if fh<0.01 and bg then nn=bN(mo-nm,-85,J)elseif fh<0.01 then nn=bN(mo-nm,-J,J)end;if bE(iV)<5 or bg or eZ or aX or nl or aW then if mH==nil then mH=pid.new(5*0.01,0,5*0.1)end;mH:inject(nn)local mq=mH:get()ln=ln+mq end end;if antigrav~=nil and(antigrav and not l and fd<200000)then if bl==nil or bl<1000 then bl=1000 end;if no~=bl then no=bl;antigrav.setBaseAltitude(no)end end end;function ki.ToggleIntoOrbit()fK=false;kt=nil;ku=nil;kz=0;if fh==0 then if bp then eY("orOff","AP")bp=false;kv=false;ky=nil;iq=k;if aW then aW=false;aY=false end;lT.VectorToTarget=false;lT.AutopilotAlign=false;kx=false elseif dh then eY("orOn","AP")bp=true;iq=true;if ky==nil then ky=cc end;if aW then aW=false;aY=false end else i3="Unable to engage auto-orbit, not near a planet"end else bp=false;kv=false;ky=nil;iq=k;if aW then aW=false end;lT.VectorToTarget=false;lT.AutopilotAlign=false;kx=false end end;function ki.ToggleVerticalTakeoff()aW=false;if a_ then fj=true;aZ=false;aY=false;aX=true;iq=true;lJ=0;if d5 and dO==-1 then aX=false;aW=true;lJ=0;by:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)fq.cmdCruise(bF(ex))end else fK=false;bc=false;by.control.retractLandingGears()bO:setTargetGroundAltitude(S)aR=true end;a_=not a_ end;function ki.checkLOS(lb)local fo,mi,mj=ly:getPlanetarySystem(0):castIntersections(gQ,lb,function(l1)if l1.noAtmosphericDensityAltitude>0 then return l1.radius+l1.noAtmosphericDensityAltitude else return l1.radius+l1.surfaceMaxAltitude*1.5 end end)local fp=mi;if mj~=nil and mi~=nil then fp=math.min(mj,mi)end;if fp~=nil then return fo,fp else return nil,nil end end;function ki.ToggleAutopilot()local function np(bn)fn=false;bg=not bg;if bg then aV=false;if not aW and not bn then fq.ToggleAltitudeHold()end end;fw="Proceeding to Waypoint"end;local nq=false;if gd-ks<1.5 and fh>0 then if not nr then i3="No space engines detected, Orbital Hop not supported"return end;if cc.hasAtmosphere then if fh>0 then b0=cc.noAtmosphericDensityAltitude+O;eY("orH","OH")end;ks=-1;if aU or bg or bp then return end end else ks=gd end;m8=false;if(bb>0 or#kA>0)and not aU and not bg and not fg and not bp then if 0.5*by:maxForceForward()/bz.g()<jf then i3="WARNING: Heavy Loads may affect autopilot performance."jp=5 end;if#kA>0 and not ff then bb=kA[1]ie.UpdateAutopilotTarget()table.remove(kA,1)i3="Route Autopilot in Progress"local lj=fP.position-gQ;local mV=lj:project_on_plane(db):len()if mV>50000 and fP.planetname==cc.name then nq=true end end;ie.UpdateAutopilotTarget()fq.showWayPoint(f_,ba)if fP~=nil then bj=nil;bn=fP.planetname=="Space"if bn then eY("apSpc","AP")if fh~=0 then fg=true;fq.ToggleAltitudeHold()else aU=true end elseif cc.name==fP.planetname then fj=true;if fh>0 then if not bg then eY("vtt","AP")np(bn)if nq then b0=cc.noAtmosphericDensityAltitude+O end end else eY("apOn","AP")if not(f_.name==cc.name and fd<ma*1.5)then fK=false;aU=true elseif not d5 then if bp then fq.ToggleIntoOrbit()end;lN=cc.noAtmosphericDensityAltitude+O;kx=true;lT.AutopilotAlign=true;lT.VectorToTarget=true;kv=false;if not bp then fq.ToggleIntoOrbit()end end end else eY("apP","AP")aS=false;aT=false;if fh~=0 then fg=true;fq.ToggleAltitudeHold()else aU=true end end elseif fh==0 then if fP==nil and(f_.name==cc.name and dh)and not bp then mx=false;fK=false;kv=false;fq.ToggleIntoOrbit()else eY("apP","AP")aU=true;aS=false;aT=false;b2=false;fe=false;aW=false;aX=false;aZ=false;aY=false;m9=false;bj=nil;mx=false end else eY("apP","AP")fg=true;fq.ToggleAltitudeHold()end else eY("apOff","AP")fq.ResetAutopilots(1)end end;function ki.routeWP(ns,nt,nu)if nu then if nu==1 then kA={}kA=fZ(kA,bu)if#kA>0 then i3="Route Loaded"else i3="No Saved Route found on Databank"end;return kA else bu={}bu=fZ(bu,kA)i3="Route Saved"nv()return end end;if ns then return kA end;if nt then kA={}i3="Current Route Cleared"else kA[#kA+1]=bb;i3="Added "..fP.name.." to route. "nw("Added "..fP.name.." to route. Total Route: "..json.encode(kA))end;return kA end;function ki.cmdThrottle(et,nx)if bO:getAxisCommandType(0)~=axisCommandType.byThrottle and not nx then by.control.cancelCurrentControlMasterMode()end;bO:setThrottleCommand(axisCommandId.longitudinal,et)iY=bN(bS(et*100,0)/100,-1,1)ny=nil end;function ki.cmdCruise(et,nx)if bO:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not nx then by.control.cancelCurrentControlMasterMode()end;bO:setTargetSpeedCommand(axisCommandId.longitudinal,et)ny=et end;function ki.ToggleLockPitch()if bj==nil then eY("lkPOn","LP")if not j2 then bj=iT else bj=L end;aY=false;aW=false;aX=false else eY("lkPOff","LP")bj=nil end end;function ki.ToggleAltitudeHold()if gd-kr<1.5 then if cc.hasAtmosphere then if fh>0 then b0=cc.spaceEngineMinAltitude-0.01*cc.noAtmosphericDensityAltitude;eY("11","EP")else if dh then b0=cc.noAtmosphericDensityAltitude+O;lN=b0;kx=true;if not bp then fq.ToggleIntoOrbit()end;kv=true end end;kr=-1;if aW or bp or a_ then return end end else kr=gd end;if dh and fh==0 then lN=fd;kx=true;kv=true;fq.ToggleIntoOrbit()if bp then kr=gd else kr=0 end;return end;aW=not aW;aX=false;aZ=false;if aW then aU=false;aT=false;aS=false;fe=false;iq=true;bj=nil;fK=false;if dO~=-1 and fu<20 then eY("lfs","LS")aY=true;if kr>-1 then b0=fd+R end;bc=false;by.control.retractLandingGears()aR=true;bO:setTargetGroundAltitude(S)if aQ and iD then fq.ToggleVerticalTakeoff()end else eY("altOn","AH")aY=false;if kr>-1 then if dh then b0=fd end end;if a_ then fq.ToggleVerticalTakeoff()end end;if fg then b0=100000 end else eY("altOff","AH")if bp then fq.ToggleIntoOrbit()end;if a_ then fq.ToggleVerticalTakeoff()end;iq=k;aY=false;bg=false;kr=0 end end;function ki.ResetAutopilots(ki)if ki then fg=false;aU=false;b2=false;m9=false;b0=fd;m8=false end;bg=false;aY=false;aZ=false;aT=false;aX=false;nz=false;eZ=nil;if not eX then aW=false;bj=nil end;if a_ then fq.ToggleVerticalTakeoff()end;if bp then fq.ToggleIntoOrbit()end;iq=k;iE=false;ff=false;lJ=0 end;function ki.BrakeToggle()aR=not aR;if aX then aX=false;iq=k end;if aR then eY("bkOn","B",1)fq.ResetAutopilots()else eY("bkOff","B",1)end end;function ki.BeginReentry()if aZ then i3="Re-Entry cancelled"eY("reOff","RE")aZ=false;iq=k;aW=false elseif not cc.hasAtmosphere then i3="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"jp=5 elseif not lH then aZ=true;if bO:getAxisCommandType(0)~=nA.cruise then by.control.cancelCurrentControlMasterMode()end;iq=true;aR=false;i3="Beginning Parachute Re-Entry - Strap In.  Target speed: "..ex;eY("par","RE")else aZ=true;aW=true;iq=true;aR=false;b0=cc.surfaceMaxAltitude+U;if b0>cc.spaceEngineMinAltitude then b0=cc.spaceEngineMinAltitude-0.01*cc.noAtmosphericDensityAltitude end;local nB=f5(b0)i3="Beginning Re-entry.  Target speed: "..ex.." Target Altitude: "..nB;eY("glide","RE")fq.cmdCruise(bF(ex))end;aY=false end;function ki.ToggleAntigrav()if antigrav and not l then if eX then eY("aggOff","AG")antigrav.deactivate()antigrav.hide()else if bl==nil then bl=fd end;if bl<1000 then bl=1000 end;eY("aggOn","AG")antigrav.activate()antigrav.show()end end end;function ki.changeSpd(nC)local nD=1;if nC then nD=-1 end;if not j2 then if p and not k6 and nE then local nF=iY;iY=bS(bN(iY+nD*au/100,-1,1),2)if iY>=0 and nF<0 then iY=0;nE=false end elseif k6 then if fh>0 or aZ then ex=bN(ex+nD*au,0,P)elseif aU then V=bN(V+nD*au/3.6*100,0,8333.00)end else bO:updateCommandFromActionStart(axisCommandId.longitudinal,nD*au)end else if aU or bg or fg or bp then iy=iy+1*nD*-1;if iy>#fO then iy=1 end;if iy<1 then iy=#fO end else if not nC then nD=1 else nD=nil end;ie.adjustAutopilotTargetIndex(nD)end end end;dO=kF()return ki end end;package.preload['ArchHUD:Modules/radarclass']=function(...)function nG(bz,bB,library,radar_1,radar_2,bE,bP,bR,bT,nH,nI)local nJ={}local nK={}local nL={XS=13,S=27,M=55,L=110,XL=221}local nM={}local nN;local gW;local gR;local nO;local nP;local nQ={}local nR="Atmo"local nS;local function nT()local function nU(nV,nW,nX,nY,nZ,n_,o0,o1)nW,nY,n_,o1=vec3(nW),vec3(nY),vec3(n_),vec3(o1)local o2,o3,o4=nV*nV,nX*nX,nZ*nZ;local o5=nY-nW;local o6=o5:normalize()local o7=o5:len()local o8=n_-nW;local o9=(o8-o8:project_on(o6)):normalize()local oa,ob=o8:dot(o6),o8:dot(o9)local oc=oa*oa+ob*ob;local od=o6:cross(o9)local cF=(o2-o3+o7*o7)/(2*o7)local dE=(o2-o4+oc-2*oa*cF)/(2*ob)local oe=o2-cF^2-dE^2;local of=bR(oe)local og=nW+o6*cF+o9*dE+od*of;local oh=nW+o6*cF+o9*dE-od*of;if bE((o1-og):len()-o0)<bE((o1-oh):len()-o0)then return og else return oh end end;local function oi()local function oj()local ok=bz.getConstructWorldOrientationRight()local o5=bz.getConstructWorldOrientationForward()local o8=bz.getConstructWorldOrientationUp()local ol=library.systemResolution3(ok,o5,o8,{1,0,0})local om=library.systemResolution3(ok,o5,o8,{0,1,0})local on=library.systemResolution3(ok,o5,o8,{0,0,1})return function(oo)return library.systemResolution3(ol,om,on,oo)end end;local op=oj()local oq=bz.getConstructWorldPos()local gD=bz.getElementPositionById(1)local os={gD[1],gD[2],gD[3]}local ot=op(os)local ou={oq[1]-ot[1],oq[2]-ot[2],oq[3]-ot[3]}return ou end;local function ov(ow,hg,ox)local oy=ow.pts;local dP=#oy;local oz=ow.ref;if dP>3 then local oA,oB,oC,oD=oy[dP],oy[dP-1],oy[dP-2],oy[dP-3]ow.ref=ox;local gD=nU(oA[1],oA[2],oB[1],oB[2],oC[1],oC[2],oD[1],oD[2])local cF,dE,of=gD.x,gD.y,gD.z;if cF==cF and dE==dE and of==of then cF=cF+oz[1]dE=dE+oz[2]of=of+oz[3]local oE=vec3(cF,dE,of)if not ow.lastPos then ow.center=oE elseif(ow.lastPos-oE):len()<2 then ow.center=oE;ow.skipCalc=true end;ow.lastPos=oE end;ow.pts={}else local oF={ox[1]-oz[1],ox[2]-oz[2],ox[3]-oz[3]}oy[dP+1]={hg,oF}end end;if radar_1 or radar_2 then id.assignRadar()end;if nQ[1]then nN=#nQ[1].getConstructIds()local oG=nQ[1].getData()local oH=oG:gmatch('{"constructId[^}]*}[^}]*}')if nN>0 then local ox=oi()local jq,oI=0,0;nP,nO=0,0;for ce in oH do local oJ,ei,h6=ce:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local oK=nL[h6]ei=nH(ei)if nQ[1].hasMatchingTransponder(oJ)==1 then table.insert(nK,oJ)end;local oL=nQ[1].getConstructType(oJ)if A then if oK>27 or oL=="static"or oL=="space"then nP=nP+1;local cO=nQ[1].getConstructName(oJ)local ow=oM[oJ]if ow==nil then oK=oK+nI;oM[oJ]={pts={},ref=ox,name=cO,i=0,radius=oK,skipCalc=false}ow=oM[oJ]end;if not ow.skipCalc then ov(ow,ei,ox)oI=oI+1 end;if ow.center then table.insert(nM,ow)end end;jq=jq+1;if dh and jq>700 or oI>70 or(not dh and jq>300 or oI>30)then coroutine.yield()jq,oI=0,0 end end end;nO=#nM;if nO>0 and fu>20 then local l1,l2,l3,oN;local oO=0;local oP=ly:getPlanetarySystem(0)oN=fr:normalize()while oO<nO do coroutine.yield()local oQ={table.unpack(nM,oO,math.min(oO+75,nO))}l1,l2,l3=oP:castIntersections(gQ,oN,nil,nil,oQ,true)if l1 and l3 then l0={l1,l2,l3}break end;oO=oO+75 end;if not l1 then l0=nil end else l0=nil end;nM={}gW=oG:find('identifiedConstructs":%[%]')else gR=oG:find('worksInEnvironment":false')end end end;local function oR()if nQ[1]then nR="Atmo"if nQ[1].getData():find('worksInAtmosphere":false')then nR="Space"end end end;function nJ.pickType()oR()end;function nJ.assignRadar()if radar_1 and nQ[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then nQ[1]=radar_2 end;if nQ[1]==radar_2 then oR()end elseif radar_2 and nQ[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then nQ[1]=radar_1 end;if nQ[1]==radar_1 then oR()end end end;function nJ.UpdateRadar()local oS=coroutine.status(nS)if oS=="suspended"then local et,oT=coroutine.resume(nS)if oT then bB.print("ERROR UPDATE RADAR: "..oT)end elseif oS=="dead"then nS=coroutine.create(nT)local et,oT=coroutine.resume(nS)end end;function nJ.GetRadarHud(jv,ju,js,jt)local oU=nK;local cm,jw;nK={}local dx=nO or 0;if nN>0 then if A then jw=dx.."/"..nP.." Plotted : "..nN-nP.." Ignored"else jw="Radar Contacts: "..nN end;cm=bT(js,jt,jw,"pbright txtbig txtmid")if#nK>0 then cm=cm..bT(jv,ju,"Friendlies In Range","pbright txtbig txtmid")for fS,ce in pairs(nK)do ju=ju+20;cm=cm..bT(jv,ju,nQ[1].getConstructName(ce),"pdim txtmid")end end;if gW==nil and jr==nil then jy=1;id.ToggleRadarPanel()end;if gW~=nil and jr~=nil then id.ToggleRadarPanel()end;if oV==nil then id.ToggleRadarPanel()end else if gR then cm=bT(js,jt,nR.." Radar: Jammed","pbright txtbig txtmid")else cm=bT(js,jt,"Radar: No "..nR.." Contacts","pbright txtbig txtmid")end;if oV~=nil then jy=0;id.ToggleRadarPanel()end end;return cm end;function nJ.GetClosestName(cO)if nQ[1]then local oJ,jL=nQ[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if oJ~=nil and oJ~=""then cO=cO.." "..nQ[1].getConstructName(oJ)end end;return cO end;function nJ.ToggleRadarPanel()if oV~=nil and jy==0 then bP(oV)oV=nil;if jr~=nil then bP(jr)jr=nil end else if jy==1 then bP(oV)oV=nil;_autoconf.displayCategoryPanel(nQ,1,"Periscope","periscope")jr=_autoconf.panels[_autoconf.panels_size]end;if oV==nil then _autoconf.displayCategoryPanel(nQ,1,"Radar","radar")oV=_autoconf.panels[_autoconf.panels_size]end;jy=0 end end;nQ[1]=nil;if radar_1 then nQ[1]=radar_1;oR()end;nS=coroutine.create(nT)return nJ end end;package.preload['ArchHUD:Modules/controlclass']=function(...)function oW(by,bz,bA,bB,bC,vBooster,hover,antigrav,bD,dbHud_2,bK,bO,bQ,oX,bP,bS,oY,nH,bN)local oZ={}local o_=true;local p0=5;local p1=5;local p2=p0;local p3=p1;function oZ.startControl(p4)local function p5(nC)local nD=1;local function p6(p7,nC)local p8={cc.surfaceMaxAltitude+100,cc.spaceEngineMinAltitude-0.01*cc.noAtmosphericDensityAltitude,cc.noAtmosphericDensityAltitude+O,cc.radius*(N-1)+cc.noAtmosphericDensityAltitude}local p9=p7;for jL,ce in ipairs(p8)do if nC and p9>ce then p7=ce elseif p7<ce and not nC then p7=ce;break end end;return p7 end;if nC then nD=-1 end;if not l and eX then if j2 and nC then bl=1000 elseif bl~=nil then bl=bl+nD*p1;if bl<1000 then bl=1000 end;if aW and bl<b0+10 and bl>b0-10 then b0=bl end else bl=no+nD*100 end elseif aW or a_ or bp then if bp then if j2 then lN=p6(lN,nC)else lN=lN+nD*p0 end;if lN<cc.noAtmosphericDensityAltitude then lN=cc.noAtmosphericDensityAltitude end else if j2 and d5 then b0=p6(b0,nC)else b0=b0+nD*p0 end end else bO:updateTargetGroundAltitudeFromActionStart(nD*1.0)end end;local function pa(pb)if not d5 then i3="Flight Assist in Atmo only"return end;local pc=type(pb)if eZ==nil then if pc=="table"then if aU or bg then fq.ToggleAutopilot()end;eY("180On","BR")elseif pb==1 then eY("bnkLft","BR")else eY("bnkRht","BR")end;if not aW and not aU and not bg then fq.ToggleAltitudeHold()if pc~="table"then pb=pb+1 end end;eZ=pb else eY("180Off","BR")eZ=nil end end;if p4=="gear"then bc=not bc;if bc then bg=false;bj=nil;fq.cmdThrottle(0)if vBooster or hover then if d5 and dO==-1 then eY("bklOn","BL")fj=true;aZ=false;aY=false;a_=false;aW=false;aX=true;iq=true;bc=false else if f3 then eY("grOut","LG",1)by.control.extendLandingGears()end;bO:setTargetGroundAltitude(T)if d5 then aR=true end end end;if f3 and not aX and not(vBooster or hover)then eY("grOut","LG",1)by.control.extendLandingGears()end else if f3 then eY("grIn","LG",1)by.control.retractLandingGears()end;bO:setTargetGroundAltitude(S)end elseif p4=="light"then if by.control.isAnyHeadlightSwitchedOn()==1 then by.control.switchOffHeadlights()else by.control.switchOnHeadlights()end elseif p4=="forward"then pd=pd-1 elseif p4=="backward"then if k6 then pa(-fr*5000)else pd=pd+1 end elseif p4=="left"then if k6 then pa(1)else pe=pe-1 end elseif p4=="right"then if k6 then pa(3)else pe=pe+1 end elseif p4=="yawright"then pf=pf-1 elseif p4=="yawleft"then pf=pf+1 elseif p4=="straferight"then bO:updateCommandFromActionStart(axisCommandId.lateral,1.0)bo=1 elseif p4=="strafeleft"then bO:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bo=-1 elseif p4=="up"then lJ=lJ+1;bO:deactivateGroundEngineAltitudeStabilization()bO:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif p4=="down"then lJ=lJ-1;bO:deactivateGroundEngineAltitudeStabilization()bO:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif p4=="groundaltitudeup"then p5()elseif p4=="groundaltitudedown"then p5(true)elseif p4=="option1"then pg=false;if k6 and j2 then local ph=""for F=1,#fA do ph=ph.."| Name: "..bB.getPlayerName(fA[F]).." Mass: "..bS(bz.getBoardedPlayerMass(fA[F])/1000,1).."t "end;bB.print("Onboard: "..ph)return end;ie.adjustAutopilotTargetIndex()elseif p4=="option2"then pg=false;if k6 and j2 then for F=1,#fA do bz.forceDeboard(fA[F])end;i3="Deboarded All Passengers"return end;ie.adjustAutopilotTargetIndex(1)elseif p4=="option3"then local function pi()o_=not o_;if not o_ then eY("wid","DH")bA.show()bz.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(pj,atmofueltank_size,"Atmo Fuel","fuel_container")pk=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(pl,spacefueltank_size,"Space Fuel","fuel_container")pm=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(pn,rocketfueltank_size,"Rocket Fuel","fuel_container")po=_autoconf.panels[_autoconf.panels_size]end;pp=bB.createWidgetPanel("Docking")pq=bB.createWidget(pp,"parenting")bB.addDataToWidget(bA.getDataId(),pq)pr=bB.createWidgetPanel("Core combat stress")ps=bB.createWidget(pr,"core_stress")bB.addDataToWidget(bz.getDataId(),ps)if bD~=nil then bD.show()end else eY("hud","DH")bA.hide()bz.hide()if pk~=nil then bP(pk)pk=nil end;if pp~=nil then bP(pp)pp=nil end;if pr~=nil then bP(pr)pr=nil end;if pm~=nil then bP(pm)pm=nil end;if po~=nil then bP(po)po=nil end;if bD~=nil then bD.hide()end end end;pg=false;if k6 and j2 then local ph=""for F=1,#pt do ph=ph.."| ID: "..pt[F].." Mass: "..bS(bz.getDockedConstructMass(pt[F])/1000,1).."t "end;bB.print("Docked Ships: "..ph)return end;if t then if s then s=false else s=true end end;pi()elseif p4=="option4"then pg=false;if k6 and j2 then for F=1,#pt do bz.forceUndock(pt[F])end;i3="Undocked all ships"return end;eZ=nil;fq.ToggleAutopilot()elseif p4=="option5"then pg=false;fq.ToggleLockPitch()elseif p4=="option6"then pg=false;if k6 and j2 then if bD then local pu=bD.getVentingCooldown()if pu>0 then i3="Cannot vent again for "..pu.." seconds"return end;if bD.getShieldHitpoints()<bD.getMaxShieldHitpoints()then bD.startVenting()i3="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else i3="Shields already at max hitpoints"end;return else i3="No shield found"return end end;fq.ToggleAltitudeHold()elseif p4=="option7"then pg=false;if k6 and j2 then if bD then bD.toggle()return else i3="No shield found"return end end;A=not A;if A then i3="Collision System Enabled"else i3="Collision System Secured"end elseif p4=="option8"then pg=false;if k6 and j2 then if bb>0 and fP~=nil then fq.routeWP()else i3="Select a saved wp on IPH to add to or remove from route"end;return end;br=not br;if not br then i3="DeCoupled Mode - Ground Stabilization off"bO:deactivateGroundEngineAltitudeStabilization()eY("gsOff","GS")else i3="Coupled Mode - Ground Stabilization on"bO:activateGroundEngineAltitudeStabilization(pv)by:setEngineForceCommand('hover',vec3(),1)eY("gsOn","GS")end elseif p4=="option9"then pg=false;if k6 and j2 then bO:resetCommand(axisCommandId.longitudinal)bO:resetCommand(axisCommandId.lateral)bO:resetCommand(axisCommandId.vertical)fq.cmdThrottle(0)bA.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()e_=gyro.getState()==1;if e_ then eY("gyOn","GA")else eY("gyOff","GA")end else i3="No gyro found"end elseif p4=="lshift"then iC=false;if k6 then j2=true end;if bQ()==1 then j2=true;b8=bQ()oX(1)elseif bK()==1 and u then j2=true;k8=false;k7=false end elseif p4=="brake"then if aP or k6 then fq.BrakeToggle()elseif not aR then fq.BrakeToggle()else aR=true end elseif p4=="lalt"then pg=true;k6=true;if bK()==0 and not d and b=="keyboard"then oX(1)end elseif p4=="booster"then if i then by:toggleBoosters()elseif not f9 then if not pw then by:toggleBoosters()pw=true end;f9=true else if pw then by:toggleBoosters()pw=false end;f9=false end elseif p4=="stopengines"then local function px()if gd-py<1.5 then eY("clear","CA")b1=false;b3=false;b4=false;aU=false;b2=false;b6="Aligning"aS=false;aT=false;eZ=nil;aW=false;aZ=false;aX=false;aR=false;aY=false;a_=false;fe=false;m9=false;iE=false;fg=false;lH=false;iq=k;bg=false;aV=false;e_=false;bj=nil;bp=false end end;px()py=gd;if bO:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if iY~=0 then bO:resetCommand(axisCommandId.longitudinal)fq.cmdThrottle(0)else fq.cmdThrottle(100)end else if bO:getTargetSpeed(axisCommandId.longitudinal)~=0 then bO:resetCommand(axisCommandId.longitudinal)else if d5 then fq.cmdCruise(P)else fq.cmdCruise(V*3.6)end end end elseif p4=="speedup"then fq.changeSpd()elseif p4=="speeddown"then fq.changeSpd(true)elseif p4=="antigravity"and not l then if antigrav~=nil then fq.ToggleAntigrav()else i3="No antigrav found"end end end;function oZ.stopControl(p4)local function pz()if not l and eX then p3=p1 end;if aW or a_ or bp then p2=p0 end end;if p4=="forward"then pd=0 elseif p4=="backward"then pd=0 elseif p4=="left"then if eZ then if eZ==2 then eZ=-2 else eZ=-1 end end;pe=0 elseif p4=="right"then if eZ then if eZ==4 then eZ=-2 else eZ=-1 end end;pe=0 elseif p4=="yawright"then pf=0 elseif p4=="yawleft"then pf=0 elseif p4=="straferight"then bO:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bo=0 elseif p4=="strafeleft"then bO:updateCommandFromActionStop(axisCommandId.lateral,1.0)bo=0 elseif p4=="up"then lJ=0;bO:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if br then bO:activateGroundEngineAltitudeStabilization(pv)by:setEngineForceCommand('hover',vec3(),1)end elseif p4=="down"then lJ=0;bO:updateCommandFromActionStop(axisCommandId.vertical,1.0)if br then bO:activateGroundEngineAltitudeStabilization(pv)by:setEngineForceCommand('hover',vec3(),1)end elseif p4=="groundaltitudeup"then pz()pg=false elseif p4=="groundaltitudedown"then pz()pg=false elseif p4=="lshift"then if bQ()==1 then jI=0;jJ=0;oX(b8)elseif bK()==1 and u then k8=false;k7=false end;j2=false elseif p4=="brake"then if not aP and not k6 then if aR then fq.BrakeToggle()else aR=false end end elseif p4=="lalt"then if bK()==0 and d then if pg then if bQ()==1 then oX(0)else oX(1)end else pg=true end elseif bK()==0 and not d and b=="keyboard"then oX(0)end;k6=false end end;function oZ.loopControl(p4)local function pA(nC)local nD=1;if nC then nD=-1 end;if not l and eX then if bl~=nil then bl=bl+nD*p3;if bl<1000 then bl=1000 end;if aW and bl<b0+10 and bl>b0-10 then b0=bl end;p3=bN(p3*1.05,p1,50)aR=false else bl=no+nD*100;aR=false end elseif aW or a_ or bp then if bp then lN=lN+nD*p2;if lN<cc.noAtmosphericDensityAltitude then lN=cc.noAtmosphericDensityAltitude end else b0=b0+nD*p2 end;p2=bN(p2*1.05,p0,50)else bO:updateTargetGroundAltitudeFromActionLoop(nD*1.0)end end;local function pB(nC)local nD=1;if nC then nD=-1 end;if not j2 then if p and not k6 then iY=bN(iY+nD*av/100,-1,1)else bO:updateCommandFromActionLoop(axisCommandId.longitudinal,nD*av)end end end;if p4=="groundaltitudeup"then if not j2 then pA()end elseif p4=="groundaltitudedown"then if not j2 then pA(true)end elseif p4=="speedup"then pB()elseif p4=="speeddown"then pB(true)end end;function oZ.inputTextControl(nB)local function pC(pD,gD,e2)local function pE(gD)local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local pF='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local pG,oJ,kU,kV,d4=oY(gD,pF)if pG=="0"and oJ=="0"then return vec3(nH(kU),nH(kV),nH(d4))end;kV=math.rad(kV)kU=math.rad(kU)local cc=bC[nH(pG)][nH(oJ)]local pH=math.cos(kU)local pI=vec3(pH*math.cos(kV),pH*math.sin(kV),math.sin(kU))return cc.center+(cc.radius+d4)*pI end;local ic=pE(gD)return ie.AddNewLocation(pD,ic,e2)end;local F;local pJ,pK=nil,nil;local pL="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp"F=string.find(nB," ")pJ=nB;if F~=nil then pJ=string.sub(nB,0,F-1)pK=string.sub(nB,F+1)end;if pJ=="/help"or pJ=="/commands"then for jo in string.gmatch(pL,"([^\n]+)")do bB.print(jo)end;return elseif pJ=="/setname"then if pK==nil or pK==""then i3="Usage: ah-setname Newname"return end;if bb>0 and fP~=nil then ie.UpdatePosition(pK)else i3="Select a saved target to rename first"end elseif bD and pJ=="/resist"then if not bD then i3="No shield found"return elseif pK==nil or bD.getResistancesCooldown()>0 then i3="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local pF=dx..', '..dx..', '..dx..', '..dx;local pM,pN,pO,pP=oY(pK,pF)if pP==nil or pM+pN+pO+pP>0.6 then i3="Improperly formatted or total exceeds 0.6"return end;if bD.setResistances(pM,pN,pO,pP)==1 then i3="Shield Resistances set"else i3="Resistance setting failed."end elseif pJ=="/addlocation"or string.find(nB,"::pos")~=nil then local e2=false;local pD="0-Temp"if pK==nil or pK==""then pK=pJ;e2=true end;F=string.find(pK,"::")if not e2 then pD=string.sub(pK,1,F-2)end;local gD=string.sub(pK,F)pC(pD,gD,e2)elseif pJ=="/agg"then if pK==nil or pK==""then i3="Usage: /agg targetheight"return end;pK=nH(pK)if pK<1000 then pK=1000 end;bl=pK;i3="AGG Target Height set to "..pK elseif pJ=="/G"then if pK==nil or pK==""then i3="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pK=="dump"then for fS,ce in pairs(i1())do if type(ce.get())=="boolean"then if ce.get()==true then bB.print(fS.." true")else bB.print(fS.." false")end elseif ce.get()==nil then bB.print(fS.." nil")else bB.print(fS.." "..ce.get())end end;return end;F=string.find(pK," ")local pQ=string.sub(pK,0,F-1)local pR=string.sub(pK,F+1)for fS,ce in pairs(i1())do if fS==pQ then i3="Variable "..pQ.." changed to "..pR;local pS=type(ce.get())if pS=="number"then pR=nH(pR)if fS=="AtmoSpeedLimit"then ex=pR end elseif pS=="boolean"then if string.lower(pR)=="true"then pR=true else pR=false end end;ce.set(pR)return end end;i3="No such global variable: "..pQ elseif pJ=="/deletewp"then if bb>0 and fP~=nil then ie.ClearCurrentPosition()else i3="Select a custom wp to delete first in IPH"end elseif pJ=="/copydatabank"then if dbHud_2 then nv(true)else i3="Spare Databank required to copy databank"end elseif pJ=="/iphWP"then if bb>0 then bB.print(fq.showWayPoint(f_,ba,true))i3="::pos waypoint shown in lua chat"else i3="No target selected in IPH"end end end;return oZ end end;pT(function()require("autoconf/custom/archhud/globals")end,function(pU)require('ArchHUD:Modules/globals')end)local bB=system;local bz=core;local bA=unit;local by=Navigator.new(bB,bz,bA)local bC=require("atlas")pT(function()require("autoconf/custom/archhud/hudclass")end,function(pU)require('ArchHUD:Modules/hudclass')end)pT(function()require("autoconf/custom/archhud/apclass")end,function(pU)require('ArchHUD:Modules/apclass')end)pT(function()require("autoconf/custom/archhud/radarclass")end,function(pU)require('ArchHUD:Modules/radarclass')end)pT(function()require("autoconf/custom/archhud/controlclass")end,function(pU)require('ArchHUD:Modules/controlclass')end)script={}VERSION_NUMBER=1.7061;local bE=math.abs;local bF=math.floor;local bG=string.format;local bH=json.decode;local pV=json.encode;local pW=bz.getElementMaxHitPointsById;local bI=bA.getAtmosphereDensity;local bJ=bz.getElementMassById;local bK=by.control.isRemoteControlled;local bL=math.atan;local oY=string.match;local bM=bB.getTime;local bN=utils.clamp;local bO=by.axisCommandManager;local bP=bB.destroyWidgetPanel;local kh=bB.updateData;local pX=bB.addDataToWidget;local oX=bB.lockView;local bQ=bB.isViewLocked;local bR=math.sqrt;local nH=tonumber;local function bS(dx,pY)local nD=10^(pY or 0)return bF(dx*nD+0.5)/nD end;gd=bM()py=bM()local nI=13;iK=a6;iM=a8;iL=a7;iY=0;eS=0;ev=false;ew=0;mX=false;m9=false;dG=55;lH=false;f3=false;pd=0;ln=0;lm=0;pe=0;pf=0;lF=0;lw=0;fe=false;j2=false;i3="empty"f9=false;l8=0;mm=0;local pZ=0;local p_=0;f_=nil;gH=0;gI=0;lJ=0;jI=0;jJ=0;jp=3;ei=0;j0=""iE=false;fg=false;ff=false;dO=-1;local q0=""d5=bI()>0;fh=bI()fd=bz.getAltitude()local q1=bz.getElementIdList()kd=bM()jf=bz.getConstructMass()nE=false;e_=nil;gC=[[rgb(]]..bF(iK+0.5)..","..bF(iL+0.5)..","..bF(iM+0.5)..[[)]]hq=[[rgb(]]..bF(iK*0.9+0.5)..","..bF(iL*0.9+0.5)..","..bF(iM*0.9+0.5)..[[)]]local q2={}j1=""cf=a3;ch=a4;jz={}jA={}jB={}local q3=0;iF=false;local q4=nil;ly=nil;ft=nil;lC=nil;lA=nil;gG=nil;ie=nil;fq=nil;id=nil;q5=nil;k7=false;k8=false;iq=k;local q6=T;eW=false;lB=0;ex=P;lK=0;fi=nil;lT={VectorToTarget=false}lN=0;fK=false;local q7=false;lL=false;nr=false;ls=vec3(bz.getConstructWorldOrientationUp())dp=vec3(bz.getConstructWorldOrientationForward())h0=vec3(bz.getConstructWorldOrientationRight())iZ=vec3(bz.getVelocity())fr=vec3(bz.getWorldVelocity())fu=vec3(fr):len()db=vec3(bz.getWorldVertical())d7=-db:dot(fr)gQ=vec3(bz.getConstructWorldPos())iD=false;eX=false;ny=nil;cl=true;iT=0;iV=0;fO={}hL=false;iJ=50000;eZ=nil;oM={}dh=bA.getClosestPlanetInfluence()>0 or fd>0 and fd<200000;fn=false;l0=nil;iC=false;iy=0;fA=nil;pt=nil;gL={}gK=90;i4=s;function nw(jw)bB.print(gd..": "..jw)end;function eY(q8,q9,type)if type==nil and not y or type~=nil and not z or c=="archHUD"then return end;if type~=nil then if type==2 then bB.logInfo("sound_loop|audiopacks/"..c.."/"..q8 .."|"..q9 .."|"..as)else bB.logInfo("sound_notification|audiopacks/"..c.."/"..q8 .."|"..q9 .."|"..as)end else bB.logInfo("sound_q|audiopacks/"..c.."/"..q8 .."|"..q9 .."|"..as)end end;function fZ(qa,qb)for fS,ce in pairs(qb)do if type(fS)=="string"then qa[fS]=ce else qa[#qa+1]=qb[fS]end end;return qa end;function i1(qc)local qd={}if not qc then fZ(qd,E)fZ(qd,a2)fZ(qd,at)fZ(qd,aO)return qd elseif qc=="boolean"then return E elseif qc=="handling"then return a2 elseif qc=="hud"then return at elseif qc=="physics"then return aO end end;local function bT(cF,dE,nB,cY,qe)if cY==nil then cY=""end;if qe==nil then qe=""end;return bG([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cY,cF,dE,qe,nB)end;function kW(gO,gP)if gO==0 then return bE(gP)<1e-09 end;if gP==0 then return bE(gO)<1e-09 end;return bE(gO-gP)<math.max(bE(gO),bE(gP))*qf end;function f5(ei,qg)local qh=ei>100000;if qg==nil then qg=1 end;if qh then return bS(ei/1000/200,qg).."SU"elseif ei<1000 then return bS(ei,qg).."M"else return bS(ei/1000,qg).."KM"end end;function cV(qi)local qj=0;local qk=0;local ql=0;if qi<60 then qi=bF(qi)elseif qi<3600 then qj=bF(qi/60)qi=bF(qi%60)elseif qi<86400 then qk=bF(qi/3600)qj=bF(qi%3600/60)else ql=bF(qi/86400)qk=bF(qi%86400/3600)end;if ql>0 then return ql.."d "..qk.."h "elseif qk>0 then return qk.."h "..qj.."m "elseif qj>0 then return qj.."m "..qi.."s"elseif qi>0 then return qi.."s"else return"0s"end end;function nv(qm)local function qn(qo)for fS,ce in pairs(qo)do dbHud_1.setStringValue(fS,pV(ce.get()))if qm and dbHud_2 then dbHud_2.setStringValue(fS,pV(ce.get()))end end end;if dbHud_1 then qn(bv)qn(i1())bB.print("Saved Variables to Datacore")if qm and dbHud_2 then i3="Databank copied.  Remove copy when ready."end end end;local function qp()local function qq(qr)return type(qr)=='number'end;local function qs(qr)return type(nH(qr))=='number'end;local function qt(pc)return type(pc)=='table'end;local function qu(bB)return type(bB)=='string'end;local function qv(ce)return qt(ce)and qq(ce.x and ce.y and ce.z)end;local function qw(oe)return qt(oe)and qq(oe.latitude and oe.longitude and oe.altitude and oe.id and oe.systemId)end;local qx=math.pi/180;local qy=180/math.pi;local qf=1e-10;local dx=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local pF='::pos{'..dx..','..dx..','..dx..','..dx..','..dx..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function qz(qr)local lg=string.gsub(string.reverse(bG('%.4f',qr)),'^0*%.?','')return lg==''and'0'or string.reverse(lg)end;local function qA(qB)if qv(qB)then return bG('{x=%.3f,y=%.3f,z=%.3f}',qB.x,qB.y,qB.z)end;if qt(qB)and not getmetatable(qB)then local qC={}local qD=next(qB)if type(qD)=='nil'or qD==1 then qC=qB else for fS,ce in pairs(qB)do local et=qA(ce)if type(fS)=='number'then table.insert(qC,bG('[%s]=%s',fS,et))else table.insert(qC,bG('%s=%s',fS,et))end end end;return bG('{%s}',table.concat(qC,','))end;if qu(qB)then return bG("'%s'",qB:gsub("'",[[\']]))end;return tostring(qB)end;local qE={}qE.__index=qE;qE.__tostring=function(qB,qF)local qG={}for fS in pairs(qB)do table.insert(qG,fS)end;table.sort(qG)local qC={}for jL,fS in ipairs(qG)do local et=qA(qB[fS])if type(fS)=='number'then table.insert(qC,bG('[%s]=%s',fS,et))else table.insert(qC,bG('%s=%s',fS,et))end end;if qF then return bG('%s%s',qF,table.concat(qC,',\n'..qF))end;return bG('{%s}',table.concat(qC,','))end;qE.__eq=function(qH,qI)return qH.systemId==qI.systemId and qH.id==qI.id and kW(qH.radius,qI.radius)and kW(qH.center.x,qI.center.x)and kW(qH.center.y,qI.center.y)and kW(qH.center.z,qI.center.z)and kW(qH.GM,qI.GM)end;local function qJ(pG,oJ,qK,kQ,qL)assert(qs(pG),'Argument 1 (systemId) must be a number:'..type(pG))assert(qs(oJ),'Argument 2 (id) must be a number:'..type(oJ))assert(qs(qK),'Argument 3 (radius) must be a number:'..type(qK))assert(qt(kQ),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(kQ))assert(qs(qL),'Argument 5 (GM) must be a number:'..type(qL))return setmetatable({systemId=nH(pG),id=nH(oJ),radius=nH(qK),center=vec3(kQ),GM=nH(qL)},qE)end;local kS={}kS.__index=kS;kS.__tostring=function(nw)return bG('::pos{%d,%d,%s,%s,%s}',nw.systemId,nw.id,qz(nw.latitude*qy),qz(nw.longitude*qy),qz(nw.altitude))end;kS.__eq=function(qH,qI)return qH.id==qI.id and qH.systemId==qI.systemId and kW(qH.latitude,qI.latitude)and kW(qH.altitude,qI.altitude)and(kW(qH.longitude,qI.longitude)or kW(qH.latitude,math.pi/2)or kW(qH.latitude,-math.pi/2))end;local function qM(qN,oJ,kU,kV,d4)local pG=qN;if qu(qN)and not kV and not d4 and not oJ and not kU then pG,oJ,kU,kV,d4=oY(qN,pF)assert(pG,'Argument 1 (position string) is malformed.')else assert(qs(pG),'Argument 1 (systemId) must be a number:'..type(pG))assert(qs(oJ),'Argument 2 (id) must be a number:'..type(oJ))assert(qs(kU),'Argument 3 (latitude) must be in degrees:'..type(kU))assert(qs(kV),'Argument 4 (longitude) must be in degrees:'..type(kV))assert(qs(d4),'Argument 5 (altitude) must be in meters:'..type(d4))end;pG=nH(pG)oJ=nH(oJ)kU=nH(kU)kV=nH(kV)d4=nH(d4)if oJ==0 then return setmetatable({latitude=kU,longitude=kV,altitude=d4,id=oJ,systemId=pG},kS)end;return setmetatable({latitude=qx*bN(kU,-90,90),longitude=qx*(kV%360),altitude=d4,id=oJ,systemId=pG},kS)end;local qO={}qO.__index=qO;qO.__tostring=function(qB,qF)local qP=qF and qF..'  'local qQ={}local qG={}for fS in pairs(qB)do table.insert(qG,fS)end;table.sort(qG)for jL,qR in ipairs(qG)do qS=qB[qR]local qT=qE.__tostring(qS,qP)if qF then table.insert(qQ,bG('[%s]={\n%s\n%s}',qR,qT,qF))else table.insert(qQ,bG('  [%s]=%s',qR,qT))end end;if qF then return bG('\n%s%s%s',qF,table.concat(qQ,',\n'..qF),qF)end;return bG('{\n%s\n}',table.concat(qQ,',\n'))end;local function qU(qV)local bC={}local pid;for jL,ce in pairs(qV)do local oJ=ce.planetarySystemId;if type(oJ)~='number'then error('Invalid planetary s ID: '..tostring(oJ))elseif pid and oJ~=pid then error('Mistringmatch planetary s IDs: '..oJ..' and '..pid)end;local qW=ce.bodyId;if type(qW)~='number'then error('Invalid body ID: '..tostring(qW))elseif bC[qW]then error('Duplicate body ID: '..tostring(qW))end;setmetatable(ce.center,getmetatable(vec3.unit_x))bC[qW]=setmetatable(ce,qE)pid=oJ end;return setmetatable(bC,qO)end;q4={}local function qX(qV)return setmetatable({galaxyAtlas=qV or{}},q4)end;q4.__index=function(pc,F)if type(F)=='number'then local bB=pc.galaxyAtlas[F]return qU(bB)end;return rawget(q4,F)end;q4.__pairs=function(qB)return function(pc,fS)local qY,qZ=next(pc,fS)return qY,qZ and qU(qZ)end,qB.galaxyAtlas,nil end;q4.__tostring=function(qB)local q_={}for jL,r0 in pairs(qB or{})do local r1=r0:getPlanetarySystemId()local r2=qO.__tostring(r0,'    ')table.insert(q_,bG('  [%s]={%s\n  }',r1,r2))end;return bG('{\n%s\n}\n',table.concat(q_,',\n'))end;q4.BodyParameters=qJ;q4.MapPosition=qM;q4.PlanetarySystem=qU;function q4.createBodyParameters(pG,oJ,r3,r4,r5,r6,r7)assert(qs(pG),'Argument 1 (systemId) must be a number:'..type(pG))assert(qs(oJ),'Argument 2 (id) must be a number:'..type(oJ))assert(qs(r3),'Argument 3 (surfaceArea) must be a number:'..type(r3))assert(qt(r4),'Argument 4 (aPosition) must be an array or vec3:'..type(r4))assert(qt(r5),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(r5))assert(qs(r6),'Argument 6 (altitude) must be in meters:'..type(r6))assert(qs(r7),'Argument 7 (gravityAtPosition) must be number:'..type(r7))local qK=bR(r3/4/math.pi)local ei=qK+r6;local r8=vec3(r4)+ei*vec3(r5)local qL=r7*ei*ei;return qJ(pG,oJ,qK,r8,qL)end;q4.isMapPosition=qw;function q4:getPlanetarySystem(qN)if F==nil then F=0 end;if qZ==nil then qZ=0 end;local pG=qN;if qw(qN)then pG=qN.systemId end;if type(pG)=='number'then local bB=self.galaxyAtlas[F]if bB then if getmetatable(qZ)~=qO then bB=qU(bB)end;return bB end end end;function qO:sizeCalculator(l1)return 1.05*l1.radius end;function qO:castIntersections(r9,lf,ra,rb,rc,rd)local re={}if rc then for jL,l1 in pairs(rc)do table.insert(re,l1)end else re=gL end;if not rd then table.sort(re,function(gM,gN)local gO=gM.center;local gP=gN.center;return(gO.x-r9.x)^2+(gO.y-r9.y)^2+(gO.z-r9.z)^2<(gP.x-r9.x)^2+(gP.y-r9.y)^2+(gP.z-r9.z)^2 end)end;local rf=lf:normalize()for jL,l1 in ipairs(re)do local rg=l1.center-r9;local qK=self:sizeCalculator(l1)local rh=rg:dot(rf)local ri=rh^2-(rg:len2()-qK^2)if ri>=0 then local rj=bR(ri)local mi=rh+rj;local mj=rh-rj;if mj>0 then return l1,mi,mj elseif mi>0 then return l1,mi,nil end end end;return nil,nil,nil end;function qO:closestBody(kM)assert(type(kM)=='table','Invalid coordinates.')local rk,l1;local rl=vec3(kM)for jL,rm in pairs(self)do local hG=(rm.center-rl):len2()if(not l1 or hG<rk)and rm.name~="Space"then l1=rm;rk=hG end end;return l1 end;function qO:convertToBodyIdAndWorldCoordinates(qN)local rn=qN;if qu(qN)then rn=qM(qN)end;if rn.id==0 then return 0,vec3(rn.latitude,rn.longitude,rn.altitude)end;local rm=self:getBodyParameters(rn)if rm then return rn.id,rm:convertToWorldCoordinates(rn)end end;function qO:getBodyParameters(qN)local oJ=qN;if qw(qN)then oJ=qN.id end;assert(qs(oJ),'Argument 1 (id) must be a number:'..type(oJ))return self[oJ]end;function qO:getPlanetarySystemId()local jL,ce=next(self)return ce and ce.systemId end;function qE:convertToMapPosition(kQ)assert(qt(kQ),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(kQ))local kR=vec3(kQ)if self.id==0 then return setmetatable({latitude=kR.x,longitude=kR.y,altitude=kR.z,id=0,systemId=self.systemId},kS)end;local kT=kR-self.center;local ei=kT:len()local d4=ei-self.radius;local kU=0;local kV=0;if not kW(ei,0)then local kX=bL(kT.y,kT.x)kV=kX>=0 and kX or 2*math.pi+kX;kU=math.pi/2-math.acos(kT.z/ei)end;return setmetatable({latitude=kU,longitude=kV,altitude=d4,id=self.id,systemId=self.systemId},kS)end;function qE:convertToWorldCoordinates(qN)local rn=qu(qN)and qM(qN)or qN;if rn.id==0 then return vec3(rn.latitude,rn.longitude,rn.altitude)end;assert(qw(rn),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(rn.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(rn.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local pH=math.cos(rn.latitude)return self.center+(self.radius+rn.altitude)*vec3(pH*math.cos(rn.longitude),pH*math.sin(rn.longitude),math.sin(rn.latitude))end;function qE:getAltitude(kQ)return(vec3(kQ)-self.center):len()-self.radius end;function qE:getDistance(kQ)return(vec3(kQ)-self.center):len()end;function qE:getGravity(kQ)local ro=self.center-vec3(kQ)local rp=ro:len2()return self.GM/rp*ro/bR(rp)end;return setmetatable(q4,{__call=function(jL,...)return qX(...)end})end;local function rq()local ft={}local rr=30000000/3600;local rs=rr*rr;local rt=100;function ft.computeAccelerationTime(ru,rv,rw)local rx=rr*math.asin(ru/rr)return(rr*math.asin(rw/rr)-rx)/rv end;function ft.computeDistanceAndTime(ru,rw,ry,rz,rA,rB)rA=rA or 0;rB=rB or 0;local rC=ru<=rw;local rD=rz*(rC and 1 or-1)/ry;local rE=-rB/ry;local rF=rD+rE;if rC and rF<=0 or not rC and rF>=0 then return-1,-1 end;local rG,rH=0,0;if rD~=0 and rA>0 then local rx=math.asin(ru/rr)local rI=math.pi*(rD/2+rE)local rJ=rD*rA;local rK=rr*math.pi;local ce=function(pc)local jW=(rI*pc-rJ*math.sin(math.pi*pc/2/rA)+rK*rx)/rK;local rL=math.tan(jW)return rr*rL/bR(rL*rL+1)end;local rM=rC and function(bB)return bB>=rw end or function(bB)return bB<=rw end;rH=2*rA;if rM(ce(rH))then local rN=0;while bE(rH-rN)>0.5 do local pc=(rH+rN)/2;if rM(ce(pc))then rH=pc else rN=pc end end end;local rO=ru;local rP=rH/rt;for rQ=1,rt do local dB=ce(rQ*rP)rG=rG+(dB+rO)*rP/2;rO=dB end;if rH<2*rA then return rG,rH end;ru=rO end;local rx=rr*math.asin(ru/rr)local gd=(rr*math.asin(rw/rr)-rx)/rF;local rR=rs*math.cos(rx/rr)/rF;local ei=rR-rs*math.cos((rF*gd+rx)/rr)/rF;return ei+rG,gd+rH end;function ft.computeTravelTime(ru,rv,ei)if ei==0 then return 0 end;if rv>0 then local rx=rr*math.asin(ru/rr)local rR=rs*math.cos(rx/rr)/rv;return(rr*math.acos(rv*(rR-ei)/rs)-rx)/rv end;if ru==0 then return-1 end;assert(ru>0,'Acceleration and initial speed are both zero.')return ei/ru end;return ft end;local function rS()local vec3=require('cpml.vec3')local qp=qp()local function qu(bB)return type(bB)=='string'end;local function qt(pc)return type(pc)=='table'end;rT={}rT.__index=rT;function rT:escapeAndOrbitalSpeed(d4)assert(self.body)local ei=d4+self.body.radius;if not kW(ei,0)then local gp=bR(self.body.GM/ei)return bR(2)*gp,gp end;return nil,nil end;function rT:orbitalParameters(qN,e6)assert(self.body)assert(qt(qN)or qu(qN))assert(qt(e6))local gD=(qu(qN)or qp.isMapPosition(qN))and self.body:convertToWorldCoordinates(qN)or vec3(qN)local ce=vec3(e6)local hz=gD-self.body.center;local o5=ce:len2()local hg=hz:len()local rU=self.body.GM;local rV=((o5-rU/hg)*hz-hz:dot(ce)*ce)/rU;local gO=rU/(2*rU/hg-o5)local rW=rV:len()local rf=rV:normalize()local rX=gO*(1-rW)local rY=gO*(1+rW)local rZ=rX*rf+self.body.center;local r_=rW<=1 and-rY*rf+self.body.center or nil;local s0=bR(gO*rU*(1-rW*rW))local s1=r_ and 2*math.pi*bR(gO^3/rU)local s2=math.acos(rV:dot(hz)/(rW*hg))if hz:dot(ce)<0 then s2=-(s2-2*math.pi)end;local s3=math.acos((math.cos(s2)+rW)/(1+rW*math.cos(s2)))local s4=s3;if s4<0 then s4=s4+2*math.pi end;local s5=s4-rW*math.sin(s4)local s6=0;local s7=0;local s8=0;if s1~=nil then s6=s5/(2*math.pi/s1)s7=s1-s6;s8=s7+s1/2;if s2-math.pi>0 then s7=s6;s8=s7+s1/2 end;if s8>s1 then s8=s8-s1 end end;return{periapsis={position=rZ,speed=s0/rX,circularOrbitSpeed=bR(rU/rX),altitude=rX-self.body.radius},apoapsis=r_ and{position=r_,speed=s0/rY,circularOrbitSpeed=bR(rU/rY),altitude=rY-self.body.radius},currentVelocity=ce,currentPosition=gD,eccentricity=rW,period=s1,eccentricAnomaly=s3,meanAnomaly=s5,timeToPeriapsis=s7,timeToApoapsis=s8,trueAnomaly=s2}end;local function s9(sa)local rm=qp.BodyParameters(sa.systemId,sa.id,sa.radius,sa.center,sa.GM)return setmetatable({body=rm},rT)end;return setmetatable(rT,{__call=function(jL,...)return s9(...)end})end;local function sb()local function sc(ic)local nw=lx:closestBody(ic)if(ic-nw.center):len()>nw.radius+nw.noAtmosphericDensityAltitude then nw=bC[0][0]end;return nw end;local function sd()local function se(sf,sg)return sf.name<sg.name end;fO={}for fS,ce in pairs(bC[0])do fO[#fO+1]={name=ce.name,index=fS}end;table.sort(fO,se)end;local function sh(si)for fS,ce in pairs(si)do if ce.name and ce.name==fP.name then return fS end end;return-1 end;local function sj()iy=bb;if bb==0 then b9="None"f_=nil;fP=nil;return true end;local sk=fO[bb].index;local sl=bC[0][sk]if sl.center then b9=sl.name;f_=ly[0][sk]if fP~=nil then if fh==0 then if kh(sm,sn)~=1 then pX(sm,sn)end;if kh(so,sp)~=1 then pX(so,sp)end;if kh(sq,sr)~=1 then pX(sq,sr)end;if kh(ss,st)~=1 then pX(ss,st)end;if kh(ml,su)~=1 then pX(ml,su)end end;if kh(sv,sw)~=1 then pX(sv,sw)end;if kh(sx,sy)~=1 then pX(sx,sy)end;if kh(sz,sA)~=1 then pX(sz,sA)end end;fP=nil else fP=sl;for jL,ce in pairs(ly[0])do if ce.name==fP.planetname then f_=ce;b9=fP.name;break end end;if kh(sv,sw)~=1 then pX(sv,sw)end;if kh(sx,sy)~=1 then pX(sx,sy)end end;if fP==nil then ba=vec3(f_.center)else ba=fP.position end;if f_.planetname~="Space"then if f_.hasAtmosphere then ma=bF(f_.radius*(N-1)+f_.noAtmosphericDensityAltitude)else ma=bF(f_.radius*(N-1)+f_.surfaceMaxAltitude)end else ma=M end;if fP~=nil and fP.planetname=="Space"then b5=0 else jL,b5=lA(f_):escapeAndOrbitalSpeed(ma)end;b7=0;b1=false;b3=false;b4=false;aU=false;b2=false;b6="Aligning"return true end;local function sB(da)if not aU and not bg and not fg and not bp and not aZ and not ff then if da==nil then bb=bb+1;if bb>#fO then bb=0 end else bb=bb-1;if bb<0 then bb=#fO end end;if bb==0 then sj()else local sk=fO[bb].index;local sl=bC[0][sk]if sl~=nil and sl.name=="Space"or bq=="Custom Only"and sl.center or bq=="No Moons"and string.find(sl.name,"Moon")~=nil then if da==nil then sB()else sB(1)end else sj()end end else i3="Disengage autopilot before changing Interplanetary Helper"eY("iph","AP")end end;local function ik()local dP=-1;dP=sh(bC[0])if dP>-1 then table.remove(bC[0],dP)end;dP=-1;dP=sh(bf)if dP~=-1 then i3=fP.name.." saved location cleared"table.remove(bf,dP)end;sB()sd()end;local function ib(cO,ic,e2,sC)if dbHud_1 or e2 then local nw=sc(ic)local j6=nw.gravity;if sC then j6=bA.getClosestPlanetInfluence()end;local sD={position=ic,name=cO,planetname=nw.name,gravity=j6,safe=sC}if not e2 then bf[#bf+1]=sD else for fS,ce in pairs(bC[0])do if ce.name and cO==ce.name then table.remove(bC[0],fS)end end end;table.insert(bC[0],sD)sd()sj()i3="Location saved as "..cO.."("..nw.name..")"else i3="Databank must be installed to save permanent locations"end end;local sE={}function sE.UpdateAtlasLocationsList()sd()end;function sE.UpdateAutopilotTarget()sj()end;function sE.adjustAutopilotTargetIndex(da)sB(da)end;function sE.findAtlasIndex(si)sh(si)end;function sE.UpdatePosition(sF)local dP=sh(bf)if dP~=-1 then if sF~=nil then bf[dP].name=sF;bb=bb-1;sB()else local sG=bf[dP]sG.gravity=bA.getClosestPlanetInfluence()sG.position=gQ;sG.safe=true end;i3=bf[dP].name.." position updated ("..bf[dP].planetname..")"else i3="Name Not Found"end end;function sE.AddNewLocation(cO,ic,e2,sC)ib(cO,ic,e2,sC)end;function sE.ClearCurrentPosition()ik()end;for fS,ce in pairs(bf)do table.insert(bC[0],ce)end;sd()if bb>#fO then bb=0 end;sE.UpdateAutopilotTarget()return sE end;function script.onStart()local sH=false;local function sI()local function sJ(sK)local sL=dbHud_1.hasKey;for fS,ce in pairs(sK)do if sL(fS)then local lg=bH(dbHud_1.getStringValue(fS))if lg~=nil then ce.set(lg)sH=true end end end end;if dbHud_1 then if not a then sJ(i1())coroutine.yield()sJ(bv)else sJ(bv)i3="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"jp=5;sH=false end;coroutine.yield()if sH then i3="Loaded Saved Variables"cf=a3;ch=a4;aP=e;b=string.lower(b)iq=k;ex=P;gC=[[rgb(]]..bF(iK+0.5)..","..bF(iL+0.5)..","..bF(iM+0.5)..[[)]]hq=[[rgb(]]..bF(iK*0.9+0.5)..","..bF(iL*0.9+0.5)..","..bF(iM*0.9+0.5)..[[)]]elseif not a then i3="No Saved Variables Found - Exit HUD to save settings"end;if bt<1.500 then if O<2000 then i3="Updating LowOrbitHeight to new minimum default of 2000."O=2000 end end;bt=VERSION_NUMBER else i3="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bm+180<gd then bk=0 end;bm=gd;b=string.lower(b)if string.find("keyboard virtual joystick mouse",b)==nil then i3="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"jp=7 end;if antigrav and not l then if bl==nil then bl=fd end;antigrav.setBaseAltitude(bl)end;fw="Proceeding to Waypoint"end;local function sM()local function sN(sO,sP)if sO>sP then sP=sO end;local sQ,sR=0,0;if a0>0 then sQ=a0*0.05 end;if a1>0 then sR=a1*0.05 end;sP=sP*(1-(sQ+sR))return sP end;local sS=bz.getElementNameById;local sT=ak~=0 and al~=0;for fS in pairs(q1)do local type=bz.getElementTypeById(q1[fS])if oY(type,'^.*Atmospheric Engine$')then if oY(tostring(bz.getElementTagsById(q1[fS])),'^.*vertical.*$')and bz.getElementForwardById(q1[fS])[3]>0 then iD=true end end;if oY(type,'^.*Space Engine$')then nr=true;if oY(tostring(bz.getElementTagsById(q1[fS])),'^.*vertical.*$')then local sU=bz.getElementForwardById(q1[fS])if sU[3]<0 then q7=true else lL=true end end end;if type=="Landing Gear"then f3=true end;if type=="Dynamic Core Unit"then local sV=pW(q1[fS])if sV>10000 then nI=110 elseif sV>1000 then nI=55 elseif sV>150 then nI=27 end end;q3=q3+pW(q1[fS])if sT and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local sV=pW(q1[fS])local je=bJ(q1[fS])local sO=0;local cR=bM()if type=="Atmospheric Fuel Tank"then local sP=400;local sW=35.03;if sV>10000 then sP=51200;sW=5480 elseif sV>1300 then sP=6400;sW=988.67 elseif sV>150 then sP=1600;sW=182.67 end;sO=je-sW;if Y>0 then sP=sP+sP*Y*0.2 end;sP=sN(sO,sP)jz[#jz+1]={q1[fS],sS(q1[fS]),sP,sW,sO,cR}end;if type=="Rocket Fuel Tank"then local sP=320;local sW=173.42;if sV>65000 then sP=40000;sW=25740 elseif sV>6000 then sP=5120;sW=4720 elseif sV>700 then sP=640;sW=886.72 end;sO=je-sW;if _>0 then sP=sP+sP*_*0.1 end;sP=sN(sO,sP)jB[#jB+1]={q1[fS],sS(q1[fS]),sP,sW,sO,cR}end;if type=="Space Fuel Tank"then local sP=600;local sW=35.03;if sV>10000 then sP=76800;sW=5480 elseif sV>1300 then sP=9600;sW=988.67 elseif sV>150 then sP=2400;sW=182.67 end;sO=je-sW;if Z>0 then sP=sP+sP*Z*0.2 end;sP=sN(sO,sP)jA[#jA+1]={q1[fS],sS(q1[fS]),sP,sW,sO,cR}end end end;if not iD then a_,aQ=false,false end end;local function sX()if gyro~=nil then e_=gyro.getState()==1 end;if not br then bO:deactivateGroundEngineAltitudeStabilization()end;if b~="keyboard"then oX(1)else oX(0)end;if door and(d5 or not d5 and fd<10000)then for jL,ce in pairs(door)do ce.toggle()end end;if switch then for jL,ce in pairs(switch)do ce.toggle()end end;if forcefield and(d5 or not d5==0 and fd<10000)then for jL,ce in pairs(forcefield)do ce.toggle()end end;if antigrav then eX=antigrav.getState()==1;if eX and not l then antigrav.show()end end;if bK()==1 and f then bB.freeze(1)else bB.freeze(0)end;if f3 then bc=by.control.isAnyLandingGearExtended()==1;if bc then by.control.extendLandingGears()else by.control.retractLandingGears()end end;if dO~=-1 or not d5 and iZ:len()<50 then aR=true;bc=true;if f3 then by.control.extendLandingGears()end else aR=false end;bO:setTargetGroundAltitude(q6)if d5 and dO~=-1 then lC=bz.getMaxKinematicsParametersAlongAxis("ground",bz.getConstructOrientationUp())[1]end;sY=d5 end;local function sZ()local s_={}local function t0()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local t1={[1]=4480,[6]=4480,[7]=6270}for t2,t3 in pairs(bC)do bC[t2][0]=t0()bC[t2][0].systemId=t2;s_[t2]={}for t4,cc in pairs(bC[t2])do cc.gravity=cc.gravity/9.8;cc.center=vec3(cc.center)cc.name=cc.name[1]cc.noAtmosphericDensityAltitude=cc.atmosphereThickness or cc.atmosphereRadius-cc.radius;cc.spaceEngineMinAltitude=t1[cc.id]or 0.68377*(cc.atmosphereThickness or cc.atmosphereRadius-cc.radius)cc.planetarySystemId=t2;cc.bodyId=cc.id;s_[t2][t4]=cc;if gy==nil or cc.center.x<gy then gy=cc.center.x end;if gx==nil or cc.center.x>gx then gx=cc.center.x end;if gB==nil or cc.center.y<gB then gB=cc.center.y end;if gA==nil or cc.center.y>gA then gA=cc.center.y end;if cc.center and cc.name~="Space"then gL[#gL+1]=cc end end end;q4=qp()ly=q4(s_)ft=rq()lA=rS()ie=sb()end;t5=false;t6=coroutine.create(function()bO:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})sI()coroutine.yield()sM()coroutine.yield()fq=kf(by,bz,bA,bB,bC,vBooster,hover,kg,antigrav,bE,bF,bI,bK,bL,bM,bN,bO,kh,bQ,bR,bS)sX()coroutine.yield()sZ()id=nG(bz,bB,library,radar_1,radar_2,bE,bP,bR,bT,nH,nI)gG=bx(by,bz,bA,bB,bC,radar_1,radar_2,antigrav,hover,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT)gG.ButtonSetup()q5=oW(by,bz,bA,bB,bC,vBooster,hover,antigrav,bD,dbHud_2,bK,bO,bQ,oX,bP,bS,oY,nH,bN)coroutine.yield()bA.hide()bB.showScreen(1)bB.showHelper(0)collectgarbage("collect")coroutine.yield()bA.setTimer("apTick",aJ)bA.setTimer("radarTick",aJ)bA.setTimer("hudTick",aK)bA.setTimer("oneSecond",1)bA.setTimer("tenthSecond",1/10)bA.setTimer("fiveSecond",5)eY("start","SU")end)coroutine.resume(t6)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not l then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;bz.hide()by.control.switchOffHeadlights()if door and(fh>0 or fh==0 and fd<10000)then for jL,ce in pairs(door)do ce.toggle()end end;if switch then for jL,ce in pairs(switch)do ce.toggle()end end;if forcefield and(fh>0 or fh==0 and fd<10000)then for jL,ce in pairs(forcefield)do ce.toggle()end end;s=i4;nv()if iA then iA.activate()end;if v then fq.showWayPoint(cc,gQ)end;eY("stop","SU")end;function script.onTick(t7)local t8=nil;if t7=="contact"then if not t9 then t9=0 end;if gd>t9+10 then i3="Radar Contact"eY("rdrCon","RC")t9=gd end;bA.stopTimer("contact")elseif t7=="tenthSecond"then local function ta()local tb=bB.createData;local tc=bB.createWidget;td=bB.createWidgetPanel("Interplanetary Helper")te=tc(td,"value")tf=tb('{"label": "Target Planet", "value": "N/A", "unit":""}')pX(tf,te)tg=tc(td,"value")th=tb('{"label": "distance", "value": "N/A", "unit":""}')pX(th,tg)sy=tc(td,"value")sx=tb('{"label": "Travel Time", "value": "N/A", "unit":""}')pX(sx,sy)sw=tc(td,"value")sv=tb('{"label": "Maximum Mass", "value": "N/A", "unit":""}')pX(sv,sw)sA=tc(td,"value")sz=tb('{"label": "Target Altitude", "value": "N/A", "unit":""}')pX(sz,sA)st=tc(td,"value")ss=tb('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')sr=tc(td,"value")sq=tb('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')sp=tc(td,"value")so=tb('{"label": "Max Brake distance", "value": "N/A", "unit":""}')sn=tc(td,"value")sm=tb('{"label": "Max Brake Time", "value": "N/A", "unit":""}')su=tc(td,"value")ml=tb('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not d5 then pX(ss,st)pX(sq,sr)pX(so,sp)pX(sm,sn)pX(ml,su)end end;local function ti()bP(td)td=nil end;local function tj()if not aU then if fP==nil or fP.planetname~=cc.name then mh=(f_.center-gQ):len()else mh=(fP.position-gQ):len()end end;local dB=fu;local mt=bA.getThrottle()/100;if p then mt=iY end;local tk,tl=ft.computeDistanceAndTime(fu,V,jf,by:maxForceForward()*mt,X,0)local l8,mm;if not aV then l8,mm=fq.GetAutopilotBrakeDistanceAndTime(V)else l8,mm=fq.GetAutopilotTBBrakeDistanceAndTime(V)end;local jL,tm;if not aV and dB>0 then jL,tm=fq.GetAutopilotBrakeDistanceAndTime(dB)else jL,tm=fq.GetAutopilotTBBrakeDistanceAndTime(dB)end;local tn=0;local to=0;if b4 or not aU and dB>5 then to=ft.computeTravelTime(dB,0,mh)elseif l8+tk<mh then tn=mh-(l8+tk)to=ft.computeTravelTime(8333.0556,0,tn)else local tp=(mh-l8)/tk;tk=mh-l8;tl=tl*tp end;if fP~=nil and fP.planetname==cc.name and not aU then return to elseif b3 then return tm elseif b4 then return to+tm else return tl+mm+to end end;local function tq(j6,tr)if j6==nil then j6=bz.g()end;j6=bS(j6,5)if tr~=nil and tr or(t8==nil or t8~=j6)then local dB=iZ:len()local ts=bH(bA.getData()).maxBrake;if ts~=nil and ts>0 and d5 then ts=ts/bN(dB/100,0.1,1)ts=ts/fh;if fh>0.10 then if bk then bk=(bk+ts)/2 else bk=ts end end end;if ts~=nil and ts>0 then bi=ts end;t8=j6 end end;tq(nil,true)if ny~=nil then if bO:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or bO:getTargetSpeed(axisCommandId.longitudinal)~=ny then fq.cmdCruise(ny)else ny=nil end end;if b9~="None"then if td==nil then ta()end;if b9~=nil then local tt=fP~=nil;local tu=0.5*bk/f_:getGravity(f_.center+vec3(0,0,1)*f_.radius):len()tu=tu>1000000 and bS(tu/1000000,2).." kTons"or bS(tu/1000,2).." Tons"kh(tf,'{"label": "Target", "value": "'..b9 ..'", "unit":""}')fs=tj()if tt and not aU then ei=(gQ-fP.position):len()else ei=(ba-gQ):len()end;if not aV then l8,mm=fq.GetAutopilotBrakeDistanceAndTime(fu)pZ,p_=fq.GetAutopilotBrakeDistanceAndTime(V)else l8,mm=fq.GetAutopilotTBBrakeDistanceAndTime(fu)pZ,p_=fq.GetAutopilotTBBrakeDistanceAndTime(V)end;local f4=f5(ei)kh(th,'{"label": "distance", "value": "'..f4 ..'"}')kh(sx,'{"label": "Travel Time", "value": "'..cV(fs)..'", "unit":""}')f4=f5(l8)kh(ss,'{"label": "Cur Brake distance", "value": "'..f4 ..'"}')kh(sq,'{"label": "Cur Brake Time", "value": "'..cV(mm)..'", "unit":""}')f4=f5(pZ)kh(so,'{"label": "Max Brake distance", "value": "'..f4 ..'"}')kh(sm,'{"label": "Max Brake Time", "value": "'..cV(p_)..'", "unit":""}')kh(sv,'{"label": "Max Brake Mass", "value": "'..bG("%s",tu)..'", "unit":""}')f4=f5(ma)kh(sz,'{"label": "Target Orbit", "value": "'..f4 ..'"}')if fh>0 and not sY then bB.removeDataFromWidget(sm,sn)bB.removeDataFromWidget(so,sp)bB.removeDataFromWidget(sq,sr)bB.removeDataFromWidget(ss,st)bB.removeDataFromWidget(ml,su)sY=true;if not cl and p and(aW or aZ or ff)then fq.cmdThrottle(1)aR=false;mX=false end end;if fh==0 and sY then if kh(sm,sn)==1 then pX(sm,sn)end;if kh(so,sp)==1 then pX(so,sp)end;if kh(sq,sr)==1 then pX(sq,sr)end;if kh(ss,st)==1 then pX(ss,st)end;if kh(ml,su)==1 then pX(ml,su)end;sY=false end end else ti()end;if warpdrive~=nil then if bH(warpdrive.getData()).destination~="Unknown"and bH(warpdrive.getData()).distance>400000 then warpdrive.show()tv=true else warpdrive.hide()tv=false end end;gG.TenthTick()elseif t7=="oneSecond"then local function tw(d3)local tx=0;j1=""local ty=q3;local tz=0;local tA=0;local tB=0;local cW=0;local cX=""local tC=bz.getElementHitPointsById;for fS in pairs(q1)do local sV=0;local tD=0;tD=pW(q1[fS])sV=tC(q1[fS])tz=tz+sV;if sV<tD then if sV==0 then tB=tB+1 else tA=tA+1 end;if iF and#q2==0 then ic=vec3(bz.getElementPositionById(q1[fS]))local cF=ic.x;local dE=ic.y;local of=ic.z;table.insert(q2,bz.spawnArrowSticker(cF,dE,of+1,"down"))table.insert(q2,bz.spawnArrowSticker(cF,dE,of+1,"down"))bz.rotateSticker(q2[2],0,0,90)table.insert(q2,bz.spawnArrowSticker(cF+1,dE,of,"north"))table.insert(q2,bz.spawnArrowSticker(cF+1,dE,of,"north"))bz.rotateSticker(q2[4],90,90,0)table.insert(q2,bz.spawnArrowSticker(cF-1,dE,of,"south"))table.insert(q2,bz.spawnArrowSticker(cF-1,dE,of,"south"))bz.rotateSticker(q2[6],90,-90,0)table.insert(q2,bz.spawnArrowSticker(cF,dE-1,of,"east"))table.insert(q2,bz.spawnArrowSticker(cF,dE-1,of,"east"))bz.rotateSticker(q2[8],90,0,90)table.insert(q2,bz.spawnArrowSticker(cF,dE+1,of,"west"))table.insert(q2,bz.spawnArrowSticker(cF,dE+1,of,"west"))bz.rotateSticker(q2[10],-90,0,90)table.insert(q2,q1[fS])end elseif iF and#q2>0 and q2[11]==q1[fS]then for cQ in pairs(q2)do bz.deleteSticker(q2[cQ])end;q2={}end end;tx=bF(tz/ty*100)if tx<100 then d3[#d3+1]=bT(0,0,"","pbright txt")cW=bF(tx*2.55)cX=bG("rgb(%d,%d,%d)",255-cW,cW,0)if tx<100 then d3[#d3+1]=bT("50%",1035,"Elemental Integrity: "..tx.."%","txtbig txtmid","fill:"..cX)if tB>0 then d3[#d3+1]=bT("50%",1055,"Disabled Modules: "..tB.." Damaged Modules: "..tA,"txtbig txtmid","fill:"..cX)elseif tA>0 then d3[#d3+1]=bT("50%",1055,"Damaged Modules: "..tA,"txtbig txtmid","fill:"..cX)end end end end;local function tE()if tF then if tG==nil and(oV~=nil or bc)then _autoconf.displayCategoryPanel(tF,weapon_size,"Weapons","weapon",true)tG=_autoconf.panels[_autoconf.panels_size]elseif tG~=nil and oV==nil and not bc then bP(tG)tG=nil end end end;local function kb()local cR=bM()local ez=fu;local kc=cR-kd;if ez>1.38889 then ez=ez/1000;local ke=ez*(cR-kd)bd=bd+ke;gH=gH+ke end;gI=gI+kc;be=be+kc;kd=cR end;kb()fA=bz.getPlayersOnBoard()pt=bz.getDockedConstructs()tE()local d3={}gG.OneSecond(d3)if n then tw(d3)end;j0=table.concat(d3,"")collectgarbage("collect")elseif t7=="fiveSecond"then if not m then return end;q0=dbHud_1.getStringValue("SPBAutopilotTargetName")if q0~=nil and q0~=""and q0~="SatNavNotChanged"then local lg=bH(dbHud_1.getStringValue("SavedLocations"))if lg~=nil then bf=lg;local dP=-1;local sD;for fS,ce in pairs(bf)do if ce.name and ce.name=="SatNav Location"then dP=fS;break end end;if dP~=-1 then sD=bf[dP]dP=-1;for fS,ce in pairs(bC[0])do if ce.name and ce.name=="SatNav Location"then dP=fS;break end end;if dP>-1 then bC[0][dP]=sD end;ie.UpdateAtlasLocationsList()i3=sD.name.." position updated"end end;for F=1,#fO do if fO[F].name==q0 then bb=F;bB.print("Index = "..bb.." "..fO[F].name)ie.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif t7=="msgTick"then local d3={}gG.DisplayMessage(d3,"empty")i3="empty"bA.stopTimer("msgTick")jp=3 elseif t7=="animateTick"then k8=true;k7=false;jI=0;jJ=0;bA.stopTimer("animateTick")elseif t7=="hudTick"then gG.hudtick()elseif t7=="apTick"then fq.APTick()elseif t7=="radarTick"then id.UpdateRadar()elseif t7=="tagTick"then if bs=="Off"then bs="All"elseif bs=="All"then bs="Longitude"elseif bs=="Longitude"then bs="Lateral"elseif bs=="Lateral"then bs="Vertical"else bs="Off"end;i3="Extra Engine Tags: "..bs;bA.stopTimer("tagTick")end end;function script.onFlush()local function tH(tI,mF)local tJ=vec3()local tK=vec3()if tI==axisCommandId.longitudinal then tJ=vec3(bz.getConstructOrientationForward())tK=dp elseif tI==axisCommandId.vertical then tJ=vec3(bz.getConstructOrientationUp())tK=ls elseif tI==axisCommandId.lateral then tJ=vec3(bz.getConstructOrientationRight())tK=h0 else return vec3()end;local tL=vec3(bz.getWorldGravity())local tM=tL:dot(tK)local tN=vec3(bz.getWorldAirFrictionAcceleration())local tO=tN:dot(tK)local tP=iZ:dot(tJ)local tQ=mF*constants.kph2m;if tR==nil then tR=pid.new(10,0,10.0)end;tR:inject(tQ-tP)local tS=tR:get()local tT=(tS-tO-tM)*tK;return tT end;local function tU(tI,mF)local tJ=vec3()local tK=vec3()if tI==axisCommandId.longitudinal then tJ=vec3(bz.getConstructOrientationForward())tK=dp elseif tI==axisCommandId.vertical then tJ=vec3(bz.getConstructOrientationUp())tK=ls elseif tI==axisCommandId.lateral then tJ=vec3(bz.getConstructOrientationRight())tK=h0 else return vec3()end;local tL=vec3(bz.getWorldGravity())local tM=tL:dot(tK)local tN=vec3(bz.getWorldAirFrictionAcceleration())local tO=tN:dot(tK)local tP=iZ:dot(tJ)local tQ=mF*constants.kph2m;if tV==nil then tV=pid.new(10,0,10.0)end;tV:inject(tQ-tP)local tS=tV:get()local tT=(tS-tO-tM)*tK;return tT end;local function tW(tX,d9,sg)local tY=tX:cross(sg):normalize_inplace()local e7=math.acos(bN(tY:dot(-d9),-1,1))*constants.rad2deg;if tY:cross(-d9):dot(sg)<0 then e7=-e7 end;return e7 end;if antigrav and not l then if not eX and antigrav.getBaseAltitude()~=bl then antigrav.setBaseAltitude(bl)end end;cl=bO:getAxisCommandType(0)==axisCommandType.byThrottle;if cl and mX then fq.cmdThrottle(0)mX=false elseif not cl and not mX then iY=0;mX=true end;aE=math.max(aE,0.01)aF=math.max(aF,0.01)az=math.max(az,0.01)aD=math.max(aD,0.01)aG=math.max(aG,0.01)aH=math.max(aH,0.01)ay=math.max(ay,0.01)local tZ=bN(pd+ln+bB.getControlDeviceForwardInput(),-1,1)local t_=bN(pe+lw+bB.getControlDeviceYawInput(),-1,1)local u0=bN(pf+lm-bB.getControlDeviceLeftRightInput(),-1,1)local u1=lF;db=vec3(bz.getWorldVertical())if db==nil or db:len()==0 then db=(cc.center-gQ):normalize()end;ls=vec3(bz.getConstructWorldOrientationUp())dp=vec3(bz.getConstructWorldOrientationForward())h0=vec3(bz.getConstructWorldOrientationRight())fr=vec3(bz.getWorldVelocity())iZ=vec3(bz.getVelocity())gQ=vec3(bz.getConstructWorldPos())jf=bz.getConstructMass()fu=vec3(fr):len()d7=-db:dot(fr)iV=getRoll(db,dp,h0)local u2=iV/180*math.pi;local u3=math.cos(u2)local u4=math.sin(u2)iT=tW(db,dp,h0*u3+ls*u4)local u5=fr:normalize()local u6=bE(iV)local u7=utils.sign(iV)local u8=vec3(bz.getWorldAngularVelocity())local u9=tZ*aE*h0+t_*az*dp+u0*aF*ls;if iq==true and db:len()>0.01 then local ua=bE(lB-iV)if((aT or aZ or aX or iE or aW or bp)and ua>0 or fh>0.0 and ua<aA and k)and t_==0 and bE(iT)<85 then local ub=lB;local uc=ay;if fh==0 then uc=uc/4;lB=0;ub=0 end;if ud==nil then ud=pid.new(uc*0.01,0,uc*0.1)end;ud:inject(ub-iV)local ue=ud:get()u9=u9+ue*dp end end;local uf=1;local ug=0;local uh=1;local ui=bB.getMouseWheel()if ui>0 then fq.changeSpd()elseif ui<0 then fq.changeSpd(true)else nE=true end;eS=0;if d5 and p and cl then if uj==nil then uj=pid.new(0.5,0,1)end;uj:inject(ex/3.6-fr:dot(dp))local uk=uj:get()ew=bN(uk,-1,1)if ew<iY and fh>0.005 then ev=true;bO:setThrottleCommand(axisCommandId.longitudinal,bN(ew,0.01,1))else ev=false;bO:setThrottleCommand(axisCommandId.longitudinal,iY)end;if ul==nil then ul=pid.new(1*0.01,0,1*0.1)end;ul:inject(fr:len()-ex/3.6)local um=bN(ul:get(),0,1)if fh>0 and d7<-80 or fh>0.005 then eS=um end;if eS>0 then if ev and ew==0.01 then bO:setThrottleCommand(axisCommandId.longitudinal,0)end else ew=bN(ew,0.01,1)end;local un=''local uo=vec3()local up=tH(axisCommandId.vertical,lJ*1000)by:setEngineForceCommand("vertical airfoil , vertical ground ",up,ug)local uq='thrust analog longitudinal 'if bs=="All"or bs=="Longitude"then uq=uq..aL end;local ur=bO:getAxisCommandType(axisCommandId.longitudinal)local us=bO:composeAxisAccelerationFromThrottle(uq,axisCommandId.longitudinal)local ut=tU(axisCommandId.lateral,bo*1000)un=un..' , '.."lateral airfoil , lateral ground "uo=uo+ut;if uo:len()>constants.epsilon then by:setEngineForceCommand(un,uo,ug,'','','',uh)end;by:setEngineForceCommand(uq,us,uf)local uu='thrust analog vertical fueled 'local uv='thrust analog lateral fueled 'if bs=="All"or bs=="Lateral"then uv=uv..aM end;if bs=="All"or bs=="Vertical"then uu=uu..aN end;if lJ~=0 or aX and aR or not bc and not br then by:setEngineForceCommand(uu,up,uf)else by:setEngineForceCommand(uu,vec3(),uf)end;if bo~=0 then by:setEngineForceCommand(uv,ut,uf)else by:setEngineForceCommand(uv,vec3(),uf)end;if u1==0 then u1=eS end;local uw=-u1*(aG*fr+aH*u5)by:setEngineForceCommand('brake',uw)else if p then bO:setThrottleCommand(axisCommandId.longitudinal,iY)end;local mF=bA.getAxisCommandValue(0)if not cl then if ul==nil then ul=pid.new(1*0.01,0,1*0.1)end;ul:inject(fr:len()-mF/3.6)local um=bN(ul:get(),0,1)u1=bN(u1+um,0,1)end;local uw=-u1*(aG*fr+aH*u5)by:setEngineForceCommand('brake',uw)local un=''local uo=vec3()local ux=false;local uq='thrust analog longitudinal 'if bs=="All"or bs=="Longitude"then uq=uq..aL end;local ur=bO:getAxisCommandType(axisCommandId.longitudinal)if ur==axisCommandType.byThrottle then local us=bO:composeAxisAccelerationFromThrottle(uq,axisCommandId.longitudinal)by:setEngineForceCommand(uq,us,uf)elseif ur==axisCommandType.byTargetSpeed then local us=bO:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)un=un..' , '..uq;uo=uo+us;if bO:getTargetSpeed(axisCommandId.longitudinal)==0 or bO:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-bO:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then ux=true end end;local uv='thrust analog lateral 'if bs=="All"or bs=="Lateral"then uv=uv..aM end;local uy=bO:getAxisCommandType(axisCommandId.lateral)if uy==axisCommandType.byThrottle then local uz=bO:composeAxisAccelerationFromThrottle(uv,axisCommandId.lateral)by:setEngineForceCommand(uv,uz,uf)elseif uy==axisCommandType.byTargetSpeed then local ut=bO:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)un=un..' , '..uv;uo=uo+ut end;local uu='thrust analog vertical 'if bs=="All"or bs=="Vertical"then uu=uu..aN end;local uA=bO:getAxisCommandType(axisCommandId.vertical)if uA==axisCommandType.byThrottle then local up=bO:composeAxisAccelerationFromThrottle(uu,axisCommandId.vertical)if lJ~=0 or aX and aR then by:setEngineForceCommand(uu,up,uf,'airfoil','ground','',uh)else by:setEngineForceCommand(uu,vec3(),uf)by:setEngineForceCommand('airfoil vertical',up,uf,'airfoil','','',uh)by:setEngineForceCommand('ground vertical',up,uf,'ground','','',uh)end elseif uA==axisCommandType.byTargetSpeed then if lJ<0 then by:setEngineForceCommand('hover',vec3(),uf)end;local uB=bO:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)un=un..' , '..uu;uo=uo+uB end;if uo:len()>constants.epsilon then if lF~=0 or ux or bE(u5:dot(dp))<0.5 then un=un..', brake'end;by:setEngineForceCommand(un,uo,ug,'','','',uh)end end;local uC=aD*(u9-u8)local uD=vec3(bz.getWorldAirFrictionAngularAcceleration())uC=uC-uD;by:setEngineTorqueCommand('torque',uC,uf,'airfoil','','',uh)by:setBoosterCommand('rocket_engine')if f9 and not i then local dB=iZ:len()local uE=0.15;if not cl then local uF=bO:getTargetSpeed(axisCommandId.longitudinal)if dB*3.6>uF*(1-uE)and pw then pw=false;by:toggleBoosters()elseif dB*3.6<uF*(1-uE)and not pw then pw=true;by:toggleBoosters()end else local mt=bA.getThrottle()if p then mt=iY*100 end;local mF=mt/100;if bI==0 then mF=mF*V;if dB>=mF*(1-uE)and pw then pw=false;by:toggleBoosters()elseif dB<mF*(1-uE)and not pw then pw=true;by:toggleBoosters()end else local mS=bF(ex)mF=mF*mS/3.6;if dB>=mF*(1-uE)and pw then pw=false;by:toggleBoosters()elseif dB<mF*(1-uE)and not pw then pw=true;by:toggleBoosters()end end end end end;function script.onUpdate()if not t5 then local oS=coroutine.status(t6)if oS=="suspended"then local et,oT=coroutine.resume(t6)if oT then bB.print("ERROR STARTUP: "..oT)end elseif oS=="dead"then t5=true end end;if t5 then by:update()if not k7 and ka~=uG then bB.setScreen(ka)end;uG=ka end end;function script.onActionStart(p4)q5.startControl(p4)end;function script.onActionStop(p4)q5.stopControl(p4)end;function script.onActionLoop(p4)q5.loopControl(p4)end;function script.onInputText(nB)q5.inputTextControl(nB)end;function script.onEnter(oJ)if radar_1 and not d5 and not hL then bA.setTimer("contact",0.1)end end;function script.onLeave(oJ)if radar_1 and A then if#oM>650 then oJ=tostring(oJ)oM[oJ]=nil end end end;script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua:       if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua:       if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua:       if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
