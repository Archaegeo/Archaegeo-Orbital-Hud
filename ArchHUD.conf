name: ArchHud - Archaegeo v0.740 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.740;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=true;u=false;v=true;w=true;x=true;y=true;z=false;A=false;B=true;C=true;D=true;E=true;F=false;G=true;H=true;I=true;J={userControlScheme={set=function(K)g=K end,get=function()return g end},soundFolder={set=function(K)h=K end,get=function()return h end},freeLookToggle={set=function(K)i=K end,get=function()return i end},BrakeToggleDefault={set=function(K)j=K end,get=function()return j end},RemoteFreeze={set=function(K)k=K end,get=function()return k end},brightHud={set=function(K)m=K end,get=function()return m end},RemoteHud={set=function(K)l=K end,get=function()return l end},VanillaRockets={set=function(K)n=K end,get=function()return n end},InvertMouse={set=function(K)o=K end,get=function()return o end},autoRollPreference={set=function(K)p=K end,get=function()return p end},ExternalAGG={set=function(K)q=K end,get=function()return q end},UseSatNav={set=function(K)r=K end,get=function()return r end},ShouldCheckDamage={set=function(K)s=K end,get=function()return s end},AtmoSpeedAssist={set=function(K)t=K end,get=function()return t end},ForceAlignment={set=function(K)u=K end,get=function()return u end},DisplayDeadZone={set=function(K)v=K end,get=function()return v end},showHud={set=function(K)w=K end,get=function()return w end},hideHudOnToggleWidgets={set=function(K)x=K end,get=function()return x end},ShiftShowsRemoteButtons={set=function(K)y=K end,get=function()return y end},SetWaypointOnExit={set=function(K)z=K end,get=function()return z end},AlwaysVSpd={set=function(K)A=K end,get=function()return A end},BarFuelDisplay={set=function(K)B=K end,get=function()return B end},voices={set=function(K)C=K end,get=function()return C end},alerts={set=function(K)D=K end,get=function()return D end},CollisionSystem={set=function(K)E=K end,get=function()return E end},AbandonedRadar={set=function(K)F=K end,get=function()return F end},AutoShieldToggle={set=function(K)G=K end,get=function()return G end},PreventPvP={set=function(K)H=K end,get=function()return H end},DisplayOdometer={set=function(K)I=K end,get=function()return I end}}L=35;M=35;N=30;O=30;P=-30;Q=0;R=5000;S=1.2;T=2000;U=1050;V=66000;W=1000;X=50;Y=0;Z=100000;_=1.0;a0=32;a1=0;a2=0;a3=0;a4=0;a5=0;a6=0;a7={YawStallAngle={set=function(K)L=K end,get=function()return L end},PitchStallAngle={set=function(K)M=K end,get=function()return M end},brakeLandingRate={set=function(K)N=K end,get=function()return N end},MaxPitch={set=function(K)O=K end,get=function()return O end},ReEntryPitch={set=function(K)P=K end,get=function()return P end},LockPitchTarget={set=function(K)Q=K end,get=function()return Q end},AutopilotSpaceDistance={set=function(K)R=K end,get=function()return R end},TargetOrbitRadius={set=function(K)S=K end,get=function()return S end},LowOrbitHeight={set=function(K)T=K end,get=function()return T end},AtmoSpeedLimit={set=function(K)U=K end,get=function()return U end},SpaceSpeedLimit={set=function(K)V=K end,get=function()return V end},AutoTakeoffAltitude={set=function(K)W=K end,get=function()return W end},TargetHoverHeight={set=function(K)X=K end,get=function()return X end},LandingGearGroundHeight={set=function(K)Y=K end,get=function()return Y end},ReEntryHeight={set=function(K)Z=K end,get=function()return Z end},MaxGameVelocity={set=function(K)a8=K end,get=function()return a8 end},AutopilotInterplanetaryThrottle={set=function(K)_=K end,get=function()return _ end},warmup={set=function(K)a0=K end,get=function()return a0 end},fuelTankHandlingAtmo={set=function(K)a1=K end,get=function()return a1 end},fuelTankHandlingSpace={set=function(K)a2=K end,get=function()return a2 end},fuelTankHandlingRocket={set=function(K)a3=K end,get=function()return a3 end},ContainerOptimization={set=function(K)a4=K end,get=function()return a4 end},FuelTankOptimization={set=function(K)a5=K end,get=function()return a5 end},AutoShieldPercent={set=function(K)a6=K end,get=function()return a6 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=1750;av=350;aw=50;ax=250;ay=0;az=30;aA=100;aB={ResolutionX={set=function(K)a9=K end,get=function()return a9 end},ResolutionY={set=function(K)aa=K end,get=function()return aa end},circleRad={set=function(K)ab=K end,get=function()return ab end},SafeR={set=function(K)ac=K end,get=function()return ac end},SafeG={set=function(K)ad=K end,get=function()return ad end},SafeB={set=function(K)ae=K end,get=function()return ae end},PvPR={set=function(K)af=K end,get=function()return af end},PvPG={set=function(K)ag=K end,get=function()return ag end},PvPB={set=function(K)ah=K end,get=function()return ah end},centerX={set=function(K)ai=K end,get=function()return ai end},centerY={set=function(K)aj=K end,get=function()return aj end},throtPosX={set=function(K)ak=K end,get=function()return ak end},throtPosY={set=function(K)al=K end,get=function()return al end},vSpdMeterX={set=function(K)am=K end,get=function()return am end},vSpdMeterY={set=function(K)an=K end,get=function()return an end},altMeterX={set=function(K)ao=K end,get=function()return ao end},altMeterY={set=function(K)ap=K end,get=function()return ap end},fuelX={set=function(K)aq=K end,get=function()return aq end},fuelY={set=function(K)ar=K end,get=function()return ar end},shieldX={set=function(K)as=K end,get=function()return as end},shieldY={set=function(K)at=K end,get=function()return at end},radarX={set=function(K)au=K end,get=function()return au end},radarY={set=function(K)av=K end,get=function()return av end},DeadZone={set=function(K)aw=K end,get=function()return aw end},OrbitMapSize={set=function(K)ax=K end,get=function()return ax end},OrbitMapX={set=function(K)ay=K end,get=function()return ay end},OrbitMapY={set=function(K)az=K end,get=function()return az end},soundVolume={set=function(K)aA=K end,get=function()return aA end}}aC=5.0;aD=1.0;aE=0.003;aF=0.003;aG=2;aH=1.5;aI=180;aJ=150;aK=0.002;aL=2;aM=0.8;aN=1;aO=3;aP=1;aQ=40;aR=0.0666667;aS=0.0;aT="none"aU="none"aV="none"aW={speedChangeLarge={set=function(K)aC=K end,get=function()return aC end},speedChangeSmall={set=function(K)aD=K end,get=function()return aD end},MouseXSensitivity={set=function(K)aE=K end,get=function()return aE end},MouseYSensitivity={set=function(K)aF=K end,get=function()return aF end},autoRollFactor={set=function(K)aG=K end,get=function()return aG end},rollSpeedFactor={set=function(K)aH=K end,get=function()return aH end},autoRollRollThreshold={set=function(K)aI=K end,get=function()return aI end},minRollVelocity={set=function(K)aJ=K end,get=function()return aJ end},TrajectoryAlignmentStrength={set=function(K)aK=K end,get=function()return aK end},torqueFactor={set=function(K)aL=K end,get=function()return aL end},pitchSpeedFactor={set=function(K)aM=K end,get=function()return aM end},yawSpeedFactor={set=function(K)aN=K end,get=function()return aN end},brakeSpeedFactor={set=function(K)aO=K end,get=function()return aO end},brakeFlatFactor={set=function(K)aP=K end,get=function()return aP end},DampingMultiplier={set=function(K)aQ=K end,get=function()return aQ end},hudTickRate={set=function(K)aR=K end,get=function()return aR end},ExtraEscapeThrust={set=function(K)aS=K end,get=function()return aS end},ExtraLongitudeTags={set=function(K)aT=K end,get=function()return aT end},ExtraLateralTags={set=function(K)aU=K end,get=function()return aU end},ExtraVerticalTags={set=function(K)aV=K end,get=function()return aV end}}aX=j;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=false;b7=false;b8=1000;b9=false;ba=false;bb=false;bc=false;bd=0;be="Aligning"bf=0;bg=1;bh="None"bi=nil;bj=0;bk=nil;bl=0.0;bm=0;bn={}bo=false;bp=0;bq=0;br=nil;bs=0;bt=1000;bu=0;bv=false;bw=0;bx=false;by="All"bz=true;bA="Off"bB=0.000;bC={}bD={}bE={VertTakeOff={set=function(K)b7=K end,get=function()return b7 end},VertTakeOffEngine={set=function(K)aY=K end,get=function()return aY end},SpaceTarget={set=function(K)bv=K end,get=function()return bv end},BrakeToggleStatus={set=function(K)aX=K end,get=function()return aX end},BrakeIsOn={set=function(K)aZ=K end,get=function()return aZ end},RetrogradeIsOn={set=function(K)a_=K end,get=function()return a_ end},ProgradeIsOn={set=function(K)b0=K end,get=function()return b0 end},Autopilot={set=function(K)b1=K end,get=function()return b1 end},TurnBurn={set=function(K)b2=K end,get=function()return b2 end},AltitudeHold={set=function(K)b3=K end,get=function()return b3 end},BrakeLanding={set=function(K)b4=K end,get=function()return b4 end},Reentry={set=function(K)b6=K end,get=function()return b6 end},AutoTakeoff={set=function(K)b5=K end,get=function()return b5 end},HoldAltitude={set=function(K)b8=K end,get=function()return b8 end},AutopilotAccelerating={set=function(K)b9=K end,get=function()return b9 end},AutopilotBraking={set=function(K)bb=K end,get=function()return bb end},AutopilotCruising={set=function(K)bc=K end,get=function()return bc end},AutopilotRealigned={set=function(K)ba=K end,get=function()return ba end},AutopilotEndSpeed={set=function(K)bd=K end,get=function()return bd end},AutopilotStatus={set=function(K)be=K end,get=function()return be end},AutopilotPlanetGravity={set=function(K)bf=K end,get=function()return bf end},PrevViewLock={set=function(K)bg=K end,get=function()return bg end},AutopilotTargetName={set=function(K)bh=K end,get=function()return bh end},AutopilotTargetCoords={set=function(K)bi=K end,get=function()return bi end},AutopilotTargetIndex={set=function(K)bj=K end,get=function()return bj end},TotalDistanceTravelled={set=function(K)bl=K end,get=function()return bl end},TotalFlightTime={set=function(K)bm=K end,get=function()return bm end},SavedLocations={set=function(K)bn=K end,get=function()return bn end},VectorToTarget={set=function(K)bo=K end,get=function()return bo end},LocationIndex={set=function(K)bp=K end,get=function()return bp end},LastMaxBrake={set=function(K)bq=K end,get=function()return bq end},LockPitch={set=function(K)br=K end,get=function()return br end},LastMaxBrakeInAtmo={set=function(K)bs=K end,get=function()return bs end},AntigravTargetAltitude={set=function(K)bt=K end,get=function()return bt end},LastStartTime={set=function(K)bu=K end,get=function()return bu end},iphCondition={set=function(K)by=K end,get=function()return by end},stablized={set=function(K)bz=K end,get=function()return bz end},UseExtra={set=function(K)bA=K end,get=function()return bA end},SelectedTab={set=function(K)bF=K end,get=function()return bF end},saveRoute={set=function(K)bC=K end,get=function()return bC end},apRoute={set=function(K)bD=K end,get=function()return bD end}}local function bG(b,c,bH,bI,bJ)local a=DUSystem;local bK=DUConstruct;bL=bH()bM=0;bN=0;bO=false;bP=0;bQ=false;bR=false;bS=0;bT=0;bU=0;bV=0;bW=false;bX=false;bY="empty"bZ=3;b_=false;c0=0;c1=0;c2=nil;c3=0;c4=0;c5=0;c6=false;c7=false;c8=false;c9=-1;ca=bJ()>0;cb=bJ()cc=b.getAltitude()cd=DUConstruct.getMass()ce=nil;cf=a9;cg=aa;ch={}ci={}cj={}ck=nil;cl=nil;cm=nil;cn=nil;co=nil;cp=nil;cq=nil;cr=nil;cs=nil;ct=false;cu=false;cv=p;cw=false;cx=U;cy=nil;cz=0;cA=false;cB=false;cC=false;cD=vec3(bK.getWorldOrientationForward())cE=vec3(bK.getWorldOrientationRight())cF=vec3(bK.getVelocity())cG=vec3(bK.getWorldVelocity())cH=vec3(cG):len()cI=vec3(b.getWorldVertical())cJ=-cI:dot(cG)cK=vec3(bK.getWorldPosition())cL=false;cM=false;cN=true;cO=0;cP=0;cQ={}cR=false;cS=50000;cT=nil;cU=c.getClosestPlanetInfluence()>0 or cc>0 and cc<200000;cV=false;cW=nil;cX=false;cY=0;cZ=nil;c_=nil;d0={}d1=90;d2=w;d3=nil;d4=nil;d5={}d6={}d7=false;d8=nil;d9=0;da=false;db=bK.getMaxSpeed()if shield then dc=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function dd(de)a.print(bL..": "..de)end;local function df(d,b,c,a,dg,dh,di,dj,dk)local function dl(dm)return type(dm)=='number'end;local function dn(dm)return type(di(dm))=='number'end;local function dp(dq)return type(dq)=='table'end;local function dr(a)return type(a)=='string'end;local function ds(dt)return dp(dt)and dl(dt.x and dt.y and dt.z)end;local function du(dv)return dp(dv)and dl(dv.latitude and dv.longitude and dv.altitude and dv.id and dv.systemId)end;local dw=math.pi/180;local dx=180/math.pi;local dy=1e-10;local dz=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dA='::pos{'..dz..','..dz..','..dz..','..dz..','..dz..'}'local utils=utils;local vec3=vec3;local function dB(dm)local dC=string.gsub(string.reverse(dg('%.4f',dm)),'^0*%.?','')return dC==''and'0'or string.reverse(dC)end;local function dD(dE)if ds(dE)then return dg('{x=%.3f,y=%.3f,z=%.3f}',dE.x,dE.y,dE.z)end;if dp(dE)and not getmetatable(dE)then local dF={}local dG=next(dE)if type(dG)=='nil'or dG==1 then dF=dE else for dH,dt in pairs(dE)do local dI=dD(dt)if type(dH)=='number'then table.insert(dF,dg('[%s]=%s',dH,dI))else table.insert(dF,dg('%s=%s',dH,dI))end end end;return dg('{%s}',table.concat(dF,','))end;if dr(dE)then return dg("'%s'",dE:gsub("'",[[\']]))end;return tostring(dE)end;local dJ={}dJ.__index=dJ;dJ.__tostring=function(dE,dK)local dL={}for dH in pairs(dE)do table.insert(dL,dH)end;table.sort(dL)local dF={}for dM,dH in ipairs(dL)do local dI=dD(dE[dH])if type(dH)=='number'then table.insert(dF,dg('[%s]=%s',dH,dI))else table.insert(dF,dg('%s=%s',dH,dI))end end;if dK then return dg('%s%s',dK,table.concat(dF,',\n'..dK))end;return dg('{%s}',table.concat(dF,','))end;dJ.__eq=function(dN,dO)return dN.systemId==dO.systemId and dN.id==dO.id and dk(dN.radius,dO.radius)and dk(dN.center.x,dO.center.x)and dk(dN.center.y,dO.center.y)and dk(dN.center.z,dO.center.z)and dk(dN.GM,dO.GM)end;local function dP(dQ,dR,dS,dT,dU)assert(dn(dQ),'Argument 1 (systemId) must be a number:'..type(dQ))assert(dn(dR),'Argument 2 (id) must be a number:'..type(dR))assert(dn(dS),'Argument 3 (radius) must be a number:'..type(dS))assert(dp(dT),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dT))assert(dn(dU),'Argument 5 (GM) must be a number:'..type(dU))return setmetatable({systemId=di(dQ),id=di(dR),radius=di(dS),center=vec3(dT),GM=di(dU)},dJ)end;local dV={}dV.__index=dV;dV.__tostring=function(dd)return dg('::pos{%d,%d,%s,%s,%s}',dd.systemId,dd.id,dB(dd.latitude*dx),dB(dd.longitude*dx),dB(dd.altitude))end;dV.__eq=function(dN,dO)return dN.id==dO.id and dN.systemId==dO.systemId and dk(dN.latitude,dO.latitude)and dk(dN.altitude,dO.altitude)and(dk(dN.longitude,dO.longitude)or dk(dN.latitude,math.pi/2)or dk(dN.latitude,-math.pi/2))end;local function dW(dX,dR,dY,dZ,d_)local dQ=dX;if dr(dX)and not dZ and not d_ and not dR and not dY then dQ,dR,dY,dZ,d_=e0(dX,dA)assert(dQ,'Argument 1 (position string) is malformed.')else assert(dn(dQ),'Argument 1 (systemId) must be a number:'..type(dQ))assert(dn(dR),'Argument 2 (id) must be a number:'..type(dR))assert(dn(dY),'Argument 3 (latitude) must be in degrees:'..type(dY))assert(dn(dZ),'Argument 4 (longitude) must be in degrees:'..type(dZ))assert(dn(d_),'Argument 5 (altitude) must be in meters:'..type(d_))end;dQ=di(dQ)dR=di(dR)dY=di(dY)dZ=di(dZ)d_=di(d_)if dR==0 then return setmetatable({latitude=dY,longitude=dZ,altitude=d_,id=dR,systemId=dQ},dV)end;return setmetatable({latitude=dw*dh(dY,-90,90),longitude=dw*(dZ%360),altitude=d_,id=dR,systemId=dQ},dV)end;local e1={}e1.__index=e1;e1.__tostring=function(dE,dK)local e2=dK and dK..'  'local e3={}local dL={}for dH in pairs(dE)do table.insert(dL,dH)end;table.sort(dL)for dM,e4 in ipairs(dL)do e5=dE[e4]local e6=dJ.__tostring(e5,e2)if dK then table.insert(e3,dg('[%s]={\n%s\n%s}',e4,e6,dK))else table.insert(e3,dg('  [%s]=%s',e4,e6))end end;if dK then return dg('\n%s%s%s',dK,table.concat(e3,',\n'..dK),dK)end;return dg('{\n%s\n}',table.concat(e3,',\n'))end;local function e7(e8)local e={}local pid;for dM,dt in pairs(e8)do local dR=dt.planetarySystemId;if type(dR)~='number'then error('Invalid planetary s ID: '..tostring(dR))elseif pid and dR~=pid then error('Mistringmatch planetary s IDs: '..dR..' and '..pid)end;local e9=dt.bodyId;if type(e9)~='number'then error('Invalid body ID: '..tostring(e9))elseif e[e9]then error('Duplicate body ID: '..tostring(e9))end;setmetatable(dt.center,getmetatable(vec3.unit_x))e[e9]=setmetatable(dt,dJ)pid=dR end;return setmetatable(e,e1)end;ea={}local function eb(e8)return setmetatable({galaxyAtlas=e8 or{}},ea)end;ea.__index=function(dq,K)if type(K)=='number'then local a=dq.galaxyAtlas[K]return e7(a)end;return rawget(ea,K)end;ea.__pairs=function(dE)return function(dq,dH)local ec,ed=next(dq,dH)return ec,ed and e7(ed)end,dE.galaxyAtlas,nil end;ea.__tostring=function(dE)local ee={}for dM,ef in pairs(dE or{})do local eg=ef:getPlanetarySystemId()local eh=e1.__tostring(ef,'    ')table.insert(ee,dg('  [%s]={%s\n  }',eg,eh))end;return dg('{\n%s\n}\n',table.concat(ee,',\n'))end;ea.BodyParameters=dP;ea.MapPosition=dW;ea.PlanetarySystem=e7;function ea.createBodyParameters(dQ,dR,ei,ej,ek,el,em)assert(dn(dQ),'Argument 1 (systemId) must be a number:'..type(dQ))assert(dn(dR),'Argument 2 (id) must be a number:'..type(dR))assert(dn(ei),'Argument 3 (surfaceArea) must be a number:'..type(ei))assert(dp(ej),'Argument 4 (aPosition) must be an array or vec3:'..type(ej))assert(dp(ek),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(ek))assert(dn(el),'Argument 6 (altitude) must be in meters:'..type(el))assert(dn(em),'Argument 7 (gravityAtPosition) must be number:'..type(em))local dS=dj(ei/4/math.pi)local c5=dS+el;local en=vec3(ej)+c5*vec3(ek)local dU=em*c5*c5;return dP(dQ,dR,dS,en,dU)end;ea.isMapPosition=du;function ea:getPlanetarySystem(dX)if K==nil then K=0 end;if ed==nil then ed=0 end;local dQ=dX;if du(dX)then dQ=dX.systemId end;if type(dQ)=='number'then local a=self.galaxyAtlas[K]if a then if getmetatable(ed)~=e1 then a=e7(a)end;return a end end end;function e1:sizeCalculator(eo)return 1.05*eo.radius end;function e1:castIntersections(ep,eq,er,es,et,eu)local ev={}if et then for dM,eo in pairs(et)do table.insert(ev,eo)end else ev=d0 end;if not eu then table.sort(ev,function(ew,ex)local ey=ew.center;local ez=ex.center;return(ey.x-ep.x)^2+(ey.y-ep.y)^2+(ey.z-ep.z)^2<(ez.x-ep.x)^2+(ez.y-ep.y)^2+(ez.z-ep.z)^2 end)end;local eA=eq:normalize()for dM,eo in ipairs(ev)do local eB=eo.center-ep;local dS;if er then dS=er(eo)else dS=self:sizeCalculator(eo)end;local eC=eB:dot(eA)local eD=eC^2-(eB:len2()-dS^2)if eD>=0 then local eE=dj(eD)local eF=eC+eE;local eG=eC-eE;if eG>0 then return eo,eF,eG elseif eF>0 then return eo,eF,nil end end end;return nil,nil,nil end;function e1:closestBody(eH)assert(type(eH)=='table','Invalid coordinates.')local eI,eo;local eJ=vec3(eH)for dM,eK in pairs(self)do local eL=(eK.center-eJ):len2()if(not eo or eL<eI)and eK.name~="Space"then eo=eK;eI=eL end end;return eo end;function e1:convertToBodyIdAndWorldCoordinates(dX)local eM=dX;if dr(dX)then eM=dW(dX)end;if eM.id==0 then return 0,vec3(eM.latitude,eM.longitude,eM.altitude)end;local eK=self:getBodyParameters(eM)if eK then return eM.id,eK:convertToWorldCoordinates(eM)end end;function e1:getBodyParameters(dX)local dR=dX;if du(dX)then dR=dX.id end;assert(dn(dR),'Argument 1 (id) must be a number:'..type(dR))return self[dR]end;function e1:getPlanetarySystemId()local dM,dt=next(self)return dt and dt.systemId end;function dJ:convertToMapPosition(dT)assert(dp(dT),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dT))local eN=vec3(dT)if self.id==0 then return setmetatable({latitude=eN.x,longitude=eN.y,altitude=eN.z,id=0,systemId=self.systemId},dV)end;local eO=eN-self.center;local c5=eO:len()local d_=c5-self.radius;local dY=0;local dZ=0;if not dk(c5,0)then local eP=eQ(eO.y,eO.x)dZ=eP>=0 and eP or 2*math.pi+eP;dY=math.pi/2-math.acos(eO.z/c5)end;return setmetatable({latitude=dY,longitude=dZ,altitude=d_,id=self.id,systemId=self.systemId},dV)end;function dJ:convertToWorldCoordinates(dX)local eM=dr(dX)and dW(dX)or dX;if eM.id==0 then return vec3(eM.latitude,eM.longitude,eM.altitude)end;assert(du(eM),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eM.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eM.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local eR=math.cos(eM.latitude)return self.center+(self.radius+eM.altitude)*vec3(eR*math.cos(eM.longitude),eR*math.sin(eM.longitude),math.sin(eM.latitude))end;function dJ:getAltitude(dT)return(vec3(dT)-self.center):len()-self.radius end;function dJ:getDistance(dT)return(vec3(dT)-self.center):len()end;function dJ:getGravity(dT)local eS=self.center-vec3(dT)local eT=eS:len2()return self.GM/eT*eS/dj(eT)end;return setmetatable(ea,{__call=function(dM,...)return eb(...)end})end;local function eU(d,b,c,a,dj,eV)local cl={}local bK=100000000/3600;local eW=bK*bK;local eX=100;function cl.computeAccelerationTime(eY,eZ,e_)local f0=bK*math.asin(eY/bK)return(bK*math.asin(e_/bK)-f0)/eZ end;function cl.computeDistanceAndTime(eY,e_,f1,f2,f3,f4)f3=f3 or 0;f4=f4 or 0;local f5=eY<=e_;local f6=f2*(f5 and 1 or-1)/f1;local f7=-f4/f1;local f8=f6+f7;if f5 and f8<=0 or not f5 and f8>=0 then return-1,-1 end;local f9,fa=0,0;if f6~=0 and f3>0 then local f0=math.asin(eY/bK)local fb=math.pi*(f6/2+f7)local fc=f6*f3;local fd=bK*math.pi;local dt=function(dq)local fe=(fb*dq-fc*math.sin(math.pi*dq/2/f3)+fd*f0)/fd;local ff=math.tan(fe)return bK*ff/dj(ff*ff+1)end;local fg=f5 and function(a)return a>=e_ end or function(a)return a<=e_ end;fa=2*f3;if fg(dt(fa))then local fh=0;while eV(fa-fh)>0.5 do local dq=(fa+fh)/2;if fg(dt(dq))then fa=dq else fh=dq end end end;local fi=eY;local fj=fa/eX;for fk=1,eX do local fl=dt(fk*fj)f9=f9+(fl+fi)*fj/2;fi=fl end;if fa<2*f3 then return f9,fa end;eY=fi end;local f0=bK*math.asin(eY/bK)local bL=(bK*math.asin(e_/bK)-f0)/f8;local fm=eW*math.cos(f0/bK)/f8;local c5=fm-eW*math.cos((f8*bL+f0)/bK)/f8;return c5+f9,bL+fa end;function cl.computeTravelTime(eY,eZ,c5)if c5==0 then return 0 end;if eZ>0 then local f0=bK*math.asin(eY/bK)local fm=eW*math.cos(f0/bK)/eZ;return(bK*math.acos(eZ*(fm-c5)/eW)-f0)/eZ end;if eY==0 then return-1 end;assert(eY>0,'Acceleration and initial speed are both zero.')return c5/eY end;return cl end;local function fn(d,b,c,a,dg,dh,di,dj,dk)local vec3=vec3;local df=df(d,b,c,a,dg,dh,di,dj,dk)local function dr(a)return type(a)=='string'end;local function dp(dq)return type(dq)=='table'end;fo={}fo.__index=fo;function fo:escapeAndOrbitalSpeed(d_)assert(self.body)local c5=d_+self.body.radius;if not dk(c5,0)then local fp=dj(self.body.GM/c5)return dj(2)*fp,fp end;return nil,nil end;function fo:orbitalParameters(dX,fq)assert(self.body)assert(dp(dX)or dr(dX))assert(dp(fq))local fr=(dr(dX)or df.isMapPosition(dX))and self.body:convertToWorldCoordinates(dX)or vec3(dX)local dt=vec3(fq)local fs=fr-self.body.center;local ft=dt:len2()local fu=fs:len()local fv=self.body.GM;local fw=((ft-fv/fu)*fs-fs:dot(dt)*dt)/fv;local ey=fv/(2*fv/fu-ft)local fx=fw:len()local eA=fw:normalize()local fy=ey*(1-fx)local fz=ey*(1+fx)local fA=fy*eA+self.body.center;local fB=fx<=1 and-fz*eA+self.body.center or nil;local fC=dj(ey*fv*(1-fx*fx))local fD=fB and 2*math.pi*dj(ey^3/fv)local fE=math.acos(fw:dot(fs)/(fx*fu))if fs:dot(dt)<0 then fE=-(fE-2*math.pi)end;local fF=math.acos((math.cos(fE)+fx)/(1+fx*math.cos(fE)))local fG=fF;if fG<0 then fG=fG+2*math.pi end;local fH=fG-fx*math.sin(fG)local fI=0;local fJ=0;local fK=0;if fD~=nil then fI=fH/(2*math.pi/fD)fJ=fD-fI;fK=fJ+fD/2;if fE-math.pi>0 then fJ=fI;fK=fJ+fD/2 end;if fK>fD then fK=fK-fD end end;return{periapsis={position=fA,speed=fC/fy,circularOrbitSpeed=dj(fv/fy),altitude=fy-self.body.radius},apoapsis=fB and{position=fB,speed=fC/fz,circularOrbitSpeed=dj(fv/fz),altitude=fz-self.body.radius},currentVelocity=dt,currentPosition=fr,eccentricity=fx,period=fD,eccentricAnomaly=fF,meanAnomaly=fH,timeToPeriapsis=fJ,timeToApoapsis=fK,trueAnomaly=fE}end;local function fL(fM)local eK=df.BodyParameters(fM.systemId,fM.id,fM.radius,fM.center,fM.GM)return setmetatable({body=eK},fo)end;return setmetatable(fo,{__call=function(dM,...)return fL(...)end})end;local function fN(d,b,c,a,dbHud_1,e,fO,fP,bI,di,dj,fQ,fR)local function fS(fT)local dd=fU:closestBody(fT)if(fT-dd.center):len()>dd.radius+dd.noAtmosphericDensityAltitude then dd=e[0][0]end;return dd end;local function fV()local function fW(fX,fY)return fX.name<fY.name end;cQ={}for dH,dt in pairs(e[0])do cQ[#cQ+1]={name=dt.name,index=dH}end;table.sort(cQ,fW)end;local function fZ(f_,g0)if not g0 then g0=g1.name end;for dH,dt in pairs(f_)do if dt.name and dt.name==g0 then return dH end end;return-1 end;local function g2()cY=bj;if bj==0 then bh="None"c2=nil;g1=nil;return true end;local g3=cQ[bj].index;local g4=e[0][g3]if g4.center then bh=g4.name;c2=ck[0][g3]if g1~=nil then if cb==0 then if fO(g5,g6)~=1 then fP(g5,g6)end;if fO(g7,g8)~=1 then fP(g7,g8)end;if fO(g9,ga)~=1 then fP(g9,ga)end;if fO(gb,gc)~=1 then fP(gb,gc)end;if fO(gd,ge)~=1 then fP(gd,ge)end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end;if fO(gj,gk)~=1 then fP(gj,gk)end end;g1=nil else g1=g4;for dM,dt in pairs(ck[0])do if dt.name==g1.planetname then c2=dt;bh=g1.name;break end end;if fO(gf,gg)~=1 then fP(gf,gg)end;if fO(gh,gi)~=1 then fP(gh,gi)end end;if g1==nil then bi=vec3(c2.center)else bi=g1.position end;if c2.planetname~="Space"then if c2.hasAtmosphere then gl=bI(c2.radius*(S-1)+c2.noAtmosphericDensityAltitude)else gl=bI(c2.radius*(S-1)+c2.surfaceMaxAltitude)end else gl=R end;if g1~=nil and g1.planetname=="Space"then bd=0 else dM,bd=cm(c2):escapeAndOrbitalSpeed(gl)end;bf=0;b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"return true end;local function gm(gn)if not b1 and not bo and not c7 and not bx and not b6 and not c8 then if gn==nil then bj=bj+1;if bj>#cQ then bj=0 end else bj=bj-1;if bj<0 then bj=#cQ end end;if bj==0 then g2()else local g3=cQ[bj].index;local g4=e[0][g3]if g4 and(g4~=nil and g4.name=="Space"or by=="Custom Only"and g4.center or by=="No Moons"and string.find(g4.name,"Moon")~=nil)then if gn==nil then gm()else gm(1)end else g2()end end else bY="Disengage autopilot before changing Interplanetary Helper"fQ("iph","AP")end end;local function go()local function gp(gq)local gr;if gq then gr=d5 else gr=bn end;local gs=-1;gs=fZ(e[0])if gs>-1 then table.remove(e[0],gs)end;gs=-1;gs=fZ(gr)if gs~=-1 then bY=g1.name.." saved location cleared"table.remove(gr,gs)end;gm()fV()return gr end;if string.sub(bh,1,1)=="*"then d5=gp(true)else bn=gp(false)end end;local function gt(gu,fT,gv,gw)local function gx(gq)if gq then gr=d5 else gr=bn end;if dbHud_1 or gv or gq then local dd=fS(fT)local gy={position=fT,name=gu,planetname=dd.name,gravity=b.getGravityIntensity(),safe=gw}if not gv then gr[#gr+1]=gy else for dH,dt in pairs(e[0])do if dt.name and gu==dt.name then table.remove(e[0],dH)end end end;table.insert(e[0],gy)fV()g2()bY="Location saved as "..gu.."("..dd.name..")"return gr else bY="Databank must be installed to save permanent locations"end end;if string.sub(gu,1,1)=="*"then d5=gx(true)else bn=gx(false)end end;local gz={}function gz.UpdateAtlasLocationsList()fV()end;function gz.UpdateAutopilotTarget()g2()end;function gz.adjustAutopilotTargetIndex(gn)gm(gn)end;function gz.findAtlasIndex(f_,g0)return fZ(f_,g0)end;function gz.UpdatePosition(gA,gB,gC)local function gD(gq)local gr;if gq then gr=d5 else gr=bn end;local gs=fZ(gr)if gs~=-1 then if gA~=nil then if gq then gA="*"..gA end;gr[gs].name=gA;bj=bj-1;gm()elseif gC~=nil then if gC then local gE=cc;if gE<1000 then gE=1000 end;gr[gs].agg=fR(gE,0)bY=gr[gs].name.." AGG Altitude:"..gr[gs].agg.." saved ("..gr[gs].planetname..")"return elseif gC==false then gr[gs].agg=nil;bY=gr[gs].name.." AGG Altitude cleared ("..gr[gs].planetname..")"return end else local gF=gr[gs]if gB then gF.heading=cE:cross(cI)*5000;bY=gr[gs].name.." heading saved ("..gr[gs].planetname..")"return elseif gB==false then gF.heading=nil;bY=gr[gs].name.." heading cleared ("..gr[gs].planetname..")"return end;gF.gravity=b.getGravityIntensity()gF.position=cK;gF.safe=true end;bY=gr[gs].name.." position updated ("..gr[gs].planetname..")"else bY="Name Not Found"end end;if string.sub(bh,1,1)=="*"then gD(true)else gD(false)end end;function gz.AddNewLocation(gu,fT,gv,gw)gt(gu,fT,gv,gw)end;function gz.ClearCurrentPosition()go()end;for dH,dt in pairs(d6)do table.insert(e[0],dt)end;if gG then for dH,dt in pairs(gG)do gz[dH]=dt end end;fV()if bj>#cQ then bj=0 end;gz.UpdateAutopilotTarget()return gz end;local function gH(b,a,c,gI,radar_1,radar_2,eV,gJ,dj,gK,di,gL,fQ)local gM={}local gN={}local gO={XS=13,S=27,M=55,L=110,XL=221}local gP={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local gQ={}local gR=0;local gS;local gT;local gU;local gV;local gW={gV}local gX="Atmo"local gY;local gZ;local g_=0;local h0={}local h1;local h2=a.getArkTime()local vec3=vec3;local h3=table.insert;local h4=-4;local h5={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local function h6()local function h7(h8,h9,ha,hb,hc,hd,he,hf)h9,hb,hd,hf=vec3(h9),vec3(hb),vec3(hd),vec3(hf)local hg,hh,hi=h8*h8,ha*ha,hc*hc;local ft=hb-h9;local hj=ft:normalize()local hk=ft:len()local hl=hd-h9;local hm=(hl-hl:project_on(hj)):normalize()local hn,ho=hl:dot(hj),hl:dot(hm)local hp=hn*hn+ho*ho;local hq=hj:cross(hm)local hr=(hg-hh+hk*hk)/(2*hk)local hs=(hg-hi+hp-2*hn*hr)/(2*ho)local dv=hg-hr^2-hs^2;local ht=dj(dv)local hu=h9+hj*hr+hm*hs+hq*ht;local hv=h9+hj*hr+hm*hs-hq*ht;if eV((hf-hu):len()-he)<eV((hf-hv):len()-he)then return hu else return hv end end;local function hw(hx,fu,hy)local hz=hx.pts;local gs=#hz;local hA=hx.ref;if gs>3 then local hB,hC,hD,hE=hz[gs],hz[gs-1],hz[gs-2],hz[gs-3]hx.ref=hy;local fr=h7(hB[1],hB[2],hC[1],hC[2],hD[1],hD[2],hE[1],hE[2])local hr,hs,ht=fr.x,fr.y,fr.z;if hr==hr and hs==hs and ht==ht then hr=hr+hA[1]hs=hs+hA[2]ht=ht+hA[3]local hF=vec3(hr,hs,ht)hx.center=hF;if hx.lastPos then if(hx.lastPos-hF):len()<2 then local hG=(hF-vec3(hy)):len()if eV(hG-fu)<10 then hx.skipCalc=true end end end;hx.lastPos=hF end;hx.pts={}else local hH={hy[1]-hA[1],hy[2]-hA[2],hy[3]-hA[3]}hz[gs+1]={fu,hH}end end;if radar_1 or radar_2 then cq.assignRadar()end;if gV then gR=#gV.getConstructIds()if gR>0 then local hI=h1:gmatch('{"constructId[^}]*}[^}]*}')local hJ=gV.hasMatchingTransponder;local hK=gV.getConstructKind;local hL=gV.isConstructAbandoned;local hM=gV.getConstructName;local hy={cK["x"],cK["y"],cK["z"]}local hN,hO=0,0;local hP=cH*10;local cU=cU;gU,gT=0,0;for dt in hI do local dR,c5,hQ=dt:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hR=gO[hQ]c5=di(c5)if hJ(dR)==1 then h3(gN,dR)end;if E then local hS=hK(dR)local hT=F and hL(dR)==1;if hT or c5<hP and(hR>27 or hS==4 or hS==6)then gU=gU+1;local gu=hM(dR)local hx=h0[dR]if hx==nil then hR=hR+gL;h0[dR]={pts={},ref=hy,name=gu,i=0,radius=hR,skipCalc=false}hx=h0[dR]end;if not hx.skipCalc then hw(hx,c5,hy)if hT and not hx.abandoned and hx.center then local bL=a.getArkTime()if h2+5<bL then h2=bL;fQ("abRdr","RD")end;a.print("Abandoned Construct: "..gu.." ("..hQ.." "..gP[hS]..") at estimated ::pos{0,0,"..hx.center.x..","..hx.center.y..","..hx.center.z.."}")bY="Abandoned Radar Contact ("..hQ.." "..gP[hS]..") detected"hx.abandoned=true end;hO=hO+1 else h3(gQ,hx)end end;hN=hN+1;if cU and hN>700 or hO>70 or(not cU and hN>300 or hO>30)then coroutine.yield()hN,hO=0,0 end end end;gT=#gQ;if gT>0 and(cH>20 or b4)then local eo,hU,hV,hW;local hX=0;local hY=ck:getPlanetarySystem(0)hW=cG:normalize()while hX<gT do coroutine.yield()local hZ={table.unpack(gQ,hX,math.min(hX+75,gT))}eo,hU,hV=hY:castIntersections(cK,hW,nil,nil,hZ,true)if eo and hV then cW={eo,hU,hV}break end;hX=hX+75 end;if not eo then cW=nil end else cW=nil end;gQ={}gS=h1:find('identifiedConstructs":%[%]')end end end;local function h_()if gV then gX="Atmo"if h1:find('worksInAtmosphere":false')then gX="Space"end end end;function gM.pickType()h_()end;function gM.assignRadar()if radar_2 and h4~=1 then if h4==-1 then if gV==radar_2 then gV=radar_1 else gV=radar_2 end end;gW={gV}h1=gV.getWidgetData()h_()else h1=gV.getWidgetData()end;h4=gV.getOperationalState()end;function gM.UpdateRadar()local i0=coroutine.status(gY)if i0=="suspended"then local dI,i1=coroutine.resume(gY)if i1 then a.print("ERROR UPDATE RADAR: "..i1)end elseif i0=="dead"then gY=coroutine.create(h6)local dI,i1=coroutine.resume(gY)end end;function gM.GetRadarHud(i2,i3,au,av)local i4=gN;local i5,de;gN={}local dz=gT or 0;if gR>0 then if E then de=dz.."/"..gU.." Plotted : "..gR-gU.." Ignored"else de="Radar Contacts: "..gR end;i5=gK(au,av,de,"pbright txtbig txtmid")if#gN>0 then i5=i5 ..gK(i2,i3,"Friendlies In Range","pbright txtbig txtmid")for dH,dt in pairs(gN)do i3=i3+20;i5=i5 ..gK(i2,i3,gV.getConstructName(dt),"pdim txtmid")end end;if gS==nil and gZ==nil then g_=1;cq.ToggleRadarPanel()end;if gS~=nil and gZ~=nil then cq.ToggleRadarPanel()end;if d4==nil then cq.ToggleRadarPanel()end else if h4~=1 then i5=gK(au,av,gX.." Radar: "..h5[h4],"pbright txtbig txtmid")else i5=gK(au,av,"Radar: No "..gX.." Contacts","pbright txtbig txtmid")end;if d4~=nil then g_=0;cq.ToggleRadarPanel()end end;return i5 end;function gM.GetClosestName(gu)if gV then local dR,dM=gV.getWidgetData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if dR~=nil and dR~=""then gu=gu.." "..gV.getConstructName(dR)end end;return gu end;function gM.ToggleRadarPanel()if d4~=nil and g_==0 then gJ(d4)d4=nil;if gZ~=nil then gJ(gZ)gZ=nil end else if g_==1 then gJ(d4)d4=nil;_autoconf.displayCategoryPanel(gW,1,"Periscope","periscope")gZ=_autoconf.panels[_autoconf.panels_size]end;if d4==nil then _autoconf.displayCategoryPanel(gW,1,"Radar","radar")d4=_autoconf.panels[_autoconf.panels_size]end;g_=0 end end;function gM.ContactTick()if not i6 then i6=0 end;if bL>i6+10 then bY="Radar Contact"fQ("rdrCon","RC")i6=bL end;c.stopTimer("contact")end;function gM.onEnter(dR)if gV and not ca and not cR then c.setTimer("contact",0.1)end end;function gM.onLeave(dR)if gV and E then if#h0>650 then dR=tostring(dR)h0[dR]=nil end end end;gV=nil;if radar_2 and radar_2.getOperationalState()==1 then gV=radar_2 else gV=radar_1 end;h4=gV.getOperationalState()gW={gV}h1=gV.getWidgetData()h_()gY=coroutine.create(h6)if i7 then for dH,dt in pairs(i7)do gM[dH]=dt end end;return gM end;local function i8(shield,e0,bI)local i9={}local ia=shield.getResistancesCooldown()local function ib()local ic=shield.isActive()if G then if not cR and ic==0 and shield.isVenting()~=1 then shield.toggle()elseif cR and ic==1 then shield.toggle()end end end;local function id()local ie=shield.getStressRatioRaw()local ig=0.5999;if ie[1]==0.0 and ie[2]==0.0 and ie[3]==0.0 and ie[4]==0.0 then return end;local ih=shield.setResistances(ig*ie[1],ig*ie[2],ig*ie[3],ig*ie[4])if ih==1 then bY="Shield Resistances updated"else bY="Value Exceeded. Failed to update Shield Resistances"end end;function i9.shieldTick()dc=bI(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())ib()ia=shield.getResistancesCooldown()if ia==0 and dc<a6 then id()end end;function i9.setResist(ii)if not shield then bY="No shield found"return elseif ii==nil or ia>0 then bY="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dz=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dA=dz..', '..dz..', '..dz..', '..dz;local ij,ik,il,im=e0(ii,dA)if im==nil or ij+ik+il+im>0.6 then bY="Improperly formatted or total exceeds 0.6"return end;if shield.setResistances(ij,ik,il,im)==1 then bY="Shield Resistances set"else bY="Resistance setting failed."end end;function i9.ventShield()local io=shield.getVentingCooldown()if io>0 then bY="Cannot vent again for "..io.." seconds"return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()bY="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else bY="Shields already at max hitpoints"end end;if ip then for dH,dt in pairs(ip)do i9[dH]=dt end end;return i9 end;local function iq(d,b,c,a,e,antigrav,hover,shield,warpdrive,ir,eV,bI,dg,is,bJ,it,iu,eQ,bH,dh,iv,fP,fO,gJ,iw,dj,fR,gK,fQ,ix,iy,iz,iA,iB,iC)local bK=DUConstruct;local iD=9.80665;local iE={}local iF={}local iG={}local iH={}local iI=nil;local iJ=nil;local iK=nil;local iL=false;local iM="none"local iN=""local iO=55;local iP=0;local iQ=0;local iR=nil;local iS=ac;local iT=ad;local iU=ae;local iV=[[rgb(]]..bI(iS+0.5)..","..bI(iT+0.5)..","..bI(iU+0.5)..[[)]]local iW=[[rgb(]]..bI(iS*0.9+0.5)..","..bI(iT*0.9+0.5)..","..bI(iU*0.9+0.5)..[[)]]local iX=0;local iY=0;local iZ=""local i_=bH()local j0=false;local j1=false;local function j2(dt)if cf==1920 then return dt else return fR(cf*dt/1920,0)end end;local function j3(dt)if cg==1080 then return dt else return fR(cg*dt/1080,0)end end;local function j4()return iw()==0 and g~="keyboard"and iu()==0 end;local function j5()local j6="TRAVEL"if not cN then j6="CRUISE"end;if b1 then j6="AUTOPILOT"end;return j6 end;local i5=""local j7=""local j8=""local j9=1;local ja=2;local jb=3;local jc=4;local jd=5;local je=6;local jf=7;local jg=""local jh=0;local ji=120.0*aR;local jj={}local jk={}local jl={}local jm={}local jn={}local jo={}local jp={}jp["atmofueltank"],jp["spacefueltank"],jp["rocketfueltank"]=0,0,0;local jq=0;local function jr(hr,js,jt,ju,jv,jw)local jx=jq;local jy=jq+5;if not B then jy=jy+5 end;if iu()==1 and not l then jx=jx-50;jy=jy-50 end;if jt=="ATMO"then jg="atmofueltank"elseif jt=="SPACE"then jg="spacefueltank"else jg="rocketfueltank"end;jh=_G[jg.."_size"]if#ju>0 then for K=1,#ju do local gu=ju[K][ja]local jz=ju[K][jf]for jA=1,jh do if ju[K][ja]==is(c[jg.."_"..jA].getWidgetData()).name then jz=jA;break end end;local jB=bH()if jv[K]==nil or jw[K]==nil or jB-ju[K][je]>ji then local jC;local jD=0;jD=it(ju[K][j9])-ju[K][jc]jC=ju[K][jd]if jC>jD then jp[jg]=jp[jg]+jC-jD end;if jz~=0 then local jE=is(c[jg.."_"..jz].getWidgetData())jw[K]=jE.percentage;jv[K]=jE.timeLeft;if jv[K]=="n/a"then jv[K]=0 end else jw[K]=bI(0.5+jD*100/ju[K][jb])if jC<=jD then jv[K]=0 else jv[K]=bI(0.5+jD/((jC-jD)/(jB-ju[K][je])))end end;ju[K][je]=jB;ju[K][jd]=jD end;if gu==js then gu=dg("%s %d",jt,K)end;if jz==0 then gu=gu.." *"end;local jF;if jv[K]==0 then jF=""else jF=iA(jv[K])end;if jw[K]~=nil then local jG=bI(jw[K]*2.55)local jH=dg("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""if jF~=""and jv[K]<120 or jw[K]<5 then jI="red "end;local jJ=dg("rgb(%d,%d,%d)",dh(bI((255-jG)/2.55),50,100),dh(bI(jG/2.55),0,50),50)local jK="rgb(196,0,255)"if jt=="ATMO"then jK="rgb(0,188,255)"elseif jt=="SPACE"then jK="rgb(239,255,0)"end;local jL=false;if jM~=jK then jL=true end;jM=jK;if B then if jL then jx=jx-5;jy=jy-5 end;j7=j7 ..dg([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jJ,jK,hr,jy,jH,bI(jw[K]*1.7+0.5)-2,hr+1,jy+1,hr+5,jy+14,gu,jw[K],jF)jx=jx-22;jy=jy-22 else j7=j7 ..gK(hr,jx,gu,jI.."pdim txtfuel")j7=j7 ..gK(hr,jy,dg("%d%% %s",jw[K],jF),"pdim txtfuel","fill:"..jH)jx=jx+30;jy=jy+30 end end end end;jq=jx end;local function jN(jO,d_)if am==0 and an==0 then return end;if d_<200000 and not ca or d_ and ca then local jP=0;if eV(cJ)>1 then jP=45*math.log(eV(cJ),10)if cJ<0 then jP=-jP end end;jO[#jO+1]=dg([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bI(cJ),bI(jP))end;return jO end;local function jQ(jR)local gn=-cI;jR=jR-jR:project_on(gn)local jS=vec3(0,0,1)jS=jS-jS:project_on(gn)local jT=jS:cross(gn)local jP=jS:angle_between(jR)*constants.rad2deg;if jR:dot(jT)<0 then jP=360-jP end;return jP end;local function jU(jO,ai,aj,jV,jW,cU)if ab==0 then return end;local jX=ab;local jY=20;local jZ=bI(jV)if cU then for K=-45,45,5 do local j_=K;jO[#jO+1]=dg([[<g transform="rotate(%f,%d,%d)">]],j_,ai,aj)k0=5;if K%15==0 then k0=15 elseif K%10==0 then k0=10 end;jO[#jO+1]=dg([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jX+jY-k0,ai,aj+jX+jY)end;jO[#jO+1]=gK(ai,aj+jX+jY-35,jW,"pdim txt txtmid")jO[#jO+1]=gK(ai,aj+jX+jY-25,jZ.." deg","pdim txt txtmid")jO[#jO+1]=dg([[<g transform="rotate(%f,%d,%d)">]],-jV,ai,aj)jO[#jO+1]=dg([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jX+jY-20,ai+5,aj+jX+jY-20,ai,aj+jX+jY-15)jO[#jO+1]="</g>"end;jO[#jO+1]=[[<g style="clip-path: url(#headingClip);">]]local k1=jZ;if cU then k1=jQ(cD)end;local k2=20;local k3=bI(k1)local k4=0;local k5=aj+jX+jY+20;local k6=ai;if jW~="YAW"then k5=j3(130)k6=j2(960)end;local k7=[[<path class="txttick line" d="]]local k8=bI(k3-(k2+10)-k3%5+0.5)for K=k8+70,k8,-5 do local hr=k6-(-K*5+k1*5)if K%10==0 then k4=10;local dz=K;if dz==360 then dz=0 elseif dz>360 then dz=dz-360 elseif dz<0 then dz=dz+360 end;jO[#jO+1]=gK(hr,k5+15,dz,"txtmid bright")elseif K%5==0 then k4=5 end;if k4==10 then k7=dg([[%s M %f %f v %d]],k7,hr,k5-5,k4)else k7=dg([[%s M %f %f v %d]],k7,hr,k5-2.5,k4)end end;jO[#jO+1]=k7 ..[["/>]]jO[#jO+1]=dg([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],k6-5,k5-20,k6+5,k5-20,k6,k5-10)if I then if cU then jW="HDG"end;jO[#jO+1]=gK(j2(960),j3(100),k3 .."Â°","dim txt txtmid size14","")jO[#jO+1]=gK(j2(960),j3(85),jW,"dim txt txtmid size20","")end;jO[#jO+1]=[[</g>]]end;local function k9(jO,ka,jV,ai,aj,cU,kb,fl)if ab==0 then return end;local jX=ab;local kc=bI(jX*3/5)if jX>0 then local kd=bI(ka)local k0=0;local k7=dg([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jV,ai,aj)if not ca then k7=dg([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jO[#jO+1]=dg([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jX-1,ai,aj)jO[#jO+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for K=bI(kd-30-kd%5+0.5),bI(kd+30+kd%5+0.5),5 do if K%10==0 then k0=30 elseif K%5==0 then k0=20 end;local hs=aj+-K*5+ka*5;if k0==30 then k7=dg([[%s M %d %f h %d]],k7,ai-kc-k0,hs,k0)if ca then jO[#jO+1]=dg([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ai,aj,ai-kc+10,hs+4,K)jO[#jO+1]=dg([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jV,ai,aj,ai+kc-10,hs+4,K)if K==0 or K==180 or K==-180 then jO[#jO+1]=dg([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ai,aj,ai-kc+20,hs,kc*2-40)end else jO[#jO+1]=gK(ai-kc+10,hs,K,"pdim txt txtmid")jO[#jO+1]=gK(ai+kc-10,hs,K,"pdim txt txtmid")end;k7=dg([[%s M %d %f h %d]],k7,ai+kc,hs,k0)else k7=dg([[%s M %d %f h %d]],k7,ai-kc-k0,hs,k0)k7=dg([[%s M %d %f h %d]],k7,ai+kc,hs,k0)end end;jO[#jO+1]=k7 ..[["/>]]local ke="PITCH"if not cU then ke="REL PITCH"end;if ka>90 and not ca then ka=90-(ka-90)elseif ka<-90 and not ca then ka=-90-(ka+90)end;if jX>200 then if ca then if fl>iO then jO[#jO+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gK(ai,aj+20,kb,"pdim txt txtmid")end;jO[#jO+1]=dg([[<g transform="rotate(%f,%d,%d)">]],-jV,ai,aj)else jO[#jO+1]=dg([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jO[#jO+1]=dg([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-kc+25,aj-5,ai-kc+20,aj,ai-kc+25,aj+5,ai-kc+50,aj+4,kd)jO[#jO+1]=dg([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+kc-25,aj-5,ai+kc-20,aj,ai+kc-25,aj+5,ai+kc-30,aj+4,kd)jO[#jO+1]="</g>"end;local kf=bI(jX/3)jO[#jO+1]=dg([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-kf,aj,jX-kf)if not ca and cU then jO[#jO+1]=dg([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jV,ai,aj,ai-kc+10,aj,kc*2-20)end;jO[#jO+1]="</g>"if jX<200 then if ca and fl>iO then jO[#jO+1]=gK(ai,aj-jX,ke,"pdim txt txtmid")jO[#jO+1]=gK(ai,aj-jX+10,kd,"pdim txt txtmid")jO[#jO+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")jO[#jO+1]=gK(ai,aj+20,kb,"pdim txt txtmid")else jO[#jO+1]=gK(ai,aj-jX,ke,"pdim txt txtmid")jO[#jO+1]=gK(ai,aj-jX+15,kd,"pdim txt txtmid")end end end end;local function kg(jO,d_,cU)local kh=ao;local ki=ap;if kh==0 and ki==0 then return end;local kj=78;local kk=19;local kl=c9;if c9~=-1 then jO[#jO+1]=gK(kh+kj,ki+kk+20,dg("AGL: %.1fm",c9),"pdim altsm txtend")end;if cU and(d_<200000 and not ca or d_ and ca)then table.insert(jO,dg([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],kh-1,ki-4,kj+2,kk+6,kh+1,ki-1,kj-4,kk))local gs=0;local km=1;local kn=0;local ko=d_<0;local kp=d_<kq.surfaceMaxAltitude;local kr=9;if ko then kr=0 end;local d_=eV(d_)while gs<6 do local ks=11;local kt=16;local ku=9;local kv=14;local jI="altsm"if gs>2 then kt=kt+3;ks=ks+2;kv=kv+2;ku=ku-6;jI="altbig"end;if ko then jI=jI.." red"elseif kp then jI=jI.." orange"end;local kw=d_/km%10;local kx=bI(kw)local ky=bI((kx+1)%10)local kz=kn;if gs==0 then kz=kw-kx;if ko then kz=1-kz end end;if ko and(gs==0 or kn~=0)then local gv=ky;ky=kx;kx=gv end;local kA=kt*(kz-1)local kB=kA+kt;local hr=kh+ku+(6-gs)*ks;local hs=ki+kv;jO[#jO+1]=gK(hr,hs+kA,ky,jI)jO[#jO+1]=gK(hr,hs+kB,kx,jI)gs=gs+1;km=km*10;if kx==kr then kn=kz else kn=0 end end;table.insert(jO,[[</g></g>]])end end;local function kC(fq)local kD=-math.deg(eQ(fq.y,fq.z))+180;kD=kD-90;if kD<0 then kD=360+kD end;if kD>180 then kD=-180+kD-180 end;return-kD end;local function kE(fq)local k1=math.deg(eQ(fq.y,fq.x))-90;if k1<-180 then k1=360+k1 end;return k1 end;local function kF(jO,fq,fl,ai,aj)if fl>5 and not ca or fl>iO then local jX=ab;local kG=20;local kH=20;local kI=kC(fq)local kJ=kE(fq)local kK=14;local kL=kK/2;local kM=-kJ/kH*jX;local kN=kI/kG*jX;local hr=ai+kM;local hs=aj+kN;local c5=dj(kM^2+kN^2)local kO=[[<circle
                            cx="]]..hr..[["
                            cy="]]..hs..[["
                            r="]]..kL/kK..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hr..[["
                            cy="]]..hs..[["
                            r="]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hr-kK..[[,]]..hs..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hr+kL..[[,]]..hs..[[ h ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hr..[[,]]..hs-kK..[[ v ]]..kL..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if c5<jX then jO[#jO+1]=kO else local jP=eQ(kN,kM)local kP=4;local kQ=ai+jX*math.cos(jP)local kR=aj+jX*math.sin(jP)jO[#jO+1]=dg('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jP*180/math.pi,kQ,kR,kQ-kP,kR-kP/2,kP*2,kP,kQ+kP,kR-kP,kP,kP,-kP,kP)end;if not ca then local kS=vec3(fq)kI=kC(-kS)kJ=kE(-kS)kM=-kJ/kH*jX;kN=kI/kG*jX;hr=ai+kM;hs=aj+kN;c5=dj(kM^2+kN^2)if c5<jX then local kT=[[<circle
                                    cx="]]..hr..[["
                                    cy="]]..hs..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hr..[[,]]..hs-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hr..[[,]]..hs..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hr..[[,]]..hs..[[)" />
                                <path
                                    d="M ]]..hr-kL..[[,]]..hs..[[ h ]]..kK..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hr..[[,]]..hs..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hr..[[,]]..hs..[[)"/>]]jO[#jO+1]=kT end end end end;local function kU(jO,j6,kV,kW)if ak==0 and al==0 then return end;kV=bI(kV+0.5)local jx=al+10;local jy=al+20;if iu()==1 and not l then jx=55;jy=65 end;local kX="CRUISE"local c="km/h"local dI=kW;if j6=="TRAVEL"or j6=="AUTOPILOT"then kX="THROT"c="%"dI=kV;local kY="dim"if kV<0 then kY="red"end;jO[#jO+1]=dg([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kY,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-eV(kV),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jO[#jO+1]=gK(ak+10,jx,kX,"pbright txtstart")jO[#jO+1]=gK(ak+10,jy,dg("%.0f %s",dI,c),"pbright txtstart")if ca and t and cN and bO then kV=bI(bP*100+0.5)local kY="red"if kV<0 then kY="red"end;jO[#jO+1]=dg([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kY,1-eV(kV),ak-10,al+50,ak-15,al+53,ak-15,al+47)jO[#jO+1]=gK(ak+10,jx+40,"LIMIT","pbright txtstart")jO[#jO+1]=gK(ak+10,jy+40,kV.."%","pbright txtstart")end;if ca and t or b6 then jO[#jO+1]=gK(ak+10,jx-40,"LIMIT: "..cx.." km/h","dim txtstart")elseif not ca and b1 then jO[#jO+1]=gK(ak+10,jx-40,"LIMIT: "..bI(a8*3.6+0.5).." km/h","dim txtstart")end end;local function kZ(jO,k_)if ak==0 and al==0 then return end;local l0=al-10;local l1=ak+10;jO[#jO+1]=gK(0,0,"","pdim txt txtend")if iu()==1 and not l then l0=75 end;jO[#jO+1]=gK(l1,l0,bI(k_).." km/h","pbright txtbig txtstart")end;local function l2(jO)jO[#jO+1]=gK(j2(150),j3(1070),dg("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jO[#jO+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jO[#jO+1]=gK(j2(960),j3(550),"Warning: Invalid Control Scheme Detected","warnings")jO[#jO+1]=gK(j2(960),j3(600),"Keyboard Scheme must be selected","warnings")jO[#jO+1]=gK(j2(960),j3(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local l3=j2(960)local l4=j3(860)local l5=j3(880)local l6=j3(900)local l7=j3(960)local l8=j3(200)local l9=j3(250)local la=j3(960)if iu()==1 and not l then l4=j3(135)l5=j3(155)l6=j3(175)l8=j3(115)l9=j3(95)end;local lb="#222222"local lc="white"local ld="dimmer"local le="pbright"local lf="#110000"local lg=lb;local lh=ld;if aZ then local li=""if type(aZ)=="string"then li="-"..aZ end;jO[#jO+1]=gK(l3,l4,"Brake Engaged"..li,"warnings")lf="#440000"lg=lc;lh=le elseif bN>0 then jO[#jO+1]=gK(l3,l4,"Auto-Brake Engaged","warnings","opacity:"..bN)end;local lj="#110000"local lk=lb;local ll=ld;if ca and cw and c9==-1 then if not b1 and not bo and not b4 and not cM and not b7 and not b5 then jO[#jO+1]=gK(l3,l8+50,"** STALL WARNING **","warnings")lj="#ff0000"lk=lc;ll=le;fQ("stall","SW",2)end end;if cT then jO[#jO+1]=gK(l3,l8+90,"Flight Assist in Progress","warnings")end;if ce then jO[#jO+1]=gK(l3,la,"Gyro Enabled","warnings")end;local lm="#111100"local ln=lb;local lo=ld;if bk then lm="#775500"ln=lc;lo=le;if bR then jO[#jO+1]=gK(l3,l5,"Gear Extended","warn")else jO[#jO+1]=gK(l3,l5,"Landed (G: Takeoff)","warnings")end end;if c9>-1 and(not cM or cc<100)then local lp=iz(d:getTargetGroundAltitude())jO[#jO+1]=gK(l3,l6,"Hover Height: "..lp,"warn")end;local lq="#000011"local lr=lb;local ls=ld;if b_ then lq="#0000DD"lr=lc;ls=le;jO[#jO+1]=gK(l3,l7+20,"ROCKET BOOST ENABLED","warn")end;local lt="#001100"local lu=lb;local lv=ld;if antigrav and not q and cM and bt~=nil then lt="#00DD00"lu=lc;lv=le;local lw="warnings"if eV(cc-antigrav.getBaseAltitude())<501 then lw="warn"end;jO[#jO+1]=gK(l3,l8+40,dg("Target Altitude: %d Singularity Altitude: %d",bI(bt),bI(antigrav.getBaseAltitude())),lw)end;if b1 and bh~="None"then jO[#jO+1]=gK(l3,l8,"Autopilot "..be,"warn")elseif br~=nil then jO[#jO+1]=gK(l3,l8+20,dg("LockedPitch: %d",bI(br)),"warn")elseif bW then jO[#jO+1]=gK(l3,l8+20,"Follow Mode Engaged","warn")elseif b6 or c8 then jO[#jO+1]=gK(l3,l8+20,"Re-entry in Progress","warn")end;if b3 or b7 then local lp=iz(b8,2)if b7 then if cM then lp=iz(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jO[#jO+1]=gK(l3,l8,"VTO to "..lp,"warn")elseif b5 and not bx then if c7 then jO[#jO+1]=gK(l3,l8,"Takeoff to "..bh,"warn")else jO[#jO+1]=gK(l3,l8,"Takeoff to "..lp,"warn")end;if aZ and not b7 then jO[#jO+1]=gK(l3,l8+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else jO[#jO+1]=gK(l3,l8,"Altitude Hold: "..dg("%.1fm",b8),"warn")end end;if b7 and(antigrav~=nil and antigrav)then if cb>0.1 then jO[#jO+1]=gK(l3,l8+20,"Beginning ascent","warn")elseif cb<0.09 and cb>0.05 then jO[#jO+1]=gK(l3,l8+20,"Aligning trajectory","warn")elseif cb<0.05 then jO[#jO+1]=gK(l3,l8+20,"Leaving atmosphere","warn")end end;if bx then if cy~=nil then jO[#jO+1]=gK(l3,l8,cy,"warn")end end;if b4 then if lx then local ly="Brake Landing"if d8 then ly=ly.."-Aligning"end;if d7 then ly=ly.."-Drift Limited"end;jO[#jO+1]=gK(l3,l8,ly,"warnings")else jO[#jO+1]=gK(l3,l8,"Coast-Landing","warnings")end end;if b0 then jO[#jO+1]=gK(l3,l8,"Prograde Alignment","crit")end;if a_ then jO[#jO+1]=gK(l3,l8,"Retrograde Alignment","crit")end;local lz="#110000"local lA=lb;local lB=ld;if cV then lz="#FF0000"lA=lc;lB=le;local type;if string.find(cV,"COLLISION")then type="warnings"else type="crit"end;jO[#jO+1]=gK(l3,l9+20,cV,type)elseif cb==0 then local lC,lD=cp.checkLOS(cG:normalize())if lD~=nil then lB=le;lz="#FF0000"lA=lc;local lp=iz(lD)local lE=cl.computeTravelTime(cH,0,lD)local lF="Collision"if lC.noAtmosphericDensityAltitude>0 then lF="Atmosphere"end;jO[#jO+1]=gK(l3,l9+20,lC.name.." "..lF.." "..iA(lE).." In "..lp,"crit")end end;if bo and not bx then jO[#jO+1]=gK(l3,l8+60,lG,"warn")end;local lH="#111100"local lI=lb;local lJ=ld;if cZ and#cZ>1 then lH="#DDDD00"lI=lc;lJ=le end;local lK=j2;local lL=j3;local ld="topButton"local lM="topButtonActive"local lN=ld;if b1 or bo or c7 or bx then lN=lM end;local lO=ld;if b0 then lO=lM end;local lP=ld;if b4 or bk then lP=lM end;local lQ=ld;if b3 or bo then lQ=lM end;local lR=ld;if a_ then lR=lM end;local lS=ld;if bx or cA and b1 then lS=lM end;if w and I then local lT=lL(30)jO[#jO+1]=dg([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lN,lK(960),lL(54),lL(-53),lK(-120),lK(25),lL(50))jO[#jO+1]=gK(lK(910),lT,"AUTOPILOT")jO[#jO+1]=dg([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lO,lK(865),lL(51),lK(-25),lL(-50),lK(-110),lK(25),lL(46))jO[#jO+1]=gK(lK(800),lT,"PROGRADE")jO[#jO+1]=dg([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lP,lK(755),lL(47),lK(-25),lL(-46),lK(-98),lK(44),lL(44))jO[#jO+1]=gK(lK(700),lT,"LAND")jO[#jO+1]=dg([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lQ,lK(960),lL(54),lL(-53),lK(120),lK(-25),lL(50))jO[#jO+1]=gK(lK(1010),lT,"ALT HOLD")jO[#jO+1]=dg([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lR,lK(1055),lL(51),lK(25),lL(-50),lK(110),lK(-25),lL(46))jO[#jO+1]=gK(lK(1122),lT,"RETROGRADE")jO[#jO+1]=dg([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lS,lK(1165),lL(47),lK(25),lL(-46),lK(98),lK(-44),lL(44))jO[#jO+1]=gK(lK(1220),lT,"ORBIT")jO[#jO+1]=[[
                                    </g>
                                </g>]]jO[#jO+1]="</g>"end;return jO end;local function lU(fl)return bI(fR(fl*3.6,0)+0.5).." km/h"end;local function lV(gs)local gu=bh;if gs~=nil and type(gs)=="number"then if gs==0 then return"None"end;gu=cQ[gs].name end;if gu==nil then gu=g1.name end;if gu==nil then gu="None"end;return gu end;local function lW(jO)local lX=cp.routeWP(true)if not lX or#lX==0 then return end;local hr=j2(750)local hs=j3(360)if b1 or bo then jO[#jO+1]=gK(hr,hs,"REMAINING ROUTE","pdim txtstart size20")else jO[#jO+1]=gK(hr,hs,"LOADED ROUTE","pdim txtstart size20")end;for dH,K in pairs(lX)do hs=hs+20;jO[#jO+1]=gK(hr,hs,dH..". "..lX[dH],"pdim txtstart size20")end end;local function lY(jO)local hr=ay+10;local hs=az+20;local lZ={}local l_={"Alt-4: AutoTakeoff to Target"}local m0={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local m1={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear","Alt-W: Toggle prograde align","Alt-S: Toggle retrograde align / Turn&Burn (AP)"}local m2={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lZ,"--------------DYNAMIC-----------------")if ca then if c9~=-1 then ix(lZ,l_)if c2 and kq and c2.name==kq.name then table.insert(lZ,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aY then if antigrav then if cM then table.insert(lZ,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lZ,"Turn on AGG to takeoff to AGG Height")end end;if aY then table.insert(lZ,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lZ,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lZ,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bk then table.insert(lZ,"G: Takeoff to hover height, raise gear")else table.insert(lZ,"G: Lowergear and Land")end else ix(lZ,m0)table.insert(lZ,"G: Begin BrakeLanding or Land")end;if b7 then table.insert(lZ,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ix(lZ,m1)if shield then table.insert(lZ,"Alt-Shift-6: Vent shields")if not G then table.insert(lZ,"Alt-Shift-7: Toggle shield off/on")end end end;if g1~=nil then table.insert(lZ,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lZ,"Alt-9: Activate Gyroscope")end;if aU~="none"or aT~="none"or aV~="none"then table.insert(lZ,"Alt-Shift-9: Cycles engines with Extra tags")end;if b3 then table.insert(lZ,"Alt-Spacebar/C will raise/lower target height")table.insert(lZ,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if t or not ca then table.insert(lZ,"LALT+Mousewheel will lower/raise speed limit")end;ix(lZ,m2)for K=1,#lZ do hs=hs+12;jO[#jO+1]=gK(hr,hs,lZ[K],"pdim txtbig txtstart")end end;local function m3(jO)local m4=ay;local m5=az;local m6=ax;local m7=4;local m8=15;local hr=0;local hs=0;local m9,ma,mb,mc;local md;local function me(type)local gE,bL,fl,mf,jI,mg;if type=="Periapsis"then gE=md.periapsis.altitude;bL=md.timeToPeriapsis;fl=md.periapsis.speed;jI="txtend"mf=12;mg=math.min(hr,m4+m6-kq.radius/mb-m7*2)else gE=md.apoapsis.altitude;bL=md.timeToApoapsis;fl=md.apoapsis.speed;mf=-12;jI="txtstart"mg=hr end;if cH<1 then bL=0 end;jO[#jO+1]=dg([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg+mf,hs-5,hr,hs-5)jO[#jO+1]=dg([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],mg-mf*4,hs+2,hr,hs+2)jO[#jO+1]=gK(mg,hs,type,jI)hr=mg-mf*2;hs=hs+m8;local lp=iz(gE)jO[#jO+1]=gK(hr,hs,lp,jI)hs=hs+m8;jO[#jO+1]=gK(hr,hs,iA(bL),jI)hs=hs+m8;jO[#jO+1]=gK(hr,hs,lU(fl),jI)end;local mh=m6*1.5;if bF=="INFO"then mh=25*9 end;if bF~="HIDE"then jO[#jO+1]=[[<g class="pbright txtorb txtmid">]]jO[#jO+1]=dg('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',m6*2,mh,m4,m5)jO[#jO+1]=dg([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],m6*2,mh,m4,m5)end;local mi=m6*1.5;local mj=m6*2;local mk=mi/2;local ml=m6;local mm=m4+ml;local mn=m5+mk;local mo=m4+mj;local mp=m5+mi;if bF=="ORBIT"then m5=m5+m7;m9=m6/2;mc=0;md={}md.periapsis={}md.apoapsis={}if fp~=nil then if fp.periapsis~=nil then md.periapsis.altitude=fp.periapsis.altitude;md.periapsis.speed=fp.periapsis.speed end;if fp.apoapsis~=nil then md.apoapsis.altitude=fp.apoapsis.altitude;md.apoapsis.speed=fp.apoapsis.speed end;md.period=fp.period;md.eccentricity=fp.eccentricity;md.timeToApoapsis=fp.timeToApoapsis;md.timeToPeriapsis=fp.timeToPeriapsis;md.eccentricAnomaly=fp.eccentricAnomaly;md.trueAnomaly=fp.trueAnomaly end;if md.periapsis==nil then md.periapsis={}md.periapsis.altitude=-kq.radius;md.periapsis.speed=a8 end;if md.eccentricity==nil then md.eccentricity=1 end;if md.apoapsis==nil then md.apoapsis={}md.apoapsis.altitude=cc;md.apoapsis.speed=0 end;if cH<1 then md.apoapsis.altitude=cc;md.apoapsis.speed=0 end;if md.apoapsis.altitude then mb=(md.apoapsis.altitude+md.periapsis.altitude+kq.radius*2)/(m9*2)ma=(kq.radius+md.apoapsis.altitude)/mb*(1-md.eccentricity)mc=m9-md.periapsis.altitude/mb-kq.radius/mb;local mq=math.pi;if md.period~=nil and md.period>0 and md.timeToApoapsis~=nil then mq=md.eccentricAnomaly;if md.timeToPeriapsis<md.timeToApoapsis then mq=2*math.pi-mq end end;if cH<1 or mq~=mq then mq=math.pi end;local mr=-m9*math.cos(mq)+m4+ml+m7;local ms=ma*math.sin(mq)+m5+mk+m7;local mt=""jO[#jO+1]='<g clip-path="url(#orbitRect)">'jO[#jO+1]=dg([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],mt,m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)if ma<1 then jO[#jO+1]=dg([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],m4+m6+m7-mc,m5+m6*1.5/2+m7,mr,ms)end;jO[#jO+1]=dg('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,(kq.radius+kq.noAtmosphericDensityAltitude)/mb)jO[#jO+1]=dg('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',m4+m6+m7-mc,m5+m6*1.5/2+m7,(kq.radius+kq.noAtmosphericDensityAltitude)/mb)jO[#jO+1]=dg([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",m4+m6+m7,m5+m6*1.5/2+m7,m9,ma)jO[#jO+1]=dg('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',m4+m6+m7-mc,m5+m6*1.5/2+m7,kq.radius/mb)jO[#jO+1]='</g>'local mu=math.floor(kq.radius/mb+0.5)hr=m4+m6+m7*4+m9;hs=m5+m6*1.5/2+5+m7;if md.apoapsis~=nil and md.apoapsis.speed<a8 then me("Apoapsis")end;hs=m5+m6*1.5/2+5+m7;hr=m4+m6-m7*2-m9;if md.periapsis~=nil and md.periapsis.speed<a8 and md.periapsis.altitude>0 then me("Periapsis")end;jO[#jO+1]=gK(m4+m6+m7,m5+20+m7,kq.name,"txtorbbig")jO[#jO+1]=dg('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',mr,ms)jO[#jO+1]=[[</g>]]return jO else jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mv=""local mw=1.2*(mx-my)/(m6*2)local mz=1.4*(mA-mB)/(m6*1.5)for dH,dt in pairs(e[0])do if dt.center then local hr=m4+m6+dt.center.x/mw;local hs=m5+m6*1.5/2+dt.center.y/mz;mv=mv..'<circle cx="'..hr..'" cy="'..hs..'" r="'..dt.radius/mw*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dt.name,"Moon")and not string.match(dt.name,"Sanctuary")and not string.match(dt.name,"Space")then mv=mv.."<text x='"..hr.."' y='"..hs+dt.radius/mw*30+20 .."' font-size='12' fill="..iV.." text-anchor='middle' font-family='Montserrat'>"..dt.name.."</text>"end end end;local fr=vec3(bK.getWorldPosition())local hr=m4+m6+fr.x/mw;local hs=m5+m6*1.5/2+fr.y/mz;mv=mv..'<circle cx="'..hr..'" cy="'..hs..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mv=mv.."<text x='"..hr.."' y='"..hs-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iI=mw;iJ=mz;local mC=fr+cG*1000000;local mD=m4+m6+mC.x/mw;local jy=m5+m6*1.5/2+mC.y/mz;mv=mv..'<line x1="'..hr..'" y1="'..hs..'" x2="'..mD..'" y2="'..jy..'" stroke="purple" stroke-width="1"/>'jO[#jO+1]=mv;jO[#jO+1]='</g>'end elseif bF=="INFO"then jO=cn.DrawOdometer(jO,iX,bl,iY)elseif bF=="HELP"then jO=lY(jO)elseif bF=="SCOPE"then jO[#jO+1]='<g clip-path="url(#orbitRect)">'local mE=d1;if cb>0 then table.sort(d0,function(ew,ex)local ey,ez=ew.center,ex.center;return(ey.x-cK.x)^2+(ey.y-cK.y)^2+(ey.z-cK.z)^2<(ez.x-cK.x)^2+(ez.y-cK.y)^2+(ez.z-cK.z)^2 end)end;local mF={}local mG={}local mH=120;local mI=nil;local mJ=nil;for K,dt in ipairs(d0)do local gS=dt.center-cK;local mK=gS:len()local mL=gS:normalize()local mM=gS:cross(cD):normalize()local mN=math.acos(mM:dot(cE))if mN~=mN then mN=0 end;if mM:cross(cE):dot(cD)<0 then mN=-mN end;local mO=gS:project_on_plane(cD):len()local mP=math.sin(mN)*math.asin(mO/mK)*constants.rad2deg;local mQ=math.cos(mN)*math.asin(mO/mK)*constants.rad2deg;if mL:dot(cD)<0 then mQ=90*math.cos(mN)+90*math.cos(mN)-mQ;mP=90*math.sin(mN)+90*math.sin(mN)-mP end;local hr=mm+mP/mE*mi;local hs=mn+mQ/mE*mi;local mR=(hr-mm)*(hr-mm)+(hs-mn)*(hs-mn)local mS=math.asin((dt.radius+dt.surfaceMaxAltitude)/mK)*constants.rad2deg;if mS~=mS then mS=mE end;local hQ=mS/mE*mi;local mT=math.asin(dt.atmosphereRadius/mK)*constants.rad2deg;if mT~=mT then mT=mS end;local mU=mT/mE*mi;local c5=iz(mK,1)local mV=dt.name;local mW=false;if hs>m5 then if hs>mp then if hs-mU<=mp then mW=true end else mW=true end else if hs+mU>=m5 then mW=true end end;local mX=false;local mY=hr;if dt.systemId==0 then mY=hr+mH else mY=hr-mH end;if mY+mH>m4 then if mY+mH>mo then if mY-mU-mH<=mo then mX=true end else mX=true end else if mY+mU+mH>=m4 then mX=true end end;local mZ={}mZ.x=hr;mZ.y=hs;mZ.planet=dt;mZ.atmoSize=mU;if not mI or mR<mI then mI=mR;mJ=mZ end;if mX and mW then local m_=math.max(mU,5)if mR<m_*m_ then mV=mV.." - "..c5 end;mZ.size=hQ;mZ.i=K;mZ.displayString=mV;mZ.distance=c5;mZ.visible=true;mG[#mG+1]=mZ else mZ.visible=false end end;local n0=false;table.sort(mG,function(ey,ez)return ey.y<ez.y end)for dH,fu in ipairs(mG)do local dt,hQ,K,mU,hr,hs,mV,c5=fu.planet,fu.size,fu.i,fu.atmoSize,fu.x,fu.y,fu.displayString,fu.distance;local mg,n1,n2,n3;local n4=15;local jI="pdim"if dt.systemId~=0 then n2=j2(string.len(mV)*5)n4=-(15+n2)n3=j3(10)jI="pdimfill"else n2=j2(string.len(mV)*9)n3=j3(15)end;if hQ*2>n2 then mg=dh(hr,m4+n2/2,mo-n2/2)n1=dh(hs,m5+n3,mp-5)mg=dh(mg,hr-hQ+n2/2,hr+hQ-n2/2)n1=dh(n1,hs-hQ+n3,hs+hQ)else mg=hr+n4;n1=hs end;for n5,fu in pairs(mF)do local n6=fu.textPositions;local n7=n6.y-n1;if n5~=K and eV(n7)<n6.height and n6.x+n6.width>mg and n6.x<mg+n2 then if hQ>n2 then n1=dh(n1+n3,m5+15,mp-5)else n1=n6.y+n6.height+1 end end end;local n8=mV~=dt.name or mg<=mm and mg+n2>=mm and n1-n3<=mn and n1>=mn;fu.hovered=n8;local n9=1;if n8 then n9=2;if hQ*2<n2 then n9=10 end;if mV==dt.name then mV=mV.." - "..c5 end;jI="pbright"if dt.systemId~=0 then n2=j2(string.len(mV)*5)n4=-(15+n2)else n2=j2(string.len(mV)*7)end;if hQ*2>n2 then mg=dh(hr,m4+n2/2,mo-n2/2)mg=dh(mg,hr-hQ+n2/2,hr+hQ-n2/2)else mg=hr+n4 end end;mF[K]={}mF[K].textPositions={}mF[K].textPositions.y=n1;mF[K].textPositions.x=mg;mF[K].textPositions.width=n2;mF[K].textPositions.height=n3;mF[K].output=""if hQ*2>n2 then jI=jI.." txtmid"else jI=jI.." txtstart"end;if mU-hQ>2 then mF[K].output=dg('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hr,hs,mU,iW,0.1*n9)end;mF[K].output=mF[K].output..dg('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hr,hs,hQ,iW,0.2*n9)if dt.systemId==0 then mF[K].output=mF[K].output..dg([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n1,iV,jI,mV)if hQ*2<=n2 then mF[K].output=mF[K].output..dg("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg+n2,n1+2,mg,n1+2,hr,hs)end else mF[K].output=mF[K].output..dg([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],mg,n1,iW,jI,mV)if hQ*2<=n2 then mF[K].output=mF[K].output..dg("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",mg,n1+2,mg+n2,n1+2,hr,hs)end end end;for dH=#d0,1,-1 do if mF[dH]then jO[#jO+1]=mF[dH].output end end;if mJ~=nil and d1<90 and not mJ.hovered then local na=mJ.planet.atmosphereRadius/mJ.atmoSize;local nb=dj(mI)*na;local nc=iz(nb,1)local n2=j2(math.max(string.len(nc)*7,string.len(mJ.planet.name)*7))local n3=j3(12)local mg=dh(mJ.x+(mm-mJ.x)/2,m4+n2/2,mo-n2/2)local n1=dh(mJ.y+(mn-mJ.y)/2,m5+n3*2,mp-5)jO[#jO+1]=dg("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mJ.x,mJ.y,mm,mn)jO[#jO+1]=dg([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n1,"white",nc)if not mJ.visible then jO[#jO+1]=dg([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],mg,n1-n3,"white",mJ.planet.name)end end;if cH>1 then local gS=cG;local mL=gS:normalize()local mO=gS:project_on_plane(cD):len()local mM=gS:cross(cD):normalize()local mN=math.acos(mM:dot(cE))if mN~=mN then mN=0 end;if mM:cross(cE):dot(cD)<0 then mN=-mN end;local mP=math.sin(mN)*math.asin(mO/gS:len())*constants.rad2deg;local mQ=math.cos(mN)*math.asin(mO/gS:len())*constants.rad2deg;if mL:dot(cD)<0 then mQ=90*math.cos(mN)+90*math.cos(mN)-mQ;mP=90*math.sin(mN)+90*math.sin(mN)-mP end;local hr=mm+mP/mE*mi;local hs=mn+mQ/mE*mi;local kK=14;local kL=kK/2;local kO=[[<circle
                                    cx="]]..hr..[["
                                    cy="]]..hs..[["
                                    r="]]..kL/kK..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hr..[["
                                    cy="]]..hs..[["
                                    r="]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hr-kK..[[,]]..hs..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hr+kL..[[,]]..hs..[[ h ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hr..[[,]]..hs-kK..[[ v ]]..kL..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jO[#jO+1]=kO end;jO[#jO+1]=dg("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm,mn-10,mm,mn+10)jO[#jO+1]=dg("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",mm-10,mn,mm+10,mn)jO[#jO+1]='</g>'else return jO end end;local function nd(ne,nf)local ng;local nh=(nf-ne):normalize()local fs=(cK-ne):dot(nh)/nh:dot(nh)if fs<=0. then return(cK-ne):len()elseif fs>=(nf-ne):len()then return(cK-nf):len()end;local ni=ne+fs*nh;ng=(ni-cK):len()return ng end;local function nj()local ng;local nk=nil;local nl=nil;local nm=nil;for dH,nn in pairs(e[0])do if nn.hasAtmosphere then local c5=nd(kq.center,nn.center)if nk==nil or c5<nk then nl=nn;nk=c5;nm=kq end;if c2 and c2.hasAtmosphere and c2.name~=kq.name then local eL=nd(c2.center,nn.center)if eL<nk then nl=nn;nk=eL;nm=c2 end end end end;local no=j2(1770)local np=j3(330)if nk then local nq="txttick "local nr=500000;if nk<nl.radius+nr or nk<nm.radius+nr then if cR then nq="txttick red "else nq="txttick orange "end end;ng=iz(nk,2)iN=gK(no,np,"Pipe ("..nm.name.."--"..nl.name.."): "..ng,nq.."pbright txtmid")end end;local function ns(hr,hs,nt,nu,kX)local nv={x=hr,y=hs,width=nt,height=nu,label=kX}iH[kX]=nv;return nv end;local function nw(nx,ny,nt,nu,hr,hs,nz,nA,nB,nC,jI)local nv={enableName=nx,disableName=ny,width=nt,height=nu,x=hr,y=hs,toggleVar=nz,toggleFunction=nA,drawCondition=nB,hovered=false,class=jI}if nC then table.insert(iG,nv)else table.insert(iF,nv)end;return nv end;local function nD(nE)if not iL then nF=false;nG=false;nH=false;w=true;return elseif nE=="handling"then nF=not nF;nG=false;nH=false elseif nE=="hud"then nG=not nG;nF=false;nH=false elseif nE=="physics"then nH=not nH;nF=false;nG=false end;if nH or nG or nF then iM=iy(nE)w=false else iM="none"w=true end end;local function nI()iL=not iL;if iL then iE=iG;bY="Hold SHIFT to see Settings"d2=w else iE=iF;bY="Hold SHIFT to see Control Buttons"nD()w=d2 end end;local function nJ()local function nK(dt,dH)dt.set(not dt.get())if dt.get()then bY=dH.." set to true"else bY=dH.." set to false"end;if dH=="showHud"then d2=dt.get()elseif dH=="BrakeToggleDefault"then aX=j end end;local nL=50;local nM=340;local hr=500;local hs=cg/2-400;local nN=0;for dH,dt in pairs(iy("boolean"))do if type(dt.get())=="boolean"then nw(dH,dH,nM,nL,hr,hs,function()return dt.get()end,function()nK(dt,dH)end,function()return true end,true)hs=hs+nL+20;if nN==9 then hr=hr+nM+20;hs=cg/2-400;nN=0 else nN=nN+1 end end end;nw("Control View","Control View",nM,nL,10,cg/2-500,function()return true end,nI,function()return true end,true)nw("View Handling Settings",'Hide Handling Settings',nM,nL,10,cg/2-(500-nL),function()return nF end,function()nD("handling")end,function()return true end,true)nw("View Hud Settings",'Hide Hud Settings',nM,nL,10,cg/2-(500-nL*2),function()return nG end,function()nD("hud")end,function()return true end,true)nw("View Physics Settings",'Hide Physics Settings',nM,nL,10,cg/2-(500-nL*3),function()return nH end,function()nD("physics")end,function()return true end,true)end;local function nO()local function gt()local fT=cK;local gu=kq.name..". "..#bn;if cq then gu=cq.GetClosestName(gu)end;return co.AddNewLocation(gu,fT,false,true)end;local function nP()b2=not b2 end;local function nQ(nR)if nR==1 then b0=not b0;a_=false else a_=not a_;b0=false end;b1=false;b3=false;bW=false;b4=false;br=nil;b6=false;b5=false end;local function nS(nT,nU)co.UpdatePosition(nil,nT,nU)end;local function go()co.ClearCurrentPosition()end;local function nV(gs)local lX=cp.routeWP(true)if lX and#lX>0 then return"Engage Route: "..lX[1]end;return"Engage Autopilot: "..lV(gs)end;local function nW(gs)local lX=cp.routeWP(true)if lX and#lX>0 then return"Next Route Point: "..lX[1]end;return"Disable Autopilot: "..lV(gs)end;local function nX()if iu()==1 then bW=not bW;if bW then b1=false;a_=false;b0=false;b3=false;b6=false;b4=false;b5=false;nY=bk;bk=false;d.control.retractLandingGears()iv:setTargetGroundAltitude(X)fQ("folOn","F")else fQ("folOff","F")aZ="Follow Off"cv=p;bk=nY;if bk then d.control.deployLandingGears()iv:setTargetGroundAltitude(Y)end end else bY="Follow Mode only works with Remote controller"bW=false end end;local nL=50;local nM=260;local nZ=j2(30)local n_=ay+ax*2+2;local o0=az+1;nw("+","+",nZ,nZ,n_,o0+nZ+1,function()return false end,function()d1=d1/8 end,function()return bF=="SCOPE"end,nil,"ZoomButton")nw("-","-",nZ,nZ,n_,o0,function()return false end,function()d1=math.min(d1*8,90)end,function()return bF=="SCOPE"end,nil,"ZoomButton")nw("0","0",nZ,nZ,n_,o0+nZ*2+2,function()return false end,function()d1=90 end,function()return bF=="SCOPE"and d1~=90 end,nil,"ZoomButton")local o1=nw("Enable Brake Toggle","Disable Brake Toggle",nM,nL,cf/2-nM/2,cg/2+350,function()return aX end,function()aX=not aX;if aX then bY="Brakes in Toggle Mode"else bY="Brakes in Default Mode"end end)nw("Align Prograde","Disable Prograde",nM,nL,cf/2-nM/2-50-o1.width,cg/2-nL+380,function()return b0 end,function()nQ(1)end)nw("Align Retrograde","Disable Retrograde",nM,nL,cf/2-nM/2+o1.width+50,cg/2-nL+380,function()return a_ end,nQ,function()return cb==0 end)o2=nw(nV,nW,600,60,cf/2-600/2,cg/2-60/2-330,function()return b1 or bo or c7 or bx end,function()end)local K;local function o3(o4)local gs=cY+o4;if gs>#cQ then gs=gs-#cQ-1 end;if gs<0 then gs=#cQ+gs end;return gs end;o5={}for K=0,10 do local o6=nw(function(ez)local gs=o3(ez.apExtraIndex)if b1 or bo or c7 or bx then return"Redirect: "..lV(gs)end;return nV(gs)end,function(ez)local gs=o3(ez.apExtraIndex)return nW(gs)end,600,60,cf/2-600/2,cg/2-60/2-330+60*K,function(ez)local gs=o3(ez.apExtraIndex)return gs==bj and(b1 or bo or c7 or bx)end,function(ez)local gs=o3(ez.apExtraIndex)local o7=bj==gs;bj=gs;co.UpdateAutopilotTarget()cp.ToggleAutopilot()if not o7 and not(b1 or bo or c7 or bx)then cp.ToggleAutopilot()end end,function()return cX and(#cp.routeWP(true)==0 or K==0)end)o6.apExtraIndex=K;o5[K]=o6 end;nw("Save Position","Save Position",200,o2.height,o2.x+o2.width+30,o2.y,function()return false end,gt,function()return bj==0 or g1==nil end)nw("Update Position","Update Position",200,o2.height,o2.x+o2.width+30,o2.y,function()return false end,function()nS(nil)end,function()return bj>0 and g1~=nil end)nw("Save Heading","Clear Heading",200,o2.height,o2.x+o2.width+30,o2.y+o2.height+20,function()return g1.heading~=nil end,function()if g1.heading~=nil then nS(false)else nS(true)end end,function()return bj>0 and g1~=nil end)nw("Save AGG Alt","Clear AGG Alt",200,o2.height,o2.x+o2.width+30,o2.y+o2.height*2+40,function()return g1.agg~=nil end,function()if g1.agg~=nil then nS(nil,false)else nS(nil,true)end end,function()return bj>0 and g1~=nil and antigrav end)nw("Clear Position","Clear Position",200,o2.height,o2.x-200-30,o2.y,function()return true end,go,function()return bj>0 and g1~=nil end)nw("Save Route","Save Route",200,o2.height,o2.x-200-30,o2.y+o2.height*2+40,function()return false end,function()cp.routeWP(false,false,2)end,function()return#cp.routeWP(true)>0 end)nw("Load Route","Clear Route",200,o2.height,o2.x-200-30,o2.y+o2.height+20,function()return#cp.routeWP(true)>0 end,function()if#cp.routeWP(true)>0 then cp.routeWP(false,true)elseif b1 or bo then bY="Disable Autopilot before loading route"return else cp.routeWP(false,false,1)end end,function()return true end)nL=60;nM=300;local hr=0;local hs=cg/2-150;nw("Enable Check Damage","Disable Check Damage",nM,nL,hr,hs-nL-20,function()return s end,function()s=not s end)nw("View Settings","View Settings",nM,nL,hr,hs,function()return true end,nI)hs=hs+nL+20;nw("Enable Turn and Burn","Disable Turn and Burn",nM,nL,hr,hs,function()return b2 end,nP)hr=10;hs=cg/2-300;nw("Horizontal Takeoff Mode","Vertical Takeoff Mode",nM,nL,cf/2-nM/2,hs+20,function()return aY end,function()aY=not aY;if aY then bY="Vertical Takeoff Mode"else bY="Horizontal Takeoff Mode"end end,function()return cL end)hs=hs+nL+20;nw("Engage Orbiting","Cancel Orbiting",nM,nL,hr+nM+20,hs,function()return bx end,cp.ToggleIntoOrbit,function()return cb==0 and cU end)hs=cg/2-150;nw("Glide Re-Entry","Cancel Glide Re-Entry",nM,nL,hr+nM+20,hs,function()return b6 end,function()c6=1;nQ(1)end,function()return kq.hasAtmosphere and not ca end)hs=hs+nL+20;nw("Parachute Re-Entry","Cancel Parachute Re-Entry",nM,nL,hr+nM+20,hs,function()return b6 end,function()c6=2;nQ(1)end,function()return kq.hasAtmosphere and not ca end)hs=hs+nL+20;nw("Engage Follow Mode","Disable Follow Mode",nM,nL,hr,hs,function()return bW end,nX,function()return iu()==1 end)nw("Enable Repair Arrows","Disable Repair Arrows",nM,nL,hr+nM+20,hs,function()return j0 end,function()j0=not j0;if j0 then bY="Repair Arrows Enabled"else bY="Repair Arrows Diabled"end end,function()return iu()==1 end)hs=hs+nL+20;if not q then nw("Enable AGG","Disable AGG",nM,nL,hr,hs,function()return cM end,cp.ToggleAntigrav,function()return antigrav~=nil end)end;nw(function()return dg("Switch IPH Mode - Current: %s",by)end,function()return dg("IPH Mode: %s",by)end,nM*2,nL,hr,hs,function()return false end,function()if by=="All"then by="Custom Only"elseif by=="Custom Only"then by="No Moons"else by="All"end;bY="IPH Mode: "..by end)hs=hs+nL+20;nw(function()return dg("Toggle Control Scheme - Current: %s",g)end,function()return dg("Control Scheme: %s",g)end,nM*2,nL,hr,hs,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;bY="New Control Scheme: "..g end)local o8=j3(20)local o6=ns(0,0,j2(70),o8,"HELP")o6=ns(o6.x+o6.width,o6.y,j2(80),o8,"INFO")o6=ns(o6.x+o6.width,o6.y,j2(70),o8,"ORBIT")o6=ns(o6.x+o6.width,o6.y,j2(70),o8,"SCOPE")ns(o6.x+o6.width,o6.y,j2(70),o8,"HIDE")end;local o9={}local oa=nil;function o9.HUDPrologue(jO)if not cR then iS=af;iT=ag;iU=ah else iS=ac;iT=ad;iU=ae end;iV=[[rgb(]]..bI(iS+0.6)..","..bI(iT+0.6)..","..bI(iU+0.6)..[[)]]iW=[[rgb(]]..bI(iS*0.8+0.5)..","..bI(iT*0.8+0.5)..","..bI(iU*0.8+0.5)..[[)]]local ob=iV;local oc=iW;local od=[[rgb(]]..bI(iS*0.4+0.5)..","..bI(iT*0.4+0.5)..","..bI(iU*0.4+0.5)..[[)]]local oe=iV;local of=iW;local og=od;if j4()and not m then ob=[[rgb(]]..bI(iS*0.5+0.5)..","..bI(iT*0.5+0.5)..","..bI(iU*0.5+0.5)..[[)]]oc=[[rgb(]]..bI(iS*0.3+0.5)..","..bI(iT*0.3+0.5)..","..bI(iU*0.2+0.5)..[[)]]od=[[rgb(]]..bI(iS*0.2+0.5)..","..bI(iT*0.2+0.5)..","..bI(iU*0.2+0.5)..[[)]]end;local lK=j2;local lL=j3;jO[#jO+1]=dg([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],ob,ob,ob,oe,oe,oc,oc,of,of,oc,ob,od,of,ob,ob,od,od,og,od,cf,cg,oc,oc,oc,oc,oc,oe,oc,of,og,of,of,og)if not oa then oa=dg([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lK(630),lL(0),lK(675),lL(45),lK(960),lL(55),lK(1245),lL(45),lK(1290),lL(0),lK(1000),lL(105),lK(1040),lL(59),lK(1250),lL(51),lK(1300),lL(0),lK(1920),lL(0),lK(1920),lL(20),lK(1400),lL(20),lK(1300),lL(105),lK(920),lL(105),lK(880),lL(59),lK(670),lL(51),lK(620),lL(0),lK(0),lL(0),lK(0),lL(20),lK(520),lL(20),lK(620),lL(105),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112),lK(890),lL(59),lK(960),lL(62),lK(1030),lL(59),lK(985),lL(112),lK(1150),lL(112),lK(1100),lL(152),lK(820),lL(152),lK(780),lL(112),lK(935),lL(112))end;if w and I then jO[#jO+1]=oa end;return jO end;function o9.DrawVerticalSpeed(jO,d_)jN(jO,d_)end;function o9.UpdateHud(jO)local kD=cO;local oh=cP;local jV=oh;local ka=kD;local kV=bI(c.getThrottle())local k_=cH*3.6;local kW=c.getAxisCommandValue(0)local oi=j2(1770)local oj=j3(310)if t and cN then kW=bM;kV=bM*100 end;local j6=j5()local jW="ROLL"if kV==nil then kV=0 end;if not cU then if cH>5 then kD=kC(cF)oh=kE(cF)else kD=0;oh=0 end;jW="YAW"end;if cS>50000 and not ca then local ok;ok=iz(cS)jO[#jO+1]=gK(oi,oj,"PvP Boundary: "..ok,"pbright txtbig txtmid")end;jO[#jO+1]=iZ;jO[#jO+1]=i5;if iN~=""then jO[#jO+1]=iN end;if j7~=""then jO[#jO+1]=j7 end;if j8~=""then jO[#jO+1]=j8 end;jN(jO,cc)if iu()==0 or l then if not j4()or m then if cU then jU(jO,ai,aj,jV,jW,cU)k9(jO,ka,jV,ai,aj,cU,bI(kE(cF)),cH)else jU(jO,ai,aj,oh,jW,cU)k9(jO,kD,oh,ai,aj,cU,bI(oh),cH)end;kg(jO,cc,cU)kF(jO,cF,cH,ai,aj)end end;kU(jO,j6,kV,kW)kZ(jO,k_)l2(jO)m3(jO)if not iL and bX then lW(jO)end;return jO end;function o9.HUDEpilogue(jO)jO[#jO+1]="</svg>"return jO end;function o9.ExtraData(jO)local ol=j2(1240)local om=j3(55)local on=om+10;local oo;local lK=j2;local lL=j3;local op=0;local j6=j5()if aY then j6=j6 .."-VERTICAL"end;if E and not b5 and not b4 and cH>20 then j6=j6 .."-COLLISION ON"end;if bA~="Off"then j6="("..bA..")-"..j6 end;if b2 then j6="TB-"..j6 end;if not bz then j6=j6 .."-DeCoupled"end;local oq=lL(99)local os=lL(80)local ot=lL(85)local ou=lL(31)local ov=0;local ow=0;local ox=cd>1000000 and fR(cd/1000000,2).."kT"or fR(cd/1000,2).."T"if ca then op=bs else op=bq end;local oy,oz=cl.computeDistanceAndTime(cH,0,cd,0,0,op)if oy<0 then oy=0 end;op=fR(op/(cd*iD),2).."g"local oA=d:maxForceForward()oo=b.getGravityIntensity()if oo>0.1 then ow=cd*oo;ow=fR(ow/(cd*iD),2).."g"ov=0.5*oA/oo;ov=ov>1000000 and fR(ov/1000000,2).."kT"or fR(ov/1000,2).."T"end;oA=fR(oA/(cd*iD),2).."g"local oB=vec3(bK.getWorldAcceleration()):len()/9.80665;oo=b.getGravityIntensity()jO[#jO+1]=[[<g class="dim txt txtend size14">]]if iu()==1 and not l then ol=j2(1120)om=j3(55)on=om+10 elseif ca and I then local oC=j2(770)jO[#jO+1]=gK(lK(895),oq,"ATMO","")jO[#jO+1]=dg([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lK(895),ot,lK(-80))jO[#jO+1]=gK(lK(815),os,dg("%.1f%%",cb*100),"txtstart size20")end;if I then jO[#jO+1]=gK(lK(1025),oq,"GRAVITY","txtstart")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1025),ot,lK(80))jO[#jO+1]=gK(lK(1105),os,dg("%.2fg",oo/9.80665),"size20")jO[#jO+1]=gK(lK(1125),oq,"ACCEL","txtstart")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1125),ot,lK(80))jO[#jO+1]=gK(lK(1205),os,dg("%.2fg",oB),"size20")jO[#jO+1]=gK(lK(695),oq,"BRK TIME","")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(695),ot,lK(-80))jO[#jO+1]=gK(lK(615),os,dg("%s",iA(oz)),"txtstart size20")jO[#jO+1]=gK(lK(635),lL(45),"TRIP","")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(635),lL(31),lK(-90))if lE then jO[#jO+1]=gK(lK(545),lL(26),dg("%s",iA(lE)),"txtstart size20")end;jO[#jO+1]=gK(lK(795),oq,"BRK DIST","")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(795),ot,lK(-80))jO[#jO+1]=gK(lK(715),os,dg("%s",iz(oy)),"txtstart size20")jO[#jO+1]=gK(lK(1285),lL(45),"MASS","txtstart")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1285),lL(31),lK(90))jO[#jO+1]=gK(lK(1375),lL(26),dg("%s",ox),"size20")jO[#jO+1]=gK(lK(1220),oq,"THRUST","txtstart")jO[#jO+1]=dg([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lK(1220),ot,lK(80))jO[#jO+1]=gK(lK(1300),os,dg("%s",oA),"size20")jO[#jO+1]=gK(j2(960),j3(175),j6,"pbright txtbig txtmid size20")end;jO[#jO+1]="</g>"end;local oD=1-(a4*0.05+a5*0.05)function o9.FuelUsed(oE)local oF;if oE=="atmofueltank"then oF=dg("Atmo Fuel Used: %.1f L",jp[oE]/(4*oD))elseif oE=="spacefueltank"then oF=dg("Space Fuel Used: %.1f L",jp[oE]/(6*oD))else oF=dg("Rocket Fuel Used: %.1f L",jp[oE]/(0.8*oD))end;return oF end;function o9.DrawOdometer(jO,iX,bl,iY)if bF~="INFO"then return jO end;local oo;local ov=0;local ow=0;local op=0;local ox=cd>1000000 and fR(cd/1000000,2).." kTons"or fR(cd/1000,2).." Tons"if ca then op=bs else op=bq end;local oy,oz=cl.computeDistanceAndTime(cH,0,cd,0,0,op)op=fR(op/(cd*iD),2).." g"local oA=d:maxForceForward()oo=b.getGravityIntensity()if oo>0.1 then ow=cd*oo;ow=fR(ow/(cd*iD),2).." g"ov=0.5*oA/oo;ov=ov>1000000 and fR(ov/1000000,2).." kTons"or fR(ov/1000,2).." Tons"end;oA=fR(oA/(cd*iD),2).." g"if iu()==0 or l then local oG=j2(ay+10)local oH=j3(az+20)local oI=j2(ay+10+ax/1.25)local nu=25;jO[#jO+1]="<g class='txtstart size14 bright'>"jO[#jO+1]=gK(oG,oH,dg("BrkTime: %s",iA(oz)))jO[#jO+1]=gK(oI,oH,dg("Trip: %.2f km",iX))jO[#jO+1]=gK(oG,oH+nu,dg("Lifetime: %.2f kSU",bl/200000))jO[#jO+1]=gK(oI,oH+nu,dg("BrkDist: %s",iz(oy)))jO[#jO+1]=gK(oG,oH+nu*2,"Trip Time: "..iA(iY))jO[#jO+1]=gK(oI,oH+nu*2,"Total Time: "..iA(bm))jO[#jO+1]=gK(oG,oH+nu*3,dg("Mass: %s",ox))jO[#jO+1]=gK(oI,oH+nu*3,dg("Max Brake: %s",op))jO[#jO+1]=gK(oG,oH+nu*4,dg("Max Thrust: %s",oA))if oo>0.1 then jO[#jO+1]=gK(oI,oH+nu*4,dg("Max Thrust Mass: %s",ov))jO[#jO+1]=gK(oG,oH+nu*5,dg("Req Thrust: %s",ow))else jO[#jO+1]=gK(oI,oH+nu*4,"Max Mass: n/a")jO[#jO+1]=gK(oG,oH+nu*5,"Req Thrust: n/a")end;jO[#jO+1]=gK(oI,oH+nu*5,cn.FuelUsed("atmofueltank"))jO[#jO+1]=gK(oG,oH+nu*6,cn.FuelUsed("spacefueltank"))jO[#jO+1]=gK(oI,oH+nu*6,cn.FuelUsed("rocketfueltank"))jO[#jO+1]=gK(oG,oH+nu*7,dg("Set Max Speed: %s",bI(a8*3.6+0.5)))jO[#jO+1]=gK(oI,oH+nu*7,dg("Actual Max Speed: %s",bI(db*3.6+0.5)))end;jO[#jO+1]="</g></g>"return jO end;function o9.DrawWarnings(jO)return l2(jO)end;function o9.DisplayOrbitScreen(jO)return m3(jO)end;function o9.DisplayMessage(jO,lp)if lp~="empty"then local hs=310;for ly in string.gmatch(lp,"([^\n]+)")do hs=hs+35;jO[#jO+1]=gK("50%",hs,ly,"msg")end end;if bZ~=0 then c.setTimer("msgTick",bZ)bZ=0 end end;function o9.DrawDeadZone(jO)jO[#jO+1]=dg([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],aw)end;function o9.UpdatePipe()if ca then iN=""return end;nj()end;function o9.DrawSettings(jO)local hr=j2(640)local hs=j3(200)jO[#jO+1]=[[<g class="pbright txtvspd txtstart">]]local hN=0;for dH,dt in pairs(iM)do hN=hN+1;jO[#jO+1]=gK(hr,hs,dH..": "..dt.get())hs=hs+20;if hN%12==0 then hr=hr+j2(350)hs=j3(200)end end;jO[#jO+1]=gK(j2(640),j3(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jO[#jO+1]="</g>"return jO end;local i3=j3(15)local i2=j2(1370)local de,oJ;function o9.DrawRadarInfo()i5=cq.GetRadarHud(i2,i3,au,av)end;function o9.DrawTanks()if aq~=0 and ar~=0 then j7=gK(aq,ar,"","txtstart pdim txtfuel")jq=ar;jr(aq,"Atmospheric ","ATMO",ch,jn,jo)jr(aq,"Space Fuel T","SPACE",ci,jl,jm)jr(aq,"Rocket Fuel ","ROCKET",cj,jj,jk)end end;function o9.DrawShield()local ic=shield.isActive()==1 and"Shield Active"or"Shield Disabled"local oK=bK.getPvPTimer()local oL=shield.getResistances()local oM="A: "..10+oL[1]*100 .."% / E: "..10+oL[2]*100 .."% / K:"..10+oL[3]*100 .."% / T: "..10+oL[4]*100 .."%"local hr,hs=as-60,at+30;local jG=bI(dc*2.55)local jH=dg("rgb(%d,%d,%d)",255-jG,jG,0)local jI=""j8=gK(hr,hs,"","txtmid pdim txtfuel")if dc<10 and ic~="Shield Disabled"then jI="red "end;oK=oK>0 and"   PvPTime: "..iA(oK)or""j8=j8 ..dg([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hr,hs,jH,dc*2,hr,hs,hr+2,hs+10,dc,oK)j8=j8 ..gK(hr,hs-5,ic,jI.."txtstart pbright txtbig")j8=j8 ..gK(hr,hs+30,oM,jI.."txtstart pbright txtsmall")end;function o9.hudtick()if not kq then return end;local function oN(jO)local jK=bI(dh(d9/(cf/4)*255,0,255))jO[#jO+1]=dg("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c3,c4,bI(iS+0.5)+jK,bI(iT+0.5)-jK,bI(iU+0.5)-jK)end;local function oO()for dM,dt in pairs(iE)do if dt.hovered then if not dt.drawCondition or dt.drawCondition(dt)then dt.toggleFunction(dt)end;dt.hovered=false end end;for dM,dt in pairs(iH)do if dt.hovered then bF=dt.label;dt.hovered=false end end end;local function oP()local function oQ(oR,oS,hr,hs,nt,nu)if oR>=hr and oR<=hr+nt and oS>=hs and oS<=hs+nu then return true else return false end end;local hr=c3+cf/2;local hs=c4+cg/2;for dM,dt in pairs(iE)do dt.hovered=oQ(hr,hs,dt.x,dt.y,dt.width,dt.height)end;for dM,dt in pairs(iH)do dt.hovered=oQ(hr,hs,dt.x,dt.y,dt.width,dt.height)end;if cX then local n8=false;for dM,ez in ipairs(o5)do if ez.hovered then n8=true;break end end;if o2.hovered then n8=true end;cX=n8 else cX=o2.hovered;if not cX then cY=bj end end end;local function oT(jO)if not bF or bF==""then bF="HELP"end;if w then for dH,dt in pairs(iH)do local jI="dim brightstroke"local oU=0.2;if bF==dH then jI="pbright dimstroke"oU=0.6 end;local oV=""if dt.hovered then oU=0.8;oV=";stroke:white"end;jO[#jO+1]=dg([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dt.width,dt.height,dt.x,dt.y,jI,oU,oV)jO[#jO+1]=gK(dt.x+dt.width/2,dt.y+dt.height/2+5,dt.label,"txt txtmid pdim")end end end;local function oW(jO)local function oX(jO,oY,hover,hr,hs,fe,oZ,o_,p0,p1,p2,o6)if type(p1)=="function"then p1=p1(o6)end;if type(p2)=="function"then p2=p2(o6)end;jO[#jO+1]=dg("<rect x='%f' y='%f' width='%f' height='%f' fill='",hr,hs,fe,oZ)if oY then jO[#jO+1]=dg("%s'",o_)else jO[#jO+1]=p0 end;if hover then jO[#jO+1]=dg(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jO[#jO+1]=dg(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",fR(ac*0.5,0),fR(ad*0.5,0),fR(ae*0.5,0))end;jO[#jO+1]=" rx='5'></rect>"jO[#jO+1]=dg("<text x='%f' y='%f' font-size='24' fill='",hr+fe/2,hs+oZ/2+5)if oY then jO[#jO+1]="black"else jO[#jO+1]="white"end;jO[#jO+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oY then jO[#jO+1]=dg("%s</text>",p1)else jO[#jO+1]=dg("%s</text>",p2)end end;local p3=dg("rgb(%d,%d,%d)'",fR(ac*0.1,0),fR(ad*0.1,0),fR(ae*0.1,0))local p4=dg("rgb(%d,%d,%d)",fR(ac*0.8,0),fR(ad*0.8,0),fR(ae*0.8,0))local p5=oX;for dM,dt in pairs(iE)do local ny=dt.disableName;local nx=dt.enableName;if type(ny)=="function"then ny=ny(dt)end;if type(nx)=="function"then nx=nx(dt)end;if not dt.drawCondition or dt.drawCondition(dt)then p5(jO,dt.toggleVar(dt),dt.hovered,dt.x,dt.y,dt.width,dt.height,p4,p3,ny,nx,dt)end end end;local p6=fR(cf/2,0)local p7=fR(cg/2,0)local jO={}if p8 then jO[#jO+1]=p8 end;cn.HUDPrologue(jO)if w then cn.UpdateHud(jO)else if A then cn.DrawVerticalSpeed(jO,cc)end;cn.DrawWarnings(jO)end;if iL and iM~="none"then cn.DrawSettings(jO)end;if cq then cn.DrawRadarInfo()end;cn.HUDEpilogue(jO)jO[#jO+1]=dg([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cf,cg)if bY~="empty"then cn.DisplayMessage(jO,bY)end;if iu()==0 and g=="virtual joystick"then if v then cn.DrawDeadZone(jO)end end;oT(jO)if iw()==0 then if iu()==1 and bX then if not p9 then oP()oW(jO)end;if not ct and not cu then local pa=table.concat(jO,"")jO={}jO[#jO+1]=dg("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cf,cg)jO[#jO+1]=pa;jO[#jO+1]="</body>"ct=true;jO[#jO+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif cu then local pa=table.concat(jO,"")jO={}jO[#jO+1]=dg("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cf,cg)jO[#jO+1]=pa;jO[#jO+1]="</body>"end;if not ct then jO[#jO+1]=dg([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p6,p7,c3,c4)end else oO()end else if not bX and iu()==0 then oO()if d9>aw then if v then oN(jO)end end elseif bX and(not p9 or not i)then oP()oW(jO)end;jO[#jO+1]=dg([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],p6,p7,c3,c4)end;jO[#jO+1]=[[</svg></body>]]pb=table.concat(jO,"")end;function o9.TenthTick()local function pc()local pd=a.createData;local pe=a.createWidget;pf=a.createWidgetPanel("Interplanetary Helper")pg=pe(pf,"value")ph=pd('{"label": "Target Planet", "value": "N/A", "unit":""}')fP(ph,pg)pi=pe(pf,"value")pj=pd('{"label": "distance", "value": "N/A", "unit":""}')fP(pj,pi)gi=pe(pf,"value")gh=pd('{"label": "Travel Time", "value": "N/A", "unit":""}')fP(gh,gi)gg=pe(pf,"value")gf=pd('{"label": "Maximum Mass", "value": "N/A", "unit":""}')fP(gf,gg)gk=pe(pf,"value")gj=pd('{"label": "Target Altitude", "value": "N/A", "unit":""}')fP(gj,gk)gc=pe(pf,"value")gb=pd('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')ga=pe(pf,"value")g9=pd('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')g8=pe(pf,"value")g7=pd('{"label": "Max Brake distance", "value": "N/A", "unit":""}')g6=pe(pf,"value")g5=pd('{"label": "Max Brake Time", "value": "N/A", "unit":""}')ge=pe(pf,"value")gd=pd('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ca then fP(gb,gc)fP(g9,ga)fP(g7,g8)fP(g5,g6)fP(gd,ge)end end;local function pk()gJ(pf)pf=nil end;cn.DrawTanks()if shield then cn.DrawShield()end;if bh~="None"then if pf==nil then pc()end;if bh~=nil then local mK;local pl=g1~=nil;local pm=0.5*bs/c2:getGravity(c2.center+vec3(0,0,1)*c2.radius):len()pm=pm>1000000 and fR(pm/1000000,2).." kTons"or fR(pm/1000,2).." Tons"fO(ph,'{"label": "Target", "value": "'..bh..'", "unit":""}')if pl and not b1 then mK=(cK-g1.position):len()else mK=(bi-cK):len()end;if not b2 then c0,c1=cp.GetAutopilotBrakeDistanceAndTime(cH)iP,iQ=cp.GetAutopilotBrakeDistanceAndTime(a8)else c0,c1=cp.GetAutopilotTBBrakeDistanceAndTime(cH)iP,iQ=cp.GetAutopilotTBBrakeDistanceAndTime(a8)end;local lp=iz(mK)fO(pj,'{"label": "distance", "value": "'..lp..'"}')fO(gh,'{"label": "Travel Time", "value": "'..iA(lE)..'", "unit":""}')lp=iz(c0)fO(gb,'{"label": "Cur Brake distance", "value": "'..lp..'"}')fO(g9,'{"label": "Cur Brake Time", "value": "'..iA(c1)..'", "unit":""}')lp=iz(iP)fO(g7,'{"label": "Max Brake distance", "value": "'..lp..'"}')fO(g5,'{"label": "Max Brake Time", "value": "'..iA(iQ)..'", "unit":""}')fO(gf,'{"label": "Max Brake Mass", "value": "'..dg("%s",pm)..'", "unit":""}')lp=iz(gl)fO(gj,'{"label": "Target Orbit", "value": "'..lp..'"}')if ca and not pn then a.removeDataFromWidget(g5,g6)a.removeDataFromWidget(g7,g8)a.removeDataFromWidget(g9,ga)a.removeDataFromWidget(gb,gc)a.removeDataFromWidget(gd,ge)pn=true;if not cN and t and(b3 or b6 or c8)then cp.cmdThrottle(1)aZ=false;bQ=false end end;if not ca and pn then if fO(g5,g6)==1 then fP(g5,g6)end;if fO(g7,g8)==1 then fP(g7,g8)end;if fO(g9,ga)==1 then fP(g9,ga)end;if fO(gb,gc)==1 then fP(gb,gc)end;if fO(gd,ge)==1 then fP(gd,ge)end;pn=false end end else pk()end;if warpdrive~=nil then local po=is(warpdrive.getWidgetData())if po.destination~="Unknown"and po.distance>400000 then if not j1 then warpdrive.showWidget()j1=true end elseif j1 then warpdrive.hideWidget()j1=false end end end;function o9.OneSecondTick()local function pp()local jB=bH()local k_=cH;local pq=jB-i_;if k_>1.38889 then k_=k_/1000;local pr=k_*(jB-i_)bl=bl+pr;iX=iX+pr end;iY=iY+pq;bm=bm+pq;i_=jB end;local function ps(jO)local pt=0;local pu=iC;local pv=0;local pw=0;local px=0;local jG=0;local jH=""local py=b.getElementHitPointsById;local pz=b.getElementMaxHitPointsById;local pA={}for dH in pairs(iB)do local pB=0;local pC=0;pC=pz(iB[dH])pB=py(iB[dH])pv=pv+pB;if pB+1<pC then if pB==0 then px=px+1 else pw=pw+1 end;if j0 and#pA==0 then fT=vec3(b.getElementPositionById(iB[dH]))local hr=fT.x;local hs=fT.y;local ht=fT.z;table.insert(pA,b.spawnArrowSticker(hr,hs,ht+1,"down"))table.insert(pA,b.spawnArrowSticker(hr,hs,ht+1,"down"))b.rotateSticker(pA[2],0,0,90)table.insert(pA,b.spawnArrowSticker(hr+1,hs,ht,"north"))table.insert(pA,b.spawnArrowSticker(hr+1,hs,ht,"north"))b.rotateSticker(pA[4],90,90,0)table.insert(pA,b.spawnArrowSticker(hr-1,hs,ht,"south"))table.insert(pA,b.spawnArrowSticker(hr-1,hs,ht,"south"))b.rotateSticker(pA[6],90,-90,0)table.insert(pA,b.spawnArrowSticker(hr,hs-1,ht,"east"))table.insert(pA,b.spawnArrowSticker(hr,hs-1,ht,"east"))b.rotateSticker(pA[8],90,0,90)table.insert(pA,b.spawnArrowSticker(hr,hs+1,ht,"west"))table.insert(pA,b.spawnArrowSticker(hr,hs+1,ht,"west"))b.rotateSticker(pA[10],-90,0,90)table.insert(pA,iB[dH])end elseif j0 and#pA>0 and pA[11]==iB[dH]then for jA in pairs(pA)do b.deleteSticker(pA[jA])end;pA={}end end;pt=fR(pv/pu*100,2)if px>0 or pw>0 then jO[#jO+1]=gK(0,0,"","pbright txt")jG=bI(pt*2.55)jH=dg("rgb(%d,%d,%d)",255-jG,jG,0)jO[#jO+1]=gK("50%",1035,"Elemental Integrity: "..pt.."%","txtbig txtmid","fill:"..jH)if px>0 then jO[#jO+1]=gK("50%",1055,"Disabled Modules: "..px.." Damaged Modules: "..pw,"txtbig txtmid","fill:"..jH)elseif pw>0 then jO[#jO+1]=gK("50%",1055,"Damaged Modules: "..pw,"txtbig txtmid","fill:"..jH)end end end;local function pD()if ir then if iR==nil and(d4~=nil or bk)then _autoconf.displayCategoryPanel(ir,weapon_size,"Weapons","weapon",true)iR=_autoconf.panels[_autoconf.panels_size]elseif iR~=nil and d4==nil and not bk then gJ(iR)iR=nil end end end;cZ=bK.getPlayersOnBoard()c_=bK.getDockedConstructs()local jO={}pp()if s then ps(jO)end;pD()cn.UpdatePipe()cn.ExtraData(jO)iZ=table.concat(jO,"")end;function o9.AnimateTick()cu=true;ct=false;c3=0;c4=0;c.stopTimer("animateTick")end;function o9.MsgTick()local jO={}cn.DisplayMessage(jO,"empty")bY="empty"c.stopTimer("msgTick")bZ=3 end;function o9.ButtonSetup()nJ()nO()iE=iF end;if pE then for dH,dt in pairs(pE)do o9[dH]=dt end end;return o9 end;local function pF(d,b,c,e,vBooster,hover,pG,antigrav,warpdrive,dbHud_1,eV,bI,bJ,iu,eQ,bH,dh,iv,fO,iw,dj,fR,fQ,ix,dk,iz,iA,pH,is,dg,fP)local a=DUSystem;local bK=DUConstruct;local pI={}local pJ=false;local pK=0;local pL=0;local pM=0;local pN=bH()local pO=0;local pP=0;local pQ=0;local pR=0;local pS=false;local pT=false;local pU=false;local pV=nil;local pW=0;local iO=55;local pX=nil;local pY=false;local pZ=false;local p_=false;local q0=0;local q1=0;local q2=0;local q3=0;local q4=0;local q5={VectorToTarget=false}local q6=vec3(bK.getWorldOrientationUp())local q7=nil;local q8=0;local q9=-1;local qa=-1;local qb=false;local qc=false;local qd=0;local qe=false;local qf=false;local qg=false;local qh=false;local qi=""local qj=false;local qk=false;local ql=""local qm=false;local qn=0;local qo=vec3({13771471,7435803,-128971})local qp=18000000;local qq=500000;local qr,qs=math.huge;local qt;local function qu(qv)qr=vec3(qv):dist(qo)if qr<qp then return true,eV(qr-qp)end;qs=vec3(qv):dist(vec3(kq.center))if qs<qq then qt=true else qt=false end;if eV(qs-qq)<eV(qr-qp)then return qt,eV(qs-qq)else return qt,eV(qr-qp)end end;local function qw(fl)local qx=bd;if not b1 then qx=0 end;local qy=bq;if ca then if bs and bs>0 then qy=bs else return 0,0 end end;return cl.computeDistanceAndTime(fl,qx,cd,0,0,qy-bf*cd)end;local function qz(fl)local qx=bd;if not b1 then qx=0 end;return cl.computeDistanceAndTime(fl,qx,cd,d:maxForceForward(),a0,bq-bf*cd)end;local function qA(qB,qC,qD)qC=qC:project_on_plane(qB)qD=qD:project_on_plane(qB)return eQ(qC:cross(qD):dot(qB),qC:dot(qD))end;local function qE()local function qF()local qG=-1;local qH=-1;if vBooster then qG=vBooster.getDistance()end;if hover then qH=hover.getDistance()end;if qG~=-1 and qH~=-1 then if qG<qH then return qG else return qH end elseif qG~=-1 then return qG elseif qH~=-1 then return qH else return-1 end end;local qI=qF()local qJ=-1;if antigrav and antigrav.isActive()==1 and not q and cH<iO then local qK=eV(cc-antigrav.getBaseAltitude())if qK<50 then return qK end end;if pG then qJ=pG.raycast().distance end;if qI~=-1 and qJ~=-1 then if qI<qJ then return qI else return qJ end elseif qI~=-1 then return qI else return qJ end end;local function qL(kq,eH,qM)local function qN(qO,dT)local eN=vec3(dT)if qO.id==0 then return setmetatable({latitude=eN.x,longitude=eN.y,altitude=eN.z,id=0,systemId=qO.systemId},dV)end;local eO=eN-qO.center;local c5=eO:len()local d_=c5-qO.radius;local dY=0;local dZ=0;if not dk(c5,0)then local eP=eQ(eO.y,eO.x)dZ=eP>=0 and eP or 2*math.pi+eP;dY=math.pi/2-math.acos(eO.z/c5)end;return setmetatable({latitude=math.deg(dY),longitude=math.deg(dZ),altitude=d_,id=qO.id,systemId=qO.systemId},dV)end;local qP=qN(kq,eH)qP="::pos{"..qP.systemId..","..qP.id..","..qP.latitude..","..qP.longitude..","..qP.altitude.."}"if qM then return qP else qg=qP;return true end end;local function qQ(qR,qS,qT)local function qU(qR,eq)qR=vec3(qR)eq=vec3(eq):normalize()local dC=qR*eq;return dC.x+dC.y+dC.z end;local qV=0.001;local qW=1;if not ca or not cw or c9~=-1 or cH<iO then if qT==nil then qT=aQ end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=vec3()-qR;local qY=-qU(qX,bK.getWorldOrientationRight())*qW;local qZ=-qU(qX,bK.getWorldOrientationUp())*qW;if pL==0 then pL=qY/2 end;if pM==0 then pM=qZ/2 end;if eV(qY)<0.1 then q1=q1-qY*2 else q1=q1-(qY+(qY-pL)*qT)end;if eV(qZ)<0.1 then q0=q0+qZ*2 else q0=q0+qZ+(qZ-pM)*qT end;pL=qY;pM=qZ;if eV(qY)<qS and eV(qZ)<qS then return true end;return false elseif cw and c9==-1 then qR=cG;if qT==nil then qT=aQ end;if qS==nil then qS=qV end;qR=vec3(qR):normalize()local qX=cD-qR;local qY=-qU(qX,bK.getWorldOrientationRight())*qW;local qZ=-qU(qX,bK.getWorldOrientationUp())*qW;if pL==0 then pL=qY/2 end;if pM==0 then pM=qZ/2 end;if eV(qY)<0.1 then q1=q1-qY*5 else q1=q1-(qY+(qY-pL)*qT)end;if eV(qZ)<0.1 then q0=q0+qZ*5 else q0=q0+qZ+(qZ-pM)*qT end;pL=qY;pM=qZ;if eV(qY)<qS and eV(qZ)<qS then return true end;return false end end;function pI.clearAll()b9=false;bb=false;bc=false;b1=false;ba=false;be="Aligning"a_=false;b0=false;cT=nil;b3=false;b6=false;b4=false;b5=false;b7=false;bW=false;pZ=false;c6=false;c7=false;p_=false;cv=p;bo=false;b2=false;ce=false;br=nil;bx=false;d7=false;d8=nil end;function pI.GetAutopilotBrakeDistanceAndTime(fl)return qw(fl)end;function pI.GetAutopilotTBBrakeDistanceAndTime(fl)return qz(fl)end;function pI.showWayPoint(kq,eH,qM)return qL(kq,eH,qM)end;function pI.APTick()local q_=a.getMouseWheel()if q_>0 then cp.changeSpd()elseif q_<0 then cp.changeSpd(true)else pY=true end;qd=iw()if qg then a.setWaypoint(qg)qg=false end;if qj then antigrav.setTargetAltitude(qj)qj=false end;if qh then fO(qh,qi)qh=false;qi=""end;if qa~=-1 then cp.cmdCruise(qa,qb)qb=false;qa=-1 end;if q7~=nil then if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or iv:getTargetSpeed(axisCommandId.longitudinal)~=q7 then iv:setTargetSpeedCommand(axisCommandId.longitudinal,q7)else q7=nil end end;if q9~=-1 then cp.cmdThrottle(q9,qb)qb=false;q9=-1 end;if qc then cr.landingGear()qc=false end;if qk then cp.ToggleAutopilot()end end;function pI.ToggleIntoOrbit()cA=false;pQ=nil;pR=nil;pW=0;if not ca then if bx then fQ("orOff","AP")bx=false;pS=false;pV=nil;cv=p;if b3 then b3=false;b5=false end;q5.VectorToTarget=false;q5.AutopilotAlign=false;pU=false elseif cU then fQ("orOn","AP")bx=true;cv=true;if pV==nil then pV=kq end;if b3 then b3=false;b5=false end else bY="Unable to engage auto-orbit, not near a planet"end else bx=false;pS=false;pV=nil;cv=p;if b3 then b3=false end;q5.VectorToTarget=false;q5.AutopilotAlign=false;pU=false end end;function pI.ToggleVerticalTakeoff()b3=false;if b7 then lx=true;b6=false;b5=false;b4=true;cv=true;bV=0;if ca and c9==-1 then b4=false;b3=true;bV=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)qa=bI(cx)end else cA=false;bk=false;d.control.retractLandingGears()iv:setTargetGroundAltitude(X)aZ="VTO Takeoff"end;b7=not b7 end;function pI.checkLOS(qR)local lC,eF,eG=ck:getPlanetarySystem(0):castIntersections(cK,qR,function(eo)if eo.noAtmosphericDensityAltitude>0 then return eo.radius+eo.noAtmosphericDensityAltitude else return eo.radius+eo.surfaceMaxAltitude*1.5 end end)local lD=eF;if eG~=nil and eF~=nil then lD=math.min(eG,eF)end;if lD~=nil then return lC,lD else return nil,nil end end;function pI.ToggleAutopilot()local function r0(bv)cV=false;bo=not bo;if bo then b2=false;if not b3 and not bv then cp.ToggleAltitudeHold()end end;lG="Proceeding to Waypoint"end;local function r1(gu)if gu then for K,dH in pairs(cQ)do if dH.name and dH.name==gu then return K end end else return 0 end end;local r2=false;if bL-pP<1.5 and ca then if not cC then if ca then b8=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude;fQ("11","EP")pP=-1;if b1 or bo or bx then return end else bY="No space engines detected, Orbital Hop not supported"return end elseif kq.hasAtmosphere then if ca then b8=kq.noAtmosphericDensityAltitude+T;fQ("orH","OH")end;pP=-1;if b1 or bo or bx then return end end else pP=bL end;r3=false;if(bj>0 or#bD>0)and not b1 and not bo and not c7 and not bx then if 0.5*d:maxForceForward()/b.getGravityIntensity()<cd then bY="WARNING: Heavy Loads may affect autopilot performance."bZ=5 end;if#bD>0 and not c8 then bj=r1(bD[1])co.UpdateAutopilotTarget()bY="Route Autopilot in Progress"local qX=g1.position-cK;local r4=qX:project_on_plane(cI):len()if r4>50000 and g1.planetname==kq.name then r2=true end end;co.UpdateAutopilotTarget()cp.showWayPoint(c2,bi)if g1~=nil then if g1.agg and not q and antigrav then if not cM then cp.ToggleAntigrav()end;bt=g1.agg end;br=nil;bv=g1.planetname=="Space"if bv then fQ("apSpc","AP")if ca then c7=true;cp.ToggleAltitudeHold()else b1=true end elseif kq.name==g1.planetname then lx=true;if ca then if not bo then fQ("vtt","AP")r0(bv)if r2 then b8=kq.noAtmosphericDensityAltitude+T end end else fQ("apOn","AP")if not(c2.name==kq.name and cc<gl*1.5)then cA=false;b1=true elseif not ca then if bx then cp.ToggleIntoOrbit()end;cz=kq.noAtmosphericDensityAltitude+T;pU=true;q5.AutopilotAlign=true;q5.VectorToTarget=true;pS=false;if not bx then cp.ToggleIntoOrbit()end end end else fQ("apP","AP")a_=false;b0=false;if ca then c7=true;cp.ToggleAltitudeHold()else b1=true end end elseif not ca then if g1==nil and(c2.name==kq.name and cU)and not bx then r5=false;cA=false;pS=false;cp.ToggleIntoOrbit()else fQ("apP","AP")b1=true;a_=false;b0=false;ba=false;bW=false;b3=false;b4=false;b6=false;b5=false;pZ=false;br=nil;r5=false end else fQ("apP","AP")c7=true;cp.ToggleAltitudeHold()end;qk=false else fQ("apOff","AP")cp.ResetAutopilots(1)if qk==2 then qk=true end end end;function pI.routeWP(r6,r7,r8)if r8 then if r8==1 then bD={}bD=ix(bD,bC)if#bD>0 then bY="Route Loaded"else bY="No Saved Route found on Databank"end;return bD else bC={}bC=ix(bC,bD)bY="Route Saved"pH()return end end;if r6 then return bD end;if r7 then bD={}bY="Current Route Cleared"else bD[#bD+1]=g1.name;bY="Added "..g1.name.." to route. "end;return bD end;function pI.cmdThrottle(dI,r9)if iv:getAxisCommandType(0)~=axisCommandType.byThrottle and not r9 then d.control.cancelCurrentControlMasterMode()end;iv:setThrottleCommand(axisCommandId.longitudinal,dI)bM=dh(fR(dI*100,0)/100,-1,1)q7=nil end;function pI.cmdCruise(dI,r9)if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not r9 then d.control.cancelCurrentControlMasterMode()end;iv:setTargetSpeedCommand(axisCommandId.longitudinal,dI)q7=dI end;function pI.ToggleLockPitch()if br==nil then fQ("lkPOn","LP")if not bX then br=cO else br=Q end;b5=false;b3=false;b4=false else fQ("lkPOff","LP")br=nil end end;function pI.ToggleAltitudeHold()if bL-pO<1.5 then if kq.hasAtmosphere then if ca then b8=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude;fQ("11","EP")else if cU then b8=kq.noAtmosphericDensityAltitude+T;cz=b8;pU=true;if not bx then cp.ToggleIntoOrbit()end;pS=true end end;pO=-1;if b3 or bx or b7 then return end end else pO=bL end;if cU and not ca then cz=cc;pU=true;pS=true;cp.ToggleIntoOrbit()if bx then pO=bL else pO=0 end;return end;b3=not b3;b4=false;b6=false;if b3 then b1=false;b0=false;a_=false;bW=false;cv=true;br=nil;cA=false;if c9~=-1 and cH<20 then if bk then cr.landingGear()end;fQ("lfs","LS")b5=true;if pO>-1 then b8=cc+W end;aZ="ATO Hold"iv:setTargetGroundAltitude(X)if aY and cL then cp.ToggleVerticalTakeoff()end else fQ("altOn","AH")b5=false;if pO>-1 then if cU then b8=cc end end;if b7 then cp.ToggleVerticalTakeoff()end end;if cM and not q then local ra=antigrav.getBaseAltitude()if bo and g1.agg and g1.agg>cc then b8=g1.agg elseif b5 then b8=ra end;if eV(cc-ra)<100 and cH<20 then b8=ra;aZ="AGG Hold"q9=0 end end;if c7 then b8=200000 end else fQ("altOff","AH")if bx then cp.ToggleIntoOrbit()end;if b7 then cp.ToggleVerticalTakeoff()end;cv=p;b5=false;bo=false;pO=0 end end;function pI.ResetAutopilots(pI)if pI then c7=false;b1=false;ba=false;pZ=false;b8=cc;r3=false;d7=false;be="Aligning"end;bo=false;b5=false;b6=false;b0=false;b4=false;d8=nil;rb=false;cT=nil;d7=false;if not cM then b3=false;br=nil end;if b7 then cp.ToggleVerticalTakeoff()end;if bx then cp.ToggleIntoOrbit()end;cv=p;c6=false;c8=false;bV=0 end;function pI.BrakeToggle(rc)if not aZ then if rc then aZ=rc else aZ=true end else aZ=false end;if b4 then b4=false;cv=p;d7=false end;if aZ then fQ("bkOn","B",1)cp.ResetAutopilots()else fQ("bkOff","B",1)end end;function pI.BeginReentry()if b6 then bY="Re-Entry cancelled"fQ("reOff","RE")b6=false;cv=p;b3=false elseif not kq.hasAtmosphere then bY="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"bZ=5 elseif not p_ then b6=true;if iv:getAxisCommandType(0)~=rd.cruise then d.control.cancelCurrentControlMasterMode()end;cv=true;aZ=false;bY="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cx;fQ("par","RE")else b6=true;b3=true;cv=true;aZ=false;b8=kq.surfaceMaxAltitude+Z;if b8>kq.spaceEngineMinAltitude then b8=kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude end;local re=iz(b8)bY="Beginning Re-entry.  Target speed: "..cx.." Target Altitude: "..re;fQ("glide","RE")qa=bI(cx)end;b5=false end;function pI.ToggleAntigrav()if antigrav and not q then if cM then fQ("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if bt==nil then bt=cc end;if bt<1000 then bt=1000 end;fQ("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function pI.changeSpd(rf)local rg=1;if rf then rg=-1 end;if not bX then if t and not p9 and pY then local rh=bM;bM=fR(dh(bM+rg*aC/100,-1,1),2)if bM>=0 and rh<0 then bM=0;pY=false end elseif p9 then if ca or b6 then cx=dh(cx+rg*aC,0,U)elseif b1 then a8=dh(a8+rg*aC/3.6*100,0,db-0.2)end else iv:updateCommandFromActionStart(axisCommandId.longitudinal,rg*aC/10)end else if b1 or bo or c7 or bx then cY=cY+1*rg*-1;if cY>#cQ then cY=1 end;if cY<1 then cY=#cQ end else if not rf then rg=1 else rg=nil end;co.adjustAutopilotTargetIndex(rg)end end end;function pI.TenthTick()local function ri()if not b1 then if g1==nil or g1.planetname~=kq.name then rj=(c2.center-cK):len()else rj=(g1.position-cK):len()end end;local fl=cH;local rk=c.getThrottle()/100;if t then rk=bM end;local rl,rm=cl.computeDistanceAndTime(cH,a8,cd,d:maxForceForward()*rk,a0,0)local c0,c1;if not b2 then c0,c1=cp.GetAutopilotBrakeDistanceAndTime(a8)else c0,c1=cp.GetAutopilotTBBrakeDistanceAndTime(a8)end;local dM,rn;if not b2 and fl>0 then dM,rn=cp.GetAutopilotBrakeDistanceAndTime(fl)else dM,rn=cp.GetAutopilotTBBrakeDistanceAndTime(fl)end;local ro=0;local rp=0;if bc or not b1 and fl>5 then rp=cl.computeTravelTime(fl,0,rj)elseif c0+rl<rj then ro=rj-(c0+rl)rp=cl.computeTravelTime(8333.0556,0,ro)else local rq=(rj-c0)/rl;rl=rj-c0;rm=rm*rq end;if g1~=nil and g1.planetname==kq.name and not b1 then return rp elseif bb then return rn elseif bc then return rp+rn else return rm+c1+rp end end;local function rr(oo,rs)if oo==nil then oo=b.getGravityIntensity()end;oo=fR(oo,5)if rs~=nil and rs or(pX==nil or pX~=oo)then local fl=cF:len()local rt=is(c.getWidgetData()).maxBrake;if rt~=nil and rt>0 and ca then rt=rt/dh(fl/100,0.1,1)rt=rt/cb;if cb>0.10 then if bs then bs=(bs+rt)/2 else bs=rt end end end;if rt~=nil and rt>0 then bq=rt end;pX=oo end end;cR,cS=qu(cK)db=bK.getMaxSpeed()if bh~="None"and(c2 or g1)then lE=ri()end;rr(nil,true)end;function pI.SatNavTick()if not r then return end;ql=dbHud_1.getStringValue("SPBAutopilotTargetName")if ql~=nil and ql~=""and ql~="SatNavNotChanged"then local dC=is(dbHud_1.getStringValue("SavedLocations"))if dC~=nil then bn=dC;local gs=-1;local gy;for dH,dt in pairs(bn)do if dt.name and dt.name=="SatNav Location"then gs=dH;break end end;if gs~=-1 then gy=bn[gs]gs=-1;for dH,dt in pairs(e[0])do if dt.name and dt.name=="SatNav Location"then gs=dH;break end end;if gs>-1 then e[0][gs]=gy end;co.UpdateAtlasLocationsList()bY=gy.name.." position updated"end end;for K=1,#cQ do if cQ[K].name==ql then bj=K;a.print("Index = "..bj.." "..cQ[K].name)co.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;function pI.onFlush()local function ru(rv,rw)local rx=vec3()local ry=vec3()if rv==axisCommandId.longitudinal then rx=vec3(bK.getOrientationForward())ry=cD elseif rv==axisCommandId.vertical then rx=vec3(bK.getOrientationUp())ry=q6 elseif rv==axisCommandId.lateral then rx=vec3(bK.getOrientationRight())ry=cE else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bK.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cF:dot(rx)local rE=rw*constants.kph2m;if rF==nil then rF=pid.new(10,0,10.0)end;rF:inject(rE-rD)local rG=rF:get()local rH=(rG-rC-rA)*ry;return rH end;local function rI(rv,rw)local rx=vec3()local ry=vec3()if rv==axisCommandId.longitudinal then rx=vec3(bK.getOrientationForward())ry=cD elseif rv==axisCommandId.vertical then rx=vec3(bK.getOrientationUp())ry=q6 elseif rv==axisCommandId.lateral then rx=vec3(bK.getOrientationRight())ry=cE else return vec3()end;local rz=vec3(b.getWorldGravity())local rA=rz:dot(ry)local rB=vec3(bK.getWorldAirFrictionAcceleration())local rC=rB:dot(ry)local rD=cF:dot(rx)local rE=rw*constants.kph2m;if rJ==nil then rJ=pid.new(10,0,10.0)end;rJ:inject(rE-rD)local rG=rJ:get()local rH=(rG-rC-rA)*ry;return rH end;local function rK(rL,jR,fY)local rM=rL:cross(fY):normalize_inplace()local kD=math.acos(dh(rM:dot(-jR),-1,1))*constants.rad2deg;if rM:cross(-jR):dot(fY)<0 then kD=-kD end;return kD end;local function rN()if cW and not b4 then local eo=cW[1]local hU,hV=cW[2],cW[3]local rO=math.min(hU,hV or hU)local rP=rO/cH;local rQ=b5 and(cH<42 or c9~=-1)local rR=b3 or bo or br or b1;if rR and not rQ and(c0*1.5>rO or rP<1)then aZ="Collision"bD={}q9=0;if b3 then cp.ToggleAltitudeHold()end;if br then cp.ToggleLockPitch()end;bY="Autopilot Cancelled due to possible collision"a.print(eo.name.." COLLISION "..iA(rP).." / "..iz(rO,2))cp.ResetAutopilots(1)lx=true;if ca then b4=true end;cv=true end;if rP<11 then cV=eo.name.." COLLISION "..iA(rP).." / "..iz(rO,2)else cV=eo.name.." collision "..iA(rP)end;if rP<6 then fQ("alarm","AL",2)end else cV=false end end;if antigrav and not q then if not cM and antigrav.getBaseAltitude()~=bt then qj=bt end end;if da then d:setEngineForceCommand('hover',vec3(),1)da=false end;cN=iv:getAxisCommandType(0)==axisCommandType.byThrottle;aM=math.max(aM,0.01)aN=math.max(aN,0.01)aH=math.max(aH,0.01)aL=math.max(aL,0.01)aO=math.max(aO,0.01)aP=math.max(aP,0.01)aG=math.max(aG,0.01)local rS=dh(bS+q0+a.getControlDeviceForwardInput(),-1,1)local rT=dh(bT+q2+a.getControlDeviceYawInput(),-1,1)local rU=dh(bU+q1-a.getControlDeviceLeftRightInput(),-1,1)local rV=aZ and 1 or 0;cI=vec3(b.getWorldVertical())if cI==nil or cI:len()==0 then cI=(kq.center-cK):normalize()end;q6=vec3(bK.getWorldOrientationUp())cD=vec3(bK.getWorldOrientationForward())cE=vec3(bK.getWorldOrientationRight())cG=vec3(bK.getWorldVelocity())cF=vec3(bK.getVelocity())cK=vec3(bK.getWorldPosition())cd=bK.getMass()cH=vec3(cG):len()cJ=-cI:dot(cG)cP=getRoll(cI,cD,cE)local rW=cP/180*math.pi;local rX=math.cos(rW)local rY=math.sin(rW)cO=rK(cI,cD,cE*rX+q6*rY)local rZ=cG:normalize()local r_=eV(cP)local s0=utils.sign(cP)local s1=vec3(bK.getWorldAngularVelocity())local s2=rS*aM*cE+rT*aH*cD+rU*aN*q6;if cv==true and cI:len()>0.01 then local s3=eV(q3-cP)if((b0 or b6 or b4 or c6 or b3 or bx)and s3>0 or ca and s3<aI and p)and rT==0 and eV(cO)<85 then local s4=q3;local s5=aG;if not ca then s5=s5/4;q3=0;s4=0 end;if s6==nil then s6=pid.new(s5*0.01,0,s5*0.1)end;s6:inject(s4-cP)local s7=s6:get()s2=s2+s7*cD end end;local s8=1;local s9=0;local sa=1;bN=0;cb=bJ()ca=false or cc<kq.noAtmosphericDensityAltitude and cb>0.00001;cc=b.getAltitude()c9=qE()bL=bH()pN=bL;if bk and c9>-1 and c9-3<Y then if iv.targetGroundAltitudeActivated then iv:deactivateGroundEngineAltitudeStabilization()end end;if cq then qm=not qm;if qm then cq.UpdateRadar()end;if E then rN()end end;if antigrav then cM=antigrav.isActive()==1 end;local sb=1;local sc=1;local sd=bL-pN;local se=-math.deg(qA(q6,cG,cD))local sf=math.deg(qA(cE,cG,cD))local gn=cI*-1;cw=ca and se<-L or se>L or sf<-M or sf>M;local sg=a.getMouseDeltaX()local sh=a.getMouseDeltaY()if qn then local si=bH()-qn;sg=sg*si/0.016;sh=sh*si/0.016 end;qn=bH()if o and not bX then sh=-sh end;q1=0;q2=0;q0=0;fU=ck[0]local sj=bK.getWorldPosition()kq=fU:closestBody(sj)sk=cm(kq)fp=sk:orbitalParameters(sj,cG)if cc==0 then cc=(cK-kq.center):len()-kq.radius end;cU=c.getClosestPlanetInfluence()>0 or cc>0 and cc<200000;local oo=kq:getGravity(sj):len()*cd;q3=0;local sl=bK.getMaxThrustAlongAxis("ground",bK.getOrientationUp())[1]if qd==0 then if iu()==1 and bX then if not ct then c3=dh(c3+sg/2,-cf/2,cf/2)c4=dh(c4+sh/2,-cg/2,cg/2)end else c3=0;c4=0 end else c3=dh(c3+sg/2,-cf/2,cf/2)c4=dh(c4+sh/2,-cg/2,cg/2)d9=dj(c3*c3+c4*c4)if not bX and iu()==0 then local kM,kN=1,1;if bF=="SCOPE"then kM,kN=d1/90,d1/90 end;if g=="virtual joystick"then if d9>aw then q1=q1-dh(eV(c3)-aw,0,cf/2)*utils.sign(c3)*aE*kM;q0=q0-dh(eV(c4)-aw,0,cg/2)*utils.sign(c4)*aF*kN end else c3=0;c4=0;if g=="mouse"then q0=(-utils.smoothstep(sh,-100,100)+0.5)*2*sb;q1=(-utils.smoothstep(sg,-100,100)+0.5)*2*sc end end end end;local sm=cH>27777;if cH>V/3.6 and not ca and not b1 and not sm then bY="Space Speed Engine Shutoff reached"q9=0 end;if not sm and sn then if not aZ then cp.BrakeToggle()end;if b1 then cp.ResetAutopilots(1)end;q9=0 end;sn=sm;if cb>0.09 then if cH>cx/3.6 and not t and not pJ then aZ="SpdLmt"pJ=true elseif not t and pJ then if cH<cx/3.6 then aZ=false;pJ=false end end end;if b0 then if c6 then aZ=false;local so=false;if g1 and c6==true then so=qQ(g1.position-cK,0.1)else so=qQ(vec3(cG),0.01)end;cv=true;if so then qa=bI(cx)if(eV(cP)<2 or eV(cO)>85)and cH>=cx/3.6-1 then aZ=false;b0=false;if c6~=2 then p_=true end;if c6==true then c8=true end;c6=false;b1=false;cp.BeginReentry()end elseif ca and t then q9=1 end elseif cH>iO then qQ(vec3(cG),0.01)end end;if a_ then if ca then a_=false elseif cH>iO then qQ(-vec3(cG))end end;if not b0 and c6 and not bx then if not ca then if c6~=2 then p_=true end;cp.BeginReentry()c6=false;c8=true else c6=false;if not qk then qk=true end end end;if c8 and g1 and(cc<b8+250 and cc>b8-250)and cH*3.6>cx-250 and eV(cJ)<25 and cb>=0.1 and(g1.position-cK):len()>2000+cc then if not qk then qk=true end;c8=false end;if b7 then cv=true;local sp=b8;if cJ<-30 then bY="Unable to achieve lift. Safety Landing."bV=0;cv=p;b7=false;b4=true elseif not q and cM or b8<kq.spaceEngineMinAltitude then if cM then sp=antigrav.getBaseAltitude()end;if cc<sp-100 then q4=0;bV=15;aZ=false elseif cJ>0 then aZ="VTO Limit"bV=0 elseif cJ<-30 then aZ="VTO Fall"bV=15 elseif cc>=sp then if cM then if b1 or bo then cp.ToggleVerticalTakeoff()else aZ="VTO Complete"b7=false end;bY="Takeoff complete. Singularity engaged"fQ("aggLk","AG")else aZ=false;bY="VTO complete. Engaging Horizontal Flight"fQ("vtoc","VT")cp.ToggleVerticalTakeoff()end;bV=0 end else if cb>0.08 then q4=0;aZ=false;bV=20 elseif cb<0.08 and ca then aZ=false;if cB then q4=0;bV=20 else bV=0;q4=36;qa=3500 end else cv=p;bx=true;cA=false;sq=false;pS=false;pQ=nil;pR=nil;if pV==nil then pV=kq end;cz=sp;pU=true;b7=false end end;if q4~=nil then if sr==nil then sr=pid.new(2*0.01,0,2*0.1)end;local ss=dh(q4-cO,-M*0.80,M*0.80)sr:inject(ss)local st=dh(sr:get(),-1,1)q0=st end end;if bx then local function su()if fp.periapsis.altitude>=cz*0.99 and fp.apoapsis.altitude>=cz*0.99 and fp.periapsis.altitude<fp.apoapsis.altitude and fp.periapsis.altitude*1.05>=fp.apoapsis.altitude and eV(cz-cc)<1000 then return true else return false end end;local qX;local sv=false;local sw=iz(cz)if pV==nil then pV=kq;if bo then pV=c2 end end;if not pU then cz=bI(pV.radius+pV.surfaceMaxAltitude+T)if pV.hasAtmosphere then cz=bI(pV.radius+pV.noAtmosphericDensityAltitude+T)end;pU=true end;if q5.VectorToTarget and g1 then qX=g1.position-cK end;local sx,sy=cm(pV):escapeAndOrbitalSpeed((cK-pV.center):len()-pV.radius)local sz=cP;if not pS then local sA=false;local sB=false;q9=0;pR=0;cy="Aligning to orbital path - OrbitHeight: "..sw;if q5.VectorToTarget then qQ(qX:normalize():project_on_plane(cI))sv=cD:dot(qX:project_on_plane(q6):normalize())>0.95 else qQ(cG)sv=se<0.5;if cH<150 then sv=true end end;q0=0;pQ=0;if cO<=pQ+2 and cO>=pQ-2 then sA=true else sA=false end;if sz<=pR+2 and sz>=pR-2 then sB=true else sB=false end;if sA and sB and sv then pQ=nil;pR=nil;pS=true end else if q5.VectorToTarget then qQ(qX:normalize():project_on_plane(cI))elseif cH>150 then qQ(cG)end;q0=0;if q5.VectorToTarget and g1 then local c0,dM=cl.computeDistanceAndTime(cH,cx/3.6,cd,0,0,bq)if cA and qX:len()>15000+c0+cc then cy="Orbiting to Target"if cc-100<=pV.noAtmosphericDensityAltitude or lE>fp.timeToPeriapsis and fp.periapsis.altitude<pV.noAtmosphericDensityAltitude or not su()and fp.eccentricity>0.1 then bY="Re-Aligning Orbit"cA=false end elseif cA or qX:len()<15000+c0+cc then bY="Orbit complete, proceeding with reentry"fQ("orCom","OB")bi=g1.position;p_=true;c8=true;q5.VectorToTarget,q5.AutopilotAlign=false,false;cp.ToggleIntoOrbit()cp.BeginReentry()return end end;if fp.periapsis~=nil and fp.apoapsis~=nil and fp.eccentricity<1 and cc>cz*0.9 and cc<cz*1.4 then if fp.apoapsis~=nil then if su()or cA then if cA then aZ=false;q9=0;pQ=0;if not q5.VectorToTarget then bY="Orbit complete"fQ("orCom","OB")cp.ToggleIntoOrbit()end else pW=pW+1;if pW>=2 then cA=true end end else cy="Adjusting Orbit - OrbitHeight: "..sw;pT=true;qa=sy*3.6+1;local sC=cz-cc;if sD==nil then sD=pid.new(0.1,0,1*0.1)end;sD:inject(sC-cJ*dh(utils.smoothstep(2000-sC,-2000,2000)^6*10,1,10))pQ=dh(sD:get(),-60,60)end end else local sE=2.75;local sF=eV(fR(sx*sE))local oD=sF%50;if oD>0 then sF=sF-oD+50 end;aZ=false;if cc<cz*0.8 then cy="Escaping planet gravity - OrbitHeight: "..sw;pQ=utils.map(cJ,200,0,-15,80)elseif cc>=cz*0.8 and cc<cz*1.15 then cy="Approaching orbital corridor - OrbitHeight: "..sw;sF=sF*0.75;pQ=utils.map(cJ,100,-100,-15,65)elseif cc>=cz*1.15 and cc<cz*1.5 then cy="Approaching orbital corridor - OrbitHeight: "..sw;sF=sF*0.75;if cJ<0 or pT then pQ=utils.map(cc,cz*1.5,cz*1.01,-30,0)else pQ=utils.map(cc,cz*0.99,cz*1.5,0,30)end elseif cc>cz*1.5 then cy="Reentering orbital corridor - OrbitHeight: "..sw;pQ=-65;local sG=utils.map(cJ,-150,-400,1,0.55)sF=sF*sG end;qa=bI(sF)end end;if pQ~=nil then if sH==nil then sH=pid.new(1*0.01,0,5*0.1)end;local sI=pQ-cO;sH:inject(sI)local sJ=dh(sH:get(),-0.5,0.5)q0=sJ end end;if b1 and not ca and not c6 then local function sK(de,fp)a.print(de)aZ=false;bb=false;b1=false;r3=false;be="Aligning"q9=0;pZ=false;bY=de;fQ("apCom","AP")if fp or c6 then if fp and gl~=nil and not c6 then if not cc or cc==0 then return end;cz=cc;pU=true end;cp.ToggleIntoOrbit()end end;local sL,sM=bi,false;if g1 and g1.planetname~="Space"then ba=true;if not r3 then local sN=(g1.position-c2.center):normalize()local sO=sN:project_on_plane((c2.center-cK):normalize()):normalize()local sP=c2.center+sO*(c2.radius+gl)local sQ=g1.position+(g1.position-c2.center):normalize()*(gl-c2:getAltitude(g1.position))if(cK-sP):len()<(cK-sQ):len()then sL=sP else sL=sQ;bd=0 end;bi=sL;cp.showWayPoint(c2,bi)sM=true;r3=true end;bf=0 elseif g1 and g1.planetname=="Space"then if not r3 then bf=0;sM=true;ba=true;r3=true;sL=g1.position+(cK-g1.position):normalize()*R;bi=sL end elseif g1==nil then bf=0;if not r3 then local sN=(cK+cG*100000-c2.center):normalize()local sO=sN:project_on_plane((c2.center-cK):normalize()):normalize()if sO:len()<1 then sN=(cK+cD*100000-c2.center):normalize()sO=sN:project_on_plane((c2.center-cK):normalize()):normalize()end;sL=c2.center+sO*(c2.radius+gl)bi=sL;r3=true;sM=true;ba=true;cp.showWayPoint(c2,bi)end end;rj=(vec3(sL)-cK):len()local lC,eF,eG=ck:getPlanetarySystem(0):castIntersections(cK,cG:normalize(),function(eo)if eo.noAtmosphericDensityAltitude>0 then return eo.radius+eo.noAtmosphericDensityAltitude else return eo.radius+eo.surfaceMaxAltitude*1.5 end end)local lD=eF;if eG~=nil and eF~=nil then lD=math.min(eG,eF)end;if lD~=nil and lD<rj and lC.name==c2.name then rj=lD end;local so=true;local sR=(c2.center-(cK+vec3(cG):normalize()*rj)):len()-c2.radius;local lp=iz(sR)qh=gd;qi='{"label": "Projected Altitude", "value": "'..lp..'"}'if cH>50 and b9 then local qX=vec3(sL)-cK;local sS=dh(math.deg(qA(q6,cG:normalize(),qX:normalize()))*cH/500,-90,90)local sT=dh(math.deg(qA(cE,cG:normalize(),qX:normalize()))*cH/500,-90,90)if eV(sS)<20 and eV(sT)<20 then sS=sS*2;sT=sT*2 end;if eV(sS)<2 and eV(sT)<2 then sS=sS*2;sT=sT*2 end;local se=-math.deg(qA(q6,cD,cG:normalize()))local sf=-math.deg(qA(cE,cD,cG:normalize()))if sU==nil then sU=pid.new(2*0.01,0,2*0.1)end;sU:inject(sT-sf)local sV=dh(sU:get(),-1,1)q0=q0+sV;if sW==nil then sW=pid.new(2*0.01,0,2*0.1)end;sW:inject(sS-se)local sX=dh(sW:get(),-1,1)q1=q1+sX;sM=true;if eV(sS)>2 or eV(sT)>2 then if be~="Adjusting Trajectory"then be="Adjusting Trajectory"fQ("apAdj","AP")end else if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end end elseif b9 and cH<=50 then qQ((sL-cK):normalize())end;if sR<gl*1.5 then bd=cx/3.6;if g1==nil then dM,bd=cm(c2):escapeAndOrbitalSpeed(sR)end end;local c0,c1;if not b2 then c0,c1=qw(cH)else c0,c1=qz(cH)end;if b1 and not b9 and not bc and not bb then local lC,lD=cp.checkLOS((bi-cK):normalize())if c2.name~=kq.name then if lC~=nil and c2.name~=lC.name and lD<rj then bY="Collision with "..lC.name.." in "..iz(lD).."\nClear LOS to continue."bZ=5;qe=true else qe=false;bY=""end end end;if not qe then if not bc and not bb and not sM then so=qQ((sL-cK):normalize())elseif b2 and(bb or bc)then so=qQ(-vec3(cG):normalize())end end;if b9 then if not pZ then aZ=false;q9=_;bM=fR(_,2)pZ=true end;local rk=c.getThrottle()if t then rk=bM end;local sY=99999;local oB=-vec3(bK.getWorldAcceleration()):dot(cG:normalize())local sZ=dh(cG:dot((sL-cK):normalize()),0,cH)if sZ>0 or oB>0 then sY=cl.computeTravelTime(sZ,oB,rj-c0)end;if a8>db then a8=db-0.2 end;if cF:len()>=a8 or rk==0 and pZ or a0/4>sY then b9=false;if be~="Cruising"then fQ("apCru","AP")be="Cruising"end;bc=true;q9=0 end;local s_=rj;if s_<=c0 or H and cS<=c0+10000 and cR then if H and cS<=c0+10000 and cR then if cS<pK and cS>2000 then cp.ResetAutopilots(1)bY="Autopilot cancelled to prevent crossing PvP Line"aZ="PvP Prevent"pK=cS else pK=cS;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true;q9=0;pZ=false end elseif bb then if be~="Orbiting to Target"then aZ="AP Brk"end;if b2 then q9=1;qb=true end;local dM,sy=cm(c2):escapeAndOrbitalSpeed((cK-kq.center):len()-kq.radius)local qX;if g1 then qX=g1.position-cK end;if g1 and g1.planetname=="Space"and cH<50 then if#bD>0 then if not qk then table.remove(bD,1)end;if#bD>0 then aZ=false;if not qk then qk=2 end;return end end;sK("Autopilot complete, arrived at space location")aZ="Space Arrival"elseif g1 and g1.planetname~="Space"and cH<=sy and(fp.apoapsis==nil or fp.periapsis==nil or fp.apoapsis.altitude<=0 or fp.periapsis.altitude<=0)then sK("Autopilot complete, commencing reentry")bi=g1.position;c6=true;cp.showWayPoint(c2,bi)elseif(g1 and g1.planetname~="Space"or g1==nil)and fp.periapsis~=nil and fp.periapsis.altitude>0 and fp.eccentricity<1 or be=="Circularizing"then if be~="Circularizing"then fQ("apCir","AP")be="Circularizing"end;if cH<=sy then if g1 then if cG:normalize():dot(qX:normalize())>0.4 then if be~="Orbiting to Target"then fQ("apOrb","OB")be="Orbiting to Target"end;if not r5 then aZ=false;cp.showWayPoint(c2,g1.position)r5=true end else sK("Autopilot complete, proceeding with reentry")bi=g1.position;c6=true;cp.showWayPoint(c2,g1.position)r5=false end else sK("Autopilot completed, setting orbit",true)aZ=false end end elseif be=="Circularizing"then sK("Autopilot complete, fixing Orbit",true)end elseif bc then local s_=rj;if s_<=c0 or H and cS<=c0+10000 and cR then if H and cS<=c0+10000 and cR then if cS<pK and cS>2000 then if not qk then qk=true end;bY="Autopilot cancelled to prevent crossing PvP Line"aZ="Prevent PvP"pK=cS else pK=cS;return end end;b9=false;if be~="Braking"then fQ("apBrk","AP")be="Braking"end;bb=true end;local rk=c.getThrottle()if t then rk=bM end;if rk>0 then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;bc=false end else if so then if not ba and g1==nil or not ba and g1 and g1.planetname~="Space"then if not c6 then bi=vec3(c2.center)+(gl+c2.radius)*cE;t0=q6;t1=cE end;ba=true elseif so and not qe then b9=true;if be~="Accelerating"then be="Accelerating"fQ("apAcc","AP")end;if not pZ then q9=_;qb=true;bM=fR(_,2)pZ=true;aZ=false end end end end elseif b1 and(g1~=nil and g1.planetname~="Space"and ca)then bY="Autopilot complete, starting reentry"fQ("apCom","AP")bi=g1.position;aZ=false;bb=false;b1=false;r3=false;be="Aligning"q9=0;pZ=false;b0=true;c6=true;cp.showWayPoint(c2,g1.position)end;if bW then cv=true;local sT=0;local fr=cK+vec3(c.getMasterPlayerRelativePosition())local t2=fr-cK;local t3=vec3(t2):project_on(cD):len()local t4=vec3(t2):project_on(cE):len()local c5=dj(t3*t3+t4*t4)qQ(t2:normalize())local mK=40;local t5=c5<mK;local t6=100;local rw=dh((c5-mK)/2,10,t6)q0=0;local so=eV(q1)<0.1;if so and cH<rw and not t5 then aZ=false;sT=-20 else aZ="Follow"sT=0 end;local t7=0;if eV(sT-cO)>t7 then if t8==nil then t8=pid.new(2*0.01,0,2*0.1)end;t8:inject(sT-cO)local sV=t8:get()q0=sV end end;if b3 or b4 or b6 or bo or br~=nil then local t9=bs;if t9 then t9=t9*dh(cH/100,0.1,1)*cb else t9=bq end;if not ca then t9=bq end;q8=cD:project_on_plane(cI):normalize():dot(cG)if q8>100 then c0,c1=cl.computeDistanceAndTime(q8,100,cd,0,0,t9)local ta,tb=cl.computeDistanceAndTime(100,0,cd,0,0,t9*0.55)c0=c0+ta else c0,c1=cl.computeDistanceAndTime(q8,0,cd,0,0,t9*0.55)end;local sC=b8-cc-cJ;local tc=200+cH;if b6 or c6 then td=2000+cH end;local te=1;if b5 then te=dh(cH/100,0.1,1)end;local sT=(utils.smoothstep(sC,-tc,tc)-0.5)*2*O*te;if not b6 and not c6 and not bo and cD:dot(cG:normalize())<0.99 then sT=(utils.smoothstep(sC,-tc*dh(20-19*cb*10,1,20),tc*dh(20-19*cb*10,1,20))-0.5)*2*O*dh(2-cb*10,1,2)*te end;if not b3 then sT=0 end;if br~=nil then if cU and not bx then sT=br else br=nil end end;cv=true;local tf=q0;if b6 then local tg=bI(cx)local th,ti=cl.computeDistanceAndTime(cH,tg/3.6,cd,0,0,bq-kq.gravity*9.8*cd)th=th==-1 and 5000 or th;local r4=cc-(kq.noAtmosphericDensityAltitude+th)local tj=cc>kq.noAtmosphericDensityAltitude+th*1.35;if tj then sT=P;if cH<=tg/3.6 and cH>tg/3.6-10 and eV(cG:normalize():dot(cD))>0.9 and not cN then bQ=false;q9=1 end elseif(cN or iv:getTargetSpeed(axisCommandId.longitudinal)~=tg)and not tj and not ca then qa=tg;qb=true end;if cN then if cH>tg/3.6 and not tj then aZ="Reentry Limit"if bM>0 then q9=0 end else aZ=false end else aZ=false end;if cJ>0 then aZ="Reentry vSpd"end;if not p_ then sT=-80;if cc<kq.surfaceMaxAltitude+(kq.atmosphereThickness-kq.surfaceMaxAltitude)*0.25 then bY="PARACHUTE DEPLOYED at "..fR(cc,0)b6=false;b4=true;lx=true;q9=0;sT=0;cv=p end elseif kq.noAtmosphericDensityAltitude>0 and tj then cv=true elseif not tj then if not ca and(cN or iv:getTargetSpeed(axisCommandId.longitudinal)~=tg)then qa=tg end;if cH<tg/3.6+1 then aZ=false;p_=false;b6=false;cv=true;q9=1 end end end;if cH>iO and not c7 and not bo and not b4 and u then qQ(vec3(cG))end;if cT or(bo or c7)and bj>0 and ca then local qX;if cT then if type(cT)=="table"then qX=cT elseif cT<3 and cT>0 then qX=-cI:cross(cG)*5000 elseif cT>=3 then qX=cI:cross(cG)*5000 elseif cT<0 then qX=cG*25000 end elseif g1~=nil then qX=g1.position-cK else qX=c2.center-cK end;local sS=math.deg(qA(cI:normalize(),cG,qX))*2;local mN=math.rad(eV(cP))if cH>aJ and ca then local tk=1000+cH;local tl=(utils.smoothstep(sC-cJ*10,-tk,tk)-0.5)*2*O;local tm=dh(90-tl,0,180)q3=dh(sS*2,-tm,tm)local tn=sS;sS=dh(dh(sS,-L*0.80,L*0.80)*math.cos(mN)+4*(cO-sT)*math.sin(math.rad(cP)),-L*0.80,L*0.80)local to=1;if q3~=0 then to=eV(mN/q3)end;to=(90-dh(eV(q3-cP),0,90))/90;local tp=sT;if eV(cP)>90 then tp=-tp end;sT=to*dh(dh(tp*math.cos(mN),-M*0.8,M*0.8)+eV(dh(eV(tn)*math.sin(mN),-M*0.80,M*0.80)),-M*0.80,M*0.80)else q3=0;sS=dh(sS,-L*0.80,L*0.80)end;local tq=se-sS;if cT and eV(tq)<=0.0001 and(type(cT)=="table"or type(cT)~="table"and cT<0 and eV(cP)<1)then if cT==-2 then cp.ToggleAltitudeHold()end;cT=nil;fQ("180Off","BR")return end;if not cw and cH>aJ and ca then if tr==nil then tr=pid.new(2*0.01,0,2*0.1)end;tr:inject(tq)local sX=dh(tr:get(),-1,1)q1=q1+sX elseif ca and c9>-1 or cH<aJ then qQ(qX)elseif cw and ca then if(se<-L or se>L)and ca then qQ(cG)end;if(sf<-M or sf>M)and ca then sT=dh(cO-sf,cO-M*0.80,cO+M*0.80)end end;if g1~=nil and not c7 then local sp=kq:getAltitude(g1.position)local r4=qX:project_on_plane(cI):len()lx=true;if b8<kq.noAtmosphericDensityAltitude and not c7 and not b5 and not b6 and(r4<=c0 and qX:len()<kq.radius)and(cG:project_on_plane(cI):normalize():dot(qX:project_on_plane(cI):normalize())>0.99 or lG=="Finalizing Approach")then lG="Finalizing Approach"if#bD>0 then if not qk then table.remove(bD,1)end;if#bD>0 then if not qk then qk=2 end;return end end;q9=0;if b3 then cp.ToggleAltitudeHold()bo=true end;aZ="AP Finalizing"elseif not b5 then aZ=false end;if lG=="Finalizing Approach"and(q8<0.1 or r4<0.1 or ts~=nil and ts<r4)then fQ("bklOn","BL")b4=true;d7=true;if g1.heading then d8=g1.heading else d8=nil end;bo=false;lG="Proceeding to Waypoint"cV=false end;ts=r4 end elseif bo and not ca and b8>kq.noAtmosphericDensityAltitude and not(c7 or b6)then if g1~=nil and c2.name==kq.name then local qX=g1.position-cK;local sp=kq:getAltitude(g1.position)local r4=dj(qX:len()^2-(cc-sp)^2)local t9=bs;if t9 then c0,c1=cl.computeDistanceAndTime(cH,0,cd,0,0,t9/2)lx=true;if r4<=c0+cH*sd/2 and cG:project_on_plane(cI):normalize():dot(qX:project_on_plane(cI):normalize())>0.99 then if kq.hasAtmosphere then aZ=false;b0=false;p_=true;c6=false;c8=true;b1=false;cp.BeginReentry()end end;ts=r4 end end end;if not ca and(b3 and b8>kq.noAtmosphericDensityAltitude)and not(c7 or bx or b6)then if not cA and not bx then cz=b8;pU=true;if bo then q5.VectorToTarget=true end;cp.ToggleIntoOrbit()bo=false;pS=true end end;if cw and ca and c9==-1 and cH>aJ and lG~="Finalizing Approach"then qQ(cG)sT=dh(cO-sf,cO-M*0.80,cO+M*0.80)end;q0=tf;local qJ=-1;if b4 then if not qf then if not cN then q9=0 end;iv:setTargetGroundAltitude(500)iv:activateGroundEngineAltitudeStabilization(500)bz=true;qf=true end;sT=0;local tt=false;local tu=math.abs(q8)if not q and cM then tt=antigrav.getBaseAltitude()if tt<kq.surfaceMaxAltitude and g1==nil or g1~=nil and kq:getAltitude(g1.position)>tt then tt=false end else tt=false end;if d8 then if tu<0.05 then if cJ>-N then aZ=false else aZ="BL Align BLR"end;if qQ(d8,0.001)then d8=nil;cv=p else q0=0;cv=true end else aZ="BL Align Hzn"end;if tt and eV(cc-tt)<250 then aZ="AGG Align"end else local tv=false;local tw=30;if tu<10 and sl~=nil and sl>0 then local tx=dh(cb,0.4,2)local t9=bs*dh(cH/100,0.1,1)*tx;local ty=sl*tx+t9-oo;local tz=t9/2-oo;local tA=cH-dj(eV(tz/2)*20/(0.5*cd))*utils.sign(tz)if tA<0 then tA=0 end;local tB;if cH>100 then local tC,dM=cl.computeDistanceAndTime(cH,100,cd,0,0,t9)local tD,dM=cl.computeDistanceAndTime(100,0,cd,0,0,dj(t9))tB=tC+tD else tB=cl.computeDistanceAndTime(cH,0,cd,0,0,dj(t9))end;if tB<20 then aZ=false else local tE=0;if tA>100 then local tF,dM=cl.computeDistanceAndTime(tA,100,cd,0,0,ty)local tG,dM=cl.computeDistanceAndTime(100,0,cd,0,0,sl*tx+dj(t9)-oo)tE=tF+tG else tE,dM=cl.computeDistanceAndTime(tA,0,cd,0,0,sl*tx+dj(t9)-oo)end;tE=(tE+15+cH*sd)*1.1;local tH=d7 and g1~=nil and kq:getAltitude(g1.position)>0 and g1.safe;local sp=nil;if tt and tt<cc then sp=tt elseif tH then sp=kq:getAltitude(g1.position)+250 elseif cc>kq.surfaceMaxAltitude then sp=kq.surfaceMaxAltitude end;if cW then local tI=kq:getAltitude(cW[1].center)if sp then if tI>sp then sp=tI end else sp=tI end end;if sp~=nil then local tJ=cc-sp;tv=true;if tJ<=tE or tE==-1 or tu>0.05 and d7 then if tu>0.05 and d7 then aZ="BL AP Hzn"else aZ="BL Stop Dist"end else aZ=false end end end end;qJ=c9;if qJ>-1 then if(cH<1 or cG:normalize():dot(cI)<0)and not d8 then b4=false;b3=false;if not tt then qc=true;iv:setTargetGroundAltitude(Y)end;bV=0;aZ="BL Complete"cv=p;d7=false else aZ="BL Slowing"end elseif not tv then if lx and cG:normalize():dot(-gn)<0.999 then aZ="BL Strong"qQ()elseif tu>10 or tu>0.05 and d7 then aZ="BL hSpd"elseif cJ<-N then aZ="BL BLR"else aZ=false end end end else qf=false end;if b5 or c7 then local lC,eG,eF;if bi~=nil then lC,eG,eF=ck:getPlanetarySystem(0):castIntersections(cK,(bi-cK):normalize(),function(eo)if eo.noAtmosphericDensityAltitude>0 then return eo.radius+eo.noAtmosphericDensityAltitude else return eo.radius+eo.surfaceMaxAltitude*1.5 end end)end;if cM and not c7 then if cc>=b8-50 and cH>iO then b5=false;if not b1 and not bo then aZ="ATO Agg Arrive"q9=0 end end elseif eV(sT)<15 and cc/b8>0.75 then b5=false;if not c7 then if cN and not t then d.control.cancelCurrentControlMasterMode()end elseif c7 and cH<iO then b1=true;c7=false;b3=false;b5=false;q9=0 elseif c7 then q9=0;aZ="ATO Space"end elseif c7 and not ca and c2~=nil and(lC==nil or lC.name==c2.name)then b1=true;c7=false;b3=false;b5=false;if not cN then q9=0 end;b9=true end end;local tK=c9>-1;local tL=cO;if(bo or c7 or cT)and not tK and cH>aJ and ca then local mN=math.rad(eV(cP))tL=cO*eV(math.cos(mN))+sf*math.sin(mN)end;local tM=dh(sT-tL,-M*0.80,M*0.80)if not ca and bo then tM=dh(sT-tL,-85,O)elseif not ca then tM=dh(sT-tL,-O,O)end;if eV(cP)<5 or bo or cT or b4 or tK or b3 then if t8==nil then t8=pid.new(5*0.01,0,5*0.1)end;t8:inject(tM)local sV=t8:get()q0=q0+sV end end;if antigrav~=nil and(antigrav and not q and cc<200000)then if bt==nil or bt<1000 then bt=1000 end;if tN~=bt then tN=bt;qj=tN end end;if(ca or b6 or c8)and t and cN then if tO==nil then tO=pid.new(0.1,0,1)end;local tP=0;if aS>0 and not b6 and cb>0.005 and cb<0.1 and cJ>-50 then tP=(0.1-cb)*cx*aS end;tO:inject(cx/3.6+tP-cG:dot(cD))local tQ=tO:get()bP=dh(tQ,-1,1)if not d3 then if bP<bM and(cb>0.005 or b6 or c8)then bO=true;d3=dh(bP,0.01,1)else bO=false;d3=bM end end;if tR==nil then tR=pid.new(1*0.01,0,1*0.1)end;tR:inject(cG:len()-cx/3.6-tP)local tS=dh(tR:get(),0,1)if ca and cJ<-80 or(cb>0.005 or b6 or c8)then bN=tS end;if bN>0 then if bO and bP==0.01 and not d3 then d3=0 end else bP=dh(bP,0.01,1)end;local tT=''local tU=vec3()local tV=ru(axisCommandId.vertical,bV*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",tV,s9)local tW='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tW=tW..aT end;local tX=iv:getAxisCommandType(axisCommandId.longitudinal)local tY=iv:composeAxisAccelerationFromThrottle(tW,axisCommandId.longitudinal)local tZ=rI(axisCommandId.lateral,bw*1000)tT=tT..' , '.."lateral airfoil , lateral ground "tU=tU+tZ;if tU:len()>constants.epsilon then d:setEngineForceCommand(tT,tU,s9,'','','',sa)end;d:setEngineForceCommand(tW,tY,s8)local t_='thrust analog vertical fueled 'local u0='thrust analog lateral fueled 'if bA=="All"or bA=="Lateral"then u0=u0 ..aU end;if bA=="All"or bA=="Vertical"then t_=t_..aV end;if bV~=0 or b4 and aZ or not bk and not bz then d:setEngineForceCommand(t_,tV,s8)else d:setEngineForceCommand(t_,vec3(),s8)end;if bw~=0 then d:setEngineForceCommand(u0,tZ,s8)else d:setEngineForceCommand(u0,vec3(),s8)end;if rV==0 then rV=bN end;local u1=-rV*(aO*cG+aP*rZ)d:setEngineForceCommand('brake',u1)else if t then if not d3 then d3=bM end end;local rw=c.getAxisCommandValue(0)if not cN then if tR==nil then tR=pid.new(1*0.01,0,1*0.1)end;tR:inject(cG:len()-rw/3.6)local tS=dh(tR:get(),0,1)rV=dh(rV+tS,0,1)end;local u1=-rV*(aO*cG+aP*rZ)d:setEngineForceCommand('brake',u1)local tT=''local tU=vec3()local u2=false;local tW='thrust analog longitudinal 'if bA=="All"or bA=="Longitude"then tW=tW..aT end;local tX=iv:getAxisCommandType(axisCommandId.longitudinal)if tX==axisCommandType.byThrottle then local tY=iv:composeAxisAccelerationFromThrottle(tW,axisCommandId.longitudinal)d:setEngineForceCommand(tW,tY,s8)elseif tX==axisCommandType.byTargetSpeed then local tY=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)tT=tT..' , '..tW;tU=tU+tY;if iv:getTargetSpeed(axisCommandId.longitudinal)==0 or iv:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-iv:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then u2=true end end;local u0='thrust analog lateral 'if bA=="All"or bA=="Lateral"then u0=u0 ..aU end;local u3=iv:getAxisCommandType(axisCommandId.lateral)if u3==axisCommandType.byThrottle then local u4=iv:composeAxisAccelerationFromThrottle(u0,axisCommandId.lateral)d:setEngineForceCommand(u0,u4,s8)elseif u3==axisCommandType.byTargetSpeed then local tZ=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)tT=tT..' , '..u0;tU=tU+tZ end;local t_='thrust analog vertical 'if bA=="All"or bA=="Vertical"then t_=t_..aV end;local u5=iv:getAxisCommandType(axisCommandId.vertical)if u5==axisCommandType.byThrottle then local tV=iv:composeAxisAccelerationFromThrottle(t_,axisCommandId.vertical)if bV~=0 or b4 and aZ then d:setEngineForceCommand(t_,tV,s8,'airfoil','ground','',sa)else d:setEngineForceCommand(t_,vec3(),s8)d:setEngineForceCommand('airfoil vertical',tV,s8,'airfoil','','',sa)d:setEngineForceCommand('ground vertical',tV,s8,'ground','','',sa)end elseif u5==axisCommandType.byTargetSpeed then if bV<0 then d:setEngineForceCommand('hover',vec3(),s8)end;local u6=iv:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)tT=tT..' , '..t_;tU=tU+u6 end;if tU:len()>constants.epsilon then if rV~=0 or u2 or eV(rZ:dot(cD))<0.5 then tT=tT..', brake'end;d:setEngineForceCommand(tT,tU,s9,'','','',sa)end end;local u7=aL*(s2-s1)local u8=vec3(bK.getWorldAirFrictionAngularAcceleration())u7=u7-u8;d:setEngineTorqueCommand('torque',u7,s8,'airfoil','','',sa)d:setBoosterCommand('rocket_engine')if b_ and not n then local fl=cF:len()local u9=0.15;if not cN then local ua=iv:getTargetSpeed(axisCommandId.longitudinal)if fl*3.6>ua*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fl*3.6<ua*(1-u9)and not ub then ub=true;d:toggleBoosters()end else local rk=c.getThrottle()if t then rk=bM*100 end;local rw=rk/100;if not ca then rw=rw*a8;if fl>=rw*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fl<rw*(1-u9)and not ub then ub=true;d:toggleBoosters()end else local tg=bI(cx)rw=rw*tg/3.6;if fl>=rw*(1-u9)and ub then ub=false;d:toggleBoosters()elseif fl<rw*(1-u9)and not ub then ub=true;d:toggleBoosters()end end end end end;if uc then for dH,dt in pairs(uc)do pI[dH]=dt end end;c9=qE()return pI end;local function ud(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ue,iu,iv,iw,uf,gJ,fR,e0,di,dh,fQ,iy,pH)local ug={}local uh=true;local ui=5;local uj=5;local uk=ui;local ul=uj;local um=bL;function ug.landingGear()bk=not bk;if bk then bo=false;br=nil;cp.cmdThrottle(0)if vBooster or hover then if ca and c9==-1 then fQ("bklOn","BL")lx=true;b6=false;b5=false;b7=false;b3=false;if b4 then d7=not d7 end;b4=true;cv=true;bk=false else if bR then fQ("grOut","LG",1)d.control.deployLandingGears()end;d7=false;iv:setTargetGroundAltitude(Y)if ca then aZ="Landing"end end elseif bR and not b4 then fQ("grOut","LG",1)d.control.deployLandingGears()end else if bR then fQ("grIn","LG",1)d.control.retractLandingGears()end;iv:activateGroundEngineAltitudeStabilization(un)if bz then if Y<iv.targetGroundAltitude then iv:setTargetGroundAltitude(iv.targetGroundAltitude)else iv:setTargetGroundAltitude(X)end end end end;function ug.startControl(uo)local function up(rf)local rg=1;local function uq(ur,rf)local us={kq.surfaceMaxAltitude+100,kq.spaceEngineMinAltitude-0.01*kq.noAtmosphericDensityAltitude,kq.noAtmosphericDensityAltitude+T,kq.radius*(S-1)+kq.noAtmosphericDensityAltitude}local ut=ur;for dM,dt in ipairs(us)do if rf and ut>dt then ur=dt elseif ur<dt and not rf then ur=dt;break end end;return ur end;if rf then rg=-1 end;if not q and cM then if bX and rf then bt=1000 elseif bt~=nil then bt=bt+rg*uj;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end else bt=tN+rg*100 end elseif b3 or b7 or bx then if bx then if bX then cz=uq(cz,rf)else cz=cz+rg*ui end;if cz<kq.noAtmosphericDensityAltitude then cz=kq.noAtmosphericDensityAltitude end else if bX and ca then b8=uq(b8,rf)else b8=b8+rg*ui end end else iv:updateTargetGroundAltitudeFromActionStart(rg*1.0)end end;local function uu(uv)if not ca then bY="Flight Assist in Atmo only"return end;local dq=type(uv)if cT==nil then if dq=="table"then if b1 or bo then cp.ToggleAutopilot()end;fQ("180On","BR")elseif uv==1 then fQ("bnkLft","BR")else fQ("bnkRht","BR")end;if not b3 and not b1 and not bo then cp.ToggleAltitudeHold()if dq~="table"then uv=uv+1 end end;cT=uv else fQ("180Off","BR")cT=nil end end;if uo=="gear"then cr.landingGear()elseif uo=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif uo=="forward"then if p9 and not ca and not b1 then b0=not b0;a_=false else bS=bS-1 end elseif uo=="backward"then if p9 then if not ca then if not b1 then a_=not a_;b0=false else b2=not b2 end else uu(-cG*5000)end else bS=bS+1 end elseif uo=="left"then if p9 then uu(1)else bT=bT-1 end elseif uo=="right"then if p9 then uu(3)else bT=bT+1 end elseif uo=="yawright"then bU=bU-1;d8=nil elseif uo=="yawleft"then bU=bU+1;d8=nil elseif uo=="straferight"then iv:updateCommandFromActionStart(axisCommandId.lateral,1.0)bw=1 elseif uo=="strafeleft"then iv:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bw=-1 elseif uo=="up"then bV=bV+1;if c9-3<Y and cc>0 and bk then cr.landingGear()end;iv:deactivateGroundEngineAltitudeStabilization()iv:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif uo=="down"then bV=bV-1;iv:deactivateGroundEngineAltitudeStabilization()iv:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif uo=="groundaltitudeup"then up()elseif uo=="groundaltitudedown"then up(true)elseif uo=="option1"then uw=false;if p9 and bX then local ux=""for K=1,#cZ do ux=ux.."| Name: "..a.getPlayerName(cZ[K]).." Mass: "..fR(b.getBoardedPlayerMass(cZ[K])/1000,1).."t "end;a.print("Onboard: "..ux)return end;co.adjustAutopilotTargetIndex()elseif uo=="option2"then uw=false;if p9 and bX then for K=1,#cZ do b.forceDeboard(cZ[K])b.forceInterruptVRSession(cZ[K])end;bY="Deboarded All Passengers"return end;co.adjustAutopilotTargetIndex(1)elseif uo=="option3"then local function uy()uh=not uh;if not uh then fQ("wid","DH")c.showWidget()b.showWidget()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(uz,atmofueltank_size,"Atmo Fuel","fuel_container")uA=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(uB,spacefueltank_size,"Space Fuel","fuel_container")uC=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(uD,rocketfueltank_size,"Rocket Fuel","fuel_container")uE=_autoconf.panels[_autoconf.panels_size]end;uF=a.createWidgetPanel("Docking")uG=a.createWidget(uF,"parenting")a.addDataToWidget(c.getWidgetDataId(),uG)uH=a.createWidgetPanel("Core combat stress")uI=a.createWidget(uH,"core_stress")a.addDataToWidget(b.getWidgetDataId(),uI)if shield~=nil then shield.showWidget()end else fQ("hud","DH")c.hideWidget()b.hideWidget()if uA~=nil then gJ(uA)uA=nil end;if uF~=nil then gJ(uF)uF=nil end;if uH~=nil then gJ(uH)uH=nil end;if uC~=nil then gJ(uC)uC=nil end;if uE~=nil then gJ(uE)uE=nil end;if shield~=nil then shield.hideWidget()end end end;uw=false;if p9 and bX then local ux=""for K=1,#c_ do ux=ux.."| ID: "..c_[K].." Mass: "..fR(b.getDockedConstructMass(c_[K])/1000,1).."t "end;a.print("Docked Ships: "..ux)return end;if x then if w then w=false else w=true end end;uy()elseif uo=="option4"then uw=false;if p9 and bX then for K=1,#c_ do b.forceUndock(c_[K])end;bY="Undocked all ships"return end;cT=nil;cp.ToggleAutopilot()elseif uo=="option5"then uw=false;cp.ToggleLockPitch()elseif uo=="option6"then uw=false;if p9 and bX then if shield then cs.ventShield()else bY="No shield found"end;return end;cp.ToggleAltitudeHold()elseif uo=="option7"then uw=false;if p9 and bX then if shield then shield.toggle()return else bY="No shield found"return end end;E=not E;if E then bY="Collision System Enabled"else bY="Collision System Secured"end elseif uo=="option8"then uw=false;if p9 and bX then if bj>0 and g1~=nil then cp.routeWP()else bY="Select a saved wp on IPH to add to or remove from route"end;return end;bz=not bz;if not bz then bY="DeCoupled Mode - Ground Stabilization off"iv:deactivateGroundEngineAltitudeStabilization()fQ("gsOff","GS")else bY="Coupled Mode - Ground Stabilization on"iv:activateGroundEngineAltitudeStabilization(un)da=true;fQ("gsOn","GS")end elseif uo=="option9"then uw=false;if p9 and bX then iv:resetCommand(axisCommandId.longitudinal)iv:resetCommand(axisCommandId.lateral)iv:resetCommand(axisCommandId.vertical)cp.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ce=gyro.getState()==1;if ce then fQ("gyOn","GA")else fQ("gyOff","GA")end else bY="No gyro found"end elseif uo=="lshift"then cX=false;if p9 then bX=true end;if iw()==1 then bX=true;bg=iw()uf(1)elseif iu()==1 and y then bX=true;cu=false;ct=false end elseif uo=="brake"then if aX or p9 then cp.BrakeToggle("Manual")elseif not aZ then cp.BrakeToggle("Manual")else aZ="Manual"end elseif uo=="lalt"then uw=true;p9=true;if iu()==0 and not i and g=="keyboard"then uf(1)end elseif uo=="booster"then if n then d:toggleBoosters()elseif not b_ then if not ub then d:toggleBoosters()ub=true end;b_=true else if ub then d:toggleBoosters()ub=false end;b_=false end elseif uo=="stopengines"then local function uJ()if bL-um<1.5 then fQ("clear","CA")cp.clearAll()end end;uJ()um=bL;if iv:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bM~=0 then iv:resetCommand(axisCommandId.longitudinal)cp.cmdThrottle(0)else cp.cmdThrottle(100)end else if iv:getTargetSpeed(axisCommandId.longitudinal)~=0 then iv:resetCommand(axisCommandId.longitudinal)else if ca then cp.cmdCruise(cx)else cp.cmdCruise(a8*3.6)end end end elseif uo=="speedup"then cp.changeSpd()elseif uo=="speeddown"then cp.changeSpd(true)elseif uo=="antigravity"and not q then if antigrav~=nil then cp.ToggleAntigrav()else bY="No antigrav found"end end end;function ug.stopControl(uo)local function uK()if not q and cM then ul=uj end;if b3 or b7 or bx then uk=ui end end;if uo=="forward"then bS=0 elseif uo=="backward"then bS=0 elseif uo=="left"then if cT then if cT==2 then cT=-2 else cT=-1 end end;bT=0 elseif uo=="right"then if cT then if cT==4 then cT=-2 else cT=-1 end end;bT=0 elseif uo=="yawright"then bU=0 elseif uo=="yawleft"then bU=0 elseif uo=="straferight"then iv:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bw=0 elseif uo=="strafeleft"then iv:updateCommandFromActionStop(axisCommandId.lateral,1.0)bw=0 elseif uo=="up"then bV=0;iv:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bz then iv:activateGroundEngineAltitudeStabilization(un)da=true end elseif uo=="down"then bV=0;iv:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bz then iv:activateGroundEngineAltitudeStabilization(un)da=true end elseif uo=="groundaltitudeup"then uK()uw=false elseif uo=="groundaltitudedown"then uK()uw=false elseif uo=="lshift"then if iw()==1 then c3=0;c4=0;uf(bg)elseif iu()==1 and y then cu=false;ct=false end;bX=false elseif uo=="brake"then if not aX and not p9 then if aZ then cp.BrakeToggle()else aZ=false end end elseif uo=="lalt"then if iu()==0 and i then if uw then if iw()==1 then uf(0)else uf(1)end else uw=true end elseif iu()==0 and not i and g=="keyboard"then uf(0)end;p9=false end end;function ug.loopControl(uo)local function uL(rf)local rg=1;if rf then rg=-1 end;if not q and cM then if bt~=nil then bt=bt+rg*ul;if bt<1000 then bt=1000 end;if b3 and bt<b8+10 and bt>b8-10 then b8=bt end;ul=dh(ul*1.05,uj,50)else bt=tN+rg*100 end elseif b3 or b7 or bx then if bx then cz=cz+rg*uk;if cz<kq.noAtmosphericDensityAltitude then cz=kq.noAtmosphericDensityAltitude end else b8=b8+rg*uk end;uk=dh(uk*1.05,ui,50)else iv:updateTargetGroundAltitudeFromActionLoop(rg*1.0)end end;local function uM(rf)local rg=1;if rf then rg=-1 end;if not bX then if t and not p9 then bM=dh(bM+rg*aD/100,-1,1)else iv:updateCommandFromActionLoop(axisCommandId.longitudinal,rg*aD)end end end;if uo=="groundaltitudeup"then if not bX then uL()end elseif uo=="groundaltitudedown"then if not bX then uL(true)end elseif uo=="speedup"then uM()elseif uo=="speeddown"then uM(true)end end;function ug.inputTextControl(re)local function uN(uO,fr,gv)local function uP(fr)local dz=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dA='::pos{'..dz..','..dz..','..dz..','..dz..','..dz..'}'local dQ,dR,dY,dZ,d_=e0(fr,dA)if dQ=="0"and dR=="0"then return vec3(di(dY),di(dZ),di(d_))end;dZ=math.rad(dZ)dY=math.rad(dY)local kq=e[di(dQ)][di(dR)]local eR=math.cos(dY)local uQ=vec3(eR*math.cos(dZ),eR*math.sin(dZ),math.sin(dY))return kq.center+(kq.radius+d_)*uQ end;local fT=uP(fr)return co.AddNewLocation(uO,fT,gv)end;local K;local uR,ii=nil,nil;local uS="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations."K=string.find(re," ")uR=re;if K~=nil then uR=string.sub(re,0,K-1)ii=string.sub(re,K+1)end;if uR=="/help"or uR=="/commands"then for ly in string.gmatch(uS,"([^\n]+)")do a.print(ly)end;return elseif uR=="/setname"then if ii==nil or ii==""then bY="Usage: ah-setname Newname"return end;if bj>0 and g1~=nil then co.UpdatePosition(ii)else bY="Select a saved target to rename first"end elseif shield and uR=="/resist"then cs.setResist(ii)elseif uR=="/addlocation"or string.find(re,"::pos")~=nil then local gv=false;local uO="0-Temp"if ii==nil or ii==""or uR~="/addlocation"then ii=uR;gv=true end;K=string.find(ii,"::")if not gv then uO=string.sub(ii,1,K-2)end;local fr=string.sub(ii,K)uN(uO,fr,gv)elseif uR=="/agg"then if ii==nil or ii==""then bY="Usage: /agg targetheight"return end;ii=di(ii)if ii<1000 then ii=1000 end;bt=ii;bY="AGG Target Height set to "..ii elseif uR=="/G"then if ii==nil or ii==""then bY="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if ii=="dump"then for dH,dt in pairs(iy())do if type(dt.get())=="boolean"then if dt.get()==true then a.print(dH.." true")else a.print(dH.." false")end elseif dt.get()==nil then a.print(dH.." nil")else a.print(dH.." "..dt.get())end end;return end;K=string.find(ii," ")local uT=string.sub(ii,0,K-1)local uU=string.sub(ii,K+1)for dH,dt in pairs(iy())do if dH==uT then local uV=type(dt.get())if uV=="number"then uU=di(uU)if dH=="AtmoSpeedLimit"then cx=uU end end;bY="Variable "..uT.." changed to "..uU;if dH=="MaxGameVelocity"then uU=uU/3.6;if uU>db-0.2 then uU=db-0.2;bY="Variable "..uT.." changed to "..fR(uU*3.6,1)end end;if uV=="boolean"then if string.lower(uU)=="true"then uU=true else uU=false end end;dt.set(uU)return end end;bY="No such global variable: "..uT elseif uR=="/deletewp"then if bj>0 and g1~=nil then co.ClearCurrentPosition()else bY="Select a custom wp to delete first in IPH"end elseif uR=="/copydatabank"then if dbHud_2 then pH(true)else bY="Spare Databank required to copy databank"end elseif uR=="/iphWP"then if bj>0 then a.print(cp.showWayPoint(c2,bi,true))a.print(json.encode(bi))bY="::pos waypoint shown in lua chat in local and world format"else bY="No target selected in IPH"end elseif uR=="/createPrivate"then local uW="privatelocations = {\n"local uX=""if#d5>0 then for dH,dt in pairs(d5)do uW=uW.."{position = {x = "..dt.position.x..", y = "..dt.position.y..", z = "..dt.position.z.."},\n ".."name = '"..dt.name.."',\n planetname = '"..dt.planetname.."',\n gravity = "..dt.gravity..",\n"if dt.heading then uW=uW.."heading = {x = "..dt.heading.x..", y = "..dt.heading.y..", z = "..dt.heading.z.."},\n"end;if dt.safe then uW=uW.."safe = true},\n"else uW=uW.."safe = false},\n"end end end;uX=#d5 .."-Private "if ii=="all"then for dH,dt in pairs(bn)do uW=uW.."{position = {x = "..dt.position.x..", y = "..dt.position.y..", z = "..dt.position.z.."},\n ".."name = '*"..dt.name.."',\n planetname = '"..dt.planetname.."',\n gravity = "..dt.gravity..",\n"if dt.heading then uW=uW.."heading = {x = "..dt.heading.x..", y = "..dt.heading.y..", z = "..dt.heading.z.."},\n"end;if dt.safe then uW=uW.." safe = true},\n"else uW=uW.."safe = false},\n"end end;uX=uX..#bn.."-Public "end;uW=uW.."}\n return privatelocations"if ue then ue.setHTML(uW)end;bY=uX.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use"bZ=7 end end;function ug.tagTick()if bA=="Off"then bA="All"elseif bA=="All"then bA="Longitude"elseif bA=="Longitude"then bA="Lateral"elseif bA=="Lateral"then bA="Vertical"else bA="Off"end;bY="Extra Engine Tags: "..bA;c.stopTimer("tagTick")end;if uY then for dH,dt in pairs(uY)do ug[dH]=dt end end;return ug end;local function uZ(d,b,c,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ir,ue)local a=DUSystem;local bK=DUConstruct;local u_=DUPlayer;local gI=DULibrary;local v0={}local dg=string.format;local is=json.decode;local v1=json.encode;local pz=b.getElementMaxHitPointsById;local it=b.getElementMassById;local iu=d.control.isRemoteControlled;local e0=string.match;local gJ=a.destroyWidgetPanel;local fO=a.updateData;local fP=a.addDataToWidget;local uf=a.lockView;local iw=a.isViewLocked;local dj=math.sqrt;local di=tonumber;local eV=math.abs;local bI=math.floor;local bJ=c.getAtmosphereDensity;local eQ=math.atan;local bH=a.getArkTime;local dh=utils.clamp;local iv=d.axisCommandManager;local v2=Y;local gL=13;local iB=b.getElementIdList()local iC=0;local function dk(ey,ez)if ey==0 then return eV(ez)<1e-09 end;if ez==0 then return eV(ey)<1e-09 end;return eV(ey-ez)<math.max(eV(ey),eV(ez))*dy end;local function fR(dz,v3)local rg=10^(v3 or 0)return bI(dz*rg+0.5)/rg end;local function ix(v4,v5)for dH,dt in pairs(v5)do if type(dH)=="string"then v4[dH]=dt else v4[#v4+1]=v5[dH]end end;return v4 end;local function iy(v6)local v7={}if not v6 then ix(v7,J)ix(v7,a7)ix(v7,aB)ix(v7,aW)return v7 elseif v6=="boolean"then return J elseif v6=="handling"then return a7 elseif v6=="hud"then return aB elseif v6=="physics"then return aW end end;local function pH(v8)local function v9(va)for dH,dt in pairs(va)do dbHud_1.setStringValue(dH,v1(dt.get()))if v8 and dbHud_2 then dbHud_2.setStringValue(dH,v1(dt.get()))end end end;if dbHud_1 then v9(bE)v9(iy())a.print("Saved Variables to Datacore")if v8 and dbHud_2 then bY="Databank copied.  Remove copy when ready."end end end;local function fQ(vb,vc,type)if type==nil and not C or type~=nil and not D or h=="archHUD"then return end;a.playSound(h.."/"..vb..".mp3")end;local function gK(hr,hs,re,jI,vd)if jI==nil then jI=""end;if vd==nil then vd=""end;return dg([[<text class="%s" x=%s y=%s style="%s">%s</text>]],jI,hr,hs,vd,re)end;local function iz(c5,ve)local vf=c5>100000;if ve==nil then ve=1 end;if vf then return fR(c5/1000/200,ve).."SU"elseif c5<1000 then return fR(c5,ve).."M"else return fR(c5/1000,ve).."KM"end end;local function iA(vg)local vh=0;local vi=0;local vj=0;if vg<60 then vg=bI(vg)elseif vg<3600 then vh=bI(vg/60)vg=bI(vg%60)elseif vg<86400 then vi=bI(vg/3600)vh=bI(vg%3600/60)else vj=bI(vg/86400)vi=bI(vg%86400/3600)end;if vj>0 then return vj.."d "..vi.."h "elseif vi>0 then return vi.."h "..vh.."m "elseif vh>0 then return vh.."m "..vg.."s"elseif vg>0 then return vg.."s"else return"0s"end end;function v0.onStart()local vk=false;local function vl()local function vm(vn)local vo=dbHud_1.hasKey;for dH,dt in pairs(vn)do if vo(dH)then local dC=is(dbHud_1.getStringValue(dH))if dC~=nil then dt.set(dC)vk=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not f then vm(iy())coroutine.yield()vm(bE)else vm(bE)bY="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"bZ=5;vk=false end;coroutine.yield()if vk then bY="Loaded Saved Variables"elseif not f then bY="No Databank Saved Variables Found\nVariables will save to Databank on standing"bZ=5 end;if#bn>0 then d6=ix(d6,bn)end else bY="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;cf=a9;cg=aa;aX=j;g=string.lower(g)cv=p;cx=U;if bu+180<bL then bs=0 end;bu=bL;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then bY="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"bZ=7 end;if antigrav and not q then if bt==nil then bt=cc end;antigrav.setTargetAltitude(bt)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then if#d5>0 then d6=ix(d6,d5)end end;lG="Proceeding to Waypoint"if a8<0 then a8=bK.getMaxSpeed()-0.1 end end;local function vp()local function vq(vr,vs)if vr>vs then vs=vr end;local vt,vu=0,0;if a4>0 then vt=a4*0.05 end;if a5>0 then vu=a5*0.05 end;vs=vs*(1-(vt+vu))return vs end;local vv=b.getElementNameById;local vw=aq~=0 and ar~=0;local vx=_G["atmofueltank_size"]local vy=_G["spacefueltank_size"]local vz=_G["rocketfueltank_size"]for dH in pairs(iB)do local type=b.getElementDisplayNameById(iB[dH])if e0(type,'^.*Atmospheric Engine$')then if e0(tostring(b.getElementTagsById(iB[dH])),'^.*vertical.*$')and b.getElementForwardById(iB[dH])[3]>0 then cL=true end end;if e0(type,'^.*Space Engine$')then cC=true;if e0(tostring(b.getElementTagsById(iB[dH])),'^.*vertical.*$')then local vA=b.getElementForwardById(iB[dH])if vA[3]<0 then vB=true else cB=true end end end;if type=="Landing Gear"then bR=true end;if type=="Dynamic Core Unit"then local pB=pz(iB[dH])if pB>10000 then gL=110 elseif pB>1000 then gL=55 elseif pB>150 then gL=27 end end;iC=iC+pz(iB[dH])if vw and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pB=pz(iB[dH])local ox=it(iB[dH])local vr=0;local jB=bH()if type=="Atmospheric Fuel Tank"then local vs=400;local vC=35.03;if pB>10000 then vs=51200;vC=5480 elseif pB>1300 then vs=6400;vC=988.67 elseif pB>150 then vs=1600;vC=182.67 end;vr=ox-vC;if a1>0 then vs=vs+vs*a1*0.2 end;vs=vq(vr,vs)local gu=vv(iB[dH])local jz=0;for jA=1,vx do if gu==is(c["atmofueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vD={iB[dH],string.sub(gu,1,12),vs,vC,vr,jB,jz}ch[#ch+1]=vD end;if type=="Rocket Fuel Tank"then local vs=320;local vC=173.42;if pB>65000 then vs=40000;vC=25740 elseif pB>6000 then vs=5120;vC=4720 elseif pB>700 then vs=640;vC=886.72 end;vr=ox-vC;if a3>0 then vs=vs+vs*a3*0.1 end;vs=vq(vr,vs)local gu=vv(iB[dH])local jz=0;for jA=1,vz do if gu==is(c["rocketfueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vD={iB[dH],string.sub(gu,1,12),vs,vC,vr,jB,jz}cj[#cj+1]=vD end;if type=="Space Fuel Tank"then local vs=600;local vC=35.03;if pB>10000 then vs=76800;vC=5480 elseif pB>1300 then vs=9600;vC=988.67 elseif pB>150 then vs=2400;vC=182.67 end;vr=ox-vC;if a2>0 then vs=vs+vs*a2*0.2 end;vs=vq(vr,vs)local gu=vv(iB[dH])local jz=0;for jA=1,vy do if gu==is(c["spacefueltank_"..jA].getWidgetData()).name then jz=jA;break end end;local vD={iB[dH],string.sub(gu,1,12),vs,vC,vr,jB,jz}ci[#ci+1]=vD end end end;if not cL then b7,aY=false,false end end;local function vE()if gyro~=nil then ce=gyro.isActive()==1 end;if not bz then iv:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then uf(1)else uf(0)end;if door and(ca or not ca and cc<10000)then for dM,dt in pairs(door)do dt.toggle()end end;if switch then for dM,dt in pairs(switch)do dt.toggle()end end;if forcefield and(ca or not ca==0 and cc<10000)then for dM,dt in pairs(forcefield)do dt.toggle()end end;if antigrav then cM=antigrav.isActive()==1;if cM and not q then antigrav.showWidget()end end;if iu()==1 and k then u_.freeze(1)else u_.freeze(0)end;if bR then if c9~=-1 and not cM then d.control.deployLandingGears()else d.control.retractLandingGears()end end;bk=d.control.isAnyLandingGearDeployed()==1 or c9~=-1 and c9-3<Y;if c9~=-1 or not ca and cF:len()<50 then aZ="Startup"else aZ=false end;iv:setTargetGroundAltitude(v2)pn=ca end;local function vF()local vG={}local function vH()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local vI={[1]=4480,[6]=4480,[7]=6270,[27]=8437}local vJ={[1]=8041,[2]=6263,[3]=39281,[4]=10881,[5]=78382,[6]=8761,[7]=11616,[8]=6272,[9]=10891,[26]=7791,[27]=15554,[100]=12511,[110]=7792,[120]=11766}for vK,vL in pairs(e)do e[vK][0]=vH()e[vK][0].systemId=vK;vG[vK]={}for vM,kq in pairs(e[vK])do kq.gravity=kq.gravity/9.8;kq.center=vec3(kq.center)kq.name=kq.name[1]kq.noAtmosphericDensityAltitude=vJ[kq.id]or kq.atmosphereThickness or kq.atmosphereRadius-kq.radius;kq.spaceEngineMinAltitude=vI[kq.id]or 0.68377*kq.atmosphereThickness;kq.planetarySystemId=vK;kq.bodyId=kq.id;vG[vK][vM]=kq;if my==nil or kq.center.x<my then my=kq.center.x end;if mx==nil or kq.center.x>mx then mx=kq.center.x end;if mB==nil or kq.center.y<mB then mB=kq.center.y end;if mA==nil or kq.center.y>mA then mA=kq.center.y end;if kq.center and kq.name~="Space"then d0[#d0+1]=kq end end end;ea=df(d,b,c,a,dg,dh,di,dj,dk)ck=ea(vG)cl=eU(d,b,c,a,dj,eV)cm=fn(d,b,c,a,dg,dh,di,dj,dk)co=fN(d,b,c,a,dbHud_1,e,fO,fP,bI,di,dj,fQ,fR)kq=ck[0]:closestBody(bK.getWorldPosition())end;vN=false;vO=coroutine.create(function()iv:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})vl()coroutine.yield()vp()coroutine.yield()cp=pF(d,b,c,e,vBooster,hover,pG,antigrav,warpdrive,dbHud_1,eV,bI,bJ,iu,eQ,bH,dh,iv,fO,iw,dj,fR,fQ,ix,dk,iz,iA,pH,is,dg,fP)vE()coroutine.yield()vF()if radar_1 then cq=gH(b,a,c,library,radar_1,radar_2,eV,gJ,dj,gK,di,gL,fQ)end;if iq then cn=iq(d,b,c,a,e,antigrav,hover,shield,warpdrive,ir,eV,bI,dg,is,bJ,it,iu,eQ,bH,dh,iv,fP,fO,gJ,iw,dj,fR,gK,fQ,ix,iy,iz,iA,iB,iC)end;if cn then cn.ButtonSetup()end;cr=ud(d,b,c,a,e,vBooster,hover,antigrav,shield,dbHud_2,gyro,ue,iu,iv,iw,uf,gJ,fR,e0,di,dh,fQ,iy,pH)if shield then cs=i8(shield,e0,bI)end;coroutine.yield()c.hideWidget()a.showScreen(1)a.showHelper(0)if ue then ue.clear()end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)if radar_1 then c.setTimer("radarTick",0.0166667)end;c.setTimer("hudTick",aR)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)if shield then c.setTimer("shieldTick",0.0166667)end;if vP then vQ.ExtraOnStart()end;fQ("start","SU")end)coroutine.resume(vO)end;function v0.onUpdate()if not vN then local i0=coroutine.status(vO)if i0=="suspended"then local dI,i1=coroutine.resume(vO)if i1 then a.print("ERROR STARTUP: "..i1)end elseif i0=="dead"then vN=true end end;if vN then d:update()if ca and t and cN then if cN and bQ then cp.cmdThrottle(0)bQ=false elseif not cN and not bQ then bM=0;bQ=true end end;if d3 then iv:setThrottleCommand(axisCommandId.longitudinal,d3)d3=nil end;if not ct and pb~=vR then a.setScreen(pb)end;vR=pb;if vP then vQ.ExtraOnUpdate()end end end;function v0.onFlush()if vN then cp.onFlush()if vP then vQ.ExtraOnFlush()end end end;function v0.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(cb>0 or cb==0 and cc<10000)then for dM,dt in pairs(door)do dt.toggle()end end;if switch then for dM,dt in pairs(switch)do dt.toggle()end end;if forcefield and(cb>0 or cb==0 and cc<10000)then for dM,dt in pairs(forcefield)do dt.toggle()end end;w=d2;pH()if o6 then o6.activate()end;if z then cp.showWayPoint(kq,cK)end;if cn then a.print(cn.FuelUsed("atmofueltank")..", "..cn.FuelUsed("spacefueltank")..", "..cn.FuelUsed("rocketfueltank"))end;if vP then vQ.ExtraOnStop()end;fQ("stop","SU")end;function v0.controlStart(uo)if vN then cr.startControl(uo)end end;function v0.controlStop(uo)if vN then cr.stopControl(uo)end end;function v0.controlLoop(uo)if vN then cr.loopControl(uo)end end;function v0.controlInput(re)if vN then cr.inputTextControl(re)end end;function v0.radarEnter(dR)if cq then cq.onEnter(dR)end end;function v0.radarLeave(dR)if cq then cq.onLeave(dR)end end;function v0.onTick(vS)if vS=="tenthSecond"then cp.TenthTick()if cn then cn.TenthTick()end elseif vS=="oneSecond"then if cn then cn.OneSecondTick()end elseif vS=="fiveSecond"then cp.SatNavTick()elseif vS=="msgTick"then if cn then cn.MsgTick()end elseif vS=="animateTick"then if cn then cn.AnimateTick()end elseif vS=="hudTick"then if cn then cn.hudtick()end elseif vS=="apTick"then cp.APTick()elseif vS=="shieldTick"then cs.shieldTick()elseif vS=="tagTick"then cr.tagTick()elseif vS=="contact"then cq.ContactTick()end end;if vP then for dH,dt in pairs(vP)do v0[dH]=dt end end;return v0 end;function script.onStart()vQ.onStart()end;function script.onOnStop()vQ.onStop()end;function script.onTick(vS)vQ.onTick(vS)end;function script.onOnFlush()vQ.onFlush()end;function script.onOnUpdate()vQ.onUpdate()end;function script.onActionStart(uo)vQ.controlStart(uo)end;function script.onActionStop(uo)vQ.controlStop(uo)end;function script.onActionLoop(uo)vQ.controlLoop(uo)end;function script.onInputText(re)vQ.controlInput(re)end;function script.onEnter(dR)vQ.radarEnter(dR)end;function script.onLeave(dR)vQ.radarLeave(dR)end;bG(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)vQ=uZ(d,core,unit,e,vBooster,hover,pG,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,ir,ue)script.onStart()
        MaxGameVelocity = -1.00 --export: (Default: -1.00) Max speed for your autopilot in m/s.  If -1 then when you sit down it will set to actual max speed.
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
