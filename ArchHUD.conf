name: ArchHud - Archaegeo v0.710 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
  screenHud:
    class: ScreenUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        __wrap_lua__showErrorOnScreens=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__showErrorOnScreens then for _,c in pairs(b) do if type(c)=="table" and c.setCenteredText and c.setHTML then if a:match("\n") then c.setHTML([[<pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]]..a..[[</pre>]]) else c.setCenteredText(a) end end end end if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)local e=require("atlas")script={}VERSION_NUMBER=0.710;f=false;g="virtual joystick"h="archHUD"i=true;j=true;k=false;l=false;m=false;n=false;o=false;p=false;q=false;r=false;s=false;t=false;u=true;v=false;w=true;x=true;y=true;z=true;A=false;B=false;C=true;D=true;E=true;F=true;G=true;H=true;I=true;J=false;K={userControlScheme={set=function(L)g=L end,get=function()return g end},soundFolder={set=function(L)h=L end,get=function()return h end},freeLookToggle={set=function(L)i=L end,get=function()return i end},BrakeToggleDefault={set=function(L)j=L end,get=function()return j end},RemoteFreeze={set=function(L)k=L end,get=function()return k end},brightHud={set=function(L)m=L end,get=function()return m end},RemoteHud={set=function(L)l=L end,get=function()return l end},VanillaRockets={set=function(L)n=L end,get=function()return n end},InvertMouse={set=function(L)o=L end,get=function()return o end},autoRollPreference={set=function(L)p=L end,get=function()return p end},ExternalAGG={set=function(L)q=L end,get=function()return q end},UseSatNav={set=function(L)r=L end,get=function()return r end},ShouldCheckDamage={set=function(L)s=L end,get=function()return s end},CalculateBrakeLandingSpeed={set=function(L)t=L end,get=function()return t end},AtmoSpeedAssist={set=function(L)u=L end,get=function()return u end},ForceAlignment={set=function(L)v=L end,get=function()return v end},DisplayDeadZone={set=function(L)w=L end,get=function()return w end},showHud={set=function(L)x=L end,get=function()return x end},hideHudOnToggleWidgets={set=function(L)y=L end,get=function()return y end},ShiftShowsRemoteButtons={set=function(L)z=L end,get=function()return z end},SetWaypointOnExit={set=function(L)A=L end,get=function()return A end},AlwaysVSpd={set=function(L)B=L end,get=function()return B end},BarFuelDisplay={set=function(L)C=L end,get=function()return C end},voices={set=function(L)D=L end,get=function()return D end},alerts={set=function(L)E=L end,get=function()return E end},CollisionSystem={set=function(L)F=L end,get=function()return F end},AutoShieldToggle={set=function(L)G=L end,get=function()return G end},PreventPvP={set=function(L)H=L end,get=function()return H end},DisplayOdometer={set=function(L)I=L end,get=function()return I end},PrivateLocations={set=function(L)J=L end,get=function()return J end}}M=35;N=35;O=30;P=30;Q=-30;R=0;S=5000;T=1.2;U=2000;V=1050;W=30000;X=1000;Y=50;Z=0;_=100000;a0=8333.00;a1=1.0;a2=32;a3=0;a4=0;a5=0;a6=0;a7=0;a8={YawStallAngle={set=function(L)M=L end,get=function()return M end},PitchStallAngle={set=function(L)N=L end,get=function()return N end},brakeLandingRate={set=function(L)O=L end,get=function()return O end},MaxPitch={set=function(L)P=L end,get=function()return P end},ReEntryPitch={set=function(L)Q=L end,get=function()return Q end},LockPitchTarget={set=function(L)R=L end,get=function()return R end},AutopilotSpaceDistance={set=function(L)S=L end,get=function()return S end},TargetOrbitRadius={set=function(L)T=L end,get=function()return T end},LowOrbitHeight={set=function(L)U=L end,get=function()return U end},AtmoSpeedLimit={set=function(L)V=L end,get=function()return V end},SpaceSpeedLimit={set=function(L)W=L end,get=function()return W end},AutoTakeoffAltitude={set=function(L)X=L end,get=function()return X end},TargetHoverHeight={set=function(L)Y=L end,get=function()return Y end},LandingGearGroundHeight={set=function(L)Z=L end,get=function()return Z end},ReEntryHeight={set=function(L)_=L end,get=function()return _ end},MaxGameVelocity={set=function(L)a0=L end,get=function()return a0 end},AutopilotInterplanetaryThrottle={set=function(L)a1=L end,get=function()return a1 end},warmup={set=function(L)a2=L end,get=function()return a2 end},fuelTankHandlingAtmo={set=function(L)a3=L end,get=function()return a3 end},fuelTankHandlingSpace={set=function(L)a4=L end,get=function()return a4 end},fuelTankHandlingRocket={set=function(L)a5=L end,get=function()return a5 end},ContainerOptimization={set=function(L)a6=L end,get=function()return a6 end},FuelTankOptimization={set=function(L)a7=L end,get=function()return a7 end}}a9=1920;aa=1080;ab=400;ac=130;ad=224;ae=255;af=255;ag=0;ah=0;ai=960;aj=540;ak=1300;al=540;am=1525;an=325;ao=550;ap=540;aq=30;ar=700;as=1750;at=250;au=50;av=250;aw=0;ax=30;ay=100;az={ResolutionX={set=function(L)a9=L end,get=function()return a9 end},ResolutionY={set=function(L)aa=L end,get=function()return aa end},circleRad={set=function(L)ab=L end,get=function()return ab end},SafeR={set=function(L)ac=L end,get=function()return ac end},SafeG={set=function(L)ad=L end,get=function()return ad end},SafeB={set=function(L)ae=L end,get=function()return ae end},PvPR={set=function(L)af=L end,get=function()return af end},PvPG={set=function(L)ag=L end,get=function()return ag end},PvPB={set=function(L)ah=L end,get=function()return ah end},centerX={set=function(L)ai=L end,get=function()return ai end},centerY={set=function(L)aj=L end,get=function()return aj end},throtPosX={set=function(L)ak=L end,get=function()return ak end},throtPosY={set=function(L)al=L end,get=function()return al end},vSpdMeterX={set=function(L)am=L end,get=function()return am end},vSpdMeterY={set=function(L)an=L end,get=function()return an end},altMeterX={set=function(L)ao=L end,get=function()return ao end},altMeterY={set=function(L)ap=L end,get=function()return ap end},fuelX={set=function(L)aq=L end,get=function()return aq end},fuelY={set=function(L)ar=L end,get=function()return ar end},shieldX={set=function(L)as=L end,get=function()return as end},shieldY={set=function(L)at=L end,get=function()return at end},DeadZone={set=function(L)au=L end,get=function()return au end},OrbitMapSize={set=function(L)av=L end,get=function()return av end},OrbitMapX={set=function(L)aw=L end,get=function()return aw end},OrbitMapY={set=function(L)ax=L end,get=function()return ax end},soundVolume={set=function(L)ay=L end,get=function()return ay end}}aA=5;aB=1;aC=0.003;aD=0.003;aE=2;aF=1.5;aG=180;aH=150;aI=0.002;aJ=2;aK=0.8;aL=1;aM=3;aN=1;aO=40;aP=0.0166667;aQ=0.0666667;aR="none"aS="none"aT="none"aU={speedChangeLarge={set=function(L)aA=L end,get=function()return aA end},speedChangeSmall={set=function(L)aB=L end,get=function()return aB end},MouseXSensitivity={set=function(L)aC=L end,get=function()return aC end},MouseYSensitivity={set=function(L)aD=L end,get=function()return aD end},autoRollFactor={set=function(L)aE=L end,get=function()return aE end},rollSpeedFactor={set=function(L)aF=L end,get=function()return aF end},autoRollRollThreshold={set=function(L)aG=L end,get=function()return aG end},minRollVelocity={set=function(L)aH=L end,get=function()return aH end},TrajectoryAlignmentStrength={set=function(L)aI=L end,get=function()return aI end},torqueFactor={set=function(L)aJ=L end,get=function()return aJ end},pitchSpeedFactor={set=function(L)aK=L end,get=function()return aK end},yawSpeedFactor={set=function(L)aL=L end,get=function()return aL end},brakeSpeedFactor={set=function(L)aM=L end,get=function()return aM end},brakeFlatFactor={set=function(L)aN=L end,get=function()return aN end},DampingMultiplier={set=function(L)aO=L end,get=function()return aO end},apTickRate={set=function(L)aP=L end,get=function()return aP end},hudTickRate={set=function(L)aQ=L end,get=function()return aQ end},ExtraLongitudeTags={set=function(L)aR=L end,get=function()return aR end},ExtraLateralTags={set=function(L)aS=L end,get=function()return aS end},ExtraVerticalTags={set=function(L)aT=L end,get=function()return aT end}}aV=j;aW=false;aX=false;aY=false;aZ=false;a_=false;b0=false;b1=false;b2=false;b3=false;b4=false;b5=false;b6=1000;b7=false;b8=false;b9=false;ba=false;bb=0;bc="Aligning"bd=0;be=1;bf="None"bg=nil;bh=0;bi=nil;bj=0.0;bk=0;bl={}bm=false;bn=0;bo=0;bp=nil;bq=0;br=1000;bs=0;bt=false;bu=0;bv=false;bw="All"bx=true;by="Off"bz=0.000;bA={}bB={VertTakeOff={set=function(L)b5=L end,get=function()return b5 end},VertTakeOffEngine={set=function(L)aW=L end,get=function()return aW end},SpaceTarget={set=function(L)bt=L end,get=function()return bt end},BrakeToggleStatus={set=function(L)aV=L end,get=function()return aV end},BrakeIsOn={set=function(L)aX=L end,get=function()return aX end},RetrogradeIsOn={set=function(L)aY=L end,get=function()return aY end},ProgradeIsOn={set=function(L)aZ=L end,get=function()return aZ end},Autopilot={set=function(L)a_=L end,get=function()return a_ end},TurnBurn={set=function(L)b0=L end,get=function()return b0 end},AltitudeHold={set=function(L)b1=L end,get=function()return b1 end},BrakeLanding={set=function(L)b2=L end,get=function()return b2 end},Reentry={set=function(L)b4=L end,get=function()return b4 end},AutoTakeoff={set=function(L)b3=L end,get=function()return b3 end},HoldAltitude={set=function(L)b6=L end,get=function()return b6 end},AutopilotAccelerating={set=function(L)b7=L end,get=function()return b7 end},AutopilotBraking={set=function(L)b9=L end,get=function()return b9 end},AutopilotCruising={set=function(L)ba=L end,get=function()return ba end},AutopilotRealigned={set=function(L)b8=L end,get=function()return b8 end},AutopilotEndSpeed={set=function(L)bb=L end,get=function()return bb end},AutopilotStatus={set=function(L)bc=L end,get=function()return bc end},AutopilotPlanetGravity={set=function(L)bd=L end,get=function()return bd end},PrevViewLock={set=function(L)be=L end,get=function()return be end},AutopilotTargetName={set=function(L)bf=L end,get=function()return bf end},AutopilotTargetCoords={set=function(L)bg=L end,get=function()return bg end},AutopilotTargetIndex={set=function(L)bh=L end,get=function()return bh end},TotalDistanceTravelled={set=function(L)bj=L end,get=function()return bj end},TotalFlightTime={set=function(L)bk=L end,get=function()return bk end},SavedLocations={set=function(L)bl=L end,get=function()return bl end},VectorToTarget={set=function(L)bm=L end,get=function()return bm end},LocationIndex={set=function(L)bn=L end,get=function()return bn end},LastMaxBrake={set=function(L)bo=L end,get=function()return bo end},LockPitch={set=function(L)bp=L end,get=function()return bp end},LastMaxBrakeInAtmo={set=function(L)bq=L end,get=function()return bq end},AntigravTargetAltitude={set=function(L)br=L end,get=function()return br end},LastStartTime={set=function(L)bs=L end,get=function()return bs end},iphCondition={set=function(L)bw=L end,get=function()return bw end},stablized={set=function(L)bx=L end,get=function()return bx end},UseExtra={set=function(L)by=L end,get=function()return by end},SelectedTab={set=function(L)bC=L end,get=function()return bC end},saveRoute={set=function(L)bA=L end,get=function()return bA end}}local function bD(a,b,c,bE,bF,bG)bH=bE()bI=ac;bJ=ae;bK=ad;bL=0;bM=0;bN=false;bO=0;bP=false;bQ=false;bR=false;bS=false;bT=0;bU=0;bV=0;bW=0;bX=0;bY=0;bZ=0;b_=false;c0=false;b_=false;c0=false;c1="empty"c2=false;c3=0;c4=0;c5=nil;c6=0;c7=0;c8=0;c9=0;ca=0;cb=3;cc=0;cd=""ce=false;cf=false;cg=false;ch=-1;ci=bG()>0;cj=bG()ck=b.getAltitude()cl=bE()cm=b.getConstructMass()cn=false;co=nil;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]cr=a9;cs=aa;ct={}cu={}cv={}cw=false;cx=nil;cy=nil;cz=nil;cA=nil;cB=nil;cC=nil;cD=nil;cE=nil;cF=nil;cG=false;cH=false;cI=p;cJ=false;cK=0;cL=V;cM=0;cN=nil;cO={VectorToTarget=false}cP=0;cQ=false;cR=false;cS=false;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cW=vec3(b.getVelocity())cX=vec3(b.getWorldVelocity())cY=vec3(cX):len()cZ=vec3(b.getWorldVertical())c_=-cZ:dot(cX)d0=vec3(b.getConstructWorldPos())d1=false;d2=false;d3=nil;d4=true;d5=0;d6=0;d7={}d8=false;d9=50000;da=nil;db={}dc=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;dd=false;de=nil;df=false;dg=0;dh=nil;di=nil;dj={}dk=90;dl=x;dm=nil;dn=nil end;local function dp(d,b,c,a,dq,dr,ds,dt,du)local function dv(dw)return type(dw)=='number'end;local function dx(dw)return type(ds(dw))=='number'end;local function dy(dz)return type(dz)=='table'end;local function dA(a)return type(a)=='string'end;local function dB(dC)return dy(dC)and dv(dC.x and dC.y and dC.z)end;local function dD(dE)return dy(dE)and dv(dE.latitude and dE.longitude and dE.altitude and dE.id and dE.systemId)end;local dF=math.pi/180;local dG=180/math.pi;local dH=1e-10;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function dK(dw)local dL=string.gsub(string.reverse(dq('%.4f',dw)),'^0*%.?','')return dL==''and'0'or string.reverse(dL)end;local function dM(dN)if dB(dN)then return dq('{x=%.3f,y=%.3f,z=%.3f}',dN.x,dN.y,dN.z)end;if dy(dN)and not getmetatable(dN)then local dO={}local dP=next(dN)if type(dP)=='nil'or dP==1 then dO=dN else for dQ,dC in pairs(dN)do local dR=dM(dC)if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end end;return dq('{%s}',table.concat(dO,','))end;if dA(dN)then return dq("'%s'",dN:gsub("'",[[\']]))end;return tostring(dN)end;local dS={}dS.__index=dS;dS.__tostring=function(dN,dT)local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)local dO={}for dV,dQ in ipairs(dU)do local dR=dM(dN[dQ])if type(dQ)=='number'then table.insert(dO,dq('[%s]=%s',dQ,dR))else table.insert(dO,dq('%s=%s',dQ,dR))end end;if dT then return dq('%s%s',dT,table.concat(dO,',\n'..dT))end;return dq('{%s}',table.concat(dO,','))end;dS.__eq=function(dW,dX)return dW.systemId==dX.systemId and dW.id==dX.id and du(dW.radius,dX.radius)and du(dW.center.x,dX.center.x)and du(dW.center.y,dX.center.y)and du(dW.center.z,dX.center.z)and du(dW.GM,dX.GM)end;local function dY(dZ,d_,e0,e1,e2)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e0),'Argument 3 (radius) must be a number:'..type(e0))assert(dy(e1),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(e1))assert(dx(e2),'Argument 5 (GM) must be a number:'..type(e2))return setmetatable({systemId=ds(dZ),id=ds(d_),radius=ds(e0),center=vec3(e1),GM=ds(e2)},dS)end;local e3={}e3.__index=e3;e3.__tostring=function(e4)return dq('::pos{%d,%d,%s,%s,%s}',e4.systemId,e4.id,dK(e4.latitude*dG),dK(e4.longitude*dG),dK(e4.altitude))end;e3.__eq=function(dW,dX)return dW.id==dX.id and dW.systemId==dX.systemId and du(dW.latitude,dX.latitude)and du(dW.altitude,dX.altitude)and(du(dW.longitude,dX.longitude)or du(dW.latitude,math.pi/2)or du(dW.latitude,-math.pi/2))end;local function e5(e6,d_,e7,e8,e9)local dZ=e6;if dA(e6)and not e8 and not e9 and not d_ and not e7 then dZ,d_,e7,e8,e9=ea(e6,dJ)assert(dZ,'Argument 1 (position string) is malformed.')else assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(e7),'Argument 3 (latitude) must be in degrees:'..type(e7))assert(dx(e8),'Argument 4 (longitude) must be in degrees:'..type(e8))assert(dx(e9),'Argument 5 (altitude) must be in meters:'..type(e9))end;dZ=ds(dZ)d_=ds(d_)e7=ds(e7)e8=ds(e8)e9=ds(e9)if d_==0 then return setmetatable({latitude=e7,longitude=e8,altitude=e9,id=d_,systemId=dZ},e3)end;return setmetatable({latitude=dF*dr(e7,-90,90),longitude=dF*(e8%360),altitude=e9,id=d_,systemId=dZ},e3)end;local eb={}eb.__index=eb;eb.__tostring=function(dN,dT)local ec=dT and dT..'  'local ed={}local dU={}for dQ in pairs(dN)do table.insert(dU,dQ)end;table.sort(dU)for dV,ee in ipairs(dU)do ef=dN[ee]local eg=dS.__tostring(ef,ec)if dT then table.insert(ed,dq('[%s]={\n%s\n%s}',ee,eg,dT))else table.insert(ed,dq('  [%s]=%s',ee,eg))end end;if dT then return dq('\n%s%s%s',dT,table.concat(ed,',\n'..dT),dT)end;return dq('{\n%s\n}',table.concat(ed,',\n'))end;local function eh(ei)local e={}local pid;for dV,dC in pairs(ei)do local d_=dC.planetarySystemId;if type(d_)~='number'then error('Invalid planetary s ID: '..tostring(d_))elseif pid and d_~=pid then error('Mistringmatch planetary s IDs: '..d_..' and '..pid)end;local ej=dC.bodyId;if type(ej)~='number'then error('Invalid body ID: '..tostring(ej))elseif e[ej]then error('Duplicate body ID: '..tostring(ej))end;setmetatable(dC.center,getmetatable(vec3.unit_x))e[ej]=setmetatable(dC,dS)pid=d_ end;return setmetatable(e,eb)end;ek={}local function el(ei)return setmetatable({galaxyAtlas=ei or{}},ek)end;ek.__index=function(dz,L)if type(L)=='number'then local a=dz.galaxyAtlas[L]return eh(a)end;return rawget(ek,L)end;ek.__pairs=function(dN)return function(dz,dQ)local em,en=next(dz,dQ)return em,en and eh(en)end,dN.galaxyAtlas,nil end;ek.__tostring=function(dN)local eo={}for dV,ep in pairs(dN or{})do local eq=ep:getPlanetarySystemId()local er=eb.__tostring(ep,'    ')table.insert(eo,dq('  [%s]={%s\n  }',eq,er))end;return dq('{\n%s\n}\n',table.concat(eo,',\n'))end;ek.BodyParameters=dY;ek.MapPosition=e5;ek.PlanetarySystem=eh;function ek.createBodyParameters(dZ,d_,es,et,eu,ev,ew)assert(dx(dZ),'Argument 1 (systemId) must be a number:'..type(dZ))assert(dx(d_),'Argument 2 (id) must be a number:'..type(d_))assert(dx(es),'Argument 3 (surfaceArea) must be a number:'..type(es))assert(dy(et),'Argument 4 (aPosition) must be an array or vec3:'..type(et))assert(dy(eu),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(eu))assert(dx(ev),'Argument 6 (altitude) must be in meters:'..type(ev))assert(dx(ew),'Argument 7 (gravityAtPosition) must be number:'..type(ew))local e0=dt(es/4/math.pi)local cc=e0+ev;local ex=vec3(et)+cc*vec3(eu)local e2=ew*cc*cc;return dY(dZ,d_,e0,ex,e2)end;ek.isMapPosition=dD;function ek:getPlanetarySystem(e6)if L==nil then L=0 end;if en==nil then en=0 end;local dZ=e6;if dD(e6)then dZ=e6.systemId end;if type(dZ)=='number'then local a=self.galaxyAtlas[L]if a then if getmetatable(en)~=eb then a=eh(a)end;return a end end end;function eb:sizeCalculator(ey)return 1.05*ey.radius end;function eb:castIntersections(ez,eA,eB,eC,eD,eE)local eF={}if eD then for dV,ey in pairs(eD)do table.insert(eF,ey)end else eF=dj end;if not eE then table.sort(eF,function(eG,eH)local eI=eG.center;local eJ=eH.center;return(eI.x-ez.x)^2+(eI.y-ez.y)^2+(eI.z-ez.z)^2<(eJ.x-ez.x)^2+(eJ.y-ez.y)^2+(eJ.z-ez.z)^2 end)end;local eK=eA:normalize()for dV,ey in ipairs(eF)do local eL=ey.center-ez;local e0=self:sizeCalculator(ey)local eM=eL:dot(eK)local eN=eM^2-(eL:len2()-e0^2)if eN>=0 then local eO=dt(eN)local eP=eM+eO;local eQ=eM-eO;if eQ>0 then return ey,eP,eQ elseif eP>0 then return ey,eP,nil end end end;return nil,nil,nil end;function eb:closestBody(eR)assert(type(eR)=='table','Invalid coordinates.')local eS,ey;local eT=vec3(eR)for dV,eU in pairs(self)do local eV=(eU.center-eT):len2()if(not ey or eV<eS)and eU.name~="Space"then ey=eU;eS=eV end end;return ey end;function eb:convertToBodyIdAndWorldCoordinates(e6)local eW=e6;if dA(e6)then eW=e5(e6)end;if eW.id==0 then return 0,vec3(eW.latitude,eW.longitude,eW.altitude)end;local eU=self:getBodyParameters(eW)if eU then return eW.id,eU:convertToWorldCoordinates(eW)end end;function eb:getBodyParameters(e6)local d_=e6;if dD(e6)then d_=e6.id end;assert(dx(d_),'Argument 1 (id) must be a number:'..type(d_))return self[d_]end;function eb:getPlanetarySystemId()local dV,dC=next(self)return dC and dC.systemId end;function dS:convertToMapPosition(e1)assert(dy(e1),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(e1))local eX=vec3(e1)if self.id==0 then return setmetatable({latitude=eX.x,longitude=eX.y,altitude=eX.z,id=0,systemId=self.systemId},e3)end;local eY=eX-self.center;local cc=eY:len()local e9=cc-self.radius;local e7=0;local e8=0;if not du(cc,0)then local eZ=e_(eY.y,eY.x)e8=eZ>=0 and eZ or 2*math.pi+eZ;e7=math.pi/2-math.acos(eY.z/cc)end;return setmetatable({latitude=e7,longitude=e8,altitude=e9,id=self.id,systemId=self.systemId},e3)end;function dS:convertToWorldCoordinates(e6)local eW=dA(e6)and e5(e6)or e6;if eW.id==0 then return vec3(eW.latitude,eW.longitude,eW.altitude)end;assert(dD(eW),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(eW.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(eW.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local f0=math.cos(eW.latitude)return self.center+(self.radius+eW.altitude)*vec3(f0*math.cos(eW.longitude),f0*math.sin(eW.longitude),math.sin(eW.latitude))end;function dS:getAltitude(e1)return(vec3(e1)-self.center):len()-self.radius end;function dS:getDistance(e1)return(vec3(e1)-self.center):len()end;function dS:getGravity(e1)local f1=self.center-vec3(e1)local f2=f1:len2()return self.GM/f2*f1/dt(f2)end;return setmetatable(ek,{__call=function(dV,...)return el(...)end})end;local function f3(d,b,c,a,dt,f4)local cy={}local f5=30000000/3600;local f6=f5*f5;local f7=100;function cy.computeAccelerationTime(f8,f9,fa)local fb=f5*math.asin(f8/f5)return(f5*math.asin(fa/f5)-fb)/f9 end;function cy.computeDistanceAndTime(f8,fa,fc,fd,fe,ff)fe=fe or 0;ff=ff or 0;local fg=f8<=fa;local fh=fd*(fg and 1 or-1)/fc;local fi=-ff/fc;local fj=fh+fi;if fg and fj<=0 or not fg and fj>=0 then return-1,-1 end;local fk,fl=0,0;if fh~=0 and fe>0 then local fb=math.asin(f8/f5)local fm=math.pi*(fh/2+fi)local fn=fh*fe;local fo=f5*math.pi;local dC=function(dz)local fp=(fm*dz-fn*math.sin(math.pi*dz/2/fe)+fo*fb)/fo;local fq=math.tan(fp)return f5*fq/dt(fq*fq+1)end;local fr=fg and function(a)return a>=fa end or function(a)return a<=fa end;fl=2*fe;if fr(dC(fl))then local fs=0;while f4(fl-fs)>0.5 do local dz=(fl+fs)/2;if fr(dC(dz))then fl=dz else fs=dz end end end;local ft=f8;local fu=fl/f7;for fv=1,f7 do local fw=dC(fv*fu)fk=fk+(fw+ft)*fu/2;ft=fw end;if fl<2*fe then return fk,fl end;f8=ft end;local fb=f5*math.asin(f8/f5)local bH=(f5*math.asin(fa/f5)-fb)/fj;local fx=f6*math.cos(fb/f5)/fj;local cc=fx-f6*math.cos((fj*bH+fb)/f5)/fj;return cc+fk,bH+fl end;function cy.computeTravelTime(f8,f9,cc)if cc==0 then return 0 end;if f9>0 then local fb=f5*math.asin(f8/f5)local fx=f6*math.cos(fb/f5)/f9;return(f5*math.acos(f9*(fx-cc)/f6)-fb)/f9 end;if f8==0 then return-1 end;assert(f8>0,'Acceleration and initial speed are both zero.')return cc/f8 end;return cy end;local function fy(d,b,c,a,dq,dr,ds,dt,du)local vec3=require('cpml.vec3')local dp=dp(d,b,c,a,dq,dr,ds,dt,du)local function dA(a)return type(a)=='string'end;local function dy(dz)return type(dz)=='table'end;fz={}fz.__index=fz;function fz:escapeAndOrbitalSpeed(e9)assert(self.body)local cc=e9+self.body.radius;if not du(cc,0)then local fA=dt(self.body.GM/cc)return dt(2)*fA,fA end;return nil,nil end;function fz:orbitalParameters(e6,fB)assert(self.body)assert(dy(e6)or dA(e6))assert(dy(fB))local fC=(dA(e6)or dp.isMapPosition(e6))and self.body:convertToWorldCoordinates(e6)or vec3(e6)local dC=vec3(fB)local fD=fC-self.body.center;local fE=dC:len2()local fF=fD:len()local fG=self.body.GM;local fH=((fE-fG/fF)*fD-fD:dot(dC)*dC)/fG;local eI=fG/(2*fG/fF-fE)local fI=fH:len()local eK=fH:normalize()local fJ=eI*(1-fI)local fK=eI*(1+fI)local fL=fJ*eK+self.body.center;local fM=fI<=1 and-fK*eK+self.body.center or nil;local fN=dt(eI*fG*(1-fI*fI))local fO=fM and 2*math.pi*dt(eI^3/fG)local fP=math.acos(fH:dot(fD)/(fI*fF))if fD:dot(dC)<0 then fP=-(fP-2*math.pi)end;local fQ=math.acos((math.cos(fP)+fI)/(1+fI*math.cos(fP)))local fR=fQ;if fR<0 then fR=fR+2*math.pi end;local fS=fR-fI*math.sin(fR)local fT=0;local fU=0;local fV=0;if fO~=nil then fT=fS/(2*math.pi/fO)fU=fO-fT;fV=fU+fO/2;if fP-math.pi>0 then fU=fT;fV=fU+fO/2 end;if fV>fO then fV=fV-fO end end;return{periapsis={position=fL,speed=fN/fJ,circularOrbitSpeed=dt(fG/fJ),altitude=fJ-self.body.radius},apoapsis=fM and{position=fM,speed=fN/fK,circularOrbitSpeed=dt(fG/fK),altitude=fK-self.body.radius},currentVelocity=dC,currentPosition=fC,eccentricity=fI,period=fO,eccentricAnomaly=fQ,meanAnomaly=fS,timeToPeriapsis=fU,timeToApoapsis=fV,trueAnomaly=fP}end;local function fW(fX)local eU=dp.BodyParameters(fX.systemId,fX.id,fX.radius,fX.center,fX.GM)return setmetatable({body=eU},fz)end;return setmetatable(fz,{__call=function(dV,...)return fW(...)end})end;local function fY(d,b,c,a,dbHud_1,e,fZ,f_,bF,ds,dt,g0)local function g1(g2)local e4=g3:closestBody(g2)if(g2-e4.center):len()>e4.radius+e4.noAtmosphericDensityAltitude then e4=e[0][0]end;return e4 end;local function g4()local function g5(g6,g7)return g6.name<g7.name end;d7={}for dQ,dC in pairs(e[0])do d7[#d7+1]={name=dC.name,index=dQ}end;table.sort(d7,g5)end;local function g8(g9)for dQ,dC in pairs(g9)do if dC.name and dC.name==ga.name then return dQ end end;return-1 end;local function gb()dg=bh;if bh==0 then bf="None"c5=nil;ga=nil;return true end;local gc=d7[bh].index;local gd=e[0][gc]if gd.center then bf=gd.name;c5=cx[0][gc]if ga~=nil then if cj==0 then if fZ(ge,gf)~=1 then f_(ge,gf)end;if fZ(gg,gh)~=1 then f_(gg,gh)end;if fZ(gi,gj)~=1 then f_(gi,gj)end;if fZ(gk,gl)~=1 then f_(gk,gl)end;if fZ(gm,gn)~=1 then f_(gm,gn)end end;if fZ(go,gp)~=1 then f_(go,gp)end;if fZ(gq,gr)~=1 then f_(gq,gr)end;if fZ(gs,gt)~=1 then f_(gs,gt)end end;ga=nil else ga=gd;for dV,dC in pairs(cx[0])do if dC.name==ga.planetname then c5=dC;bf=ga.name;break end end;if fZ(go,gp)~=1 then f_(go,gp)end;if fZ(gq,gr)~=1 then f_(gq,gr)end end;if ga==nil then bg=vec3(c5.center)else bg=ga.position end;if c5.planetname~="Space"then if c5.hasAtmosphere then gu=bF(c5.radius*(T-1)+c5.noAtmosphericDensityAltitude)else gu=bF(c5.radius*(T-1)+c5.surfaceMaxAltitude)end else gu=S end;if ga~=nil and ga.planetname=="Space"then bb=0 else dV,bb=cA(c5):escapeAndOrbitalSpeed(gu)end;bd=0;b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"return true end;local function gv(gw)if not a_ and not bm and not cf and not bv and not b4 and not cg then if gw==nil then bh=bh+1;if bh>#d7 then bh=0 end else bh=bh-1;if bh<0 then bh=#d7 end end;if bh==0 then gb()else local gc=d7[bh].index;local gd=e[0][gc]if gd~=nil and gd.name=="Space"or bw=="Custom Only"and gd.center or bw=="No Moons"and string.find(gd.name,"Moon")~=nil then if gw==nil then gv()else gv(1)end else gb()end end else c1="Disengage autopilot before changing Interplanetary Helper"g0("iph","AP")end end;local function gx()local gy=-1;gy=g8(e[0])if gy>-1 then table.remove(e[0],gy)end;gy=-1;gy=g8(bl)if gy~=-1 then c1=ga.name.." saved location cleared"table.remove(bl,gy)end;gv()g4()end;local function gz(gA,g2,gB,gC)if dbHud_1 or gB then local e4=g1(g2)local gD=e4.gravity;if gC then gD=c.getClosestPlanetInfluence()end;local gE={position=g2,name=gA,planetname=e4.name,gravity=gD,safe=gC}if not gB then bl[#bl+1]=gE else for dQ,dC in pairs(e[0])do if dC.name and gA==dC.name then table.remove(e[0],dQ)end end end;table.insert(e[0],gE)g4()gb()c1="Location saved as "..gA.."("..e4.name..")"else c1="Databank must be installed to save permanent locations"end end;local gF={}function gF.UpdateAtlasLocationsList()g4()end;function gF.UpdateAutopilotTarget()gb()end;function gF.adjustAutopilotTargetIndex(gw)gv(gw)end;function gF.findAtlasIndex(g9)g8(g9)end;function gF.UpdatePosition(gG)local gy=g8(bl)if gy~=-1 then if gG~=nil then bl[gy].name=gG;bh=bh-1;gv()else local gH=bl[gy]gH.gravity=c.getClosestPlanetInfluence()gH.position=d0;gH.safe=true end;c1=bl[gy].name.." position updated ("..bl[gy].planetname..")"else c1="Name Not Found"end end;function gF.AddNewLocation(gA,g2,gB,gC)gz(gA,g2,gB,gC)end;function gF.ClearCurrentPosition()gx()end;for dQ,dC in pairs(bl)do table.insert(e[0],dC)end;g4()if bh>#d7 then bh=0 end;gF.UpdateAutopilotTarget()return gF end;local function gI(b,a,c,library,radar_1,radar_2,f4,gJ,dt,gK,ds,gL,g0)local gM={}local gN={}local gO={XS=13,S=27,M=55,L=110,XL=221}local gP={}local gQ;local gR;local gS;local gT;local gU;local gV={}local gW="Atmo"local gX;local gY;local gZ=0;local function g_()local function h0(h1,h2,h3,h4,h5,h6,h7,h8)h2,h4,h6,h8=vec3(h2),vec3(h4),vec3(h6),vec3(h8)local h9,ha,hb=h1*h1,h3*h3,h5*h5;local fE=h4-h2;local hc=fE:normalize()local hd=fE:len()local he=h6-h2;local hf=(he-he:project_on(hc)):normalize()local hg,hh=he:dot(hc),he:dot(hf)local hi=hg*hg+hh*hh;local hj=hc:cross(hf)local hk=(h9-ha+hd*hd)/(2*hd)local hl=(h9-hb+hi-2*hg*hk)/(2*hh)local dE=h9-hk^2-hl^2;local hm=dt(dE)local hn=h2+hc*hk+hf*hl+hj*hm;local ho=h2+hc*hk+hf*hl-hj*hm;if f4((h8-hn):len()-h7)<f4((h8-ho):len()-h7)then return hn else return ho end end;local function hp()local function hq()local hr=b.getConstructWorldOrientationRight()local fE=b.getConstructWorldOrientationForward()local he=b.getConstructWorldOrientationUp()local hs=library.systemResolution3(hr,fE,he,{1,0,0})local ht=library.systemResolution3(hr,fE,he,{0,1,0})local hu=library.systemResolution3(hr,fE,he,{0,0,1})return function(hv)return library.systemResolution3(hs,ht,hu,hv)end end;local hw=hq()local hx=b.getConstructWorldPos()local fC=b.getElementPositionById(1)local hy={fC[1],fC[2],fC[3]}local hz=hw(hy)local hA={hx[1]-hz[1],hx[2]-hz[2],hx[3]-hz[3]}return hA end;local function hB(hC,fF,hD)local hE=hC.pts;local gy=#hE;local hF=hC.ref;if gy>3 then local hG,hH,hI,hJ=hE[gy],hE[gy-1],hE[gy-2],hE[gy-3]hC.ref=hD;local fC=h0(hG[1],hG[2],hH[1],hH[2],hI[1],hI[2],hJ[1],hJ[2])local hk,hl,hm=fC.x,fC.y,fC.z;if hk==hk and hl==hl and hm==hm then hk=hk+hF[1]hl=hl+hF[2]hm=hm+hF[3]local hK=vec3(hk,hl,hm)if not hC.lastPos then hC.center=hK elseif(hC.lastPos-hK):len()<2 then hC.center=hK;hC.skipCalc=true end;hC.lastPos=hK end;hC.pts={}else local hL={hD[1]-hF[1],hD[2]-hF[2],hD[3]-hF[3]}hE[gy+1]={fF,hL}end end;if radar_1 or radar_2 then cE.assignRadar()end;if gV[1]then gQ=#gV[1].getConstructIds()local hM=gV[1].getData()local hN=hM:gmatch('{"constructId[^}]*}[^}]*}')if gQ>0 then local hD=hp()local hO,hP=0,0;gU,gT=0,0;for dC in hN do local d_,cc,hQ=dC:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local hR=gO[hQ]cc=ds(cc)if gV[1].hasMatchingTransponder(d_)==1 then table.insert(gN,d_)end;local hS=gV[1].getConstructType(d_)if F then if hR>27 or hS=="static"or hS=="space"then gU=gU+1;local gA=gV[1].getConstructName(d_)local hC=db[d_]if hC==nil then hR=hR+gL;db[d_]={pts={},ref=hD,name=gA,i=0,radius=hR,skipCalc=false}hC=db[d_]end;if not hC.skipCalc then hB(hC,cc,hD)hP=hP+1 end;if hC.center then table.insert(gP,hC)end end;hO=hO+1;if dc and hO>700 or hP>70 or(not dc and hO>300 or hP>30)then coroutine.yield()hO,hP=0,0 end end end;gT=#gP;if gT>0 and cY>20 then local ey,hT,hU,hV;local hW=0;local hX=cx:getPlanetarySystem(0)hV=cX:normalize()while hW<gT do coroutine.yield()local hY={table.unpack(gP,hW,math.min(hW+75,gT))}ey,hT,hU=hX:castIntersections(d0,hV,nil,nil,hY,true)if ey and hU then de={ey,hT,hU}break end;hW=hW+75 end;if not ey then de=nil end else de=nil end;gP={}gR=hM:find('identifiedConstructs":%[%]')else gS=hM:find('worksInEnvironment":false')end end end;local function hZ()if gV[1]then gW="Atmo"if gV[1].getData():find('worksInAtmosphere":false')then gW="Space"end end end;function gM.pickType()hZ()end;function gM.assignRadar()if radar_1 and gV[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then gV[1]=radar_2 end;if gV[1]==radar_2 then hZ()end elseif radar_2 and gV[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then gV[1]=radar_1 end;if gV[1]==radar_1 then hZ()end end end;function gM.UpdateRadar()local h_=coroutine.status(gX)if h_=="suspended"then local dR,i0=coroutine.resume(gX)if i0 then a.print("ERROR UPDATE RADAR: "..i0)end elseif h_=="dead"then gX=coroutine.create(g_)local dR,i0=coroutine.resume(gX)end end;function gM.GetRadarHud(i1,i2,i3,i4)local i5=gN;local i6,i7;gN={}local dI=gT or 0;if gQ>0 then if F then i7=dI.."/"..gU.." Plotted : "..gQ-gU.." Ignored"else i7="Radar Contacts: "..gQ end;i6=gK(i3,i4,i7,"pbright txtbig txtmid")if#gN>0 then i6=i6 ..gK(i1,i2,"Friendlies In Range","pbright txtbig txtmid")for dQ,dC in pairs(gN)do i2=i2+20;i6=i6 ..gK(i1,i2,gV[1].getConstructName(dC),"pdim txtmid")end end;if gR==nil and gY==nil then gZ=1;cE.ToggleRadarPanel()end;if gR~=nil and gY~=nil then cE.ToggleRadarPanel()end;if dn==nil then cE.ToggleRadarPanel()end else if gS then i6=gK(i3,i4,gW.." Radar: Jammed","pbright txtbig txtmid")else i6=gK(i3,i4,"Radar: No "..gW.." Contacts","pbright txtbig txtmid")end;if dn~=nil then gZ=0;cE.ToggleRadarPanel()end end;return i6 end;function gM.GetClosestName(gA)if gV[1]then local d_,dV=gV[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if d_~=nil and d_~=""then gA=gA.." "..gV[1].getConstructName(d_)end end;return gA end;function gM.ToggleRadarPanel()if dn~=nil and gZ==0 then gJ(dn)dn=nil;if gY~=nil then gJ(gY)gY=nil end else if gZ==1 then gJ(dn)dn=nil;_autoconf.displayCategoryPanel(gV,1,"Periscope","periscope")gY=_autoconf.panels[_autoconf.panels_size]end;if dn==nil then _autoconf.displayCategoryPanel(gV,1,"Radar","radar")dn=_autoconf.panels[_autoconf.panels_size]end;gZ=0 end end;function gM.ContactTick()if not i8 then i8=0 end;if bH>i8+10 then c1="Radar Contact"g0("rdrCon","RC")i8=bH end;c.stopTimer("contact")end;function gM.onEnter(d_)if radar_1 and not ci and not d8 then c.setTimer("contact",0.1)end end;function gM.onLeave(d_)if radar_1 and F then if#db>650 then d_=tostring(d_)db[d_]=nil end end end;gV[1]=nil;if radar_1 then gV[1]=radar_1;hZ()end;gX=coroutine.create(g_)return gM end;local function i9(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ia,warpdrive,ib,f4,bF,dq,ic,bG,id,ie,e_,bE,dr,ig,f_,fZ,gJ,ih,dt,ii,gK,g0,ij,ik,il,im,io,ip)local iq=9.80665;local ir={}local is={}local it={}local iu={}local iv=nil;local iw=nil;local ix=nil;local iy=false;local iz="none"local iA=""local iB=55;local iC=0;local iD=0;local iE=""local iF=nil;local iG=vec3({13771471,7435803,-128971})local iH=18000000;local iI=500000;local iJ,iK=math.huge;local iL;local function iM(iN)iJ=vec3(iN):dist(iG)if iJ<iH then return true,f4(iJ-iH)end;iK=vec3(iN):dist(vec3(iO.center))if iK<iI then iL=true else iL=false end;if f4(iK-iI)<f4(iJ-iH)then return iL,f4(iK-iI)else return iL,f4(iJ-iH)end end;local function iP(dC)if cr==1920 then return dC else return ii(cr*dC/1920,0)end end;local function iQ(dC)if cs==1080 then return dC else return ii(cs*dC/1080,0)end end;local function iR()return ih()==0 and g~="keyboard"and ie()==0 end;local function iS()local iT="TRAVEL"if not d4 then iT="CRUISE"end;if a_ then iT="AUTOPILOT"end;return iT end;local i6=""local iU=""local iV=""local iW=1;local iX=2;local iY=3;local iZ=4;local i_=5;local j0=6;local j1=""local j2=0;local j3=bF(1/aP)*2*aQ;local j4={}local j5={}local j6={}local j7={}local j8={}local j9={}local ja={}ja["atmofueltank"],ja["spacefueltank"],ja["rocketfueltank"]=0,0,0;local jb=0;local function jc(hk,jd,je,jf,jg,jh)local ji=jb;local jj=jb+5;if not C then jj=jj+5 end;if ie()==1 and not l then ji=ji-50;jj=jj-50 end;if je=="ATMO"then j1="atmofueltank"elseif je=="SPACE"then j1="spacefueltank"else j1="rocketfueltank"end;j2=_G[j1 .."_size"]if#jf>0 then for L=1,#jf do local gA=string.sub(jf[L][iX],1,12)local jk=0;for jl=1,j2 do if jf[L][iX]==ic(c[j1 .."_"..jl].getData()).name then jk=jl;break end end;local jm=bE()if jg[L]==nil or jh[L]==nil or jm-jf[L][j0]>j3 then local jn;local jo=0;jo=id(jf[L][iW])-jf[L][iZ]jn=jf[L][i_]if jn>jo then jf[L][j0]=jm;ja[j1]=ja[j1]+jn-jo end;jf[L][i_]=jo;if jk~=0 then jh[L]=ic(c[j1 .."_"..jk].getData()).percentage;jg[L]=ic(c[j1 .."_"..jk].getData()).timeLeft;if jg[L]=="n/a"then jg[L]=0 end else jh[L]=bF(0.5+jo*100/jf[L][iY])if jn<=jo then jg[L]=0 else jg[L]=bF(0.5+jo/((jn-jo)/(jm-jf[L][j0])))end end end;if gA==jd then gA=dq("%s %d",je,L)end;if jk==0 then gA=gA.." *"end;local jp;if jg[L]==0 then jp=""else jp=im(jg[L])end;if jh[L]~=nil then local jq=bF(jh[L]*2.55)local jr=dq("rgb(%d,%d,%d)",255-jq,jq,0)local js=""if jp~=""and jg[L]<120 or jh[L]<5 then js="red "end;local jt=dq("rgb(%d,%d,%d)",dr(bF((255-jq)/2.55),50,100),dr(bF(jq/2.55),0,50),50)local ju="rgb(196,0,255)"if je=="ATMO"then ju="rgb(0,188,255)"elseif je=="SPACE"then ju="rgb(239,255,0)"end;local jv=false;if jw~=ju then jv=true end;jw=ju;if C then if jv then ji=ji-5;jj=jj-5 end;iU=iU..dq([[
                                            <g class="pdim">                        
                                            <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                            </g>]],jt,ju,hk,jj,jr,bF(jh[L]*1.7+0.5)-2,hk+1,jj+1,hk+5,jj+14,gA,jh[L],jp)ji=ji-22;jj=jj-22 else iU=iU..gK(hk,ji,gA,js.."pdim txtfuel")iU=iU..gK(hk,jj,dq("%d%% %s",jh[L],jp),"pdim txtfuel","fill:"..jr)ji=ji+30;jj=jj+30 end end end end;jb=ji end;local function jx(jy,e9)if am==0 and an==0 then return end;if e9<200000 and not ci or e9 and ci then local jz=0;if f4(c_)>1 then jz=45*math.log(f4(c_),10)if c_<0 then jz=-jz end end;jy[#jy+1]=dq([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],am,an,bF(c_),bF(jz))end;return jy end;local function jA(jB)local gw=-cZ;jB=jB-jB:project_on(gw)local jC=vec3(0,0,1)jC=jC-jC:project_on(gw)local jD=jC:cross(gw)local jz=jC:angle_between(jB)*constants.rad2deg;if jB:dot(jD)<0 then jz=360-jz end;return jz end;local function jE(jy,ai,aj,jF,jG,dc)if ab==0 then return end;local jH=ab;local jI=20;local jJ=bF(jF)if dc then for L=-45,45,5 do local jK=L;jy[#jy+1]=dq([[<g transform="rotate(%f,%d,%d)">]],jK,ai,aj)jL=5;if L%15==0 then jL=15 elseif L%10==0 then jL=10 end;jy[#jy+1]=dq([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],ai,aj+jH+jI-jL,ai,aj+jH+jI)end;jy[#jy+1]=gK(ai,aj+jH+jI-35,jG,"pdim txt txtmid")jy[#jy+1]=gK(ai,aj+jH+jI-25,jJ.." deg","pdim txt txtmid")jy[#jy+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jF,ai,aj)jy[#jy+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/>]],ai-5,aj+jH+jI-20,ai+5,aj+jH+jI-20,ai,aj+jH+jI-15)jy[#jy+1]="</g>"end;jy[#jy+1]=[[<g style="clip-path: url(#headingClip);">]]local jM=jJ;if dc then jM=jA(cU)end;local jN=20;local jO=bF(jM)local jP=0;local jQ=aj+jH+jI+20;local jR=ai;if jG~="YAW"then jQ=iQ(130)jR=iP(960)end;local jS=[[<path class="txttick line" d="]]local jT=bF(jO-(jN+10)-jO%5+0.5)for L=jT+70,jT,-5 do local hk=jR-(-L*5+jM*5)if L%10==0 then jP=10;local dI=L;if dI==360 then dI=0 elseif dI>360 then dI=dI-360 elseif dI<0 then dI=dI+360 end;jy[#jy+1]=gK(hk,jQ+15,dI,"txtmid bright")elseif L%5==0 then jP=5 end;if jP==10 then jS=dq([[%s M %f %f v %d]],jS,hk,jQ-5,jP)else jS=dq([[%s M %f %f v %d]],jS,hk,jQ-2.5,jP)end end;jy[#jy+1]=jS..[["/>]]jy[#jy+1]=dq([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],jR-5,jQ-20,jR+5,jQ-20,jR,jQ-10)if I then if dc then jG="HDG"end;jy[#jy+1]=gK(iP(960),iQ(100),jO.."°","dim txt txtmid size14","")jy[#jy+1]=gK(iP(960),iQ(85),jG,"dim txt txtmid size20","")end;jy[#jy+1]=[[</g>]]end;local function jU(jy,jV,jF,ai,aj,dc,jW,fw)if ab==0 then return end;local jH=ab;local jX=bF(jH*3/5)if jH>0 then local jY=bF(jV)local jL=0;local jS=dq([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*jF,ai,aj)if not ci then jS=dq([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],ai,aj)end;jy[#jy+1]=dq([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],jH-1,ai,aj)jy[#jy+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for L=bF(jY-30-jY%5+0.5),bF(jY+30+jY%5+0.5),5 do if L%10==0 then jL=30 elseif L%5==0 then jL=20 end;local hl=aj+-L*5+jV*5;if jL==30 then jS=dq([[%s M %d %f h %d]],jS,ai-jX-jL,hl,jL)if ci then jy[#jy+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jF,ai,aj,ai-jX+10,hl+4,L)jy[#jy+1]=dq([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*jF,ai,aj,ai+jX-10,hl+4,L)if L==0 or L==180 or L==-180 then jy[#jy+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jF,ai,aj,ai-jX+20,hl,jX*2-40)end else jy[#jy+1]=gK(ai-jX+10,hl,L,"pdim txt txtmid")jy[#jy+1]=gK(ai+jX-10,hl,L,"pdim txt txtmid")end;jS=dq([[%s M %d %f h %d]],jS,ai+jX,hl,jL)else jS=dq([[%s M %d %f h %d]],jS,ai-jX-jL,hl,jL)jS=dq([[%s M %d %f h %d]],jS,ai+jX,hl,jL)end end;jy[#jy+1]=jS..[["/>]]local jZ="PITCH"if not dc then jZ="REL PITCH"end;if jV>90 and not ci then jV=90-(jV-90)elseif jV<-90 and not ci then jV=-90-(jV+90)end;if jH>200 then if ci then if fw>iB then jy[#jy+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")jy[#jy+1]=gK(ai,aj+20,jW,"pdim txt txtmid")end;jy[#jy+1]=dq([[<g transform="rotate(%f,%d,%d)">]],-jF,ai,aj)else jy[#jy+1]=dq([[<g transform="rotate(0,%d,%d)">]],ai,aj)end;jy[#jy+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai-jX+25,aj-5,ai-jX+20,aj,ai-jX+25,aj+5,ai-jX+50,aj+4,jY)jy[#jy+1]=dq([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],ai+jX-25,aj-5,ai+jX-20,aj,ai+jX-25,aj+5,ai+jX-30,aj+4,jY)jy[#jy+1]="</g>"end;local j_=bF(jH/3)jy[#jy+1]=dq([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],ai-j_,aj,jH-j_)if not ci and dc then jy[#jy+1]=dq([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*jF,ai,aj,ai-jX+10,aj,jX*2-20)end;jy[#jy+1]="</g>"if jH<200 then if ci and fw>iB then jy[#jy+1]=gK(ai,aj-jH,jZ,"pdim txt txtmid")jy[#jy+1]=gK(ai,aj-jH+10,jY,"pdim txt txtmid")jy[#jy+1]=gK(ai,aj-15,"Yaw","pdim txt txtmid")jy[#jy+1]=gK(ai,aj+20,jW,"pdim txt txtmid")else jy[#jy+1]=gK(ai,aj-jH,jZ,"pdim txt txtmid")jy[#jy+1]=gK(ai,aj-jH+15,jY,"pdim txt txtmid")end end end end;local function k0(jy,e9,dc)local k1=ao;local k2=ap;if k1==0 and k2==0 then return end;local k3=78;local k4=19;local k5=ch;if ch~=-1 then jy[#jy+1]=gK(k1+k3,k2+k4+20,dq("AGL: %.1fm",ch),"pdim altsm txtend")end;if dc and(e9<200000 and not ci or e9 and ci)then table.insert(jy,dq([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],k1-1,k2-4,k3+2,k4+6,k1+1,k2-1,k3-4,k4))local gy=0;local k6=1;local k7=0;local k8=e9<0;local k9=e9<iO.surfaceMaxAltitude;local ka=9;if k8 then ka=0 end;local e9=f4(e9)while gy<6 do local kb=11;local kc=16;local kd=9;local ke=14;local js="altsm"if gy>2 then kc=kc+3;kb=kb+2;ke=ke+2;kd=kd-6;js="altbig"end;if k8 then js=js.." red"elseif k9 then js=js.." orange"end;local kf=e9/k6%10;local kg=bF(kf)local kh=bF((kg+1)%10)local ki=k7;if gy==0 then ki=kf-kg;if k8 then ki=1-ki end end;if k8 and(gy==0 or k7~=0)then local gB=kh;kh=kg;kg=gB end;local kj=kc*(ki-1)local kk=kj+kc;local hk=k1+kd+(6-gy)*kb;local hl=k2+ke;jy[#jy+1]=gK(hk,hl+kj,kh,js)jy[#jy+1]=gK(hk,hl+kk,kg,js)gy=gy+1;k6=k6*10;if kg==ka then k7=ki else k7=0 end end;table.insert(jy,[[</g></g>]])end end;local function kl(fB)local km=-math.deg(e_(fB.y,fB.z))+180;km=km-90;if km<0 then km=360+km end;if km>180 then km=-180+km-180 end;return-km end;local function kn(fB)local jM=math.deg(e_(fB.y,fB.x))-90;if jM<-180 then jM=360+jM end;return jM end;local function ko(jy,fB,fw,ai,aj)if fw>5 and not ci or fw>iB then local jH=ab;local kp=20;local kq=20;local kr=kl(fB)local ks=kn(fB)local kt=14;local ku=kt/2;local kv=-ks/kq*jH;local kw=kr/kp*jH;local hk=ai+kv;local hl=aj+kw;local cc=dt(kv^2+kw^2)local kx=[[<circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..ku/kt..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..hk..[["
                            cy="]]..hl..[["
                            r="]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..hk-kt..[[,]]..hl..[[ h ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk+ku..[[,]]..hl..[[ h ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..hk..[[,]]..hl-kt..[[ v ]]..ku..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if cc<jH then jy[#jy+1]=kx else local jz=e_(kw,kv)local ky=4;local kz=ai+jH*math.cos(jz)local kA=aj+jH*math.sin(jz)jy[#jy+1]=dq('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',jz*180/math.pi,kz,kA,kz-ky,kA-ky/2,ky*2,ky,kz+ky,kA-ky,ky,ky,-ky,ky)end;if not ci then local kB=vec3(fB)kr=kl(-kB)ks=kn(-kB)kv=-ks/kq*jH;kw=kr/kp*jH;hk=ai+kv;hl=aj+kw;cc=dt(kv^2+kw^2)if cc<jH then local kC=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kt..[[ v ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..hk..[[,]]..hl..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..hk..[[,]]..hl..[[)" />
                                <path
                                    d="M ]]..hk-ku..[[,]]..hl..[[ h ]]..kt..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..hk..[[,]]..hl..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..hk..[[,]]..hl..[[)"/>]]jy[#jy+1]=kC end end end end;local function kD(jy,iT,kE,kF)if ak==0 and al==0 then return end;kE=bF(kE+0.5)local ji=al+10;local jj=al+20;if ie()==1 and not l then ji=55;jj=65 end;local kG="CRUISE"local c="km/h"local dR=kF;if iT=="TRAVEL"or iT=="AUTOPILOT"then kG="THROT"c="%"dR=kE;local kH="dim"if kE<0 then kH="red"end;jy[#jy+1]=dq([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],kH,ak-7,al-50,ak,al-50,ak,al+50,ak-7,al+50,1-f4(kE),ak-10,al+50,ak-15,al+53,ak-15,al+47)end;jy[#jy+1]=gK(ak+10,ji,kG,"pbright txtstart")jy[#jy+1]=gK(ak+10,jj,dq("%.0f %s",dR,c),"pbright txtstart")if ci and u and d4 and bN then kE=bF(bO*100+0.5)local kH="red"if kE<0 then kH="red"end;jy[#jy+1]=dq([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],kH,1-f4(kE),ak-10,al+50,ak-15,al+53,ak-15,al+47)jy[#jy+1]=gK(ak+10,ji+40,"LIMIT","pbright txtstart")jy[#jy+1]=gK(ak+10,jj+40,kE.."%","pbright txtstart")end;if ci and u or b4 then jy[#jy+1]=gK(ak+10,ji-40,"LIMIT: "..cL.." km/h","dim txtstart")elseif not ci and a_ then jy[#jy+1]=gK(ak+10,ji-40,"LIMIT: "..bF(a0*3.6+0.5).." km/h","dim txtstart")end end;local function kI(jy,kJ)if ak==0 and al==0 then return end;local kK=al-10;local kL=ak+10;jy[#jy+1]=gK(0,0,"","pdim txt txtend")if ie()==1 and not l then kK=75 end;jy[#jy+1]=gK(kL,kK,bF(kJ).." km/h","pbright txtbig txtstart")end;local function kM(jy)jy[#jy+1]=gK(iP(1900),iQ(1070),dq("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")jy[#jy+1]=[[<g class="warnings">]]if c.isMouseControlActivated()==1 then jy[#jy+1]=gK(iP(960),iQ(550),"Warning: Invalid Control Scheme Detected","warnings")jy[#jy+1]=gK(iP(960),iQ(600),"Keyboard Scheme must be selected","warnings")jy[#jy+1]=gK(iP(960),iQ(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local kN=iP(960)local kO=iQ(860)local kP=iQ(880)local kQ=iQ(900)local kR=iQ(960)local kS=iQ(200)local kT=iQ(250)local kU=iQ(960)if ie()==1 and not l then kO=iQ(135)kP=iQ(155)kQ=iQ(175)kS=iQ(115)kT=iQ(95)end;local kV="#222222"local kW="white"local kX="dimmer"local kY="pbright"local kZ="#110000"local k_=kV;local l0=kX;if aX then jy[#jy+1]=gK(kN,kO,"Brake Engaged","warnings")kZ="#440000"k_=kW;l0=kY elseif bM>0 then jy[#jy+1]=gK(kN,kO,"Auto-Brake Engaged","warnings","opacity:"..bM)end;local l1="#110000"local l2=kV;local l3=kX;if ci and cJ and ch==-1 then if not a_ and not bm and not b2 and not d2 and not b5 and not b3 then jy[#jy+1]=gK(kN,kS+50,"** STALL WARNING **","warnings")l1="#ff0000"l2=kW;l3=kY;g0("stall","SW",2)end end;if da then jy[#jy+1]=gK(kN,kS+90,"Flight Assist in Progress","warnings")end;if co then jy[#jy+1]=gK(kN,kU,"Gyro Enabled","warnings")end;local l4="#111100"local l5=kV;local l6=kX;if bi then l4="#775500"l5=kW;l6=kY;if bS then jy[#jy+1]=gK(kN,kP,"Gear Extended","warn")else jy[#jy+1]=gK(kN,kP,"Landed (G: Takeoff)","warnings")end;local l7=il(d:getTargetGroundAltitude())jy[#jy+1]=gK(kN,kQ,"Hover Height: "..l7,"warn")end;local l8="#000011"local l9=kV;local la=kX;if c2 then l8="#0000DD"l9=kW;la=kY;jy[#jy+1]=gK(kN,kR+20,"ROCKET BOOST ENABLED","warn")end;local lb="#001100"local lc=kV;local ld=kX;if antigrav and not q and d2 and br~=nil then lb="#00DD00"lc=kW;ld=kY;if f4(ck-antigrav.getBaseAltitude())<501 then jy[#jy+1]=gK(kN,kS+15,dq("Target Altitude: %d Singularity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warn")else jy[#jy+1]=gK(kN,kS+15,dq("Target Altitude: %d Singluarity Altitude: %d",bF(br),bF(antigrav.getBaseAltitude())),"warnings")end elseif a_ and bf~="None"then jy[#jy+1]=gK(kN,kS+20,"Autopilot "..bc,"warn")elseif bp~=nil then jy[#jy+1]=gK(kN,kS+20,dq("LockedPitch: %d",bF(bp)),"warn")elseif b_ then jy[#jy+1]=gK(kN,kS+20,"Follow Mode Engaged","warn")elseif b4 or cg then jy[#jy+1]=gK(kN,kS+20,"Re-entry in Progress","warn")end;if b1 or b5 then local l7=il(b6,2)if b5 then if d2 then l7=il(antigrav.getBaseAltitude(),2).." AGG singularity height"end;jy[#jy+1]=gK(kN,kS,"VTO to "..l7,"warn")elseif b3 and not bv then if cf then jy[#jy+1]=gK(kN,kS,"Takeoff to "..bf,"warn")else jy[#jy+1]=gK(kN,kS,"Takeoff to "..l7,"warn")end;if aX and not b5 then jy[#jy+1]=gK(kN,kS+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else jy[#jy+1]=gK(kN,kS,"Altitude Hold: "..l7,"warn")end end;if b5 and(antigrav~=nil and antigrav)then if cj>0.1 then jy[#jy+1]=gK(kN,kS+20,"Beginning ascent","warn")elseif cj<0.09 and cj>0.05 then jy[#jy+1]=gK(kN,kS+20,"Aligning trajectory","warn")elseif cj<0.05 then jy[#jy+1]=gK(kN,kS+20,"Leaving atmosphere","warn")end end;if bv then if cN~=nil then jy[#jy+1]=gK(kN,kS,cN,"warn")end end;if b2 then if le then jy[#jy+1]=gK(kN,kS,"Brake-Landing","warnings")else jy[#jy+1]=gK(kN,kS,"Coast-Landing","warnings")end end;if aZ then jy[#jy+1]=gK(kN,kS,"Prograde Alignment","crit")end;if aY then jy[#jy+1]=gK(kN,kS,"Retrograde Alignment","crit")end;local lf="#110000"local lg=kV;local lh=kX;if dd then lf="#FF0000"lg=kW;lh=kY;local type;if string.find(dd,"COLLISION")then type="warnings"else type="crit"end;jy[#jy+1]=gK(kN,kT+20,dd,type)elseif cj==0 then local li,lj=cD.checkLOS(cX:normalize())if lj~=nil then lh=kY;lf="#FF0000"lg=kW;local l7=il(lj)local lk=cy.computeTravelTime(cY,0,lj)local ll="Collision"if li.noAtmosphericDensityAltitude>0 then ll="Atmosphere"end;jy[#jy+1]=gK(kN,kT+20,li.name.." "..ll.." "..im(lk).." In "..l7,"crit")end end;if bm and not bv then jy[#jy+1]=gK(kN,kS+35,lm,"warn")end;local ln="#111100"local lo=kV;local lp=kX;if dh and#dh>1 then ln="#DDDD00"lo=kW;lp=kY end;local lq=iP;local lr=iQ;local kX="topButton"local ls="topButtonActive"local lt=kX;if a_ or bm or cf or bv then lt=ls end;local lu=kX;if aZ then lu=ls end;local lv=kX;if b2 or bi then lv=ls end;local lw=kX;if b1 or bm then lw=ls end;local lx=kX;if aY then lx=ls end;local ly=kX;if bv or cQ and a_ then ly=ls end;if x and I then local lz=lr(30)jy[#jy+1]=dq([[ 
                                <g class="pdim txt txtmid">
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lt,lq(960),lr(54),lr(-53),lq(-120),lq(25),lr(50))jy[#jy+1]=gK(lq(910),lz,"AUTOPILOT")jy[#jy+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lu,lq(865),lr(51),lq(-25),lr(-50),lq(-110),lq(25),lr(46))jy[#jy+1]=gK(lq(800),lz,"PROGRADE")jy[#jy+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lv,lq(755),lr(47),lq(-25),lr(-46),lq(-98),lq(44),lr(44))jy[#jy+1]=gK(lq(700),lz,"LAND")jy[#jy+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                    ]],lw,lq(960),lr(54),lr(-53),lq(120),lq(-25),lr(50))jy[#jy+1]=gK(lq(1010),lz,"ALT HOLD")jy[#jy+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],lx,lq(1055),lr(51),lq(25),lr(-50),lq(110),lq(-25),lr(46))jy[#jy+1]=gK(lq(1122),lz,"RETROGRADE")jy[#jy+1]=dq([[
                                    </g>
                
                                    <g class="%s">
                                    <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                    ]],ly,lq(1165),lr(47),lq(25),lr(-46),lq(98),lq(-44),lr(44))jy[#jy+1]=gK(lq(1220),lz,"ORBIT")jy[#jy+1]=[[
                                    </g>
                                </g>]]jy[#jy+1]="</g>"end;return jy end;local function lA(fw)return bF(ii(fw*3.6,0)+0.5).." km/h"end;local function lB(gy)local gA=bf;if gy~=nil and type(gy)=="number"then if gy==0 then return"None"end;gA=d7[gy].name end;if gA==nil then gA=ga.name end;if gA==nil then gA="None"end;return gA end;local function lC(jy)local lD=cD.routeWP(true)if not lD or#lD==0 then return end;local hk=iP(750)local hl=iQ(360)if a_ or bm then jy[#jy+1]=gK(hk,hl,"REMAINING ROUTE","pdim txtstart size20")else jy[#jy+1]=gK(hk,hl,"LOADED ROUTE","pdim txtstart size20")end;for dQ,L in pairs(lD)do hl=hl+20;jy[#jy+1]=gK(hk,hl,dQ..". "..lB(lD[dQ]),"pdim txtstart size20")end end;local function lE(jy)local hk=aw+10;local hl=ax+20;local lF={}local lG={"Alt-4: AutoTakeoff to Target"}local lH={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local lI={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere","G: Raise or lower landing gear"}local lJ={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-Shift 1: Show passengers on board","Alt-Shift-2: Deboard passengers","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-Shift-3: Show docked ships","Alt-Shift-4: Undock all ships","Alt-5: Lock Pitch at current pitch","Alt-Shift-5: Lock pitch at preset pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","B: Toggle rocket boost on/off","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","L: Toggle lights on and off","Type /commands or /help in lua chat to see text commands"}table.insert(lF,"--------------DYNAMIC-----------------")if ci then if ch~=-1 then ij(lF,lG)if c5 and iO and c5.name==iO.name then table.insert(lF,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or aW then if antigrav then if d2 then table.insert(lF,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(lF,"Turn on AGG to takeoff to AGG Height")end end;if aW then table.insert(lF,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(lF,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(lF,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if bi then table.insert(lF,"G: Takeoff to hover height, raise gear")else table.insert(lF,"G: Lowergear and Land")end else ij(lF,lH)table.insert(lF,"G: Begin BrakeLanding or Land")end;if b5 then table.insert(lF,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else ij(lF,lI)if ia then table.insert(lF,"Alt-Shift-6: Vent shields")table.insert(lF,"Alt-Shift-7: Toggle shied off/on")end end;if ga~=nil then table.insert(lF,"Alt-Shift-8: Add current IPH target to Route")end;if gyro then table.insert(lF,"Alt-9: Activate Gyroscope")end;if aS~="none"or aR~="none"or aT~="none"then table.insert(lF,"Alt-Shift-9: Cycles engines with Extra tags")end;if b1 then table.insert(lF,"Alt-Spacebar/C will raise/lower target height")table.insert(lF,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if u or not ci then table.insert(lF,"LALT+Mousewheel will lower/raise speed limit")end;ij(lF,lJ)for L=1,#lF do hl=hl+12;jy[#jy+1]=gK(hk,hl,lF[L],"pdim txtbig txtstart")end end;local function lK(jy)local lL=aw;local lM=ax;local lN=av;local lO=4;local lP=15;local hk=0;local hl=0;local lQ,lR,lS,lT;local lU;local function lV(type)local lW,bH,fw,lX,js,lY;if type=="Periapsis"then lW=lU.periapsis.altitude;bH=lU.timeToPeriapsis;fw=lU.periapsis.speed;js="txtend"lX=12;lY=math.min(hk,lL+lN-iO.radius/lS-lO*2)else lW=lU.apoapsis.altitude;bH=lU.timeToApoapsis;fw=lU.apoapsis.speed;lX=-12;js="txtstart"lY=hk end;if cY<1 then bH=0 end;jy[#jy+1]=dq([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lY+lX,hl-5,hk,hl-5)jy[#jy+1]=dq([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],lY-lX*4,hl+2,hk,hl+2)jy[#jy+1]=gK(lY,hl,type,js)hk=lY-lX*2;hl=hl+lP;local l7=il(lW)jy[#jy+1]=gK(hk,hl,l7,js)hl=hl+lP;jy[#jy+1]=gK(hk,hl,im(bH),js)hl=hl+lP;jy[#jy+1]=gK(hk,hl,lA(fw),js)end;local lZ=lN*1.5;if bC=="INFO"then lZ=25*9 end;if bC~="HIDE"then jy[#jy+1]=[[<g class="pbright txtorb txtmid">]]jy[#jy+1]=dq('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',lN*2,lZ,lL,lM)jy[#jy+1]=dq([[<clippath id="orbitRect">
                                                        <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                        </clippath>]],lN*2,lZ,lL,lM)end;local l_=lN*1.5;local m0=lN*2;local m1=l_/2;local m2=lN;local m3=lL+m2;local m4=lM+m1;local m5=lL+m0;local m6=lM+l_;if bC=="ORBIT"then lM=lM+lO;lQ=lN/2;lT=0;lU={}lU.periapsis={}lU.apoapsis={}if fA~=nil then if fA.periapsis~=nil then lU.periapsis.altitude=fA.periapsis.altitude;lU.periapsis.speed=fA.periapsis.speed end;if fA.apoapsis~=nil then lU.apoapsis.altitude=fA.apoapsis.altitude;lU.apoapsis.speed=fA.apoapsis.speed end;lU.period=fA.period;lU.eccentricity=fA.eccentricity;lU.timeToApoapsis=fA.timeToApoapsis;lU.timeToPeriapsis=fA.timeToPeriapsis;lU.eccentricAnomaly=fA.eccentricAnomaly;lU.trueAnomaly=fA.trueAnomaly end;if lU.periapsis==nil then lU.periapsis={}lU.periapsis.altitude=-iO.radius;lU.periapsis.speed=a0 end;if lU.eccentricity==nil then lU.eccentricity=1 end;if lU.apoapsis==nil then lU.apoapsis={}lU.apoapsis.altitude=ck;lU.apoapsis.speed=0 end;if cY<1 then lU.apoapsis.altitude=ck;lU.apoapsis.speed=0 end;if lU.apoapsis.altitude then lS=(lU.apoapsis.altitude+lU.periapsis.altitude+iO.radius*2)/(lQ*2)lR=(iO.radius+lU.apoapsis.altitude)/lS*(1-lU.eccentricity)lT=lQ-lU.periapsis.altitude/lS-iO.radius/lS;local m7=math.pi;if lU.period~=nil and lU.period>0 and lU.timeToApoapsis~=nil then m7=lU.eccentricAnomaly;if lU.timeToPeriapsis<lU.timeToApoapsis then m7=2*math.pi-m7 end end;if cY<1 or m7~=m7 then m7=math.pi end;local m8=-lQ*math.cos(m7)+lL+m2+lO;local m9=lR*math.sin(m7)+lM+m1+lO;local ma=""jy[#jy+1]='<g clip-path="url(#orbitRect)">'jy[#jy+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],ma,lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)if lR<1 then jy[#jy+1]=dq([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],lL+lN+lO-lT,lM+lN*1.5/2+lO,m8,m9)end;jy[#jy+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,(iO.radius+iO.noAtmosphericDensityAltitude)/lS)jy[#jy+1]=dq('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',lL+lN+lO-lT,lM+lN*1.5/2+lO,(iO.radius+iO.noAtmosphericDensityAltitude)/lS)jy[#jy+1]=dq([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",lL+lN+lO,lM+lN*1.5/2+lO,lQ,lR)jy[#jy+1]=dq('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',lL+lN+lO-lT,lM+lN*1.5/2+lO,iO.radius/lS)jy[#jy+1]='</g>'local mb=math.floor(iO.radius/lS+0.5)hk=lL+lN+lO*4+lQ;hl=lM+lN*1.5/2+5+lO;if lU.apoapsis~=nil and lU.apoapsis.speed<a0 then lV("Apoapsis")end;hl=lM+lN*1.5/2+5+lO;hk=lL+lN-lO*2-lQ;if lU.periapsis~=nil and lU.periapsis.speed<a0 and lU.periapsis.altitude>0 then lV("Periapsis")end;jy[#jy+1]=gK(lL+lN+lO,lM+20+lO,iO.name,"txtorbbig")jy[#jy+1]=dq('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',m8,m9)jy[#jy+1]=[[</g>]]return jy else jy[#jy+1]='<g clip-path="url(#orbitRect)">'local mc=""local md=1.2*(me-mf)/(lN*2)local mg=1.4*(mh-mi)/(lN*1.5)for dQ,dC in pairs(e[0])do if dC.center then local hk=lL+lN+dC.center.x/md;local hl=lM+lN*1.5/2+dC.center.y/mg;mc=mc..'<circle cx="'..hk..'" cy="'..hl..'" r="'..dC.radius/md*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(dC.name,"Moon")and not string.match(dC.name,"Sanctuary")and not string.match(dC.name,"Space")then mc=mc.."<text x='"..hk.."' y='"..hl+dC.radius/md*30+20 .."' font-size='12' fill="..cp.." text-anchor='middle' font-family='Montserrat'>"..dC.name.."</text>"end end end;local fC=vec3(b.getConstructWorldPos())local hk=lL+lN+fC.x/md;local hl=lM+lN*1.5/2+fC.y/mg;mc=mc..'<circle cx="'..hk..'" cy="'..hl..'" r="2" stroke="white" stroke-width="1" fill="red"/>'mc=mc.."<text x='"..hk.."' y='"..hl-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"iv=md;iw=mg;local mj=fC+cX*1000000;local mk=lL+lN+mj.x/md;local jj=lM+lN*1.5/2+mj.y/mg;mc=mc..'<line x1="'..hk..'" y1="'..hl..'" x2="'..mk..'" y2="'..jj..'" stroke="purple" stroke-width="1"/>'jy[#jy+1]=mc;jy[#jy+1]='</g>'end elseif bC=="INFO"then jy=cB.DrawOdometer(jy,c6,bj,c7)elseif bC=="HELP"then jy=lE(jy)elseif bC=="SCOPE"then jy[#jy+1]='<g clip-path="url(#orbitRect)">'local ml=dk;if cj>0 then table.sort(dj,function(eG,eH)local eI,eJ=eG.center,eH.center;return(eI.x-d0.x)^2+(eI.y-d0.y)^2+(eI.z-d0.z)^2<(eJ.x-d0.x)^2+(eJ.y-d0.y)^2+(eJ.z-d0.z)^2 end)end;local gS={}local mm={}local mn=120;local mo=nil;local mp=nil;for L,dC in ipairs(dj)do local gR=dC.center-d0;local mq=gR:len()local mr=gR:normalize()local ms=gR:cross(cU):normalize()local mt=math.acos(ms:dot(cV))if mt~=mt then mt=0 end;if ms:cross(cV):dot(cU)<0 then mt=-mt end;local mu=gR:project_on_plane(cU):len()local mv=math.sin(mt)*math.asin(mu/mq)*constants.rad2deg;local mw=math.cos(mt)*math.asin(mu/mq)*constants.rad2deg;if mr:dot(cU)<0 then mw=90*math.cos(mt)+90*math.cos(mt)-mw;mv=90*math.sin(mt)+90*math.sin(mt)-mv end;local hk=m3+mv/ml*l_;local hl=m4+mw/ml*l_;local mx=(hk-m3)*(hk-m3)+(hl-m4)*(hl-m4)local my=math.asin((dC.radius+dC.surfaceMaxAltitude)/mq)*constants.rad2deg;if my~=my then my=ml end;local hQ=my/ml*l_;local mz=math.asin(dC.atmosphereRadius/mq)*constants.rad2deg;if mz~=mz then mz=my end;local mA=mz/ml*l_;local cc=il(mq,1)local mB=dC.name;local mC=false;if hl>lM then if hl>m6 then if hl-mA<=m6 then mC=true end else mC=true end else if hl+mA>=lM then mC=true end end;local mD=false;local mE=hk;if dC.systemId==0 then mE=hk+mn else mE=hk-mn end;if mE+mn>lL then if mE+mn>m5 then if mE-mA-mn<=m5 then mD=true end else mD=true end else if mE+mA+mn>=lL then mD=true end end;local mF={}mF.x=hk;mF.y=hl;mF.planet=dC;mF.atmoSize=mA;if not mo or mx<mo then mo=mx;mp=mF end;if mD and mC then local mG=math.max(mA,5)if mx<mG*mG then mB=mB.." - "..cc end;mF.size=hQ;mF.i=L;mF.displayString=mB;mF.distance=cc;mF.visible=true;mm[#mm+1]=mF else mF.visible=false end end;local mH=false;table.sort(mm,function(eI,eJ)return eI.y<eJ.y end)for dQ,fF in ipairs(mm)do local dC,hQ,L,mA,hk,hl,mB,cc=fF.planet,fF.size,fF.i,fF.atmoSize,fF.x,fF.y,fF.displayString,fF.distance;local lY,mI,mJ,mK;local mL=15;local js="pdim"if dC.systemId~=0 then mJ=iP(string.len(mB)*5)mL=-(15+mJ)mK=iQ(10)js="pdimfill"else mJ=iP(string.len(mB)*9)mK=iQ(15)end;if hQ*2>mJ then lY=dr(hk,lL+mJ/2,m5-mJ/2)mI=dr(hl,lM+mK,m6-5)lY=dr(lY,hk-hQ+mJ/2,hk+hQ-mJ/2)mI=dr(mI,hl-hQ+mK,hl+hQ)else lY=hk+mL;mI=hl end;for mM,fF in pairs(gS)do local mN=fF.textPositions;local mO=mN.y-mI;if mM~=L and f4(mO)<mN.height and mN.x+mN.width>lY and mN.x<lY+mJ then if hQ>mJ then mI=dr(mI+mK,lM+15,m6-5)else mI=mN.y+mN.height+1 end end end;local mP=mB~=dC.name or lY<=m3 and lY+mJ>=m3 and mI-mK<=m4 and mI>=m4;fF.hovered=mP;local mQ=1;if mP then mQ=2;if hQ*2<mJ then mQ=10 end;if mB==dC.name then mB=mB.." - "..cc end;js="pbright"if dC.systemId~=0 then mJ=iP(string.len(mB)*5)mL=-(15+mJ)else mJ=iP(string.len(mB)*7)end;if hQ*2>mJ then lY=dr(hk,lL+mJ/2,m5-mJ/2)lY=dr(lY,hk-hQ+mJ/2,hk+hQ-mJ/2)else lY=hk+mL end end;gS[L]={}gS[L].textPositions={}gS[L].textPositions.y=mI;gS[L].textPositions.x=lY;gS[L].textPositions.width=mJ;gS[L].textPositions.height=mK;gS[L].output=""if hQ*2>mJ then js=js.." txtmid"else js=js.." txtstart"end;if mA-hQ>2 then gS[L].output=dq('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',hk,hl,mA,cq,0.1*mQ)end;gS[L].output=gS[L].output..dq('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',hk,hl,hQ,cq,0.2*mQ)if dC.systemId==0 then gS[L].output=gS[L].output..dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lY,mI,cp,js,mB)if hQ*2<=mJ then gS[L].output=gS[L].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lY+mJ,mI+2,lY,mI+2,hk,hl)end else gS[L].output=gS[L].output..dq([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],lY,mI,cq,js,mB)if hQ*2<=mJ then gS[L].output=gS[L].output..dq("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",lY,mI+2,lY+mJ,mI+2,hk,hl)end end end;for dQ=#dj,1,-1 do if gS[dQ]then jy[#jy+1]=gS[dQ].output end end;if mp~=nil and dk<90 and not mp.hovered then local mR=mp.planet.atmosphereRadius/mp.atmoSize;local mS=dt(mo)*mR;local mT=il(mS,1)local mJ=iP(math.max(string.len(mT)*7,string.len(mp.planet.name)*7))local mK=iQ(12)local lY=dr(mp.x+(m3-mp.x)/2,lL+mJ/2,m5-mJ/2)local mI=dr(mp.y+(m4-mp.y)/2,lM+mK*2,m6-5)jy[#jy+1]=dq("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",mp.x,mp.y,m3,m4)jy[#jy+1]=dq([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lY,mI,"white",mT)if not mp.visible then jy[#jy+1]=dq([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],lY,mI-mK,"white",mp.planet.name)end end;if cY>1 then local gR=cX;local mr=gR:normalize()local mu=gR:project_on_plane(cU):len()local ms=gR:cross(cU):normalize()local mt=math.acos(ms:dot(cV))if mt~=mt then mt=0 end;if ms:cross(cV):dot(cU)<0 then mt=-mt end;local mv=math.sin(mt)*math.asin(mu/gR:len())*constants.rad2deg;local mw=math.cos(mt)*math.asin(mu/gR:len())*constants.rad2deg;if mr:dot(cU)<0 then mw=90*math.cos(mt)+90*math.cos(mt)-mw;mv=90*math.sin(mt)+90*math.sin(mt)-mv end;local hk=m3+mv/ml*l_;local hl=m4+mw/ml*l_;local kt=14;local ku=kt/2;local kx=[[<circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..ku/kt..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..hk..[["
                                    cy="]]..hl..[["
                                    r="]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..hk-kt..[[,]]..hl..[[ h ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk+ku..[[,]]..hl..[[ h ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..hk..[[,]]..hl-kt..[[ v ]]..ku..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]jy[#jy+1]=kx end;jy[#jy+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m3,m4-10,m3,m4+10)jy[#jy+1]=dq("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",m3-10,m4,m3+10,m4)jy[#jy+1]='</g>'else return jy end end;local function mU(mV,mW)local mX;local mY=(mW-mV):normalize()local fD=(d0-mV):dot(mY)/mY:dot(mY)if fD<=0. then return(d0-mV):len()elseif fD>=(mW-mV):len()then return(d0-mW):len()end;local mZ=mV+fD*mY;mX=(mZ-d0):len()return mX end;local function m_()local mX;local n0=nil;local n1=nil;local n2=nil;for dQ,n3 in pairs(e[0])do if n3.hasAtmosphere then local cc=mU(iO.center,n3.center)if n0==nil or cc<n0 then n1=n3;n0=cc;n2=iO end;if c5 and c5.hasAtmosphere and c5.name~=iO.name then local eV=mU(c5.center,n3.center)if eV<n0 then n1=n3;n0=eV;n2=c5 end end end end;local n4=iP(1770)local n5=iQ(330)if n0 then local n6="txttick "local n7=500000;if n0<n1.radius+n7 or n0<n2.radius+n7 then if d8 then n6="txttick red "else n6="txttick orange "end end;mX=il(n0,2)iA=gK(n4,n5,"Pipe ("..n2.name.."--"..n1.name.."): "..mX,n6 .."pbright txtmid")end end;local function n8(hk,hl,n9,na,kG)local nb={x=hk,y=hl,width=n9,height=na,label=kG}iu[kG]=nb;return nb end;local function nc(nd,ne,n9,na,hk,hl,nf,ng,nh,ni,js)local nb={enableName=nd,disableName=ne,width=n9,height=na,x=hk,y=hl,toggleVar=nf,toggleFunction=ng,drawCondition=nh,hovered=false,class=js}if ni then table.insert(it,nb)else table.insert(is,nb)end;return nb end;local function nj(nk)if not iy then nl=false;nm=false;nn=false;x=true;return elseif nk=="handling"then nl=not nl;nm=false;nn=false elseif nk=="hud"then nm=not nm;nl=false;nn=false elseif nk=="physics"then nn=not nn;nl=false;nm=false end;if nn or nm or nl then iz=ik(nk)x=false else iz="none"x=true end end;local function no()iy=not iy;if iy then ir=it;c1="Hold SHIFT to see Settings"dl=x else ir=is;c1="Hold SHIFT to see Control Buttons"nj()x=dl end end;local function np()local function nq(dC,dQ)dC.set(not dC.get())if dC.get()then c1=dQ.." set to true"else c1=dQ.." set to false"end;if dQ=="showHud"then dl=dC.get()elseif dQ=="BrakeToggleDefault"then aV=j end end;local nr=50;local ns=340;local hk=500;local hl=cs/2-400;local nt=0;for dQ,dC in pairs(ik("boolean"))do if type(dC.get())=="boolean"then nc(dQ,dQ,ns,nr,hk,hl,function()return dC.get()end,function()nq(dC,dQ)end,function()return true end,true)hl=hl+nr+20;if nt==9 then hk=hk+ns+20;hl=cs/2-400;nt=0 else nt=nt+1 end end end;nc("Control View","Control View",ns,nr,10,cs/2-500,function()return true end,no,function()return true end,true)nc("View Handling Settings",'Hide Handling Settings',ns,nr,10,cs/2-(500-nr),function()return nl end,function()nj("handling")end,function()return true end,true)nc("View Hud Settings",'Hide Hud Settings',ns,nr,10,cs/2-(500-nr*2),function()return nm end,function()nj("hud")end,function()return true end,true)nc("View Physics Settings",'Hide Physics Settings',ns,nr,10,cs/2-(500-nr*3),function()return nn end,function()nj("physics")end,function()return true end,true)end;local function nu()local function gz()local g2=d0;local gA=iO.name..". "..#bl;if radar_1 then gA=cE.GetClosestName(gA)end;return cC.AddNewLocation(gA,g2,false,true)end;local function nv()b0=not b0 end;local function nw(nx)if nx==1 then aZ=not aZ;aY=false else aY=not aY;aZ=false end;a_=false;b1=false;b_=false;b2=false;bp=nil;b4=false;b3=false end;local function ny()cC.UpdatePosition()end;local function gx()cC.ClearCurrentPosition()end;local function nz(gy)local lD=cD.routeWP(true)if lD and#lD>0 then return"Engage Route: "..lB(lD[1])end;return"Engage Autopilot: "..lB(gy)end;local function nA(gy)local lD=cD.routeWP(true)if lD and#lD>0 then return"Next Route Point: "..lB(lD[1])end;return"Disable Autopilot: "..lB(gy)end;local function nB()if ie()==1 then b_=not b_;if b_ then a_=false;aY=false;aZ=false;b1=false;b4=false;b2=false;b3=false;nC=bi;bi=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(Y)g0("folOn","F")else g0("folOff","F")aX=true;cI=p;bi=nC;if bi then d.control.extendLandingGears()ig:setTargetGroundAltitude(Z)end end else c1="Follow Mode only works with Remote controller"b_=false end end;local nr=50;local ns=260;local nD=iP(30)local nE=aw+av*2+2;local nF=ax+1;nc("+","+",nD,nD,nE,nF+nD+1,function()return false end,function()dk=dk/8 end,function()return bC=="SCOPE"end,nil,"ZoomButton")nc("-","-",nD,nD,nE,nF,function()return false end,function()dk=math.min(dk*8,90)end,function()return bC=="SCOPE"end,nil,"ZoomButton")nc("0","0",nD,nD,nE,nF+nD*2+2,function()return false end,function()dk=90 end,function()return bC=="SCOPE"and dk~=90 end,nil,"ZoomButton")local nG=nc("Enable Brake Toggle","Disable Brake Toggle",ns,nr,cr/2-ns/2,cs/2+350,function()return aV end,function()aV=not aV;if aV then c1="Brakes in Toggle Mode"else c1="Brakes in Default Mode"end end)nc("Align Prograde","Disable Prograde",ns,nr,cr/2-ns/2-50-nG.width,cs/2-nr+380,function()return aZ end,function()nw(1)end)nc("Align Retrograde","Disable Retrograde",ns,nr,cr/2-ns/2+nG.width+50,cs/2-nr+380,function()return aY end,nw,function()return cj==0 end)nH=nc(nz,nA,600,60,cr/2-600/2,cs/2-60/2-330,function()return a_ or bm or cf or bv end,function()end)local L;local function nI(nJ)local lD=cD.routeWP(true)if lD and#lD>0 then return lD[1]end;local gy=dg+nJ;if gy>#d7 then gy=gy-#d7-1 end;if gy<0 then gy=#d7+gy end;return gy end;nK={}for L=0,10 do local nL=nc(function(eJ)local gy=nI(eJ.apExtraIndex)if a_ or bm or cf or bv then return"Redirect: "..lB(gy)end;return nz(gy)end,function(eJ)local gy=nI(eJ.apExtraIndex)return nA(gy)end,600,60,cr/2-600/2,cs/2-60/2-330+60*L,function(eJ)local gy=nI(eJ.apExtraIndex)return gy==bh and(a_ or bm or cf or bv)end,function(eJ)local gy=nI(eJ.apExtraIndex)local nM=bh==gy;bh=gy;cC.UpdateAutopilotTarget()cD.ToggleAutopilot()if not nM and not(a_ or bm or cf or bv)then cD.ToggleAutopilot()end end,function()return df and(#cD.routeWP(true)==0 or L==0)end)nL.apExtraIndex=L;nK[L]=nL end;nc("Save Position","Save Position",200,nH.height,nH.x+nH.width+30,nH.y,function()return false end,gz,function()return bh==0 or ga==nil end)nc("Update Position","Update Position",200,nH.height,nH.x+nH.width+30,nH.y,function()return false end,ny,function()return bh>0 and ga~=nil end)nc("Clear Position","Clear Position",200,nH.height,nH.x-200-30,nH.y,function()return true end,gx,function()return bh>0 and ga~=nil end)nc("Save Route","Save Route",200,nH.height,nH.x+nH.width+30,nH.y+nH.height+20,function()return false end,function()cD.routeWP(false,false,2)end,function()return#cD.routeWP(true)>0 end)nc("Load Route","Clear Route",200,nH.height,nH.x-200-30,nH.y+nH.height+20,function()return#cD.routeWP(true)>0 end,function()if#cD.routeWP(true)>0 then cD.routeWP(false,true)elseif a_ or bm then c1="Disable Autopilot before loading route"return else cD.routeWP(false,false,1)end end,function()return true end)nr=60;ns=300;local hk=0;local hl=cs/2-150;nc("Enable Check Damage","Disable Check Damage",ns,nr,hk,hl-nr-20,function()return s end,function()s=not s end)nc("View Settings","View Settings",ns,nr,hk,hl,function()return true end,no)hl=hl+nr+20;nc("Enable Turn and Burn","Disable Turn and Burn",ns,nr,hk,hl,function()return b0 end,nv)hk=10;hl=cs/2-300;nc("Horizontal Takeoff Mode","Vertical Takeoff Mode",ns,nr,hk+ns+20,hl,function()return aW end,function()aW=not aW;if aW then c1="Vertical Takeoff Mode"else c1="Horizontal Takeoff Mode"end end,function()return d1 end)hl=hl+nr+20;nc("Engage Orbiting","Cancel Orbiting",ns,nr,hk+ns+20,hl,function()return bv end,cD.ToggleIntoOrbit,function()return cj==0 and dc end)hl=cs/2-150;nc("Glide Re-Entry","Cancel Glide Re-Entry",ns,nr,hk+ns+20,hl,function()return b4 end,function()ce=1;nw(1)end,function()return iO.hasAtmosphere and not ci end)hl=hl+nr+20;nc("Parachute Re-Entry","Cancel Parachute Re-Entry",ns,nr,hk+ns+20,hl,function()return b4 end,function()ce=2;nw(1)end,function()return iO.hasAtmosphere and not ci end)hl=hl+nr+20;nc("Engage Follow Mode","Disable Follow Mode",ns,nr,hk,hl,function()return b_ end,nB,function()return ie()==1 end)nc("Enable Repair Arrows","Disable Repair Arrows",ns,nr,hk+ns+20,hl,function()return cw end,function()cw=not cw;if cw then c1="Repair Arrows Enabled"else c1="Repair Arrows Diabled"end end,function()return ie()==1 end)hl=hl+nr+20;if not q then nc("Enable AGG","Disable AGG",ns,nr,hk,hl,function()return d2 end,cD.ToggleAntigrav,function()return antigrav~=nil end)end;nc(function()return dq("Switch IPH Mode - Current: %s",bw)end,function()return dq("IPH Mode: %s",bw)end,ns*2,nr,hk,hl,function()return false end,function()if bw=="All"then bw="Custom Only"elseif bw=="Custom Only"then bw="No Moons"else bw="All"end;c1="IPH Mode: "..bw end)hl=hl+nr+20;nc(function()return dq("Toggle Control Scheme - Current: %s",g)end,function()return dq("Control Scheme: %s",g)end,ns*2,nr,hk,hl,function()return false end,function()if g=="keyboard"then g="mouse"elseif g=="mouse"then g="virtual joystick"else g="keyboard"end;c1="New Control Scheme: "..g end)local nN=iQ(20)local nL=n8(0,0,iP(70),nN,"HELP")nL=n8(nL.x+nL.width,nL.y,iP(80),nN,"INFO")nL=n8(nL.x+nL.width,nL.y,iP(70),nN,"ORBIT")nL=n8(nL.x+nL.width,nL.y,iP(70),nN,"SCOPE")n8(nL.x+nL.width,nL.y,iP(70),nN,"HIDE")end;local nO={}local nP=nil;function nO.HUDPrologue(jy)d8,d9=iM(d0)if not d8 then bI=af;bK=ag;bJ=ah;if ia and G and ia.getState()==0 then ia.toggle()end else bI=ac;bK=ad;bJ=ae;if ia and G and ia.getState()==1 then ia.toggle()end end;cp=[[rgb(]]..bF(bI+0.6)..","..bF(bK+0.6)..","..bF(bJ+0.6)..[[)]]cq=[[rgb(]]..bF(bI*0.8+0.5)..","..bF(bK*0.8+0.5)..","..bF(bJ*0.8+0.5)..[[)]]local nQ=cp;local nR=cq;local nS=[[rgb(]]..bF(bI*0.4+0.5)..","..bF(bK*0.4+0.5)..","..bF(bJ*0.4+0.5)..[[)]]local nT=cp;local nU=cq;local nV=nS;if iR()and not m then nQ=[[rgb(]]..bF(bI*0.5+0.5)..","..bF(bK*0.5+0.5)..","..bF(bJ*0.5+0.5)..[[)]]nR=[[rgb(]]..bF(bI*0.3+0.5)..","..bF(bK*0.3+0.5)..","..bF(bJ*0.2+0.5)..[[)]]nS=[[rgb(]]..bF(bI*0.2+0.5)..","..bF(bK*0.2+0.5)..","..bF(bJ*0.2+0.5)..[[)]]end;local lq=iP;local lr=iQ;jy[#jy+1]=dq([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],nQ,nQ,nQ,nT,nT,nR,nR,nU,nU,nR,nQ,nS,nU,nQ,nQ,nS,nS,nV,nS,cr,cs,nR,nR,nR,nR,nR,nT,nR,nU,nV,nU,nU,nV)if not nP then nP=dq([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],lq(630),lr(0),lq(675),lr(45),lq(960),lr(55),lq(1245),lr(45),lq(1290),lr(0),lq(1000),lr(105),lq(1040),lr(59),lq(1250),lr(51),lq(1300),lr(0),lq(1920),lr(0),lq(1920),lr(20),lq(1400),lr(20),lq(1300),lr(105),lq(920),lr(105),lq(880),lr(59),lq(670),lr(51),lq(620),lr(0),lq(0),lr(0),lq(0),lr(20),lq(520),lr(20),lq(620),lr(105),lq(890),lr(59),lq(960),lr(62),lq(1030),lr(59),lq(985),lr(112),lq(1150),lr(112),lq(1100),lr(152),lq(820),lr(152),lq(780),lr(112),lq(935),lr(112),lq(890),lr(59),lq(960),lr(62),lq(1030),lr(59),lq(985),lr(112),lq(1150),lr(112),lq(1100),lr(152),lq(820),lr(152),lq(780),lr(112),lq(935),lr(112))end;if x and I then jy[#jy+1]=nP end;return jy end;function nO.DrawVerticalSpeed(jy,e9)jx(jy,e9)end;function nO.UpdateHud(jy)local km=d5;local nW=d6;local jF=nW;local jV=km;local kE=bF(c.getThrottle())local kJ=cY*3.6;local kF=c.getAxisCommandValue(0)local nX=iP(1770)local nY=iQ(310)if u and d4 then kF=bL;kE=bL*100 end;local iT=iS()local jG="ROLL"if kE==nil then kE=0 end;if not dc then if cY>5 then km=kl(cW)nW=kn(cW)else km=0;nW=0 end;jG="YAW"end;if d9>50000 and not ci then local nZ;nZ=il(d9)jy[#jy+1]=gK(nX,nY,"PvP Boundary: "..nZ,"pbright txtbig txtmid")end;jy[#jy+1]=cd;jy[#jy+1]=iE;jy[#jy+1]=i6;if iA~=""then jy[#jy+1]=iA end;if iU~=""then jy[#jy+1]=iU end;if iV~=""then jy[#jy+1]=iV end;jx(jy,ck)if ie()==0 or l then if dc then jE(jy,ai,aj,jF,jG,dc)else jE(jy,ai,aj,nW,jG,dc)end;if not iR()or m then if dc then jE(jy,ai,aj,jF,jG,dc)jU(jy,jV,jF,ai,aj,dc,bF(kn(cW)),cY)else jE(jy,ai,aj,nW,jG,dc)jU(jy,km,nW,ai,aj,dc,bF(nW),cY)end;k0(jy,ck,dc)ko(jy,cW,cY,ai,aj)end end;kD(jy,iT,kE,kF)kI(jy,kJ)kM(jy)lK(jy)if not iy and c0 then lC(jy)end;return jy end;function nO.HUDEpilogue(jy)jy[#jy+1]="</svg>"return jy end;function nO.ExtraData(jy)local n_=iP(1240)local o0=iQ(55)local o1=o0+10;local gD;local lq=iP;local lr=iQ;local o2=0;local iT=iS()if aW then iT=iT.."-VERTICAL"end;if F and not b3 and not b2 and cY>20 then iT=iT.."-COLLISION ON"end;if by~="Off"then iT="("..by..")-"..iT end;if b0 then iT="TB-"..iT end;if not bx then iT=iT.."-DeCoupled"end;local o3=lr(99)local o4=lr(80)local o5=lr(85)local o6=lr(31)local o7=0;local o8=0;local o9=cm>1000000 and ii(cm/1000000,2).."kT"or ii(cm/1000,2).."T"if ci then o2=bq else o2=bo end;local oa,ob=cy.computeDistanceAndTime(cY,0,cm,0,0,o2)if oa<0 then oa=0 end;o2=ii(o2/(cm*iq),2).."g"local oc=d:maxForceForward()gD=b.g()if gD>0.1 then o8=cm*gD;o8=ii(o8/(cm*iq),2).."g"o7=0.5*oc/gD;o7=o7>1000000 and ii(o7/1000000,2).."kT"or ii(o7/1000,2).."T"end;oc=ii(oc/(cm*iq),2).."g"local od=vec3(b.getWorldAcceleration()):len()/9.80665;gD=b.g()jy[#jy+1]=[[<g class="dim txt txtend size14">]]if ie()==1 and not l then n_=iP(1120)o0=iQ(55)o1=o0+10 elseif ci and I then local oe=iP(770)jy[#jy+1]=gK(lq(895),o3,"ATMO","")jy[#jy+1]=dq([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],lq(895),o5,lq(-80))jy[#jy+1]=gK(lq(815),o4,dq("%.1f%%",cj*100),"txtstart size20")end;if I then jy[#jy+1]=gK(lq(1025),o3,"GRAVITY","txtstart")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1025),o5,lq(80))jy[#jy+1]=gK(lq(1105),o4,dq("%.2fg",gD/9.80665),"size20")jy[#jy+1]=gK(lq(1125),o3,"ACCEL","txtstart")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1125),o5,lq(80))jy[#jy+1]=gK(lq(1205),o4,dq("%.2fg",od),"size20")jy[#jy+1]=gK(lq(695),o3,"BRK TIME","")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(695),o5,lq(-80))jy[#jy+1]=gK(lq(615),o4,dq("%s",im(ob)),"txtstart size20")jy[#jy+1]=gK(lq(635),lr(45),"TRIP","")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(635),lr(31),lq(-90))if lk then jy[#jy+1]=gK(lq(532),lr(23),dq("%s",im(lk)),"txtstart size20")end;jy[#jy+1]=gK(lq(795),o3,"BRK DIST","")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(795),o5,lq(-80))jy[#jy+1]=gK(lq(715),o4,dq("%s",il(oa)),"txtstart size20")jy[#jy+1]=gK(lq(1285),lr(45),"MASS","txtstart")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1285),lr(31),lq(90))jy[#jy+1]=gK(lq(1388),lr(23),dq("%s",o9),"size20")jy[#jy+1]=gK(lq(1220),o3,"THRUST","txtstart")jy[#jy+1]=dq([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],lq(1220),o5,lq(80))jy[#jy+1]=gK(lq(1300),o4,dq("%s",oc),"size20")jy[#jy+1]=gK(iP(960),iQ(175),iT,"pbright txtbig txtmid size20")end;jy[#jy+1]="</g>"end;local of=1-(a6*0.05+a7*0.05)function nO.FuelUsed(og)local oh;if og=="atmofueltank"then oh=dq("Atmo Fuel Used: %.1f L",ja[og]/(4*of))elseif og=="spacefueltank"then oh=dq("Space Fuel Used: %.1f L",ja[og]/(6*of))else oh=dq("Rocket Fuel Used: %.1f L",ja[og]/(0.8*of))end;return oh end;function nO.DrawOdometer(jy,c6,bj,c7)if bC~="INFO"then return jy end;local gD;local o7=0;local o8=0;local o2=0;local o9=cm>1000000 and ii(cm/1000000,2).." kTons"or ii(cm/1000,2).." Tons"if ci then o2=bq else o2=bo end;local oa,ob=cy.computeDistanceAndTime(cY,0,cm,0,0,o2)o2=ii(o2/(cm*iq),2).." g"local oc=d:maxForceForward()gD=b.g()if gD>0.1 then o8=cm*gD;o8=ii(o8/(cm*iq),2).." g"o7=0.5*oc/gD;o7=o7>1000000 and ii(o7/1000000,2).." kTons"or ii(o7/1000,2).." Tons"end;oc=ii(oc/(cm*iq),2).." g"if ie()==0 or l then local oi=iP(aw+10)local oj=iQ(ax+20)local ok=iP(aw+10+av/1.25)local na=25;jy[#jy+1]="<g class='txtstart size14 bright'>"jy[#jy+1]=gK(oi,oj,dq("BrkTime: %s",im(ob)))jy[#jy+1]=gK(ok,oj,dq("Trip: %.2f km",c6))jy[#jy+1]=gK(oi,oj+na,dq("Lifetime: %.2f kSU",bj/200000))jy[#jy+1]=gK(ok,oj+na,dq("BrkDist: %s",il(oa)))jy[#jy+1]=gK(oi,oj+na*2,"Trip Time: "..im(c7))jy[#jy+1]=gK(ok,oj+na*2,"Total Time: "..im(bk))jy[#jy+1]=gK(oi,oj+na*3,dq("Mass: %s",o9))jy[#jy+1]=gK(ok,oj+na*3,dq("Max Brake: %s",o2))jy[#jy+1]=gK(oi,oj+na*4,dq("Max Thrust: %s",oc))if gD>0.1 then jy[#jy+1]=gK(ok,oj+na*4,dq("Max Thrust Mass: %s",o7))jy[#jy+1]=gK(oi,oj+na*5,dq("Req Thrust: %s",o8))else jy[#jy+1]=gK(ok,oj+na*4,"Max Mass: n/a")jy[#jy+1]=gK(oi,oj+na*5,"Req Thrust: n/a")end;jy[#jy+1]=gK(ok,oj+na*5,cB.FuelUsed("atmofueltank"))jy[#jy+1]=gK(oi,oj+na*6,cB.FuelUsed("spacefueltank"))jy[#jy+1]=gK(ok,oj+na*6,cB.FuelUsed("rocketfueltank"))end;jy[#jy+1]="</g></g>"return jy end;function nO.DrawWarnings(jy)return kM(jy)end;function nO.DisplayOrbitScreen(jy)return lK(jy)end;function nO.DisplayMessage(jy,l7)if l7~="empty"then local hl=310;for ol in string.gmatch(l7,"([^\n]+)")do hl=hl+35;jy[#jy+1]=gK("50%",hl,ol,"msg")end end;if cb~=0 then c.setTimer("msgTick",cb)cb=0 end end;function nO.DrawDeadZone(jy)jy[#jy+1]=dq([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],au)end;function nO.UpdatePipe()if ci then iA=""return end;m_()end;function nO.DrawSettings(jy)local hk=iP(640)local hl=iQ(200)jy[#jy+1]=[[<g class="pbright txtvspd txtstart">]]local hO=0;for dQ,dC in pairs(iz)do hO=hO+1;jy[#jy+1]=gK(hk,hl,dQ..": "..dC.get())hl=hl+20;if hO%12==0 then hk=hk+iP(350)hl=iQ(200)end end;jy[#jy+1]=gK(iP(640),iQ(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")jy[#jy+1]="</g>"return jy end;local i3=iP(1770)local i4=iQ(350)local i2=iQ(15)local i1=iP(1370)local i7,om;function nO.DrawRadarInfo()i6=cE.GetRadarHud(i1,i2,i3,i4)end;function nO.DrawTanks()if aq~=0 and ar~=0 then iU=gK(aq,ar,"","txtstart pdim txtfuel")jb=ar;jc(aq,"Atmospheric ","ATMO",ct,j8,j9)jc(aq,"Space Fuel T","SPACE",cu,j6,j7)jc(aq,"Rocket Fuel ","ROCKET",cv,j4,j5)end end;function nO.DrawShield()local on=ia.getState()==1 and"Shield Active"or"Shield Disabled"local oo=b.getPvPTimer()local op=ia.getResistances()local oq="A: "..10+op[1]*100 .."% / E: "..10+op[2]*100 .."% / K:"..10+op[3]*100 .."% / T: "..10+op[4]*100 .."%"local hk,hl=as-60,at+30;local os=bF(0.5+ia.getShieldHitpoints()*100/ia.getMaxShieldHitpoints())local jq=bF(os*2.55)local jr=dq("rgb(%d,%d,%d)",255-jq,jq,0)local js=""iV=gK(hk,hl,"","txtmid pdim txtfuel")if os<10 and on~="Shield Disabled"then js="red "end;oo=oo>0 and"   PvPTime: "..im(oo)or""iV=iV..dq([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],hk,hl,jr,os*2,hk,hl,hk+2,hl+10,os,oo)iV=iV..gK(hk,hl-5,on,js.."txtstart pbright txtbig")iV=iV..gK(hk,hl+30,oq,js.."txtstart pbright txtsmall")end;function nO.hudtick()if not iO then return end;local function ot(jy)local ju=bF(dr(cc/(cr/4)*255,0,255))jy[#jy+1]=dq("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",c9,ca,bF(bI+0.5)+ju,bF(bK+0.5)-ju,bF(bJ+0.5)-ju)end;local function ou()for dV,dC in pairs(ir)do if dC.hovered then if not dC.drawCondition or dC.drawCondition(dC)then dC.toggleFunction(dC)end;dC.hovered=false end end;for dV,dC in pairs(iu)do if dC.hovered then bC=dC.label;dC.hovered=false end end end;local function ov()local function ow(ox,oy,hk,hl,n9,na)if ox>=hk and ox<=hk+n9 and oy>=hl and oy<=hl+na then return true else return false end end;local hk=c9+cr/2;local hl=ca+cs/2;for dV,dC in pairs(ir)do dC.hovered=ow(hk,hl,dC.x,dC.y,dC.width,dC.height)end;for dV,dC in pairs(iu)do dC.hovered=ow(hk,hl,dC.x,dC.y,dC.width,dC.height)end;if df then local mP=false;for dV,eJ in ipairs(nK)do if eJ.hovered then mP=true;break end end;if nH.hovered then mP=true end;df=mP else df=nH.hovered;if not df then dg=bh end end end;local function oz(jy)if not bC or bC==""then bC="HELP"end;if x then for dQ,dC in pairs(iu)do local js="dim brightstroke"local oA=0.2;if bC==dQ then js="pbright dimstroke"oA=0.6 end;local oB=""if dC.hovered then oA=0.8;oB=";stroke:white"end;jy[#jy+1]=dq([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],dC.width,dC.height,dC.x,dC.y,js,oA,oB)jy[#jy+1]=gK(dC.x+dC.width/2,dC.y+dC.height/2+5,dC.label,"txt txtmid pdim")end end end;local function oC(jy)local function oD(jy,oE,hover,hk,hl,fp,oF,oG,oH,oI,oJ,nL)if type(oI)=="function"then oI=oI(nL)end;if type(oJ)=="function"then oJ=oJ(nL)end;jy[#jy+1]=dq("<rect x='%f' y='%f' width='%f' height='%f' fill='",hk,hl,fp,oF)if oE then jy[#jy+1]=dq("%s'",oG)else jy[#jy+1]=oH end;if hover then jy[#jy+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",ac,ad,ae)else jy[#jy+1]=dq(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",ii(ac*0.5,0),ii(ad*0.5,0),ii(ae*0.5,0))end;jy[#jy+1]=" rx='5'></rect>"jy[#jy+1]=dq("<text x='%f' y='%f' font-size='24' fill='",hk+fp/2,hl+oF/2+5)if oE then jy[#jy+1]="black"else jy[#jy+1]="white"end;jy[#jy+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if oE then jy[#jy+1]=dq("%s</text>",oI)else jy[#jy+1]=dq("%s</text>",oJ)end end;local oK=dq("rgb(%d,%d,%d)'",ii(ac*0.1,0),ii(ad*0.1,0),ii(ae*0.1,0))local oL=dq("rgb(%d,%d,%d)",ii(ac*0.8,0),ii(ad*0.8,0),ii(ae*0.8,0))local oM=oD;for dV,dC in pairs(ir)do local ne=dC.disableName;local nd=dC.enableName;if type(ne)=="function"then ne=ne(dC)end;if type(nd)=="function"then nd=nd(dC)end;if not dC.drawCondition or dC.drawCondition(dC)then oM(jy,dC.toggleVar(dC),dC.hovered,dC.x,dC.y,dC.width,dC.height,oL,oK,ne,nd,dC)end end end;local oN=ii(cr/2,0)local oO=ii(cs/2,0)local jy={}cB.HUDPrologue(jy)if x then cB.UpdateHud(jy)else if B then cB.DrawVerticalSpeed(jy,ck)end;cB.DrawWarnings(jy)end;if iy and iz~="none"then cB.DrawSettings(jy)end;if radar_1 then cB.DrawRadarInfo()end;cB.HUDEpilogue(jy)jy[#jy+1]=dq([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],cr,cs)if c1~="empty"then cB.DisplayMessage(jy,c1)end;if ie()==0 and g=="virtual joystick"then if w then cB.DrawDeadZone(jy)end end;oz(jy)if ih()==0 then if ie()==1 and c0 then if not oP then ov()oC(jy)end;if not cG and not cH then local oQ=table.concat(jy,"")jy={}jy[#jy+1]=dq("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jy[#jy+1]=oQ;jy[#jy+1]="</body>"cG=true;jy[#jy+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)local oR=table.concat(jy,"")a.setScreen(oR)elseif cH then local oQ=table.concat(jy,"")jy={}jy[#jy+1]=dq("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",cr,cs)jy[#jy+1]=oQ;jy[#jy+1]="</body>"end;if not cG then jy[#jy+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oN,oO,c9,ca)end else ou()end else if not c0 and ie()==0 then ou()if cc>au then if w then ot(jy)end end elseif c0 and(not oP or not i)then ov()oC(jy)end;jy[#jy+1]=dq([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],oN,oO,c9,ca)end;jy[#jy+1]=[[</svg></body>]]oR=table.concat(jy,"")end;function nO.TenthTick()local function oS()local oT=a.createData;local oU=a.createWidget;oV=a.createWidgetPanel("Interplanetary Helper")oW=oU(oV,"value")oX=oT('{"label": "Target Planet", "value": "N/A", "unit":""}')f_(oX,oW)oY=oU(oV,"value")oZ=oT('{"label": "distance", "value": "N/A", "unit":""}')f_(oZ,oY)gr=oU(oV,"value")gq=oT('{"label": "Travel Time", "value": "N/A", "unit":""}')f_(gq,gr)gp=oU(oV,"value")go=oT('{"label": "Maximum Mass", "value": "N/A", "unit":""}')f_(go,gp)gt=oU(oV,"value")gs=oT('{"label": "Target Altitude", "value": "N/A", "unit":""}')f_(gs,gt)gl=oU(oV,"value")gk=oT('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')gj=oU(oV,"value")gi=oT('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')gh=oU(oV,"value")gg=oT('{"label": "Max Brake distance", "value": "N/A", "unit":""}')gf=oU(oV,"value")ge=oT('{"label": "Max Brake Time", "value": "N/A", "unit":""}')gn=oU(oV,"value")gm=oT('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not ci then f_(gk,gl)f_(gi,gj)f_(gg,gh)f_(ge,gf)f_(gm,gn)end end;local function o_()gJ(oV)oV=nil end;local function p0()if not a_ then if ga==nil or ga.planetname~=iO.name then p1=(c5.center-d0):len()else p1=(ga.position-d0):len()end end;local fw=cY;local p2=c.getThrottle()/100;if u then p2=bL end;local p3,p4=cy.computeDistanceAndTime(cY,a0,cm,d:maxForceForward()*p2,a2,0)local c3,c4;if not b0 then c3,c4=cD.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cD.GetAutopilotTBBrakeDistanceAndTime(a0)end;local dV,p5;if not b0 and fw>0 then dV,p5=cD.GetAutopilotBrakeDistanceAndTime(fw)else dV,p5=cD.GetAutopilotTBBrakeDistanceAndTime(fw)end;local p6=0;local p7=0;if ba or not a_ and fw>5 then p7=cy.computeTravelTime(fw,0,p1)elseif c3+p3<p1 then p6=p1-(c3+p3)p7=cy.computeTravelTime(8333.0556,0,p6)else local p8=(p1-c3)/p3;p3=p1-c3;p4=p4*p8 end;if ga~=nil and ga.planetname==iO.name and not a_ then return p7 elseif b9 then return p5 elseif ba then return p7+p5 else return p4+c4+p7 end end;cB.DrawTanks()if ia then cB.DrawShield()end;if bf~="None"then if oV==nil then oS()end;if bf~=nil then local p9=ga~=nil;local pa=0.5*bq/c5:getGravity(c5.center+vec3(0,0,1)*c5.radius):len()pa=pa>1000000 and ii(pa/1000000,2).." kTons"or ii(pa/1000,2).." Tons"fZ(oX,'{"label": "Target", "value": "'..bf..'", "unit":""}')lk=p0()if p9 and not a_ then cc=(d0-ga.position):len()else cc=(bg-d0):len()end;if not b0 then c3,c4=cD.GetAutopilotBrakeDistanceAndTime(cY)iC,iD=cD.GetAutopilotBrakeDistanceAndTime(a0)else c3,c4=cD.GetAutopilotTBBrakeDistanceAndTime(cY)iC,iD=cD.GetAutopilotTBBrakeDistanceAndTime(a0)end;local l7=il(cc)fZ(oZ,'{"label": "distance", "value": "'..l7 ..'"}')fZ(gq,'{"label": "Travel Time", "value": "'..im(lk)..'", "unit":""}')l7=il(c3)fZ(gk,'{"label": "Cur Brake distance", "value": "'..l7 ..'"}')fZ(gi,'{"label": "Cur Brake Time", "value": "'..im(c4)..'", "unit":""}')l7=il(iC)fZ(gg,'{"label": "Max Brake distance", "value": "'..l7 ..'"}')fZ(ge,'{"label": "Max Brake Time", "value": "'..im(iD)..'", "unit":""}')fZ(go,'{"label": "Max Brake Mass", "value": "'..dq("%s",pa)..'", "unit":""}')l7=il(gu)fZ(gs,'{"label": "Target Orbit", "value": "'..l7 ..'"}')if cj>0 and not pb then a.removeDataFromWidget(ge,gf)a.removeDataFromWidget(gg,gh)a.removeDataFromWidget(gi,gj)a.removeDataFromWidget(gk,gl)a.removeDataFromWidget(gm,gn)pb=true;if not d4 and u and(b1 or b4 or cg)then cD.cmdThrottle(1)aX=false;bP=false end end;if cj==0 and pb then if fZ(ge,gf)==1 then f_(ge,gf)end;if fZ(gg,gh)==1 then f_(gg,gh)end;if fZ(gi,gj)==1 then f_(gi,gj)end;if fZ(gk,gl)==1 then f_(gk,gl)end;if fZ(gm,gn)==1 then f_(gm,gn)end;pb=false end end else o_()end;if warpdrive~=nil then if ic(warpdrive.getData()).destination~="Unknown"and ic(warpdrive.getData()).distance>400000 then warpdrive.show()pc=true else warpdrive.hide()pc=false end end end;function nO.OneSecondTick()local function pd()local jm=bE()local kJ=cY;local pe=jm-cl;if kJ>1.38889 then kJ=kJ/1000;local pf=kJ*(jm-cl)bj=bj+pf;c6=c6+pf end;c7=c7+pe;bk=bk+pe;cl=jm end;local function pg(jy)local ph=0;iE=""local pi=ip;local pj=0;local pk=0;local pl=0;local jq=0;local jr=""local pm=b.getElementHitPointsById;local pn=b.getElementMaxHitPointsById;local po={}for dQ in pairs(io)do local pp=0;local pq=0;pq=pn(io[dQ])pp=pm(io[dQ])pj=pj+pp;if pp<pq then if pp==0 then pl=pl+1 else pk=pk+1 end;if cw and#po==0 then g2=vec3(b.getElementPositionById(io[dQ]))local hk=g2.x;local hl=g2.y;local hm=g2.z;table.insert(po,b.spawnArrowSticker(hk,hl,hm+1,"down"))table.insert(po,b.spawnArrowSticker(hk,hl,hm+1,"down"))b.rotateSticker(po[2],0,0,90)table.insert(po,b.spawnArrowSticker(hk+1,hl,hm,"north"))table.insert(po,b.spawnArrowSticker(hk+1,hl,hm,"north"))b.rotateSticker(po[4],90,90,0)table.insert(po,b.spawnArrowSticker(hk-1,hl,hm,"south"))table.insert(po,b.spawnArrowSticker(hk-1,hl,hm,"south"))b.rotateSticker(po[6],90,-90,0)table.insert(po,b.spawnArrowSticker(hk,hl-1,hm,"east"))table.insert(po,b.spawnArrowSticker(hk,hl-1,hm,"east"))b.rotateSticker(po[8],90,0,90)table.insert(po,b.spawnArrowSticker(hk,hl+1,hm,"west"))table.insert(po,b.spawnArrowSticker(hk,hl+1,hm,"west"))b.rotateSticker(po[10],-90,0,90)table.insert(po,io[dQ])end elseif cw and#po>0 and po[11]==io[dQ]then for jl in pairs(po)do b.deleteSticker(po[jl])end;po={}end end;ph=bF(pj/pi*100)if ph<100 then jy[#jy+1]=gK(0,0,"","pbright txt")jq=bF(ph*2.55)jr=dq("rgb(%d,%d,%d)",255-jq,jq,0)if ph<100 then jy[#jy+1]=gK("50%",1035,"Elemental Integrity: "..ph.."%","txtbig txtmid","fill:"..jr)if pl>0 then jy[#jy+1]=gK("50%",1055,"Disabled Modules: "..pl.." Damaged Modules: "..pk,"txtbig txtmid","fill:"..jr)elseif pk>0 then jy[#jy+1]=gK("50%",1055,"Damaged Modules: "..pk,"txtbig txtmid","fill:"..jr)end end end end;local function pr()if ib then if iF==nil and(dn~=nil or bi)then _autoconf.displayCategoryPanel(ib,weapon_size,"Weapons","weapon",true)iF=_autoconf.panels[_autoconf.panels_size]elseif iF~=nil and dn==nil and not bi then gJ(iF)iF=nil end end end;dh=b.getPlayersOnBoard()di=b.getDockedConstructs()local jy={}pd()if s then pg(jy)end;pr()cB.UpdatePipe()cB.ExtraData(jy)cd=table.concat(jy,"")collectgarbage("collect")end;function nO.AnimateTick()cH=true;cG=false;c9=0;ca=0;c.stopTimer("animateTick")end;function nO.MsgTick()local jy={}cB.DisplayMessage(jy,"empty")c1="empty"c.stopTimer("msgTick")cb=3 end;function nO.ButtonSetup()np()nu()ir=is end;return nO end;local function ps(d,b,c,a,e,vBooster,hover,pt,antigrav,warpdrive,dbHud_1,f4,bF,bG,ie,e_,bE,dr,ig,fZ,ih,dt,ii,g0,ij,du,il,im,pu,ic,dq,f_)local pv={}local function pw(fw)local px=bb;if not a_ then px=0 end;if not ci then return cy.computeDistanceAndTime(fw,px,cm,0,0,bo-bd*cm)else if bq and bq>0 then return cy.computeDistanceAndTime(fw,px,cm,0,0,bq-bd*cm)else return 0,0 end end end;local function py(fw)local px=bb;if not a_ then px=0 end;return cy.computeDistanceAndTime(fw,px,cm,d:maxForceForward(),a2,bo-bd*cm)end;local pz=false;local pA=0;local pB=0;local pC=0;local pD=bE()local pE=0;local pF=0;local pG=0;local pH=0;local pI=false;local pJ=false;local pK=false;local pL=nil;local pM=0;local pN={}local iB=55;local pO=nil;local pP=""function pv.GetAutopilotBrakeDistanceAndTime(fw)return pw(fw)end;function pv.GetAutopilotTBBrakeDistanceAndTime(fw)return py(fw)end;local function pQ(pR,pS,pT)pS=pS:project_on_plane(pR)pT=pT:project_on_plane(pR)return e_(pS:cross(pT):dot(pR),pS:dot(pT))end;local function pU()local function pV()local pW=-1;local pX=-1;if vBooster then pW=vBooster.getDistance()end;if hover then pX=hover.getDistance()end;if pW~=-1 and pX~=-1 then if pW<pX then return pW else return pX end elseif pW~=-1 then return pW elseif pX~=-1 then return pX else return-1 end end;local pY=pV()local pZ=-1;if pt then pZ=pt.getDistance()end;if pY~=-1 and pZ~=-1 then if pY<pZ then return pY else return pZ end elseif pY~=-1 then return pY else return pZ end end;local function p_(iO,eR,q0)local function q1(q2,e1)local eX=vec3(e1)if q2.id==0 then return setmetatable({latitude=eX.x,longitude=eX.y,altitude=eX.z,id=0,systemId=q2.systemId},e3)end;local eY=eX-q2.center;local cc=eY:len()local e9=cc-q2.radius;local e7=0;local e8=0;if not du(cc,0)then local eZ=e_(eY.y,eY.x)e8=eZ>=0 and eZ or 2*math.pi+eZ;e7=math.pi/2-math.acos(eY.z/cc)end;return setmetatable({latitude=math.deg(e7),longitude=math.deg(e8),altitude=e9,id=q2.id,systemId=q2.systemId},e3)end;local q3=q1(iO,eR)q3="::pos{"..q3.systemId..","..q3.id..","..q3.latitude..","..q3.longitude..","..q3.altitude.."}"if q0 then return q3 else a.setWaypoint(q3)return true end end;local q4=false;function pv.showWayPoint(iO,eR,q0)return p_(iO,eR,q0)end;function pv.APTick()local function q5()if de and not b2 then local ey=de[1]local hT,hU=de[2],de[3]local q6=math.min(hT,hU or hT)local q7=q6/cY;local q8=b3 and(cY<42 or ch~=-1)local q9=b1 or bm or bp or a_;if q9 and not q8 and(c3*1.5>q6 or q7<1)then aX=true;pN={}cD.cmdThrottle(0)if b1 then cD.ToggleAltitudeHold()end;if bp then cD.ToggleLockPitch()end;c1="Autopilot Cancelled due to possible collision"if bm or a_ then cD.ToggleAutopilot()end;le=true;b2=true;cI=true end;if q7<11 then dd=ey.name.." COLLISION "..im(q7).." / "..il(q6,2)else dd=ey.name.." collision "..im(q7)end;if q7<6 then g0("alarm","AL",2)end else dd=false end end;local function qa(qb,qc,qd)local function qe(qb,eA)qb=vec3(qb)eA=vec3(eA):normalize()local dL=qb*eA;return dL.x+dL.y+dL.z end;local qf=0.001;local qg=1;if not ci or not cJ or ch~=-1 or cY<iB then if qd==nil then qd=aO end;if qc==nil then qc=qf end;qb=vec3(qb):normalize()local qh=vec3()-qb;local qi=-qe(qh,b.getConstructWorldOrientationRight())*qg;local qj=-qe(qh,b.getConstructWorldOrientationUp())*qg;if pB==0 then pB=qi/2 end;if pC==0 then pC=qj/2 end;if f4(qi)<0.1 then bV=bV-qi*2 else bV=bV-(qi+(qi-pB)*qd)end;if f4(qj)<0.1 then bU=bU+qj*2 else bU=bU+qj+(qj-pC)*qd end;pB=qi;pC=qj;if f4(qi)<qc and f4(qj)<qc then return true end;return false elseif cJ and ch==-1 then qb=cX;if qd==nil then qd=aO end;if qc==nil then qc=qf end;qb=vec3(qb):normalize()local qh=cU-qb;local qi=-qe(qh,b.getConstructWorldOrientationRight())*qg;local qj=-qe(qh,b.getConstructWorldOrientationUp())*qg;if pB==0 then pB=qi/2 end;if pC==0 then pC=qj/2 end;if f4(qi)<0.1 then bV=bV-qi*5 else bV=bV-(qi+(qi-pB)*qd)end;if f4(qj)<0.1 then bU=bU+qj*5 else bU=bU+qj+(qj-pC)*qd end;pB=qi;pC=qj;if f4(qi)<qc and f4(qj)<qc then return true end;return false end end;ci=bG()>0;cj=bG()ck=b.getAltitude()ch=pU()bH=bE()pD=bH;if F then q5()end;if antigrav then d2=antigrav.getState()==1 end;local qk=a.getMouseWheel()if qk>0 then cD.changeSpd()elseif qk<0 then cD.changeSpd(true)else cn=true end;local ql=1;local qm=1;local qn=bH-pD;local qo=-math.deg(pQ(cT,cX,cU))local qp=math.deg(pQ(cV,cX,cU))local gw=cZ*-1;cJ=ci and qo<-M or qo>M or qp<-N or qp>N;local qq=a.getMouseDeltaX()local qr=a.getMouseDeltaY()if o and not c0 then qr=-qr end;bV=0;bZ=0;bU=0;g3=cx[0]iO=g3:closestBody(b.getConstructWorldPos())qs=cA(iO)fA=qs:orbitalParameters(b.getConstructWorldPos(),cX)if ck==0 then ck=(d0-iO.center):len()-iO.radius end;dc=c.getClosestPlanetInfluence()>0 or ck>0 and ck<200000;local gD=iO:getGravity(b.getConstructWorldPos()):len()*cm;cK=0;cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]if ih()==0 then if ie()==1 and c0 then if not cG then c9=dr(c9+qq,-cr/2,cr/2)ca=dr(ca+qr,-cs/2,cs/2)end else c9=0;ca=0 end else c9=dr(c9+qq,-cr/2,cr/2)ca=dr(ca+qr,-cs/2,cs/2)cc=dt(c9*c9+ca*ca)if not c0 and ie()==0 then local kv,kw=1,1;if bC=="SCOPE"then kv,kw=dk/90,dk/90 end;if g=="virtual joystick"then if c9>0 and c9>au then bV=bV-(c9-au)*aC*kv elseif c9<0 and c9<au*-1 then bV=bV-(c9+au)*aC*kv else bV=0 end;if ca>0 and ca>au then bU=bU-(ca-au)*aD*kw elseif ca<0 and ca<au*-1 then bU=bU-(ca+au)*aD*kw else bU=0 end else c9=0;ca=0;if g=="mouse"then bU=(-utils.smoothstep(qr,-100,100)+0.5)*2*ql;bV=(-utils.smoothstep(qq,-100,100)+0.5)*2*qm end end end end;local qt=cY>8334;if cY>W/3.6 and not ci and not a_ and not qt then c1="Space Speed Engine Shutoff reached"cD.cmdThrottle(0)end;if not qt and qu then if not aX then cD.BrakeToggle()end;if a_ then cD.ToggleAutopilot()end end;qu=qt;if ci and cj>0.09 then if cY>cL/3.6 and not u and not pz then aX=true;pz=true elseif not u and pz then if cY<cL/3.6 then aX=false;pz=false end end end;if aX then bY=1 else bY=0 end;if aZ then if ce then aX=false;local qv=false;if ga and ce==true then qv=qa(ga.position-d0,0.1)else qv=qa(vec3(cX),0.01)end;cI=true;if qv then cD.cmdCruise(bF(cL))if(f4(d6)<2 or f4(d5)>85)and cY>=cL/3.6-1 then aX=false;aZ=false;if ce~=2 then bR=true end;if ce==true then cg=true end;ce=false;a_=false;cD.BeginReentry()end elseif ci and u then cD.cmdThrottle(1)end elseif cY>iB then qa(vec3(cX),0.01)end end;if aY then if ci then aY=false elseif cY>iB then qa(-vec3(cX))end end;if not aZ and ce and not bv then if cj==0 then if ce~=2 then bR=true end;cD.BeginReentry()ce=false;cg=true else ce=false;cD.ToggleAutopilot()end end;if cg and ga and(ck<b6+250 and ck>b6-250)and cY*3.6>cL-250 and f4(c_)<25 and cj>=0.1 and(ga.position-d0):len()>2000+ck then cD.ToggleAutopilot()cg=false end;if b5 then cI=true;local qw=b6;if c_<-30 then c1="Unable to achieve lift. Safety Landing."c8=0;cI=p;b5=false;b2=true elseif not q and d2 or b6<iO.spaceEngineMinAltitude then if d2 then qw=antigrav.getBaseAltitude()end;if ck<qw-100 then cM=0;c8=15;aX=false elseif c_>0 then aX=true;c8=0 elseif c_<-30 then aX=true;c8=15 elseif ck>=qw then if d2 then if a_ or bm then cD.ToggleVerticalTakeoff()else aX=true;b5=false end;c1="Takeoff complete. Singularity engaged"g0("aggLk","AG")else aX=false;c1="VTO complete. Engaging Horizontal Flight"g0("vtoc","VT")cD.ToggleVerticalTakeoff()end;c8=0 end else if cj>0.08 then cM=0;aX=false;c8=20 elseif cj<0.08 and cj>0 then aX=false;if cR then cM=0;c8=20 else c8=0;cM=36;cD.cmdCruise(3500)end else cI=p;bv=true;cQ=false;qx=false;pI=false;pG=nil;pH=nil;if pL==nil then pL=iO end;cP=qw;pK=true;b5=false end end;if cM~=nil then if qy==nil then qy=pid.new(2*0.01,0,2*0.1)end;local qz=dr(cM-d5,-N*0.80,N*0.80)qy:inject(qz)local qA=dr(qy:get(),-1,1)bU=qA end end;if bv then local qh;local qB=false;local qC=il(cP)if pL==nil then pL=iO;if bm then pL=c5 end end;if not pK then cP=bF(pL.radius+pL.surfaceMaxAltitude+U)if pL.hasAtmosphere then cP=bF(pL.radius+pL.noAtmosphericDensityAltitude+U)end;pK=true end;if cO.VectorToTarget and ga then qh=ga.position-d0 end;local qD,qE=cA(pL):escapeAndOrbitalSpeed((d0-pL.center):len()-pL.radius)local qF=d6;if not pI then local qG=false;local qH=false;cD.cmdThrottle(0)pH=0;cN="Aligning to orbital path - OrbitHeight: "..qC;if cO.VectorToTarget then qa(qh:normalize():project_on_plane(cZ))qB=cU:dot(qh:project_on_plane(cT):normalize())>0.95 else qa(cX)qB=qo<0.5;if cY<150 then qB=true end end;bU=0;pG=0;if d5<=pG+1 and d5>=pG-1 then qG=true else qG=false end;if qF<=pH+1 and qF>=pH-1 then qH=true else qH=false end;if qG and qH and qB then pG=nil;pH=nil;pI=true end else if cO.VectorToTarget then qa(qh:normalize():project_on_plane(cZ))elseif cY>150 then qa(cX)end;bU=0;if cO.VectorToTarget and ga then local c3,dV=cy.computeDistanceAndTime(cY,cL/3.6,cm,0,0,bo)if cQ and qh:len()>15000+c3+ck then cN="Orbiting to Target"if ck-100<=pL.noAtmosphericDensityAltitude or lk>fA.timeToPeriapsis and fA.periapsis.altitude<pL.noAtmosphericDensityAltitude then cQ=false end elseif cQ or qh:len()<15000+c3+ck then c1="Orbit complete, proceeding with reentry"g0("orCom","OB")bg=ga.position;bR=true;cg=true;cO.VectorToTarget,cO.AutopilotAlign=false,false;cD.ToggleIntoOrbit()cD.BeginReentry()return end end;if fA.periapsis~=nil and fA.apoapsis~=nil and fA.eccentricity<1 and ck>cP*0.9 and ck<cP*1.4 then if fA.apoapsis~=nil then if fA.periapsis.altitude>=cP*0.99 and fA.apoapsis.altitude>=cP*0.99 and fA.periapsis.altitude<fA.apoapsis.altitude and fA.periapsis.altitude*1.05>=fA.apoapsis.altitude or cQ then if cQ then aX=false;cD.cmdThrottle(0)pG=0;if not cO.VectorToTarget then c1="Orbit complete"g0("orCom","OB")cD.ToggleIntoOrbit()end else pM=pM+1;if pM>=2 then cQ=true end end else cN="Adjusting Orbit - OrbitHeight: "..qC;pJ=true;cD.cmdCruise(qE*3.6+1)local qI=cP-ck;if qJ==nil then qJ=pid.new(0.1,0,1*0.1)end;qJ:inject(qI-c_*dr(utils.smoothstep(2000-qI,-2000,2000)^6*10,1,10))pG=dr(qJ:get(),-60,60)end end else local qK=2.75;local qL=f4(ii(qD*qK))local of=qL%50;if of>0 then qL=qL-of+50 end;aX=false;if ck<cP*0.8 then cN="Escaping planet gravity - OrbitHeight: "..qC;pG=utils.map(c_,200,0,-15,80)elseif ck>=cP*0.8 and ck<cP*1.15 then cN="Approaching orbital corridor - OrbitHeight: "..qC;qL=qL*0.75;pG=utils.map(c_,100,-100,-15,65)elseif ck>=cP*1.15 and ck<cP*1.5 then cN="Approaching orbital corridor - OrbitHeight: "..qC;qL=qL*0.75;if c_<0 or pJ then pG=utils.map(ck,cP*1.5,cP*1.01,-30,0)else pG=utils.map(ck,cP*0.99,cP*1.5,0,30)end elseif ck>cP*1.5 then cN="Reentering orbital corridor - OrbitHeight: "..qC;pG=-65;local qM=utils.map(c_,-150,-400,1,0.55)qL=qL*qM end;cD.cmdCruise(bF(qL))end end;if pG~=nil then if qN==nil then qN=pid.new(1*0.01,0,5*0.1)end;local qO=pG-d5;qN:inject(qO)local qP=dr(qN:get(),-0.5,0.5)bU=qP end end;if a_ and cj==0 and not ce then local function qQ(i7,fA)a.print(i7)aX=false;b9=false;a_=false;qR=false;bc="Aligning"cD.cmdThrottle(0)bQ=false;c1=i7;g0("apCom","AP")if fA or ce then if fA and gu~=nil and not ce then if not ck or ck==0 then return end;cP=ck;pK=true end;cD.ToggleIntoOrbit()end end;local qS,qT=bg,false;if ga and ga.planetname~="Space"then b8=true;if not qR then local qU=(ga.position-c5.center):normalize()local qV=qU:project_on_plane((c5.center-d0):normalize()):normalize()local qW=c5.center+qV*(c5.radius+gu)local qX=ga.position+(ga.position-c5.center):normalize()*(gu-c5:getAltitude(ga.position))if(d0-qW):len()<(d0-qX):len()then qS=qW else qS=qX;bb=0 end;bg=qS;cD.showWayPoint(c5,bg)qT=true;qR=true end;bd=0 elseif ga and ga.planetname=="Space"then if not qR then bd=0;qT=true;b8=true;qR=true;qS=ga.position+(d0-ga.position):normalize()*S;bg=qS end elseif ga==nil then bd=0;if not qR then local qU=(d0+cX*100000-c5.center):normalize()local qV=qU:project_on_plane((c5.center-d0):normalize()):normalize()if qV:len()<1 then qU=(d0+cU*100000-c5.center):normalize()qV=qU:project_on_plane((c5.center-d0):normalize()):normalize()end;qS=c5.center+qV*(c5.radius+gu)bg=qS;qR=true;qT=true;b8=true;cD.showWayPoint(c5,bg)end end;p1=(vec3(qS)-d0):len()local li,eP,eQ=cx:getPlanetarySystem(0):castIntersections(d0,cX:normalize(),function(ey)if ey.noAtmosphericDensityAltitude>0 then return ey.radius+ey.noAtmosphericDensityAltitude else return ey.radius+ey.surfaceMaxAltitude*1.5 end end)local lj=eP;if eQ~=nil and eP~=nil then lj=math.min(eQ,eP)end;if lj~=nil and lj<p1 and li.name==c5.name then p1=lj end;local qv=true;local qY=(c5.center-(d0+vec3(cX):normalize()*p1)):len()-c5.radius;local l7=il(qY)fZ(gm,'{"label": "Projected Altitude", "value": "'..l7 ..'"}')local c3,c4;if not b0 then c3,c4=pw(cY)else c3,c4=py(cY)end;if cY>50 and b7 then local qh=vec3(qS)-d0;local qZ=dr(math.deg(pQ(cT,cX:normalize(),qh:normalize()))*cY/500,-90,90)local q_=dr(math.deg(pQ(cV,cX:normalize(),qh:normalize()))*cY/500,-90,90)if f4(qZ)<20 and f4(q_)<20 then qZ=qZ*2;q_=q_*2 end;if f4(qZ)<2 and f4(q_)<2 then qZ=qZ*2;q_=q_*2 end;local qo=-math.deg(pQ(cT,cU,cX:normalize()))local qp=-math.deg(pQ(cV,cU,cX:normalize()))if r0==nil then r0=pid.new(2*0.01,0,2*0.1)end;r0:inject(q_-qp)local r1=dr(r0:get(),-1,1)bU=bU+r1;if r2==nil then r2=pid.new(2*0.01,0,2*0.1)end;r2:inject(qZ-qo)local r3=dr(r2:get(),-1,1)bV=bV+r3;qT=true;if f4(qZ)>2 or f4(q_)>2 then if bc~="Adjusting Trajectory"then bc="Adjusting Trajectory"g0("apAdj","AP")end else if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end end elseif b7 and cY<=50 then qa((qS-d0):normalize())end;if qY<gu*1.5 then if ga and ga.planetname=="Space"then bb=0 elseif ga==nil then dV,bb=cA(c5):escapeAndOrbitalSpeed(qY)end end;if a_ and not b7 and not ba and not b9 then local li,lj=cD.checkLOS((bg-d0):normalize())if c5.name~=iO.name then if li~=nil and c5.name~=li.name and lj<p1 then c1="Collision with "..li.name.." in "..il(lj).."\nClear LOS to continue."cb=5;q4=true else q4=false;c1=""end end end;if not q4 then if not ba and not b9 and not qT then qv=qa((qS-d0):normalize())elseif b0 and(b9 or ba)then qv=qa(-vec3(cX):normalize())end end;if b7 then if not bQ then aX=false;cD.cmdThrottle(a1)bL=ii(a1,2)bQ=true end;local p2=c.getThrottle()if u then p2=bL end;local r4=99999;local od=-vec3(b.getWorldAcceleration()):dot(cX:normalize())local r5=dr(cX:dot((qS-d0):normalize()),0,cY)if r5>0 or od>0 then r4=cy.computeTravelTime(r5,od,p1-c3)end;if cW:len()>=a0 or p2==0 and bQ or a2/4>r4 then b7=false;if bc~="Cruising"then g0("apCru","AP")bc="Cruising"end;ba=true;cD.cmdThrottle(0)end;local r6=p1;if r6<=c3 or H and d9<=c3+10000 and d8 then if H and d9<=c3+10000 and d8 then if d9<pA and d9>2000 then cD.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pA=d9 else pA=d9;return end end;b7=false;if bc~="Braking"then g0("apBrk","AP")bc="Braking"end;b9=true;cD.cmdThrottle(0)bQ=false end elseif b9 then if bc~="Orbiting to Target"then aX=true;bY=1 end;if b0 then cD.cmdThrottle(1,true)end;local dV,qE=cA(c5):escapeAndOrbitalSpeed((d0-iO.center):len()-iO.radius)local qh;if ga then qh=ga.position-d0 end;if ga and ga.planetname=="Space"and cY<50 then if#pN>0 then aX=false;cD.ToggleAutopilot()cD.ToggleAutopilot()return end;qQ("Autopilot complete, arrived at space location")aX=true;bY=1 elseif ga and ga.planetname~="Space"and cY<=qE and(fA.apoapsis==nil or fA.periapsis==nil or fA.apoapsis.altitude<=0 or fA.periapsis.altitude<=0)then qQ("Autopilot complete, commencing reentry")bg=ga.position;ce=true;cD.showWayPoint(c5,bg)elseif(ga and ga.planetname~="Space"or ga==nil)and fA.periapsis~=nil and fA.periapsis.altitude>0 and fA.eccentricity<1 or bc=="Circularizing"then if bc~="Circularizing"then g0("apCir","AP")bc="Circularizing"end;if cY<=qE then if ga then if cX:normalize():dot(qh:normalize())>0.4 then if bc~="Orbiting to Target"then g0("apOrb","OB")bc="Orbiting to Target"end;if not r7 then aX=false;cD.showWayPoint(c5,ga.position)r7=true end else qQ("Autopilot complete, proceeding with reentry")bg=ga.position;ce=true;cD.showWayPoint(c5,ga.position)r7=false end else qQ("Autopilot completed, setting orbit",true)bY=0 end end elseif bc=="Circularizing"then qQ("Autopilot complete, fixing Orbit",true)end elseif ba then local r6=p1;if r6<=c3 or H and d9<=c3+10000 and d8 then if H and d9<=c3+10000 and d8 then if d9<pA and d9>2000 then cD.ToggleAutopilot()c1="Autopilot cancelled to prevent crossing PvP Line"aX=true;pA=d9 else pA=d9;return end end;b7=false;if bc~="Braking"then g0("apBrk","AP")bc="Braking"end;b9=true end;local p2=c.getThrottle()if u then p2=bL end;if p2>0 then b7=true;if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end;ba=false end else if qv then if not b8 and ga==nil or not b8 and ga and ga.planetname~="Space"then if not ce then bg=vec3(c5.center)+(gu+c5.radius)*cV;r8=cT;r9=cV end;b8=true elseif qv and not q4 then b7=true;if bc~="Accelerating"then bc="Accelerating"g0("apAcc","AP")end;if not bQ then cD.cmdThrottle(a1,true)bL=ii(a1,2)bQ=true;aX=false end end end end elseif a_ and(ga~=nil and ga.planetname~="Space"and cj>0)then c1="Autopilot complete, starting reentry"g0("apCom","AP")bg=ga.position;aX=false;b9=false;a_=false;qR=false;bc="Aligning"bY=0;cD.cmdThrottle(0)bQ=false;aZ=true;ce=true;cD.showWayPoint(c5,ga.position)end;if b_ then cI=true;local q_=0;local fC=d0+vec3(c.getMasterPlayerRelativePosition())local ra=fC-d0;local rb=vec3(ra):project_on(cU):len()local rc=vec3(ra):project_on(cV):len()local cc=dt(rb*rb+rc*rc)qa(ra:normalize())local mq=40;local rd=cc<mq;local re=100;local rf=dr((cc-mq)/2,10,re)bU=0;local qv=f4(bV)<0.1;if qv and cY<rf and not rd then aX=false;q_=-20 else aX=true;q_=0 end;local rg=0;if f4(q_-d5)>rg then if rh==nil then rh=pid.new(2*0.01,0,2*0.1)end;rh:inject(q_-d5)local r1=rh:get()bU=r1 end end;if b1 or b2 or b4 or bm or bp~=nil then local ri=bq;if ri then ri=ri*dr(cY/100,0.1,1)*cj else ri=bo end;if cj<0.01 then ri=bo end;local rj=cU:project_on_plane(cZ):normalize():dot(cX)local rk=vec3(b.getWorldAirFrictionAcceleration())local rl=rk:len()*cm;if rj>100 then c3,c4=cy.computeDistanceAndTime(rj,100,cm,0,0,ri)local rm,rn=cy.computeDistanceAndTime(100,0,cm,0,0,ri*0.55)c3=c3+rm else c3,c4=cy.computeDistanceAndTime(rj,0,cm,0,0,ri*0.55)end;local qI=b6-ck-c_;local ro=200+cY;if b4 or ce then rp=2000+cY end;local rq=1;if b3 then rq=dr(cY/100,0.1,1)end;local q_=(utils.smoothstep(qI,-ro,ro)-0.5)*2*P*rq;if not b4 and not ce and not bm and cU:dot(cX:normalize())<0.99 then q_=(utils.smoothstep(qI,-ro*dr(20-19*cj*10,1,20),ro*dr(20-19*cj*10,1,20))-0.5)*2*P*dr(2-cj*10,1,2)*rq end;if not b1 then q_=0 end;if bp~=nil then if dc and not bv then q_=bp else bp=nil end end;cI=true;local rr=bU;if b4 then local rs=bF(cL)local rt,ru=cy.computeDistanceAndTime(cY,rs/3.6,cm,0,0,bo-iO.gravity*9.8*cm)rt=rt==-1 and 5000 or rt;local rv=ck-(iO.noAtmosphericDensityAltitude+rt)local rw=ck>iO.noAtmosphericDensityAltitude+rt*1.35;if rw then q_=Q;if cY<=rs/3.6 and cY>rs/3.6-10 and f4(cX:normalize():dot(cU))>0.9 and not d4 then bP=false;cD.cmdThrottle(1)end elseif(d4 or ig:getTargetSpeed(axisCommandId.longitudinal)~=rs)and not rw and not ci then cD.cmdCruise(rs,true)end;if d4 then if cY>rs/3.6 and not rw then aX=true else aX=false end else aX=false end;if c_>0 then aX=true end;if not bR then q_=-80;if ck<iO.surfaceMaxAltitude+(iO.atmosphereThickness-iO.surfaceMaxAltitude)*0.25 then c1="PARACHUTE DEPLOYED at "..ii(ck,0)b4=false;b2=true;le=true;cD.cmdThrottle(0)q_=0;cI=p end elseif iO.noAtmosphericDensityAltitude>0 and rw then cI=true elseif not rw then if not ci and(d4 or ig:getTargetSpeed(axisCommandId.longitudinal)~=rs)then cD.cmdCruise(rs)end;if cY<rs/3.6+1 then aX=false;bR=false;b4=false;cI=true end end end;if cY>iB and not cf and not bm and not b2 and v then qa(vec3(cX))end;if da or(bm or cf)and bh>0 and cj>0.01 then local qh;if da then if type(da)=="table"then qh=da elseif da<3 and da>0 then qh=-cZ:cross(cX)*5000 elseif da>=3 then qh=cZ:cross(cX)*5000 elseif da<0 then qh=cX*25000 end elseif ga~=nil then qh=ga.position-d0 else qh=c5.center-d0 end;local qZ=math.deg(pQ(cZ:normalize(),cX,qh))*2;local mt=math.rad(f4(d6))if cY>aH and cj>0.01 then local rx=1000+cY;local ry=(utils.smoothstep(qI-c_*10,-rx,rx)-0.5)*2*P;local rz=dr(90-ry,0,180)cK=dr(qZ*2,-rz,rz)local rA=qZ;qZ=dr(dr(qZ,-M*0.80,M*0.80)*math.cos(mt)+4*(d5-q_)*math.sin(math.rad(d6)),-M*0.80,M*0.80)local rB=1;if cK~=0 then rB=f4(mt/cK)end;rB=(90-dr(f4(cK-d6),0,90))/90;local rC=q_;if f4(d6)>90 then rC=-rC end;q_=rB*dr(dr(rC*math.cos(mt),-N*0.8,N*0.8)+f4(dr(f4(rA)*math.sin(mt),-N*0.80,N*0.80)),-N*0.80,N*0.80)else cK=0;qZ=dr(qZ,-M*0.80,M*0.80)end;local rD=qo-qZ;if da and f4(rD)<=0.0001 and(type(da)=="table"or type(da)~="table"and da<0 and f4(d6)<1)then if da==-2 then cD.ToggleAltitudeHold()end;da=nil;g0("180Off","BR")return end;if not cJ and cY>aH and cj>0.01 then if rE==nil then rE=pid.new(2*0.01,0,2*0.1)end;rE:inject(rD)local r3=dr(rE:get(),-1,1)bV=bV+r3 elseif ci and ch>-1 or cY<aH then qa(qh)elseif cJ and cj>0.01 then if(qo<-M or qo>M)and cj>0.01 then qa(cX)end;if(qp<-N or qp>N)and cj>0.01 then q_=dr(d5-qp,d5-N*0.80,d5+N*0.80)end end;if ga~=nil and not cf then local qw=iO:getAltitude(ga.position)local rv=qh:project_on_plane(cZ):len()le=true;if not cf and not b4 and rv<=c3 and(cX:project_on_plane(cZ):normalize():dot(qh:project_on_plane(cZ):normalize())>0.99 or lm=="Finalizing Approach")then lm="Finalizing Approach"if#pN>0 then cD.ToggleAutopilot()cD.ToggleAutopilot()return end;cD.cmdThrottle(0)if b1 then cD.ToggleAltitudeHold()bm=true end;aX=true elseif not b3 then aX=false end;if lm=="Finalizing Approach"and(rj<0.1 or rv<0.1 or rF~=nil and rF<rv)then if not d2 then g0("bklOn","BL")b2=true end;bm=false;lm="Proceeding to Waypoint"dd=false end;rF=rv end elseif bm and cj==0 and b6>iO.noAtmosphericDensityAltitude and not(cf or b4)then if ga~=nil and c5.name==iO.name then local qh=ga.position-d0;local qw=iO:getAltitude(ga.position)local rv=dt(qh:len()^2-(ck-qw)^2)local ri=bq;if ri then c3,c4=cy.computeDistanceAndTime(cY,0,cm,0,0,ri/2)le=true;if rv<=c3+cY*qn/2 and cX:project_on_plane(cZ):normalize():dot(qh:project_on_plane(cZ):normalize())>0.99 then if iO.hasAtmosphere then aX=false;aZ=false;bR=true;ce=false;cg=true;a_=false;cD.BeginReentry()end end;rF=rv end end end;if cj==0 and(b1 and b6>iO.noAtmosphericDensityAltitude)and not(cf or bv or b4)then if not cQ and not bv then cP=b6;pK=true;if bm then cO.VectorToTarget=true end;cD.ToggleIntoOrbit()bm=false;pI=true end end;if cJ and cj>0.01 and ch==-1 and cY>aH and lm~="Finalizing Approach"then qa(cX)q_=dr(d5-qp,d5-N*0.80,d5+N*0.80)end;bU=rr;local pZ=-1;if b2 then q_=0;local rG=false;local rH=30;if cz~=nil and cz>0 then local rI=dr(cj,0.4,2)local ri=bq*dr(cY/100,0.1,1)*rI;local rJ=cz*rI+ri-gD;local rK=ri/2-gD;local rL=cY-dt(f4(rK/2)*20/(0.5*cm))*utils.sign(rK)if rL<0 then rL=0 end;local rM;if cY>100 then local rN,dV=cy.computeDistanceAndTime(cY,100,cm,0,0,ri)local rO,dV=cy.computeDistanceAndTime(100,0,cm,0,0,dt(ri))rM=rN+rO else rM=cy.computeDistanceAndTime(cY,0,cm,0,0,dt(ri))end;if rM<20 then aX=false else local rP=0;if rL>100 then local rQ,dV=cy.computeDistanceAndTime(rL,100,cm,0,0,rJ)local rR,dV=cy.computeDistanceAndTime(100,0,cm,0,0,cz*rI+dt(ri)-gD)rP=rQ+rR else rP,dV=cy.computeDistanceAndTime(rL,0,cm,0,0,cz*rI+dt(ri)-gD)end;rP=(rP+15+cY*qn)*1.1;local rS=ga~=nil and iO:getAltitude(ga.position)>0 and ga.safe;if rS then local qw=iO:getAltitude(ga.position)local rT=ck-qw-100;local qh=ga.position-d0;local rU=dt(qh:len()^2-(ck-qw)^2)if rU>100 then rS=false elseif rT<=rP or rP==-1 then aX=true;rG=true else aX=false;rG=true end end;if not rS and t then if rP>=rH then aX=true else aX=false end;rG=true end end end;if not d4 then cD.cmdThrottle(0)end;ig:setTargetGroundAltitude(500)ig:activateGroundEngineAltitudeStabilization(500)bx=true;pZ=ch;if pZ>-1 then cI=p;if cY<1 or cX:normalize():dot(cZ)<0 then b2=false;b1=false;bi=true;if bS then d.control.extendLandingGears()g0("grOut","LG",1)end;ig:setTargetGroundAltitude(Z)c8=0;aX=true else aX=true end elseif le and cX:normalize():dot(-gw)<0.999 then aX=true elseif c_<-O and not rG then aX=true elseif not rG then aX=false end end;if b3 or cf then local li,eQ,eP;if bg~=nil then li,eQ,eP=cx:getPlanetarySystem(0):castIntersections(d0,(bg-d0):normalize(),function(ey)return ey.radius+ey.noAtmosphericDensityAltitude end)end;if d2 then if ck>=b6-50 then b3=false;if not a_ and not bm then aX=true;cD.cmdThrottle(0)end else b6=antigrav.getBaseAltitude()end elseif f4(q_)<15 and ck/b6>0.75 then b3=false;if not cf then if d4 and not u then d.control.cancelCurrentControlMasterMode()end elseif cf and cY<iB then a_=true;cf=false;b1=false;b3=false;cD.cmdThrottle(0)elseif cf then cD.cmdThrottle(0)aX=true end elseif cf and cj==0 and c5~=nil and(li==nil or li.name==c5.name)then a_=true;cf=false;b1=false;b3=false;if not d4 then cD.cmdThrottle(0)end;b7=true end end;local rV=ch>-1;local rW=d5;if(bm or cf or da)and not rV and cY>aH and cj>0.01 then local mt=math.rad(f4(d6))rW=d5*f4(math.cos(mt))+qp*math.sin(mt)end;local rX=dr(q_-rW,-N*0.80,N*0.80)if cj<0.01 and bm then rX=dr(q_-rW,-85,P)elseif cj<0.01 then rX=dr(q_-rW,-P,P)end;if f4(d6)<5 or bm or da or b2 or rV or b1 then if rh==nil then rh=pid.new(5*0.01,0,5*0.1)end;rh:inject(rX)local r1=rh:get()bU=bU+r1 end end;if antigrav~=nil and(antigrav and not q and ck<200000)then if br==nil or br<1000 then br=1000 end;if rY~=br then rY=br;antigrav.setBaseAltitude(rY)end end end;function pv.ToggleIntoOrbit()cQ=false;pG=nil;pH=nil;pM=0;if cj==0 then if bv then g0("orOff","AP")bv=false;pI=false;pL=nil;cI=p;if b1 then b1=false;b3=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pK=false elseif dc then g0("orOn","AP")bv=true;cI=true;if pL==nil then pL=iO end;if b1 then b1=false;b3=false end else c1="Unable to engage auto-orbit, not near a planet"end else bv=false;pI=false;pL=nil;cI=p;if b1 then b1=false end;cO.VectorToTarget=false;cO.AutopilotAlign=false;pK=false end end;function pv.ToggleVerticalTakeoff()b1=false;if b5 then le=true;b4=false;b3=false;b2=true;cI=true;c8=0;if ci and ch==-1 then b2=false;b1=true;c8=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cD.cmdCruise(bF(cL))end else cQ=false;bi=false;d.control.retractLandingGears()ig:setTargetGroundAltitude(Y)aX=true end;b5=not b5 end;function pv.checkLOS(qb)local li,eP,eQ=cx:getPlanetarySystem(0):castIntersections(d0,qb,function(ey)if ey.noAtmosphericDensityAltitude>0 then return ey.radius+ey.noAtmosphericDensityAltitude else return ey.radius+ey.surfaceMaxAltitude*1.5 end end)local lj=eP;if eQ~=nil and eP~=nil then lj=math.min(eQ,eP)end;if lj~=nil then return li,lj else return nil,nil end end;function pv.ToggleAutopilot()local function rZ(bt)dd=false;bm=not bm;if bm then b0=false;if not b1 and not bt then cD.ToggleAltitudeHold()end end;lm="Proceeding to Waypoint"end;local r_=false;if bH-pF<1.5 and cj>0 then if not cS then c1="No space engines detected, Orbital Hop not supported"return end;if iO.hasAtmosphere then if cj>0 then b6=iO.noAtmosphericDensityAltitude+U;g0("orH","OH")end;pF=-1;if a_ or bm or bv then return end end else pF=bH end;qR=false;if(bh>0 or#pN>0)and not a_ and not bm and not cf and not bv then if 0.5*d:maxForceForward()/b.g()<cm then c1="WARNING: Heavy Loads may affect autopilot performance."cb=5 end;if#pN>0 and not cg then bh=pN[1]cC.UpdateAutopilotTarget()table.remove(pN,1)c1="Route Autopilot in Progress"local qh=ga.position-d0;local rv=qh:project_on_plane(cZ):len()if rv>50000 and ga.planetname==iO.name then r_=true end end;cC.UpdateAutopilotTarget()cD.showWayPoint(c5,bg)if ga~=nil then bp=nil;bt=ga.planetname=="Space"if bt then g0("apSpc","AP")if cj~=0 then cf=true;cD.ToggleAltitudeHold()else a_=true end elseif iO.name==ga.planetname then le=true;if cj>0 then if not bm then g0("vtt","AP")rZ(bt)if r_ then b6=iO.noAtmosphericDensityAltitude+U end end else g0("apOn","AP")if not(c5.name==iO.name and ck<gu*1.5)then cQ=false;a_=true elseif not ci then if bv then cD.ToggleIntoOrbit()end;cP=iO.noAtmosphericDensityAltitude+U;pK=true;cO.AutopilotAlign=true;cO.VectorToTarget=true;pI=false;if not bv then cD.ToggleIntoOrbit()end end end else g0("apP","AP")aY=false;aZ=false;if cj~=0 then cf=true;cD.ToggleAltitudeHold()else a_=true end end elseif cj==0 then if ga==nil and(c5.name==iO.name and dc)and not bv then r7=false;cQ=false;pI=false;cD.ToggleIntoOrbit()else g0("apP","AP")a_=true;aY=false;aZ=false;b8=false;b_=false;b1=false;b2=false;b4=false;b3=false;bQ=false;bp=nil;r7=false end else g0("apP","AP")cf=true;cD.ToggleAltitudeHold()end else g0("apOff","AP")cD.ResetAutopilots(1)end end;function pv.routeWP(s0,s1,s2)if s2 then if s2==1 then pN={}pN=ij(pN,bA)if#pN>0 then c1="Route Loaded"else c1="No Saved Route found on Databank"end;return pN else bA={}bA=ij(bA,pN)c1="Route Saved"pu()return end end;if s0 then return pN end;if s1 then pN={}c1="Current Route Cleared"else pN[#pN+1]=bh;c1="Added "..ga.name.." to route. "end;return pN end;function pv.cmdThrottle(dR,s3)if ig:getAxisCommandType(0)~=axisCommandType.byThrottle and not s3 then d.control.cancelCurrentControlMasterMode()end;ig:setThrottleCommand(axisCommandId.longitudinal,dR)bL=dr(ii(dR*100,0)/100,-1,1)d3=nil end;function pv.cmdCruise(dR,s3)if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not s3 then d.control.cancelCurrentControlMasterMode()end;ig:setTargetSpeedCommand(axisCommandId.longitudinal,dR)d3=dR end;function pv.ToggleLockPitch()if bp==nil then g0("lkPOn","LP")if not c0 then bp=d5 else bp=R end;b3=false;b1=false;b2=false else g0("lkPOff","LP")bp=nil end end;function pv.ToggleAltitudeHold()if bH-pE<1.5 then if iO.hasAtmosphere then if cj>0 then b6=iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude;g0("11","EP")else if dc then b6=iO.noAtmosphericDensityAltitude+U;cP=b6;pK=true;if not bv then cD.ToggleIntoOrbit()end;pI=true end end;pE=-1;if b1 or bv or b5 then return end end else pE=bH end;if dc and cj==0 then cP=ck;pK=true;pI=true;cD.ToggleIntoOrbit()if bv then pE=bH else pE=0 end;return end;b1=not b1;b2=false;b4=false;if b1 then a_=false;aZ=false;aY=false;b_=false;cI=true;bp=nil;cQ=false;if ch~=-1 and cY<20 then g0("lfs","LS")b3=true;if pE>-1 then b6=ck+X end;bi=false;d.control.retractLandingGears()aX=true;ig:setTargetGroundAltitude(Y)if aW and d1 then cD.ToggleVerticalTakeoff()end else g0("altOn","AH")b3=false;if pE>-1 then if dc then b6=ck end end;if b5 then cD.ToggleVerticalTakeoff()end end;if cf then b6=100000 end else g0("altOff","AH")if bv then cD.ToggleIntoOrbit()end;if b5 then cD.ToggleVerticalTakeoff()end;cI=p;b3=false;bm=false;pE=0 end end;function pv.ResetAutopilots(pv)if pv then cf=false;a_=false;b8=false;bQ=false;b6=ck;qR=false end;bm=false;b3=false;b4=false;aZ=false;b2=false;s4=false;da=nil;if not d2 then b1=false;bp=nil end;if b5 then cD.ToggleVerticalTakeoff()end;if bv then cD.ToggleIntoOrbit()end;cI=p;ce=false;cg=false;c8=0 end;function pv.BrakeToggle()aX=not aX;if b2 then b2=false;cI=p end;if aX then g0("bkOn","B",1)cD.ResetAutopilots()else g0("bkOff","B",1)end end;function pv.BeginReentry()if b4 then c1="Re-Entry cancelled"g0("reOff","RE")b4=false;cI=p;b1=false elseif not iO.hasAtmosphere then c1="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"cb=5 elseif not bR then b4=true;if ig:getAxisCommandType(0)~=s5.cruise then d.control.cancelCurrentControlMasterMode()end;cI=true;aX=false;c1="Beginning Parachute Re-Entry - Strap In.  Target speed: "..cL;g0("par","RE")else b4=true;b1=true;cI=true;aX=false;b6=iO.surfaceMaxAltitude+_;if b6>iO.spaceEngineMinAltitude then b6=iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude end;local s6=il(b6)c1="Beginning Re-entry.  Target speed: "..cL.." Target Altitude: "..s6;g0("glide","RE")cD.cmdCruise(bF(cL))end;b3=false end;function pv.ToggleAntigrav()if antigrav and not q then if d2 then g0("aggOff","AG")antigrav.deactivate()antigrav.hide()else if br==nil then br=ck end;if br<1000 then br=1000 end;g0("aggOn","AG")antigrav.activate()antigrav.show()end end end;function pv.changeSpd(s7)local s8=1;if s7 then s8=-1 end;if not c0 then if u and not oP and cn then local s9=bL;bL=ii(dr(bL+s8*aA/100,-1,1),2)if bL>=0 and s9<0 then bL=0;cn=false end elseif oP then if cj>0 or b4 then cL=dr(cL+s8*aA,0,V)elseif a_ then a0=dr(a0+s8*aA/3.6*100,0,8333.00)end else ig:updateCommandFromActionStart(axisCommandId.longitudinal,s8*aA/10)end else if a_ or bm or cf or bv then dg=dg+1*s8*-1;if dg>#d7 then dg=1 end;if dg<1 then dg=#d7 end else if not s7 then s8=1 else s8=nil end;cC.adjustAutopilotTargetIndex(s8)end end end;function pv.TenthTick()local function sa(gD,sb)if gD==nil then gD=b.g()end;gD=ii(gD,5)if sb~=nil and sb or(pO==nil or pO~=gD)then local fw=cW:len()local sc=ic(c.getData()).maxBrake;if sc~=nil and sc>0 and ci then sc=sc/dr(fw/100,0.1,1)sc=sc/cj;if cj>0.10 then if bq then bq=(bq+sc)/2 else bq=sc end end end;if sc~=nil and sc>0 then bo=sc end;pO=gD end end;sa(nil,true)if d3~=nil then if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or ig:getTargetSpeed(axisCommandId.longitudinal)~=d3 then cD.cmdCruise(d3)else d3=nil end end end;function pv.SatNavTick()if not r then return end;pP=dbHud_1.getStringValue("SPBAutopilotTargetName")if pP~=nil and pP~=""and pP~="SatNavNotChanged"then local dL=ic(dbHud_1.getStringValue("SavedLocations"))if dL~=nil then bl=dL;local gy=-1;local gE;for dQ,dC in pairs(bl)do if dC.name and dC.name=="SatNav Location"then gy=dQ;break end end;if gy~=-1 then gE=bl[gy]gy=-1;for dQ,dC in pairs(e[0])do if dC.name and dC.name=="SatNav Location"then gy=dQ;break end end;if gy>-1 then e[0][gy]=gE end;cC.UpdateAtlasLocationsList()c1=gE.name.." position updated"end end;for L=1,#d7 do if d7[L].name==pP then bh=L;a.print("Index = "..bh.." "..d7[L].name)cC.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end end;ch=pU()return pv end;local function sd(d,b,c,a,e,vBooster,hover,antigrav,ia,dbHud_2,gyro,screenHud_1,ie,ig,ih,se,gJ,ii,ea,ds,dr,g0,ik,pu)local sf={}local sg=true;local sh=5;local si=5;local sj=sh;local sk=si;local sl=bH;function sf.startControl(sm)local function sn(s7)local s8=1;local function so(sp,s7)local sq={iO.surfaceMaxAltitude+100,iO.spaceEngineMinAltitude-0.01*iO.noAtmosphericDensityAltitude,iO.noAtmosphericDensityAltitude+U,iO.radius*(T-1)+iO.noAtmosphericDensityAltitude}local sr=sp;for dV,dC in ipairs(sq)do if s7 and sr>dC then sp=dC elseif sp<dC and not s7 then sp=dC;break end end;return sp end;if s7 then s8=-1 end;if not q and d2 then if c0 and s7 then br=1000 elseif br~=nil then br=br+s8*si;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end else br=rY+s8*100 end elseif b1 or b5 or bv then if bv then if c0 then cP=so(cP,s7)else cP=cP+s8*sh end;if cP<iO.noAtmosphericDensityAltitude then cP=iO.noAtmosphericDensityAltitude end else if c0 and ci then b6=so(b6,s7)else b6=b6+s8*sh end end else ig:updateTargetGroundAltitudeFromActionStart(s8*1.0)end end;local function ss(st)if not ci then c1="Flight Assist in Atmo only"return end;local dz=type(st)if da==nil then if dz=="table"then if a_ or bm then cD.ToggleAutopilot()end;g0("180On","BR")elseif st==1 then g0("bnkLft","BR")else g0("bnkRht","BR")end;if not b1 and not a_ and not bm then cD.ToggleAltitudeHold()if dz~="table"then st=st+1 end end;da=st else g0("180Off","BR")da=nil end end;if sm=="gear"then bi=not bi;if bi then bm=false;bp=nil;cD.cmdThrottle(0)if vBooster or hover then if ci and ch==-1 then g0("bklOn","BL")le=true;b4=false;b3=false;b5=false;b1=false;b2=true;cI=true;bi=false else if bS then g0("grOut","LG",1)d.control.extendLandingGears()end;ig:setTargetGroundAltitude(Z)if ci then aX=true end end end;if bS and not b2 and not(vBooster or hover)then g0("grOut","LG",1)d.control.extendLandingGears()end else if bS then g0("grIn","LG",1)d.control.retractLandingGears()end;ig:setTargetGroundAltitude(Y)end elseif sm=="light"then if d.control.isAnyHeadlightSwitchedOn()==1 then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif sm=="forward"then bT=bT-1 elseif sm=="backward"then if oP then ss(-cX*5000)else bT=bT+1 end elseif sm=="left"then if oP then ss(1)else bW=bW-1 end elseif sm=="right"then if oP then ss(3)else bW=bW+1 end elseif sm=="yawright"then bX=bX-1 elseif sm=="yawleft"then bX=bX+1 elseif sm=="straferight"then ig:updateCommandFromActionStart(axisCommandId.lateral,1.0)bu=1 elseif sm=="strafeleft"then ig:updateCommandFromActionStart(axisCommandId.lateral,-1.0)bu=-1 elseif sm=="up"then c8=c8+1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif sm=="down"then c8=c8-1;ig:deactivateGroundEngineAltitudeStabilization()ig:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif sm=="groundaltitudeup"then sn()elseif sm=="groundaltitudedown"then sn(true)elseif sm=="option1"then su=false;if oP and c0 then local sv=""for L=1,#dh do sv=sv.."| Name: "..a.getPlayerName(dh[L]).." Mass: "..ii(b.getBoardedPlayerMass(dh[L])/1000,1).."t "end;a.print("Onboard: "..sv)return end;cC.adjustAutopilotTargetIndex()elseif sm=="option2"then su=false;if oP and c0 then for L=1,#dh do b.forceDeboard(dh[L])end;c1="Deboarded All Passengers"return end;cC.adjustAutopilotTargetIndex(1)elseif sm=="option3"then local function sw()sg=not sg;if not sg then g0("wid","DH")c.show()b.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(sx,atmofueltank_size,"Atmo Fuel","fuel_container")sy=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(sz,spacefueltank_size,"Space Fuel","fuel_container")sA=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(sB,rocketfueltank_size,"Rocket Fuel","fuel_container")sC=_autoconf.panels[_autoconf.panels_size]end;sD=a.createWidgetPanel("Docking")sE=a.createWidget(sD,"parenting")a.addDataToWidget(c.getDataId(),sE)sF=a.createWidgetPanel("Core combat stress")sG=a.createWidget(sF,"core_stress")a.addDataToWidget(b.getDataId(),sG)if ia~=nil then ia.show()end else g0("hud","DH")c.hide()b.hide()if sy~=nil then gJ(sy)sy=nil end;if sD~=nil then gJ(sD)sD=nil end;if sF~=nil then gJ(sF)sF=nil end;if sA~=nil then gJ(sA)sA=nil end;if sC~=nil then gJ(sC)sC=nil end;if ia~=nil then ia.hide()end end end;su=false;if oP and c0 then local sv=""for L=1,#di do sv=sv.."| ID: "..di[L].." Mass: "..ii(b.getDockedConstructMass(di[L])/1000,1).."t "end;a.print("Docked Ships: "..sv)return end;if y then if x then x=false else x=true end end;sw()elseif sm=="option4"then su=false;if oP and c0 then for L=1,#di do b.forceUndock(di[L])end;c1="Undocked all ships"return end;da=nil;cD.ToggleAutopilot()elseif sm=="option5"then su=false;cD.ToggleLockPitch()elseif sm=="option6"then su=false;if oP and c0 then if ia then local sH=ia.getVentingCooldown()if sH>0 then c1="Cannot vent again for "..sH.." seconds"return end;if ia.getShieldHitpoints()<ia.getMaxShieldHitpoints()then ia.startVenting()c1="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else c1="Shields already at max hitpoints"end;return else c1="No shield found"return end end;cD.ToggleAltitudeHold()elseif sm=="option7"then su=false;if oP and c0 then if ia then ia.toggle()return else c1="No shield found"return end end;F=not F;if F then c1="Collision System Enabled"else c1="Collision System Secured"end elseif sm=="option8"then su=false;if oP and c0 then if bh>0 and ga~=nil then cD.routeWP()else c1="Select a saved wp on IPH to add to or remove from route"end;return end;bx=not bx;if not bx then c1="DeCoupled Mode - Ground Stabilization off"ig:deactivateGroundEngineAltitudeStabilization()g0("gsOff","GS")else c1="Coupled Mode - Ground Stabilization on"ig:activateGroundEngineAltitudeStabilization(sI)d:setEngineForceCommand('hover',vec3(),1)g0("gsOn","GS")end elseif sm=="option9"then su=false;if oP and c0 then ig:resetCommand(axisCommandId.longitudinal)ig:resetCommand(axisCommandId.lateral)ig:resetCommand(axisCommandId.vertical)cD.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()co=gyro.getState()==1;if co then g0("gyOn","GA")else g0("gyOff","GA")end else c1="No gyro found"end elseif sm=="lshift"then df=false;if oP then c0=true end;if ih()==1 then c0=true;be=ih()se(1)elseif ie()==1 and z then c0=true;cH=false;cG=false end elseif sm=="brake"then if aV or oP then cD.BrakeToggle()elseif not aX then cD.BrakeToggle()else aX=true end elseif sm=="lalt"then su=true;oP=true;if ie()==0 and not i and g=="keyboard"then se(1)end elseif sm=="booster"then if n then d:toggleBoosters()elseif not c2 then if not sJ then d:toggleBoosters()sJ=true end;c2=true else if sJ then d:toggleBoosters()sJ=false end;c2=false end elseif sm=="stopengines"then local function sK()if bH-sl<1.5 then g0("clear","CA")b7=false;b9=false;ba=false;a_=false;b8=false;bc="Aligning"aY=false;aZ=false;da=nil;b1=false;b4=false;b2=false;aX=false;b3=false;b5=false;b_=false;bQ=false;ce=false;cf=false;bR=false;cI=p;bm=false;b0=false;co=false;bp=nil;bv=false end end;sK()sl=bH;if ig:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if bL~=0 then ig:resetCommand(axisCommandId.longitudinal)cD.cmdThrottle(0)else cD.cmdThrottle(100)end else if ig:getTargetSpeed(axisCommandId.longitudinal)~=0 then ig:resetCommand(axisCommandId.longitudinal)else if ci then cD.cmdCruise(V)else cD.cmdCruise(a0*3.6)end end end elseif sm=="speedup"then cD.changeSpd()elseif sm=="speeddown"then cD.changeSpd(true)elseif sm=="antigravity"and not q then if antigrav~=nil then cD.ToggleAntigrav()else c1="No antigrav found"end end end;function sf.stopControl(sm)local function sL()if not q and d2 then sk=si end;if b1 or b5 or bv then sj=sh end end;if sm=="forward"then bT=0 elseif sm=="backward"then bT=0 elseif sm=="left"then if da then if da==2 then da=-2 else da=-1 end end;bW=0 elseif sm=="right"then if da then if da==4 then da=-2 else da=-1 end end;bW=0 elseif sm=="yawright"then bX=0 elseif sm=="yawleft"then bX=0 elseif sm=="straferight"then ig:updateCommandFromActionStop(axisCommandId.lateral,-1.0)bu=0 elseif sm=="strafeleft"then ig:updateCommandFromActionStop(axisCommandId.lateral,1.0)bu=0 elseif sm=="up"then c8=0;ig:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if bx then ig:activateGroundEngineAltitudeStabilization(sI)d:setEngineForceCommand('hover',vec3(),1)end elseif sm=="down"then c8=0;ig:updateCommandFromActionStop(axisCommandId.vertical,1.0)if bx then ig:activateGroundEngineAltitudeStabilization(sI)d:setEngineForceCommand('hover',vec3(),1)end elseif sm=="groundaltitudeup"then sL()su=false elseif sm=="groundaltitudedown"then sL()su=false elseif sm=="lshift"then if ih()==1 then c9=0;ca=0;se(be)elseif ie()==1 and z then cH=false;cG=false end;c0=false elseif sm=="brake"then if not aV and not oP then if aX then cD.BrakeToggle()else aX=false end end elseif sm=="lalt"then if ie()==0 and i then if su then if ih()==1 then se(0)else se(1)end else su=true end elseif ie()==0 and not i and g=="keyboard"then se(0)end;oP=false end end;function sf.loopControl(sm)local function sM(s7)local s8=1;if s7 then s8=-1 end;if not q and d2 then if br~=nil then br=br+s8*sk;if br<1000 then br=1000 end;if b1 and br<b6+10 and br>b6-10 then b6=br end;sk=dr(sk*1.05,si,50)aX=false else br=rY+s8*100;aX=false end elseif b1 or b5 or bv then if bv then cP=cP+s8*sj;if cP<iO.noAtmosphericDensityAltitude then cP=iO.noAtmosphericDensityAltitude end else b6=b6+s8*sj end;sj=dr(sj*1.05,sh,50)else ig:updateTargetGroundAltitudeFromActionLoop(s8*1.0)end end;local function sN(s7)local s8=1;if s7 then s8=-1 end;if not c0 then if u and not oP then bL=dr(bL+s8*aB/100,-1,1)else ig:updateCommandFromActionLoop(axisCommandId.longitudinal,s8*aB)end end end;if sm=="groundaltitudeup"then if not c0 then sM()end elseif sm=="groundaltitudedown"then if not c0 then sM(true)end elseif sm=="speedup"then sN()elseif sm=="speeddown"then sN(true)end end;function sf.inputTextControl(s6)local function sO(sP,fC,gB)local function sQ(fC)local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ='::pos{'..dI..','..dI..','..dI..','..dI..','..dI..'}'local dZ,d_,e7,e8,e9=ea(fC,dJ)if dZ=="0"and d_=="0"then return vec3(ds(e7),ds(e8),ds(e9))end;e8=math.rad(e8)e7=math.rad(e7)local iO=e[ds(dZ)][ds(d_)]local f0=math.cos(e7)local sR=vec3(f0*math.cos(e8),f0*math.sin(e8),math.sin(e7))return iO.center+(iO.radius+e9)*sR end;local g2=sQ(fC)return cC.AddNewLocation(sP,g2,gB)end;local L;local sS,sT=nil,nil;local sU="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate - dumps all custom waypoints to logfile and a screen if present for cut and paste to privatelocations.lua"L=string.find(s6," ")sS=s6;if L~=nil then sS=string.sub(s6,0,L-1)sT=string.sub(s6,L+1)end;if sS=="/help"or sS=="/commands"then for ol in string.gmatch(sU,"([^\n]+)")do a.print(ol)end;return elseif sS=="/setname"then if sT==nil or sT==""then c1="Usage: ah-setname Newname"return end;if bh>0 and ga~=nil then cC.UpdatePosition(sT)else c1="Select a saved target to rename first"end elseif ia and sS=="/resist"then if not ia then c1="No shield found"return elseif sT==nil or ia.getResistancesCooldown()>0 then c1="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local dI=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local dJ=dI..', '..dI..', '..dI..', '..dI;local sV,sW,sX,sY=ea(sT,dJ)if sY==nil or sV+sW+sX+sY>0.6 then c1="Improperly formatted or total exceeds 0.6"return end;if ia.setResistances(sV,sW,sX,sY)==1 then c1="Shield Resistances set"else c1="Resistance setting failed."end elseif sS=="/addlocation"or string.find(s6,"::pos")~=nil then local gB=false;local sP="0-Temp"if sT==nil or sT==""then sT=sS;gB=true end;L=string.find(sT,"::")if not gB then sP=string.sub(sT,1,L-2)end;local fC=string.sub(sT,L)sO(sP,fC,gB)elseif sS=="/agg"then if sT==nil or sT==""then c1="Usage: /agg targetheight"return end;sT=ds(sT)if sT<1000 then sT=1000 end;br=sT;c1="AGG Target Height set to "..sT elseif sS=="/G"then if sT==nil or sT==""then c1="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if sT=="dump"then for dQ,dC in pairs(ik())do if type(dC.get())=="boolean"then if dC.get()==true then a.print(dQ.." true")else a.print(dQ.." false")end elseif dC.get()==nil then a.print(dQ.." nil")else a.print(dQ.." "..dC.get())end end;return end;L=string.find(sT," ")local sZ=string.sub(sT,0,L-1)local s_=string.sub(sT,L+1)for dQ,dC in pairs(ik())do if dQ==sZ then c1="Variable "..sZ.." changed to "..s_;local t0=type(dC.get())if t0=="number"then s_=ds(s_)if dQ=="AtmoSpeedLimit"then cL=s_ end elseif t0=="boolean"then if string.lower(s_)=="true"then s_=true else s_=false end end;dC.set(s_)return end end;c1="No such global variable: "..sZ elseif sS=="/deletewp"then if bh>0 and ga~=nil then cC.ClearCurrentPosition()else c1="Select a custom wp to delete first in IPH"end elseif sS=="/copydatabank"then if dbHud_2 then pu(true)else c1="Spare Databank required to copy databank"end elseif sS=="/iphWP"then if bh>0 then a.print(cD.showWayPoint(c5,bg,true))a.print(json.encode(bg))local t1="SavedLocations = {"for dQ,dC in pairs(bl)do t1=t1 .."{position = {x = "..dC.position.x..", y = "..dC.position.y..", z = "..dC.position.z.."} ".."name = \""..dC.name.."\" planetname = \""..dC.planetname.."\" gravity = "..dC.gravity.." save = "if dC.safe then t1=t1 .."true}"else t1=t1 .."false}"end end;t1=t1 .."}"a.logInfo("PRIVATELOCATIONS:"..t1)if screenHud_1 then a.print("HERE1")screenHud_1.setCenteredText(t1)end;c1="::pos waypoint shown in lua chat in local and world format"else c1="No target selected in IPH"end elseif sS=="/createPrivate"then if#bl>0 then local t1="SavedLocations = {"for dQ,dC in pairs(bl)do t1=t1 .."{position = {x = "..dC.position.x..", y = "..dC.position.y..", z = "..dC.position.z.."}, ".."name = '"..dC.name.."', planetname = '"..dC.planetname.."', gravity = "..dC.gravity..", save = "if dC.safe then t1=t1 .."true},"else t1=t1 .."false},"end end;t1=t1 .."} return SavedLocations"a.logInfo("PRIVATELOCATIONS:"..t1)if screenHud_1 then screenHud_1.setHTML(t1)end;c1="privatelocations.lua created in logfile and on attached screen if present"else c1="No Custom Locations to save"end end end;function sf.tagTick()if by=="Off"then by="All"elseif by=="All"then by="Longitude"elseif by=="Longitude"then by="Lateral"elseif by=="Lateral"then by="Vertical"else by="Off"end;c1="Extra Engine Tags: "..by;c.stopTimer("tagTick")end;return sf end;local function t2(d,b,c,a,library,e,vBooster,hover,pt,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ia,gyro,warpdrive,ib,screenHud_1)local t3={}local dq=string.format;local ic=json.decode;local t4=json.encode;local pn=b.getElementMaxHitPointsById;local id=b.getElementMassById;local ie=d.control.isRemoteControlled;local ea=string.match;local gJ=a.destroyWidgetPanel;local fZ=a.updateData;local f_=a.addDataToWidget;local se=a.lockView;local ih=a.isViewLocked;local dt=math.sqrt;local ds=tonumber;local f4=math.abs;local bF=math.floor;local bG=c.getAtmosphereDensity;local e_=math.atan;local bE=a.getTime;local dr=utils.clamp;local ig=d.axisCommandManager;local t5=Z;local gL=13;local io=b.getElementIdList()local ip=0;local function du(eI,eJ)if eI==0 then return f4(eJ)<1e-09 end;if eJ==0 then return f4(eI)<1e-09 end;return f4(eI-eJ)<math.max(f4(eI),f4(eJ))*dH end;local function ii(dI,t6)local s8=10^(t6 or 0)return bF(dI*s8+0.5)/s8 end;local function ij(t7,t8)for dQ,dC in pairs(t8)do if type(dQ)=="string"then t7[dQ]=dC else t7[#t7+1]=t8[dQ]end end;return t7 end;local function ik(t9)local ta={}if not t9 then ij(ta,K)ij(ta,a8)ij(ta,az)ij(ta,aU)return ta elseif t9=="boolean"then return K elseif t9=="handling"then return a8 elseif t9=="hud"then return az elseif t9=="physics"then return aU end end;local function pu(tb)local function tc(td)for dQ,dC in pairs(td)do if not J or J and dQ~="SavedLocations"then dbHud_1.setStringValue(dQ,t4(dC.get()))if tb and dbHud_2 then dbHud_2.setStringValue(dQ,t4(dC.get()))end end end end;if dbHud_1 then tc(bB)tc(ik())a.print("Saved Variables to Datacore")if tb and dbHud_2 then c1="Databank copied.  Remove copy when ready."end end end;local function g0(te,tf,type)if type==nil and not D or type~=nil and not E or h=="archHUD"then return end;if type~=nil then if type==2 then a.logInfo("sound_loop|audiopacks/"..h.."/"..te.."|"..tf.."|"..ay)else a.logInfo("sound_notification|audiopacks/"..h.."/"..te.."|"..tf.."|"..ay)end else a.logInfo("sound_q|audiopacks/"..h.."/"..te.."|"..tf.."|"..ay)end end;local function gK(hk,hl,s6,js,tg)if js==nil then js=""end;if tg==nil then tg=""end;return dq([[<text class="%s" x=%s y=%s style="%s">%s</text>]],js,hk,hl,tg,s6)end;local function il(cc,th)local ti=cc>100000;if th==nil then th=1 end;if ti then return ii(cc/1000/200,th).."SU"elseif cc<1000 then return ii(cc,th).."M"else return ii(cc/1000,th).."KM"end end;local function im(tj)local tk=0;local tl=0;local tm=0;if tj<60 then tj=bF(tj)elseif tj<3600 then tk=bF(tj/60)tj=bF(tj%60)elseif tj<86400 then tl=bF(tj/3600)tk=bF(tj%3600/60)else tm=bF(tj/86400)tl=bF(tj%86400/3600)end;if tm>0 then return tm.."d "..tl.."h "elseif tl>0 then return tl.."h "..tk.."m "elseif tk>0 then return tk.."m "..tj.."s"elseif tj>0 then return tj.."s"else return"0s"end end;function t3.onStart()local tn=false;local function to()local function tp(tq)local tr=dbHud_1.hasKey;for dQ,dC in pairs(tq)do if tr(dQ)then local dL=ic(dbHud_1.getStringValue(dQ))if dL~=nil then dC.set(dL)tn=true end end end end;if dbHud_1 then if not f then tp(ik())coroutine.yield()tp(bB)else tp(bB)c1="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"cb=5;tn=false end;coroutine.yield()if tn then c1="Loaded Saved Variables"cr=a9;cs=aa;aV=j;g=string.lower(g)cI=p;cL=V;cp=[[rgb(]]..bF(bI+0.5)..","..bF(bK+0.5)..","..bF(bJ+0.5)..[[)]]cq=[[rgb(]]..bF(bI*0.9+0.5)..","..bF(bK*0.9+0.5)..","..bF(bJ*0.9+0.5)..[[)]]elseif not f then c1="No Saved Variables Found - Exit HUD to save settings"end;if bz<1.500 then if U<2000 then c1="Updating LowOrbitHeight to new minimum default of 2000."U=2000 end end;bz=VERSION_NUMBER else c1="No databank found. Attach one to control u and rerun \nthe autoconfigure to save preferences and locations"end;if bs+180<bH then bq=0 end;bs=bH;g=string.lower(g)if string.find("keyboard virtual joystick mouse",g)==nil then c1="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"cb=7 end;if antigrav and not q then if br==nil then br=ck end;antigrav.setBaseAltitude(br)end;if pcall(require,"autoconf/custom/archhud/privatelocations")then bl=require("autoconf/custom/archhud/privatelocations")end;lm="Proceeding to Waypoint"end;local function ts()local function tt(tu,tv)if tu>tv then tv=tu end;local tw,tx=0,0;if a6>0 then tw=a6*0.05 end;if a7>0 then tx=a7*0.05 end;tv=tv*(1-(tw+tx))return tv end;local ty=b.getElementNameById;local tz=aq~=0 and ar~=0;for dQ in pairs(io)do local type=b.getElementTypeById(io[dQ])if ea(type,'^.*Atmospheric Engine$')then if ea(tostring(b.getElementTagsById(io[dQ])),'^.*vertical.*$')and b.getElementForwardById(io[dQ])[3]>0 then d1=true end end;if ea(type,'^.*Space Engine$')then cS=true;if ea(tostring(b.getElementTagsById(io[dQ])),'^.*vertical.*$')then local tA=b.getElementForwardById(io[dQ])if tA[3]<0 then tB=true else cR=true end end end;if type=="Landing Gear"then bS=true end;if type=="Dynamic Core Unit"then local pp=pn(io[dQ])if pp>10000 then gL=110 elseif pp>1000 then gL=55 elseif pp>150 then gL=27 end end;ip=ip+pn(io[dQ])if tz and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local pp=pn(io[dQ])local o9=id(io[dQ])local tu=0;local jm=bE()if type=="Atmospheric Fuel Tank"then local tv=400;local tC=35.03;if pp>10000 then tv=51200;tC=5480 elseif pp>1300 then tv=6400;tC=988.67 elseif pp>150 then tv=1600;tC=182.67 end;tu=o9-tC;if a3>0 then tv=tv+tv*a3*0.2 end;tv=tt(tu,tv)ct[#ct+1]={io[dQ],ty(io[dQ]),tv,tC,tu,jm}end;if type=="Rocket Fuel Tank"then local tv=320;local tC=173.42;if pp>65000 then tv=40000;tC=25740 elseif pp>6000 then tv=5120;tC=4720 elseif pp>700 then tv=640;tC=886.72 end;tu=o9-tC;if a5>0 then tv=tv+tv*a5*0.1 end;tv=tt(tu,tv)cv[#cv+1]={io[dQ],ty(io[dQ]),tv,tC,tu,jm}end;if type=="Space Fuel Tank"then local tv=600;local tC=35.03;if pp>10000 then tv=76800;tC=5480 elseif pp>1300 then tv=9600;tC=988.67 elseif pp>150 then tv=2400;tC=182.67 end;tu=o9-tC;if a4>0 then tv=tv+tv*a4*0.2 end;tv=tt(tu,tv)cu[#cu+1]={io[dQ],ty(io[dQ]),tv,tC,tu,jm}end end end;if not d1 then b5,aW=false,false end end;local function tD()if gyro~=nil then co=gyro.getState()==1 end;if not bx then ig:deactivateGroundEngineAltitudeStabilization()end;if g~="keyboard"then se(1)else se(0)end;if door and(ci or not ci and ck<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(ci or not ci==0 and ck<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;if antigrav then d2=antigrav.getState()==1;if d2 and not q then antigrav.show()end end;if ie()==1 and k then a.freeze(1)else a.freeze(0)end;if bS then bi=d.control.isAnyLandingGearExtended()==1;if bi then d.control.extendLandingGears()else d.control.retractLandingGears()end end;if ch~=-1 or not ci and cW:len()<50 then aX=true;bi=true;if bS then d.control.extendLandingGears()end else aX=false end;ig:setTargetGroundAltitude(t5)if ci and ch~=-1 then cz=b.getMaxKinematicsParametersAlongAxis("ground",b.getConstructOrientationUp())[1]end;pb=ci end;local function tE()local tF={}local function tG()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local tH={[1]=4480,[6]=4480,[7]=6270}for tI,tJ in pairs(e)do e[tI][0]=tG()e[tI][0].systemId=tI;tF[tI]={}for tK,iO in pairs(e[tI])do iO.gravity=iO.gravity/9.8;iO.center=vec3(iO.center)iO.name=iO.name[1]iO.noAtmosphericDensityAltitude=iO.atmosphereThickness or iO.atmosphereRadius-iO.radius;iO.spaceEngineMinAltitude=tH[iO.id]or 0.68377*(iO.atmosphereThickness or iO.atmosphereRadius-iO.radius)iO.planetarySystemId=tI;iO.bodyId=iO.id;tF[tI][tK]=iO;if mf==nil or iO.center.x<mf then mf=iO.center.x end;if me==nil or iO.center.x>me then me=iO.center.x end;if mi==nil or iO.center.y<mi then mi=iO.center.y end;if mh==nil or iO.center.y>mh then mh=iO.center.y end;if iO.center and iO.name~="Space"then dj[#dj+1]=iO end end end;ek=dp(d,b,c,a,dq,dr,ds,dt,du)cx=ek(tF)cy=f3(d,b,c,a,dt,f4)cA=fy(d,b,c,a,dq,dr,ds,dt,du)cC=fY(d,b,c,a,dbHud_1,e,fZ,f_,bF,ds,dt,g0)end;tL=false;tM=coroutine.create(function()ig:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})to()coroutine.yield()ts()coroutine.yield()cD=ps(d,b,c,a,e,vBooster,hover,pt,antigrav,warpdrive,dbHud_1,f4,bF,bG,ie,e_,bE,dr,ig,fZ,ih,dt,ii,g0,ij,du,il,im,pu,ic,dq,f_)tD()coroutine.yield()tE()cE=gI(b,a,c,library,radar_1,radar_2,f4,gJ,dt,gK,ds,gL,g0)cB=i9(d,b,c,a,e,radar_1,radar_2,antigrav,hover,ia,warpdrive,ib,f4,bF,dq,ic,bG,id,ie,e_,bE,dr,ig,f_,fZ,gJ,ih,dt,ii,gK,g0,ij,ik,il,im,io,ip)cB.ButtonSetup()cF=sd(d,b,c,a,e,vBooster,hover,antigrav,ia,dbHud_2,gyro,screenHud_1,ie,ig,ih,se,gJ,ii,ea,ds,dr,g0,ik,pu)coroutine.yield()c.hide()a.showScreen(1)a.showHelper(0)collectgarbage("collect")coroutine.yield()c.setTimer("apTick",aP)c.setTimer("radarTick",aP)c.setTimer("hudTick",aQ)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)c.setTimer("fiveSecond",5)g0("start","SU")end)coroutine.resume(tM)end;function t3.onUpdate()if not tL then local h_=coroutine.status(tM)if h_=="suspended"then local dR,i0=coroutine.resume(tM)if i0 then a.print("ERROR STARTUP: "..i0)end elseif h_=="dead"then tL=true end end;if tL then d:update()if ci and u and d4 then if d4 and bP then cD.cmdThrottle(0)bP=false elseif not d4 and not bP then bL=0;bP=true end end;if dm then ig:setThrottleCommand(axisCommandId.longitudinal,dm)dm=nil end;if not cG and oR~=tN then a.setScreen(oR)end;tN=oR end end;function t3.onFlush()local function tO(tP,rf)local tQ=vec3()local tR=vec3()if tP==axisCommandId.longitudinal then tQ=vec3(b.getConstructOrientationForward())tR=cU elseif tP==axisCommandId.vertical then tQ=vec3(b.getConstructOrientationUp())tR=cT elseif tP==axisCommandId.lateral then tQ=vec3(b.getConstructOrientationRight())tR=cV else return vec3()end;local tS=vec3(b.getWorldGravity())local tT=tS:dot(tR)local tU=vec3(b.getWorldAirFrictionAcceleration())local tV=tU:dot(tR)local tW=cW:dot(tQ)local tX=rf*constants.kph2m;if tY==nil then tY=pid.new(10,0,10.0)end;tY:inject(tX-tW)local tZ=tY:get()local t_=(tZ-tV-tT)*tR;return t_ end;local function u0(tP,rf)local tQ=vec3()local tR=vec3()if tP==axisCommandId.longitudinal then tQ=vec3(b.getConstructOrientationForward())tR=cU elseif tP==axisCommandId.vertical then tQ=vec3(b.getConstructOrientationUp())tR=cT elseif tP==axisCommandId.lateral then tQ=vec3(b.getConstructOrientationRight())tR=cV else return vec3()end;local tS=vec3(b.getWorldGravity())local tT=tS:dot(tR)local tU=vec3(b.getWorldAirFrictionAcceleration())local tV=tU:dot(tR)local tW=cW:dot(tQ)local tX=rf*constants.kph2m;if u1==nil then u1=pid.new(10,0,10.0)end;u1:inject(tX-tW)local tZ=u1:get()local t_=(tZ-tV-tT)*tR;return t_ end;local function u2(u3,jB,g7)local u4=u3:cross(g7):normalize_inplace()local km=math.acos(dr(u4:dot(-jB),-1,1))*constants.rad2deg;if u4:cross(-jB):dot(g7)<0 then km=-km end;return km end;if antigrav and not q then if not d2 and antigrav.getBaseAltitude()~=br then antigrav.setBaseAltitude(br)end end;d4=ig:getAxisCommandType(0)==axisCommandType.byThrottle;aK=math.max(aK,0.01)aL=math.max(aL,0.01)aF=math.max(aF,0.01)aJ=math.max(aJ,0.01)aM=math.max(aM,0.01)aN=math.max(aN,0.01)aE=math.max(aE,0.01)local u5=dr(bT+bU+a.getControlDeviceForwardInput(),-1,1)local u6=dr(bW+bZ+a.getControlDeviceYawInput(),-1,1)local u7=dr(bX+bV-a.getControlDeviceLeftRightInput(),-1,1)local u8=bY;cZ=vec3(b.getWorldVertical())if cZ==nil or cZ:len()==0 then cZ=(iO.center-d0):normalize()end;cT=vec3(b.getConstructWorldOrientationUp())cU=vec3(b.getConstructWorldOrientationForward())cV=vec3(b.getConstructWorldOrientationRight())cX=vec3(b.getWorldVelocity())cW=vec3(b.getVelocity())d0=vec3(b.getConstructWorldPos())cm=b.getConstructMass()cY=vec3(cX):len()c_=-cZ:dot(cX)d6=getRoll(cZ,cU,cV)local u9=d6/180*math.pi;local ua=math.cos(u9)local ub=math.sin(u9)d5=u2(cZ,cU,cV*ua+cT*ub)local uc=cX:normalize()local ud=f4(d6)local ue=utils.sign(d6)local uf=vec3(b.getWorldAngularVelocity())local ug=u5*aK*cV+u6*aF*cU+u7*aL*cT;if cI==true and cZ:len()>0.01 then local uh=f4(cK-d6)if((aZ or b4 or b2 or ce or b1 or bv)and uh>0 or cj>0.0 and uh<aG and p)and u6==0 and f4(d5)<85 then local ui=cK;local uj=aE;if cj==0 then uj=uj/4;cK=0;ui=0 end;if uk==nil then uk=pid.new(uj*0.01,0,uj*0.1)end;uk:inject(ui-d6)local ul=uk:get()ug=ug+ul*cU end end;local um=1;local un=0;local uo=1;bM=0;if ci and u and d4 then if up==nil then up=pid.new(0.1,0,1)end;up:inject(cL/3.6-cX:dot(cU))local uq=up:get()bO=dr(uq,-1,1)if not dm then if bO<bL and cj>0.005 then bN=true;dm=dr(bO,0.01,1)else bN=false;dm=bL end end;if ur==nil then ur=pid.new(1*0.01,0,1*0.1)end;ur:inject(cX:len()-cL/3.6)local us=dr(ur:get(),0,1)if cj>0 and c_<-80 or cj>0.005 then bM=us end;if bM>0 then if bN and bO==0.01 and not dm then dm=0 end else bO=dr(bO,0.01,1)end;local ut=''local uu=vec3()local uv=tO(axisCommandId.vertical,c8*1000)d:setEngineForceCommand("vertical airfoil , vertical ground ",uv,un)local uw='thrust analog longitudinal 'if by=="All"or by=="Longitude"then uw=uw..aR end;local ux=ig:getAxisCommandType(axisCommandId.longitudinal)local uy=ig:composeAxisAccelerationFromThrottle(uw,axisCommandId.longitudinal)local uz=u0(axisCommandId.lateral,bu*1000)ut=ut..' , '.."lateral airfoil , lateral ground "uu=uu+uz;if uu:len()>constants.epsilon then d:setEngineForceCommand(ut,uu,un,'','','',uo)end;d:setEngineForceCommand(uw,uy,um)local uA='thrust analog vertical fueled 'local uB='thrust analog lateral fueled 'if by=="All"or by=="Lateral"then uB=uB..aS end;if by=="All"or by=="Vertical"then uA=uA..aT end;if c8~=0 or b2 and aX or not bi and not bx then d:setEngineForceCommand(uA,uv,um)else d:setEngineForceCommand(uA,vec3(),um)end;if bu~=0 then d:setEngineForceCommand(uB,uz,um)else d:setEngineForceCommand(uB,vec3(),um)end;if u8==0 then u8=bM end;local uC=-u8*(aM*cX+aN*uc)d:setEngineForceCommand('brake',uC)else if u then if not dm then dm=bL end end;local rf=c.getAxisCommandValue(0)if not d4 then if ur==nil then ur=pid.new(1*0.01,0,1*0.1)end;ur:inject(cX:len()-rf/3.6)local us=dr(ur:get(),0,1)u8=dr(u8+us,0,1)end;local uC=-u8*(aM*cX+aN*uc)d:setEngineForceCommand('brake',uC)local ut=''local uu=vec3()local uD=false;local uw='thrust analog longitudinal 'if by=="All"or by=="Longitude"then uw=uw..aR end;local ux=ig:getAxisCommandType(axisCommandId.longitudinal)if ux==axisCommandType.byThrottle then local uy=ig:composeAxisAccelerationFromThrottle(uw,axisCommandId.longitudinal)d:setEngineForceCommand(uw,uy,um)elseif ux==axisCommandType.byTargetSpeed then local uy=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)ut=ut..' , '..uw;uu=uu+uy;if ig:getTargetSpeed(axisCommandId.longitudinal)==0 or ig:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-ig:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then uD=true end end;local uB='thrust analog lateral 'if by=="All"or by=="Lateral"then uB=uB..aS end;local uE=ig:getAxisCommandType(axisCommandId.lateral)if uE==axisCommandType.byThrottle then local uF=ig:composeAxisAccelerationFromThrottle(uB,axisCommandId.lateral)d:setEngineForceCommand(uB,uF,um)elseif uE==axisCommandType.byTargetSpeed then local uz=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)ut=ut..' , '..uB;uu=uu+uz end;local uA='thrust analog vertical 'if by=="All"or by=="Vertical"then uA=uA..aT end;local uG=ig:getAxisCommandType(axisCommandId.vertical)if uG==axisCommandType.byThrottle then local uv=ig:composeAxisAccelerationFromThrottle(uA,axisCommandId.vertical)if c8~=0 or b2 and aX then d:setEngineForceCommand(uA,uv,um,'airfoil','ground','',uo)else d:setEngineForceCommand(uA,vec3(),um)d:setEngineForceCommand('airfoil vertical',uv,um,'airfoil','','',uo)d:setEngineForceCommand('ground vertical',uv,um,'ground','','',uo)end elseif uG==axisCommandType.byTargetSpeed then if c8<0 then d:setEngineForceCommand('hover',vec3(),um)end;local uH=ig:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)ut=ut..' , '..uA;uu=uu+uH end;if uu:len()>constants.epsilon then if bY~=0 or uD or f4(uc:dot(cU))<0.5 then ut=ut..', brake'end;d:setEngineForceCommand(ut,uu,un,'','','',uo)end end;local uI=aJ*(ug-uf)local uJ=vec3(b.getWorldAirFrictionAngularAcceleration())uI=uI-uJ;d:setEngineTorqueCommand('torque',uI,um,'airfoil','','',uo)d:setBoosterCommand('rocket_engine')if c2 and not n then local fw=cW:len()local uK=0.15;if not d4 then local uL=ig:getTargetSpeed(axisCommandId.longitudinal)if fw*3.6>uL*(1-uK)and sJ then sJ=false;d:toggleBoosters()elseif fw*3.6<uL*(1-uK)and not sJ then sJ=true;d:toggleBoosters()end else local p2=c.getThrottle()if u then p2=bL*100 end;local rf=p2/100;if bG==0 then rf=rf*a0;if fw>=rf*(1-uK)and sJ then sJ=false;d:toggleBoosters()elseif fw<rf*(1-uK)and not sJ then sJ=true;d:toggleBoosters()end else local rs=bF(cL)rf=rf*rs/3.6;if fw>=rf*(1-uK)and sJ then sJ=false;d:toggleBoosters()elseif fw<rf*(1-uK)and not sJ then sJ=true;d:toggleBoosters()end end end end end;function t3.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not q then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;b.hide()d.control.switchOffHeadlights()if door and(cj>0 or cj==0 and ck<10000)then for dV,dC in pairs(door)do dC.toggle()end end;if switch then for dV,dC in pairs(switch)do dC.toggle()end end;if forcefield and(cj>0 or cj==0 and ck<10000)then for dV,dC in pairs(forcefield)do dC.toggle()end end;x=dl;pu()if nL then nL.activate()end;if A then cD.showWayPoint(iO,d0)end;local of=1-(a6*0.05+a7*0.05)a.print(cB.FuelUsed("atmofueltank")..", "..cB.FuelUsed("spacefueltank")..", "..cB.FuelUsed("rocketfueltank"))g0("stop","SU")end;function t3.controlStart(sm)cF.startControl(sm)end;function t3.controlStop(sm)cF.stopControl(sm)end;function t3.controlLoop(sm)cF.loopControl(sm)end;function t3.controlInput(s6)cF.inputTextControl(s6)end;function t3.radarEnter(d_)cE.onEnter(d_)end;function t3.radarLeave(d_)cE.onLeave(d_)end;function t3.onTick(uM)if uM=="tenthSecond"then cD.TenthTick()cB.TenthTick()elseif uM=="oneSecond"then cB.OneSecondTick()elseif uM=="fiveSecond"then cD.SatNavTick()elseif uM=="msgTick"then cB.MsgTick()elseif uM=="animateTick"then cB.AnimateTick()elseif uM=="hudTick"then cB.hudtick()elseif uM=="apTick"then cD.APTick()elseif uM=="radarTick"then cE.UpdateRadar()elseif uM=="tagTick"then cF.tagTick()elseif uM=="contact"then cE.ContactTick()end end;return t3 end;function script.onStart()uN.onStart()end;function script.onStop()uN.onStop()end;function script.onTick(uM)uN.onTick(uM)end;function script.onFlush()uN.onFlush()end;function script.onUpdate()uN.onUpdate()end;function script.onActionStart(sm)uN.controlStart(sm)end;function script.onActionStop(sm)uN.controlStop(sm)end;function script.onActionLoop(sm)uN.controlLoop(sm)end;function script.onInputText(s6)uN.controlInput(s6)end;function script.onEnter(d_)uN.radarEnter(d_)end;function script.onLeave(d_)uN.radarLeave(d_)end;bD(a,b,c,a.getTime,math.floor,c.getAtmosphereDensity)uN=t2(d,b,c,a,library,e,vBooster,hover,pt,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,ia,gyro,warpdrive,ib,screenHud_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script = {} end end 
    stop:
      lua: if not __wrap_lua__stopped and script.onStop then local a,b=xpcall(script.onStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua: if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua: if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua: if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua: if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    update:
      lua: if not __wrap_lua__stopped and script.onUpdate then local a,b=xpcall(script.onUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    flush:
      lua: if not __wrap_lua__stopped and script.onFlush then local a,b=xpcall(script.onFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua: if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
