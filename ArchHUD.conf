name: ArchHud - Archaegeo v1.512 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
    select: manual
handlers:
  unit:
    start:
      lua: |
        -- error handling code added by wrap.lua
        __wrap_lua__stopped = false
        __wrap_lua__stopOnError = false
        __wrap_lua__rethrowErrorAlways = false
        __wrap_lua__rethrowErrorIfStopped = true
        __wrap_lua__printError = true
        __wrap_lua__showErrorOnScreens = true
        
        function __wrap_lua__error (message)
          if __wrap_lua__stopped then return end
        
          -- make the traceback more readable and escape HTML syntax characters
          message = tostring(message):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"', 'chunk'):gsub("&", "&amp;"):gsub("<", "&lt;"):gsub(">", "&gt;")
        
          local unit = unit or self or {}
        
          if __wrap_lua__showErrorOnScreens then
            for _, value in pairs(unit) do
              if type(value) == "table" and value.setCenteredText and value.setHTML then -- value is a screen
                if message:match("\n") then
                  value.setHTML([[
        <pre style="color: white; background-color: black; font-family: Consolas,monospace; font-size: 4vh; white-space: pre-wrap; margin: 1em">
        Error: ]] .. message .. [[
        </pre>]])
                else
                  value.setCenteredText(message)
                end
              end
            end
          end
        
          if __wrap_lua__printError and system and system.print then
            system.print("Error: " .. message:gsub("\n", "<br>"))
          end
        
          if __wrap_lua__stopOnError then
            __wrap_lua__stopped = true
          end
        
          if __wrap_lua__stopped and unit and unit.exit then
            unit.exit()
          end
        
          if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then
            error(message)
          end
        end
        
        -- in case traceback is removed or renamed
        __wrap_lua__traceback = traceback or (debug and debug.traceback) or function (arg1, arg2) return arg2 or arg1 end
        
        local ok, message = xpcall(function ()
        
        -- script code
        
        useTheseSettings = false --export:
        userControlScheme = "virtual joystick" --export:
        soundFolder = "archHUD" --export:
        freeLookToggle = true --export:
        BrakeToggleDefault = true --export:
        RemoteFreeze = false --export:
        RemoteHud = true --export:
        brightHud = false --export:
        VanillaRockets = false --export:
        InvertMouse = false --export:
        autoRollPreference = false --export:
        ExternalAGG = false --export:
        UseSatNav = false --export:
        ShouldCheckDamage = true --export:
        CalculateBrakeLandingSpeed = false --export:
        AtmoSpeedAssist = true --export:
        ForceAlignment = false --export:
        DisplayDeadZone = true --export:
        showHud = true --export: 
        ShowOdometer = true --export:
        hideHudOnToggleWidgets = true --export:
        ShiftShowsRemoteButtons = true --export:
        DisplayOrbit = true --export: 
        SetWaypointOnExit = false --export:
        AlwaysVSpd = false --export:
        BarFuelDisplay = true --export:
        showHelp = true --export:
        voices = true --export:
        alerts = true --export:
        CollisionSystem = true --export:
        AutoShieldToggle = true --export:
        PreventPvP = true --export:
        YawStallAngle = 35 --export:
        PitchStallAngle = 35 --export:
        brakeLandingRate = 30 --export:
        MaxPitch = 30 --export:
        ReEntryPitch = -30 --export:
        LockPitchTarget = 0 --export:
        AutopilotSpaceDistance = 5000 --export:
        TargetOrbitRadius = 1.2 --export:
        LowOrbitHeight = 2000 --export:
        AtmoSpeedLimit = 1050 --export:
        SpaceSpeedLimit = 30000 --export:
        AutoTakeoffAltitude = 1000 --export:
        TargetHoverHeight = 50 --export:
        LandingGearGroundHeight = 0 --export:
        ReEntryHeight = 100000 --export:
        MaxGameVelocity = 8333.00 --export:
        AutopilotInterplanetaryThrottle = 1.0 --export:
        warmup = 32 --export:
        fuelTankHandlingAtmo = 0 --export:
        fuelTankHandlingSpace = 0 --export:
        fuelTankHandlingRocket = 0 --export:
        ContainerOptimization = 0 --export:
        FuelTankOptimization = 0 --export:
        WipeDamage = 0 --export:
        ResolutionX = 1920 --export:
        ResolutionY = 1080 --export:
        circleRad = 400 --export:
        SafeR = 130 --export:
        SafeG = 224 --export:
        SafeB = 255 --export:
        PvPR = 255 --export:
        PvPG = 0 --export:
        PvPB = 0 --export:
        centerX = 960 --export:
        centerY = 540 --export:
        throtPosX = 1300 --export:
        throtPosY = 540 --export:
        vSpdMeterX = 1525  --export:
        vSpdMeterY = 325 --export:
        altMeterX = 550  --export:
        altMeterY = 540 --export:
        fuelX = 30 --export:
        fuelY = 700 --export:
        shieldX = 1750 --export:
        shieldY = 250 --export:
        DeadZone = 50 --export:
        OrbitMapSize = 250 --export:
        OrbitMapX = 75 --export:
        OrbitMapY = 0 --export:
        soundVolume = 100 --export:
        speedChangeLarge = 5 --export:
        speedChangeSmall = 1 --export:
        MouseXSensitivity = 0.003 --export:
        MouseYSensitivity = 0.003 --export:
        autoRollFactor = 2 --export:
        rollSpeedFactor = 1.5 --export:
        autoRollRollThreshold = 180 --export:
        minRollVelocity = 150 --export:
        TrajectoryAlignmentStrength = 0.002 --export:
        torqueFactor = 2 --export:
        pitchSpeedFactor = 0.8 --export:
        yawSpeedFactor = 1 --export:
        brakeSpeedFactor = 3 --export:
        brakeFlatFactor = 1 --export:
        DampingMultiplier = 40 --export:
        apTickRate = 0.0166667 --export:
        hudTickRate = 0.0666667 --export:
        ExtraLongitudeTags = "none" --export:
        ExtraLateralTags = "none" --export:
        ExtraVerticalTags = "none" --export:
        local a=Navigator.new(system,core,unit)local b=require("atlas")script={}VERSION_NUMBER=1.512;BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"AutopilotPlanetGravity=0;PrevViewLock=1;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;local c={"VertTakeOff","VertTakeOffEngine","SpaceTarget","BrakeToggleStatus","BrakeIsOn","RetrogradeIsOn","ProgradeIsOn","Autopilot","TurnBurn","AltitudeHold","BrakeLanding","Reentry","AutoTakeoff","HoldAltitude","AutopilotAccelerating","AutopilotBraking","AutopilotCruising","AutopilotRealigned","AutopilotEndSpeed","AutopilotStatus","AutopilotPlanetGravity","PrevViewLock","AutopilotTargetName","AutopilotTargetCoords","AutopilotTargetIndex","TotalDistanceTravelled","TotalFlightTime","SavedLocations","VectorToTarget","LocationIndex","LastMaxBrake","LockPitch","LastMaxBrakeInAtmo","AntigravTargetAltitude","LastStartTime","iphCondition","stablized","UseExtra","SelectedTab"}local d=math.abs;local e=math.floor;local f=string.format;local g=json.decode;local h=json.encode;local j=core.getElementMaxHitPointsById;local k=unit.getAtmosphereDensity;local l=core.getElementMassById;local m=a.control.isRemoteControlled;local n=math.atan;local o=string.match;local q=system.getTime;local vec3=vec3;local r=utils.clamp;local s=a.axisCommandManager;local t=system.destroyWidgetPanel;local u=system.updateData;local v=system.addDataToWidget;local w=system.lockView;local x=system.isViewLocked;local y=math.sqrt;local z=tonumber;local core=core;local function A(B,C)local D=10^(C or 0)return e(B*D+0.5)/D end;local E=q()local F=q()local G=13;local H=SafeR;local I=SafeB;local J=SafeG;local K=0;local L=0;local M=false;local N=0;local O=false;local P=false;local Q=55;local R=false;local S=false;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local a0=false;local a1=false;local a2="empty"local a3=5;local a4=5;local a5=a3;local a6=a4;local a7=false;local a8=0;local a9=0;local aa=0;local ab=0;local ac=nil;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=3;local aj=0;local ak=""local al=false;local am=false;local an=false;local ao=-1;local ap=""local aq=k()>0;local ar=k()local as=core.getAltitude()local at=core.getElementIdList()local au=q()local av=core.getConstructMass()local aw=false;local ax=nil;local ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]local az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]local aA={}local aB=0;local aC=0;local aD=""local aE=true;local aF={}local aG=ResolutionX;local aH=ResolutionY;local aI={}local aJ={}local aK={}local aL=0;local aM=false;local aN=nil;local aO=nil;local aP=nil;local aQ=nil;local aR=nil;local aS=nil;local aT=nil;local aU=nil;local aV=nil;local aW=nil;local aX=nil;local aY=nil;local aZ=false;local a_=false;local b0=autoRollPreference;local b1=LandingGearGroundHeight;local b2=false;local b3=q()local b4=0;local b5=0;local b6=0;local b7=AtmoSpeedLimit;local b8=0;local b9=nil;local ba=0;local bb=0;local bc=false;local bd=false;local be={VectorToTarget=false}local bf=false;local bg=0;local bh=nil;local bi=false;local bj=false;local bk=false;local bl=false;local bm=0;local bn=vec3(core.getConstructWorldOrientationUp())local bo=vec3(core.getConstructWorldOrientationForward())local bp=vec3(core.getConstructWorldOrientationRight())local bq=vec3(core.getVelocity())local br=vec3(core.getWorldVelocity())local bs=vec3(br):len()local bt=vec3(core.getWorldVertical())local bu=-bt:dot(br)local bv=vec3(core.getConstructWorldPos())local bw=0;local bx=false;local by=false;local bz=nil;local bA=true;local bB=0;local bC=0;local bD=false;local bE={}local bF=showHud;local bG={}local bH=false;local bI=50000;local bJ=""local bK=nil;local bL={}local bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local bN=false;local bO=nil;local bP={}local bQ="Atmo"local bR=false;local bS=0;local bT={}function p(bU)system.print(E..": "..bU)end;local function bV(bW)local D=1;if bW then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn and aw then local bX=K;K=A(r(K+D*speedChangeLarge/100,-1,1),2)if K>=0 and bX<0 then K=0;aw=false end elseif AltIsOn then if ar>0 or Reentry then b7=r(b7+D*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then MaxGameVelocity=r(MaxGameVelocity+D*speedChangeLarge/3.6*100,0,8333.00)end else s:updateCommandFromActionStart(axisCommandId.longitudinal,D*speedChangeLarge)end else if Autopilot or VectorToTarget or am or IntoOrbit then bS=bS+1*D*-1;if bS>#bG then bS=1 end;if bS<1 then bS=#bG end else if not bW then D=1 else D=nil end;aW.adjustAutopilotTargetIndex(D)end end end;local function bY(bZ)local b_,c0,c1=aR:getPlanetarySystem(0):castIntersections(bv,bZ,function(c2)if c2.noAtmosphericDensityAltitude>0 then return c2.radius+c2.noAtmosphericDensityAltitude else return c2.radius+c2.surfaceMaxAltitude*1.5 end end)local c3=c0;if c1~=nil and c0~=nil then c3=math.min(c1,c0)end;if c3~=nil then return b_,c3 else return nil,nil end end;local function c4(c5,c6,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;if type~=nil then if type==2 then system.logInfo("sound_loop|audiopacks/"..soundFolder.."/"..c5 .."|"..c6 .."|"..soundVolume)else system.logInfo("sound_notification|audiopacks/"..soundFolder.."/"..c5 .."|"..c6 .."|"..soundVolume)end else system.logInfo("sound_q|audiopacks/"..soundFolder.."/"..c5 .."|"..c6 .."|"..soundVolume)end end;local function c7(c8,c9)for i=1,#c9 do c8[#c8+1]=c9[i]end;return c8 end;local function ca(cb)local cc={}local cd={"userControlScheme","soundFolder","freeLookToggle","BrakeToggleDefault","RemoteFreeze","brightHud","RemoteHud","VanillaRockets","InvertMouse","autoRollPreference","ExternalAGG","UseSatNav","ShouldCheckDamage","CalculateBrakeLandingSpeed","AtmoSpeedAssist","ForceAlignment","DisplayDeadZone","showHud","ShowOdometer","hideHudOnToggleWidgets","ShiftShowsRemoteButtons","DisplayOrbit","SetWaypointOnExit","AlwaysVSpd","BarFuelDisplay","showHelp","voices","alerts","CollisionSystem","AutoShieldToggle","PreventPvP"}local ce={"YawStallAngle","PitchStallAngle","brakeLandingRate","MaxPitch","ReEntryPitch","LockPitchTarget","AutopilotSpaceDistance","TargetOrbitRadius","LowOrbitHeight","AtmoSpeedLimit","SpaceSpeedLimit","AutoTakeoffAltitude","TargetHoverHeight","LandingGearGroundHeight","ReEntryHeight","MaxGameVelocity","AutopilotInterplanetaryThrottle","warmup","fuelTankHandlingAtmo","fuelTankHandlingSpace","fuelTankHandlingRocket","ContainerOptimization","FuelTankOptimization","WipeDamage"}local cf={"ResolutionX","ResolutionY","circleRad","SafeR","SafeG","SafeB","PvPR","PvPG","PvPB","centerX","centerY","throtPosX","throtPosY","vSpdMeterX","vSpdMeterY","altMeterX","altMeterY","fuelX","fuelY","shieldX","shieldY","DeadZone","OrbitMapSize","OrbitMapX","OrbitMapY","soundVolume"}local cg={"speedChangeLarge","speedChangeSmall","MouseXSensitivity","MouseYSensitivity","autoRollFactor","rollSpeedFactor","autoRollRollThreshold","minRollVelocity","TrajectoryAlignmentStrength","torqueFactor","pitchSpeedFactor","yawSpeedFactor","brakeSpeedFactor","brakeFlatFactor","DampingMultiplier","apTickRate","hudTickRate","ExtraLongitudeTags","ExtraLateralTags","ExtraVerticalTags"}if not cb then c7(cc,cd)c7(cc,ce)c7(cc,cf)c7(cc,cg)return cc elseif cb=="boolean"then return cd elseif cb=="handling"then return ce elseif cb=="hud"then return cf elseif cb=="physics"then return cg end end;local function ch(ci,cj,ck,cl,cm)if cl==nil then cl=""end;if cm==nil then cm=""end;return f([[<text class="%s" x=%s y=%s style="%s">%s</text>]],cl,ci,cj,cm,ck)end;local function cn(co,cp)if s:getAxisCommandType(0)~=axisCommandType.byThrottle and not cp then a.control.cancelCurrentControlMasterMode()end;s:setThrottleCommand(axisCommandId.longitudinal,co)K=r(A(co*100,0)/100,-1,1)bz=nil end;local function cq(co,cp)if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not cp then a.control.cancelCurrentControlMasterMode()end;s:setTargetSpeedCommand(axisCommandId.longitudinal,co)bz=co end;local function cr(cs,ct)if cs==0 then return d(ct)<1e-09 end;if ct==0 then return d(cs)<1e-09 end;return d(cs-ct)<math.max(d(cs),d(ct))*epsilon end;local function cu(aj,cv)local cw=aj>100000;if cv==nil then cv=1 end;if cw then return A(aj/1000/200,cv).."SU"elseif aj<1000 then return A(aj,cv).."M"else return A(aj/1000,cv).."KM"end end;local function cx()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;b0=true;af=0;if aq and ao==-1 then BrakeLanding=false;AltitudeHold=true;af=0;a:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)cq(e(b7))end else bi=false;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn=true end;VertTakeOff=not VertTakeOff end;local function cy()bi=false;ba=nil;bb=nil;bm=0;if ar==0 then if IntoOrbit then c4("orOff","AP")IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false elseif bM then c4("orOn","AP")IntoOrbit=true;b0=true;if bh==nil then bh=planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else a2="Unable to engage auto-orbit, not near a planet"end else IntoOrbit=false;bc=false;bh=nil;b0=autoRollPreference;if AltitudeHold then AltitudeHold=false end;be.VectorToTarget=false;be.AutopilotAlign=false;bf=false end end;local function cz()if E-b5<1.5 then if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;c4("11","EP")else if bM then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bg=HoldAltitude;bf=true;if not IntoOrbit then cy()end;bc=true end end;b5=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else b5=E end;if bM and ar==0 then bg=as;bf=true;bc=true;cy()if IntoOrbit then b5=E else b5=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;a0=false;b0=true;LockPitch=nil;bi=false;if ao~=-1 and bs<20 then c4("lfs","LS")AutoTakeoff=true;if b5>-1 then HoldAltitude=as+AutoTakeoffAltitude end;GearExtended=false;a.control.retractLandingGears()BrakeIsOn=true;s:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and bx then cx()end else c4("altOn","AH")AutoTakeoff=false;if b5>-1 then if bM then HoldAltitude=as end end;if VertTakeOff then cx()end end;if am then HoldAltitude=100000 end else c4("altOff","AH")if IntoOrbit then cy()end;if VertTakeOff then cx()end;b0=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;b5=0 end end;local function cA(cB)if cB then am=false;Autopilot=false;AutopilotRealigned=false;P=false;HoldAltitude=as;TargetSet=false end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;ProgradeIsOn=false;BrakeLanding=false;AutoLanding=false;bK=nil;if not by then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then cx()end;if IntoOrbit then cy()end;b0=autoRollPreference;al=false;an=false;af=0 end;local function cC()local function cD(SpaceTarget)bN=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then cz()end end;VectorStatus="Proceeding to Waypoint"end;if E-b6<1.5 and ar>0 then if not bl then a2="No space engines detected, Orbital Hop not supported"return end;if planet.hasAtmosphere then if ar>0 then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;c4("orH","OH")end;b6=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else b6=E end;TargetSet=false;if AutopilotTargetIndex>0 and not Autopilot and not VectorToTarget and not am and not IntoOrbit then if 0.5*a:maxForceForward()/core.g()<av then a2="WARNING: Heavy Loads may affect autopilot performance."ai=5 end;aW.UpdateAutopilotTarget()aX.showWayPoint(ac,AutopilotTargetCoords)if CustomTarget~=nil then LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then c4("apSpc","AP")if ar~=0 then am=true;cz()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if ar>0 then if not VectorToTarget then c4("vtt","AP")cD(SpaceTarget)end else c4("apOn","AP")if not(ac.name==planet.name and as<AutopilotTargetOrbit*1.5)then bi=false;Autopilot=true elseif not aq then if IntoOrbit then cy()end;bg=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bf=true;be.AutopilotAlign=true;be.VectorToTarget=true;bc=false;if not IntoOrbit then cy()end end end else c4("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if ar~=0 then am=true;cz()else Autopilot=true end end elseif ar==0 then if CustomTarget==nil and(ac.name==planet.name and bM)and not IntoOrbit then WaypointSet=false;bi=false;bc=false;cy()else c4("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;a0=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;P=false;LockPitch=nil;WaypointSet=false end else c4("apP","AP")am=true;cz()end else c4("apOff","AP")cA(1)end end;local function cE()BrakeIsOn=not BrakeIsOn;if BrakeLanding then BrakeLanding=false;b0=autoRollPreference end;if BrakeIsOn then c4("bkOn","B",1)cA()else c4("bkOff","B",1)end end;local function cF()if Reentry then a2="Re-Entry cancelled"c4("reOff","RE")Reentry=false;b0=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then a2="Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere"ai=5 elseif not R then Reentry=true;if s:getAxisCommandType(0)~=controlMasterModeId.cruise then a.control.cancelCurrentControlMasterMode()end;b0=true;BrakeIsOn=false;a2="Beginning Parachute Re-Entry - Strap In.  Target speed: "..b7;c4("par","RE")else Reentry=true;AltitudeHold=true;b0=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local ck=cu(HoldAltitude)a2="Beginning Re-entry.  Target speed: "..b7 .." Target Altitude: "..ck;c4("glide","RE")cq(e(b7))end;AutoTakeoff=false end;local function cG()if antigrav and not ExternalAGG then if by then c4("aggOff","AG")antigrav.deactivate()antigrav.hide()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;c4("aggOn","AG")antigrav.activate()antigrav.show()end end end;local function cH(cI)local cJ=0;local cK=0;local cL=0;if cI<60 then cI=e(cI)elseif cI<3600 then cJ=e(cI/60)cI=e(cI%60)elseif cI<86400 then cK=e(cI/3600)cJ=e(cI%3600/60)else cL=e(cI/86400)cK=e(cI%86400/3600)end;if cL>0 then return cL.."d "..cK.."h "elseif cK>0 then return cK.."h "..cJ.."m "elseif cJ>0 then return cJ.."m "..cI.."s"elseif cI>0 then return cI.."s"else return"0s"end end;local function cM(cN)local function cO(cP)for cQ,cR in pairs(cP)do dbHud_1.setStringValue(cR,h(_G[cR]))if cN and dbHud_2 then dbHud_2.setStringValue(cR,h(_G[cR]))end end end;if dbHud_1 then cO(c)cO(ca())system.print("Saved Variables to Datacore")if cN and dbHud_2 then a2="Databank copied.  Remove copy when ready."end end end;local function cS()local function cT(cU)return type(cU)=='number'end;local function cV(cU)return type(z(cU))=='number'end;local function cW(cX)return type(cX)=='table'end;local function cY(cZ)return type(cZ)=='string'end;local function c_(cR)return cW(cR)and cT(cR.x and cR.y and cR.z)end;local function d0(d1)return cW(d1)and cT(d1.latitude and d1.longitude and d1.altitude and d1.id and d1.systemId)end;local d2=math.pi/180;local d3=180/math.pi;local epsilon=1e-10;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d4='::pos{'..B..','..B..','..B..','..B..','..B..'}'local utils=require('cpml.utils')local vec3=require('cpml.vec3')local function d5(cU)local d6=string.gsub(string.reverse(f('%.4f',cU)),'^0*%.?','')return d6==''and'0'or string.reverse(d6)end;local function d7(d8)if c_(d8)then return f('{x=%.3f,y=%.3f,z=%.3f}',d8.x,d8.y,d8.z)end;if cW(d8)and not getmetatable(d8)then local d9={}local da=next(d8)if type(da)=='nil'or da==1 then d9=d8 else for cQ,cR in pairs(d8)do local co=d7(cR)if type(cQ)=='number'then table.insert(d9,f('[%s]=%s',cQ,co))else table.insert(d9,f('%s=%s',cQ,co))end end end;return f('{%s}',table.concat(d9,','))end;if cY(d8)then return f("'%s'",d8:gsub("'",[[\']]))end;return tostring(d8)end;local db={}db.__index=db;db.__tostring=function(d8,dc)local dd={}for cQ in pairs(d8)do table.insert(dd,cQ)end;table.sort(dd)local d9={}for _,cQ in ipairs(dd)do local co=d7(d8[cQ])if type(cQ)=='number'then table.insert(d9,f('[%s]=%s',cQ,co))else table.insert(d9,f('%s=%s',cQ,co))end end;if dc then return f('%s%s',dc,table.concat(d9,',\n'..dc))end;return f('{%s}',table.concat(d9,','))end;db.__eq=function(de,df)return de.systemId==df.systemId and de.id==df.id and cr(de.radius,df.radius)and cr(de.center.x,df.center.x)and cr(de.center.y,df.center.y)and cr(de.center.z,df.center.z)and cr(de.GM,df.GM)end;local function dg(dh,di,dj,dk,dl)assert(cV(dh),'Argument 1 (systemId) must be a number:'..type(dh))assert(cV(di),'Argument 2 (id) must be a number:'..type(di))assert(cV(dj),'Argument 3 (radius) must be a number:'..type(dj))assert(cW(dk),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(dk))assert(cV(dl),'Argument 5 (GM) must be a number:'..type(dl))return setmetatable({systemId=z(dh),id=z(di),radius=z(dj),center=vec3(dk),GM=z(dl)},db)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return f('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,d5(p.latitude*d3),d5(p.longitude*d3),d5(p.altitude))end;MapPosition.__eq=function(de,df)return de.id==df.id and de.systemId==df.systemId and cr(de.latitude,df.latitude)and cr(de.altitude,df.altitude)and(cr(de.longitude,df.longitude)or cr(de.latitude,math.pi/2)or cr(de.latitude,-math.pi/2))end;local function dm(dn,di,dp,dq,dr)local dh=dn;if cY(dn)and not dq and not dr and not di and not dp then dh,di,dp,dq,dr=o(dn,d4)assert(dh,'Argument 1 (position string) is malformed.')else assert(cV(dh),'Argument 1 (systemId) must be a number:'..type(dh))assert(cV(di),'Argument 2 (id) must be a number:'..type(di))assert(cV(dp),'Argument 3 (latitude) must be in degrees:'..type(dp))assert(cV(dq),'Argument 4 (longitude) must be in degrees:'..type(dq))assert(cV(dr),'Argument 5 (altitude) must be in meters:'..type(dr))end;dh=z(dh)di=z(di)dp=z(dp)dq=z(dq)dr=z(dr)if di==0 then return setmetatable({latitude=dp,longitude=dq,altitude=dr,id=di,systemId=dh},MapPosition)end;return setmetatable({latitude=d2*r(dp,-90,90),longitude=d2*(dq%360),altitude=dr,id=di,systemId=dh},MapPosition)end;local ds={}ds.__index=ds;ds.__tostring=function(d8,dc)local dt=dc and dc..'  'local du={}local dd={}for cQ in pairs(d8)do table.insert(dd,cQ)end;table.sort(dd)for _,dv in ipairs(dd)do bdy=d8[dv]local dw=db.__tostring(bdy,dt)if dc then table.insert(du,f('[%s]={\n%s\n%s}',dv,dw,dc))else table.insert(du,f('  [%s]=%s',dv,dw))end end;if dc then return f('\n%s%s%s',dc,table.concat(du,',\n'..dc),dc)end;return f('{\n%s\n}',table.concat(du,',\n'))end;local function dx(dy)local b={}local pid;for _,cR in pairs(dy)do local di=cR.planetarySystemId;if type(di)~='number'then error('Invalid planetary system ID: '..tostring(di))elseif pid and di~=pid then error('Mistringmatch planetary system IDs: '..di..' and '..pid)end;local dz=cR.bodyId;if type(dz)~='number'then error('Invalid body ID: '..tostring(dz))elseif b[dz]then error('Duplicate body ID: '..tostring(dz))end;setmetatable(cR.center,getmetatable(vec3.unit_x))b[dz]=setmetatable(cR,db)pid=di end;return setmetatable(b,ds)end;aQ={}local function dA(dy)return setmetatable({galaxyAtlas=dy or{}},aQ)end;aQ.__index=function(cX,i)if type(i)=='number'then local system=cX.galaxyAtlas[i]return dx(system)end;return rawget(aQ,i)end;aQ.__pairs=function(d8)return function(cX,cQ)local dB,nv=next(cX,cQ)return dB,nv and dx(nv)end,d8.galaxyAtlas,nil end;aQ.__tostring=function(d8)local dC={}for _,dD in pairs(d8 or{})do local dE=dD:getPlanetarySystemId()local dF=ds.__tostring(dD,'    ')table.insert(dC,f('  [%s]={%s\n  }',dE,dF))end;return f('{\n%s\n}\n',table.concat(dC,',\n'))end;aQ.BodyParameters=dg;aQ.MapPosition=dm;aQ.PlanetarySystem=dx;function aQ.createBodyParameters(dh,di,dG,dH,dI,dJ,dK)assert(cV(dh),'Argument 1 (systemId) must be a number:'..type(dh))assert(cV(di),'Argument 2 (id) must be a number:'..type(di))assert(cV(dG),'Argument 3 (surfaceArea) must be a number:'..type(dG))assert(cW(dH),'Argument 4 (aPosition) must be an array or vec3:'..type(dH))assert(cW(dI),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(dI))assert(cV(dJ),'Argument 6 (altitude) must be in meters:'..type(dJ))assert(cV(dK),'Argument 7 (gravityAtPosition) must be number:'..type(dK))local dj=y(dG/4/math.pi)local aj=dj+dJ;local dL=vec3(dH)+aj*vec3(dI)local dl=dK*aj*aj;return dg(dh,di,dj,dL,dl)end;aQ.isMapPosition=d0;function aQ:getPlanetarySystem(dn)if i==nil then i=0 end;if nv==nil then nv=0 end;local dh=dn;if d0(dn)then dh=dn.systemId end;if type(dh)=='number'then local system=self.galaxyAtlas[i]if system then if getmetatable(nv)~=ds then system=dx(system)end;return system end end end;function ds:sizeCalculator(c2)return 1.05*c2.radius end;function ds:castIntersections(dM,dN,dO,dP,dQ,dR)local dS={}local dT=dQ or self;for _,c2 in pairs(dT)do table.insert(dS,c2)end;if not dR then table.sort(dS,function(dU,dV)return(dU.center-dM):len()<(dV.center-dM):len()end)end;local dW=dN:normalize()for _,c2 in ipairs(dS)do local dX=c2.center-dM;local dj=self:sizeCalculator(c2)local dY=dX:dot(dW)local dZ=dY^2-(dX:len2()-dj^2)if dZ>=0 then local d_=y(dZ)local c0=dY+d_;local c1=dY-d_;if c1>0 then return c2,c0,c1 elseif c0>0 then return c2,c0,nil end end end;return nil,nil,nil end;function ds:closestBody(e0)assert(type(e0)=='table','Invalid coordinates.')local e1,c2;local e2=vec3(e0)for _,e3 in pairs(self)do local e4=(e3.center-e2):len2()if(not c2 or e4<e1)and e3.name~="Space"then c2=e3;e1=e4 end end;return c2 end;function ds:convertToBodyIdAndWorldCoordinates(dn)local e5=dn;if cY(dn)then e5=dm(dn)end;if e5.id==0 then return 0,vec3(e5.latitude,e5.longitude,e5.altitude)end;local e3=self:getBodyParameters(e5)if e3 then return e5.id,e3:convertToWorldCoordinates(e5)end end;function ds:getBodyParameters(dn)local di=dn;if d0(dn)then di=dn.id end;assert(cV(di),'Argument 1 (id) must be a number:'..type(di))return self[di]end;function ds:getPlanetarySystemId()local _,cR=next(self)return cR and cR.systemId end;function db:convertToMapPosition(dk)assert(cW(dk),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(dk))local e6=vec3(dk)if self.id==0 then return setmetatable({latitude=e6.x,longitude=e6.y,altitude=e6.z,id=0,systemId=self.systemId},MapPosition)end;local e7=e6-self.center;local aj=e7:len()local dr=aj-self.radius;local dp=0;local dq=0;if not cr(aj,0)then local e8=n(e7.y,e7.x)dq=e8>=0 and e8 or 2*math.pi+e8;dp=math.pi/2-math.acos(e7.z/aj)end;return setmetatable({latitude=dp,longitude=dq,altitude=dr,id=self.id,systemId=self.systemId},MapPosition)end;function db:convertToWorldCoordinates(dn)local e5=cY(dn)and dm(dn)or dn;if e5.id==0 then return vec3(e5.latitude,e5.longitude,e5.altitude)end;assert(d0(e5),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(e5.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary system ID.')assert(e5.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local e9=math.cos(e5.latitude)return self.center+(self.radius+e5.altitude)*vec3(e9*math.cos(e5.longitude),e9*math.sin(e5.longitude),math.sin(e5.latitude))end;function db:getAltitude(dk)return(vec3(dk)-self.center):len()-self.radius end;function db:getDistance(dk)return(vec3(dk)-self.center):len()end;function db:getGravity(dk)local ea=self.center-vec3(dk)local eb=ea:len2()return self.GM/eb*ea/y(eb)end;return setmetatable(aQ,{__call=function(_,...)return dA(...)end})end;local function ec()local aS={}local ed=30000000/3600;local ee=ed*ed;local ef=100;function aS.computeAccelerationTime(eg,eh,ei)local ej=ed*math.asin(eg/ed)return(ed*math.asin(ei/ed)-ej)/eh end;function aS.computeDistanceAndTime(eg,ei,ek,el,em,en)em=em or 0;en=en or 0;local eo=eg<=ei;local ep=el*(eo and 1 or-1)/ek;local eq=-en/ek;local er=ep+eq;if eo and er<=0 or not eo and er>=0 then return-1,-1 end;local es,et=0,0;if ep~=0 and em>0 then local ej=math.asin(eg/ed)local eu=math.pi*(ep/2+eq)local ev=ep*em;local ew=ed*math.pi;local cR=function(cX)local ex=(eu*cX-ev*math.sin(math.pi*cX/2/em)+ew*ej)/ew;local ey=math.tan(ex)return ed*ey/y(ey*ey+1)end;local ez=eo and function(cZ)return cZ>=ei end or function(cZ)return cZ<=ei end;et=2*em;if ez(cR(et))then local eA=0;while d(et-eA)>0.5 do local cX=(et+eA)/2;if ez(cR(cX))then et=cX else eA=cX end end end;local eB=eg;local eC=et/ef;for eD=1,ef do local eE=cR(eD*eC)es=es+(eE+eB)*eC/2;eB=eE end;if et<2*em then return es,et end;eg=eB end;local ej=ed*math.asin(eg/ed)local E=(ed*math.asin(ei/ed)-ej)/er;local eF=ee*math.cos(ej/ed)/er;local aj=eF-ee*math.cos((er*E+ej)/ed)/er;return aj+es,E+et end;function aS.computeTravelTime(eg,eh,aj)if aj==0 then return 0 end;if eh>0 then local ej=ed*math.asin(eg/ed)local eF=ee*math.cos(ej/ed)/eh;return(ed*math.acos(eh*(eF-aj)/ee)-ej)/eh end;if eg==0 then return-1 end;assert(eg>0,'Acceleration and initial speed are both zero.')return aj/eg end;return aS end;local function eG()local vec3=require('cpml.vec3')local cS=cS()local function cY(cZ)return type(cZ)=='string'end;local function cW(cX)return type(cX)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(dr)assert(self.body)local aj=dr+self.body.radius;if not cr(aj,0)then local orbit=y(self.body.GM/aj)return y(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(dn,eH)assert(self.body)assert(cW(dn)or cY(dn))assert(cW(eH))local eI=(cY(dn)or cS.isMapPosition(dn))and self.body:convertToWorldCoordinates(dn)or vec3(dn)local cR=vec3(eH)local eJ=eI-self.body.center;local eK=cR:len2()local eL=eJ:len()local eM=self.body.GM;local eN=((eK-eM/eL)*eJ-eJ:dot(cR)*cR)/eM;local cs=eM/(2*eM/eL-eK)local eO=eN:len()local dW=eN:normalize()local eP=cs*(1-eO)local eQ=cs*(1+eO)local eR=eP*dW+self.body.center;local eS=eO<=1 and-eQ*dW+self.body.center or nil;local eT=y(cs*eM*(1-eO*eO))local eU=eS and 2*math.pi*y(cs^3/eM)local eV=math.acos(eN:dot(eJ)/(eO*eL))if eJ:dot(cR)<0 then eV=-(eV-2*math.pi)end;local eW=math.acos((math.cos(eV)+eO)/(1+eO*math.cos(eV)))local eX=eW;if eX<0 then eX=eX+2*math.pi end;local eY=eX-eO*math.sin(eX)local eZ=0;local e_=0;local f0=0;if eU~=nil then eZ=eY/(2*math.pi/eU)e_=eU-eZ;f0=e_+eU/2;if eV-math.pi>0 then e_=eZ;f0=e_+eU/2 end;if f0>eU then f0=f0-eU end end;return{periapsis={position=eR,speed=eT/eP,circularOrbitSpeed=y(eM/eP),altitude=eP-self.body.radius},apoapsis=eS and{position=eS,speed=eT/eQ,circularOrbitSpeed=y(eM/eQ),altitude=eQ-self.body.radius},currentVelocity=cR,currentPosition=eI,eccentricity=eO,period=eU,eccentricAnomaly=eW,meanAnomaly=eY,timeToPeriapsis=e_,timeToApoapsis=f0}end;local function f1(f2)local e3=cS.BodyParameters(f2.systemId,f2.id,f2.radius,f2.center,f2.GM)return setmetatable({body=e3},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return f1(...)end})end;local function f3()local f4={}local f5={}local f6={XS=13,S=27,M=55,L=110,XL=221}local f7={}local f8;local f9;local fa;local fb;local fc;local function fd()local function fe(ff,fg,fh,fi,fj,fk,fl,fm)fg,fi,fk,fm=vec3(fg),vec3(fi),vec3(fk),vec3(fm)local fn,fo,fp=ff*ff,fh*fh,fj*fj;local eK=fi-fg;local fq=eK:normalize()local fr=eK:len()local fs=fk-fg;local ft=(fs-fs:project_on(fq)):normalize()local fu,fv=fs:dot(fq),fs:dot(ft)local fw=fu*fu+fv*fv;local fx=fq:cross(ft)local ci=(fn-fo+fr*fr)/(2*fr)local cj=(fn-fp+fw-2*fu*ci)/(2*fv)local d1=fn-ci^2-cj^2;local fy=y(d1)local fz=fg+fq*ci+ft*cj+fx*fy;local fA=fg+fq*ci+ft*cj-fx*fy;if d((fm-fz):len()-fl)<d((fm-fA):len()-fl)then return fz else return fA end end;local function fB()local function fC()local fD=core.getConstructWorldOrientationRight()local eK=core.getConstructWorldOrientationForward()local fs=core.getConstructWorldOrientationUp()local fE=library.systemResolution3(fD,eK,fs,{1,0,0})local fF=library.systemResolution3(fD,eK,fs,{0,1,0})local fG=library.systemResolution3(fD,eK,fs,{0,0,1})return function(fH)return library.systemResolution3(fE,fF,fG,fH)end end;local fI=fC()local fJ=core.getConstructWorldPos()local eI=core.getElementPositionById(1)local fK={eI[1],eI[2],eI[3]}local fL=fI(fK)local fM={fJ[1]-fL[1],fJ[2]-fL[2],fJ[3]-fL[3]}return fM end;local function fN(fO,eL,fP)local fQ=fO.pts;local fR=#fQ;local fS=fO.ref;if fR>3 then local fT,fU,fV,fW=fQ[fR],fQ[fR-1],fQ[fR-2],fQ[fR-3]fO.ref=fP;local eI=fe(fT[1],fT[2],fU[1],fU[2],fV[1],fV[2],fW[1],fW[2])local ci,cj,fy=eI.x,eI.y,eI.z;if ci==ci and cj==cj and fy==fy then ci=ci+fS[1]cj=cj+fS[2]fy=fy+fS[3]local fX=vec3(ci,cj,fy)if not fO.lastPos then fO.center=fX elseif(fO.lastPos-fX):len()<2 then fO.center=fX;fO.skipCalc=true end;fO.lastPos=fX end;fO.pts={}else local fY={fP[1]-fS[1],fP[2]-fS[2],fP[3]-fS[3]}fQ[fR+1]={eL,fY}end end;if bP[1]then f8=#bP[1].getConstructIds()local fZ=bP[1].getData()local f_=fZ:gmatch('{"constructId[^}]*}[^}]*}')if f8>0 then local fP=fB()local g0,g1=0,0;fc,fb=0,0;for cR in f_ do local di,aj,g2=cR:match([[{"constructId":"([%d%.]*)","distance":([%d%.]*).-"size":"(%a+)"]])local g3=f6[g2]aj=z(aj)if bP[1].hasMatchingTransponder(di)==1 then table.insert(f5,di)end;local g4=bP[1].getConstructType(di)if CollisionSystem then if g3>27 or g4=="static"or g4=="space"then fc=fc+1;local g5=bP[1].getConstructName(di)local fO=bL[di]if fO==nil then g3=g3+G;bL[di]={pts={},ref=fP,name=g5,i=0,radius=g3,skipCalc=false}fO=bL[di]end;if not fO.skipCalc then fN(fO,aj,fP)g1=g1+1 end;if fO.center then table.insert(f7,fO)end end;g0=g0+1;if bM and g0>700 or g1>70 or(not bM and g0>300 or g1>30)then coroutine.yield()g0,g1=0,0 end end end;fb=#f7;if fb>0 and bs>20 then local c2,g6,g7,g8;local g9=0;local ga=aR:getPlanetarySystem(0)g8=br:normalize()while g9<fb do coroutine.yield()local gb={table.unpack(f7,g9,math.min(g9+75,fb))}c2,g6,g7=ga:castIntersections(bv,g8,nil,nil,gb,true)if c2 and g7 then bO={c2,g6,g7}break end;g9=g9+75 end;if not c2 then bO=nil end else bO=nil end;f7={}f9=fZ:find('identifiedConstructs":%[%]')else fa=fZ:find('worksInEnvironment":false')end end end;local function gc()if bP[1]then bQ="Atmo"if bP[1].getData():find('worksInAtmosphere":false')then bQ="Space"end end end;function f4.pickType()gc()end;function f4.assignRadar()if radar_1 and bP[1]==radar_1 and radar_1.isOperational()~=1 then if radar_2 and radar_2.isOperational()==1 then bP[1]=radar_2 end;if bP[1]==radar_2 then gc()end elseif radar_2 and bP[1]==radar_2 and radar_2.isOperational()~=1 then if radar_1 and radar_1.isOperational()==1 then bP[1]=radar_1 end;if bP[1]==radar_1 then gc()end end end;function f4.UpdateRadar()local gd=coroutine.status(UpdateRadarCoroutine)if gd=="suspended"then local co,ge=coroutine.resume(UpdateRadarCoroutine)if ge then system.print("ERROR UPDATE RADAR: "..ge)end elseif gd=="dead"then UpdateRadarCoroutine=coroutine.create(fd)local co,ge=coroutine.resume(UpdateRadarCoroutine)end end;function f4.GetRadarHud()local gf=f5;f5={}return f9,fa,f8,fb,fc,gf end;UpdateRadarCoroutine=coroutine.create(fd)return f4 end;local function gg(cR)if aG==1920 then return cR else return A(aG*cR/1920,0)end end;local function gh(cR)if aH==1080 then return cR else return A(aH*cR/1080,0)end end;local function gi()local gj=9.80665;local gk=vec3({13771471,7435803,-128971})local gl=18000000;local gm=500000;local gn,go=math.huge;local gp;local function gq(gr)gn=vec3(gr):dist(gk)if gn<gl then return true,d(gn-gl)end;go=vec3(gr):dist(vec3(planet.center))if go<gm then gp=true else gp=false end;if d(go-gm)<d(gn-gl)then return gp,d(go-gm)else return gp,d(gn-gl)end end;local function gs()return x()==0 and userControlScheme~="keyboard"and m()==0 end;local function gt()local gu="TRAVEL"if not bA then gu="CRUISE"end;if Autopilot then gu="AUTOPILOT"end;return gu end;local gv=""local gw=""local gx=""local gy=1;local gz=2;local gA=3;local gB=4;local gC=5;local gD=6;local gE=""local gF=0;local gG=e(1/apTickRate)*2*hudTickRate;local gH={}local gI={}local gJ={}local gK={}local gL={}local gM={}local function gN(ci,gO,gP,gQ,gR,gS)local gT=tankY;local gU=tankY+5;if not BarFuelDisplay then gU=gU+5 end;if m()==1 and not RemoteHud then gT=gT-50;gU=gU-50 end;if gP=="ATMO"then gE="atmofueltank"elseif gP=="SPACE"then gE="spacefueltank"else gE="rocketfueltank"end;gF=_G[gE.."_size"]if#gQ>0 then for i=1,#gQ do local g5=string.sub(gQ[i][gz],1,12)local gV=0;for gW=1,gF do if gQ[i][gz]==g(unit[gE.."_"..gW].getData()).name then gV=gW;break end end;local gX=q()if gR[i]==nil or gS[i]==nil or gX-gQ[i][gD]>gG then local gY;local gZ=0;if gV~=0 then gS[i]=g(unit[gE.."_"..gV].getData()).percentage;gR[i]=g(unit[gE.."_"..gV].getData()).timeLeft;if gR[i]=="n/a"then gR[i]=0 end else gZ=l(gQ[i][gy])-gQ[i][gB]gS[i]=e(0.5+gZ*100/gQ[i][gA])gY=gQ[i][gC]if gY<=gZ then gR[i]=0 else gR[i]=e(0.5+gZ/((gY-gZ)/(gX-gQ[i][gD])))end;gQ[i][gC]=gZ;gQ[i][gD]=gX end end;if g5==gO then g5=f("%s %d",gP,i)end;if gV==0 then g5=g5 .." *"end;local g_;if gR[i]==0 then g_=""else g_=cH(gR[i])end;if gS[i]~=nil then local h0=e(gS[i]*2.55)local h1=f("rgb(%d,%d,%d)",255-h0,h0,0)local cl=""if g_~=""and gR[i]<120 or gS[i]<5 then cl="red "end;if BarFuelDisplay then gw=gw..f([[
                                            <g class="pdim">                        
                                            <rect fill=#222222 class="bar" x="%d" y="%d" width="170" height="20"></rect></g>
                                            <g class="bar txtstart">
                                            <rect fill=%s width="%d" height="20" x="%d" y="%d"></rect>
                                            <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%% %s</text>
                                            </g>]],ci,gU,h1,e(gS[i]*1.7+0.5),ci,gU,ci+5,gU+14,g5,gS[i],g_)gT=gT-22;gU=gU-22 else gw=gw..ch(ci,gT,g5,cl.."pdim txtfuel")gw=gw..ch(ci,gU,f("%d%% %s",gS[i],g_),"pdim txtfuel","fill:"..h1)gT=gT+30;gU=gU+30 end end end end;tankY=gT end;local function h2(h3,dr)if dr<200000 and not aq or dr and aq then local h4=0;if d(bu)>1 then h4=45*math.log(d(bu),10)if bu<0 then h4=-h4 end end;h3[#h3+1]=f([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,e(bu),e(h4))end;return h3 end;local function h5(h6)local h7=-bt;h6=h6-h6:project_on(h7)local h8=vec3(0,0,1)h8=h8-h8:project_on(h7)local h9=h8:cross(h7)local h4=h8:angle_between(h6)*constants.rad2deg;if h6:dot(h9)<0 then h4=360-h4 end;return h4 end;local function ha(h3,centerX,centerY,hb,hc,bM)local hd=circleRad;local he=20;local hf=e(hb)if bM then for i=-45,45,5 do local hg=i;h3[#h3+1]=f([[<g transform="rotate(%f,%d,%d)">]],hg,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;h3[#h3+1]=f([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+hd+he-len,centerX,centerY+hd+he)end;h3[#h3+1]=ch(centerX,centerY+hd+he-35,hc,"pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY+hd+he-25,hf.." deg","pdim txt txtmid")h3[#h3+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hb,centerX,centerY)h3[#h3+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+hd+he-20,centerX+5,centerY+hd+he-20,centerX,centerY+hd+he-15)h3[#h3+1]="</g>"end;h3[#h3+1]=[[<g style="clip-path: url(#headingClip);">]]local hh=hf;if bM then hh=h5(bo)end;local hi=20;local hj=e(hh)local hk=0;local hl=centerY+hd+he+20;local hm=centerX;if hc~="YAW"then hl=gh(130)hm=gg(960)end;local hn=[[<path class="txttick line" d="]]local ho=e(hj-(hi+10)-hj%5+0.5)for i=ho+70,ho,-5 do local ci=hm-(-i*5+hh*5)if i%10==0 then hk=10;local B=i;if B==360 then B=0 elseif B>360 then B=B-360 elseif B<0 then B=B+360 end;h3[#h3+1]=ch(ci,hl+15,B,"txtmid bright")elseif i%5==0 then hk=5 end;if hk==10 then hn=f([[%s M %f %f v %d]],hn,ci,hl-5,hk)else hn=f([[%s M %f %f v %d]],hn,ci,hl-2.5,hk)end end;h3[#h3+1]=hn..[["/>]]h3[#h3+1]=f([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],hm-5,hl-20,hm+5,hl-20,hm,hl-10)if bM then hc="HDG"end;h3[#h3+1]=ch(gg(960),gh(100),hj.."°","dim txt txtmid size14","")h3[#h3+1]=ch(gg(960),gh(85),hc,"dim txt txtmid size20","")h3[#h3+1]=[[</g>]]end;local function hp(h3,hq,hb,centerX,centerY,bM,hr,eE)local hd=circleRad;local hs=e(hd*3/5)if hd>0 then local ht=e(hq)local len=0;local hn=f([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*hb,centerX,centerY)if not aq then hn=f([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;h3[#h3+1]=f([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],hd-1,centerX,centerY)h3[#h3+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=e(ht-30-ht%5+0.5),e(ht+30+ht%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local cj=centerY+-i*5+hq*5;if len==30 then hn=f([[%s M %d %f h %d]],hn,centerX-hs-len,cj,len)if aq then h3[#h3+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hb,centerX,centerY,centerX-hs+10,cj+4,i)h3[#h3+1]=f([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hb,centerX,centerY,centerX+hs-10,cj+4,i)if i==0 or i==180 or i==-180 then h3[#h3+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hb,centerX,centerY,centerX-hs+20,cj,hs*2-40)end else h3[#h3+1]=ch(centerX-hs+10,cj,i,"pdim txt txtmid")h3[#h3+1]=ch(centerX+hs-10,cj,i,"pdim txt txtmid")end;hn=f([[%s M %d %f h %d]],hn,centerX+hs,cj,len)else hn=f([[%s M %d %f h %d]],hn,centerX-hs-len,cj,len)hn=f([[%s M %d %f h %d]],hn,centerX+hs,cj,len)end end;h3[#h3+1]=hn..[["/>]]local hu="PITCH"if not bM then hu="REL PITCH"end;if hq>90 and not aq then hq=90-(hq-90)elseif hq<-90 and not aq then hq=-90-(hq+90)end;if hd>200 then if aq then if eE>Q then h3[#h3+1]=ch(centerX,centerY-15,"Yaw","pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY+20,hr,"pdim txt txtmid")end;h3[#h3+1]=f([[<g transform="rotate(%f,%d,%d)">]],-hb,centerX,centerY)else h3[#h3+1]=f([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;h3[#h3+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hs+25,centerY-5,centerX-hs+20,centerY,centerX-hs+25,centerY+5,centerX-hs+50,centerY+4,ht)h3[#h3+1]=f([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hs-25,centerY-5,centerX+hs-20,centerY,centerX+hs-25,centerY+5,centerX+hs-30,centerY+4,ht)h3[#h3+1]="</g>"end;local hv=e(hd/3)h3[#h3+1]=f([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hv,centerY,hd-hv)if not aq and bM then h3[#h3+1]=f([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hb,centerX,centerY,centerX-hs+10,centerY,hs*2-20)end;h3[#h3+1]="</g>"if hd<200 then if aq and eE>Q then h3[#h3+1]=ch(centerX,centerY-hd,hu,"pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY-hd+10,ht,"pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY-15,"Yaw","pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY+20,hr,"pdim txt txtmid")else h3[#h3+1]=ch(centerX,centerY-hd,hu,"pdim txt txtmid")h3[#h3+1]=ch(centerX,centerY-hd+15,ht,"pdim txt txtmid")end end end end;local function hw(h3,dr,bM)local hx=altMeterX;local hy=altMeterY;local hz=78;local hA=19;local hB=ao;if ao~=-1 then h3[#h3+1]=ch(hx+hz,hy+hA+20,f("AGL: %.1fm",ao),"pdim altsm txtend")end;if bM and(dr<200000 and not aq or dr and aq)then table.insert(h3,f([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],hx-1,hy-4,hz+2,hA+6,hx+1,hy-1,hz-4,hA))local fR=0;local hC=1;local hD=0;local hE=dr<0;local hF=dr<planet.surfaceMaxAltitude;local hG=9;if hE then hG=0 end;local dr=d(dr)while fR<6 do local hH=11;local hI=16;local hJ=9;local hK=14;local cl="altsm"if fR>2 then hI=hI+3;hH=hH+2;hK=hK+2;hJ=hJ-6;cl="altbig"end;if hE then cl=cl.." red"elseif hF then cl=cl.." orange"end;local hL=dr/hC%10;local hM=e(hL)local hN=e((hM+1)%10)local hO=hD;if fR==0 then hO=hL-hM;if hE then hO=1-hO end end;if hE and(fR==0 or hD~=0)then local hP=hN;hN=hM;hM=hP end;local hQ=hI*(hO-1)local hR=hQ+hI;local ci=hx+hJ+(6-fR)*hH;local cj=hy+hK;h3[#h3+1]=ch(ci,cj+hQ,hN,cl)h3[#h3+1]=ch(ci,cj+hR,hM,cl)fR=fR+1;hC=hC*10;if hM==hG then hD=hO else hD=0 end end;table.insert(h3,[[</g></g>]])end end;local function hS(eH)local hT=-math.deg(n(eH.y,eH.z))+180;hT=hT-90;if hT<0 then hT=360+hT end;if hT>180 then hT=-180+hT-180 end;return-hT end;local function hU(eH)local hh=math.deg(n(eH.y,eH.x))-90;if hh<-180 then hh=360+hh end;return hh end;local function hV(h3,eH,eE,centerX,centerY)if eE>5 and not aq or eE>Q then local hd=circleRad;local hW=20;local hX=20;local hY=hS(eH)local hZ=hU(eH)local h_=14;local i0=h_/2;local i1=-hZ/hX*hd;local i2=hY/hW*hd;local ci=centerX+i1;local cj=centerY+i2;local aj=y(i1^2+i2^2)local i3=[[<circle
                            cx="]]..ci..[["
                            cy="]]..cj..[["
                            r="]]..i0/h_..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..ci..[["
                            cy="]]..cj..[["
                            r="]]..i0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..ci-h_..[[,]]..cj..[[ h ]]..i0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ci+i0 ..[[,]]..cj..[[ h ]]..i0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..ci..[[,]]..cj-h_..[[ v ]]..i0 ..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if aj<hd then h3[#h3+1]=i3 else local h4=n(i2,i1)local i4=4;local i5=centerX+hd*math.cos(h4)local i6=centerY+hd*math.sin(h4)h3[#h3+1]=f('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',h4*180/math.pi,i5,i6,i5-i4,i6-i4/2,i4*2,i4,i5+i4,i6-i4,i4,i4,-i4,i4)end;if not aq then local i7=vec3(eH)hY=hS(-i7)hZ=hU(-i7)i1=-hZ/hX*hd;i2=hY/hW*hd;ci=centerX+i1;cj=centerY+i2;aj=y(i1^2+i2^2)if aj<hd then local i8=[[<circle
                                    cx="]]..ci..[["
                                    cy="]]..cj..[["
                                    r="]]..i0 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..ci..[[,]]..cj-h_..[[ v ]]..i0 ..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..ci..[[,]]..cj..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..ci..[[,]]..cj..[[)" />
                                <path
                                    d="M ]]..ci-i0 ..[[,]]..cj..[[ h ]]..h_..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..ci..[[,]]..cj..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..ci..[[,]]..cj..[[)"/>]]h3[#h3+1]=i8 end end end end;local function i9(h3,gu,ia,ib)ia=e(ia+0.5)local gT=throtPosY+10;local gU=throtPosY+20;if m()==1 and not RemoteHud then gT=55;gU=65 end;local ic="CRUISE"local unit="km/h"local co=ib;if gu=="TRAVEL"or gu=="AUTOPILOT"then ic="THROT"unit="%"co=ia;local id="dim"if ia<0 then id="red"end;h3[#h3+1]=f([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],id,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-d(ia),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;h3[#h3+1]=ch(throtPosX+10,gT,ic,"pbright txtstart")h3[#h3+1]=ch(throtPosX+10,gU,f("%.0f %s",co,unit),"pbright txtstart")if aq and AtmoSpeedAssist and bA and M then ia=e(N*100+0.5)local id="red"if ia<0 then id="red"end;h3[#h3+1]=f([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],id,1-d(ia),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)h3[#h3+1]=ch(throtPosX+10,gT+40,"LIMIT","pbright txtstart")h3[#h3+1]=ch(throtPosX+10,gU+40,ia.."%","pbright txtstart")end;if aq and AtmoSpeedAssist or Reentry then h3[#h3+1]=ch(throtPosX+10,gT-40,"LIMIT: "..b7 .." km/h","dim txtstart")elseif not aq and Autopilot then h3[#h3+1]=ch(throtPosX+10,gT-40,"LIMIT: "..e(MaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function ie(h3,ig)local ih=throtPosY-10;local ii=throtPosX+10;h3[#h3+1]=ch(0,0,"","pdim txt txtend")if m()==1 and not RemoteHud then ih=75 end;h3[#h3+1]=ch(ii,ih,e(ig).." km/h","pbright txtbig txtstart")end;local function ij(h3)h3[#h3+1]=ch(gg(1900),gh(1070),f("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")h3[#h3+1]=[[<g class="warnings">]]if unit.isMouseControlActivated()==1 then h3[#h3+1]=ch(gg(960),gh(550),"Warning: Invalid Control Scheme Detected","warnings")h3[#h3+1]=ch(gg(960),gh(600),"Keyboard Scheme must be selected","warnings")h3[#h3+1]=ch(gg(960),gh(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local ik=gg(960)local il=gh(860)local im=gh(880)local io=gh(900)local ip=gh(960)local iq=gh(200)local ir=gh(250)local is=gh(960)if m()==1 and not RemoteHud then il=gh(135)im=gh(155)io=gh(175)iq=gh(115)ir=gh(95)end;local it="#222222"local iu="white"local iv="dimmer"local iw="pbright"local ix="#110000"local iy=it;local iz=iv;if BrakeIsOn then h3[#h3+1]=ch(ik,il,"Brake Engaged","warnings")ix="#440000"iy=iu;iz=iw elseif L>0 then h3[#h3+1]=ch(ik,il,"Auto-Brake Engaged","warnings","opacity:"..L)end;local iA="#110000"local iB=it;local iC=iv;if aq and b2 and ao==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not by and not VertTakeOff and not AutoTakeoff then h3[#h3+1]=ch(ik,iq+50,"** STALL WARNING **","warnings")iA="#ff0000"iB=iu;iC=iw;c4("stall","SW",2)end end;if bK then h3[#h3+1]=ch(ik,iq+90,"Flight Assist in Progress","warnings")end;if ax then h3[#h3+1]=ch(ik,is,"Gyro Enabled","warnings")end;local iD="#111100"local iE=it;local iF=iv;if GearExtended then iD="#775500"iE=iu;iF=iw;if S then h3[#h3+1]=ch(ik,im,"Gear Extended","warn")else h3[#h3+1]=ch(ik,im,"Landed (G: Takeoff)","warnings")end;local iG=cu(a:getTargetGroundAltitude())h3[#h3+1]=ch(ik,io,"Hover Height: "..iG,"warn")end;local iH="#000011"local iI=it;local iJ=iv;if a7 then iH="#0000DD"iI=iu;iJ=iw;h3[#h3+1]=ch(ik,ip+20,"ROCKET BOOST ENABLED","warn")end;local iK="#001100"local iL=it;local iM=iv;if antigrav and not ExternalAGG and by and AntigravTargetAltitude~=nil then iK="#00DD00"iL=iu;iM=iw;if d(as-antigrav.getBaseAltitude())<501 then h3[#h3+1]=ch(ik,iq+15,f("Target Altitude: %d Singularity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warn")else h3[#h3+1]=ch(ik,iq+15,f("Target Altitude: %d Singluarity Altitude: %d",e(AntigravTargetAltitude),e(antigrav.getBaseAltitude())),"warnings")end elseif Autopilot and AutopilotTargetName~="None"then h3[#h3+1]=ch(ik,iq+20,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then h3[#h3+1]=ch(ik,iq+20,f("LockedPitch: %d",e(LockPitch)),"warn")elseif a0 then h3[#h3+1]=ch(ik,iq+20,"Follow Mode Engaged","warn")elseif Reentry or an then h3[#h3+1]=ch(ik,iq+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local iG=cu(HoldAltitude,2)if VertTakeOff then if by then iG=cu(antigrav.getBaseAltitude(),2).." AGG singularity height"end;h3[#h3+1]=ch(ik,iq,"VTO to "..iG,"warn")elseif AutoTakeoff and not IntoOrbit then if am then h3[#h3+1]=ch(ik,iq,"Takeoff to "..AutopilotTargetName,"warn")else h3[#h3+1]=ch(ik,iq,"Takeoff to "..iG,"warn")end;if BrakeIsOn and not VertTakeOff then h3[#h3+1]=ch(ik,iq+50,"Throttle Up and Disengage Brake For Takeoff","crit")end else h3[#h3+1]=ch(ik,iq,"Altitude Hold: "..iG,"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if ar>0.1 then h3[#h3+1]=ch(ik,iq+20,"Beginning ascent","warn")elseif ar<0.09 and ar>0.05 then h3[#h3+1]=ch(ik,iq+20,"Aligning trajectory","warn")elseif ar<0.05 then h3[#h3+1]=ch(ik,iq+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if b9~=nil then h3[#h3+1]=ch(ik,iq,b9,"warn")end end;if BrakeLanding then if StrongBrakes then h3[#h3+1]=ch(ik,iq,"Brake-Landing","warnings")else h3[#h3+1]=ch(ik,iq,"Coast-Landing","warnings")end end;if ProgradeIsOn then h3[#h3+1]=ch(ik,iq,"Prograde Alignment","crit")end;if RetrogradeIsOn then h3[#h3+1]=ch(ik,iq,"Retrograde Alignment","crit")end;local iN="#110000"local iO=it;local iP=iv;if bN then iN="#FF0000"iO=iu;iP=iw;local type;if string.find(bN,"COLLISION")then type="warnings"else type="crit"end;h3[#h3+1]=ch(ik,ir+20,bN,type)elseif ar==0 then local b_,c3=bY(br:normalize())if c3~=nil then iP=iw;iN="#FF0000"iO=iu;local iG=cu(c3)local travelTime=aS.computeTravelTime(bs,0,c3)local iQ="Collision"if b_.noAtmosphericDensityAltitude>0 then iQ="Atmosphere"end;h3[#h3+1]=ch(ik,ir+20,b_.name.." "..iQ.." "..cH(travelTime).." In "..iG,"crit")end end;if VectorToTarget and not IntoOrbit then h3[#h3+1]=ch(ik,iq+35,VectorStatus,"warn")end;local iR="#111100"local iS=it;local iT=iv;if passengers and#passengers>1 then iR="#DDDD00"iS=iu;iT=iw end;local iU=gg;local iV=gh;local iv="topButton"local iW="topButtonActive"local iX=iv;if Autopilot or VectorToTarget or am or IntoOrbit then iX=iW end;local iY=iv;if ProgradeIsOn then iY=iW end;local iZ=iv;if BrakeLanding or GearExtended then iZ=iW end;local i_=iv;if AltitudeHold or VectorToTarget then i_=iW end;local j0=iv;if RetrogradeIsOn then j0=iW end;local j1=iv;if IntoOrbit or bi and Autopilot then j1=iW end;local j2=iV(30)h3[#h3+1]=f([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],iX,iU(960),iV(54),iV(-53),iU(-120),iU(25),iV(50))h3[#h3+1]=ch(iU(910),j2,"AUTOPILOT")h3[#h3+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iY,iU(865),iV(51),iU(-25),iV(-50),iU(-110),iU(25),iV(46))h3[#h3+1]=ch(iU(800),j2,"PROGRADE")h3[#h3+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],iZ,iU(755),iV(47),iU(-25),iV(-46),iU(-98),iU(44),iV(44))h3[#h3+1]=ch(iU(700),j2,"LAND")h3[#h3+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],i_,iU(960),iV(54),iV(-53),iU(120),iU(-25),iV(50))h3[#h3+1]=ch(iU(1010),j2,"ALT HOLD")h3[#h3+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j0,iU(1055),iV(51),iU(25),iV(-50),iU(110),iU(-25),iV(46))h3[#h3+1]=ch(iU(1122),j2,"RETROGRADE")h3[#h3+1]=f([[
                                </g>
        
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],j1,iU(1165),iV(47),iU(25),iV(-46),iU(98),iU(-44),iV(44))h3[#h3+1]=ch(iU(1220),j2,"ORBIT")h3[#h3+1]=[[
                                </g>
                            </g>]]h3[#h3+1]="</g>"return h3 end;local function j3(eE)return e(A(eE*3.6,0)+0.5).." km/h"end;local function j4(h3)local ci=OrbitMapX+10;local cj=OrbitMapY+20;local j5={}local j6={"Alt-4: AutoTakeoff to Target"}local j7={"Alt-6: Altitude hold at current altitude","Alt-6-6: Altitude Hold at 11% atmosphere","Alt-Q/E: Hard Bankroll left/right till released","Alt-S: 180 deg bank turn"}local j8={"Alt-6: Orbit at current altitude","Alt-6-6: Orbit at LowOrbitHeight over atmosphere"}local j9={"","------------------ALWAYS--------------------","Alt-1: Increment Interplanetary Helper","Alt-2: Decrement Interplanetary Helper","Alt-3: Toggle Vanilla Widget view","Alt-4: Autopilot to IPH target","Alt-5: Lock Pitch at current pitch","Alt-7: Toggle Collision System on and off","Alt-8: Toggle ground stabilization (underwater flight)","CTRL: Toggle Brakes on and off. Cancels active AP","LAlt: Tap to shift freelook on and off","Shift: Hold while not in freelook to see Buttons","Type /commands or /help in lua chat to see text commands"}table.insert(j5,"--------------DYNAMIC-----------------")if aq then if ao~=-1 then c7(j5,j6)if ac and planet and ac.name==planet.name then table.insert(j5,"Alt-4-4: Low Orbit Autopilot to Target")end;if antigrav or VertTakeOffEngine then if antigrav then if by then table.insert(j5,"Alt-6: AGG is on, will takeoff to AGG Height")else table.insert(j5,"Turn on AGG to takeoff to AGG Height")end end;if VertTakeOffEngine then table.insert(j5,"Alt-6: Begins Vertical AutoTakeoff.")end else table.insert(j5,"Alt-6: Autotakeoff to AutoTakeoffAltitude")table.insert(j5,"Alt-6-6: Autotakeoff to 11% atmosphere")end;if GearExtended then table.insert(j5,"G: Takeoff to hover height, raise gear")else table.insert(j5,"G: Lowergear and Land")end else c7(j5,j7)table.insert(j5,"G: Begin BrakeLanding or Land")end;if VertTakeOff then table.insert(j5,"Hit Alt-6 before exiting Atmosphere during VTO to hold in level flight")end else c7(j5,j8)if shield_1 then table.insert(j5,"Alt-Shift-5: Toggle shield off and on")table.insert(j5,"Alt-Shift-6: Vent shields")end end;if gyro then table.insert(j5,"Alt-9: Activate Gyroscope")end;if ExtraLateralTags~="none"or ExtraLongitudeTags~="none"or ExtraVerticalTags~="none"then table.insert(j5,"Alt-Shift-9: Cycles engines with Extra tags")end;if AltitudeHold then table.insert(j5,"Alt-Spacebar/C will raise/lower target height")table.insert(j5,"Alt+Shift+Spacebar/C will raise/lower target to preset values")end;if AtmoSpeedAssist or not aq then table.insert(j5,"LALT+Mousewheel will lower/raise speed limit")end;c7(j5,j9)for i=1,#j5 do cj=cj+12;h3[#h3+1]=ch(ci,cj,j5[i],"pdim txttick txtstart")end end;local function ja(h3)local jb=gg(OrbitMapX)local jc=gh(OrbitMapY)local jd=OrbitMapSize;local je=4;local jf=15;local ci=0;local cj=0;local jg,jh,ji,jj;local function jk(type)local jl,E,eE,jm;if type=="Periapsis"then jl=orbit.periapsis.altitude;E=orbit.timeToPeriapsis;eE=orbit.periapsis.speed;jm=35 else jl=orbit.apoapsis.altitude;E=orbit.timeToApoapsis;eE=orbit.apoapsis.speed;jm=-35 end;h3[#h3+1]=f([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],ci+jm,cj-5,jb+jd/2-jg+jj,cj-5)h3[#h3+1]=ch(ci,cj,type)cj=cj+jf;local iG=cu(jl)h3[#h3+1]=ch(ci,cj,iG)cj=cj+jf;h3[#h3+1]=ch(ci,cj,cH(E))cj=cj+jf;h3[#h3+1]=ch(ci,cj,j3(eE))end;local jn=jd*1.5;if SelectedTab=="INFO"then jn=25*7 end;if SelectedTab~="HIDE"then h3[#h3+1]=[[<g class="pbright txtorb txtmid">]]h3[#h3+1]=f('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',jd*2,jn,jb,jc)end;if SelectedTab=="ORBIT"then jc=jc+je;ci=jb+jd+je;cj=jc+jd*1.5/2+5+je;jg=jd/4;jj=0;if orbit.periapsis~=nil and orbit.apoapsis~=nil then ji=(orbit.apoapsis.altitude+orbit.periapsis.altitude+planet.radius*2)/(jg*2)jh=(planet.radius+orbit.periapsis.altitude+(orbit.apoapsis.altitude-orbit.periapsis.altitude)/2)/ji*(1-orbit.eccentricity)jj=jg-orbit.periapsis.altitude/ji-planet.radius/ji;local jo=""if orbit.periapsis.altitude<=0 then jo='redout'end;h3[#h3+1]=f([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],jo,jb+jd+jj+je,jc+jd*1.5/2+je,jg,jh)h3[#h3+1]=f('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />',jb+jd+je,jc+jd*1.5/2+je,planet.radius/ji)end;if orbit.apoapsis~=nil and orbit.apoapsis.speed<MaxGameVelocity and orbit.apoapsis.speed>1 then jk("Apoapsis")end;cj=jc+jd*1.5/2+5+je;ci=jb-jb+10+je;if orbit.periapsis~=nil and orbit.periapsis.speed<MaxGameVelocity and orbit.periapsis.speed>1 then jk("Periapsis")end;h3[#h3+1]=ch(jb+jd+je,jc+20+je,planet.name,"txtorbbig")if orbit.period~=nil and orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.apoapsis.speed>1 then local jp=orbit.timeToApoapsis/orbit.period*2*math.pi;local jq=jg*math.cos(jp)local jr=jh*math.sin(jp)h3[#h3+1]=f('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />',jb+jd+jq+jj+je,jc+jd*1.5/2+jr+je)end;h3[#h3+1]=[[</g>]]return h3 elseif SelectedTab=="INFO"then h3=aV.DrawOdometer(h3,ad,TotalDistanceTravelled,ae)elseif SelectedTab=="HELP"then h3=j4(h3)else return h3 end end;local function js(jt,ju)local jv;local jw=(ju-jt):normalize()local eJ=(bv-jt):dot(jw)/jw:dot(jw)if eJ<=0.then return(bv-jt):len()elseif eJ>=(ju-jt):len()then return(bv-ju):len()end;local jx=jt+eJ*jw;jv=(jx-bv):len()return jv end;local function jy()local jv;local jz=nil;local jA=nil;local jB=nil;for cQ,jC in pairs(b[0])do if jC.hasAtmosphere then local aj=js(planet.center,jC.center)if jz==nil or aj<jz then jA=jC;jz=aj;jB=planet end;if ac and ac.hasAtmosphere and ac.name~=planet.name then local e4=js(ac.center,jC.center)if e4<jz then jA=jC;jz=e4;jB=ac end end end end;local jD=gg(1770)local jE=gh(330)if jz then local jF="txttick "local jG=500000;if jz<jA.radius+jG or jz<jB.radius+jG then if bH then jF="txttick red "else jF="txttick orange "end end;jv=cu(jz,2)bJ=ch(jD,jE,"Pipe ("..jB.name.."--"..jA.name.."): "..jv,jF.."pbright txtmid")end end;local jH={}local jI=nil;function jH.HUDPrologue(h3)bH,bI=gq(bv)if not bH then H=PvPR;J=PvPG;I=PvPB;if shield_1 and AutoShieldToggle and shield_1.getState()==0 then shield_1.toggle()end else H=SafeR;J=SafeG;I=SafeB;if shield_1 and AutoShieldToggle and shield_1.getState()==1 then shield_1.toggle()end end;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.8+0.5)..","..e(J*0.8+0.5)..","..e(I*0.8+0.5)..[[)]]local jJ=ay;local jK=az;local jL=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.3+0.5)..[[)]]local jM=ay;local jN=az;if gs()and not brightHud then jJ=[[rgb(]]..e(H*0.5+0.5)..","..e(J*0.5+0.5)..","..e(I*0.5+0.5)..[[)]]jK=[[rgb(]]..e(H*0.3+0.5)..","..e(J*0.3+0.5)..","..e(I*0.2+0.5)..[[)]]end;local iU=gg;local iV=gh;h3[#h3+1]=f([[
                        <head>
                            <style>
                                body {margin: 0}
                                svg {position:absolute;top:0;left:0;font-family:Montserrat;} 
                                .txt {font-size:10px;font-weight:bold;}
                                .txttick {font-size:12px;font-weight:bold;}
                                .txtbig {font-size:14px;font-weight:bold;}
                                .altsm {font-size:16px;font-weight:normal;}
                                .altbig {font-size:21px;font-weight:normal;}
                                .line {stroke-width:2px;fill:none;stroke:%s}
                                .linethick {stroke-width:3px;fill:none}
                                .linethin {stroke-width:1px;fill:none}
                                .warnings {font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}
                                .warn {fill:orange; font-size:24px}
                                .crit {fill:darkred;font-size:28px}
                                .bright {fill:%s;stroke:%s}
                                text.bright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pbright {fill:%s;stroke:%s}
                                text.pbright {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dim {fill:%s;stroke:%s}
                                text.dim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .pdim {fill:%s;stroke:%s}
                                text.pdim {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .red {fill:red;stroke:red}
                                text.red {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .orange {fill:orange;stroke:orange}
                                text.orange {stroke:black; stroke-width:10px;paint-order:stroke;}
                                .redout {fill:none;stroke:red}
                                .op30 {opacity:0.3}
                                .op10 {opacity:0.1}
                                .txtstart {text-anchor:start}
                                .txtend {text-anchor:end}
                                .txtmid {text-anchor:middle}
                                .txtvspd {font-family:sans-serif;font-weight:normal}
                                .txtvspdval {font-size:20px}
                                .txtfuel {font-size:11px;font-weight:bold}
                                .txtorb {font-size:12px}
                                .txtorbbig {font-size:18px}
                                .hudver {font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}
                                .msg {font-size:40px;fill:red;text-anchor:middle;font-weight:normal}
                                .cursor {stroke:white}
                                text { stroke:black; stroke-width:10px;paint-order:stroke;}
                                .dimstroke {stroke:%s}
                                .brightstroke {stroke:%s}
                                .indicatorText {font-size:20px;fill:white}
                                .size14 {font-size:14px}
                                .size20 {font-size:20px}
                                .topButton {fill:%s;opacity:0.5;stroke-width:2;stroke:%s}
                                .topButtonActive {fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}
                                .topButton text {font-size:13px; fill: %s; opacity:1; stroke-width:20px}
                                .topButtonActive text {font-size:13px;fill:%s; stroke-width:0px; opacity:1}
                                .indicatorFont {font-size:20px;font-family:Bank}
                                .dimmer {stroke: %s;}
                                .dimfill {fill: %s;}
                            </style>
                        </head>
                        <body>
                            <svg height="100%%" width="100%%" viewBox="0 0 %d %d">
                                <defs>
                                    <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="100%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/>
                                        <stop offset="200%%" stop-color="black" stop-opacity="0"/>
                                    </radialGradient>
                                    <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1">
                                        <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/>
                                        <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/>
                                    </radialGradient>
                                </defs>
                                <g class="pdim txt txtend">
                                
                            ]],jJ,jJ,jJ,jM,jM,jK,jK,jN,jN,jK,jJ,jL,jN,jJ,jJ,jL,jL,jL,aG,aH,jK,jK,jK,jK,jK,jM,jK)if not jI then jI=f([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        
                        <clipPath id="headingClip">
                            <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                        </clipPath>
                        <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],iU(630),iV(0),iU(675),iV(45),iU(960),iV(55),iU(1245),iV(45),iU(1290),iV(0),iU(1000),iV(105),iU(1040),iV(59),iU(1250),iV(51),iU(1300),iV(0),iU(1920),iV(0),iU(1920),iV(20),iU(1400),iV(20),iU(1300),iV(105),iU(920),iV(105),iU(880),iV(59),iU(670),iV(51),iU(620),iV(0),iU(0),iV(0),iU(0),iV(20),iU(520),iV(20),iU(620),iV(105),iU(890),iV(59),iU(960),iV(62),iU(1030),iV(59),iU(985),iV(112),iU(1150),iV(112),iU(1100),iV(152),iU(820),iV(152),iU(780),iV(112),iU(935),iV(112),iU(890),iV(59),iU(960),iV(62),iU(1030),iV(59),iU(985),iV(112),iU(1150),iV(112),iU(1100),iV(152),iU(820),iV(152),iU(780),iV(112),iU(935),iV(112))end;h3[#h3+1]=jI;return h3 end;function jH.DrawVerticalSpeed(h3,dr)h2(h3,dr)end;function jH.UpdateHud(h3)local hT=bB;local jO=bC;local hb=jO;local hq=hT;local ia=e(unit.getThrottle())local ig=bs*3.6;local ib=unit.getAxisCommandValue(0)local jP=gg(1770)local jQ=gh(310)if AtmoSpeedAssist and bA then ib=K;ia=K*100 end;local gu=gt()local hc="ROLL"if ia==nil then ia=0 end;if not bM then if bs>5 then hT=hS(bq)jO=hU(bq)else hT=0;jO=0 end;hc="YAW"end;if bI>50000 and not aq then local jR;jR=cu(bI)h3[#h3+1]=ch(jP,jQ,"PvP Boundary: "..jR,"pbright txtbig txtmid")end;h3[#h3+1]=ak;h3[#h3+1]=aD;h3[#h3+1]=gv;if bJ~=""then h3[#h3+1]=bJ end;if gw~=""then h3[#h3+1]=gw end;if gx~=""then h3[#h3+1]=gx end;h2(h3,as)if m()==0 or RemoteHud then if bM then ha(h3,centerX,centerY,hb,hc,bM)else ha(h3,centerX,centerY,jO,hc,bM)end;if not gs()or brightHud then if bM then ha(h3,centerX,centerY,hb,hc,bM)hp(h3,hq,hb,centerX,centerY,bM,e(hU(bq)),bs)else ha(h3,centerX,centerY,jO,hc,bM)hp(h3,hT,jO,centerX,centerY,bM,e(jO),bs)end;hw(h3,as,bM)hV(h3,bq,bs,centerX,centerY)end end;i9(h3,gu,ia,ib)ie(h3,ig)ij(h3)ja(h3)return h3 end;function jH.HUDEpilogue(h3)h3[#h3+1]="</svg>"return h3 end;function jH.ExtraData(h3)local jS=gg(1240)local jT=gh(55)local jU=jT+10;local jV;local iU=gg;local iV=gh;local jW=0;local gu=gt()local jX=iU(99)local jY=iU(80)local jZ=iV(85)local j_=iV(31)local k0=0;local k1=0;local k2=av>1000000 and A(av/1000000,2).."kT"or A(av/1000,2).."T"if aq then jW=LastMaxBrakeInAtmo else jW=LastMaxBrake end;local k3,k4=aS.computeDistanceAndTime(bs,0,av,0,0,jW)if k3<0 then k3=0 end;jW=A(jW/(av*gj),2).."g"local k5=a:maxForceForward()jV=core.g()if jV>0.1 then k1=av*jV;k1=A(k1/(av*gj),2).."g"k0=0.5*k5/jV;k0=k0>1000000 and A(k0/1000000,2).."kT"or A(k0/1000,2).."T"end;k5=A(k5/(av*gj),2).."g"local k6=vec3(core.getWorldAcceleration()):len()/9.80665;jV=core.g()h3[#h3+1]=[[<g class="dim txt txtend size14">]]if m()==1 and not RemoteHud then jS=gg(1120)jT=gh(55)jU=jT+10 elseif aq then local k7=gg(770)h3[#h3+1]=ch(iU(895),jX,"ATMO","")h3[#h3+1]=f([[<path class="linethin dimstroke"  d="M %f %f l -80 0"/>]],iU(895),jZ)h3[#h3+1]=ch(iU(815),jY,f("%.1f%%",ar*100),"txtstart size20")end;h3[#h3+1]=ch(iU(1025),jX,"GRAVITY","txtstart")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iU(1025),jZ)h3[#h3+1]=ch(iU(1105),jY,f("%.2fg",jV/9.80665),"size20")h3[#h3+1]=ch(iU(1125),jX,"ACCEL","txtstart")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iU(1125),jZ)h3[#h3+1]=ch(iU(1205),jY,f("%.2fg",k6),"size20")h3[#h3+1]=ch(iU(695),jX,"BRAKE","")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l -80 0"/>]],iU(695),jZ)h3[#h3+1]=ch(iU(615),jY,f("%s",cH(k4)),"txtstart size20")h3[#h3+1]=ch(iU(635),iV(45),"TRIP","")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l -90 0"/>]],iU(635),iV(31))if travelTime then h3[#h3+1]=ch(iU(532),iV(23),f("%s",cH(travelTime)),"txtstart size20")end;h3[#h3+1]=ch(iU(795),jX,"BRAKE","")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l -80 0"/>]],iU(795),jZ)h3[#h3+1]=ch(iU(715),jY,f("%s",cu(k3)),"txtstart size20")h3[#h3+1]=ch(iU(1285),iV(45),"MASS","txtstart")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l 90 0"/>]],iU(1285),iV(31))h3[#h3+1]=ch(iU(1388),iV(23),f("%s",k2),"size20")h3[#h3+1]=ch(iU(1220),jX,"THRUST","txtstart")h3[#h3+1]=f([[<path class="linethin dimstroke" d="M %f %f l 80 0"/>]],iU(1220),jZ)h3[#h3+1]=ch(iU(1300),jY,f("%s",k5),"size20")h3[#h3+1]=ch(gg(960),gh(175),gu,"pbright txtbig txtmid size20")h3[#h3+1]="</g>"end;function jH.DrawOdometer(h3,ad,TotalDistanceTravelled,ae)if SelectedTab~="INFO"then return h3 end;local jV;local k0=0;local k1=0;local jW=0;local k2=av>1000000 and A(av/1000000,2).." kTons"or A(av/1000,2).." Tons"if aq then jW=LastMaxBrakeInAtmo else jW=LastMaxBrake end;local k3,k4=aS.computeDistanceAndTime(bs,0,av,0,0,jW)jW=A(jW/(av*gj),2).." g"local k5=a:maxForceForward()jV=core.g()if jV>0.1 then k1=av*jV;k1=A(k1/(av*gj),2).." g"k0=0.5*k5/jV;k0=k0>1000000 and A(k0/1000000,2).." kTons"or A(k0/1000,2).." Tons"end;k5=A(k5/(av*gj),2).." g"if m()==0 or RemoteHud then local k8=gg(OrbitMapX+10)local k9=gh(OrbitMapY+20)local ka=gg(OrbitMapX+10+OrbitMapSize)local kb=25;h3[#h3+1]="<g class='txtstart size14 bright'>"h3[#h3+1]=ch(k8,k9,f("BrkTime: %s",cH(k4)))h3[#h3+1]=ch(ka,k9,f("Trip: %.2f km",ad))h3[#h3+1]=ch(k8,k9+kb,f("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))h3[#h3+1]=ch(ka,k9+kb,f("BrkDist: %s",cu(k3)))h3[#h3+1]=ch(k8,k9+kb*2,"Trip Time: "..cH(ae))h3[#h3+1]=ch(ka,k9+kb*2,"Total Time: "..cH(TotalFlightTime))h3[#h3+1]=ch(k8,k9+kb*3,f("Mass: %s",k2))h3[#h3+1]=ch(ka,k9+kb*3,f("Max Brake: %s",jW))h3[#h3+1]=ch(k8,k9+kb*4,f("Max Thrust: %s",k5))if jV>0.1 then h3[#h3+1]=ch(ka,k9+kb*4,f("Max Thrust Mass: %s",k0))h3[#h3+1]=ch(k8,k9+kb*5,f("Req Thrust: %s",k1))else h3[#h3+1]=ch(ka,k9+kb*5,"Max Mass: n/a")h3[#h3+1]=ch(k8,k9+kb*6,"Req Thrust: n/a")end end;h3[#h3+1]="</g></g>"return h3 end;function jH.DrawWarnings(h3)return ij(h3)end;function jH.DisplayOrbitScreen(h3)return ja(h3)end;function jH.DisplayMessage(h3,iG)if iG~="empty"then local cj=310;for kc in string.gmatch(iG,"([^\n]+)")do cj=cj+35;h3[#h3+1]=ch("50%",cj,kc,"msg")end end;if ai~=0 then unit.setTimer("msgTick",ai)ai=0 end end;function jH.DrawDeadZone(h3)h3[#h3+1]=f([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;function jH.UpdatePipe()if aq then bJ=""return end;jy()end;function jH.DrawSettings(h3)if#bE>0 then local ci=gg(640)local cj=gh(200)h3[#h3+1]=[[<g class="pbright txtvspd txtstart">]]for cQ,cR in pairs(bE)do h3[#h3+1]=ch(ci,cj,cR..": ".._G[cR])cj=cj+20;if cQ%12==0 then ci=ci+gg(350)cj=gh(200)end end;h3[#h3+1]=ch(gg(640),gh(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")h3[#h3+1]="</g>"end;return h3 end;local kd;local ke=gg(1770)local kf=gh(350)local kg=gh(15)local kh=gg(1370)local bU,ki;local kj=0;function jH.DrawRadarInfo()local function kk()if radarPanelID~=nil and kj==0 then t(radarPanelID)radarPanelID=nil;if kd~=nil then t(kd)kd=nil end else if kj==1 then t(radarPanelID)radarPanelID=nil;_autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_periscope", "Periscope"),"periscope")kd=_autoconf.panels[_autoconf.panels_size]end;if radarPanelID==nil then _autoconf.displayCategoryPanel(bP,1,L_TEXT("ui_lua_widget_radar", "Radar"),"radar")radarPanelID=_autoconf.panels[_autoconf.panels_size]end;kj=0 end end;local f9,fa,f8,fb,fc,f5=aY.GetRadarHud()local B=fb or 0;if f8>0 then if CollisionSystem then bU=B.."/"..fc.." Plotted : "..f8-fc.." Ignored"else bU="Radar Contacts: "..f8 end;gv=ch(ke,kf,bU,"pbright txtbig txtmid")if#f5>0 then gv=gv..ch(kh,kg,"Friendlies In Range","pbright txtbig txtmid")for cQ,cR in pairs(f5)do kg=kg+20;gv=gv..ch(kh,kg,bP[1].getConstructName(cR),"pdim txtmid")end end;if f9==nil and kd==nil then kj=1;kk()end;if f9~=nil and kd~=nil then kk()end;if radarPanelID==nil then kk()end else if fa then gv=ch(ke,kf,bQ.." Radar: Jammed","pbright txtbig txtmid")else gv=ch(ke,kf,"Radar: No "..bQ.." Contacts","pbright txtbig txtmid")end;if radarPanelID~=nil then kj=0;kk()end end end;function jH.DrawTanks()if fuelX~=0 and fuelY~=0 then gw=ch(fuelX,fuelY,"","txtstart pdim txtfuel")tankY=fuelY;gN(fuelX,"Atmospheric ","ATMO",aI,gL,gM)gN(fuelX,"Space Fuel T","SPACE",aJ,gJ,gK)gN(fuelX,"Rocket Fuel ","ROCKET",aK,gH,gI)end end;function jH.DrawShield()local kl=shield_1.getState()==1 and"Shield Active"or"Shield Disabled"local km=core.getPvPTimer()local kn=shield_1.getResistances()local ko="A: "..10+kn[1]*100 .."% / E: "..10+kn[2]*100 .."% / K:"..10+kn[3]*100 .."% / T: "..10+kn[4]*100 .."%"local ci,cj=shieldX-60,shieldY+30;local kp=e(0.5+shield_1.getShieldHitpoints()*100/shield_1.getMaxShieldHitpoints())local h0=e(kp*2.55)local h1=f("rgb(%d,%d,%d)",255-h0,h0,0)local cl=""gx=ch(ci,cj,"","txtmid pdim txtfuel")if kp<10 and kl~="Shield Disabled"then cl="red "end;km=km>0 and"   PvPTime: "..cH(km)or""gx=gx..f([[
                        <g class="pdim">                        
                        <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                        <g class="bar txtstart">
                        <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                        <text fill=black x="%d" y="%d">%s%%%s</text>
                        </g>]],ci,cj,h1,kp*2,ci,cj,ci+2,cj+10,kp,km)gx=gx..ch(ci,cj-5,kl,cl.."txtstart pbright txtbig")gx=gx..ch(ci,cj+30,ko,cl.."txtstart pbright txtsmall")end;return jH end;local function kq()local function kr(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=b[0][0]end;return p end;local function ks()local function kt(ku,kv)return ku.name<kv.name end;bG={}for cQ,cR in pairs(b[0])do bG[#bG+1]={name=cR.name,index=cQ}end;table.sort(bG,kt)end;local function kw(kx)for cQ,cR in pairs(kx)do if cR.name and cR.name==CustomTarget.name then return cQ end end;return-1 end;local function ky()bS=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"ac=nil;CustomTarget=nil;return true end;local kz=bG[AutopilotTargetIndex].index;local kA=b[0][kz]if kA.center then AutopilotTargetName=kA.name;ac=aR[0][kz]if CustomTarget~=nil then if ar==0 then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)~=1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)~=1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)~=1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)~=1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)~=1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end;if u(widgetTargetOrbitText,widgetTargetOrbit)~=1 then v(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=kA;for _,cR in pairs(aR[0])do if cR.name==CustomTarget.planetname then ac=cR;AutopilotTargetName=CustomTarget.name;break end end;if u(widgetMaxMassText,widgetMaxMass)~=1 then v(widgetMaxMassText,widgetMaxMass)end;if u(widgetTravelTimeText,widgetTravelTime)~=1 then v(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(ac.center)else AutopilotTargetCoords=CustomTarget.position end;if ac.planetname~="Space"then if ac.hasAtmosphere then AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=e(ac.radius*(TargetOrbitRadius-1)+ac.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotPlanetGravity=0;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function kB(h7)if not Autopilot and not VectorToTarget and not am and not IntoOrbit then if h7==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#bG end end;if AutopilotTargetIndex==0 then ky()else local kz=bG[AutopilotTargetIndex].index;local kA=b[0][kz]if kA~=nil and kA.name=="Space"or iphCondition=="Custom Only"and kA.center or iphCondition=="No Moons"and string.find(kA.name,"Moon")~=nil then if h7==nil then kB()else kB(1)end else ky()end end else a2="Disengage autopilot before changing Interplanetary Helper"c4("iph","AP")end end;local function kC()local fR=-1;fR=kw(b[0])if fR>-1 then table.remove(b[0],fR)end;fR=-1;fR=kw(SavedLocations)if fR~=-1 then a2=CustomTarget.name.." saved location cleared"table.remove(SavedLocations,fR)end;kB()ks()end;local function kD(g5,position,hP,kE)if dbHud_1 or hP then local p=kr(position)local jV=p.gravity;if kE then jV=unit.getClosestPlanetInfluence()end;local kF={position=position,name=g5,planetname=p.name,gravity=jV,safe=kE}if not hP then SavedLocations[#SavedLocations+1]=kF else for cQ,cR in pairs(b[0])do if cR.name and g5==cR.name then table.remove(b[0],cQ)end end end;table.insert(b[0],kF)ks()ky()a2="Location saved as "..g5 .."("..p.name..")"else a2="Databank must be installed to save permanent locations"end end;local kG={}function kG.UpdateAtlasLocationsList()ks()end;function kG.UpdateAutopilotTarget()ky()end;function kG.adjustAutopilotTargetIndex(h7)kB(h7)end;function kG.findAtlasIndex(kx)kw(kx)end;function kG.UpdatePosition(kH)local fR=kw(SavedLocations)if fR~=-1 then if kH~=nil then SavedLocations[fR].name=kH;AutopilotTargetIndex=AutopilotTargetIndex-1;kB()else local kI=SavedLocations[fR]kI.gravity=unit.getClosestPlanetInfluence()kI.position=bv;kI.safe=true end;a2=SavedLocations[fR].name.." position updated ("..SavedLocations[fR].planetname..")"else a2="Name Not Found"end end;function kG.AddNewLocation(g5,position,hP,kE)kD(g5,position,hP,kE)end;function kG.ClearCurrentPosition()kC()end;for cQ,cR in pairs(SavedLocations)do table.insert(b[0],cR)end;ks()if AutopilotTargetIndex>#bG then AutopilotTargetIndex=0 end;kG.UpdateAutopilotTarget()return kG end;local function kJ()local cB={}local function kK(eE)local kL=AutopilotEndSpeed;if not Autopilot then kL=0 end;if not aq then return aS.computeDistanceAndTime(eE,kL,av,0,0,LastMaxBrake-AutopilotPlanetGravity*av)else if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then return aS.computeDistanceAndTime(eE,kL,av,0,0,LastMaxBrakeInAtmo-AutopilotPlanetGravity*av)else return 0,0 end end end;local function kM(eE)local kL=AutopilotEndSpeed;if not Autopilot then kL=0 end;return aS.computeDistanceAndTime(eE,kL,av,a:maxForceForward(),warmup,LastMaxBrake-AutopilotPlanetGravity*av)end;local kN=false;local kO=0;function cB.GetAutopilotBrakeDistanceAndTime(eE)return kK(eE)end;function cB.GetAutopilotTBBrakeDistanceAndTime(eE)return kM(eE)end;local function kP(kQ,kR,kS)kR=kR:project_on_plane(kQ)kS=kS:project_on_plane(kQ)return n(kR:cross(kS):dot(kQ),kR:dot(kS))end;local function kT()local function kU()local kV=-1;local kW=-1;if vBooster then kV=vBooster.getDistance()end;if hover then kW=hover.getDistance()end;if kV~=-1 and kW~=-1 then if kV<kW then return kV else return kW end elseif kV~=-1 then return kV elseif kW~=-1 then return kW else return-1 end end;local kX=kU()local kY=-1;if telemeter_1 then kY=telemeter_1.getDistance()end;if kX~=-1 and kY~=-1 then if kX<kY then return kX else return kY end elseif kX~=-1 then return kX else return kY end end;local function kZ(planet,e0,k_)local function l0(l1,dk)local e6=vec3(dk)if l1.id==0 then return setmetatable({latitude=e6.x,longitude=e6.y,altitude=e6.z,id=0,systemId=l1.systemId},MapPosition)end;local e7=e6-l1.center;local aj=e7:len()local dr=aj-l1.radius;local dp=0;local dq=0;if not cr(aj,0)then local e8=n(e7.y,e7.x)dq=e8>=0 and e8 or 2*math.pi+e8;dp=math.pi/2-math.acos(e7.z/aj)end;return setmetatable({latitude=math.deg(dp),longitude=math.deg(dq),altitude=dr,id=l1.id,systemId=l1.systemId},MapPosition)end;local l2=l0(planet,e0)l2="::pos{"..l2.systemId..","..l2.id..","..l2.latitude..","..l2.longitude..","..l2.altitude.."}"if k_ then return l2 else system.setWaypoint(l2)return true end end;local l3=false;function cB.showWayPoint(planet,e0,k_)return kZ(planet,e0,k_)end;function cB.APTick()local function l4()if bO and not BrakeLanding then local c2=bO[1]local g6,g7=bO[2],bO[3]local l5=math.min(g6,g7 or g6)local l6=l5/bs;local l7=AutoTakeoff and(bs<42 or ao~=-1)local l8=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if l8 and not l7 and(a8*1.5>l5 or l6<1)then BrakeIsOn=true;cn(0)if AltitudeHold then cz()end;if LockPitch then ToggleLockPitch()end;a2="Autopilot Cancelled due to possible collision"if VectorToTarget or Autopilot then cC()end;StrongBrakes=true;BrakeLanding=true;b0=true end;if l6<11 then bN=c2.name.." COLLISION "..cH(l6).." / "..cu(l5,2)else bN=c2.name.." collision "..cH(l6)end;if l6<6 then c4("alarm","AL",2)end else bN=false end end;local function l9(bZ,la,lb)local function lc(bZ,dN)bZ=vec3(bZ)dN=vec3(dN):normalize()local d6=bZ*dN;return d6.x+d6.y+d6.z end;local ld=0.001;local le=1;if not aq or not b2 or ao~=-1 or bs<Q then if lb==nil then lb=DampingMultiplier end;if la==nil then la=ld end;bZ=vec3(bZ):normalize()local lf=vec3()-bZ;local lg=-lc(lf,core.getConstructWorldOrientationRight())*le;local lh=-lc(lf,core.getConstructWorldOrientationUp())*le;if aB==0 then aB=lg/2 end;if aC==0 then aC=lh/2 end;if d(lg)<0.1 then V=V-lg*2 else V=V-(lg+(lg-aB)*lb)end;if d(lh)<0.1 then U=U+lh*2 else U=U+lh+(lh-aC)*lb end;aB=lg;aC=lh;if d(lg)<la and d(lh)<la then return true end;return false elseif b2 and ao==-1 then bZ=br;if lb==nil then lb=DampingMultiplier end;if la==nil then la=ld end;bZ=vec3(bZ):normalize()local lf=bo-bZ;local lg=-lc(lf,core.getConstructWorldOrientationRight())*le;local lh=-lc(lf,core.getConstructWorldOrientationUp())*le;if aB==0 then aB=lg/2 end;if aC==0 then aC=lh/2 end;if d(lg)<0.1 then V=V-lg*5 else V=V-(lg+(lg-aB)*lb)end;if d(lh)<0.1 then U=U+lh*5 else U=U+lh+(lh-aC)*lb end;aB=lg;aC=lh;if d(lg)<la and d(lh)<la then return true end;return false end end;aq=k()>0;ar=k()as=core.getAltitude()ao=kT()E=q()b3=E;if CollisionSystem then l4()end;if antigrav then by=antigrav.getState()==1 end;local li=1;local lj=1;local lk=E-b3;local ll=-math.deg(kP(bn,br,bo))local lm=math.deg(kP(bp,br,bo))local h7=bt*-1;b2=aq and ll<-YawStallAngle or ll>YawStallAngle or lm<-PitchStallAngle or lm>PitchStallAngle;local ln=system.getMouseDeltaX()local lo=system.getMouseDeltaY()if InvertMouse and not a1 then lo=-lo end;V=0;Z=0;U=0;sys=aR[0]planet=sys:closestBody(core.getConstructWorldPos())kepPlanet=aU(planet)orbit=kepPlanet:orbitalParameters(core.getConstructWorldPos(),br)if as==0 then as=(bv-planet.center):len()-planet.radius end;bM=unit.getClosestPlanetInfluence()>0 or as>0 and as<200000;local jV=planet:getGravity(core.getConstructWorldPos()):len()*av;b4=0;aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]if x()==0 then if m()==1 and a1 then if not aZ then ag=ag+ln;ah=ah+lo end else ag=0;ah=0 end else ag=ag+ln;ah=ah+lo;aj=y(ag*ag+ah*ah)if not a1 and m()==0 then if userControlScheme=="virtual joystick"then if ag>0 and ag>DeadZone then V=V-(ag-DeadZone)*MouseXSensitivity elseif ag<0 and ag<DeadZone*-1 then V=V-(ag+DeadZone)*MouseXSensitivity else V=0 end;if ah>0 and ah>DeadZone then U=U-(ah-DeadZone)*MouseYSensitivity elseif ah<0 and ah<DeadZone*-1 then U=U-(ah+DeadZone)*MouseYSensitivity else U=0 end else ag=0;ah=0;if userControlScheme=="mouse"then U=(-utils.smoothstep(lo,-100,100)+0.5)*2*li;V=(-utils.smoothstep(ln,-100,100)+0.5)*2*lj end end end end;local lp=bs>8334;if bs>SpaceSpeedLimit/3.6 and not aq and not Autopilot and not lp then a2="Space Speed Engine Shutoff reached"cn(0)end;if not lp and LastIsWarping then if not BrakeIsOn then cE()end;if Autopilot then cC()end end;LastIsWarping=lp;if aq and ar>0.09 then if bs>b7/3.6 and not AtmoSpeedAssist and not kN then BrakeIsOn=true;kN=true elseif not AtmoSpeedAssist and kN then if bs<b7/3.6 then BrakeIsOn=false;kN=false end end end;if BrakeIsOn then Y=1 else Y=0 end;if ProgradeIsOn then if al then BrakeIsOn=false;local lq=false;if CustomTarget~=nil and al~=1 then lq=l9(CustomTarget.position-bv,0.1)else lq=l9(vec3(br),0.01)end;b0=true;if lq then cq(e(b7))if(d(bC)<2 or d(bB)>85)and bs>=b7/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;R=true;if al~=1 then an=true end;al=false;Autopilot=false;cF()end elseif aq and AtmoSpeedAssist then cn(1)end elseif bs>Q then l9(vec3(br),0.01)end end;if RetrogradeIsOn then if aq then RetrogradeIsOn=false elseif bs>Q then l9(-vec3(br))end end;if not ProgradeIsOn and al and not IntoOrbit then if ar==0 then R=true;cF()al=false;an=true else al=false;cC()end end;if an and CustomTarget~=nil and(as<HoldAltitude+250 and as>HoldAltitude-250)and bs*3.6>b7-250 and d(bu)<25 and ar>=0.1 and(CustomTarget.position-bv):len()>2000+as then cC()an=false end;if VertTakeOff then b0=true;local lr=HoldAltitude;if bu<-30 then a2="Unable to achieve lift. Safety Landing."af=0;b0=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and by or HoldAltitude<planet.spaceEngineMinAltitude then if by then lr=antigrav.getBaseAltitude()end;if as<lr-100 then b8=0;af=15;BrakeIsOn=false elseif bu>0 then BrakeIsOn=true;af=0 elseif bu<-30 then BrakeIsOn=true;af=15 elseif as>=lr then if by then if Autopilot or VectorToTarget then cx()else BrakeIsOn=true;VertTakeOff=false end;a2="Takeoff complete. Singularity engaged"c4("aggLk","AG")else BrakeIsOn=false;a2="VTO complete. Engaging Horizontal Flight"c4("vtoc","VT")cx()end;af=0 end else if ar>0.08 then b8=0;BrakeIsOn=false;af=20 elseif ar<0.08 and ar>0 then BrakeIsOn=false;if bk then b8=0;af=20 else af=0;b8=36;cq(3500)end else b0=autoRollPreference;IntoOrbit=true;bi=false;CancelIntoOrbit=false;bc=false;ba=nil;bb=nil;if bh==nil then bh=planet end;bg=lr;bf=true;VertTakeOff=false end end;if b8~=nil then if vTpitchPID==nil then vTpitchPID=pid.new(2*0.01,0,2*0.1)end;local ls=r(b8-bB,-PitchStallAngle*0.80,PitchStallAngle*0.80)vTpitchPID:inject(ls)local lt=r(vTpitchPID:get(),-1,1)U=lt end end;if IntoOrbit then local lf;local lu=false;local lv=cu(bg)if bh==nil then bh=planet;if VectorToTarget then bh=ac end end;if not bf then bg=e(bh.radius+bh.surfaceMaxAltitude+LowOrbitHeight)if bh.hasAtmosphere then bg=e(bh.radius+bh.noAtmosphericDensityAltitude+LowOrbitHeight)end;bf=true end;if be.VectorToTarget then lf=CustomTarget.position-bv end;local lw,lx=aU(bh):escapeAndOrbitalSpeed((bv-bh.center):len()-bh.radius)local ly=bC;if not bc then local lz=false;local lA=false;cn(0)bb=0;b9="Aligning to orbital path - OrbitHeight: "..lv;if be.VectorToTarget then l9(lf:normalize():project_on_plane(bt))lu=bo:dot(lf:project_on_plane(bn):normalize())>0.95 else l9(br)lu=ll<0.5;if bs<150 then lu=true end end;U=0;ba=0;if bB<=ba+1 and bB>=ba-1 then lz=true else lz=false end;if ly<=bb+1 and ly>=bb-1 then lA=true else lA=false end;if lz and lA and lu then ba=nil;bb=nil;bc=true end else if be.VectorToTarget then l9(lf:normalize():project_on_plane(bt))elseif bs>150 then l9(br)end;U=0;if be.VectorToTarget then local a8,_=aS.computeDistanceAndTime(bs,b7/3.6,av,0,0,LastMaxBrake)if bi and lf:len()>15000+a8+as then b9="Orbiting to Target"if as-100<=bh.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<bh.noAtmosphericDensityAltitude then bi=false end elseif bi or lf:len()<15000+a8+as then a2="Orbit complete, proceeding with reentry"c4("orCom","OB")AutopilotTargetCoords=CustomTarget.position;R=true;an=true;be.VectorToTarget,be.AutopilotAlign=false,false;cy()cF()return end end;if orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and as>bg*0.9 and as<bg*1.4 then if orbit.apoapsis~=nil then if orbit.periapsis.altitude>=bg*0.99 and orbit.apoapsis.altitude>=bg*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude or bi then if bi then BrakeIsOn=false;cn(0)ba=0;if not be.VectorToTarget then a2="Orbit complete"c4("orCom","OB")cy()end else bm=bm+1;if bm>=2 then bi=true end end else b9="Adjusting Orbit - OrbitHeight: "..lv;bd=true;cq(lx*3.6+1)local lB=bg-as;if VSpdPID==nil then VSpdPID=pid.new(0.1,0,1*0.1)end;VSpdPID:inject(lB-bu*r(utils.smoothstep(2000-lB,-2000,2000)^6*10,1,10))ba=r(VSpdPID:get(),-60,60)end end else local lC=2.75;local lD=d(A(lw*lC))local lE=lD%50;if lE>0 then lD=lD-lE+50 end;BrakeIsOn=false;if as<bg*0.8 then b9="Escaping planet gravity - OrbitHeight: "..lv;ba=utils.map(bu,200,0,-15,80)elseif as>=bg*0.8 and as<bg*1.15 then b9="Approaching orbital corridor - OrbitHeight: "..lv;lD=lD*0.75;ba=utils.map(bu,100,-100,-15,65)elseif as>=bg*1.15 and as<bg*1.5 then b9="Approaching orbital corridor - OrbitHeight: "..lv;lD=lD*0.75;if bu<0 or bd then ba=utils.map(as,bg*1.5,bg*1.01,-30,0)else ba=utils.map(as,bg*0.99,bg*1.5,0,30)end elseif as>bg*1.5 then b9="Reentering orbital corridor - OrbitHeight: "..lv;ba=-65;local lF=utils.map(bu,-150,-400,1,0.55)lD=lD*lF end;cq(e(lD))end end;if ba~=nil then if OrbitPitchPID==nil then OrbitPitchPID=pid.new(1*0.01,0,5*0.1)end;local lG=ba-bB;OrbitPitchPID:inject(lG)local lH=r(OrbitPitchPID:get(),-0.5,0.5)U=lH end end;if Autopilot and ar==0 and not al then local function lI(bU,orbit)system.print(bU)BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"cn(0)P=false;a2=bU;c4("apCom","AP")if orbit or al then if orbit and AutopilotTargetOrbit~=nil and not al then if not as or as==0 then return end;bg=as;bf=true end;cy()end end;local lJ,lK=AutopilotTargetCoords,false;if CustomTarget~=nil and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local lL=(CustomTarget.position-ac.center):normalize()local lM=lL:project_on_plane((ac.center-bv):normalize()):normalize()local lN=ac.center+lM*(ac.radius+AutopilotTargetOrbit)local lO=CustomTarget.position+(CustomTarget.position-ac.center):normalize()*(AutopilotTargetOrbit-ac:getAltitude(CustomTarget.position))if(bv-lN):len()<(bv-lO):len()then lJ=lN else lJ=lO;AutopilotEndSpeed=0 end;AutopilotTargetCoords=lJ;aX.showWayPoint(ac,AutopilotTargetCoords)lK=true;TargetSet=true end;AutopilotPlanetGravity=0 elseif CustomTarget~=nil and CustomTarget.planetname=="Space"then if not TargetSet then AutopilotPlanetGravity=0;lK=true;AutopilotRealigned=true;TargetSet=true;lJ=CustomTarget.position+(bv-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=lJ end elseif CustomTarget==nil then AutopilotPlanetGravity=0;if not TargetSet then local lL=(bv+br*100000-ac.center):normalize()local lM=lL:project_on_plane((ac.center-bv):normalize()):normalize()if lM:len()<1 then lL=(bv+bo*100000-ac.center):normalize()lM=lL:project_on_plane((ac.center-bv):normalize()):normalize()end;lJ=ac.center+lM*(ac.radius+AutopilotTargetOrbit)AutopilotTargetCoords=lJ;TargetSet=true;lK=true;AutopilotRealigned=true;aX.showWayPoint(ac,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(lJ)-bv):len()local b_,c0,c1=aR:getPlanetarySystem(0):castIntersections(bv,br:normalize(),function(c2)if c2.noAtmosphericDensityAltitude>0 then return c2.radius+c2.noAtmosphericDensityAltitude else return c2.radius+c2.surfaceMaxAltitude*1.5 end end)local c3=c0;if c1~=nil and c0~=nil then c3=math.min(c1,c0)end;if c3~=nil and c3<AutopilotDistance and b_.name==ac.name then AutopilotDistance=c3 end;local lq=true;local lP=(ac.center-(bv+vec3(br):normalize()*AutopilotDistance)):len()-ac.radius;local iG=cu(lP)u(widgetTrajectoryAltitudeText,'{"label": "Projected Altitude", "value": "'..iG..'"}')local a8,a9;if not TurnBurn then a8,a9=kK(bs)else a8,a9=kM(bs)end;if bs>50 and AutopilotAccelerating then local lf=vec3(lJ)-bv;local lQ=r(math.deg(kP(bn,br:normalize(),lf:normalize()))*bs/500,-90,90)local lR=r(math.deg(kP(bp,br:normalize(),lf:normalize()))*bs/500,-90,90)if d(lQ)<20 and d(lR)<20 then lQ=lQ*2;lR=lR*2 end;if d(lQ)<2 and d(lR)<2 then lQ=lQ*2;lR=lR*2 end;local ll=-math.deg(kP(bn,bo,br:normalize()))local lm=-math.deg(kP(bp,bo,br:normalize()))if apPitchPID==nil then apPitchPID=pid.new(2*0.01,0,2*0.1)end;apPitchPID:inject(lR-lm)local lS=r(apPitchPID:get(),-1,1)U=U+lS;if apYawPID==nil then apYawPID=pid.new(2*0.01,0,2*0.1)end;apYawPID:inject(lQ-ll)local lT=r(apYawPID:get(),-1,1)V=V+lT;lK=true;if d(lQ)>2 or d(lR)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"c4("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c4("apAcc","AP")end end elseif AutopilotAccelerating and bs<=50 then l9((lJ-bv):normalize())end;if lP<AutopilotTargetOrbit*1.5 then if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 elseif CustomTarget==nil then _,AutopilotEndSpeed=aU(ac):escapeAndOrbitalSpeed(lP)end end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local b_,c3=bY((AutopilotTargetCoords-bv):normalize())if ac.name~=planet.name then if b_~=nil and ac.name~=b_.name and c3<AutopilotDistance then a2="Collision with "..b_.name.." in "..cu(c3).."\nClear LOS to continue."ai=5;l3=true else l3=false;a2=""end end end;if not l3 then if not AutopilotCruising and not AutopilotBraking and not lK then lq=l9((lJ-bv):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then lq=l9(-vec3(br):normalize())end end;if AutopilotAccelerating then if not P then BrakeIsOn=false;cn(AutopilotInterplanetaryThrottle)K=A(AutopilotInterplanetaryThrottle,2)P=true end;local lU=unit.getThrottle()if AtmoSpeedAssist then lU=K end;local lV=99999;local k6=-vec3(core.getWorldAcceleration()):dot(br:normalize())local lW=r(br:dot((lJ-bv):normalize()),0,bs)if lW>0 or k6>0 then lV=aS.computeTravelTime(lW,k6,AutopilotDistance-a8)end;if bq:len()>=MaxGameVelocity or lU==0 and P or warmup/4>lV then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then c4("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;cn(0)end;local lX=AutopilotDistance;if lX<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<kO and bI>2000 then cC()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;kO=bI else kO=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c4("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;cn(0)P=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn=true;Y=1 end;if TurnBurn then cn(1,true)end;local _,lx=aU(ac):escapeAndOrbitalSpeed((bv-planet.center):len()-planet.radius)local lf;if CustomTarget~=nil then lf=CustomTarget.position-bv end;if CustomTarget~=nil and CustomTarget.planetname=="Space"and bs<50 then lI("Autopilot complete, arrived at space location")BrakeIsOn=true;Y=1 elseif CustomTarget~=nil and CustomTarget.planetname~="Space"and bs<=lx and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then lI("Autopilot complete, commencing reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,AutopilotTargetCoords)elseif CustomTarget.planetname~="Space"and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then c4("apCir","AP")AutopilotStatus="Circularizing"end;if bs<=lx then if CustomTarget~=nil then if br:normalize():dot(lf:normalize())>0.4 then if AutopilotStatus~="Orbiting to Target"then c4("apOrb","OB")AutopilotStatus="Orbiting to Target"end;if not WaypointSet then BrakeIsOn=false;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=true end else lI("Autopilot complete, proceeding with reentry")AutopilotTargetCoords=CustomTarget.position;al=true;aX.showWayPoint(ac,CustomTarget.position)WaypointSet=false end else lI("Autopilot completed, setting orbit",true)Y=0 end end elseif AutopilotStatus=="Circularizing"then lI("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local lX=AutopilotDistance;if lX<=a8 or PreventPvP and bI<=a8+10000 and bH then if PreventPvP and bI<=a8+10000 and bH then if bI<kO and bI>2000 then cC()a2="Autopilot cancelled to prevent crossing PvP Line"BrakeIsOn=true;kO=bI else kO=bI;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then c4("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true end;local lU=unit.getThrottle()if AtmoSpeedAssist then lU=K end;if lU>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c4("apAcc","AP")end;AutopilotCruising=false end else if lq then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget~=nil and CustomTarget.planetname~="Space"then if not al then AutopilotTargetCoords=vec3(ac.center)+(AutopilotTargetOrbit+ac.radius)*bp;AutopilotShipUp=bn;AutopilotShipRight=bp end;AutopilotRealigned=true elseif lq and not l3 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"c4("apAcc","AP")end;if not P then cn(AutopilotInterplanetaryThrottle,true)K=A(AutopilotInterplanetaryThrottle,2)P=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and ar>0)then a2="Autopilot complete, starting reentry"c4("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"Y=0;cn(0)P=false;ProgradeIsOn=true;al=true;aX.showWayPoint(ac,CustomTarget.position)end;if a0 then b0=true;local lR=0;local eI=bv+vec3(unit.getMasterPlayerRelativePosition())local lY=eI-bv;local lZ=vec3(lY):project_on(bo):len()local l_=vec3(lY):project_on(bp):len()local aj=y(lZ*lZ+l_*l_)l9(lY:normalize())local m0=40;local m1=aj<m0;local m2=100;local m3=r((aj-m0)/2,10,m2)U=0;local lq=d(V)<0.1;if lq and bs<m3 and not m1 then BrakeIsOn=false;lR=-20 else BrakeIsOn=true;lR=0 end;local m4=0;if d(lR-bB)>m4 then if pitchPID==nil then pitchPID=pid.new(2*0.01,0,2*0.1)end;pitchPID:inject(lR-bB)local lS=pitchPID:get()U=lS end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local m5=LastMaxBrakeInAtmo;if m5 then m5=m5*r(bs/100,0.1,1)*ar else m5=LastMaxBrake end;if ar<0.01 then m5=LastMaxBrake end;local m6=bo:project_on_plane(bt):normalize():dot(br)local m7=vec3(core.getWorldAirFrictionAcceleration())local m8=m7:len()*av;if m6>100 then a8,a9=aS.computeDistanceAndTime(m6,100,av,0,0,m5)local m9,ma=aS.computeDistanceAndTime(100,0,av,0,0,m5*0.55)a8=a8+m9 else a8,a9=aS.computeDistanceAndTime(m6,0,av,0,0,m5*0.55)end;local lB=HoldAltitude-as-bu;local mb=200+bs;if Reentry or al then minMax=2000+bs end;local mc=1;if AutoTakeoff then mc=r(bs/100,0.1,1)end;local lR=(utils.smoothstep(lB,-mb,mb)-0.5)*2*MaxPitch*mc;if not Reentry and not al and not VectorToTarget and bo:dot(br:normalize())<0.99 then lR=(utils.smoothstep(lB,-mb*r(20-19*ar*10,1,20),mb*r(20-19*ar*10,1,20))-0.5)*2*MaxPitch*r(2-ar*10,1,2)*mc end;if not AltitudeHold then lR=0 end;if LockPitch~=nil then if bM and not IntoOrbit then lR=LockPitch else LockPitch=nil end end;b0=true;local md=U;if Reentry then local me=e(b7)local mf,mg=aS.computeDistanceAndTime(bs,me/3.6,av,0,0,LastMaxBrake-planet.gravity*9.8*av)mf=mf==-1 and 5000 or mf;local mh=as-(planet.noAtmosphericDensityAltitude+mf)local mi=as>planet.noAtmosphericDensityAltitude+mf*1.35;if mi then lR=ReEntryPitch;if bs<=me/3.6 and bs>me/3.6-10 and d(br:normalize():dot(bo))>0.9 and not bA then O=false;cn(1)end elseif bA and not mi and not aq then cq(me,true)end;if bA then if bs>me/3.6 and not mi then BrakeIsOn=true else BrakeIsOn=false end else BrakeIsOn=false end;if bu>0 then BrakeIsOn=true end;if not R then lR=-80;if ar>0.02 then a2="PARACHUTE DEPLOYED"Reentry=false;BrakeLanding=true;lR=0;b0=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and mi then b0=true elseif not mi then if not aq and(bA or s:getTargetSpeed(axisCommandId.longitudinal)~=me)then cq(me)end;if bs<me/3.6+1 then BrakeIsOn=false;R=false;Reentry=false;b0=true end end end;if bs>Q and not am and not VectorToTarget and not BrakeLanding and ForceAlignment then l9(vec3(br))end;if bK or(VectorToTarget or am)and AutopilotTargetIndex>0 and ar>0.01 then local lf;if bK then if type(bK)=="table"then lf=bK elseif bK<3 and bK>0 then lf=-bt:cross(br)*5000 elseif bK>=3 then lf=bt:cross(br)*5000 elseif bK<0 then lf=br*25000 end elseif CustomTarget~=nil then lf=CustomTarget.position-bv else lf=ac.center-bv end;local lQ=math.deg(kP(bt:normalize(),br,lf))*2;local mj=math.rad(d(bC))if bs>minRollVelocity and ar>0.01 then local mk=1000+bs;local ml=(utils.smoothstep(lB-bu*10,-mk,mk)-0.5)*2*MaxPitch;local mm=r(90-ml,0,180)b4=r(lQ*2,-mm,mm)local mn=lQ;lQ=r(r(lQ,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(mj)+4*(bB-lR)*math.sin(math.rad(bC)),-YawStallAngle*0.80,YawStallAngle*0.80)local mo=1;if b4~=0 then mo=d(mj/b4)end;mo=(90-r(d(b4-bC),0,90))/90;local mp=lR;if d(bC)>90 then mp=-mp end;lR=mo*r(r(mp*math.cos(mj),-PitchStallAngle*0.8,PitchStallAngle*0.8)+d(r(d(mn)*math.sin(mj),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else b4=0;lQ=r(lQ,-YawStallAngle*0.80,YawStallAngle*0.80)end;local mq=ll-lQ;if bK and d(mq)<=0.0001 and(type(bK)=="table"or type(bK)~="table"and bK<0 and d(bC)<1)then if bK==-2 then cz()end;bK=nil;c4("180Off","BR")return end;if not b2 and bs>minRollVelocity and ar>0.01 then if yawPID==nil then yawPID=pid.new(2*0.01,0,2*0.1)end;yawPID:inject(mq)local lT=r(yawPID:get(),-1,1)V=V+lT elseif aq and ao>-1 or bs<minRollVelocity then l9(lf)elseif b2 and ar>0.01 then if(ll<-YawStallAngle or ll>YawStallAngle)and ar>0.01 then l9(br)end;if(lm<-PitchStallAngle or lm>PitchStallAngle)and ar>0.01 then lR=r(bB-lm,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not am then local lr=planet:getAltitude(CustomTarget.position)local mh=lf:project_on_plane(bt):len()StrongBrakes=true;if not am and not Reentry and mh<=a8 and(br:project_on_plane(bt):normalize():dot(lf:project_on_plane(bt):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"cn(0)if AltitudeHold then cz()VectorToTarget=true end;BrakeIsOn=true elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(m6<0.1 or mh<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<mh)then if not by then c4("bklOn","BL")BrakeLanding=true end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"bN=false end;LastDistanceToTarget=mh end elseif VectorToTarget and ar==0 and HoldAltitude>planet.noAtmosphericDensityAltitude and not(am or Reentry)then if CustomTarget~=nil and ac.name==planet.name then local lf=CustomTarget.position-bv;local lr=planet:getAltitude(CustomTarget.position)local mh=y(lf:len()^2-(as-lr)^2)local m5=LastMaxBrakeInAtmo;if m5 then a8,a9=aS.computeDistanceAndTime(bs,0,av,0,0,m5/2)StrongBrakes=true;if mh<=a8+bs*lk/2 and br:project_on_plane(bt):normalize():dot(lf:project_on_plane(bt):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;R=true;al=false;an=true;Autopilot=false;cF()end end;LastDistanceToTarget=mh end end end;if ar==0 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(am or IntoOrbit or Reentry)then if not bi and not IntoOrbit then bg=HoldAltitude;bf=true;if VectorToTarget then be.VectorToTarget=true end;cy()VectorToTarget=false;bc=true end end;if b2 and ar>0.01 and ao==-1 and bs>minRollVelocity and VectorStatus~="Finalizing Approach"then l9(br)lR=r(bB-lm,bB-PitchStallAngle*0.80,bB+PitchStallAngle*0.80)end;U=md;local kY=-1;if BrakeLanding then lR=0;local mr=false;local ms=30;if aT~=nil and aT>0 then local mt=r(ar,0.4,2)local m5=LastMaxBrakeInAtmo*r(bs/100,0.1,1)*mt;local mu=aT*mt+m5-jV;local mv=m5/2-jV;local mw=bs-y(d(mv/2)*20/(0.5*av))*utils.sign(mv)if mw<0 then mw=0 end;local mx;if bs>100 then local my,_=aS.computeDistanceAndTime(bs,100,av,0,0,m5)local mz,_=aS.computeDistanceAndTime(100,0,av,0,0,y(m5))mx=my+mz else mx=aS.computeDistanceAndTime(bs,0,av,0,0,y(m5))end;if mx<20 then BrakeIsOn=false else local mA=0;if mw>100 then local mB,_=aS.computeDistanceAndTime(mw,100,av,0,0,mu)local mC,_=aS.computeDistanceAndTime(100,0,av,0,0,aT*mt+y(m5)-jV)mA=mB+mC else mA,_=aS.computeDistanceAndTime(mw,0,av,0,0,aT*mt+y(m5)-jV)end;mA=(mA+15+bs*lk)*1.1;local mD=CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;if mD then local lr=planet:getAltitude(CustomTarget.position)local mE=as-lr-100;local lf=CustomTarget.position-bv;local mF=y(lf:len()^2-(as-lr)^2)if mF>100 then mD=false elseif mE<=mA or mA==-1 then BrakeIsOn=true;mr=true else BrakeIsOn=false;mr=true end end;if not mD and CalculateBrakeLandingSpeed then if mA>=ms then BrakeIsOn=true else BrakeIsOn=false end;mr=true end end end;if not bA then cn(0)end;s:setTargetGroundAltitude(500)s:activateGroundEngineAltitudeStabilization(500)stablized=true;kY=ao;if kY>-1 then b0=autoRollPreference;if bs<1 or br:normalize():dot(bt)<0 then BrakeLanding=false;AltitudeHold=false;GearExtended=true;if S then a.control.extendLandingGears()c4("grOut","LG",1)end;s:setTargetGroundAltitude(LandingGearGroundHeight)af=0;BrakeIsOn=true else BrakeIsOn=true end elseif StrongBrakes and br:normalize():dot(-h7)<0.999 then BrakeIsOn=true elseif bu<-brakeLandingRate and not mr then BrakeIsOn=true elseif not mr then BrakeIsOn=false end end;if AutoTakeoff or am then local b_,c1,c0;if AutopilotTargetCoords~=nil then b_,c1,c0=aR:getPlanetarySystem(0):castIntersections(bv,(AutopilotTargetCoords-bv):normalize(),function(c2)return c2.radius+c2.noAtmosphericDensityAltitude end)end;if by then if as>=HoldAltitude-50 then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn=true;cn(0)end else HoldAltitude=antigrav.getBaseAltitude()end elseif d(lR)<15 and as/HoldAltitude>0.75 then AutoTakeoff=false;if not am then if bA and not AtmoSpeedAssist then a.control.cancelCurrentControlMasterMode()end elseif am and bs<Q then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;cn(0)elseif am then cn(0)BrakeIsOn=true end elseif am and ar==0 and ac~=nil and(b_==nil or b_.name==ac.name)then Autopilot=true;am=false;AltitudeHold=false;AutoTakeoff=false;if not bA then cn(0)end;AutopilotAccelerating=true end end;local mG=ao>-1;local mH=bB;if(VectorToTarget or am or bK)and not mG and bs>minRollVelocity and ar>0.01 then local mj=math.rad(d(bC))mH=bB*d(math.cos(mj))+lm*math.sin(mj)end;local mI=r(lR-mH,-PitchStallAngle*0.80,PitchStallAngle*0.80)if ar<0.01 and VectorToTarget then mI=r(lR-mH,-85,MaxPitch)elseif ar<0.01 then mI=r(lR-mH,-MaxPitch,MaxPitch)end;if d(bC)<5 or VectorToTarget or bK or BrakeLanding or mG or AltitudeHold then if pitchPID==nil then pitchPID=pid.new(5*0.01,0,5*0.1)end;pitchPID:inject(mI)local lS=pitchPID:get()U=U+lS end end;if antigrav~=nil and(antigrav and not ExternalAGG and as<200000)then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;antigrav.setBaseAltitude(desiredBaseAltitude)end end end;ao=kT()return cB end;function script.onStart()local mJ={}local mK={}local mL=false;local function mM()local function mN(mO)local mP=dbHud_1.hasKey;for cQ,cR in pairs(mO)do if mP(cR)then local d6=g(dbHud_1.getStringValue(cR))if d6~=nil then _G[cR]=d6;mL=true end end end end;if dbHud_1 then if not useTheseSettings then mN(ca())coroutine.yield()mN(c)else mN(c)a2="Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use saved values"ai=5;mL=false end;coroutine.yield()if mL then a2="Loaded Saved Variables"aG=ResolutionX;aH=ResolutionY;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)b0=autoRollPreference;b7=AtmoSpeedLimit;ay=[[rgb(]]..e(H+0.5)..","..e(J+0.5)..","..e(I+0.5)..[[)]]az=[[rgb(]]..e(H*0.9+0.5)..","..e(J*0.9+0.5)..","..e(I*0.9+0.5)..[[)]]elseif not useTheseSettings then a2="No Saved Variables Found - Exit HUD to save settings"end;if LastVersionUpdate<1.500 then if LowOrbitHeight<2000 then a2="Updating LowOrbitHeight to new minimum default of 2000."LowOrbitHeight=2000 end end;LastVersionUpdate=VERSION_NUMBER else a2="No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations"end;if LastStartTime+180<E then LastMaxBrakeInAtmo=0 end;LastStartTime=E;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then a2="Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen"ai=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=as end;antigrav.setBaseAltitude(AntigravTargetAltitude)end;VectorStatus="Proceeding to Waypoint"end;local function mQ()local function mR(mS,mT)if mS>mT then mT=mS end;local mU,mV=0,0;if ContainerOptimization>0 then mU=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then mV=FuelTankOptimization*0.05 end;mT=mT*(1-(mU+mV))return mT end;local mW=core.getElementNameById;local mX=fuelX~=0 and fuelY~=0;for cQ in pairs(at)do local type=core.getElementTypeById(at[cQ])if o(type,'^.*Atmospheric Engine$')then if o(tostring(core.getElementTagsById(at[cQ])),'^.*vertical.*$')and core.getElementForwardById(at[cQ])[3]>0 then bx=true end end;if o(type,'^.*Space Engine$')then bl=true;if o(tostring(core.getElementTagsById(at[cQ])),'^.*vertical.*$')then local mY=core.getElementForwardById(at[cQ])if mY[3]<0 then bj=true else bk=true end end end;if type=="Landing Gear"then S=true end;if type=="Dynamic Core Unit"then local mZ=j(at[cQ])if mZ>10000 then G=110 elseif mZ>1000 then G=55 elseif mZ>150 then G=27 end end;aL=aL+j(at[cQ])if mX and(type=="Atmospheric Fuel Tank"or type=="Space Fuel Tank"or type=="Rocket Fuel Tank")then local mZ=j(at[cQ])local k2=l(at[cQ])local mS=0;local gX=q()if type=="Atmospheric Fuel Tank"then local mT=400;local m_=35.03;if mZ>10000 then mT=51200;m_=5480 elseif mZ>1300 then mT=6400;m_=988.67 elseif mZ>150 then mT=1600;m_=182.67 end;mS=k2-m_;if fuelTankHandlingAtmo>0 then mT=mT+mT*fuelTankHandlingAtmo*0.2 end;mT=mR(mS,mT)aI[#aI+1]={at[cQ],mW(at[cQ]),mT,m_,mS,gX}end;if type=="Rocket Fuel Tank"then local mT=320;local m_=173.42;if mZ>65000 then mT=40000;m_=25740 elseif mZ>6000 then mT=5120;m_=4720 elseif mZ>700 then mT=640;m_=886.72 end;mS=k2-m_;if fuelTankHandlingRocket>0 then mT=mT+mT*fuelTankHandlingRocket*0.1 end;mT=mR(mS,mT)aK[#aK+1]={at[cQ],mW(at[cQ]),mT,m_,mS,gX}end;if type=="Space Fuel Tank"then local mT=600;local m_=35.03;if mZ>10000 then mT=76800;m_=5480 elseif mZ>1300 then mT=9600;m_=988.67 elseif mZ>150 then mT=2400;m_=182.67 end;mS=k2-m_;if fuelTankHandlingSpace>0 then mT=mT+mT*fuelTankHandlingSpace*0.2 end;mT=mR(mS,mT)aJ[#aJ+1]={at[cQ],mW(at[cQ]),mT,m_,mS,gX}end end end;if not bx then VertTakeOff,VertTakeOffEngine=false,false end end;local function n0()if gyro~=nil then ax=gyro.getState()==1 end;if not stablized then s:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then w(1)else w(0)end;if door and(aq or not aq and as<10000)then for _,cR in pairs(door)do cR.toggle()end end;if switch then for _,cR in pairs(switch)do cR.toggle()end end;if forcefield and(aq or not aq==0 and as<10000)then for _,cR in pairs(forcefield)do cR.toggle()end end;if antigrav then by=antigrav.getState()==1;if by and not ExternalAGG then antigrav.show()end end;if m()==1 and RemoteFreeze then system.freeze(1)else system.freeze(0)end;if S then GearExtended=a.control.isAnyLandingGearExtended()==1;if GearExtended then a.control.extendLandingGears()else a.control.retractLandingGears()end end;if ao~=-1 or not aq and bq:len()<50 then BrakeIsOn=true;GearExtended=true;if S then a.control.extendLandingGears()end else BrakeIsOn=false end;s:setTargetGroundAltitude(b1)if aq and ao~=-1 then aT=core.getMaxKinematicsParametersAlongAxis("ground",core.getConstructOrientationUp())[1]end;WasInAtmo=aq end;local function n1(ci,cj,n2,kb,ic)local n3={x=ci,y=cj,width=n2,height=kb,label=ic}bT[ic]=n3;return n3 end;local function n4(n5,n6,n2,kb,ci,cj,n7,n8,n9,na)local n3={enableName=n5,disableName=n6,width=n2,height=kb,x=ci,y=cj,toggleVar=n7,toggleFunction=n8,drawCondition=n9,hovered=false}if na then table.insert(mK,n3)else table.insert(mJ,n3)end;return n3 end;local function nb(nc)if not bD then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif nc=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif nc=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif nc=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then bE=ca(nc)showHud=false else bE={}showHud=true end end;local function nd()bD=not bD;if bD then aF=mK;a2="Hold SHIFT to see Settings"bF=showHud else aF=mJ;a2="Hold SHIFT to see Control Buttons"nb()showHud=bF end end;local function ne(cR)_G[cR]=not _G[cR]if _G[cR]then a2=cR.." set to true"else a2=cR.." set to false"end;if cR=="showHud"then bF=_G[cR]elseif cR=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local function nf()local ng=50;local nh=340;local ci=500;local cj=aH/2-400;local ni=0;for cQ,cR in pairs(ca("boolean"))do if type(_G[cR])=="boolean"then n4(cR,cR,nh,ng,ci,cj,function()return _G[cR]end,function()ne(cR)end,function()return true end,true)cj=cj+ng+20;if ni==9 then ci=ci+nh+20;cj=aH/2-400;ni=0 else ni=ni+1 end end end;n4("Control View","Control View",nh,ng,10,aH/2-500,function()return true end,nd,function()return true end,true)n4("View Handling Settings",'Hide Handling Settings',nh,ng,10,aH/2-(500-ng),function()return showHandlingVariables end,function()nb("handling")end,function()return true end,true)n4("View Hud Settings",'Hide Hud Settings',nh,ng,10,aH/2-(500-ng*2),function()return showHudVariables end,function()nb("hud")end,function()return true end,true)n4("View Physics Settings",'Hide Physics Settings',nh,ng,10,aH/2-(500-ng*3),function()return showPhysicsVariables end,function()nb("physics")end,function()return true end,true)end;local function nj()local function kD()local position=bv;local g5=planet.name..". "..#SavedLocations;if bP[1]then local di,_=bP[1].getData():match('"constructId":"([0-9]*)","distance":([%d%.]*)')if di~=nil and di~=""then g5=g5 .." "..bP[1].getConstructName(di)end end;return aW.AddNewLocation(g5,position,false,true)end;local function nk()TurnBurn=not TurnBurn end;local function nl(nm)if nm==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;a0=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function nn()aW.UpdatePosition()end;local function kC()aW.ClearCurrentPosition()end;local function no(fR)local g5=AutopilotTargetName;if fR~=nil and type(fR)=="number"then if fR==0 then return"None"end;g5=bG[fR].name end;if g5==nil then g5=CustomTarget.name end;if g5==nil then g5="None"end;return g5 end;local function np(fR)return"Engage Autopilot: "..no(fR)end;local function nq(fR)return"Disable Autopilot: "..no(fR)end;local function nr()if m()==1 then a0=not a0;if a0 then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;a.control.retractLandingGears()s:setTargetGroundAltitude(TargetHoverHeight)c4("folOn","F")else c4("folOff","F")BrakeIsOn=true;b0=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then a.control.extendLandingGears()s:setTargetGroundAltitude(LandingGearGroundHeight)end end else a2="Follow Mode only works with Remote controller"a0=false end end;local ng=50;local nh=260;local ns=n4("Enable Brake Toggle","Disable Brake Toggle",nh,ng,aG/2-nh/2,aH/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then a2="Brakes in Toggle Mode"else a2="Brakes in Default Mode"end end)n4("Align Prograde","Disable Prograde",nh,ng,aG/2-nh/2-50-ns.width,aH/2-ng+380,function()return ProgradeIsOn end,function()nl(1)end)n4("Align Retrograde","Disable Retrograde",nh,ng,aG/2-nh/2+ns.width+50,aH/2-ng+380,function()return RetrogradeIsOn end,nl,function()return ar==0 end)apbutton=n4(np,nq,600,60,aG/2-600/2,aH/2-60/2-330,function()return Autopilot or VectorToTarget or am or IntoOrbit end,function()end)local i;local function nt(nu)local fR=bS+nu;if fR>#bG then fR=fR-#bG-1 end;if fR<0 then fR=#bG+fR end;return fR end;apExtraButtons={}for i=0,10 do local button=n4(function(ct)local fR=nt(ct.apExtraIndex)if Autopilot or VectorToTarget or am or IntoOrbit then return"Redirect: "..no(fR)end;return np(fR)end,function(ct)local fR=nt(ct.apExtraIndex)return nq(fR)end,600,60,aG/2-600/2,aH/2-60/2-330+60*i,function(ct)local fR=nt(ct.apExtraIndex)return fR==AutopilotTargetIndex and(Autopilot or VectorToTarget or am or IntoOrbit)end,function(ct)local fR=nt(ct.apExtraIndex)local nw=AutopilotTargetIndex==fR;AutopilotTargetIndex=fR;aW.UpdateAutopilotTarget()cC()if not nw and not(Autopilot or VectorToTarget or am or IntoOrbit)then cC()end end,function()return bR end)button.apExtraIndex=i;apExtraButtons[i]=button end;n4("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,kD,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)n4("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,nn,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)n4("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,kC,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)ng=60;nh=300;local ci=aG-nh-10;local cj=aH/2-150;n4("View Settings","View Settings",nh,ng,ci,cj,function()return true end,nd)cj=cj+ng+20;n4("Enable Turn and Burn","Disable Turn and Burn",nh,ng,ci,cj,function()return TurnBurn end,nk)ci=10;cj=aH/2-300;n4("Horizontal Takeoff Mode","Vertical Takeoff Mode",nh,ng,ci+nh+20,cj,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then a2="Vertical Takeoff Mode"else a2="Horizontal Takeoff Mode"end end,function()return bx end)cj=cj+ng+20;n4("Engage Orbiting","Cancel Orbiting",nh,ng,ci+nh+20,cj,function()return IntoOrbit end,cy,function()return ar==0 and bM end)cj=cj+ng+20;n4("Glide Re-Entry","Cancel Glide Re-Entry",nh,ng,ci,cj,function()return Reentry end,function()al=1;nl(1)end,function()return planet.hasAtmosphere and not aq end)n4("Parachute Re-Entry","Cancel Parachute Re-Entry",nh,ng,ci+nh+20,cj,function()return Reentry end,cF,function()return planet.hasAtmosphere and not aq end)cj=cj+ng+20;n4("Engage Follow Mode","Disable Follow Mode",nh,ng,ci,cj,function()return a0 end,nr,function()return m()==1 end)n4("Enable Repair Arrows","Disable Repair Arrows",nh,ng,ci+nh+20,cj,function()return aM end,function()aM=not aM;if aM then a2="Repair Arrows Enabled"else a2="Repair Arrows Diabled"end end,function()return m()==1 end)cj=cj+ng+20;if not ExternalAGG then n4("Enable AGG","Disable AGG",nh,ng,ci,cj,function()return by end,cG,function()return antigrav~=nil end)end;n4(function()return f("Switch IPH Mode - Current: %s",iphCondition)end,function()return f("IPH Mode: %s",iphCondition)end,nh*2,ng,ci,cj,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons"else iphCondition="All"end;a2="IPH Mode: "..iphCondition end)cj=cj+ng+20;n4(function()return f("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return f("Control Scheme: %s",userControlScheme)end,nh*2,ng,ci,cj,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;a2="New Control Scheme: "..userControlScheme end)local nx=gh(20)local button=n1(0,0,gg(70),nx,"INFO")button=n1(button.x+button.width,button.y,gg(80),nx,"ORBIT")button=n1(button.x+button.width,button.y,gg(70),nx,"HELP")n1(button.x+button.width,button.y,gg(70),nx,"HIDE")end;local function ny()local nz={}local function nA()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local nB={[1]=4480,[6]=4480,[7]=6270}for nC,nD in pairs(b)do b[nC][0]=nA()b[nC][0].systemId=nC;nz[nC]={}for nE,planet in pairs(b[nC])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness or planet.atmosphereRadius-planet.radius;planet.spaceEngineMinAltitude=nB[planet.id]or 0.68377*(planet.atmosphereThickness or planet.atmosphereRadius-planet.radius)planet.planetarySystemId=nC;planet.bodyId=planet.id;nz[nC][nE]=planet end end;aQ=cS()aR=aQ(nz)aS=ec()aU=eG()aY=f3()aV=gi()aW=kq()end;SetupComplete=false;beginSetup=coroutine.create(function()s:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})mM()coroutine.yield()mQ()coroutine.yield()aX=kJ()n0()nf()nj()aF=mJ;coroutine.yield()ny()coroutine.yield()unit.hide()system.showScreen(1)system.showHelper(0)collectgarbage("collect")coroutine.yield()unit.setTimer("apTick",apTickRate)unit.setTimer("radarTick",apTickRate)unit.setTimer("hudTick",hudTickRate)unit.setTimer("oneSecond",1)unit.setTimer("tenthSecond",1/10)unit.setTimer("fiveSecond",5)bP[1]=nil;if radar_1 then bP[1]=radar_1;aY.pickType()end;c4("start","SU")end)coroutine.resume(beginSetup)end;function script.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hide()end;if warpdrive~=nil then warpdrive.hide()end;core.hide()a.control.switchOffHeadlights()if door and(ar>0 or ar==0 and as<10000)then for _,cR in pairs(door)do cR.toggle()end end;if switch then for _,cR in pairs(switch)do cR.toggle()end end;if forcefield and(ar>0 or ar==0 and as<10000)then for _,cR in pairs(forcefield)do cR.toggle()end end;cM()if button then button.activate()end;if SetWaypointOnExit then aX.showWayPoint(planet,bv)end;c4("stop","SU")end;function script.onTick(nF)local nG=nil;if nF=="contact"then if not contactTimer then contactTimer=0 end;if E>contactTimer+10 then a2="Radar Contact"c4("rdrCon","RC")contactTimer=E end;unit.stopTimer("contact")elseif nF=="tenthSecond"then local function nH()local nI=system.createData;local nJ=system.createWidget;panelInterplanetary=system.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=nJ(panelInterplanetary,"value")interplanetaryHeaderText=nI('{"label": "Target Planet", "value": "N/A", "unit":""}')v(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=nJ(panelInterplanetary,"value")widgetDistanceText=nI('{"label": "distance", "value": "N/A", "unit":""}')v(widgetDistanceText,widgetDistance)widgetTravelTime=nJ(panelInterplanetary,"value")widgetTravelTimeText=nI('{"label": "Travel Time", "value": "N/A", "unit":""}')v(widgetTravelTimeText,widgetTravelTime)widgetMaxMass=nJ(panelInterplanetary,"value")widgetMaxMassText=nI('{"label": "Maximum Mass", "value": "N/A", "unit":""}')v(widgetMaxMassText,widgetMaxMass)widgetTargetOrbit=nJ(panelInterplanetary,"value")widgetTargetOrbitText=nI('{"label": "Target Altitude", "value": "N/A", "unit":""}')v(widgetTargetOrbitText,widgetTargetOrbit)widgetCurBrakeDistance=nJ(panelInterplanetary,"value")widgetCurBrakeDistanceText=nI('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=nJ(panelInterplanetary,"value")widgetCurBrakeTimeText=nI('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=nJ(panelInterplanetary,"value")widgetMaxBrakeDistanceText=nI('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=nJ(panelInterplanetary,"value")widgetMaxBrakeTimeText=nI('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=nJ(panelInterplanetary,"value")widgetTrajectoryAltitudeText=nI('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not aq then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)v(widgetCurBrakeTimeText,widgetCurBrakeTime)v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function nK()t(panelInterplanetary)panelInterplanetary=nil end;local function nL()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(ac.center-bv):len()else AutopilotDistance=(CustomTarget.position-bv):len()end end;local eE=bs;local lU=unit.getThrottle()/100;if AtmoSpeedAssist then lU=K end;local nM,nN=aS.computeDistanceAndTime(bs,MaxGameVelocity,av,a:maxForceForward()*lU,warmup,0)local a8,a9;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local _,nO;if not TurnBurn and eE>0 then _,nO=aX.GetAutopilotBrakeDistanceAndTime(eE)else _,nO=aX.GetAutopilotTBBrakeDistanceAndTime(eE)end;local nP=0;local nQ=0;if AutopilotCruising or not Autopilot and eE>5 then nQ=aS.computeTravelTime(eE,0,AutopilotDistance)elseif a8+nM<AutopilotDistance then nP=AutopilotDistance-(a8+nM)nQ=aS.computeTravelTime(8333.0556,0,nP)else local nR=(AutopilotDistance-a8)/nM;nM=AutopilotDistance-a8;nN=nN*nR end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return nQ elseif AutopilotBraking then return nO elseif AutopilotCruising then return nQ+nO else return nN+a9+nQ end end;local function nS(jV,nT)if jV==nil then jV=core.g()end;jV=A(jV,5)if nT~=nil and nT or(nG==nil or nG~=jV)then local eE=bq:len()local nU=g(unit.getData()).maxBrake;if nU~=nil and nU>0 and aq then nU=nU/r(eE/100,0.1,1)nU=nU/ar;if ar>0.10 then if LastMaxBrakeInAtmo then LastMaxBrakeInAtmo=(LastMaxBrakeInAtmo+nU)/2 else LastMaxBrakeInAtmo=nU end end end;if nU~=nil and nU>0 then LastMaxBrake=nU end;nG=jV end end;nS(nil,true)if bz~=nil then if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed or s:getTargetSpeed(axisCommandId.longitudinal)~=bz then cq(bz)else bz=nil end end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then nH()end;if AutopilotTargetName~=nil then local nV=CustomTarget~=nil;local nW=0.5*LastMaxBrakeInAtmo/ac:getGravity(ac.center+vec3(0,0,1)*ac.radius):len()nW=nW>1000000 and A(nW/1000000,2).." kTons"or A(nW/1000,2).." Tons"u(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')travelTime=nL()if nV and not Autopilot then aj=(bv-CustomTarget.position):len()else aj=(AutopilotTargetCoords-bv):len()end;if not TurnBurn then a8,a9=aX.GetAutopilotBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)else a8,a9=aX.GetAutopilotTBBrakeDistanceAndTime(bs)aa,ab=aX.GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)end;local iG=cu(aj)u(widgetDistanceText,'{"label": "distance", "value": "'..iG..'"}')u(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..cH(travelTime)..'", "unit":""}')iG=cu(a8)u(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..iG..'"}')u(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..cH(a9)..'", "unit":""}')iG=cu(aa)u(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..iG..'"}')u(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..cH(ab)..'", "unit":""}')u(widgetMaxMassText,'{"label": "Max Brake Mass", "value": "'..f("%s",nW)..'", "unit":""}')iG=cu(AutopilotTargetOrbit)u(widgetTargetOrbitText,'{"label": "Target Orbit", "value": "'..iG..'"}')if ar>0 and not WasInAtmo then system.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)system.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)system.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)system.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)system.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not bA and AtmoSpeedAssist and(AltitudeHold or Reentry or an)then cn(1)BrakeIsOn=false;O=false end end;if ar==0 and WasInAtmo then if u(widgetMaxBrakeTimeText,widgetMaxBrakeTime)==1 then v(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if u(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)==1 then v(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if u(widgetCurBrakeTimeText,widgetCurBrakeTime)==1 then v(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if u(widgetCurBrakeDistanceText,widgetCurBrakeDistance)==1 then v(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if u(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)==1 then v(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else nK()end;if warpdrive~=nil then if g(warpdrive.getData()).destination~="Unknown"and g(warpdrive.getData()).distance>400000 then warpdrive.show()showWarpWidget=true else warpdrive.hide()showWarpWidget=false end end;aV.DrawTanks()if shield_1 then aV.DrawShield()end elseif nF=="oneSecond"then local function nX(h3)local function nY()for cQ,cR in pairs(ca())do dbHud_1.setStringValue(cR,h(nil))end;for cQ,cR in pairs(c)do dbHud_1.setStringValue(cR,h(nil))end;a2="Databank wiped"ai=5 end;local nZ=0;aD=""local n_=aL;local o0=0;local o1=0;local o2=0;local h0=0;local h1=""local o3=core.getElementHitPointsById;for cQ in pairs(at)do local mZ=0;local o4=0;o4=j(at[cQ])mZ=o3(at[cQ])o0=o0+mZ;if mZ<o4 then if mZ==0 then o2=o2+1 else o1=o1+1 end;if aM and#aA==0 then position=vec3(core.getElementPositionById(at[cQ]))local ci=position.x;local cj=position.y;local fy=position.z;table.insert(aA,core.spawnArrowSticker(ci,cj,fy+1,"down"))table.insert(aA,core.spawnArrowSticker(ci,cj,fy+1,"down"))core.rotateSticker(aA[2],0,0,90)table.insert(aA,core.spawnArrowSticker(ci+1,cj,fy,"north"))table.insert(aA,core.spawnArrowSticker(ci+1,cj,fy,"north"))core.rotateSticker(aA[4],90,90,0)table.insert(aA,core.spawnArrowSticker(ci-1,cj,fy,"south"))table.insert(aA,core.spawnArrowSticker(ci-1,cj,fy,"south"))core.rotateSticker(aA[6],90,-90,0)table.insert(aA,core.spawnArrowSticker(ci,cj-1,fy,"east"))table.insert(aA,core.spawnArrowSticker(ci,cj-1,fy,"east"))core.rotateSticker(aA[8],90,0,90)table.insert(aA,core.spawnArrowSticker(ci,cj+1,fy,"west"))table.insert(aA,core.spawnArrowSticker(ci,cj+1,fy,"west"))core.rotateSticker(aA[10],-90,0,90)table.insert(aA,at[cQ])end elseif aM and#aA>0 and aA[11]==at[cQ]then for gW in pairs(aA)do core.deleteSticker(aA[gW])end;aA={}end end;nZ=e(o0/n_*100)if nZ<100 then if nZ>0 and nZ<WipeDamage then nY()end;h3[#h3+1]=ch(0,0,"","pbright txt")h0=e(nZ*2.55)h1=f("rgb(%d,%d,%d)",255-h0,h0,0)if nZ<100 then h3[#h3+1]=ch("50%",1035,"Elemental Integrity: "..nZ.."%","txtbig txtmid","fill:"..h1)if o2>0 then h3[#h3+1]=ch("50%",1055,"Disabled Modules: "..o2 .." Damaged Modules: "..o1,"txtbig txtmid","fill:"..h1)elseif o1>0 then h3[#h3+1]=ch("50%",1055,"Damaged Modules: "..o1,"txtbig txtmid","fill:"..h1)end end end end;local function o5()if weapon then if WeaponPanelID==nil and(radarPanelID~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,L_TEXT("ui_lua_widget_weapon", "Weapons"),"weapon",true)WeaponPanelID=_autoconf.panels[_autoconf.panels_size]elseif WeaponPanelID~=nil and radarPanelID==nil and not GearExtended then t(WeaponPanelID)WeaponPanelID=nil end end end;local function o6()local gX=q()local ig=bs;local o7=gX-au;if ig>1.38889 then ig=ig/1000;local o8=ig*(gX-au)TotalDistanceTravelled=TotalDistanceTravelled+o8;ad=ad+o8 end;ae=ae+o7;TotalFlightTime=TotalFlightTime+o7;au=gX end;o6()aV.UpdatePipe()passengers=core.getPlayersOnBoard()ships=core.getDockedConstructs()o5()local h3={}aV.ExtraData(h3)if ShouldCheckDamage then nX(h3)end;ak=table.concat(h3,"")collectgarbage("collect")elseif nF=="fiveSecond"then if not UseSatNav then return end;ap=dbHud_1.getStringValue("SPBAutopilotTargetName")if ap~=nil and ap~=""and ap~="SatNavNotChanged"then local d6=g(dbHud_1.getStringValue("SavedLocations"))if d6~=nil then _G["SavedLocations"]=d6;local fR=-1;local kF;for cQ,cR in pairs(SavedLocations)do if cR.name and cR.name=="SatNav Location"then fR=cQ;break end end;if fR~=-1 then kF=SavedLocations[fR]fR=-1;for cQ,cR in pairs(b[0])do if cR.name and cR.name=="SatNav Location"then fR=cQ;break end end;if fR>-1 then b[0][fR]=kF end;aW.UpdateAtlasLocationsList()a2=kF.name.." position updated"end end;for i=1,#bG do if bG[i].name==ap then AutopilotTargetIndex=i;system.print("Index = "..AutopilotTargetIndex.." "..bG[i].name)aW.UpdateAutopilotTarget()dbHud_1.setStringValue("SPBAutopilotTargetName","SatNavNotChanged")break end end end elseif nF=="msgTick"then local h3={}aV.DisplayMessage(h3,"empty")a2="empty"unit.stopTimer("msgTick")ai=3 elseif nF=="animateTick"then a_=true;aZ=false;ag=0;ah=0;unit.stopTimer("animateTick")elseif nF=="hudTick"then if not planet then return end;local function o9(h3)local oa=e(r(aj/(aG/4)*255,0,255))h3[#h3+1]=f("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",ag,ah,e(H+0.5)+oa,e(J+0.5)-oa,e(I+0.5)-oa)end;local function ob()for _,cR in pairs(aF)do if cR.hovered then if not cR.drawCondition or cR.drawCondition(cR)then cR.toggleFunction(cR)end;cR.hovered=false end end;for _,cR in pairs(bT)do if cR.hovered then SelectedTab=cR.label;cR.hovered=false end end end;local function oc()local function od(oe,of,ci,cj,n2,kb)if oe>=ci and oe<=ci+n2 and of>=cj and of<=cj+kb then return true else return false end end;local ci=ag+aG/2;local cj=ah+aH/2;for _,cR in pairs(aF)do cR.hovered=od(ci,cj,cR.x,cR.y,cR.width,cR.height)end;for _,cR in pairs(bT)do cR.hovered=od(ci,cj,cR.x,cR.y,cR.width,cR.height)end;if bR then local og=false;for _,ct in ipairs(apExtraButtons)do if ct.hovered then og=true;break end end;if apbutton.hovered then og=true end;bR=og else bR=apbutton.hovered;if not bR then bS=AutopilotTargetIndex end end end;local function oh(h3)if not SelectedTab or SelectedTab==""then SelectedTab="INFO"end;for cQ,cR in pairs(bT)do local cl="dim brightstroke"local oi=0.2;if SelectedTab==cQ then cl="pbright dimstroke"oi=0.6 end;local oj=""if cR.hovered then oi=0.8;oj=";stroke:white"end;h3[#h3+1]=f([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],cR.width,cR.height,cR.x,cR.y,cl,oi,oj)h3[#h3+1]=ch(cR.x+cR.width/2,cR.y+cR.height/2+5,cR.label,"txt txtmid pdim")end end;local function ok(h3)local function ol(h3,om,hover,ci,cj,ex,on,oo,op,oq,os,button)if type(oq)=="function"then oq=oq(button)end;if type(os)=="function"then os=os(button)end;h3[#h3+1]=f("<rect x='%f' y='%f' width='%f' height='%f' fill='",ci,cj,ex,on)if om then h3[#h3+1]=f("%s'",oo)else h3[#h3+1]=op end;if hover then h3[#h3+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else h3[#h3+1]=f(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",A(SafeR*0.5,0),A(SafeG*0.5,0),A(SafeB*0.5,0))end;h3[#h3+1]=" rx='5'></rect>"h3[#h3+1]=f("<text x='%f' y='%f' font-size='24' fill='",ci+ex/2,cj+on/2+5)if om then h3[#h3+1]="black"else h3[#h3+1]="white"end;h3[#h3+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if om then h3[#h3+1]=f("%s</text>",oq)else h3[#h3+1]=f("%s</text>",os)end end;local ot=f("rgb(%d,%d,%d)'",A(SafeR*0.1,0),A(SafeG*0.1,0),A(SafeB*0.1,0))local ou=f("rgb(%d,%d,%d)",A(SafeR*0.8,0),A(SafeG*0.8,0),A(SafeB*0.8,0))local ov=ol;for _,cR in pairs(aF)do local n6=cR.disableName;local n5=cR.enableName;if type(n6)=="function"then n6=n6(cR)end;if type(n5)=="function"then n5=n5(cR)end;if not cR.drawCondition or cR.drawCondition(cR)then ov(h3,cR.toggleVar(cR),cR.hovered,cR.x,cR.y,cR.width,cR.height,ou,ot,n6,n5,cR)end end end;local ow=A(ResolutionX/2,0)local ox=A(ResolutionY/2,0)local h3={}aV.HUDPrologue(h3)if showHud then aV.UpdateHud(h3)else if AlwaysVSpd then aV.DrawVerticalSpeed(h3,as)end;aV.DisplayOrbitScreen(h3)aV.DrawWarnings(h3)end;if bD and bE~={}then aV.DrawSettings(h3)end;if radar_1 or radar_2 then aY.assignRadar()end;if bP[1]then aV.DrawRadarInfo()end;aV.HUDEpilogue(h3)h3[#h3+1]=f([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],aG,aH)if a2~="empty"then aV.DisplayMessage(h3,a2)end;if m()==0 and userControlScheme=="virtual joystick"then if DisplayDeadZone then aV.DrawDeadZone(h3)end end;oh(h3)if x()==0 then if m()==1 and a1 then if not AltIsOn then oc()ok(h3)end;if not aZ and not a_ then local oy=table.concat(h3,"")h3={}h3[#h3+1]=f("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h3[#h3+1]=oy;h3[#h3+1]="</body>"aZ=true;h3[#h3+1]=[[</svg></body>]]unit.setTimer("animateTick",0.5)local content=table.concat(h3,"")system.setScreen(content)elseif a_ then local oy=table.concat(h3,"")h3={}h3[#h3+1]=f("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",aG,aH)h3[#h3+1]=oy;h3[#h3+1]="</body>"end;if not aZ then h3[#h3+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ow,ox,ag,ah)end else ob()end else if not a1 and m()==0 then ob()if aj>DeadZone then if DisplayDeadZone then o9(h3)end end elseif not AltIsOn or AltIsOn and a1 then oc()ok(h3)end;h3[#h3+1]=f([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],ow,ox,ag,ah)end;h3[#h3+1]=[[</svg></body>]]content=table.concat(h3,"")elseif nF=="apTick"then aX.APTick()elseif nF=="radarTick"then aY.UpdateRadar()elseif nF=="tagTick"then if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;a2="Extra Engine Tags: "..UseExtra;unit.stopTimer("tagTick")end end;function script.onFlush()local function oz(oA,m3)local oB=vec3()local oC=vec3()if oA==axisCommandId.longitudinal then oB=vec3(core.getConstructOrientationForward())oC=bo elseif oA==axisCommandId.vertical then oB=vec3(core.getConstructOrientationUp())oC=bn elseif oA==axisCommandId.lateral then oB=vec3(core.getConstructOrientationRight())oC=bp else return vec3()end;local oD=vec3(core.getWorldGravity())local oE=oD:dot(oC)local oF=vec3(core.getWorldAirFrictionAcceleration())local oG=oF:dot(oC)local oH=bq:dot(oB)local oI=m3*constants.kph2m;if targetSpeedPID2==nil then targetSpeedPID2=pid.new(10,0,10.0)end;targetSpeedPID2:inject(oI-oH)local oJ=targetSpeedPID2:get()local oK=(oJ-oG-oE)*oC;return oK end;local function oL(oA,m3)local oB=vec3()local oC=vec3()if oA==axisCommandId.longitudinal then oB=vec3(core.getConstructOrientationForward())oC=bo elseif oA==axisCommandId.vertical then oB=vec3(core.getConstructOrientationUp())oC=bn elseif oA==axisCommandId.lateral then oB=vec3(core.getConstructOrientationRight())oC=bp else return vec3()end;local oD=vec3(core.getWorldGravity())local oE=oD:dot(oC)local oF=vec3(core.getWorldAirFrictionAcceleration())local oG=oF:dot(oC)local oH=bq:dot(oB)local oI=m3*constants.kph2m;if targetSpeedPID==nil then targetSpeedPID=pid.new(10,0,10.0)end;targetSpeedPID:inject(oI-oH)local oJ=targetSpeedPID:get()local oK=(oJ-oG-oE)*oC;return oK end;local function oM(oN,h6,kv)local oO=oN:cross(kv):normalize_inplace()local hT=math.acos(r(oO:dot(-h6),-1,1))*constants.rad2deg;if oO:cross(-h6):dot(kv)<0 then hT=-hT end;return hT end;if antigrav and not ExternalAGG then if not by and antigrav.getBaseAltitude()~=AntigravTargetAltitude then antigrav.setBaseAltitude(AntigravTargetAltitude)end end;bA=s:getAxisCommandType(0)==axisCommandType.byThrottle;if bA and O then cn(0)O=false elseif not bA and not O then K=0;O=true end;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)local oP=r(T+U+system.getControlDeviceForwardInput(),-1,1)local oQ=r(W+Z+system.getControlDeviceYawInput(),-1,1)local oR=r(X+V-system.getControlDeviceLeftRightInput(),-1,1)local oS=Y;bt=vec3(core.getWorldVertical())if bt==nil or bt:len()==0 then bt=(planet.center-bv):normalize()end;bn=vec3(core.getConstructWorldOrientationUp())bo=vec3(core.getConstructWorldOrientationForward())bp=vec3(core.getConstructWorldOrientationRight())br=vec3(core.getWorldVelocity())bq=vec3(core.getVelocity())bv=vec3(core.getConstructWorldPos())av=core.getConstructMass()bs=vec3(br):len()bu=-bt:dot(br)bC=getRoll(bt,bo,bp)local oT=bC/180*math.pi;local oU=math.cos(oT)local oV=math.sin(oT)bB=oM(bt,bo,bp*oU+bn*oV)local oW=br:normalize()local oX=d(bC)local oY=utils.sign(bC)local oZ=vec3(core.getWorldAngularVelocity())local o_=oP*pitchSpeedFactor*bp+oQ*rollSpeedFactor*bo+oR*yawSpeedFactor*bn;if b0==true and bt:len()>0.01 then local p0=d(b4-bC)if((ProgradeIsOn or Reentry or BrakeLanding or al or AltitudeHold or IntoOrbit)and p0>0 or ar>0.0 and p0<autoRollRollThreshold and autoRollPreference)and oQ==0 and d(bB)<85 then local p1=b4;local p2=autoRollFactor;if ar==0 then p2=p2/4;b4=0;p1=0 end;if rollPID==nil then rollPID=pid.new(p2*0.01,0,p2*0.1)end;rollPID:inject(p1-bC)local p3=rollPID:get()o_=o_+p3*bo end end;local p4=1;local p5=0;local p6=1;local p7=system.getMouseWheel()if p7>0 then bV()elseif p7<0 then bV(true)else aw=true end;L=0;if aq and AtmoSpeedAssist and bA then if throttlePID==nil then throttlePID=pid.new(0.5,0,1)end;throttlePID:inject(b7/3.6-br:dot(bo))local p8=throttlePID:get()N=r(p8,-1,1)if N<K and ar>0.005 then M=true;s:setThrottleCommand(axisCommandId.longitudinal,r(N,0.01,1))else M=false;s:setThrottleCommand(axisCommandId.longitudinal,K)end;if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-b7/3.6)local p9=r(brakePID:get(),0,1)if ar>0 and bu<-80 or ar>0.005 then L=p9 end;if L>0 then if M and N==0.01 then s:setThrottleCommand(axisCommandId.longitudinal,0)end else N=r(N,0.01,1)end;local pa=''local pb=vec3()local pc=oz(axisCommandId.vertical,af*1000)a:setEngineForceCommand("vertical airfoil , vertical ground ",pc,p5)local pd='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pd=pd..ExtraLongitudeTags end;local pe=s:getAxisCommandType(axisCommandId.longitudinal)local pf=s:composeAxisAccelerationFromThrottle(pd,axisCommandId.longitudinal)local pg=oL(axisCommandId.lateral,LeftAmount*1000)pa=pa..' , '.."lateral airfoil , lateral ground "pb=pb+pg;if pb:len()>constants.epsilon then a:setEngineForceCommand(pa,pb,p5,'','','',p6)end;a:setEngineForceCommand(pd,pf,p4)local ph='thrust analog vertical fueled 'local pi='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then pi=pi..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then ph=ph..ExtraVerticalTags end;if af~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then a:setEngineForceCommand(ph,pc,p4)else a:setEngineForceCommand(ph,vec3(),p4)end;if LeftAmount~=0 then a:setEngineForceCommand(pi,pg,p4)else a:setEngineForceCommand(pi,vec3(),p4)end;if oS==0 then oS=L end;local pj=-oS*(brakeSpeedFactor*br+brakeFlatFactor*oW)a:setEngineForceCommand('brake',pj)else if AtmoSpeedAssist then s:setThrottleCommand(axisCommandId.longitudinal,K)end;local m3=unit.getAxisCommandValue(0)if not bA then if brakePID==nil then brakePID=pid.new(1*0.01,0,1*0.1)end;brakePID:inject(br:len()-m3/3.6)local p9=r(brakePID:get(),0,1)oS=r(oS+p9,0,1)end;local pj=-oS*(brakeSpeedFactor*br+brakeFlatFactor*oW)a:setEngineForceCommand('brake',pj)local pa=''local pb=vec3()local pk=false;local pd='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then pd=pd..ExtraLongitudeTags end;local pe=s:getAxisCommandType(axisCommandId.longitudinal)if pe==axisCommandType.byThrottle then local pf=s:composeAxisAccelerationFromThrottle(pd,axisCommandId.longitudinal)a:setEngineForceCommand(pd,pf,p4)elseif pe==axisCommandType.byTargetSpeed then local pf=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)pa=pa..' , '..pd;pb=pb+pf;if s:getTargetSpeed(axisCommandId.longitudinal)==0 or s:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-s:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then pk=true end end;local pi='thrust analog lateral 'if UseExtra=="All"or UseExtra=="Lateral"then pi=pi..ExtraLateralTags end;local pl=s:getAxisCommandType(axisCommandId.lateral)if pl==axisCommandType.byThrottle then local pm=s:composeAxisAccelerationFromThrottle(pi,axisCommandId.lateral)a:setEngineForceCommand(pi,pm,p4)elseif pl==axisCommandType.byTargetSpeed then local pg=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)pa=pa..' , '..pi;pb=pb+pg end;local ph='thrust analog vertical 'if UseExtra=="All"or UseExtra=="Vertical"then ph=ph..ExtraVerticalTags end;local pn=s:getAxisCommandType(axisCommandId.vertical)if pn==axisCommandType.byThrottle then local pc=s:composeAxisAccelerationFromThrottle(ph,axisCommandId.vertical)if af~=0 or BrakeLanding and BrakeIsOn then a:setEngineForceCommand(ph,pc,p4,'airfoil','ground','',p6)else a:setEngineForceCommand(ph,vec3(),p4)a:setEngineForceCommand('airfoil vertical',pc,p4,'airfoil','','',p6)a:setEngineForceCommand('ground vertical',pc,p4,'ground','','',p6)end elseif pn==axisCommandType.byTargetSpeed then if af<0 then a:setEngineForceCommand('hover',vec3(),p4)end;local po=s:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)pa=pa..' , '..ph;pb=pb+po end;if pb:len()>constants.epsilon then if Y~=0 or pk or d(oW:dot(bo))<0.5 then pa=pa..', brake'end;a:setEngineForceCommand(pa,pb,p5,'','','',p6)end end;local pp=torqueFactor*(o_-oZ)local pq=vec3(core.getWorldAirFrictionAngularAcceleration())pp=pp-pq;a:setEngineTorqueCommand('torque',pp,p4,'airfoil','','',p6)a:setBoosterCommand('rocket_engine')if a7 and not VanillaRockets then local eE=bq:len()local pr=0.15;if not bA then local ps=s:getTargetSpeed(axisCommandId.longitudinal)if eE*3.6>ps*(1-pr)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eE*3.6<ps*(1-pr)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local lU=unit.getThrottle()if AtmoSpeedAssist then lU=K*100 end;local m3=lU/100;if k==0 then m3=m3*MaxGameVelocity;if eE>=m3*(1-pr)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eE<m3*(1-pr)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end else local me=e(b7)m3=m3*me/3.6;if eE>=m3*(1-pr)and IsRocketOn then IsRocketOn=false;a:toggleBoosters()elseif eE<m3*(1-pr)and not IsRocketOn then IsRocketOn=true;a:toggleBoosters()end end end end end;function script.onUpdate()if not SetupComplete then local gd=coroutine.status(beginSetup)if gd=="suspended"then local co,ge=coroutine.resume(beginSetup)if ge then system.print("ERROR STARTUP: "..ge)end elseif gd=="dead"then SetupComplete=true end end;if SetupComplete then a:update()if not aZ and content~=LastContent then system.setScreen(content)end;LastContent=content end end;function script.onActionStart(pt)local function pu(bW)local D=1;local function pv(pw,bW)local px={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local py=pw;for _,cR in ipairs(px)do if bW and py>cR then pw=cR elseif pw<cR and not bW then pw=cR;break end end;return pw end;if bW then D=-1 end;if not ExternalAGG and by then if a1 and bW then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a4;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+D*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if a1 then bg=pv(bg,bW)else bg=bg+D*a3 end;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else if a1 and aq then HoldAltitude=pv(HoldAltitude,bW)else HoldAltitude=HoldAltitude+D*a3 end end else s:updateTargetGroundAltitudeFromActionStart(D*1.0)end end;local function pz(pA)if not aq then a2="Flight Assist in Atmo only"return end;local cX=type(pA)if bK==nil then if cX=="table"then if Autopilot or VectorToTarget then cC()end;c4("180On","BR")elseif pA==1 then c4("bnkLft","BR")else c4("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then cz()if cX~="table"then pA=pA+1 end end;bK=pA else c4("180Off","BR")bK=nil end end;if pt=="gear"then GearExtended=not GearExtended;if GearExtended then VectorToTarget=false;LockPitch=nil;cn(0)if vBooster or hover then if aq and ao==-1 then c4("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;AltitudeHold=false;BrakeLanding=true;b0=true;GearExtended=false else if S then c4("grOut","LG",1)a.control.extendLandingGears()end;s:setTargetGroundAltitude(LandingGearGroundHeight)if aq then BrakeIsOn=true end end end;if S and not BrakeLanding and not(vBooster or hover)then c4("grOut","LG",1)a.control.extendLandingGears()end else if S then c4("grIn","LG",1)a.control.retractLandingGears()end;s:setTargetGroundAltitude(TargetHoverHeight)end elseif pt=="light"then if a.control.isAnyHeadlightSwitchedOn()==1 then a.control.switchOffHeadlights()else a.control.switchOnHeadlights()end elseif pt=="forward"then T=T-1 elseif pt=="backward"then if AltIsOn then pz(-br*5000)else T=T+1 end elseif pt=="left"then if AltIsOn then pz(1)else W=W-1 end elseif pt=="right"then if AltIsOn then pz(3)else W=W+1 end elseif pt=="yawright"then X=X-1 elseif pt=="yawleft"then X=X+1 elseif pt=="straferight"then s:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif pt=="strafeleft"then s:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif pt=="up"then af=af+1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,1.0)elseif pt=="down"then af=af-1;s:deactivateGroundEngineAltitudeStabilization()s:updateCommandFromActionStart(axisCommandId.vertical,-1.0)elseif pt=="groundaltitudeup"then pu()elseif pt=="groundaltitudedown"then pu(true)elseif pt=="option1"then toggleView=false;if AltIsOn and a1 then local pB=""for i=1,#passengers do pB=pB.."| Name: "..system.getPlayerName(passengers[i]).." Mass: "..A(core.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;system.print("Onboard: "..pB)return end;aW.adjustAutopilotTargetIndex()elseif pt=="option2"then toggleView=false;if AltIsOn and a1 then for i=1,#passengers do core.forceDeboard(passengers[i])end;a2="Deboarded All Passengers"return end;aW.adjustAutopilotTargetIndex(1)elseif pt=="option3"then local function pC()aE=not aE;if not aE then c4("wid","DH")unit.show()core.show()if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank,atmofueltank_size,L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"),"fuel_container")fuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank,spacefueltank_size,L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"),"fuel_container")spacefuelPanelID=_autoconf.panels[_autoconf.panels_size]end;if rocketfueltank_size>0 then _autoconf.displayCategoryPanel(rocketfueltank,rocketfueltank_size,L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"),"fuel_container")rocketfuelPanelID=_autoconf.panels[_autoconf.panels_size]end;parentingPanelId=system.createWidgetPanel("Docking")parentingWidgetId=system.createWidget(parentingPanelId,"parenting")system.addDataToWidget(unit.getDataId(),parentingWidgetId)coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)if shield_1~=nil then shield_1.show()end else c4("hud","DH")unit.hide()core.hide()if fuelPanelID~=nil then t(fuelPanelID)fuelPanelID=nil end;if parentingPanelId~=nil then t(parentingPanelId)parentingPanelId=nil end;if coreCombatStressPanelId~=nil then t(coreCombatStressPanelId)coreCombatStressPanelId=nil end;if spacefuelPanelID~=nil then t(spacefuelPanelID)spacefuelPanelID=nil end;if rocketfuelPanelID~=nil then t(rocketfuelPanelID)rocketfuelPanelID=nil end;if shield_1~=nil then shield_1.hide()end end end;if AltIsOn and a1 then local pB=""for i=1,#ships do pB=pB.."| ID: "..ships[i].." Mass: "..A(core.getDockedConstructMass(ships[i])/1000,1).."t "end;system.print("Docked Ships: "..pB)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end;pC()toggleView=false elseif pt=="option4"then toggleView=false;if AltIsOn and a1 then for i=1,#ships do core.forceUndock(ships[i])end;a2="Undocked all ships"return end;bK=nil;cC()elseif pt=="option5"then toggleView=false;if AltIsOn and a1 then if shield_1 then shield_1.toggle()return else a2="No shield found"return end end;function ToggleLockPitch()if LockPitch==nil then c4("lkPOn","LP")if not a1 then LockPitch=bB else LockPitch=LockPitchTarget end;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else c4("lkPOff","LP")LockPitch=nil end end;ToggleLockPitch()elseif pt=="option6"then toggleView=false;if AltIsOn and a1 then if shield_1 then local pD=shield_1.getVentingCooldown()if pD>0 then a2="Cannot vent again for "..pD.." seconds"return end;if shield_1.getShieldHitpoints()<shield_1.getMaxShieldHitpoints()then shield_1.startVenting()a2="Shields Venting Enabled - NO SHIELDS WHILE VENTING"else a2="Shields already at max hitpoints"end;return else a2="No shield found"return end end;cz()elseif pt=="option7"then CollisionSystem=not CollisionSystem;if CollisionSystem then a2="Collision System Enabled"else a2="Collision System Secured"end;toggleView=false elseif pt=="option8"then stablized=not stablized;if not stablized then a2="DeCoupled Mode - Ground Stabilization off"s:deactivateGroundEngineAltitudeStabilization()c4("gsOff","GS")else a2="Coupled Mode - Ground Stabilization on"s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)c4("gsOn","GS")end;toggleView=false elseif pt=="option9"then if AltIsOn and a1 then s:resetCommand(axisCommandId.longitudinal)s:resetCommand(axisCommandId.lateral)s:resetCommand(axisCommandId.vertical)cn(0)unit.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()ax=gyro.getState()==1;if ax then c4("gyOn","GA")else c4("gyOff","GA")end end;toggleView=false elseif pt=="lshift"then bR=false;if AltIsOn then a1=true end;if x()==1 then a1=true;PrevViewLock=x()w(1)elseif m()==1 and ShiftShowsRemoteButtons then a1=true;a_=false;aZ=false end elseif pt=="brake"then if BrakeToggleStatus or AltIsOn then cE()elseif not BrakeIsOn then cE()else BrakeIsOn=true end elseif pt=="lalt"then toggleView=true;AltIsOn=true;if m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(1)end elseif pt=="booster"then if VanillaRockets then a:toggleBoosters()elseif not a7 then if not IsRocketOn then a:toggleBoosters()IsRocketOn=true end;a7=true else if IsRocketOn then a:toggleBoosters()IsRocketOn=false end;a7=false end elseif pt=="stopengines"then local function pE()if E-F<1.5 then c4("clear","CA")AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;bK=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;BrakeIsOn=false;AutoTakeoff=false;VertTakeOff=false;a0=false;P=false;al=false;am=false;R=false;b0=autoRollPreference;VectorToTarget=false;TurnBurn=false;ax=false;LockPitch=nil;IntoOrbit=false end end;pE()F=E;if s:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if K~=0 then s:resetCommand(axisCommandId.longitudinal)cn(0)else cn(100)end else if s:getTargetSpeed(axisCommandId.longitudinal)~=0 then s:resetCommand(axisCommandId.longitudinal)else if aq then cq(AtmoSpeedLimit)else cq(MaxGameVelocity*3.6)end end end elseif pt=="speedup"then bV()elseif pt=="speeddown"then bV(true)elseif pt=="antigravity"and not ExternalAGG then if antigrav~=nil then cG()end end end;function script.onActionStop(pt)local function pF()if not ExternalAGG and by then a6=a4 end;if AltitudeHold or VertTakeOff or IntoOrbit then a5=a3 end end;if pt=="forward"then T=0 elseif pt=="backward"then T=0 elseif pt=="left"then if bK then if bK==2 then bK=-2 else bK=-1 end end;W=0 elseif pt=="right"then if bK then if bK==4 then bK=-2 else bK=-1 end end;W=0 elseif pt=="yawright"then X=0 elseif pt=="yawleft"then X=0 elseif pt=="straferight"then s:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif pt=="strafeleft"then s:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif pt=="up"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,-1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pt=="down"then af=0;s:updateCommandFromActionStop(axisCommandId.vertical,1.0)if stablized then s:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)a:setEngineForceCommand('hover',vec3(),1)end elseif pt=="groundaltitudeup"then pF()toggleView=false elseif pt=="groundaltitudedown"then pF()toggleView=false elseif pt=="lshift"then if x()==1 then ag=0;ah=0;w(PrevViewLock)elseif m()==1 and ShiftShowsRemoteButtons then a_=false;aZ=false end;a1=false elseif pt=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then cE()else BrakeIsOn=false end end elseif pt=="lalt"then if m()==0 and freeLookToggle then if toggleView then if x()==1 then w(0)else w(1)end else toggleView=true end elseif m()==0 and not freeLookToggle and userControlScheme=="keyboard"then w(0)end;AltIsOn=false end end;function script.onActionLoop(pt)local function pG(bW)local D=1;if bW then D=-1 end;if not ExternalAGG and by then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+D*a6;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;a6=r(a6*1.05,a4,50)BrakeIsOn=false else AntigravTargetAltitude=desiredBaseAltitude+D*100;BrakeIsOn=false end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then bg=bg+D*a5;if bg<planet.noAtmosphericDensityAltitude then bg=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+D*a5 end;a5=r(a5*1.05,a3,50)else s:updateTargetGroundAltitudeFromActionLoop(D*1.0)end end;local function pH(bW)local D=1;if bW then D=-1 end;if not a1 then if AtmoSpeedAssist and not AltIsOn then K=r(K+D*speedChangeSmall/100,-1,1)else s:updateCommandFromActionLoop(axisCommandId.longitudinal,D*speedChangeSmall)end end end;if pt=="groundaltitudeup"then if not a1 then pG()end elseif pt=="groundaltitudedown"then if not a1 then pG(true)end elseif pt=="speedup"then pH()elseif pt=="speeddown"then pH(true)end end;function script.onInputText(ck)local function pI(pJ,eI,hP)local function pK(eI)local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d4='::pos{'..B..','..B..','..B..','..B..','..B..'}'local dh,di,dp,dq,dr=o(eI,d4)if dh=="0"and di=="0"then return vec3(z(dp),z(dq),z(dr))end;dq=math.rad(dq)dp=math.rad(dp)local planet=b[z(dh)][z(di)]local e9=math.cos(dp)local pL=vec3(e9*math.cos(dq),e9*math.sin(dq),math.sin(dp))return planet.center+(planet.radius+dr)*pL end;local position=pK(eI)return aW.AddNewLocation(pJ,position,hP)end;local i;local pM,pN=nil,nil;local pO="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute".."/deletewp - Deletes current selected custom wp"i=string.find(ck," ")pM=ck;if i~=nil then pM=string.sub(ck,0,i-1)pN=string.sub(ck,i+1)end;if pM=="/help"or pM=="/commands"then for kc in string.gmatch(pO,"([^\n]+)")do system.print(kc)end;return elseif pM=="/setname"then if pN==nil or pN==""then a2="Usage: ah-setname Newname"return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then aW.UpdatePosition(pN)else a2="Select a saved target to rename first"end elseif shield_1 and pM=="/resist"then if pN==nil or shield_1.getResistancesCooldown()>0 then a2="Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15"return end;local B=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local d4=B..', '..B..', '..B..', '..B;local pP,pQ,pR,pS=o(pN,d4)if pS==nil or pP+pQ+pR+pS>0.6 then a2="Improperly formatted or total exceeds 0.6"return end;if shield_1.setResistances(pP,pQ,pR,pS)==1 then a2="Shield Resistances set"else a2="Resistance setting failed."end elseif pM=="/addlocation"or string.find(ck,"::pos")~=nil then local hP=false;local pJ="0-Temp"if pN==nil or pN==""then pN=pM;hP=true end;i=string.find(pN,"::")if not hP then pJ=string.sub(pN,1,i-2)end;local eI=string.sub(pN,i)pI(pJ,eI,hP)elseif pM=="/agg"then if pN==nil or pN==""then a2="Usage: /agg targetheight"return end;pN=z(pN)if pN<1000 then pN=1000 end;AntigravTargetAltitude=pN;a2="AGG Target Height set to "..pN elseif pM=="/G"then if pN==nil or pN==""then a2="Usage: /G VariableName variablevalue\n/G dump - shows all variables"return end;if pN=="dump"then for cQ,cR in pairs(ca())do if type(_G[cR])=="boolean"then if _G[cR]==true then system.print(cR.." true")else system.print(cR.." false")end elseif _G[cR]==nil then system.print(cR.." nil")else system.print(cR.." ".._G[cR])end end;return end;i=string.find(pN," ")local pT=string.sub(pN,0,i-1)local pU=string.sub(pN,i+1)for cQ,cR in pairs(ca())do if cR==pT then a2="Variable "..pT.." changed to "..pU;local pV=type(_G[cR])if pV=="number"then pU=z(pU)if cR=="AtmoSpeedLimit"then b7=pU end elseif pV=="boolean"then if string.lower(pU)=="true"then pU=true else pU=false end end;_G[cR]=pU;return end end;a2="No such global variable: "..pT elseif pM=="/deletewp"then if autopilotTargetIndex>0 and CustomTarget~=nil then aW.ClearCurrentPosition()else a2="Select a custom wp to delete first in IPH"end elseif pM=="/copydatabank"then if dbHud_2 then cM(true)else a2="Spare Databank required to copy databank"end elseif pM=="/iphWP"then if AutopilotTargetIndex>0 then system.print(aX.showWayPoint(ac,AutopilotTargetCoords,true))a2="::pos waypoint shown in lua chat"else a2="No target selected in IPH"end end end;function script.onEnter(di)if bP[1]and not aq and not bH then unit.setTimer("contact",0.1)end end;function script.onLeave(di)if bP[1]and CollisionSystem then if#bL>650 then di=tostring(di)bL[di]=nil end end end;script.onStart()
        
        
        -- error handling code added by wrap.lua
        end, __wrap_lua__traceback)
        if not ok then
          __wrap_lua__error(message)
          if not script then script = {} end
        end
    stop:
      lua: |
        if not __wrap_lua__stopped and script.onStop then
          local ok, message = xpcall(script.onStop,__wrap_lua__traceback,unit)
          if not ok then __wrap_lua__error(message) end
        end
    tick(timerId):
      lua: |
        if not __wrap_lua__stopped and script.onTick then
          local ok, message = xpcall(script.onTick,__wrap_lua__traceback,timerId,unit)
          if not ok then __wrap_lua__error(message) end
        end
  system:
    actionStart(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStart then
          local ok, message = xpcall(script.onActionStart,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionStop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionStop then
          local ok, message = xpcall(script.onActionStop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    actionLoop(action):
      lua: |
        if not __wrap_lua__stopped and script.onActionLoop then
          local ok, message = xpcall(script.onActionLoop,__wrap_lua__traceback,action,system)
          if not ok then __wrap_lua__error(message) end
        end
    update:
      lua: |
        if not __wrap_lua__stopped and script.onUpdate then
          local ok, message = xpcall(script.onUpdate,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    flush:
      lua: |
        if not __wrap_lua__stopped and script.onFlush then
          local ok, message = xpcall(script.onFlush,__wrap_lua__traceback,system)
          if not ok then __wrap_lua__error(message) end
        end
    inputText(text):
      lua: |
        if not __wrap_lua__stopped and script.onInputText then
          local ok, message = xpcall(script.onInputText,__wrap_lua__traceback,text,system)
          if not ok then __wrap_lua__error(message) end
        end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_1
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_2
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_3:
    enter(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_3
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_4:
    enter(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_4
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_5:
    enter(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_5
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_6:
    enter(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_6
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_7:
    enter(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_7
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_8:
    enter(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_8
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_9:
    enter(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_9
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
  radar_10:
    enter(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onEnter then
          local ok, message = xpcall(script.onEnter,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
    leave(id):
      lua: |
        local radar = radar_10
        if not __wrap_lua__stopped and script.onLeave then
          local ok, message = xpcall(script.onLeave,__wrap_lua__traceback,id,radar)
          if not ok then __wrap_lua__error(message) end
        end
