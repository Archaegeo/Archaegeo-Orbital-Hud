{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"databank","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"local sqrt, len, max, print = math.sqrt, string.len, math.max, system.print\n\nfreelook = false --export: Enable freelook in first person mode.\naltHold = false --export: Enable alt-holding to freelook, otherwise it is toggle\naltstate = true\nlocal loadWaypoints = true --export: Enable to load waypoints from Archaegeo's HUD's DB.\nlocal displayWarpCells = true --export: To display warp cells or not.\nlocal archHudWaypointSize = 0.01 --export: The size in meters of an ArchHud waypoint\nlocal archHudWPRender = 400 --export: The size in kilometers at which point ArchHud Waypoints do not render.\nlocal maxWaypointSize = 800 --export: The Max Size of a waypoint in pixels.\nlocal minWaypointSize = 15 --export: The min size of a waypoint in pixels.\nlocal infoHighlight = 200 --export: The number of pixels within info is displayed.\nfontsize = 20 --export: font size\ncolorWarp = \"#ADD8E6\" --export: Colour of warpable waypoints\nnonWarp = \"#FFA500\" --export: Colour of non-warpable waypoints\n\nwaypoint = false\nlocal waypointInfo = {\n  {name = \"Madis\", center = {17465536,22665536,-34464}, radius=44300},\n  {name = \"Alioth\", center = {-8,-8,-126303}, radius=126068},\n  {name = \"Thades\", center = {29165536,10865536,65536}, radius=49000},\n  {name = \"Talemai\", center = {-13234464,55765536,465536}, radius=57450},\n  {name = \"Feli\", center = {-43534464,22565536,-48934464}, radius=60000},\n  {name = \"Sicari\", center = {52765536,27165538,52065535}, radius=51100},\n  {name = \"Sinnen\", center = {58665538,29665535,58165535}, radius=54950},\n  {name = \"Teoma\", center = {80865538,54665536,-934463.94}, radius=62000},\n  {name = \"Jago\", center = {-94134462,12765534,-3634464}, radius=61590},\n  {name = \"Lacobus\", center = {98865536,-13534464,-934461.99}, radius=55650},\n  {name = \"Symeon\", center = {14165536,-85634465,-934464.3}, radius=49050},\n  {name = \"Symeon\", center = {14165536,-85634465,-934464.3}, radius=49050},\n  {name = \"ME\", center ={2515342.2058,-99129540.3141,-1117557.9816}, radius=archHudWaypointSize},\n  {name = \"Ion\", center = {2865536.7,-99034464,-934462.02}, radius=44950}\n}\n\nlocal function bTW(bool)\n    if bool then\n        return \"enabled\"\n    else\n        return \"disabled\"\n    end\nend\n\nprint(\"=======================\")\nprint(\"DU AR Waypoint System\")\nprint(\"=======================\")\nprint(\"Concept: Archaegeo\")\nprint(\"Coder  : EasternGamer\")\nprint(\"=======================\")\nprint(\"Settings\")\nprint(\"=======================\")\nprint(\"Freelook        : \" .. bTW(freelook))\nprint(\"Disp. Warp Cells: \" .. bTW(displayWarpCells))\nprint(\"Load saved WP   : \" .. bTW(loadWaypoints))\nprint(\"Font Size       : \" .. fontsize .. \"px\")\nprint(\"Max WP Render   : \" .. archHudWPRender .. \"km\")\nprint(\"Max WP Size     : \" .. maxWaypointSize .. \"px\")\nprint(\"Min WP Size     : \" .. minWaypointSize .. \"px\")\nprint(\"ArchHUD WP Size : \" .. archHudWaypointSize .. \"m\")\nprint(\"Info HL Distance: \" .. infoHighlight .. \"px\")\nprint(\"=======================\")\n\nif loadWaypoints then\n    if databank ~= nil then\n        local getString = databank.getStringValue\n        if getString ~= nil then\n            local dbInfo = json.decode(getString(\"SavedLocations\"))\n            if dbInfo ~= nil then\n                local size = #waypointInfo\n                local dbInfoSize = #dbInfo\n                local c = 0\n                print(\"Found \" .. dbInfoSize .. \" waypoints in databank.\")\n                for i=1, #dbInfo do\n                    local dbEntry = dbInfo[i]\n                    local pos=dbEntry.position\n                    waypointInfo[size+c+1] = {name=dbEntry.name, center={pos.x, pos.y, pos.z}, radius=archHudWaypointSize}\n                    c=c+1\n                end\n                print(\"Loaded \" .. c .. \" waypoints.\")\n            else\n                print('ERROR! No data to read.')\n            end\n        else\n            print('ERROR! Incorrect slot used for databank.')\n        end\n    else\n        print(\"ERROR! No slot connected to databank slot.\")\n    end\nend\n\nlocal position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal orientation = {0,0,0}\nlocal width = system.getScreenWidth() / 2\nlocal height = system.getScreenHeight() / 2\nlocal objectBuilder = ObjectBuilderLinear()\n\ncamera = Camera(cameraTypes.player.construct, {0,0,0}, {0,0,0})\n\ncamera.setViewLock(not freelook)\nprojector = Projector(camera)\n\nwaypoints = {}\n\nlocal warp = ObjectGroup(\"Warp\")\nlocal notwarp = ObjectGroup(\"NotWarp\")\nprojector.addObjectGroup(warp)\nprojector.addObjectGroup(notwarp)\n\nlocal function drawText(svg, c, x, y, text, opacity)\n    svg[c] = '<text x=\"'\n    svg[c+1] = x\n    svg[c+2] = '\" y=\"'\n    svg[c+3] = y\n    svg[c+4] = '\" fill-opacity=\"'\n    svg[c+5] = opacity\n    svg[c+6] = '\" stroke-opacity=\"'\n    svg[c+7] = opacity\n    svg[c+8] = '\">'\n    svg[c+9] = text\n    svg[c+10] = '</text>'\n    return c+11\nend\nlocal function drawHorizontalLine(svg, c, x, y, length, thickness)\n    svg[c] = '<path fill=\"none\" stroke-width=\"'\n    svg[c+1] = thickness\n    svg[c+2] = '\" d=\"M'\n    svg[c+3] = x\n    svg[c+4] = ' '\n    svg[c+5] = y\n    svg[c+6] = ' h '\n    svg[c+7] = length\n    svg[c+8] = '\"/>'\n    return c+9\nend\nlocal maxD = sqrt(width*width + height*height)\nlocal function drawInfo(svg, c, tx, ty, data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local font = fontsize\n    local name,distance,warpCost,disKM,disM = data.getWaypointInfo()\n    local keyframe = data.keyframe\n\n    if distance > 500 then\n        local id = data.subId\n        local d = notwarp.addObject(waypoints[id][2], id)\n        warp.removeObject(id)\n    else\n        local id = data.subId\n        warp.addObject(waypoints[id][2], id)\n        notwarp.removeObject(id)\n    end\n    c = drawHorizontalLine(svg, c, tx, ty + 3, len(name)*(font*0.7), 2)\n    c = drawText(svg, c, tx, ty, name, 1)\n    \n    if distanceToMouse <= infoHighlight then\n        if keyframe < 6 then\n            data.keyframe = keyframe + 1\n        end\n    else\n        if keyframe ~= 0 then\n            data.keyframe = keyframe - 1\n        end\n    end\n    local opacity = keyframe/6\n    if distanceToMouse < 25 and waypoint then\n        system.setWaypoint('::pos{0,0,' .. data.x ..',' .. data.y .. ',' .. data.z ..'}')\n        waypoint = false\n    end\n    if keyframe > 0 then\n        local disText = ''\n        if disM <=1000 then\n            disText = disM .. ' M'\n        elseif disKM <= 200 then\n            disText = disKM .. ' KM'\n        else\n            disText = distance .. ' SU'\n        end\n        c = drawText(svg, c, tx + 60 - keyframe*10, ty+font+5, disText, opacity)\n        if displayWarpCells then\n            c = drawText(svg, c, tx + 60 - keyframe*10, ty+(font+5)*2, warpCost .. ' Warp Cells', opacity)\n        end\n    end\n    return c\nend\nlocal function draw(svg,c,object,tx,ty,tz,data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local r = data.radius\n    local off = (((tz/1000)/200))/100\n    local size = max(projector.getSize(r, tz, 100000000, minWaypointSize) - off, 5)\n    if size >= maxWaypointSize or distanceToMouse > maxD or (r==archHudWaypointSize*1.25 and tz>archHudWPRender*1000) then -- Don't display\n        return c\n    end\n    svg[c] = '<circle cx=\"'\n    svg[c+1] = tx\n    svg[c+2] = '\" cy=\"'\n    svg[c+3] = ty\n    svg[c+4] = '\" r=\"'\n    if r==archHudWaypointSize*1.25 then\n        size = size /2\n        svg[c+5] = size\n        svg[c+6] = '\" fill=\"' .. colorWarp .. '\"/>'\n    else\n        svg[c+5] = size\n        svg[c+6] = '\" fill=\"none\"/>'\n    end\n    c=c+7\n    c=drawInfo(svg, c, tx + size + 5, ty - size + 5, data)\n    return c\nend\n\nfor ii = 1, #waypointInfo do\n    local wDat = waypointInfo[ii]\n    local wCenter = wDat.center\n    local wName = wDat.name\n    local wRadius = wDat.radius\n    local waypoint = objectBuilder\n\t\t\t\t.setStyle(wName)\n\t\t\t\t.setPosition({0,0,0})\n\t\t\t\t.setOffset({0,0,0})\n\t\t\t\t.setOrientation({0,0,0})\n\t\t\t\t.setPositionType(positionTypes.globalP)\n\t\t\t\t.setOrientationType(orientationTypes.globalO)\n\t\t\t\t.build()\n    \n    local subId = warp.addObject(waypoint)\n    local nsubId = notwarp.addObject(waypoint)\n    notwarp.removeObject(nsubId)\n    local waypointObject = Waypoint(wCenter[1],wCenter[2],wCenter[3], wRadius * 1.25, wName, subId)\n    local customSVG = waypoint.setCustomSVGs(1, wName).addSinglePointSVG()\n    waypoints[ii] = {wCenter, waypoint}\n    customSVG.setPosition({wCenter[1], wCenter[2], wCenter[3]})\n    \t    .setData(waypointObject)\n    \t    .setDrawFunction(draw)\n    \t    .build()\nend\n\nunit.setTimer(\"fixed_1\", 1/1000) --The timer to update the camera\nunit.setTimer(\"update\", 1/1000) -- The timer to update the screen\nsystem.showScreen(1)\nunit.hide()","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"local concat = table.concat\nlocal svg, index = projector.getSVG()\n\nlocal width = system.getScreenWidth()\nlocal height = system.getScreenHeight()\nlocal fontsize = fontsize\nsvg[index] = '<style>svg{ width:'\nsvg[index+1] = width\nsvg[index+2] ='px; height:'\nsvg[index+3] =height\nsvg[index+4] ='px; position:absolute; top:0px; left:0px;}.NotWarp{filter: drop-shadow(0 0 0.5rem '\nsvg[index+5] =nonWarp\nsvg[index+6] ='); stroke: '\nsvg[index+7] =nonWarp\nsvg[index+8] ='; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: '\nsvg[index+9] =fontsize\nsvg[index+10] ='px;}.me{filter: drop-shadow(0 0 0.5rem '\nsvg[index+11] ='crimson'\nsvg[index+12] ='); stroke: '\nsvg[index+13] ='crimson'\nsvg[index+14] ='; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: '\nsvg[index+15] =fontsize\nsvg[index+16] ='px;}.Warp{filter: drop-shadow(0 0 0.5rem '\nsvg[index+17] =colorWarp\nsvg[index+18] ='); stroke: '\nsvg[index+19] =colorWarp\nsvg[index+20] ='; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: '\nsvg[index+21] =fontsize\nsvg[index+22] ='px;}</style>'\nlocal rendered = concat(svg)\nsystem.setScreen(rendered)\n--slot3.setHTML(rendered)","filter":{"args":[{"value":"update"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"projector.updateCamera()","filter":{"args":[{"value":"fixed_1"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"waypoint = true","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"3"},{"code":"if not freelook then\n    if altHold then\n        camera.setViewLock(false)\n    else\n        altstate = not altstate\n        camera.setViewLock(altstate)\n    end\nend","filter":{"args":[{"value":"lalt"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"4"},{"code":"if not freelook then\n    if altHold then\n        camera.setViewLock(true)\n    end\n    --system.print('Viewlock: true')\nend","filter":{"args":[{"value":"lalt"}],"signature":"actionStop(action)","slotKey":"-2"},"key":"5"},{"code":"function Projector(camera)\n    local isClicked=false\n    -- Localize frequently accessed data\n    local utils=require('cpml.utils')\n    \n    --local library=library\n    local core,system,manager=core,system,getManager()\n    \n    -- Localize frequently accessed functions\n    --- Library-based function calls\n    --local solve=library.systemResolution3\n    \n    --- System-based function calls\n    local getWidth,getHeight,getFov,getMouseDeltaX,getMouseDeltaY,print=system.getScreenWidth,system.getScreenHeight,system.getFov,system.getMouseDeltaX,system.getMouseDeltaY,system.print\n    \n    --- Core-based function calls\n    local getCWorldR,getCWorldF,getCWorldU,getCWorldPos=core.getConstructWorldRight,core.getConstructWorldForward,core.getConstructWorldUp,core.getConstructWorldPos\n\n    -- Unit-based function calls\n    local getPlayerLocalPos=unit.getMasterPlayerPosition\n    \n    --- Camera-based function calls\n    local getAlignmentType=camera.getAlignmentType\n    \n    --- Manager-based function calls\n    ---- Positional Operations\n    --local getLocalToWorldConverter=manager.getLocalToWorldConverter\n    --local getWorldToLocalConverter=manager.getWorldToLocalConverter\n    local getPlayerLocalRotation=manager.getPlayerLocalRotation\n    ---- Quaternion operations\n    local t3DP,rotToEuler,rotToQuat=manager.transPoint3D,manager.rotMatrixToEuler,manager.rotMatrixToQuat\n    \n    -- Localize Math functions\n    local sin,cos,tan,rad,deg,sqrt,atan,ceil,floor=math.sin,math.cos,math.tan,math.rad,math.deg,math.sqrt,math.atan,math.ceil,math.floor\n    local rnd=utils.round\n    -- Projection infomation\n    --- Screen Parameters\n    local width,height=getWidth()*0.5,getHeight()*0.5\n\n    --- FOV Paramters\n    \n    --local offset = (width + height) / 5000\n    --local offset=0\n    local hfovRad=rad(getFov())\n    local tanFov=tan(hfovRad*0.5)*height/width\n\n    --- Matrix Subprocessing\n    local aspect,near,far=width/height,width/tanFov,10000\n    local top=near*tanFov\n    local bottom=-top\n    local left,right=bottom*aspect,top*aspect\n\n    --- Matrix Paramters\n    local x0,y0=2*near/(right-left),2*near/(top-bottom)\n    \n    -- Player-related values\n    --local playerId=unit.getMasterPlayerId()\n    --local unitId=unit.getId()\n    \n    -- Camera-Related values\n    local eye=camera.position\n    local cOrientation=camera.orientation\n    local cameraType=camera.cType\n    local alignmentType=nil\n    \n    --- Mouse info\n    local sensitivity=1 --export: Sensitivtiy\n    local m=sensitivity*(width*2)*0.00104584100642898+0.00222458611638299\n\n    local topLock,bottomLock,rightLock,leftLock=false,false,false,false\n\n    local objectGroups={}\n    \n    local self={objectGroups=objectGroups}\n\n    function self.getSize(size,zDepth,max,min)\n        local pSize=atan(size,zDepth)*(near/aspect)\n        local max=max or pSize\n        local min=min or pSize\n        if pSize>=max then return max\n        elseif pSize<=min then return min\n        else return pSize end\n    end\n    \n    local function matrixToQuat(m11,m21,m31,m12,m22,m32,m13,m23,m33)\n        local t=m11+m22+m33\n        if t>0 then\n            local s=0.5/sqrt(t+1)\n            return (m32-m23)*s,(m13-m31)*s,(m21-m12)*s,0.25/s\n        elseif m11>m22 and m11>m33 then\n            local s = 2*sqrt(1+m11-m22-m33)\n            return 0.25*s,(m12+m21)/s,(m13+m31)/s,(m32-m23)/s\n        elseif m22>m33 then\n            local s=2*sqrt(1+m22-m11-m33)\n            return (m12+m21)/s,0.25*s,(m23+m32)/s,(m13-m31)/s\n        else\n            local s=2*sqrt(1+m33-m11- m22)\n            return (m13+m31)/s,(m23+m32)/s,0.25*s,(m21-m12)/s\n        end\n    end\n    \n    function self.updateCamera()\n        if cameraType.name~=\"fGlobal\" and cameraType.name~=\"fLocal\" then\n            -- Localize variables\n            local atan=atan\n            isClicked=clicked\n            clicked=false\n            eye=getPlayerLocalPos()\n            \n            local deltaMouseX,deltaMouseY=getMouseDeltaX(),getMouseDeltaY()\n            local width=width\n            local deltaPitch=atan(-deltaMouseY,width)*m\n            local deltaHeading=atan(deltaMouseX,width)*m\n        \n            local pPitch=cOrientation[1]\n            local pHeading=cOrientation[2]\n            \n            local alignType=alignmentType\n            if alignType==nil then alignType=getAlignmentType() end\n            \n            local pitPos,pitNeg=alignType.pitchPos,alignType.pitchNeg\n            local headPos,headNeg=alignType.headingPos,alignType.headingNeg\n            \n            if pitPos~=nil then\n                if not(bottomLock or topLock) then  \n                    pPitch=pPitch+deltaPitch\n                    if pPitch<=pitNeg then\n                        pPitch=pitNeg\n                        bottomLock=true\n                    end\n                    if pPitch>=pitPos then\n                        pPitch=pitPos\n                        topLock=true\n                    end\n                else\n                    if bottomLock and deltaMouseY<0 then\n                        bottomLock=false\n                        pPitch=pPitch+deltaPitch\n                    end\n                    if topLock and deltaMouseY>0 then\n                        topLock=false\n                        pPitch=pPitch+deltaPitch\n                    end\n                end\n                cOrientation[1]=pPitch\n            else\n                cOrientation[1]=0\n            end\n            if headPos ~= nil then\n                if not(leftLock or rightLock) then  \n                    pHeading=pHeading+deltaHeading\n                    if pHeading<=headNeg then\n                        pHeading=headNeg\n                        leftLock=true\n                    end\n                    if pHeading>=headPos then\n                        pHeading=headPos\n                        rightLock=true\n                    end\n                else\n                    if rightLock and deltaMouseX<0 then\n                        rightLock=false\n                        pHeading=pHeading+deltaHeading\n                    end\n                    if leftLock and deltaMouseX>0 then\n                        leftLock=false\n                        pHeading=pHeading+deltaHeading\n                    end\n                end\n                cOrientation[2]=pHeading\n            else\n                cOrientation[2]=0\n            end\n        end\n    end\n\n    function self.addObjectGroup(objectGroup, id)\n        local index=id or #objectGroups+1\n        objectGroups[index]=objectGroup\n        return index\n    end\n\n    function self.removeObjectGroup(id)\n    \tobjectGroups[id]={}\n    end\n    \n    local cUX,cUY,cUZ,cFX,cFY,cFZ,cRX,cRY,cRZ,sx,sy,sz,sw = nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil\n    \n    function self.getModelMatrices(mObject)\n        local s,c=sin,cos\n        local modelMatrices={}\n            \n        -- Localize Object values.\n        local objOri,objPos=mObject[10],mObject[12]\n        local objPosX,objPosY,objPosZ=objPos[1],objPos[2],objPos[3]\n        \n        local cRX,cRY,cRZ,cFX,cFY,cFZ,cUX,cUY,cUZ,sx,sy,sz,sw=cRX,cRY,cRZ,cFX,cFY,cFZ,cUX,cUY,cUZ,-sx,-sy,-sz,sw\n        \n        local ct=2\n        local function subObjectMatrices(kx,ky,kz,kw,sObjX,sObjY,sObjZ,object,posLX,posLY,posLZ)\n            local kx,ky,kz,kw=kx,ky,kz,-kw\n            local objPos,objRot=object[12],object[10]\n            local objX,objY,objZ=objPos[1],objPos[2],objPos[3]\n            \n            local objP,objH,objR=objRot[1]*0.5,objRot[2]*0.5,objRot[3]*0.5\n            local sP,sH,sR=s(objP),s(objR),s(objH)\n            local cP,cH,cR=c(objP),c(objR),c(objH)\n    \n            local wwx,wwy,wwz,www=sP*cH*cR-cP*sH*sR,cP*sH*cR+sP*cH*sR,cP*cH*sR-sP*sH*cR,cP*cH*cR+sP*sH*sR\n            local wx,wy,wz,ww=wwx,wwy,wwz,www\n\n            local posIX,posIY,posIZ=t3DP(kx,ky,kz,kw,objX,objY,objZ)\n\t\t\t\n            if object[9]==2 then\n                local mx,my,mz,mw=wx*sw+ww*sx+wy*sz-wz*sy, wy*sw+ww*sy+wz*sx-wx*sz, wz*sw+ww*sz+wx*sy-wy*sx, ww*sw-wx*sx-wy*sy-wz*sz\n\t\t\t\twx,wy,wz,ww=mx, my, mz, mw\n            end\n\t\t\t\n\t\t\tlocal matrix = {\n                    1-2*(wywy+wzwz),2*(wx*wy+wz*ww),2*(wx*wz-wy*ww),0,\n                    2*(wx*wy-wz*ww),1-2*(wxwx+wzwz),2*(wy*wz+wx*ww),0,\n                    2*(wx*wz+wy*ww),2*(wy*wz-wx*ww),1-2*(wxwx+wywy),0\n                }\n\t\t\t\t\n            if object[8]==2 then\n                matrix[4]=cRX*posIX+cFX*posIY+cUX*posIZ+posLX\n                matrix[8]=cRY*posIX+cFY*posIY+cUY*posIZ+posLY\n                matrix[12]=cRZ*posIX+cFZ*posIY+cUZ*posIZ+posLZ\n            end\n            \n            modelMatrices[ct]={object,matrix}\n            ct=ct+1\n            \n            local subObjects=object[7]\n            if #subObjects>0 then\n                for k=1,#subObjects do\n                    local subObj=subObjects[k]\n                    if subObj[12]~=nil then\n                        subObjectMatrices(wwx,wwy,wwz,www,objX,objY,objZ,subObj,matrix[4],matrix[8],matrix[12])\n                    end\n                end\n            end\n        end\n        local pitch,heading,roll=objOri[1]*0.5,objOri[2]*0.5,objOri[3]*0.5\n        \n        --- Quaternion of object rotations\n        local sP,sH,sR=s(pitch),s(roll),s(heading)\n        local cP,cH,cR=c(pitch),c(roll),c(heading)\n    \n        local wwx,wwy,wwz,www=(sP*cH*cR-cP*sH*sR),(cP*sH*cR+sP*cH*sR),(cP*cH*sR-sP*sH*cR),(cP*cH*cR+sP*sH*sR)\n        local wx,wy,wz,ww=wwx,wwy,wwz,www\n        if mObject[9]==2 then\n\t\t\tlocal mx,my,mz,mw=wx*sw+ww*sx+wy*sz-wz*sy, wy*sw+ww*sy+wz*sx-wx*sz, wz*sw+ww*sz+wx*sy-wy*sx, ww*sw-wx*sx-wy*sy-wz*sz\n            wx,wy,wz,ww=mx,my,mz,mw\n        end\n        \n        local wxwx,wywy,wzwz,wwww=wx*wx,wy*wy,wz*wz,ww*ww\n\t\tlocal matrix = {\n\t\t\t\t1-2*(wywy+wzwz),2*(wx*wy+wz*ww),2*(wx*wz-wy*ww),0,\n\t\t\t\t2*(wx*wy-wz*ww),1-2*(wxwx+wzwz),2*(wy*wz+wx*ww),0,\n\t\t\t\t2*(wx*wz+wy*ww),2*(wy*wz-wx*ww),1-2*(wxwx+wywy),0\n\t\t\t}\n        if mObject[8]==2 then\n            matrix[4],matrix[8],matrix[12]=cRX*objPosX+cFX*objPosY+cUX*objPosZ,cRY*objPosX+cFY*objPosY+cUY*objPosZ,cRZ*objPosX+cFZ*objPosY+cUZ*objPosZ\n        else\n            local cWorldPos=getCWorldPos()\n\t\t\tmatrix[4],matrix[8],matrix[12]=objPosX-cWorldPos[1],objPosY-cWorldPos[2],objPosZ-cWorldPos[3]\n        end\n        modelMatrices[1]={mObject,matrix}\n        local subObjs=mObject[7]\n        if #subObjs>0 then\n            for k=1,#subObjs do\n                local subObj=subObjs[k]\n                if subObj[7]~= nil then\n                    subObjectMatrices(wwx,wwy,wwz,www,objPos[1],objPos[2],objPos[3],subObj,matrix[4],matrix[8],matrix[12])\n                end\n            end\n        end\n\n        return modelMatrices\n    end\n\n    local function updateReferentials()\n        local cU,cF,cR = getCWorldU(),getCWorldF(),getCWorldR()\n\n        cRX,cRY,cRZ,cFX,cFY,cFZ,cUX,cUY,cUZ=cR[1],cR[2],cR[3],cF[1],cF[2],cF[3],cU[1],cU[2],cU[3]\n        sx,sy,sz,sw=matrixToQuat(cRX,cRY,cRZ,cFX,cFY,cFZ,cUX,cUY,cUZ)\n    end\n    \n    function self.getViewMatrix()\n        updateReferentials()\n        local s,c=sin,cos\n\n        local eye=eye\n        local eyeX,eyeY,eyeZ=eye[1],eye[2],eye[3]\n\n        local dotX,dotY,dotZ,wx,wy,wz,ww=eyeX,eyeY,eyeZ,0,0,0,1\n        \n        local ax,ay,az,aw=getPlayerLocalRotation()\n        local sx,sy,sz,sw=sx,sy,sz,sw\n        \n        \n        local alignment=getAlignmentType(ax,ay,az,aw,eyeX,eyeY,eyeZ)\n        alignmentType=alignment\n        \n        local shift=alignment.shift\n        local eyeIX,eyeIY,eyeIZ=t3DP(ax,ay,az,aw,shift[1],shift[2],shift[3])\n        \n        local alignName=alignment.name\n        \n        local fG,fL=alignName==\"fGlobal\",alignName==\"fLocal\"\n\n        local pitch,heading=cOrientation[1]*0.5,-cOrientation[2]*0.5\n       \n        if pitch~=0 or heading~=0 or fG or fL then\n            local sP,sR=s(pitch),s(heading)\n            local cP,cR=c(pitch),c(heading)\n            \n            local cx,cy,cz,cw=sP*cR,sP*sR,cP*sR,cP*cR\n            \n            if not fG and not fL then \n\t\t\t\tlocal mx,my,mz,mw=ax*cw+aw*cx+ay*cz-az*cy,ay*cw+aw*cy+az*cx-ax*cz,az*cw+aw*cz+ax*cy-ay*cx,aw*cw-ax*cx-ay*cy-az*cz\n                ax,ay,az,aw=mx,my,mz,mw\n            elseif fG then \n                wx,wy,wz,ww=cx,cy,cz,cw\n            else\n\t\t\t\tlocal mx,my,mz,mw=sx*cw+sw*cx+sy*cz-sz*cy,sy*cw+sw*cy+sz*cx-sx*cz,sz*cw+sw*cz+sx*cy-sy*cx,sw*cw-sx*cx-sy*cy-sz*cz\n                wx,wy,wz,ww=mx,my,mz,mw\n            end\n        end\n\n        if not fG and not fL then\n            local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n            \n            eyeX=eyeX+eyeIX\n            eyeY=eyeY+eyeIY\n            eyeZ=eyeZ+eyeIZ\n        \n            dotX=2*((0.5-ayay-azaz)*eyeX+(ax*ay+az*aw)*eyeY+(ax*az-ay*aw)*eyeZ)\n            dotY=2*((ax*ay-az*aw)*eyeX+(0.5-axax-azaz)*eyeY+(ay*az+ax*aw)*eyeZ)\n            dotZ=2*((ax*az+ay*aw)*eyeX+(ay*az-ax*aw)*eyeY+(0.5-axax-ayay)*eyeZ)\n            \n\t\t\tlocal mx,my,mz,mw=sx*aw+sw*ax+sy*az-sz*ay,sy*aw+sw*ay+sz*ax-sx*az,sz*aw+sw*az+sx*ay-sy*ax,sw*aw-sx*ax-sy*ay-sz*az\n            wx,wy,wz,ww=mx,my,mz,mw\n        end\n        --print(eyeX)\n        eye[1],eye[2],eye[3]=t3DP(sx,sy,sz,sw,eyeX,eyeY,eyeZ)\n        local wxwx,wywy,wzwz,wwww=wx*wx,wy*wy,wz*wz,ww*ww\n        \n        return {\n            1-2*(wywy+wzwz),2*(wx*wy+wz*ww),2*(wx*wz-wy*ww),-dotX,\n            2*(wx*wy-wz*ww),1-2*(wxwx+wzwz),2*(wy*wz+wx*ww),-dotY,\n            2*(wx*wz+wy*ww),2*(wy*wz-wx*ww),1-2*(wxwx+wywy),-dotZ\n        }\n    end\n    \n    function self.getSVG(svg, c)\n        svg=svg or {}\n        c = c or 1\n        local view=self.getViewMatrix()\n        \n        local vx1,vy1,vz1,vw1=view[1],view[2],view[3],view[4]\n        local vx2,vy2,vz2,vw2=view[5],view[6],view[7],view[8]\n        local vx3,vy3,vz3,vw3=view[9],view[10],view[11],view[12]\n        \n        local dert = (vx2 + vy2 + vz2) / (vx2*vx2+vy2*vy2+vz2*vz2)\n        local uDX,uDY,uDZ = vx2*dert,vy2*dert,vz2*dert\n        local nearDivAspect = (near/aspect)\n        local eyeX,eyeY,eyeZ=eye[1],eye[2],eye[3]\n        \n        local getSize,atan,sort,format,unpack,concat,abs,t3DP,getModelMatrices=self.getSize,atan,table.sort,string.format,table.unpack,table.concat,math.abs,t3DP,self.getModelMatrices\n\n        local function zSort(t1,t2)\n            return t1[1]>t2[1]\n        end\n        --local function zSort(t1,t2)\n            --return t1[20]>t2[20]\n        --end\n\n        local function createLabel(svg,c,x,y,text,size,opacity,fill)\n            svg[c]='<text x=\"';svg[c+1]=x;svg[c+2]='\" y=\"';svg[c+3]=y\n            c=c+4\n            if opacity then\n                svg[c]='\" fill-opacity=\"';svg[c+1]=opacity;svg[c+2]='\" stroke-opacity=\"';svg[c+3]=opacity\n                c=c+4\n            end\n            if fill then\n                svg[c]='\" fill=\"';svg[c+1]=fill\n                c=c+2\n            end\n            if size then\n                svg[c]='\" font-size=\"';svg[c+1]=size\n                c=c+2\n            end\n            svg[c]='\">';svg[c+1]=text;svg[c+2]='</text>'\n            return c+3\n        end\n        -- Localize projection matrix values\n        local px1=x0\n        local pz3=y0\n        \n        -- Localize screen info\n        local width=width\n        local height=height\n        local nxB,pxB,nyB,pyB=-width*2,width*2,-height*2,height*2\n        local dptPercision = ((2^32-1)*near)\n        local objectGroups=objectGroups\n        \n        for i = 1, #objectGroups do\n            local objectGroup=objectGroups[i]\n            if objectGroup.enabled==false then goto not_enabled end\n            local objGTransX=objectGroup.transX or width\n            local objGTransY=objectGroup.transY or height\n            local objects=objectGroup.objects\n            \n            svg[c]=format('<svg viewBox=\"0 0 %g %g\" class=\"%s\"><g transform=\"translate(%g,%g)\">',width*2,height*2,objectGroup.style,objGTransX,objGTransY)\n            c=c+1\n            for m=1,#objects do\n                local obj=objects[m]\n                if obj[12]==nil then goto is_nil end\n                local models=getModelMatrices(obj)\n                -- Localize model matrix values\n                for k=1,#models do\n                    local modelObj=models[k]\n                    local object=modelObj[1]\n                    local model=modelObj[2]\n                    \n                    local objStyle=object[11]\n                    local objTransX=object[14] or 0\n                    local objTransY=object[15] or 0\n                    \n                    if objTransX~=0 or objTransY~=0 then\n                        svg[c]=format('<g class=\"%s\" transform=\"translate(%g,%g)\">',objStyle,objTransX,objTransY)\n                    else\n                        svg[c]=format('<g class=\"%s\">',objStyle)\n                    end\n                    c=c+1\n                    \n                    local mx1,my1,mz1,mw1=model[1],model[2],model[3],model[4]\n                    local mx2,my2,mz2,mw2=model[5],model[6],model[7],model[8]\n                    local mx3,my3,mz3,mw3=model[9],model[10],model[11],model[12]\n                \n                    local pxw=px1*width\n                    local mXX,mXY,mXZ,mXW=(vx1*mx1+vy1*mx2+vz1*mx3)*pxw,\n                                          (vx1*my1+vy1*my2+vz1*my3)*pxw,\n                                          (vx1*mz1+vy1*mz2+vz1*mz3)*pxw,\n                                          (vw1+vx1*mw1+vy1*mw2+vz1*mw3)*pxw\n        \n                    local mYX,mYY,mYZ,mYW=(vx2*mx1+vy2*mx2+vz2*mx3),\n                                          (vx2*my1+vy2*my2+vz2*my3),\n                                          (vx2*mz1+vy2*mz2+vz2*mz3),\n                                          (vw2+vx2*mw1+vy2*mw2+vz2*mw3)\n        \n                    local pzw=-pz3*height\n                    local mZX,mZY,mZZ,mZW=(vx3*mx1+vy3*mx2+vz3*mx3)*pzw,\n                                          (vx3*my1+vy3*my2+vz3*my3)*pzw,\n                                          (vx3*mz1+vy3*mz2+vz3*mz3)*pzw,\n                                          (vw3+vx3*mw1+vy3*mw2+vz3*mw3)*pzw\n\n                    \n                    local P0X,P0Y,P0Z=eyeX-mw1,eyeY-mw2,eyeZ-mw3\n                    \n                    local polylineGroups,circleGroups,curvesGroups,customGroups,triangleGroups,uiGroups=object[1],object[2],object[3],object[4],object[5],object[6]\n                    -- Polylines for-loop\n                    for d=1,#polylineGroups do\n                        local polylineGroup = polylineGroups[d]\n                        svg[c]=format('<path class=\"%s\" d=\"%s\"/>', polylineGroup[1])\n                        c=c+1\n                        \n                        for f=2,#polylineGroup do\n                            local line=polylineGroup[f]\n                            svg[c]='M '\n                            local lC=0\n                            local sPX,sPY,ePX,ePY=nil,nil,nil,nil\n                            c=c+1\n                            for h=1,#line do\n                                local p=line[h]\n                                local x,y,z=p[1],p[2],p[3]\n\n                                local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                if pz<0 then goto behindLine end\n\n                                local wx=(mXX*x+mXY*y+mXZ*z+mXW)/pz\n                                local wy=(mZX*x+mZY*y+mZZ*z+mZW)/pz\n                                if lC~=0 then\n                                    svg[c]=' L '\n                                    c=c+1\n                                    ePX,ePY=wx,wy\n                                else\n                                    sPX,sPY=wx,wy\n                                end\n                                svg[c]=wx\n                                svg[c+1]=' '\n                                svg[c+2]=wy\n                                c=c+3\n                                lC=lC+1\n                                ::behindLine::\n                            end\n                            if lC < 2 then\n                                if lC==1 then c=c-4\n                                else c=c-1 end\n                            else\n                                if ePX==sPX and ePY==sPY then\n                                    svg[c-4]=' Z '\n                                    c=c-3\n                                end\n                            end\n                        end\n                        svg[c] = '\"/>'\n                        c=c+1\n                    end\n                    \n                    for cG=1,#circleGroups do\n                        local circleGroup=circleGroups[cG]\n                        svg[c]=format('<g class=\"%s\">', circleGroup[1])\n                        c=c+1\n                        for l=2,#circleGroup do\n                            local cir=circleGroup[l]\n                            local p=cir[1]\n                            local x,y,z=p[1],p[2],p[3]\n                            local pz=mYX*x+mYY*y+mYZ*z+mYW\n                            if pz<0 then goto behindCircle end\n\n                            local wx,wy=(mXX*x+mXY*y+mXZ*z+mXW)/pz,(mZX*x+mZY*y+mZZ*z+mZW)/pz\n                            local radius,fill,label,offX,offY,size,resize,action=cir[2],cir[3],cir[4],cir[5],cir[6],cir[7],cir[8],cir[9]\n                            svg[c]=format('<circle cx=\"%g\" cy=\"%g\" r=\"%g\" fill=\"%s\"/>',wx,wy,radius,fill);\n                            c=c+1\n                            if label then\n                                svg[c]='<text x=\"';\n                                svg[c+1]=wx+offX;\n                                svg[c+2]='\" y=\"';\n                                svg[c+3]=wy+offY\n                                c=c+4\n                                if size then\n                                    if resize==true then\n                                        svg[c]='\" font-size=\"';\n                                        svg[c+1]=getSize(size,wz)\n                                    else\n                                        svg[c]='\" font-size=\"';\n                                        svg[c+1]=size\n                                    end\n                                    c=c+2\n                                end\n                                svg[c]='\">';\n                                svg[c+1]=label;\n                                svg[c+2]='</text>'\n                                c=c+3\n                            end\n                            if action then\n                                c=action(svg,c,object,wx,wy,pz)\n                            end\n                            ::behindCircle::\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    \n                    for cuG=1,#curvesGroups do\n                        \n                        local curveG=curvesGroups[cuG]\n                        local curves=curveG[2]\n                        local sLabelDat={}\n                        local sLDC=0\n\n                        svg[c]=format('<g class=\"%s\"><path d=\"',curveG[1])\n                        c=c+1\n                        for cCt=1,#curves do\n                            local curve=curves[cCt]\n                            if curve[1]==1 then\n                                local pts=curve[2]\n                                local labelDat=curve[3]\n                                local tPts={}\n                                for i=1,12 do\n                                    local p=pts[i]\n                                    local x,y,z=p[1],p[2],p[3]\n                                    local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                    if pz<0 then tPts[i]={0,0,false}; goto continueCurve end\n\n                                    tPts[i]={(mXX*x+mXY*y+mXZ*z+mXW)/pz,(mZX*x+mZY*y+mZZ*z+mZW)/pz,true}\n                                    ::continueCurve::\n                                end\n                                local m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12=tPts[1],tPts[2],tPts[3],tPts[4],tPts[5],tPts[6],tPts[7],tPts[8],tPts[9],tPts[10],tPts[11],tPts[12]\n                                local m1x,m1y,m1z,m2x,m2y,m3x,m3y,m4x,m4y,m4z=m1[1],m1[2],m1[3],m2[1],m2[2],m3[1],m3[2],m4[1],m4[2],m4[3]\n                                if m1[3] and m1[3] and m1[3] and m4z then\n                                    svg[c]=format('M%g %gC%g %g,%g %g,%g %g',m1x,m1y,m2x,m2y,m3x,m3y,m4x,m4y)\n                                    c=c+1\n                                end\n                                local m5x,m5y,m6x,m6y,m7x,m7y,m7z=m5[1],m5[2],m6[1],m6[2],m7[1],m7[2],m7[3]\n                                if m4z and m5[3] and m6[3] and m7z then\n                                    svg[c]=format('M%g %gC%g %g,%g %g,%g %g',m4x,m4y,m5x,m5y,m6x,m6y,m7x,m7y)\n                                    c=c+1\n                                end\n                                local m8x,m8y,m9x,m9y,m10x,m10y,m10z=m8[1],m8[2],m9[1],m9[2],m10[1],m10[2],m10[3]\n                                if m7z and m8[3] and m9[3] and m10z then\n                                    svg[c]=format('M%g %gC%g %g,%g %g,%g %g',m7x,m7y,m8x,m8y,m9x,m9y,m10x,m10y)\n                                    c=c+1\n                                end    \n                                local m11x,m11y,m12x,m12y=m11[1],m11[2],m12[1],m12[2]\n                                if m10z and m11[3] and m12[3] and m1z then\n                                    svg[c]=format('M%g %gC%g %g,%g %g,%g %g',m10x,m10y,m11x,m11y,m12x,m12y,m1x,m1y)\n                                    c=c+1\n                                end\n                                if labelDat[1] then\n                                    if m1z and m4z and m7z and m10z then\n                                        sLabelDat[sLDC+1]={{m1x,m1y,m1z},{m4x,m4y,m4z},{m7x,m7y,m7z},{m10x,m10y,m10z},labelDat}\n                                        sLDC=sLDC+1\n                                    end\n                                end\n                            else\n                            end\n                        end\n                        svg[c]='\"/>'\n                        c=c+1\n                        if sLDC>0 then\n                            for ll=1,sLDC do\n                                local lInfo=sLabelDat[ll]\n                                local text=dat[1]\n                                local s=dat[3]\n                                for i=1,4 do\n                                    local p=lInfo[i]\n                                    local s=s\n                                    if dat[2] then\n                                        s=getSize(s,p[3],100,1)\n                                    end\n                                    \n                                    svg[c]=format('<text x=\"%g\" y=\"%g\" fill=\"white\" font-size=\"%g\">%s</text>',p[1],p[2],s,text)\n                                    c=c+1\n                                end\n                            end\n                        end\n                    end\n                    \n                    for cG=1,#customGroups do\n                        local customGroup=customGroups[cG]\n                        local multiGroups=customGroup[2]\n                        local singleGroups=customGroup[3]\n                        svg[c]=format('<g class=\"%s\">',customGroup[1])\n                        c=c+1\n                        for mGC=1,#multiGroups do\n                            local multiGroup=multiGroups[mGC]\n                            local pts=multiGroup[1]\n                            local tPoints={}\n                            local ct=1\n                            local modP={}\n                            for pC=1,#pts do\n                                local p=pts[pC]\n                                local x,y,z=p[1],p[2],p[3]\n                                local pz=mYX*x+mYY*y+mYZ*z+mYW\n                                if pz<0 then goto behindMG end\n\n                                tPoints[ct]={(mXX*x+mXY*y+mXZ*z+mXW)/pz,(mZX*x+mZY*y+mZZ*z+mZW)/pz,pz}\n                                modP[ct]={mx1*x+my1*y+mz1*z,mx2*x+my2*y+mz2*z,mx3*x+my3*y+mz3*z}\n                                ct=ct+1\n                                ::behindMG::\n                            end\n                            if ct~=1 then\n                                local drawFunction=multiGroup[2]\n                                local data=multiGroup[3]\n                                c=drawFunction(svg,c,object,tPoints,data)\n                            end\n                        end\n                        for sGC=1,#singleGroups do\n                            local singleGroup=singleGroups[sGC]\n                            local p=singleGroup[1]\n                            local x,y,z=p[1],p[2],p[3]\n                            local pz=mYX*x+mYY*y+mYZ*z+mYW\n                            if pz<0 then goto behindSingle end\n                            \n                            local drawFunction=singleGroup[2]\n                            local data=singleGroup[3]\n                            c=drawFunction(svg,c,object,(mXX*x+mXY*y+mXZ*z+mXW)/pz,(mZX*x+mZY*y+mZZ*z+mZW)/pz,pz,data)\n                            ::behindSingle::\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    local notIntersected = true\n                    for uiC=1,#uiGroups do\n                        local uiGroup=uiGroups[uiC]\n                         \n                        local elements=uiGroup[2]\n                        local zBuffer={}\n                        local zBC=0\n                        \n                        for eC=1,#elements do\n                            local el=elements[eC]\n                            if not el[6] then goto behindElement end\n                            \n                            local eXO,eYO,eZO=el[10],el[11],el[12]\n                            \n                            local eCZ=mYX*eXO+mYY*eYO+mYZ*eZO+mYW\n                            if eCZ<0 then goto behindElement end\n                            local distance = eCZ*eCZ\n                            local count = 1\n                            \n                            local drawOrder=el[7]\n                            local drawData=el[8]\n                            local points=el[9]\n                            \n                            local unpackData={}\n                            local uC=1\n                            if drawData then\n                                local drawDatCount = #drawData\n                                local strokeWidth = atan(drawData[1],eCZ)*nearDivAspect\n                                \n                                unpackData[1] = strokeWidth\n                                for dDC = 2, drawDatCount do\n                                    unpackData[dDC] = drawData[dDC]\n                                end\n                                uC = drawDatCount+1\n                            end\n                            local broken=false\n                            if not drawOrder then\n                                for ePC=1,#points,3 do\n                                    local ex,ey,ez=points[ePC],points[ePC+1],points[ePC+2]\n                                    \n                                    local pz=mYX*ex+mYY*ey+mYZ*ez+mYW\n                                    if pz<0 then broken=true;break end\n                                \n                                    unpackData[uC]=(mXX*ex+mXY*ey+mXZ*ez+mXW)/pz\n                                    unpackData[uC+1]=(mZX*ex+mZY*ey+mZZ*ez+mZW)/pz\n                                    uC=uC+2\n                                end\n                            else\n                                for ePC=1,#points,3 do\n                                    local ex,ey,ez=points[ePC],points[ePC+1],points[ePC+2]\n                                    \n                                    local pz=mYX*ex+mYY*ey+mYZ*ez+mYW\n                                    \n                                    if pz<0 then broken=true;break end\n                                    distance = distance + (pz*pz) --(1/pz)\n                                    --distance = (pz*pz)/((2^32-1)*near) + (px*px)/((2^32-1)*near)\n                                    --distance = (pz*pz) + (px*px) + (pm*pm)\n                                    --distance = (dptP1+(1/pz)*dptP2) + (dptP1+(1/pd)*dptP2)\n                                    --distance = count*dptP1 + ((1/pz) + (1/pd) + (1/pc))*dptP2\n                                    count = count + 1\n                                    local px = (mXX*ex+mXY*ey+mXZ*ez+mXW)/pz\n                                    local py = (mZX*ex+mZY*ey+mZZ*ez+mZW)/pz\n                                    --print(\"Point\")\n                                    local indexList = drawOrder[ePC]\n                                    for i=1, #indexList do\n                                        local index = indexList[i] + (uC  - 1)\n                                        unpackData[index] = px\n                                        unpackData[index+1] = py\n                                        --print(index)\n                                    end\n                                end\n                            end\n                            \n                            if not broken then\n                                local mCX,mCY,mCZ=(mx1*eXO+my1*eYO+mz1*eZO)-P0X,(mx2*eXO+my2*eYO+mz2*eZO)-P0Y,(mx3*eXO+my3*eYO+mz3*eZO)-P0Z\n\n                                zBC=zBC+1\n                                zBuffer[zBC]={\n                                    (distance*dptPercision)/count, --dptP1+(distance*dptP2)/count, --mCX*mCX + mCY*mCY + mCZ*mCZ, --abs(((mCX-P0X)*uDX) + ((mCY-P0Y)*uDY) + ((mCZ-P0Z)*uDZ)), -- Highly reduced distance comparison value\n                                    {el[1],el[2],el[3]}, \n                                    unpackData,\n                                    -mCX,\n                                    -mCY,\n                                    -mCZ,\n                                    el[13],\n                                    el[14],\n                                    el[15],\n                                    el[16],\n                                    el[4],\n                                    el[5],\n                                    el[17],\n                                    el[18],\n                                    el[19],\n                                    el[20],\n                                    eXO,\n                                    eYO,\n                                    eZO --,\n                                    --abs((mCX*uDX) + (mCY*uDY) + (mCZ*uDZ))\n                                }\n                            end\n                            ::behindElement::\n                        end\n                        \n                        sort(zBuffer,zSort)\n                        \n                        for zC=zBC,1,-1 do\n                            local uiElmt=zBuffer[zC]\n                            \n                            local drawForms=uiElmt[2]\n                            local drawForm = drawForms[2]\n                            if notIntersected then\n                                local eBounds = uiElmt[10]\n                                if eBounds then\n                                    local eNX,eNY,eNZ,p0X,p0Y,p0Z = uiElmt[7],uiElmt[8],uiElmt[9],uiElmt[4],uiElmt[5],uiElmt[6]\n                                    \n                                    local NX,NY,NZ=mx1*eNX+my1*eNY+mz1*eNZ,mx2*eNX+my2*eNY+mz2*eNZ,mx3*eNX+my3*eNY+mz3*eNZ\n                                    \n                                    local t=-(p0X*NX+p0Y*NY+p0Z*NZ)/(vx2*NX+vy2*NY+vz2*NZ)\n                                    local px,py,pz=p0X+t*vx2,p0Y+t*vy2,p0Z+t*vz2\n                                    \n                                    local uox,uoy,uoz,uow=uiElmt[13],uiElmt[14],uiElmt[15],uiElmt[16]\n                                    local uoyuoy=uoy*uoy\n                                    \n                                    local ix,iy,iz = mx1*px + mx2*py + mx3*pz,my1*px + my2*py + my3*pz,mz1*px + mz2*py + mz3*pz\n                                    \n                                    local pX,pZ=2*((0.5-uoyuoy-uoz*uoz)*ix+(uox*uoy+uoz*uow)*iy+(uox*uoz-uoy*uow)*iz),2*((uox*uoz+uoy*uow)*ix+(uoy*uoz-uox*uow)*iy+(0.5-uox*uox-uoyuoy)*iz)\n                                    \n                                    local inside = false\n                                    local N = #eBounds+1\n                                    local p1 = eBounds[1]\n                                    \n                                    local offset = 0\n                                    for eb=2,N do\n                                        local mod = eb%N\n                                        if mod == 0 then\n                                            offset = 1\n                                        end\n                                        local p2 = eBounds[mod + offset]\n                                        \n                                        local minY = p1[2] < p2[2] and p1[2] or p2[2]\n                                        if pZ > minY then\n                                            local maxY = p1[2] > p2[2] and p1[2] or p2[2]\n                                            if pZ <= maxY then\n                                                local maxX = p1[1] > p2[1] and p1[1] or p2[1]\n                                                if pX <= maxX then\n                                                    if p1[2] ~= p2[2] then\n                                                        if p1[1] == p2[1] or pX <= (pZ-p1[2])*(p2[1]-p1[1])/(p2[2]-p1[2])+p1[1] then\n                                                            inside = not inside\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n                                        p1=p2\n                                    end\n                                    if not inside then\n                                        goto broke\n                                    end\n                                    notIntersected = false\n                                    drawForm = drawForms[1]\n                                \n                                    if isClicked then\n                                        drawForm = drawForms[3]\n                                        print(\"Clicked\")\n                                        local clickAction = uiElmt[11]\n                                        if clickAction then\n                                            clickAction(pX,pZ,uiElmt[17],uiElmt[18],uiElmt[19])\n                                            isClicked = false\n                                        end\n                                    else\n                                        local hoverAction = uiElmt[12]\n                                        if hoverAction then\n                                            hoverAction(pX,pZ,uiElmt[17],uiElmt[18],uiElmt[19])\n                                        end\n                                    end\n                                    ::broke::\n                                end\n                            end\n                            uiElmt[2]=drawForm\n                        end\n                        --sort(zBuffer,dSort)\n                        svg[c]=format('<g class=\"%s\">',uiGroup[1])\n                        c=c+1\n                        for zC=1,zBC do\n                            local uiElement=zBuffer[zC]\n                            local drawForm=uiElement[2]\n\n                            if drawForm then\n                                svg[c]=format(drawForm,unpack(uiElement[3]))\n                                c=c+1\n                            end\n                        end\n                        svg[c]='</g>'\n                        c=c+1\n                    end\n                    svg[c]='</g>'\n                    c=c+1\n                end\n                ::is_nil::\n            end\n            svg[c]='</g></svg>'\n            c=c+1\n            ::not_enabled::\n        end\n        return svg, c, near, mReturn1\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"6"},{"code":"positionTypes = {\n    globalP=1,\n    localP=2\n}\norientationTypes = {\n    globalO=1,\n    localO=2 \n}\n\ntextAlignments = {\n    [\"middle\"] = 'middle',\n    [\"end\"] = 'end',\n    [\"start\"] = 'start'\n}\n\nlocal print = system.print\n\nlocal TEXT_ARRAY = {\n    [10] = {{},{},16,''},--new line\n    [32] = {{}, {}, 10,''}, -- space\n    [33] = {{4, 0, 3, 2, 5, 2, 4, 0, 4, 4, 4, 12}, {1, 2, 3, 4, false, 5, 6}, 6, 'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- !\n    [34] = {{2, 10, 2, 6, 6, 10, 6, 6}, {1, 2, false, 3, 4}, 6,'M%g %gL%g %g M%g %gL%g %g'}, -- \"\n    [35] = {{0, 4, 8, 4, 6, 2, 6, 10, 8, 8, 0, 8, 2, 10, 2, 2}, {1, 2, false, 3, 4, false, 5, 6, false, 7, 8}, 10,'M%g %gL%g %g M%g %gL%g %g M%g %gL%g %g M%g %gL%g %g'}, -- #\n    [36] = {{6, 2, 2, 6, 6, 10, 4, 12, 4, 0}, {1, 2, 3, false, 4, 5}, 6,'M%g %gL%g %gL%g %g M%g %gL%g %g'}, --$\n    [37] = {{0, 0, 8, 12, 2, 10, 2, 8, 6, 4, 6, 2}, {1, 2, false, 3, 4, false, 5, 6}, 10,'M%g %gL%g %g M%g %gL%g %g M%g %gL%g %g'}, -- %\n    [38] = {{8, 0, 4, 12, 8, 8, 0, 4, 4, 0, 8, 4}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, --&\n    [39] = {{0, 8, 0, 12}, {1, 2}, 2,'M%g %gL%g %g'}, --'\n    \n    [40] = {{6, 0, 2, 4, 2, 8, 6, 12}, {1, 2, 3, 4}, 6,'M%g %gL%g %gL%g %gL%g %g'}, --(\n    [41] = {{2, 0, 6, 4, 6, 8, 2, 12}, {1, 2, 3, 4}, 6,'M%g %gL%g %gL%g %gL%g %g'}, --)\n    [42] = {{0, 0, 4, 12, 8, 0, 0, 8, 8, 8, 0, 0}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, --*\n    [43] = {{1, 6, 7, 6, 4, 9, 4, 3}, {1, 2, false, 3, 4}, 8,'M%g %gL%g %g M%g %gL%g %g'}, -- +\n    [44] = {{-1, -2, 1, 1}, {1, 2}, 4,'M%g %gL%g %g'}, -- ,\n    [45] = {{2, 6, 6, 6}, {1, 2}, 6,'M%g %gL%g %g'}, -- -\n    [46] = {{0, 0, 1, 0}, {1, 2}, 3,'M%g %gL%g %g'}, -- .\n    [47] = {{0, 0, 8, 12}, {1, 2}, 10,'M%g %gL%g %g'}, -- /\n    [48] = {{0, 0, 8, 0, 8, 12, 0, 12, 0, 0, 8, 12}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- 0\n    [49] = {{2, 0, 2, 12, 0, 10}, {1, 2, 3}, 6,'M%g %gL%g %gL%g %g'}, -- 1\n\n    \n    [50] = {{0, 12, 8, 12, 8, 7, 0, 5, 0, 0, 8, 0}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- 2\n    [51] = {{0, 12, 8, 12, 8, 0, 0, 0, 0, 6, 8, 6}, {1, 2, 3, 4, false, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- 3\n    [52] = {{0, 12, 0, 6, 8, 6, 8, 12, 8, 0}, {1, 2, 3, false, 4, 5}, 10,'M%g %gL%g %gL%g %g M%g %gL%g %g'}, -- 4\n    [53] = {{0, 0, 8, 0, 8, 6, 0, 7, 0, 12, 8, 12}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- 5\n    [54] = {{0, 12, 0, 0, 8, 0, 8, 5, 0, 7}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- 6\n    [55] = {{0, 12, 8, 12, 8, 6, 4, 0}, {1, 2, 3, 4}, 10,'M%g %gL%g %gL%g %gL%g %g'}, -- 7\n    [56] = {{0, 0, 8, 0, 8, 12, 0, 12, 0, 6, 8, 6}, {1, 2, 3, 4, 1, false, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gZ M%g %gL%g %g'}, -- 8\n    [57] = {{8, 0, 8, 12, 0, 12, 0, 7, 8, 5}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- 9\n    [58] = {{4, 9, 4, 7, 4, 5, 4, 3}, {1, 2, false, 3, 4}, 2,'M%g %gL%g %g M%g %gL%g %g'}, -- :\n    [59] = {{4, 9, 4, 7, 4, 5, 1, 2}, {1, 2, false, 3, 4}, 5,'M%g %gL%g %g M%g %gL%g %g'}, -- ;\n    \n    [60] = {{6, 0, 2, 6, 6, 12}, {1, 2, 3}, 6,'M%g %gL%g %gL%g %g'}, -- <\n    [61] = {{1, 4, 7, 4, 1, 8, 7, 8}, {1, 2, false, 3, 4}, 8,'M%g %gL%g %g M%g %gL%g %g'}, -- =\n    [62] = {{2, 0, 6, 6, 2, 12}, {1, 2, 3}, 6,'M%g %gL%g %gL%g %g'}, -- >\n    [63] = {{0, 8, 4, 12, 8, 8, 4, 4, 4, 1, 4, 0}, {1, 2, 3, 4, false, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- ?\n    [64] = {{8, 4, 4, 0, 0, 4, 0, 8, 4, 12, 8, 8, 4, 4, 3, 6}, {1, 2, 3, 4, 5, 6, 7, 8}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- @\n    [65] = {{0, 0, 0, 8, 4, 12, 8, 8, 8, 0, 0, 4, 8, 4}, {1, 2, 3, 4, 5, false, 6, 7}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- A\n    [66] = {{0, 0, 0, 12, 4, 12, 8, 10, 4, 6, 8, 2, 4, 0}, {1, 2, 3, 4, 5, 6, 7, 1}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %gL%g %gZ'}, --B\n    [67] = {{8, 0, 0, 0, 0, 12, 8, 12}, {1, 2, 3, 4}, 10,'M%g %gL%g %gL%g %gL%g %g'}, -- C\n    [68] = {{0, 0, 0, 12, 4, 12, 8, 8, 8, 4, 4, 0}, {1, 2, 3, 4, 5, 6, 1}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %gZ'}, -- D \n    [69] = {{8, 0, 0, 0, 0, 12, 8, 12, 0, 6, 6, 6}, {1, 2, 3, 4, false, 5, 6}, 10, 'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- E\n    \n    \n    [70] = {{0, 0, 0, 12, 8, 12, 0, 6, 6, 6}, {1, 2, 3, false, 4, 5}, 10,'M%g %gL%g %gL%g %g M%g %gL%g %g'}, -- F\n    [71] = {{6, 6, 8, 4, 8, 0, 0, 0, 0, 12, 8, 12}, {1, 2, 3, 4, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- G\n    [72] = {{0, 0, 0, 12, 0, 6, 8, 6, 8, 12, 8, 0}, {1, 2, false, 3, 4, false, 5, 6}, 10,'M%g %gL%g %g M%g %gL%g %g M%g %gL%g %g'}, -- H\n    [73] = {{0, 0, 8, 0, 4, 0, 4, 12, 0, 12, 8, 12}, {1, 2, false, 3, 4, false, 5, 6}, 10,'M%g %gL%g %g M%g %gL%g %g M%g %gL%g %g'}, -- I\n    [74] = {{0, 4, 4, 0, 8, 0, 8, 12}, {1, 2, 3, 4}, 10,'M%g %gL%g %gL%g %gL%g %g'}, -- J\n    [75] = {{0, 0, 0, 12, 8, 12, 0, 6, 6, 0}, {1, 2, false, 3, 4, 5}, 10,'M%g %gL%g %g M%g %gL%g %gL%g %g'}, -- K\n    [76] = {{8, 0, 0, 0, 0, 12}, {1, 2, 3}, 10,'M%g %gL%g %gL%g %g'}, -- L\n    [77] = {{0, 0, 0, 12, 4, 8, 8, 12, 8, 0}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- M\n    [78] = {{0, 0, 0, 12, 8, 0, 8, 12}, {1, 2, 3, 4}, 10,'M%g %gL%g %gL%g %gL%g %g'}, -- N\n    [79] = {{0, 0, 0, 12, 8, 12, 8, 0}, {1, 2, 3, 4, 1}, 10,'M%g %gL%g %gL%g %gL%g %gZ'}, -- O\n    \n    [80] = {{0, 0, 0, 12, 8, 12, 8, 6, 0, 5}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- P\n    [81] = {{0, 0, 0, 12, 8, 12, 8, 4, 4, 4, 8, 0}, {1, 2, 3, 4, 1, false, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %gZ M%g %gL%g %g'}, -- Q\n    [82] = {{0, 0, 0, 12, 8, 12, 8, 6, 0, 5, 4, 5, 8, 0}, {1, 2, 3, 4, 5, false, 6, 7}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- R\n    [83] = {{0, 2, 2, 0, 8, 0, 8, 5, 0, 7, 0, 12, 6, 12, 8, 10}, {1, 2, 3, 4, 5, 6, 7, 8}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %gL%g %gL%g %gL%g %g'}, -- S\n    [84] = {{0, 12, 8, 12, 4, 12, 4, 0}, {1, 2, false, 3, 4}, 10,'M%g %gL%g %g M%g %gL%g %g'}, -- T\n    [85] = {{0, 12, 0, 2, 4, 0, 8, 2, 8, 12}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- U\n    [86] = {{0, 12, 4, 0, 8, 12}, {1, 2, 3}, 10,'M%g %gL%g %gL%g %g'}, -- V\n    [87] = {{0, 12, 2, 0, 4, 4, 6, 0, 8, 12}, {1, 2, 3, 4, 5}, 10,'M%g %gL%g %gL%g %gL%g %gL%g %g'}, -- W\n    [88] = {{0, 0, 8, 12, 0, 12, 8, 0}, {1, 2, false, 3, 4}, 10,'M%g %gL%g %g M%g %gL%g %g'}, -- X\n    [89] = {{0, 12, 4, 6, 8, 12, 4, 6, 4, 0}, {1, 2, 3, false, 4, 5}, 10,'M%g %gL%g %gL%g %g M%g %gL%g %g'}, -- Y\n    \n    [90] = {{0, 12, 8, 12, 0, 0, 8, 0, 2, 6, 6, 6}, {1, 2, 3, 4, false, 5, 6}, 10,'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- Z\n    [91] = {{6, 0, 2, 0, 2, 12, 6, 12}, {1, 2, 3, 4}, 6,'M%g %gL%g %gL%g %gL%g %g'}, -- [\n    [92] = {{0, 12, 8, 0}, {1, 2}, 10,'M%g %gL%g %g'}, -- \\\n    [93] = {{2, 0, 6, 0, 6, 12, 2, 12}, {1, 2, 3, 4}, 6,'M%g %gL%g %gL%g %gL%g %g'}, -- ]\n    [94] = {{2, 6, 4, 12, 6, 6}, {1, 2, 3}, 6,'M%g %gL%g %gL%g %g'}, -- ^\n    [95] = {{0, 0, 8, 0}, {1, 2}, 10,'M%g %gL%g %g'}, -- _\n    [96] = {{2, 12, 6, 8}, {1, 2}, 6,'M%g %gL%g %g'}, -- `\n    \n    [123] = {{6, 0, 4, 2, 4, 10, 6, 12, 2, 6, 4, 6}, {1, 2, 3, 4, false, 5, 6}, 6,'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- {\n    [124] = {{4, 0, 4, 5, 4, 6, 4, 12}, {1, 2, false, 3, 4}, 6,'M%g %gL%g %g M%g %gL%g %g'}, -- |\n    [125] = {{4, 0, 6, 2, 6, 10, 4, 12, 6, 6, 8, 6}, {1, 2, 3, 4, false, 5, 6}, 6,'M%g %gL%g %gL%g %gL%g %g M%g %gL%g %g'}, -- }\n    [126] = {{0, 4, 2, 8, 6, 4, 8, 8}, {1, 2, 3, 4}, 10,'M%g %gL%g %gL%g %gL%g %g'}, -- ~\n}\n\nfunction Text(string, size, alignmentX, alignmentY)\n    alignmentX = alignmentX or 'middle'\n    alignmentY = alignmentY or 'middle'\n\n    local self = {}\n    local byte, upper = string.byte, string.upper\n    local encodedChars = {}\n    local fontSize = size * 0.05 or 0.05\n    local offsetX = 0\n    local offsetY = 0\n\n    local drawData = {fontSize, \"#0F0\"}\n    local points = {}\n\n    function self.setFontSize(size)\n        fontSize = size * 0.05\n        drawData[1] = size * 0.05\n    end\n    function self.setFontColor(color)\n        drawData[2] = color \n    end\n    function self.setOpacity(opacity)\n        drawData[3] = opacity \n    end\n\n    function self.setCharacters(characters)\n        encodedChars = {}\n\n        local result = {byte(upper(characters), 1, #characters)}\n\n        local count = 0\n        local newline = TEXT_ARRAY[10]\n        offsetX = 0\n        offsetY = 0\n        for k = 1, #result do\n            count = count + 1\n            local points = {}\n            local charCode = result[k]\n            local charCode1 = result[k + 1] or 10\n\n            local char, charSize1 = TEXT_ARRAY[charCode], TEXT_ARRAY[charCode1][3]\n            local charPoints, charIndex, charSize0 = char[1], char[2], char[3]\n            local pM = 1\n            local charSize = charSize0\n            for m = 1, #charPoints, 2 do\n                points[pM] = charPoints[m] * fontSize + offsetX\n                points[pM + 1] = 0\n                points[pM + 2] = charPoints[m + 1] * fontSize + offsetY\n                pM = pM + 3\n            end\n\n            offsetX = offsetX + charSize * fontSize\n            if charCode == 10 then\n                offsetX = 0\n                offsetY = offsetY - charSize*fontSize\n            end\n            encodedChars[count] = {points, charIndex,char[4]}\n        end\n        \n    end\n    self.setCharacters(string)\n\n    function self.getDrawStrings()\n        local concat = table.concat\n        local chars = encodedChars\n        local drawStrings = {'<path stroke-width=\"%gpx\" stroke=\"%s\" stroke-opacity=\"%g\" fill=\"none\" d=\"'}\n        local c = 2\n        for i = 1, #chars do\n            local char = chars[i]\n            local charPI = char[2]\n            local length = #charPI - 1\n            if length == -1 then\n                goto empty\n            end\n            drawStrings[c] = char[3]\n            c = c + 1\n            ::empty::\n        end\n        drawStrings[c] = '\"/>'\n        return drawData, concat(drawStrings)\n    end\n    function self.getPoints()\n        local chars = encodedChars\n        local drawOrder = {}\n        local points = {}\n        local alignmentOffsetX = 0\n        local alignmentOffsetY = 0\n        if alignmentX == \"middle\" then\n            alignmentOffsetX = -offsetX * 0.5\n        elseif alignmentX == \"end\" then\n            alignmentOffsetX = -offsetX\n        end\n        if alignmentY == \"middle\" then\n            if offsetY == 0 then\n                alignmentOffsetY = -5*fontSize\n            else\n                alignmentOffsetY = -offsetY * 0.5\n            end\n        elseif alignmentY == \"end\" then\n            alignmentOffsetY = -offsetY\n        end\n\n        local pCount = 1\n        local iCount3 = 0\n        local iCount2 = 1\n\n        for i = 1, #chars do\n            local char = chars[i]\n            local charPoints = char[1]\n            local charIndexes = char[2]\n            local offset = 0\n            for m = 1, #charIndexes do\n                local index = charIndexes[m]\n                if not (index == true or index == false) and (index ~= 1 or (index == 1 and m == 1)) then\n                    local order = drawOrder[index * 3 - 2 + iCount3]\n                    if not order then\n                        order = {}\n                        drawOrder[index * 3 - 2 + iCount3] = order\n                    end\n                    order[#order + 1] = iCount2\n                    iCount2 = iCount2 + 2\n                end\n            end\n\n            for k = 1, #charPoints, 3 do\n                points[pCount] = charPoints[k] + alignmentOffsetX\n                points[pCount + 1] = charPoints[k + 1]\n                points[pCount + 2] = charPoints[k + 2] + alignmentOffsetY\n                pCount = pCount + 3\n                iCount3 = iCount3 + 3\n            end\n        end\n\n        return drawOrder, points\n    end\n    return self\nend\n\n\nlocal function getQuaternion(pitch,roll,heading)\n    pitch = pitch * 0.5\n    roll = roll * 0.5\n    heading = heading * 0.5\n    local s,c=math.sin,math.cos\n    local sP,sH,sR=s(pitch),s(roll),s(heading)\n    local cP,cH,cR=c(pitch),c(roll),c(heading)\n    return (sP*cH*cR-cP*sH*sR),(cP*sH*cR+sP*cH*sR),(cP*cH*sR-sP*sH*cR),(cP*cH*cR+sP*sH*sR)\nend\nlocal function quatRotate(ax,ay,az,aw,points)\n    local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n    \n    local a1,b1,c1 = (awaw+axax-ayay-azaz), 2*(ax*ay-aw*az), 2*(ax*az+aw*ay)\n    local d1,e1,f1 = 2*(aw*az+ax*ay), (awaw-axax+ayay-azaz), 2*(ay*az-aw*ax)\n    local g1,h1,i1 = 2*(ax*az-aw*ay), 2*(ax*aw+ay*az), (awaw-axax-ayay+azaz)\n    \n    local pts={}\n    for i=1,#points,3 do\n        local x,y,z=points[i],points[i+1],points[i+2]\n        pts[i]   = x*a1 + y*b1 + z*c1\n        pts[i+1] = x*d1 + y*e1 + z*f1\n        pts[i+2] = x*g1 + y*h1 + z*i1\n    end\n    return pts\nend\n\nfunction ObjectGroup(style, objects, transX, transY)\n    local objects=objects or {}\n    local self={style=style,objects=objects,transX=transX,transY=transY,enabled=true}\n    function self.addObject(object, id)\n        local id=id or #objects+1\n        objects[id]=object\n        return id\n    end\n    function self.removeObject(id) objects[id] = {} end\n    function self.hide() self.enabled = false end\n    function self.show() self.enabled = true end\n    function self.isEnabled() return self.enabled end\n    return self\nend\n\nfunction Object(style, position, offset, orientation, positionType, orientationType, transX, transY)\n    local rad,print=math.rad,system.print\n    \n    local position=position\n    local positionOffset=offset\n    local heading=rad(orientation[1])\n    local pitch=rad(orientation[2])\n    local roll=rad(orientation[3])\n    \n    local style=style\n    local polylineGroups,circleGroups,curveGroups,customGroups,triangleGroups,uiGroups,subObjects={},{},{},{},{},{},{}\n    local positionType=positionType\n    local orientationType=orientationType\n    \n    local self = {\n        polylineGroups,circleGroups,curveGroups,customGroups,triangleGroups,uiGroups,subObjects,\n        positionType, --8\n        orientationType, --9\n        {pitch,heading,roll},\n        style,\n        position,\n        offset,\n        transX,\n        transY\n    }\n    \n    function self.setPolylines(groupId,style,points,scale)\n        -- Polylines for-loop\n        local group={style}\n        local scale=scale or 1\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        for i=2,#points+1 do\n            local line=points[i-1]\n            local newPoints={}\n            local counter=1\n            for k=1,#line,3 do\n                newPoints[counter]={line[k]/scale+offsetX,line[k+1]/scale-offsetY,line[k+2]/scale-offsetZ}\n                counter=counter+1\n            end\n            group[i]=newPoints\n        end\n        self[1][groupId]=group\n    end\n    \n    function self.setCircles(groupId,style,scale)\n        local group={style}\n        local scale=scale or 1\n        local c=2\n        self[2][groupId]=group\n        local offset=offset or positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        local self={}\n        function self.addCircle(position,radius,fill)\n            local self={}\n            local position={position[1]/scale+offsetX,position[2]/scale-offsetY,position[3]/scale-offsetZ}\n            local label,offX,offY,size,resize,action = nil,nil,nil,nil,false,nil\n\n            function self.setLabel(lab,rs,s,ofX,ofY)\n                label=lab\n                offX=ofX or 0\n                offY=ofY or 0\n                size=s or 10\n                resize=rs or false\n                return self\n            end\n            function self.setActionFunction(actionFunction)\n                action=actionFunction\n                return self\n            end\n            function self.build()\n                local circleObj={position,radius,fill,label,offX,offY,size,resize,actionFunction}\n                group[c]=circleObj\n                c=c+1\n                return circleObj,c\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCurves(groupId,style,scale)\n        local scale=scale or 1\n        local curves= {}\n        local group={style,curves}\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        self[3][groupId]=group\n        local self={}\n        local c=1\n        function self.circleBuilder()\n            local self={}\n            function self.createCircle(center,radius)\n                local k=0.5522847498307933984023\n                local radius=radius/scale\n                local cX,cY,cZ=center[1]/scale+offsetX,center[2]/scale-offsetY,center[3]/scale-offsetZ\n                local cPoints={\n                    {cX,radius+cY,cZ},{radius*k+cX,radius+cY,cZ},{radius+cX,radius*k+cY,cZ},\n                    {radius+cX,cY,cZ},{radius+cX,-radius*k+cY,cZ},{radius*k+cX,-radius+cY,cZ},\n                    {cX,-radius+cY,cZ},{-radius*k+cX,-radius+cY,cZ},{-radius+cX,-radius*k+cY,cZ},\n                    {-radius+cX,cY,cZ},{-radius+cX,radius*k+cY,cZ},{-radius*k+cX,radius+cY,cZ}\n                }\n                local resize,size=false,10\n                local labelDat={nil,resize,size}\n                local self={}\n                \n                function self.setLabel(label,resize,size)\n                    local resize=resize or false\n                    local size=size*0.002 or 0.05\n                    labelDat={label,resize,size}\n                    return self\n                end\n                function self.build()\n                    local persCircleArray={1,cPoints,labelDat}\n                    curves[c]=persCircleArray\n                    c=c+1\n                    return persCircleArray,c\n                end\n                return self\n            end\n            return self\n        end\n        function self.bezierBuilder()\n            local self={}\n            function self.createCurve(sP)\n            end\n            function self.addControlPoint(cP)\n            end\n            function self.addEndPoint(eP)\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCustomSVGs(groupId,style,scale)\n        local multiPoint={}\n        local singlePoint={}\n        local group={style,multiPoint,singlePoint}\n        local scale=scale or 1\n        local mC,sC=1,1\n        self[4][groupId]=group\n        local offset=positionOffset\n        local offsetX,offsetY,offsetZ=offset[1],offset[2],offset[3]\n        local self={}\n        function self.addMultiPointSVG()\n            local points={}\n            local data=nil\n            local drawFunction=nil\n            local self={}\n            local pC=1\n            function self.addPoint(point)\n                local point=point\n                points[pC]={point[1]/scale+offsetX,point[2]/scale-offsetY,point[3]/scale-offsetZ}\n                pC=pC+1\n                return self\n            end\n            function self.bulkSetPoints(bulk)\n                points=bulk\n                pC=#points+1\n                return self\n            end\n            function self.setData(dat)\n                data=dat\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction=draw\n                return self\n            end\n            function self.build()\n                if pC > 1 then\n                    if drawFunction ~= nil then\n                        multiPoint[mC]={points, drawFunction, data}\n                        mC=mC+1\n                        return points\n                    else print(\"WARNING! Malformed multi-point build operation, no draw function specified. Ignoring.\")\n                    end\n                else print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        function self.addSinglePointSVG()\n            local point,drawFunction,data={0,0,0},nil,nil\n            local self={}\n            function self.setPosition(position)\n                point[1],point[2],point[3]=position[1]/scale+offsetX,position[2]/scale-offsetY,position[3]/scale-offsetZ\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction=draw\n                return self\n            end\n            function self.setData(dat)\n                data=dat\n                return self\n            end\n            function self.build()\n                if point~=nil then\n                    if drawFunction~=nil then\n                        singlePoint[sC]={point,drawFunction,data}\n                        sC=sC+1\n                    else print(\"WARNING! Malformed single point build operation, no draw function specified. Ignoring.\")\n                    end\n                else print(\"WARNING! Malformed single point build operation, no point specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return self\n    end\n    function self.setUIElements(groupId, style, scale)\n        local sqrt, s, c,remove = math.sqrt, math.sin, math.cos, table.remove\n\n        local function createNormal(points)\n            if #points < 9 then\n                print(\"Invalid Point Set!\")\n                do\n                    return\n                end\n            end\n            local p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z =\n                points[1],\n                points[2],\n                points[3],\n                points[4],\n                points[5],\n                points[6],\n                points[7],\n                points[8],\n                points[9]\n\n            local sx, sy, sz = p1x - p2x, p1y - p2y, p1z - p2z\n            local vx, vy, vz = p1x - p3x, p1y - p3y, p1z - p3z\n            local nx, ny, nz, nw = sy * vz - sz * vy, sz * vx - sx * vz, sx * vy - sy * vx\n            local val = 1 / sqrt(nx * nx + ny * ny + nz * nz)\n\n            return nx * val, ny * val, nz * val\n        end\n        local function createBounds(points)\n            local bounds = {}\n            local size = #points\n            if size >= 60 then\n                return false\n            end\n            local delta = 1\n            for i = 1, size, 3 do\n                bounds[delta] = {points[i],points[i+2]}\n                delta = delta + 1\n            end\n            return bounds\n        end\n        \n        local elements = {}\n        local elementClasses = {}\n\n        local group = {style, elements}\n        local scale = scale or 1\n\n        self[6][groupId] = group\n        \n        local pitch, roll, yaw = 0, 0, 0\n\n        local self = {}\n        local pC, eC = 0, 0\n\n        local rx, ry, rz, rw = getQuaternion(0, 0, 0)\n\n        local px,py,pz = 0,0,0\n        \n        function self.setReferencePoint(x,y,z)\n            for i = 1, eC do\n                local class = elementClasses[i]\n                class.setPosition(class.get)\n            end\n            px,py,pz = x,y,z\n        end\n        \n        \n        local function createUITemplate(x,y,z,offset)\n            \n            local user = {}\n            local raw = {}\n            \n            local tx = x + px\n            local ty = y + py\n            local tz = z + pz\n\n            local pCounter = 0\n            local elementIndex = eC + 1 + (offset or 0)\n            --local hoverDraw defaultDraw, clickDraw = false, false, false\n            --local clickAction, hoverAction =  false, false\n            --local show = true\n            --local drawOrder, pointSet, rawPointSet = false, {}, {}\n            local pointSet = {}\n            local rawPointSet = {}\n            --local elementData = {hoverDraw, defaultDraw, clickDraw, clickAction, hoverAction, show, drawOrder, drawData, points, tx, ty, tz}\n            local elementData = {false, false, false, false, false, true, false, false, pointSet, tx, ty, tz}\n            local subElements = {}\n            \n            local rx, ry, rz, rw = getQuaternion(0, 0, 0)\n            local rotateX, rotateY, rotateZ = 0, 0, 0\n            \n            local template = {user=user, raw=raw}\n            \n            function user.rotateXYZ(rotX,rotY,rotZ)\n                \n                if rotX and rotY and rotZ then\n                    rotateX = rotX\n                    rotateY = rotY\n                    rotateZ = rotZ\n                    rotate()\n                else\n                    print('Invalid format. Must be three angles. Use radians.')\n                end\n            end\n            function user.addSubElement(element)\n                local index = #subElements + 1\n                subElements[index] = element\n                return index\n            end\n            function user.removeSubElement(index)\n                remove(subElements, index)\n            end\n            function user.addPoint(x,y,z)\n                if x and y and z then\n                    rawPointSet[pCounter+1] = x\n                    rawPointSet[pCounter+2] = y\n                    rawPointSet[pCounter+3] = z\n                    pCounter=pCounter+3\n                else\n                    if type(x) == 'table' and #x > 0 then\n                        rawPointSet[pCounter+1] = x[1]\n                        rawPointSet[pCounter+2] = x[2]\n                        rawPointSet[pCounter+3] = x[3]\n                        pCounter=pCounter+3\n                        return pCounter\n                    else\n                        print('Invalid format for point.')\n                    end\n                end\n            end\n            \n            function user.addPoints(points)\n                if points then\n                    local pointCount = #points\n                    if pointCount > 0 then\n                        local pType = type(points[1])\n                        if pType == 'number' then\n                            local pointTable = rawPointSet\n                            \n                            local startIndex = pCounter + 1\n                            local indicesAdded = {}\n                            local c = 1\n                            for i = 1, pointCount,3 do\n                                local index = startIndex + i\n                                pointTable[index] = points[i]\n                                pointTable[index+1] = points[i+1]\n                                pointTable[index+2] = points[i+2]\n                                indicesAdded[c] = index\n                                c = c + 1\n                            end\n                            pCounter = #pointTable\n                            return indicesAdded\n                        elseif pType == 'table' then\n                            local pointTable = rawPointSet\n                            \n                            local startIndex = pCounter + 1\n                            local indicesAdded = {}\n                            local c = 1\n                            local interval = 0\n                            for i = 1, pointCount do\n                                local point = points[i]\n                                local index = startIndex + interval\n                                pointTable[index] = point[1]\n                                pointTable[index + 1] = point[2]\n                                pointTable[index + 2] = point[3]\n                                indicesAdded[c] = index\n                                c=c+1\n                                interval=interval+3\n                                \n                            end\n                            pCounter = #pointTable\n                            return indicesAdded\n                        else\n                            print('No compatible format found.')\n                        end\n                    end\n                end\n            end\n            \n            local function rotate()\n                rx, ry, rz, rw = getQuaternion(rotateX,rotateY,rotateZ)\n                pointSet = quatRotate(rx, ry, rz, rw, rawPointSet)\n                elementData[9] = pointSet\n                elementData[17] = -rx\n                elementData[18] = -ry\n                elementData[19] = -rz\n                elementData[20] = rw\n                for i=1, #subElements do\n                    subElements[i][1].rotateXYZ(rotateX,rotateY,rotateZ)\n                end\n            end\n            \n            function user.rotateX(rotX) rotateX = rotX; rotate() end\n            function user.rotateY(rotY) rotateY = rotY; rotate() end\n            function user.rotateZ(rotZ) rotateZ = rotZ; rotate() end\n\n            function user.setHoverDraw(hDraw) elementData[1] = hDraw end\n            function user.setDefaultDraw(dDraw) elementData[2] = dDraw end\n            function user.setClickDraw(cDraw) elementData[3] = cDraw end\n            \n            function user.setClickAction(cAction) elementData[4] = cAction end\n            function user.setHoverAction(hAction) elementData[5] = hAction end\n            \n            function user.hide() elementData[6] = false end\n            function user.show() elementData[6] = true end\n            \n            function user.remove() \n                remove(elements,elementIndex)\n                remove(elementClasses,elementIndex)\n                for i = elementIndex, eC do\n                    elementClasses[i].raw.setElementIndex(i)\n                end\n            end\n\n            function user.movePoints(sx,sy,sz)\n                if #pointSet ~= #rawPointSet then\n                    rotate()\n                end\n                local ox = sx + px\n                local oy = sy + py\n                local oz = sz + pz\n                \n                for i = 1, #pointSet, 3 do\n                    pointSet[i] = pointSet[i] - tx + ox\n                    pointSet[i+1] = pointSet[i+1] - ty + oy\n                    pointSet[i+2] = pointSet[i+2] - tz + oz\n                end\n                x = sx\n                y = sy\n                z = sz\n                \n                tx = ox\n                ty = oy\n                tz = oz\n            end\n            \n            function user.setPosition(sx,sy,sz)\n                user.movePoints(sx,sy,sz)\n                raw.setPosition(sx+px,sy+py,sz+pz)\n                for i=1, #subElements do\n                    subElements[i][1].setPosition(sx,sy,sz)\n                end\n            end\n            \n            function user.setDrawOrder(indices)\n                local drawOrder = {}\n                for i=1, #indices do\n                    local index = indices[i]\n                    \n                    local order = drawOrder[index*3-2]\n                    if not order then\n                        order = {}\n                        drawOrder[index*3-2] = order\n                    end\n                    order[#order+1] = i*2-1\n                end\n                elementData[7] = drawOrder\n            end\n            \n            function user.setDrawData(drawData) elementData[8] = drawData end\n            \n            function raw.getDrawOrder() return elementData[7] end\n            function raw.getDrawData() return elementData[8] end\n            \n            function raw.getPointSet() return elementData[9] end\n            function raw.getRawPoints() return rawPointSet end\n            \n            function raw.setDrawOrder(drawOrder) elementData[7] = drawOrder end\n            function raw.setDrawData(drawData) elementData[8] = drawData end\n            \n            function raw.setPoints(points) pointSet = points; elementData[9] = points end\n            function raw.setRawPoints(rPointSet) rawPointSet = rPointSet end\n            \n            function raw.setElementIndex(eI) elementIndex = eI end\n            function raw.getElementIndex(eI) return elementIndex end\n            \n            function raw.getPosition() return x, y, z end\n            \n            function raw.setPosition(tx,ty,tz)\n                x = tx - px\n                y = ty - py\n                z = tz - pz\n                elementData[10] = tx\n                elementData[11] = ty\n                elementData[12] = tz\n                for i=1, #subElements do\n                    subElements[i][2].setPosition(tx,ty,tz)\n                end\n            end\n            \n            function raw.setNormal(nx,ny,nz)\n                elementData[13] = nx\n                elementData[14] = ny\n                elementData[15] = nz\n            end\n            \n            function raw.setBounds(bounds)\n                elementData[16] = bounds\n            end\n            \n            function user.build(force, hasBounds)\n                if #pointSet ~= #rawPointSet or force then\n                    rotate()\n                end\n                \n                local nx, ny, nz = createNormal(pointSet)\n                if nx then\n                    if elementData[2] then\n                        \n                        if not elementData[3] then\n                            elementData[3] = elementData[2]\n                        end\n                        if not elementData[1] then\n                            elementData[1] = elementData[2]\n                        end\n                        \n                        for i = 1, #pointSet, 3 do\n                            pointSet[i] = pointSet[i] + tx\n                            pointSet[i+1] = pointSet[i+1] + ty\n                            pointSet[i+2] = pointSet[i+2] + tz\n                        end\n                        \n                        raw.setNormal(nx,ny,nz)\n                        if not force then\n                            eC = eC + 1\n                            if hasBounds or hasBounds == nil then\n                                local bounds = createBounds(rawPointSet)\n                                raw.setBounds(bounds)\n                            else\n                                raw.setBounds(false)\n                            end\n                        end\n                        \n                        elements[elementIndex] = elementData\n                    else\n                        print(\"Element Malformed: No default draw.\")\n                    end\n                else\n                    print(\"Element Malformed: Insufficient points.\")\n                end\n            end\n            return template, elementData\n        end\n        \n        \n        function self.createText(tx, ty, tz, o)\n            local textTemplate,text = createUITemplate(tx, ty, tz, (o or 0))\n            local userFunc = textTemplate.user\n            local rawFunc = textTemplate.raw\n            \n            function userFunc.setData(textData)\n                drawOrder,wPoints = textData.getPoints()\n\n                local drawData, draw = textData.getDrawStrings()\n                --system.print(draw)\n                userFunc.setDefaultDraw(draw)\n                userFunc.setHoverDraw(draw)\n                userFunc.setClickDraw(draw)\n                rawFunc.setDrawOrder(drawOrder)\n                rawFunc.setDrawData(drawData)\n                rawFunc.setRawPoints(wPoints)\n            end\n\n            return userFunc\n        end\n        function self.createButton(bx, by, bz)\n            local buttonTemplate,button = createUITemplate(bx, by, bz)\n            local userFunc = buttonTemplate.user\n            local rawFunc = buttonTemplate.raw\n            function userFunc.setText(text, rx, ry, rz)\n                local textFuncs = self.createText(bx+rx, by+ry, bz+rz,1)\n                textFuncs.setData(text)\n                \n                textFuncs.build(false, false)\n                return textFuncs\n            end\n            return userFunc\n        end\n        \n        function self.createProgressBar(ex, ey, ez)\n            \n            local outlineTemplate,outline = createUITemplate(ex, ey, ez)\n            local fillTemplate,fill = createUITemplate(ex, ey, ez, 1)\n            \n            local userFuncOut = outlineTemplate.user\n            local rawFuncOut = outlineTemplate.raw\n            \n            local userFuncFill = fillTemplate.user\n            local rawFuncFill = fillTemplate.raw\n            \n            local sPointIndices = {}\n            local ePointIndices = {}\n            local intervals = {}\n            local progress = 100\n            \n            function userFuncOut.getIntervals()\n                return intervals\n            end\n            \n            function userFuncOut.getProgress(pX)\n                local points = rawFuncFill.getRawPoints()\n                if pX then\n                    local c = intervals[1]\n                    local xC = c[1]\n                    \n                    local prog = (pX - points[sPointIndices[1]])/xC\n                    if prog < 0 then \n                        return 0.001 \n                    elseif prog > 100 then \n                        return 100 \n                    else \n                        return prog \n                    end\n                end\n                return progress\n            end\n            \n            local function makeIntervals()\n                \n                local sPCount = #sPointIndices\n                local ePCount = #ePointIndices\n                \n                local points = rawFuncFill.getRawPoints()\n                if sPCount == ePCount then\n                    for i=1, sPCount do\n                        local sPI = sPointIndices[i]\n                        local ePI = ePointIndices[i]\n                        \n                        local xChangePercent = (points[ePI]-points[sPI]) * 0.01\n                        local yChangePercent = (points[ePI+1]-points[sPI+1]) * 0.01\n                        local zChangePercent = (points[ePI+2]-points[sPI+2]) * 0.01\n                        intervals[i] = {xChangePercent,yChangePercent,zChangePercent}\n                    end\n                else\n                    --print(\"ERROR: Must have a 1:1 relationship of start and end points.\")\n                end\n            end\n            \n            function userFuncOut.setStartPoints(startPoints, order)\n                local sPIndicesAdded = userFuncFill.addPoints(startPoints)\n                if order then\n                    for i = 1, #order do\n                        sPointIndices[i] = sPIndicesAdded[order[i]]\n                    end\n                else\n                    sPointIndices = sPIndicesAdded\n                end\n                makeIntervals()\n            end\n            \n            function userFuncOut.setEndPoints(endPoints, order)\n                local ePIndicesAdded = userFuncFill.addPoints(endPoints)\n                if order then\n                    for i = 1, #order do\n                        ePointIndices[i] = ePIndicesAdded[order[i]]\n                    end\n                else\n                    ePointIndices = ePIndicesAdded\n                end\n                makeIntervals()\n            end\n            \n            function userFunc.addText(text, rx, ry, rz)\n                local textFuncs = self.createText(ex+rx, ey+ry, ez+rz,1)\n                textFuncs.setData(text)\n                \n                textFuncs.build(false, false)\n                return textFuncs\n            end\n            \n            function userFuncOut.updateProgress(prog)\n                progress = prog or 0\n                local points = rawFuncFill.getRawPoints()\n                \n                for i=1, #ePointIndices do\n                    local c = intervals[i]\n                    local xC,yC,zC = c[1],c[2],c[3]\n                    local sPI = sPointIndices[i]\n                    local ePI = ePointIndices[i]\n                    \n                    points[ePI] = points[sPI] + xC * progress\n                    points[ePI+1] = points[sPI+1] + yC * progress\n                    points[ePI+2] = points[sPI+2] + zC * progress\n                    \n                end\n                userFuncOut.build(true)\n                userFuncFill.build(true)\n            end\n            \n            return userFuncOut,userFuncFill\n        end\n        local function getRectangle(width,height)\n            local height = height*0.5\n            local length = width*0.5\n            return {{-length,0,height}, {-length,0,-height}, {length,0,-height}, {length,0,height}}\n        end\n        function self.createTableDraw(tx, ty, tz)\n            local tableTemplate = createUITemplate(tx, ty, tz)\n            \n            local userFuncOut = tableTemplate.user\n            local rawFuncOut = tableTemplate.raw\n            \n            local columns = {}\n            local c = 1\n            local heightOffset = 0\n            local wO = 0\n            \n            local function createEntry(x,y,z,w,h,text,fontSize,data,hA,cA)\n                local txt = Text(text,fontSize,textAlignments.middle, textAlignments.middle)\n                local button = self.createButton(x, y, z)\n                \n                button.setDefaultDraw('<path stroke-width=\"%gpx\" stroke=\"%s\" fill=\"%s\" d=\"M%g %g L%g %g L%g %g L%g %g Z\"/>')\n                button.setHoverAction(hA)\n                button.setClickAction(cA)\n                button.setText(txt,0,-0.005,0)\n                button.setDrawData(data)\n                button.addPoints(getRectangle(w, h))\n                button.build()\n                return button\n            end\n            \n            function columns.addColumn(name, w, h)\n                columns[c] = {name, w, h, {}}\n                c=c+1\n                createEntry(tx+wO,ty,tz,w,h,name,h*0.9,{0.01, 'black', 'green'},hoverAction,clickAction)\n                if heightOffset == 0 then\n                    heightOffset = heightOffset - h*0.5\n                end\n                wO = wO + w\n            end\n            local notAdded = true\n            function columns.addRow(row, h, stroke, strokeWidth, fill, clickAction, hoverAction)\n                local widthOffset = 0\n                local visible = true\n                if notAdded then\n                heightOffset = heightOffset - h*0.5\n                    notAdded = false\n                end\n                for i=1, #columns do\n                    local entry = row[i]\n                    local column = columns[i]\n                    local w = column[2]\n                    \n                    local rows = column[4]\n                    rows[#rows+1] = {createEntry(tx+widthOffset,ty,tz+heightOffset,w,h,entry,h*0.9,{strokeWidth, stroke, fill},hoverAction,clickAction), w, h}\n                    widthOffset = widthOffset + w\n                end\n                heightOffset = heightOffset - h\n                function row.hide()\n                    if visible then\n                    end\n                end\n                function row.show()\n                    if not visible then\n                    end\n                end\n            end\n            return columns\n        end\n        function self.createCustomDraw(center)\n            local self = {}\n            return self\n        end\n        function self.createSlider(uiElement, center)\n            local self = {}\n            return self\n        end\n        return self\n    end\n    \n    function self.rotateHeading(heading) self[10][2]=self[10][2]+rad(heading) end\n    function self.rotatePitch(pitch) self[10][1]=self[10][1]+rad(pitch) end\n    function self.rotateRoll(roll) self[10][3]=self[10][3]+rad(roll) end\n    function self.setPosition(posX, posY, posZ) self[11] = {posX, posY, posZ} end\n    \n    function self.addSubObject(object, id)\n        local id=id or #self[6]+1\n        self[6][id]=object\n        return id\n    end\n    function self.removeSubObject(id)\n        self[6][id]={}\n    end\n    \n    function self.setSubObjects()\n        local self={}\n        local c=1\n        function self.addSubObject(object)\n            self[6][c]=object\n            c=c+1\n            return self\n        end\n        return self\n    end\n    \n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self={}\n    function self.setStyle(style)\n        local self={}\n        local style=style\n        function self.setPosition(pos)\n            local self={}\n            local pos=pos\n            function self.setOffset(offset)\n                local self={}\n                local offset=offset\n                function self.setOrientation(orientation)\n                    local self={}\n                    local orientation=orientation\n                    function self.setPositionType(positionType)\n                        local self={}\n                        local positionType=positionType\n                        function self.setOrientationType(orientationType)\n                            local self={}\n                            local orientationType = orientationType\n                            local transX,transY=nil,nil\n                            function self.setTranslation(translateX,translateY)\n                                transX,transY=translateX,translateY\n                                return self\n                            end\n                            function self.build()\n                                return Object(style,pos,offset,orientation,positionType,orientationType,transX,transY)\n                            end\n                            return self\n                        end\n                        return self\n                    end\n                    return self\n                end\n                return self\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"7"},{"code":"local rad = math.rad\ncameraTypes={\n    fixed={\n        fLocal={\n            name=\"fLocal\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0}\n        },\n        fGlobal={\n            name=\"fGlobal\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,0}\n        }\n    },\n    player={\n        jetpack={\n            name=\"jetpack\",\n            pitchPos=nil,\n            pitchNeg=nil,\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,1.9}\n        },\n        planet={\n            name=\"planet\",\n            pitchPos=rad(75),\n            pitchNeg=rad(-75),\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,1.85}\n        },\n        construct={\n            name=\"construct\",\n            pitchPos=rad(75),\n            pitchNeg=rad(-75),\n            headingPos=nil,\n            headingNeg=nil,\n            shift={0,0,1.8}\n        },\n        chair={\n            firstPerson={\n                mouseControlled={\n                    name=\"chairfp_mouse\",\n                    pitchPos=nil,\n                    pitchNeg=nil,\n                    headingPos=nil,\n                    headingNeg=nil,\n                    shift={-0.1,0,0.65}\n                },\n                freelook={\n                    name=\"chairfp_free\",\n                    pitchPos=rad(75),\n                    pitchNeg=rad(-75),\n                    headingPos=rad(95),\n                    headingNeg=rad(-95),\n                    shift={-0.1,0,0.65}\n                }\n            },\n            secondPerson={\n                name=\"chairsp\",\n                pitchPos=0,\n                pitchNeg=0,\n                headingPos=0,\n                headingNeg=0,\n                shift={0,0,0}\n            },\n            thirdPerson={\n                name=\"chairtp\",\n                pitchPos=rad(84),\n                pitchNeg=rad(-89),\n                headingPos=nil,\n                headingNeg=nil,\n                shift={0,0,0}\n            }\n        }\n    }\n}\n\nlocal function getChairPositions()\n    local eL=core.getElementIdList()\n    local eT=core.getElementTypeById\n    local ePos=core.getElementPositionById\n    local cOff=cOff\n    local pL={}\n    local c=1\n    for i=1, #eL do\n        local el=eT(eL[i])\n        if el==\"Gunner Module\" then\n            pL[c]=ePos(eL[i])\n            c=c+1\n        end\n        if el==\"Command Seat Controller\" then\n            pL[c]=ePos(eL[i])\n            c=c+1\n        end\n        if el==\"Wooden Chair\" then\n            pL[c]=ePos(eL[i])\n            c=c+1\n        end\n        if el==\"Hovercraft Seat Controller\" then\n            pL[c]=ePos(eL[i])\n            c=c+1\n        end\n    end\n    return pL\nend\n\nfunction Camera(camType, position, orientation)\n    local core=core\n    local system=system\n    local unit=unit\n    local planetaryInfluence=unit.getClosestPlanetInfluence\n    \n    local isViewLocked = false\n    \n    local print,types,rad,abs=system.print,cameraTypes,math.rad,math.abs\n    local chairs = getChairPositions()\n    local position = {position[1], position[2], position[3]}\n    local self = {\n        cType = camType,\n        position = position, \n        orientation = {rad(orientation[1]), rad(orientation[2]), rad(orientation[3])},\n        isViewLocked = isViewLocked,\n        cameraShift\n    }\n    \n    function self.rotateHeading(heading) self.orientation[2]=self.orientation[2]+rad(heading) end\n    function self.rotatePitch(pitch) self.orientation[1]=self.orientation[1]+rad(pitch) end\n    function self.rotateRoll(roll) self.orientation[3]=self.orientation[3]+rad(roll) end\n    function self.setAlignmentType(alignmentType) self.cType = alignmentType end\n    function self.setPosition(pos) self.position={pos[1],pos[2],pos[3]} end\n    function self.setViewLock(isViewLocked) self.isViewLocked = isViewLocked end\n    \n    function self.getAlignmentType(ax,ay,az,aw,bodyX,bodyY,bodyZ)\n        local playerType=types.player\n        local alignmentType=playerType.construct\n        if self.cType.name==\"fLocal\" then\n            alignmentType=types.fixed.fLocal\n            return alignmentType\n        elseif self.cType.name==\"fGlobal\" then\n            alignmentType=types.fixed.fGlobal\n            return alignmentType\n        end\n        if ax~=nil then\n            if ax>0.001 or ax<-0.001 or ay>0.001 or ay<-0.001 then alignmentType=playerType.jetpack end\n            if planetaryInfluence() > 0.85 then alignmentType=playerType.planet end\n        \n            local chairs=chairs\n            local abs=abs\n            for i=1,#chairs do\n                local chairPos=chairs[i]\n                local difX=abs(chairPos[1]-bodyX)\n                local difY=abs(chairPos[2]-bodyY)\n                local difZ=abs(chairPos[3]-bodyZ)\n\n                if difX<0.4 and difY<0.4 and difZ<0.4 then\n                    local switch=switched%3\n                    if switch==0 then\n                        local fp=playerType.chair.firstPerson\n                        if self.isViewLocked then\n                            alignmentType=fp.mouseControlled\n                        else\n                            alignmentType=fp.freelook\n                        end\n                        return alignmentType\n                    elseif switch==1 then\n                        alignmentType=playerType.chair.thirdPerson\n                        return alignmentType\n                    elseif switch==2 then\n                        alignmentType=playerType.chair.secondPerson\n                        return alignmentType\n                    end\n                end\n            end\n        end\n        switched=0\n        return alignmentType\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"8"},{"code":"function getManager()\n    local self = {}\n    -- Misc function calls\n    local solve=library.systemResolution3\n    local sqrt,atan,asin,acos,print=math.sqrt,math.atan,math.asin,math.acos,system.print\n    \n    --- Core-based function calls\n    local gCWOR,gCWOF,gCWOU,gCLOR,gCLOF,gCLOU,gCWR,gCWF,gCWU=core.getConstructWorldOrientationRight,core.getConstructWorldOrientationForward,core.getConstructWorldOrientationUp,core.getConstructOrientationRight,core.getConstructOrientationForward,core.getConstructOrientationUp,core.getConstructWorldRight,core.getConstructWorldForward,core.getConstructWorldUp\n    local gWTLC,gLTWC=nil,nil\n    \n    function self.getLocalToWorldConverter()\n        local s=solve\n        local r,f,u=gCWR(),gCWF(),gCWU()\n        local tr = {r[1],f[1],u[1]}\n        local tf = {r[2],f[2],u[2]}\n        local tu = {r[3],f[3],u[3]}\n        return function(c)\n            return s(tr, tf, tu, c)  \n        end\n    end\n\n    function self.getWorldToLocalConverter()\n        local xM,yM,zM=gCWR(),gCWF(),gCWU()\n        local s = solve\n        return function(w) return solve(xM,yM,zM,w) end\n    end\n    function self.quatToAxisAngle(ax,ay,az,aw)\n        local awaw = 1/sqrt(1-aw*aw)\n\n        return ax*awaw, ay*awaw, az*awaw, 2*acos(aw)\n    end\n    local function matrixToQuat(m11,m21,m31,m12,m22,m32,m13,m23,m33)\n        local t=m11+m22+m33\n        if t>0 then\n            local s=0.5/sqrt(t+1)\n            return (m32-m23)*s,(m13-m31)*s,(m21-m12)*s,0.25/s\n        elseif m11>m22 and m11>m33 then\n            local s = 2*sqrt(1+m11-m22-m33)\n            return 0.25*s,(m12+m21)/s,(m13+m31)/s,(m32-m23)/s\n        elseif m22>m33 then\n            local s=2*sqrt(1+m22-m11-m33)\n            return (m12+m21)/s,0.25*s,(m23+m32)/s,(m13-m31)/s\n        else\n            local s=2*sqrt(1+m33-m11- m22)\n            return (m13+m31)/s,(m23+m32)/s,0.25*s,(m21-m12)/s\n        end\n    end\n    \n    function self.getPlayerLocalRotation()\n        local fwd = unit.getMasterPlayerForward()\n        local right = unit.getMasterPlayerRight()\n        local up = unit.getMasterPlayerUp()\n\n        return matrixToQuat(right[1],right[2],right[3],fwd[1],fwd[2],fwd[3],up[1],up[2],up[3])\n    end\n    \n    \n    function self.rotMatrixToQuat(rM)\n        return matrixToQuat(rM[1],rM[5],rM[9],rM[2],rM[6],rM[10],rM[3],rM[7],rM[11])\n    end\n    function self.inverse(qX,qY,qZ,qW)\n        return -qX,-qY,-qZ,qW\n    end\n    function self.inverseMulti(ax,ay,az,aw,bx,by,bz,bw)\n        local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n        return bx*(awaw-axax-ayay-azaz)+2*aw*(ax*bw+ay*bz-az*by),2*(bx*(aw*az+ax*ay)+bz*(ay*az-aw*ax))+by*(awaw-axax+ayay-azaz),2*(bx*(ax*az-aw*ay)+by*(ax*aw+ay*az))+bz*(awaw-axax-ayay+azaz),bw*(awaw+axax+ayay+azaz)\n    end\n    function self.transPoint3D(ax,ay,az,aw,bx,by,bz)\n        local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n        return \n        2*(by*(ax*ay-aw*az)+bz*(ax*az+aw*ay))+bx*(awaw+axax-ayay-azaz),\n        2*(bx*(aw*az+ax*ay)+bz*(ay*az-aw*ax))+by*(awaw-axax+ayay-azaz),\n        2*(bx*(ax*az-aw*ay)+by*(ax*aw+ay*az))+bz*(awaw-axax-ayay+azaz)\n    end\n    \n    function self.transPoints3D(ax,ay,az,aw,points)\n        \n        local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n        \n        -- What I derived\n        local a,b,c = (awaw+axax-ayay-azaz), 2*(ax*ay-aw*az), 2*(ax*az+aw*ay)\n        local d,f,e = 2*(aw*az+ax*ay), (awaw-axax+ayay-azaz), 2*(ay*az-aw*ax)\n        local g,h,i = 2*(ax*az-aw*ay), 2*(ax*aw+ay*az), (awaw-axax-ayay+azaz)\n        \n        local pts={}\n        for i=1,#points,3 do\n            local x,y,z=points[i],points[i+1],points[i+2]\n            pts[i]=x*a+y*b+z*c\n            pts[i+1]=x*d+y*e+z*f\n            pts[i+2]=x*g+y*h+z*i\n        end\n        return pts\n    end\n    function self.transPoints2D(ax,ay,az,aw,points)\n        local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n        local b,c=2*(ax*az+aw*ay),(awaw+axax-ayay-azaz)\n        local d,e=2*(aw*az+ax*ay),2*(ay*az-aw*ax)\n        local g,i=2*(ax*az-aw*ay),(awaw-axax-ayay+azaz)\n        local pts={}\n        for i=1,#points,3 do\n            local x,z=points[i],points[i+2]\n            pts[i]=x*c+z*b\n            pts[i+1]=x*d+z*e\n            pts[i+2]=x*g+z*i\n        end\n        return pts\n    end\n    function self.transPoint2D(ax,ay,az,aw,x,y)\n        local axax,ayay,azaz,awaw=ax*ax,ay*ay,az*az,aw*aw\n        return 2*z*(ax*az+aw*ay)+x*(awaw+axax-ayay-azaz),2*(x*(aw*az+ax*ay)+z*(ay*az-aw*ax)),2*x*(ax*az-aw*ay)+z*(awaw-axax-ayay+azaz)\n    end\n    gWTLC,gLTWC=self.getWorldToLocalConverter,self.getLocalToWorldConverter\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"9"},{"code":"function Waypoint(x,y,z, radius, name, subId)\n    local sqrt,ceil,floor,max=math.sqrt,math.ceil,math.floor,math.max\n    local function round(value, precision)\n        local value = value/precision\n        local value = value >= 0 and floor(value+0.5) or ceil(value-0.5)\n        return value * precision\n    end\n    \n    local getCWorldPos,getCMass = core.getConstructWorldPos,core.getConstructMass\n    \n    local keyframe = 0\n    local self = {\n        radius = radius,\n        x = x,\n        y = y,\n        z = z,\n        name = name,\n        subId = subId,\n        keyframe = keyframe\n    }\n    \n    function self.getWaypointInfo()\n        local tons = getCMass() / 1000\n        local cPos = getCWorldPos()\n        local px,py,pz = self.x-cPos[1], self.y-cPos[2], self.z-cPos[3]\n        local distance = sqrt(px*px + py*py + pz*pz)\n        local warpCost = max(floor(tons*floor(((distance/1000)/200))*0.00024), 1)\n        local name = self.name\n        \n        return name, round((distance/1000)/200, 0.01), warpCost,round((distance/1000), 0.01),round(distance, 0.01)\n    end\n    return self\nend","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"10"}],"methods":[],"events":[]}
