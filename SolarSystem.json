{
  "slots": {
    "0": {
      "name": "core",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "slot2",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "slot3",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "slot4",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "\nwaypoint = false\nlocal planetInfo = {\n  {name = \"Madis\", center = {17465536,22665536,-34464}, radius=44300},\n  {name = \"Alioth\", center = {-8,-8,-126303}, radius=126068},\n  {name = \"Thades\", center = {29165536,10865536,65536}, radius=49000},\n  {name = \"Talemai\", center = {-13234464,55765536,465536}, radius=57450},\n  {name = \"Feli\", center = {-43534464,22565536,-48934464}, radius=60000},\n  {name = \"Sicari\", center = {52765536,27165538,52065535}, radius=51100},\n  {name = \"Sinnen\", center = {58665538,29665535,58165535}, radius=54950},\n  {name = \"Teoma\", center = {80865538,54665536,-934463.94}, radius=62000},\n  {name = \"Jago\", center = {-94134462,12765534,-3634464}, radius=61590},\n  {name = \"Lacobus\", center = {98865536,-13534464,-934461.99}, radius=55650},\n  {name = \"Symeon\", center = {14165536,-85634465,-934464.3}, radius=49050},\n  {name = \"Ion\", center = {2865536.7,-99034464,-934462.02}, radius=44950}\n}\nlocal sqrt = math.sqrt\nlocal position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal orientation = {0,0,0}\nlocal width = system.getScreenWidth() / 2\nlocal height = system.getScreenHeight() / 2\nlocal objectBuilder = ObjectBuilderLinear()\n\nlocal camera = Camera(cameraTypes.player.construct, {0,0,0}, {0,0,0})\ncamera.setViewLock(true)\nprojector = Projector(core, camera)\nfontsize = 20 --export: font size\ncolorWarp = \"#ADD8E6\"\nnonWarp = \"#FFA500\"\nlocal planets = {}\n\nlocal warp = objectBuilder\n\t\t\t\t.setStyle(\"Warp\")\n\t\t\t\t.setPosition({0,0,0})\n\t\t\t\t.setOffset({0,0,0})\n\t\t\t\t.setOrientation({0,0,0})\n\t\t\t\t.setPositionType(positionTypes.globalP)\n\t\t\t\t.setOrientationType(orientationTypes.globalP)\n\t\t\t\t.build()\nlocal notwarp = objectBuilder\n\t\t\t\t.setStyle(\"NotWarp\")\n\t\t\t\t.setPosition({0,0,0})\n\t\t\t\t.setOffset({0,0,0})\n\t\t\t\t.setOrientation({0,0,0})\n\t\t\t\t.setPositionType(positionTypes.globalP)\n\t\t\t\t.setOrientationType(orientationTypes.globalP)\n\t\t\t\t.build()\nprojector.addObject(warp)\nprojector.addObject(notwarp)\n\n\nlocal function drawText(svg, c, x, y, text, opacity)\n    svg[c] = '<text x=\"'\n    svg[c+1] = x\n    svg[c+2] = '\" y=\"'\n    svg[c+3] = y\n    svg[c+4] = '\" fill-opacity=\"'\n    svg[c+5] = opacity\n    svg[c+6] = '\" stroke-opacity=\"'\n    svg[c+7] = opacity\n    svg[c+8] = '\">'\n    svg[c+9] = text\n    svg[c+10] = '</text>'\n    return c+11\nend\nlocal function drawHorizontalLine(svg, c, x, y, length, thickness)\n    svg[c] = '<path fill=\"none\" stroke-width=\"'\n    svg[c+1] = thickness\n    svg[c+2] = '\" d=\"M'\n    svg[c+3] = x\n    svg[c+4] = ' '\n    svg[c+5] = y\n    svg[c+6] = ' h '\n    svg[c+7] = length\n    svg[c+8] = '\"/>'\n    return c+9\nend\nlocal maxD = sqrt(width*width + height*height)\nlocal function drawInfo(svg, c, tx, ty, data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local font = data.fontsize\n    local name,distance,warpCost = data.getPlanetInfo()\n    local keyframe = data.keyframe\n\n    if distance > 500 then\n        local id = data.subId\n        local d = notwarp.addSubObject(planets[id][2], id)\n        warp.removeSubObject(id)\n    else\n        local id = data.subId\n        warp.addSubObject(planets[id][2], id)\n        notwarp.removeSubObject(id)\n    end\n    c = drawHorizontalLine(svg, c, tx, ty + 3, string.len(name)*font, 2)\n    c = drawText(svg, c, tx, ty, name, 1)\n    \n    if distanceToMouse < 200 then\n        if keyframe < 6 then\n            data.keyframe = keyframe + 1\n        end\n    else\n        if keyframe ~= 0 then\n            data.keyframe = keyframe - 1\n        end\n    end\n    local opacity = keyframe/6\n    if distanceToMouse < 25 and waypoint then\n        system.setWaypoint('::pos{0,0,' .. data.x ..',' .. data.y .. ',' .. data.z ..'}')\n        waypoint = false\n    end\n    if keyframe > 0 then\n        c = drawText(svg, c, tx + 60 - keyframe*10, ty+font+5, distance .. ' SU', opacity)\n        c = drawText(svg, c, tx + 60 - keyframe*10, ty+(font+5)*2, warpCost .. ' Warp Cells', opacity)\n    end\n    return c\nend\nlocal function draw(svg,c,object,tx,ty,tz,data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local size = projector.getSize(data.radius, tz, 100000000, 10)\n    if size > 300 or distanceToMouse > maxD then\n        return c\n    end\n    svg[c] = '<circle cx=\"'\n    svg[c+1] = tx\n    svg[c+2] = '\" cy=\"'\n    svg[c+3] = ty\n    svg[c+4] = '\" r=\"'\n    svg[c+5] = size\n    svg[c+6] = '\" fill=\"none\"/>'\n    c=c+7\n    c=drawInfo(svg, c, tx + size + 5, ty - size + 5, data)\n    return c\nend\n\nfor ii = 1, #planetInfo do\n    local pDat = planetInfo[ii]\n    local pCenter = pDat.center\n    local pName = pDat.name\n    local pColor = pDat.color\n    local pRadius = pDat.radius\n    local planet = objectBuilder\n\t\t\t\t.setStyle(pName)\n\t\t\t\t.setPosition({0,0,0})\n\t\t\t\t.setOffset({0,0,0})\n\t\t\t\t.setOrientation({0,0,0})\n\t\t\t\t.setPositionType(positionTypes.globalP)\n\t\t\t\t.setOrientationType(orientationTypes.globalP)\n\t\t\t\t.build()\n    local subId = warp.addSubObject(planet)\n    local nsubId = notwarp.addSubObject(planet)\n    notwarp.removeSubObject(nsubId)\n    local planetObject = PlanetObject(pCenter[1],pCenter[2],pCenter[3], pRadius * 1.25, pName, pColor, fontsize, subId)\n    local customSVG = planet.setCustomSVGs(1, pName).addSinglePointSVG()\n    planets[ii] = {planetObject, planet}\n    customSVG.setPosition({pCenter[1], pCenter[2], pCenter[3]})\n    \t    .setData(planetObject)\n    \t    .setDrawFunction(draw)\n    \t    .build()\nend\n\n\nunit.setTimer(\"fixed_1\", 1/1000) --The timer to update the camera\nunit.setTimer(\"update\", 1/1000) -- The timer to update the screen\nsystem.showScreen(1)\nunit.hide()",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "local svg, index = projector.getSVG()\n\nlocal width = system.getScreenWidth()\nlocal height = system.getScreenHeight()\nlocal fontsize = fontsize\nsvg[index] =\n'<style>svg{ width:'..width ..'px; height:'..height ..'px; position:absolute; top:0px; left:0px;}' .. [[\n.NotWarp{filter: drop-shadow(0 0 0.5rem ]] .. nonWarp .. '); stroke: ' .. nonWarp .. '; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: ' .. fontsize .. 'px;}' ..\n'.Warp{filter: drop-shadow(0 0 0.5rem ' .. colorWarp .. '); stroke: ' .. colorWarp .. '; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: ' .. fontsize .. 'px;}' .. '</style>'\nlocal rendered = table.concat(svg)\nsystem.setScreen(rendered)\n--slot2.setHTML(rendered)",
      "filter": {
        "args": [
          {
            "value": "update"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "projector.updateCamera()",
      "filter": {
        "args": [
          {
            "value": "fixed_1"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "waypoint = true",
      "filter": {
        "args": [
          {
            "value": "option1"
          }
        ],
        "signature": "actionStart(action)",
        "slotKey": "-2"
      },
      "key": "3"
    },
    {
      "code": "function Projector(core, camera)\n    -- Localize frequently accessed data\n    local library = library\n    local core = core\n    local unit = unit\n    local system = system\n    local manager = getManager()\n    \n    -- Localize frequently accessed functions\n    --- Library-based function calls\n    local solve = library.systemResolution3\n    \n    --- System-based function calls\n    local getWidth = system.getScreenWidth\n    local getHeight = system.getScreenHeight\n    local getFov = system.getFov\n    local getMouseDeltaX = system.getMouseDeltaX\n    local getMouseDeltaY = system.getMouseDeltaY\n    local getPlayerWorldPos = system.getPlayerWorldPos\n    local print = system.print\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    local getElementRotationById = core.getElementRotationById\n    \n    --- Unit-based function calls\n    local getRelativeOrientation = unit.getMasterPlayerRelativeOrientation\n    \n    --- Camera-based function calls\n    local getAlignmentType = camera.getAlignmentType\n    \n    --- Manager-based function calls\n    ---- Positional Operations\n    local getLocalToWorldConverter = manager.getLocalToWorldConverter\n    local getWorldToLocalConverter = manager.getWorldToLocalConverter\n    local getTrueWorldPos = manager.getTrueWorldPos\n    local getPlayerLocalPos = manager.getPlayerLocalPos\n    ---- Quaternion operations\n    local rotToQuat = manager.rotationMatrixToQuaternion\n    local rotToEuler = manager.rotationMatrixToEuler\n    local inverse = manager.inverse\n    local multiply = manager.multiply\n    local divide = manager.divide\n    \n    -- Localize Math functions\n    local sin, cos, tan = math.sin, math.cos, math.tan\n    local rad, deg, sqrt = math.rad, math.deg, math.sqrt\n    local atan = math.atan\n\n    -- Projection infomation\n    --- Screen Parameters\n    local width = getWidth()/2\n    local height = getHeight()/2\n\n    --- FOV Paramters\n    local hfovRad = rad(getFov());\n    local fov = 2*atan(tan(hfovRad/2)*height,width)\n\n    --- Matrix Subprocessing\n    local tanFov = tan(fov/2)\n    local aspect = width/height\n    local near = width/tanFov\n    local top = near * tanFov\n    local bottom = -top;\n    local left = bottom * aspect\n    local right = top * aspect\n\n    --- Matrix Paramters\n    local x0 = 2 * near / (right - left)\n    local y0 = 2 * near / (top - bottom)\n\n    -- Player-related values\n    local playerId = unit.getMasterPlayerId()\n    local unitId = unit.getId()\n    \n    -- Camera-Related values\n    local eye = camera.position\n    local cOrientation = camera.orientation\n    local cameraType = camera.cType\n    local alignmentType = nil\n    \n    --- Mouse info\n    local sensitivity = 1 -- export: Sensitivtiy\n    local m = sensitivity*(width*2)*0.00104584100642898 + 0.00222458611638299\n    local bottomLock = false\n    local topLock = false\n    local rightLock = false\n    local leftLock = false\n\n    local self = {}\n    local objects = {}\n\n    function self.getSize(size, zDepth, max, min)\n        local pSize = atan(size, zDepth) * (near / aspect)\n        local max = max or pSize\n        if pSize >= max then\n            return max\n        elseif pSize <= min then\n            return min\n        else\n            return pSize\n        end\n    end\n    \n    function self.updateCamera()\n        if cameraType.name ~= \"fGlobal\" and cameraType.name ~= \"fLocal\" then\n            \n            -- Localize variables\n            local atan = atan\n            \n            eye = getPlayerLocalPos(playerId)\n\n            local deltaMouseY = getMouseDeltaY()\n            local deltaMouseX = getMouseDeltaX()\n            local width = width\n            local deltaPitch = atan(-deltaMouseY/width) * m\n            local deltaHeading = atan(deltaMouseX/width) * m\n        \n            local pPitch = cOrientation[1]\n            local pHeading = cOrientation[2]\n            \n            local alignmentType = alignmentType\n            if alignmentType == nil then\n                alignmentType = getAlignmentType()\n            end\n            --print(alignmentType.name)\n            local pitchPos = alignmentType.pitchPos\n            local pitchNeg = alignmentType.pitchNeg\n            local headingPos = alignmentType.headingPos\n            local headingNeg = alignmentType.headingNeg\n            \n            if pitchPos ~= nil then\n                if (bottomLock == false and topLock == false) then  \n                    pPitch = pPitch + deltaPitch\n                    if pPitch <= pitchNeg then\n                        pPitch = pitchNeg\n                        bottomLock = true\n                    end\n                    if pPitch >= pitchPos then\n                        pPitch = pitchPos\n                        topLock = true\n                    end\n                else\n                    if bottomLock == true and deltaMouseY < 0 then\n                        bottomLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                    if topLock == true and deltaMouseY > 0 then\n                        topLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                end\n                cOrientation[1] = pPitch\n            else\n                cOrientation[1] = 0\n            end\n            if headingPos ~= nil then\n                if (leftLock == false and rightLock == false) then  \n                    pHeading = pHeading + deltaHeading\n                    if pHeading <= headingNeg then\n                        pHeading = headingNeg\n                        leftLock = true\n                    end\n                    if pHeading >= headingPos then\n                        pHeading = headingPos\n                        rightLock = true\n                    end\n                else\n                    if rightLock == true and deltaMouseX < 0 then\n                        rightLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                    if leftLock == true and deltaMouseX > 0 then\n                        leftLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                end\n                cOrientation[2] = pHeading\n            else\n                cOrientation[2] = 0\n            end\n        end\n    end\n\n    function self.addObject(object)\n        local index = #objects + 1\n        objects[index] = object\n        return index\n    end\n\n    function self.removeObject(id)\n    \tobjects[id] = {}\n    end\n    \n    function self.getModelMatrices(mObject)\n        \n        local s = sin\n        local c = cos\n        local multi = multiply\n        local inverse = inverse\n        local modelMatrices = {}\n        \n        -- Localize Object values.\n        local obj = mObject\n        local objOriType = obj.orientationType\n        local objOri = obj.orientation\n        local objPosType = obj.positionType\n        local objPos = obj.position\n        local objPosX,objPosY,objPosZ = objPos[1],objPos[2],objPos[3]\n        \n        local cU = getCWorldOriU()\n        local cUX,cUY,cUZ = cU[1],cU[2],cU[3]\n        local cF = getCWorldOriF()\n        local cFX,cFY,cFZ = cF[1],cF[2],cF[3]\n        local cR = getCWorldOriR()\n        local cRX,cRY,cRZ = cR[1],cR[2],cR[3]\n        \n        local sx,sy,sz,sw = rotToQuat({cRX,cRY,cRZ,0,cFX,cFY,cFZ,0,cUX,cUY,cUZ,0,0,0,0,1})\n        \n        local recurse = {}\n        local ct = 2\n        function recurse.subObjectMatrices(lx, ly, lz, lw, sObjX, sObjY, sObjZ, object, posLX, posLY, posLZ)\n            local objPos = object.position\n            local objRot = object.orientation\n            local objRotType = object.orientationType\n            local objX,objY,objZ = objPos[1],objPos[2],objPos[3]\n            \n            local objP,objH,objR = objRot[1] / 2,objRot[2] / 2,objRot[3] / 2\n            local sP,sH,sR = s(objP),s(objR),s(objH)\n            local cP,cH,cR = c(objP),c(objR),c(objH)\n    \n            local wwx = sP*cH*cR - cP*sH*sR\n            local wwy = cP*sH*cR + sP*cH*sR\n            local wwz = cP*cH*sR - sP*sH*cR\n            local www = cP*cH*cR + sP*sH*sR\n            local wx, wy, wz, ww = wwx,wwy,wwz,www\n\n            local lix, liy, liz, liw = inverse(lx, ly, lz, lw)\n            \n            local posTX, posTY, posTZ, posTW = multi(lx, ly, lz, lw, objX, objY, objZ, 0)\n\n            local posIX = -posTX*liw + posTW*lix - posTY*liz - posTZ*liy\n            local posIY = posTY*liw + posTW*liy + posTZ*lix - posTX*liz\n            local posIZ = -posTZ*liw + posTW*liz + posTX*liy + posTY*lix\n\n            if object.positionType == \"local\" then\n                local dotX = cRX*posIX + cFX*posIY + cUX*posIZ\n                local dotY = cRY*posIX + cFY*posIY + cUY*posIZ\n                local dotZ = cRZ*posIX + cFZ*posIY + cUZ*posIZ\n                posIX = dotX\n                posIY = dotY\n                posIZ = dotZ\n            end\n            posIX, posIY, posIZ = posIX + posLX, posIY + posLY, posIZ + posLZ\n            \n            if objRotType == \"local\" then\n                wx, wy, wz, ww = multi(wx, wy, wz, ww, sx, sy, sz, sw)\n            end\n            local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n            local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n            local wzwz,wzww = wz*wz,wz*ww\n            local a1 = 1 - 2*(wywy + wzwz)\n            local b1 = 2*(wxwy - wzww)\n            local c1 = 2*(wxwz + wyww)\n    \n            local d1 = 2*(wxwy + wzww)\n            local e1 = 1 - 2*(wxwx + wzwz)\n            local f1 = 2*(wywz - wxww)\n    \n            local g1 = 2*(wxwz - wyww)\n            local h1 = 2*(wywz + wxww)\n            local i1 = 1 - 2*(wxwx + wywy)\n            \n            modelMatrices[ct] = {\n                object,\n                {\n                    a1, -d1, -g1, posIX,\n                    -b1, e1, h1, -posIY,\n                    -c1, f1, i1, -posIZ,\n                    0, 0, 0, 1\n                }\n\n            }\n            ct=ct+1\n            \n            local subObjects = object.subObjects\n            if #subObjects > 0 then\n                for k = 1, #subObjects do\n                    local subObj = subObjects[k][1]\n                    if subObj~=nil then\n                        recurse.subObjectMatrices(wwx, wwy, wwz, www, objX, objY, objZ, subObj, posIX, posIY, posIZ)\n                    end\n                end\n            end\n        end\n        local pitch,heading,roll = objOri[1] / 2,objOri[2] / 2,objOri[3] / 2\n        \n        --- Quaternion of object rotations\n        local sP,sH,sR = s(pitch),s(roll),s(heading)\n        local cP,cH,cR = c(pitch),c(roll),c(heading)\n    \n        local wwx = (sP*cH*cR - cP*sH*sR)\n        local wwy = (cP*sH*cR + sP*cH*sR)\n        local wwz = (cP*cH*sR - sP*sH*cR)\n        local www = (cP*cH*cR + sP*sH*sR)\n        local wx,wy,wz,ww = wwx,wwy,wwz,www\n        \n        if objOriType == \"local\" then\n            wx,wy,wz,ww = multiply(wx,wy,wz,ww,sx,sy,sz,sw)\n        end\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        if objPosType == \"local\" then\n            local dotX = cRX*objPosX + cFX*objPosY + cUX*objPosZ\n            local dotY = cRY*objPosX + cFY*objPosY + cUY*objPosZ\n            local dotZ = cRZ*objPosX + cFZ*objPosY + cUZ*objPosZ\n            objPosX = dotX\n            objPosY = dotY\n            objPosZ = dotZ\n        else\n            local cWorldPos = getTrueWorldPos()\n            objPosX = objPosX - cWorldPos[1]\n            objPosY = objPosY - cWorldPos[2]\n            objPosZ = objPosZ - cWorldPos[3]\n        end\n        local subObjs = obj.subObjects\n        if #subObjs > 0 then\n            for k = 1, #subObjs do\n                local subObj = subObjs[k][1]\n                if subObj ~= nil then\n                    recurse.subObjectMatrices(wwx,wwy,wwz,www,objPos[1],objPos[2],objPos[3],subObj,objPosX,objPosY,objPosZ)\n                end\n            end\n        end\n        modelMatrices[1] = {obj,{a2, -d2, -g2, objPosX,-b2, e2, h2, -objPosY,-c2, f2, i2, -objPosZ,0, 0, 0, 1}}\n        return modelMatrices\n    end\n\n    function self.getViewMatrix()\n        local multi = multiply\n        local solve = solve\n        \n        local board = getElementRotationById(unitId)\n        local ax,ay,az,aw = board[1],board[2],board[3],board[4]\n        \n        local body = getRelativeOrientation()\n        local bx,by,bz,bw = body[1],body[2],body[3],body[4]\n\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1,v2,v3,{1,0,0})\n        local v2t = solve(v1,v2,v3,{0,1,0})\n        local v3t = solve(v1,v2,v3,{0,0,1})\n        \n        local sx, sy, sz, sw = rotToQuat({v1t[1],v1t[2],v1t[3],0,v2t[1],v2t[2],v2t[3],0,v3t[1],v3t[2],v3t[3],0,0,0,0,1})\n        local lx, ly, lz, lw = rotToQuat({v1[1],v1[2],v1[3],0,v2[1],v2[2],v2[3],0,v3[1],v3[2],v3[3],0,0,0,0,1})\n\n        local eye = eye\n        local eyeX,eyeY,eyeZ = eye[1],eye[2],eye[3]\n        local dotX, dotY, dotZ = eyeX, eyeY, eyeZ\n        local wx, wy, wz, ww = 0,0,0,1\n        local s = sin\n        local c = cos\n        \n        local px, py, pz, pw = multi(ax, ay, az, aw, bx, by, bz, bw)\n        local alignment = getAlignmentType(px, py, pz, pw, eyeX, eyeY, eyeZ)\n        alignmentType = alignment\n        local pix, piy, piz, piw = inverse(px, py, pz, pw)\n        local shift = alignment.shift\n            \n        local eyeTX, eyeTY, eyeTZ, eyeTW = multi(px, py, pz, pw, shift[1], shift[2], shift[3], 0)\n        local eyeIX, eyeIY, eyeIZ, eyeIW = multi(eyeTX, eyeTY, eyeTZ, eyeTW, pix, piy, piz, piw)\n        \n        local alignName = alignment.name\n        local nFG=alignName~=\"fGlobal\"\n        local fG=alignName==\"fGlobal\"\n        local nFL=alignName~=\"fLocal\"\n        local fL=alignName==\"fLocal\"\n        local ori = cOrientation\n        local pitch,roll,heading = ori[1] / 2,0,ori[2] / 2,0\n        if pitch ~= 0 or heading ~= 0 or roll ~= 0 or fG or fL then\n            local sP,sH,sR = s(pitch),s(roll),s(heading)\n            local cP,cH,cR = c(pitch),c(roll),c(heading)\n            \n            local cx = sP*cH*cR - cP*sH*sR\n            local cy = -cP*sH*cR - sP*cH*sR\n            local cz = -cP*cH*sR + sP*sH*cR\n            local cw = cP*cH*cR + sP*sH*sR\n            if nFG and nFL then\n                px,py,pz,pw = multi(px,py,pz,pw,cx,cy,cz,cw)\n\n            elseif alignName == \"fGlobal\" then\n                wx,wy,wz,ww = cx,cy,cz,cw\n            else\n                wx,wy,wz,ww = multi(sx,sy,sz,sw,cx,cy,cz,cw)\n            end\n        end\n        \n        if nFG and nFL then\n            local pxpx,pxpy,pxpz,pxpw = px*px,px*py,px*pz,px*pw\n            local pypy,pypz,pypw = py*py,py*pz,py*pw\n            local pzpz,pzpw = pz*pz,pz*pw\n            \n            local a1 = 1 - 2*(pypy + pzpz)\n            local b1 = 2*(pxpy - pzpw)\n            local c1 = 2*(pxpz + pypw)\n    \n            local d1 = 2*(pxpy + pzpw)\n            local e1 = 1 - 2*(pxpx + pzpz)\n            local f1 = 2*(pypz - pxpw)\n    \n            local g1 = 2*(pxpz - pypw)\n            local h1 = 2*(pypz + pxpw)\n            local i1 = 1 - 2*(pxpx + pypy)\n            eyeX = eyeX - eyeIX\n            eyeY = eyeY + eyeIY\n            eyeZ = eyeZ + eyeIZ\n        \n            dotX = a1*eyeX + -d1*eyeY + -g1*eyeZ\n            dotY = -b1*eyeX + e1*eyeY + h1*eyeZ\n            dotZ = -c1*eyeX + f1*eyeY + i1*eyeZ\n            wx,wy,wz,ww = multi(sx,sy,sz,sw,px,py,pz,pw)\n        end\n        -- Camera rotation determination\n        --- Directly input euler angles in radians\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        --- Matrix of camera rotations, using quaternions\n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        return {a2, -d2, -g2, dotX,-b2, e2, h2, dotY,-c2, f2, i2, dotZ,0, 0, 0, 1}\n    end\n    \n    function self.getSVG()\n        local svg = {}\n        local c = 1\n        local view = self.getViewMatrix()\n\n        local vx1,vy1,vz1,vw1 = view[1],view[2],view[3],view[4]\n        local vx2,vy2,vz2,vw2 = view[5],view[6],view[7],view[8]\n        local vx3,vy3,vz3,vw3 = view[9],view[10],view[11],view[12]\n        \n        local function translate(x,y,z,mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n            local x,y,z = x,-y,-z\n            local px = mXX * x + mXY * y + mXZ * z + mXW\n            local py = mYX * x + mYY * y + mYZ * z + mYW\n            local pz = mZX * x + mZY * y + mZZ * z + mZW\n            local pw = -py\n                \n            -- Convert to window coordinates after W-Divide\n            local wx = (px / pw) * width\n            local wy = (pz / pw) * height\n            return wx, wy, pw\n        end\n        -- Localize projection matrix values\n        local px1 = x0\n        local py2 = 1 --c0\n        local pz3 = y0\n        \n        -- Localize screen info\n        local width = width\n        local height = height\n\n        for i = 1, #objects do\n            \n            local object = objects[i]\n            local objTransX = object.transX or width\n            local objTransY = object.transY or height\n            \n            svg[c] = [[<svg viewBox=\"0 0 ]]\n            svg[c+1] = width*2\n            svg[c+2] = [[ ]]\n            svg[c+3] = height*2\n            svg[c+4] = [[\" class=\"]]\n            svg[c+5] = object.style\n            svg[c+6] = '\"><g transform=\"translate('\n            svg[c+7] = objTransX\n            svg[c+8] = ','\n            svg[c+9] = objTransY\n            svg[c+10] = ')\">'\n            c=c+11\n            local models = self.getModelMatrices(object)\n            \n            -- Localize model matrix values\n            for k = 1, #models do\n                local modelObj = models[k]\n                local object = modelObj[1]\n                local model = modelObj[2]\n                \n                local mx1,my1,mz1,mw1 = model[1],model[2],model[3],model[4]\n                local mx2,my2,mz2,mw2 = model[5],model[6],model[7],model[8]\n                local mx3,my3,mz3,mw3 = model[9],model[10],model[11],model[12]\n                \n                local mXX = px1*(vx1*mx1 + vy1*mx2 + vz1*mx3)\n                local mXY = px1*(vx1*my1 + vy1*my2 + vz1*my3)\n                local mXZ = px1*(vx1*mz1 + vy1*mz2 + vz1*mz3)\n                local mXW = px1*(vw1 + vx1*mw1 + vy1*mw2 + vz1*mw3)\n        \n                local mYX = (vx2*mx1 + vy2*mx2 + vz2*mx3)\n                local mYY = (vx2*my1 + vy2*my2 + vz2*my3)\n                local mYZ = (vx2*mz1 + vy2*mz2 + vz2*mz3)\n                local mYW = (vw2 + vx2*mw1 + vy2*mw2 + vz2*mw3)\n        \n                local mZX = pz3*(vx3*mx1 + vy3*mx2 + vz3*mx3)\n                local mZY = pz3*(vx3*my1 + vy3*my2 + vz3*my3)\n                local mZZ = pz3*(vx3*mz1 + vy3*mz2 + vz3*mz3)\n                local mZW = pz3*(vw3 + vx3*mw1 + vy3*mw2 + vz3*mw3)\n                \n                local polylineGroups = object.polylineGroups\n                local circleGroups = object.circleGroups\n                local curvesGroups = object.curvesGroups\n                local customGroups = object.customGroups\n            \n                -- Polylines for-loop\n                for d=1,#polylineGroups do\n                    local polylineGroup = polylineGroups[d]\n                    svg[c] = '<path class=\"'\n                    svg[c+1] = polylineGroup[1]\n                    svg[c+2] = '\" d=\"'\n                    c = c+3\n                    for f=2,#polylineGroup do\n                        local line = polylineGroup[f]\n                        svg[c] = 'M '\n                        local lC=0\n                        local sP={}\n                        local eP={}\n                        c=c+1\n                        for h = 1, #line do\n                            local p = line[h]\n                            local wx,wy,ww = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n\n                            -- If PW is negative, it means the point is behind you\n                            if ww > 0 then\n                                if lC ~= 0 then\n                                    svg[c] = ' L '\n                                    c = c + 1\n                                    eP = {wx, wy}\n                                else\n                                    sP = {wx, wy}\n                                end\n                                svg[c] = wx\n                                svg[c+1] = ' '\n                                svg[c+2] = wy\n                                c=c+3\n                                lC=lC+1\n                            end\n                        end\n                        if lC < 2 then\n                            if lC == 1 then\n                                svg[c-4] = ''\n                                svg[c-3] = ''\n                                svg[c-2] = ''\n                                svg[c-1] = ''\n                                c=c-4\n                            else\n                                svg[c-1] = ''\n                                c=c-1\n                            end\n                        else\n                            if eP[1] == sP[1] and eP[2] == sP[2] then\n                                svg[c-4] = ' Z '\n                                svg[c-3] = ''\n                                svg[c-2] = ''\n                                svg[c-1] = ''\n                                c=c-3\n                            end\n                        end\n                    end\n                    svg[c] = '\"/>'\n                    c=c+1\n                end\n                for cG=1,#circleGroups do\n                    local circleGroup = circleGroups[cG]\n                    svg[c] = '<g class=\"'\n                    svg[c+1] = circleGroup[1]\n                    svg[c+2] = '\">'\n                    c=c+3\n                    for l=2, #circleGroup do\n                        local circle = circleGroup[l]\n                        local p = circle[1]\n                        \n                        local wx, wy, wz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                        if wz > 0 then\n                            local radius = circle[2]\n                            local fill = circle[3]\n                            local label = circle[4]\n                            local offX = circle[5]\n                            local offY = circle[6]\n                            local action = circle[7]\n                            svg[c] = '<circle cx=\"'\n                            svg[c+1] = wx\n                            svg[c+2] = '\" cy=\"'\n                            svg[c+3] = wy\n                            svg[c+4] = '\" r=\"'\n                            svg[c+5] = radius\n                            svg[c+6] = '\" fill=\"'\n                            svg[c+7] = fill\n                            svg[c+8] = '\"/>'\n                            c = c+9\n                            if label ~= nil then\n                                svg[c] = '<text x=\"'\n                                svg[c+1] = wx + offX\n                                svg[c+2] = '\" y=\"'\n                                svg[c+3] = wy + offY\n                                svg[c+4] = '\">'\n                                svg[c+5] = label\n                                svg[c+6] = '</text>'\n                                c=c+7\n                            end\n                            if action ~= nil then\n                                c = action(svg, c, object, wx, wy, wz)\n                            end\n                        end\n                    end\n                    svg[c] = '</g>'\n                    c=c+1\n                end\n                for cG = 1, #customGroups do\n                    local customGroup = customGroups[cG]\n                    local multiGroups = customGroup[2]\n                    local singleGroups = customGroup[3]\n                    svg[c] = '<g class=\"'\n                    svg[c+1] = customGroup[1]\n                    svg[c+2] = '\">'\n                    c = c+3\n                    for mGC = 1, #multiGroups do\n                        local multiGroup = multiGroups[mGC]\n                        local pts = multiGroup[1]\n                        local tPoints = {}\n                        local ct = 1\n                        for pC = 1, #pts do\n                            local p = pts[pC]\n                            local tx,ty,tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                            if tz > 0 then\n                                tPoints[ct] = {tx,ty,tz}\n                                ct = ct + 1\n                            end\n                        end\n                        if ct ~= 1 then\n                            local drawFunction = multiGroup[2]\n                            local data = multiGroup[3]\n                            c = drawFunction(svg, c, object, tPoints, data)\n                        end\n                    end\n                    for sGC = 1, #singleGroups do\n                        local singleGroup = singleGroups[sGC]\n                        local p = singleGroup[1]\n                        local tx, ty, tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                        if tz > 0 then\n                            local drawFunction = singleGroup[2]\n                            local data = singleGroup[3]\n                            c = drawFunction(svg,c,object,tx,ty,tz,data)\n                        end\n                    end\n                    svg[c] = '</g>'\n                    c=c+1\n                end\n            end\n            svg[c] = '</g></svg>'\n            c = c+1\n        end\n        return svg, c\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "4"
    },
    {
      "code": "positionTypes = {\n    globalP = \"global\",\n    localP = \"local\"\n}\norientationTypes = {\n    globalO = \"global\",\n    localO = \"local\" \n}\n\nfunction Object(style, position, offset, orientation, positionType, orientationType, transX, transY)\n    local rad = math.rad\n    local print = system.print\n    \n    local position = position\n    local positionOffset = offset\n    local heading = rad(orientation[1])\n    local pitch = rad(orientation[2])\n    local roll = rad(orientation[3])\n    \n    local style = style\n    local polylineGroups = {}\n    local circleGroups = {}\n    local curveGroups = {}\n    local customGroups = {}\n    local subObjects = {}\n    local positionType = positionType\n    local orientationType = orientationType\n    \n    local self = {\n        polylineGroups = polylineGroups, \n        circleGroups = circleGroups, \n        curveGroups = curveGroups, \n        customGroups = customGroups,\n        subObjects = subObjects,\n        positionType = positionType,\n        orientationType = orientationType,\n        orientation = {pitch,heading,roll},\n        style = style,\n        position = position,\n        offset = offset,\n        transX,\n        transY\n    }\n    \n    function self.setPolylines(groupId, style, points, scale)\n        -- Polylines for-loop\n        local group = {style}\n        local scale = scale or 1\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        for i = 2, #points do\n            local line = points[i - 1]\n            local newPoints = {}\n            for k = 1, #line do\n                local point = line[k]\n                newPoints[k] = {(point[1]) / scale + offsetX, (point[2] / scale - offsetY), (point[3] / scale  - offsetZ)}\n            end\n            group[i] = newPoints\n        end\n        self.polylineGroups[groupId] = group\n    end\n    \n    function self.setCircles(groupId, style, scale, offset)\n        local group = {\n            style\n        }\n        local scale = scale or 1\n        local c = 2\n        self.circleGroups[groupId] = group\n        local offset = offset or positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addCircle(position, radius, fill)\n            local self = {}\n            local position = {\n                (position[1] - offsetX) / scale,\n                (position[2] - offsetY) / scale, \n                (position[3] - offsetZ) / scale\n            }\n            function self.setLabel(label, offX, offY)\n                local self = {}\n                local label = label\n                local offX = offX or 0\n                local offY = offY or 0\n                function self.setActionFunction(actionFunction)\n                    local self = {}\n                    function self.build()\n                        group[c] = {position, radius, fill, label, offX, offY, actionFunction}\n                        c = c + 1\n                    end\n                    return self\n                end\n                function self.build()\n                    group[c] = {position, radius, fill, label, offX, offY, nil}\n                    c = c + 1\n                end\n                return self\n            end\n            function self.build()\n                group[c] = {position, radius, fill, nil, nil, nil, nil}\n                c = c + 1\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCurves(group, points)\n    end\n\n    function self.setCustomSVGs(groupId, style, scale)\n        local multiPoint = {}\n        local singlePoint = {}\n        local group = {\n            style,\n            multiPoint,\n            singlePoint\n        }\n        local scale = scale or 1\n        local mC = 1\n        local sC = 1\n        self.customGroups[groupId] = group\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addMultiPointSVG()\n            local points = {}\n            local data = nil\n            local drawFunction = nil\n            local self = {}\n            local pC = 1\n            function self.addPoint(point)\n                local point = point\n                points[pC] = {\n                    (point[1] + offsetX) / scale, \n                    (point[2] - offsetY) / scale, \n                    (point[3] - offsetZ) / scale\n                }\n                pC = pC + 1\n                return self\n            end\n            -- ! This function applies no processing !\n            function self.bulkSetPoints(bulk)\n                points = bulk\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.setDrawFunction(draw)\n                \n                drawFunction = draw\n                return self\n            end\n            function self.build()\n                if pC > 0 then\n                    if drawFunction ~= nil then\n                        multiPoint[mC] = {points, drawFunction, data}\n                        mC = mC + 1\n                        return points\n                    else\n                        print(\"WARNING! Malformed multi-point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        function self.addSinglePointSVG()\n            local point = nil\n            local drawFunction = nil\n            local data = nil\n            local self = {}\n            function self.setPosition(position)\n                point = {\n                    (position[1] + offsetX) / scale, \n                    (position[2] - offsetY) / scale, \n                    (position[3] - offsetZ) / scale\n                }\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction = draw\n                return self\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.build()\n                if point ~= nil then\n                    if drawFunction ~= nil then\n                        singlePoint[sC] = {point, drawFunction, data}\n                        sC = sC + 1\n                    else\n                        print(\"WARNING! Malformed single point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed single point build operation, no point specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return self\n    end\n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setPosition(posX, posY, posZ)\n        self.position = {posX, posY, posZ}\n    end\n    \n    function self.addSubObject(object, id)\n        local id = id or #self.subObjects+1\n        self.subObjects[id] = {object}\n        return id\n    end\n    function self.removeSubObject(id)\n        self.subObjects[id] = {}\n    end\n    \n    function self.setSubObjects()\n        local self = {}\n        local c = 1\n        function self.addSubObject(object)\n            subObjects[c] = object\n            c = c + 1\n            return self\n        end\n        return self\n    end\n    \n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self = {}\n    function self.setStyle(style)\n        local self = {}\n        local style = style\n        function self.setPosition(pos)\n            local self = {}\n            local pos = pos\n            function self.setOffset(offset)\n                local self = {}\n                local offset = offset\n                function self.setOrientation(orientation)\n                    local self = {}\n                    local orientation = orientation\n                    function self.setPositionType(positionType)\n                        local self = {}\n                        local positionType = positionType\n                        function self.setOrientationType(orientationType)\n                            local self = {}\n                            local orientationType = orientationType\n                            local transX = nil\n                            local transY = nil\n                            function self.setTranslation(translateX, translateY)\n                                transX = translateX\n                                transY = translateY\n                                return self\n                            end\n                            function self.build()\n                                return Object(style, pos, offset, orientation, positionType, orientationType, transX, transY)\n                            end\n                            return self\n                        end\n                        return self\n                    end\n                    return self\n                end\n                return self\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "5"
    },
    {
      "code": "local rad = math.rad\ncameraTypes = {\n    fixed = {\n        fLocal = {\n            name = \"fLocal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        },\n        fGlobal = {\n            name = \"fGlobal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        }\n    },\n    player = {\n        jetpack = {\n            name = \"jetpack\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.9}\n        },\n        planet = {\n            name = \"planet\",\n            pitchPos = rad(74.8),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        construct = {\n            name = \"construct\",\n            pitchPos = rad(74.8),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        chair = {\n            firstPerson = {\n                mouseControlled = {\n                    name = \"chairfp_mouse\",\n                    pitchPos = nil,\n                    pitchNeg = nil,\n                    headingPos = nil,\n                    headingNeg = nil,\n                    shift = {-0.1, 0.0, 0.65}\n                },\n                freelook = {\n                    name = \"chairfp_free\",\n                    pitchPos = rad(75),\n                    pitchNeg = rad(-75),\n                    headingPos = rad(95),\n                    headingNeg = rad(-95),\n                    shift = {-0.1, 0.0, 0.65}\n                }\n            },\n            secondPerson = {\n                name = \"chairsp\",\n                pitchPos = 0,\n                pitchNeg = 0,\n                headingPos = 0,\n                headingNeg = 0,\n                shift = {0.0, 0.0, 0.0}\n            },\n            thirdPerson = {\n                name = \"chairtp\",\n                pitchPos = rad(84),\n                pitchNeg = rad(-89),\n                headingPos = nil,\n                headingNeg = nil,\n                shift = {0.0, 0.0, 0.0}\n            }\n        }\n    }\n}\n\nlocal hp = core.getHitPoints()\nlocal coreOffset = 16\nif hp > 10000 then\n    coreOffset = 128\nelseif hp > 1000 then\n    coreOffset = 64\nelseif hp > 150 then\n    coreOffset = 32\nend\n\nlocal function getChairPositions()\n    local elementList = core.getElementIdList()\n    local elementType = core.getElementTypeById\n    local elementPos = core.getElementPositionById\n    local coreOffset = coreOffset\n    local positionList = {}\n    local c = 1\n    for i = 1, #elementList do\n        local element = elementType(elementList[i])\n        if element == \"Gunner Module\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Command Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Wooden Chair\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Hovercraft Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        -- Need to add more seat types here.\n    end\n    return positionList\nend\n\nfunction Camera(camType, position, orientation)\n    local core = core\n    local system = system\n    local unit = unit\n    local planetaryInfluence = unit.getClosestPlanetInfluence\n    \n    local isViewLocked = false\n    \n    local print = system.print\n    local chairs = getChairPositions()\n    local types = cameraTypes\n    local rad = math.rad\n    local abs = math.abs\n    local position = {-position[1], position[2], position[3]}\n    local self = {\n        cType = camType,\n        position = position, \n        orientation = {rad(orientation[1]), rad(orientation[2]), rad(orientation[3])},\n        isViewLocked = isViewLocked,\n        cameraShift\n    }\n    \n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setAlignmentType(alignmentType)\n        self.type = alignmentType\n    end\n    \n    function self.setPosition(pos)\n        self.position = {-pos[1], pos[2], pos[3]}\n    end\n    \n    function self.setViewLock(isViewLocked)\n        self.isViewLocked = isViewLocked\n    end\n    \n    function self.getAlignmentType(ax, ay, az, aw, bodyX, bodyY, bodyZ)\n        local playerType = types.player\n        local alignmentType = playerType.construct\n        if self.cType.name == \"fLocal\" then\n            alignmentType = types.fixed.fLocal\n            return alignmentType\n        elseif self.cType.name == \"fGlobal\" then\n            alignmentType = types.fixed.fGlobal\n            return alignmentType\n        end\n        if ax ~= nil then\n            if ax > 0.001 or ax < -0.001 or ay > 0.001 or ay < -0.001 then\n                alignmentType = playerType.jetpack\n            end\n            if planetaryInfluence() > 0.85 then\n                alignmentType = playerType.planet\n            end\n        \n            local chairs = chairs\n            local bodyX = bodyX\n            local bodyY = bodyY\n            local bodyZ = bodyZ\n            local abs = abs\n            for i = 1, #chairs do\n                local chairPos = chairs[i]\n                local difX = abs(chairPos[1] - bodyX)\n                local difY = abs(chairPos[2] - bodyY)\n                local difZ = abs(chairPos[3] - bodyZ)\n\n                if difX < 0.4 and difY < 0.4 and difZ < 0.4 then\n                    local switch = switched % 3\n                    if switch == 0 then\n                        local fp = playerType.chair.firstPerson\n                        if self.isViewLocked then\n                            alignmentType = fp.mouseControlled\n                        else\n                            alignmentType = fp.freelook\n                        end\n                        return alignmentType\n                    elseif switch == 1 then\n                        alignmentType = playerType.chair.thirdPerson\n                        return alignmentType\n                    elseif switch == 2 then\n                        alignmentType = playerType.chair.secondPerson\n                        return alignmentType\n                    end\n                end\n            end\n        end\n        switched = 0\n        return alignmentType\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "6"
    },
    {
      "code": "function getManager()\n    local self = {}\n    \n    -- Misc function calls\n    local solve = library.systemResolution3\n    local getPWorldPos = system.getPlayerWorldPos\n    local sqrt = math.sqrt\n    local atan = math.atan\n    local asin = math.asin\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    \n    local hp = core.getMaxHitPoints()\n    local cOff = 16\n    if hp > 10000 then\n        cOff = 128\n    elseif hp > 1000 then\n        cOff = 64\n    elseif hp > 150 then\n        cOff = 32\n    end\n\n    function self.getLocalToWorldConverter()\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1, v2, v3, {1,0,0})\n        local v2t = solve(v1, v2, v3, {0,1,0})\n        local v3t = solve(v1, v2, v3, {0,0,1})\n        return function(cref)\n            return solve(v1t, v2t, v3t, cref)\n        end\n    end\n    function self.getWorldToLocalConverter()\n        local vc1 = getCWorldOriR()\n        local vc2 = getCWorldOriF()\n        local vc3 = getCWorldOriU()\n        return function(world)\n            return solve(vc1, vc2, vc3, world)\n        end\n    end\n\n    function self.getTrueWorldPos()\n        local cal = self.getLocalToWorldConverter()\n        local cWorldPos = getCWorldPos()\n        local pos = getElementPositionById(1)\n        local offsetPosition = {pos[1] - cOff, pos[2] - cOff, pos[3] - cOff}\n        local adj = cal(offsetPosition)\n        local adjPos = {cWorldPos[1] - adj[1], cWorldPos[2] - adj[2], cWorldPos[3] - adj[3]}\n        return adjPos\n    end\n\n    function self.getPlayerLocalPos(playerId)\n        local c = self.getWorldToLocalConverter()\n        local cWorldPos = self.getTrueWorldPos()\n        local pWorldPos = getPWorldPos(playerId)\n        local adjPos = c({pWorldPos[1] - cWorldPos[1], pWorldPos[2] - cWorldPos[2], pWorldPos[3] - cWorldPos[3]})\n        adjPos = {-adjPos[1], adjPos[2], adjPos[3]}\n        return adjPos\n    end\n\n    function self.rotationMatrixToQuaternion(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        \n        local t = m11 + m22 + m33\n        if t > 0 then\n            local s = 0.5 / sqrt(t + 1.0)\n            return (m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s\n        elseif m11 > m22 and m11 > m33 then\n            local s = 2.0 * sqrt(1.0 + m11 - m22 - m33)\n            return 0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s\n        elseif m22 > m33 then\n            local s = 2.0 * sqrt(1.0 + m22 - m11 - m33)\n            return (m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s\n        else\n            local s = 2.0 * sqrt(1.0 + m33 - m11 - m22)\n            return (m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s\n        end\n    end\n    \n    function self.rotationMatrixToEuler(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        local y = 0\n        \n        if m13 >= 1 then\n            y = asin(1)\n        elseif m13 <=-1 then\n            y = asin(-1)\n        else\n            y = asin(m13)\n        end\n        if abs(m13) < 0.9999999 then\n            return {atan(-m23,m33), -y, -atan(-m12,m11)}\n        else\n            return {atan(m32, m22), -y, -0}\n        end\n    end\n    \n    function self.inverse(qX, qY, qZ, qW)\n        local mag = qX*qX + qY*qY + qZ*qZ + qW*qW\n        return -qX/mag, -qY/mag, -qZ/mag, qW/mag\n    end\n    \n    function self.multiply(ax, ay, az, aw, bx, by, bz, bw)\n        return ax*bw + aw*bx + ay*bz - az*by, ay*bw + aw*by + az*bx - ax*bz, az*bw + aw*bz + ax*by - ay*bx, aw*bw - ax*bx - ay*by - az*bz\n    end\n    \n    function self.divide(ax, ay, az, aw, bx, by, bz, bw)\n        local cx, cy, cz, cw = self.inverse(bx, by, bz, bw)\n        return self.multiply(ax, ay, az, aw, cx, cy, cz, cw)\n    end\n    \n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "7"
    },
    {
      "code": "function PlanetObject(x,y,z, radius, name, stroke, fontsize, subId, obj)\n    local sqrt,ceil,floor=math.sqrt,math.ceil,math.floor\n    local function round(value, precision)\n        local value = value/precision\n        local value = value >= 0 and floor(value+0.5) or ceil(value-0.5)\n        return value * precision\n    end\n    local getCWorldPos,getCMass = core.getConstructWorldPos,core.getConstructMass\n    local keyframe = 0\n    local self = {\n        radius = radius,\n        x = x,\n        y = y,\n        z = z,\n        name = name,\n        stroke = stroke,\n        fontsize = fontsize,\n        subId = subId,\n        object = obj,\n        keyframe = keyframe\n    }\n    \n    function self.getCSSData()\n        return '.' .. self.name .. '{filter: drop-shadow(0 0 0.5rem ' .. self.stroke .. '); stroke: ' .. self.stroke .. '; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: ' .. self.fontsize .. 'px;}'\n    end\n    \n    function self.getPlanetInfo()\n        local tons = getCMass() / 1000\n        local cPos = getCWorldPos()\n        local px,py,pz = self.x-cPos[1], self.y-cPos[2], self.z-cPos[3]\n        local planetDistance = sqrt(px*px + py*py + pz*pz)\n        local warpCost = ceil(tons*((planetDistance/1000)/200)*0.00025)\n        local name = self.name\n        return name, round((planetDistance/1000)/200, 0.01), warpCost\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "8"
    }
  ],
  "methods": [],
  "events": []
}