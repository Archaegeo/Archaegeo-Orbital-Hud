{
  "slots": {
    "0": {
      "name": "core",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "slot2",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "slot3",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "slot4",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "safeZones = {\n  {id = 1, name = \"Madis\", center = {17465536,22665536,-34464}, color = \"blue\"},\n  {id = 2, name = \"Alioth\", center = {-8,-8,-126303}, color = \"blue\"},\n  {id = 3, name = \"Thades\", center = {29165536,10865536,65536}, color = \"orange\"},\n  {id = 4, name = \"Talemai\", center = {-13234464,55765536,465536}, color = \"blue\"},\n  {id = 5, name = \"Feli\", center = {-43534464,22565536,-48934464}, color = \"brown\"},\n  {id = 6, name = \"Sicari\", center = {52765536,27165538,52065535}, color = \"orange\"},\n  {id = 7, name = \"Sinnen\", center = {58665538,29665535,58165535}, color = \"orange\"},\n  {id = 8, name = \"Teoma\", center = {80865538,54665536,-934463.94}, color = \"blue\"},\n  {id = 9, name = \"Jago\", center = {-94134462,12765534,-3634464}, color = \"blue\"},\n  {id = 100, name = \"Lacobus\", center = {98865536,-13534464,-934461.99}, color = \"grey\"},\n  {id = 110, name = \"Symeon\", center = {14165536,-85634465,-934464.3}, color = \"purple\"},\n  {id = 120, name = \"Ion\", center = {2865536.7,-99034464,-934462.02}, color = \"grey\"}\n}\n\n-- Parameters\nlocal style = \"PlanetGroup\"\nlocal position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal orientation = {0,0,0}\n\nlocal objectBuilder = ObjectBuilderLinear()\n-- The linear builder essentially as the names says, linear, it must be built in this order.\nplanets = objectBuilder\n\t\t\t\t.setStyle(style) -- Sets the class of this graphic\n\t\t\t\t.setPosition(position) -- Sets the position of the object, around which it rotates\n\t\t\t\t.setOffset(offsetPos) -- Sets the offset, usually not used but sometimes useful\n\t\t\t\t.setOrientation(orientation) -- Sets the default pitch, heading and roll (in degrees)\n\t\t\t\t.setPositionType(positionTypes.globalP) -- Sets how the position relates to the world.\n\t\t\t\t.setOrientationType(orientationTypes.globalP) -- Sets how the orientation relates to the world.\n\t\t\t\t.build() -- creates the object\nship = objectBuilder\n\t\t\t\t.setStyle(\"ship\") -- Sets the class of this graphic\n\t\t\t\t.setPosition(position) -- Sets the position of the object, around which it rotates\n\t\t\t\t.setOffset(offsetPos) -- Sets the offset, usually not used but sometimes useful\n\t\t\t\t.setOrientation(orientation) -- Sets the default pitch, heading and roll (in degrees)\n\t\t\t\t.setPositionType(positionTypes.globalP) -- Sets how the position relates to the world.\n\t\t\t\t.setOrientationType(orientationTypes.globalO) -- Sets how the orientation relates to the world.\n\t\t\t\t.build() -- creates the object\nship.setCircles(1, \"Player\", 0).addCircle({0,0,0}, 3, \"green\").setLabel(\"Me\").build()\n-- ^ Adds a a green circle at 0,0,0 of the *object* with a radius of 3.\nplanets.setSubObjects().addSubObject(ship)\n-- Creates the camera with the initial super type and the initial position and orientation, respectively.\nlocal camera = Camera(cameraTypes.player.construct, {0,0,0}, {-5,0,0})\ncamera.setViewLock(true)\nprojector = Projector(core, camera) -- Creates the projector\nprojector.addObject(planets) -- Adds the planets to the projector\n\n-- Now to actually add data to the planets, we do the following.\nlocal scale = 1 -- i.e. 1:50000000\nlocal planetCircles = planets.setCircles(1, \"planets\", scale)\n-- We use \"set circles\" because we we don't really care about scaling the object.\n-- It also is just simpler this way.\nlocal myLocation = vec3(core.getConstructWorldPos())\nlocal myDistance, mySize, safeZone\nfor ii = 1, #safeZones do\n    safeZone = safeZones[ii]\n    myDistance = (myLocation - vec3(safeZone.center)):len()\n    if myDistance > 2000000 then \n\t   local mySize = math.max((-1/1000000)*myDistance + 75, 15)\n        local name = safeZone.name\n        planetCircles --Position, size and fill respectively\n    \t\t.addCircle(safeZone.center, mySize, \"none\") -- I can add a circle in a chain like this.\n    \t\t.setLabel(safeZone.name) -- Adds the label to it. Labels are basic at the moment.\n    \t\t.build() -- Tells the program you are done with creating it and adds it.\n    end\nend\n\n\nunit.setTimer(\"fixed_1\", 1/1000) --The timer to update the camera\nunit.setTimer(\"update\", 1/1000) -- The timer to update the screen\nsystem.showScreen(1)\nunit.hide()",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "local svg, index = projector.getSVG()\n\nlocal width = system.getScreenWidth()\nlocal height = system.getScreenHeight()\n\nsvg[index] =\n[[\n<style>\nsvg{ width:]]..width ..[[px; height:]]..height ..[[px; position:absolute; top:0px; left:0px;}\n.Player{stroke: red; fill: white; text-align: center;}\n.PlanetGroup{filter: drop-shadow(0 0 0.5rem #FFA500);}\n.planets{ stroke: #FF7F00; stroke-width: 3; fill: white; text-anchor:middle;}\n</style>]]\nlocal rendered = table.concat(svg)\nsystem.setScreen(rendered)",
      "filter": {
        "args": [
          {
            "value": "update"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "projector.updateCamera()\n--planets.rotateHeading(0.5)\nlocal position = core.getConstructWorldPos()\nlocal scale = 1\nship.setPosition(position[1] / scale, position[2] / scale, position[3] / scale)\n-- Now to actually add data to the planets, we do the following.\nlocal planetCircles = planets.setCircles(1, \"planets\", scale)\n-- We use \"set circles\" because we we don't really care about scaling the object.\n-- It also is just simpler this way.\nlocal myLocation = vec3(core.getConstructWorldPos())\nlocal myDistance, mySize, safeZone\nfor ii = 1, #safeZones do\n    safeZone = safeZones[ii]\n    myDistance = (myLocation - vec3(safeZone.center)):len()\n    if myDistance > 2000000 then \n\t   local mySize = math.max((-1/1000000)*myDistance + 75, 15)\n        local name = safeZone.name\n        planetCircles --Position, size and fill respectively\n    \t\t.addCircle(safeZone.center, mySize, \"none\") -- I can add a circle in a chain like this.\n    \t\t.setLabel(name, mySize + string.len(name)*7, 6) -- Adds the label to it. Labels are basic at the moment.\n    \t\t.build() -- Tells the program you are done with creating it and adds it.\n    end\nend",
      "filter": {
        "args": [
          {
            "value": "fixed_1"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "function Projector(core, camera)\n    -- Localize frequently accessed data\n    local library = library\n    local core = core\n    local unit = unit\n    local system = system\n    local manager = getManager()\n    \n    -- Localize frequently accessed functions\n    --- Library-based function calls\n    local solve = library.systemResolution3\n    \n    --- System-based function calls\n    local getWidth = system.getScreenWidth\n    local getHeight = system.getScreenHeight\n    local getFov = system.getFov\n    local getMouseDeltaX = system.getMouseDeltaX\n    local getMouseDeltaY = system.getMouseDeltaY\n    local getPlayerWorldPos = system.getPlayerWorldPos\n    local print = system.print\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    local getElementRotationById = core.getElementRotationById\n    \n    --- Unit-based function calls\n    local getRelativeOrientation = unit.getMasterPlayerRelativeOrientation\n    \n    --- Camera-based function calls\n    local getAlignmentType = camera.getAlignmentType\n    \n    --- Manager-based function calls\n    ---- Positional Operations\n    local getLocalToWorldConverter = manager.getLocalToWorldConverter\n    local getWorldToLocalConverter = manager.getWorldToLocalConverter\n    local getTrueWorldPos = manager.getTrueWorldPos\n    local getPlayerLocalPos = manager.getPlayerLocalPos\n    ---- Quaternion operations\n    local rotToQuat = manager.rotationMatrixToQuaternion\n    local rotToEuler = manager.rotationMatrixToEuler\n    local inverse = manager.inverse\n    local multiply = manager.multiply\n    local divide = manager.divide\n    \n    -- Localize Math functions\n    local sin, cos, tan = math.sin, math.cos, math.tan\n    local rad, deg, sqrt = math.rad, math.deg, math.sqrt\n    local atan = math.atan\n\n    -- Projection infomation\n    --- Screen Parameters\n    local width = getWidth()/2\n    local height = getHeight()/2\n\n    --- FOV Paramters\n    local hfovRad = rad(getFov());\n    local fov = 2*atan(tan(hfovRad/2)*height,width)\n\n    --- Matrix Subprocessing\n    local tanFov = tan(fov/2)\n    local aspect = width/height\n    local near = width/tanFov\n    local top = near * tanFov\n    local bottom = -top;\n    local left = bottom * aspect\n    local right = top * aspect\n\n    --- Matrix Paramters\n    local x0 = 2 * near / (right - left)\n    local y0 = 2 * near / (top - bottom)\n\n    -- Player-related values\n    local playerId = unit.getMasterPlayerId()\n    local unitId = unit.getId()\n    \n    -- Camera-Related values\n    local eye = camera.position\n    local cOrientation = camera.orientation\n    local cameraType = camera.cType\n    local alignmentType = nil\n    \n    --- Mouse info\n    local sensitivity = 1 -- export: Sensitivtiy\n    local m = sensitivity*(width*2)*0.00104584100642898 + 0.00222458611638299\n    local bottomLock = false\n    local topLock = false\n    local rightLock = false\n    local leftLock = false\n\n    local self = {}\n    local objects = {}\n\n    function self.getSize(size, zDepth, max, min)\n        local pSize = atan(size, zDepth) * (near / aspect)\n        local max = max or pSize\n        if pSize >= max then\n            return max\n        elseif pSize <= min then\n            return min\n        else\n            return pSize\n        end\n    end\n    \n    function self.updateCamera()\n        if cameraType.name ~= \"fGlobal\" and cameraType.name ~= \"fLocal\" then\n            \n            -- Localize variables\n            local atan = atan\n            \n            eye = getPlayerLocalPos(playerId)\n\n            local deltaMouseY = getMouseDeltaY()\n            local deltaMouseX = getMouseDeltaX()\n            local width = width\n            local deltaPitch = atan(-deltaMouseY/width) * m\n            local deltaHeading = atan(deltaMouseX/width) * m\n        \n            local pPitch = cOrientation[1]\n            local pHeading = cOrientation[2]\n            \n            local alignmentType = alignmentType\n            if alignmentType == nil then\n                alignmentType = getAlignmentType()\n            end\n            --print(alignmentType.name)\n            local pitchPos = alignmentType.pitchPos\n            local pitchNeg = alignmentType.pitchNeg\n            local headingPos = alignmentType.headingPos\n            local headingNeg = alignmentType.headingNeg\n            \n            if pitchPos ~= nil then\n                if (bottomLock == false and topLock == false) then  \n                    pPitch = pPitch + deltaPitch\n                    if pPitch <= pitchNeg then\n                        pPitch = pitchNeg\n                        bottomLock = true\n                    end\n                    if pPitch >= pitchPos then\n                        pPitch = pitchPos\n                        topLock = true\n                    end\n                else\n                    if bottomLock == true and deltaMouseY < 0 then\n                        bottomLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                    if topLock == true and deltaMouseY > 0 then\n                        topLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                end\n                cOrientation[1] = pPitch\n            else\n                cOrientation[1] = 0\n            end\n            if headingPos ~= nil then\n                if (leftLock == false and rightLock == false) then  \n                    pHeading = pHeading + deltaHeading\n                    if pHeading <= headingNeg then\n                        pHeading = headingNeg\n                        leftLock = true\n                    end\n                    if pHeading >= headingPos then\n                        pHeading = headingPos\n                        rightLock = true\n                    end\n                else\n                    if rightLock == true and deltaMouseX < 0 then\n                        rightLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                    if leftLock == true and deltaMouseX > 0 then\n                        leftLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                end\n                cOrientation[2] = pHeading\n            else\n                cOrientation[2] = 0\n            end\n        end\n    end\n\n    function self.addObject(object)\n        local index = #objects + 1\n        objects[index] = object\n        return index\n    end\n\n    function self.removeObject(id)\n    \tobjects[id] = {}\n    end\n    \n    function self.getModelMatrices(mObject)\n        \n        local s = sin\n        local c = cos\n        local multi = multiply\n        local inverse = inverse\n        local modelMatrices = {}\n        \n        -- Localize Object values.\n        local obj = mObject\n        local objOriType = obj.orientationType\n        local objOri = obj.orientation\n        local objPosType = obj.positionType\n        local objPos = obj.position\n        local objPosX,objPosY,objPosZ = objPos[1],objPos[2],objPos[3]\n        \n        local cU = getCWorldOriU()\n        local cUX,cUY,cUZ = cU[1],cU[2],cU[3]\n        local cF = getCWorldOriF()\n        local cFX,cFY,cFZ = cF[1],cF[2],cF[3]\n        local cR = getCWorldOriR()\n        local cRX,cRY,cRZ = cR[1],cR[2],cR[3]\n        \n        local sx,sy,sz,sw = rotToQuat({cRX,cRY,cRZ,0,cFX,cFY,cFZ,0,cUX,cUY,cUZ,0,0,0,0,1})\n        \n        local recurse = {}\n        local ct = 2\n        function recurse.subObjectMatrices(lx, ly, lz, lw, sObjX, sObjY, sObjZ, object, posLX, posLY, posLZ)\n            local objPos = object.position\n            local objRot = object.orientation\n            local objRotType = object.orientationType\n            local objX,objY,objZ = objPos[1],objPos[2],objPos[3]\n            \n            local objP,objH,objR = objRot[1] / 2,objRot[2] / 2,objRot[3] / 2\n            local sP,sH,sR = s(objP),s(objR),s(objH)\n            local cP,cH,cR = c(objP),c(objR),c(objH)\n    \n            local wwx = sP*cH*cR - cP*sH*sR\n            local wwy = cP*sH*cR + sP*cH*sR\n            local wwz = cP*cH*sR - sP*sH*cR\n            local www = cP*cH*cR + sP*sH*sR\n            local wx, wy, wz, ww = wwx,wwy,wwz,www\n\n            local lix, liy, liz, liw = inverse(lx, ly, lz, lw)\n            \n            local posTX, posTY, posTZ, posTW = multi(lx, ly, lz, lw, objX, objY, objZ, 0)\n\n            local posIX = -posTX*liw + posTW*lix - posTY*liz - posTZ*liy\n            local posIY = posTY*liw + posTW*liy + posTZ*lix - posTX*liz\n            local posIZ = -posTZ*liw + posTW*liz + posTX*liy + posTY*lix\n\n            if object.positionType == \"local\" then\n                local dotX = cRX*posIX + cFX*posIY + cUX*posIZ\n                local dotY = cRY*posIX + cFY*posIY + cUY*posIZ\n                local dotZ = cRZ*posIX + cFZ*posIY + cUZ*posIZ\n                posIX = dotX\n                posIY = dotY\n                posIZ = dotZ\n            end\n            posIX, posIY, posIZ = posIX + posLX, posIY + posLY, posIZ + posLZ\n            \n            if objRotType == \"local\" then\n                wx, wy, wz, ww = multi(wx, wy, wz, ww, sx, sy, sz, sw)\n            end\n            local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n            local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n            local wzwz,wzww = wz*wz,wz*ww\n            local a1 = 1 - 2*(wywy + wzwz)\n            local b1 = 2*(wxwy - wzww)\n            local c1 = 2*(wxwz + wyww)\n    \n            local d1 = 2*(wxwy + wzww)\n            local e1 = 1 - 2*(wxwx + wzwz)\n            local f1 = 2*(wywz - wxww)\n    \n            local g1 = 2*(wxwz - wyww)\n            local h1 = 2*(wywz + wxww)\n            local i1 = 1 - 2*(wxwx + wywy)\n            \n            modelMatrices[ct] = {\n                object,\n                {\n                    a1, -d1, -g1, posIX,\n                    -b1, e1, h1, -posIY,\n                    -c1, f1, i1, -posIZ,\n                    0, 0, 0, 1\n                }\n\n            }\n            ct=ct+1\n            \n            local subObjects = object.subObjects\n            if #subObjects > 0 then\n                for k = 1, #subObjects do\n                    recurse.subObjectMatrices(wwx, wwy, wwz, www, objX, objY, objZ, subObjects[k], posIX, posIY, posIZ)\n                end\n            end\n        end\n        local pitch,heading,roll = objOri[1] / 2,objOri[2] / 2,objOri[3] / 2\n        \n        --- Quaternion of object rotations\n        local sP,sH,sR = s(pitch),s(roll),s(heading)\n        local cP,cH,cR = c(pitch),c(roll),c(heading)\n    \n        local wwx = (sP*cH*cR - cP*sH*sR)\n        local wwy = (cP*sH*cR + sP*cH*sR)\n        local wwz = (cP*cH*sR - sP*sH*cR)\n        local www = (cP*cH*cR + sP*sH*sR)\n        local wx,wy,wz,ww = wwx,wwy,wwz,www\n        \n        if objOriType == \"local\" then\n            wx,wy,wz,ww = multiply(wx,wy,wz,ww,sx,sy,sz,sw)\n        end\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        if objPosType == \"local\" then\n            local dotX = cRX*objPosX + cFX*objPosY + cUX*objPosZ\n            local dotY = cRY*objPosX + cFY*objPosY + cUY*objPosZ\n            local dotZ = cRZ*objPosX + cFZ*objPosY + cUZ*objPosZ\n            objPosX = dotX\n            objPosY = dotY\n            objPosZ = dotZ\n        else\n            local cWorldPos = getTrueWorldPos()\n            objPosX = objPosX - cWorldPos[1]\n            objPosY = objPosY - cWorldPos[2]\n            objPosZ = objPosZ - cWorldPos[3]\n        end\n        local subObjs = obj.subObjects\n        if #subObjs > 0 then\n            for k = 1, #subObjs do\n                recurse.subObjectMatrices(wwx,wwy,wwz,www,objPos[1],objPos[2],objPos[3],subObjs[k],objPosX,objPosY,objPosZ)\n            end\n        end\n        modelMatrices[1] = {obj,{a2, -d2, -g2, objPosX,-b2, e2, h2, -objPosY,-c2, f2, i2, -objPosZ,0, 0, 0, 1}}\n        return modelMatrices\n    end\n\n    function self.getViewMatrix()\n        local multi = multiply\n        local solve = solve\n        \n        local board = getElementRotationById(unitId)\n        local ax,ay,az,aw = board[1],board[2],board[3],board[4]\n        \n        local body = getRelativeOrientation()\n        local bx,by,bz,bw = body[1],body[2],body[3],body[4]\n\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1,v2,v3,{1,0,0})\n        local v2t = solve(v1,v2,v3,{0,1,0})\n        local v3t = solve(v1,v2,v3,{0,0,1})\n        \n        local sx, sy, sz, sw = rotToQuat({v1t[1],v1t[2],v1t[3],0,v2t[1],v2t[2],v2t[3],0,v3t[1],v3t[2],v3t[3],0,0,0,0,1})\n        local lx, ly, lz, lw = rotToQuat({v1[1],v1[2],v1[3],0,v2[1],v2[2],v2[3],0,v3[1],v3[2],v3[3],0,0,0,0,1})\n\n        local eye = eye\n        local eyeX,eyeY,eyeZ = eye[1],eye[2],eye[3]\n        local dotX, dotY, dotZ = eyeX, eyeY, eyeZ\n        local wx, wy, wz, ww = 0,0,0,1\n        local s = sin\n        local c = cos\n        \n        local px, py, pz, pw = multi(ax, ay, az, aw, bx, by, bz, bw)\n        local alignment = getAlignmentType(px, py, pz, pw, eyeX, eyeY, eyeZ)\n        alignmentType = alignment\n        local pix, piy, piz, piw = inverse(px, py, pz, pw)\n        local shift = alignment.shift\n            \n        local eyeTX, eyeTY, eyeTZ, eyeTW = multi(px, py, pz, pw, shift[1], shift[2], shift[3], 0)\n        local eyeIX, eyeIY, eyeIZ, eyeIW = multi(eyeTX, eyeTY, eyeTZ, eyeTW, pix, piy, piz, piw)\n        \n        local alignName = alignment.name\n        local nFG=alignName~=\"fGlobal\"\n        local fG=alignName==\"fGlobal\"\n        local nFL=alignName~=\"fLocal\"\n        local fL=alignName==\"fLocal\"\n        local ori = cOrientation\n        local pitch,roll,heading = ori[1] / 2,0,ori[2] / 2,0\n        if pitch ~= 0 or heading ~= 0 or roll ~= 0 or fG or fL then\n            local sP,sH,sR = s(pitch),s(roll),s(heading)\n            local cP,cH,cR = c(pitch),c(roll),c(heading)\n            \n            local cx = sP*cH*cR - cP*sH*sR\n            local cy = -cP*sH*cR - sP*cH*sR\n            local cz = -cP*cH*sR + sP*sH*cR\n            local cw = cP*cH*cR + sP*sH*sR\n            if nFG and nFL then\n                px,py,pz,pw = multi(px,py,pz,pw,cx,cy,cz,cw)\n\n            elseif alignName == \"fGlobal\" then\n                wx,wy,wz,ww = cx,cy,cz,cw\n            else\n                wx,wy,wz,ww = multi(sx,sy,sz,sw,cx,cy,cz,cw)\n            end\n        end\n        \n        if nFG and nFL then\n            local pxpx,pxpy,pxpz,pxpw = px*px,px*py,px*pz,px*pw\n            local pypy,pypz,pypw = py*py,py*pz,py*pw\n            local pzpz,pzpw = pz*pz,pz*pw\n            \n            local a1 = 1 - 2*(pypy + pzpz)\n            local b1 = 2*(pxpy - pzpw)\n            local c1 = 2*(pxpz + pypw)\n    \n            local d1 = 2*(pxpy + pzpw)\n            local e1 = 1 - 2*(pxpx + pzpz)\n            local f1 = 2*(pypz - pxpw)\n    \n            local g1 = 2*(pxpz - pypw)\n            local h1 = 2*(pypz + pxpw)\n            local i1 = 1 - 2*(pxpx + pypy)\n            eyeX = eyeX - eyeIX\n            eyeY = eyeY + eyeIY\n            eyeZ = eyeZ + eyeIZ\n        \n            dotX = a1*eyeX + -d1*eyeY + -g1*eyeZ\n            dotY = -b1*eyeX + e1*eyeY + h1*eyeZ\n            dotZ = -c1*eyeX + f1*eyeY + i1*eyeZ\n            wx,wy,wz,ww = multi(sx,sy,sz,sw,px,py,pz,pw)\n        end\n        -- Camera rotation determination\n        --- Directly input euler angles in radians\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        --- Matrix of camera rotations, using quaternions\n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        return {a2, -d2, -g2, dotX,-b2, e2, h2, dotY,-c2, f2, i2, dotZ,0, 0, 0, 1}\n    end\n    \n    function self.getSVG()\n        local svg = {}\n        local c = 1\n        local view = self.getViewMatrix()\n\n        local vx1,vy1,vz1,vw1 = view[1],view[2],view[3],view[4]\n        local vx2,vy2,vz2,vw2 = view[5],view[6],view[7],view[8]\n        local vx3,vy3,vz3,vw3 = view[9],view[10],view[11],view[12]\n        \n        local function translate(x,y,z,mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n            local x,y,z = x,-y,-z\n            local px = mXX * x + mXY * y + mXZ * z + mXW\n            local py = mYX * x + mYY * y + mYZ * z + mYW\n            local pz = mZX * x + mZY * y + mZZ * z + mZW\n            local pw = -py\n                \n            -- Convert to window coordinates after W-Divide\n            local wx = (px / pw) * width\n            local wy = (pz / pw) * height\n            return wx, wy, pw\n        end\n        -- Localize projection matrix values\n        local px1 = x0\n        local py2 = 1 --c0\n        local pz3 = y0\n        \n        -- Localize screen info\n        local width = width\n        local height = height\n\n        for i = 1, #objects do\n            \n            local object = objects[i]\n            local objTransX = object.transX or width\n            local objTransY = object.transY or height\n            \n            svg[c] = [[<svg viewBox=\"0 0 ]]\n            svg[c+1] = width*2\n            svg[c+2] = [[ ]]\n            svg[c+3] = height*2\n            svg[c+4] = [[\" class=\"]]\n            svg[c+5] = object.style\n            svg[c+6] = '\"><g transform=\"translate('\n            svg[c+7] = objTransX\n            svg[c+8] = ','\n            svg[c+9] = objTransY\n            svg[c+10] = ')\">'\n            c=c+11\n            local models = self.getModelMatrices(object)\n            \n            -- Localize model matrix values\n            for k = 1, #models do\n                local modelObj = models[k]\n                local object = modelObj[1]\n                local model = modelObj[2]\n                \n                local mx1,my1,mz1,mw1 = model[1],model[2],model[3],model[4]\n                local mx2,my2,mz2,mw2 = model[5],model[6],model[7],model[8]\n                local mx3,my3,mz3,mw3 = model[9],model[10],model[11],model[12]\n                \n                local mXX = px1*(vx1*mx1 + vy1*mx2 + vz1*mx3)\n                local mXY = px1*(vx1*my1 + vy1*my2 + vz1*my3)\n                local mXZ = px1*(vx1*mz1 + vy1*mz2 + vz1*mz3)\n                local mXW = px1*(vw1 + vx1*mw1 + vy1*mw2 + vz1*mw3)\n        \n                local mYX = (vx2*mx1 + vy2*mx2 + vz2*mx3)\n                local mYY = (vx2*my1 + vy2*my2 + vz2*my3)\n                local mYZ = (vx2*mz1 + vy2*mz2 + vz2*mz3)\n                local mYW = (vw2 + vx2*mw1 + vy2*mw2 + vz2*mw3)\n        \n                local mZX = pz3*(vx3*mx1 + vy3*mx2 + vz3*mx3)\n                local mZY = pz3*(vx3*my1 + vy3*my2 + vz3*my3)\n                local mZZ = pz3*(vx3*mz1 + vy3*mz2 + vz3*mz3)\n                local mZW = pz3*(vw3 + vx3*mw1 + vy3*mw2 + vz3*mw3)\n                \n                local polylineGroups = object.polylineGroups\n                local circleGroups = object.circleGroups\n                local curvesGroups = object.curvesGroups\n                local customGroups = object.customGroups\n            \n                -- Polylines for-loop\n                for d=1,#polylineGroups do\n                    local polylineGroup = polylineGroups[d]\n                    svg[c] = '<path class=\"'\n                    svg[c+1] = polylineGroup[1]\n                    svg[c+2] = '\" d=\"'\n                    c = c+3\n                    for f=2,#polylineGroup do\n                        local line = polylineGroup[f]\n                        svg[c] = 'M '\n                        local lC=0\n                        local sP={}\n                        local eP={}\n                        c=c+1\n                        for h = 1, #line do\n                            local p = line[h]\n                            local wx,wy,ww = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n\n                            -- If PW is negative, it means the point is behind you\n                            if ww > 0 then\n                                if lC ~= 0 then\n                                    svg[c] = ' L '\n                                    c = c + 1\n                                    eP = {wx, wy}\n                                else\n                                    sP = {wx, wy}\n                                end\n                                svg[c] = wx\n                                svg[c+1] = ' '\n                                svg[c+2] = wy\n                                c=c+3\n                                lC=lC+1\n                            end\n                        end\n                        if lC < 2 then\n                            if lC == 1 then\n                                svg[c-4] = ''\n                                svg[c-3] = ''\n                                svg[c-2] = ''\n                                svg[c-1] = ''\n                                c=c-4\n                            else\n                                svg[c-1] = ''\n                                c=c-1\n                            end\n                        else\n                            if eP[1] == sP[1] and eP[2] == sP[2] then\n                                svg[c-4] = ' Z '\n                                svg[c-3] = ''\n                                svg[c-2] = ''\n                                svg[c-1] = ''\n                                c=c-3\n                            end\n                        end\n                    end\n                    svg[c] = '\"/>'\n                    c=c+1\n                end\n                for cG=1,#circleGroups do\n                    local circleGroup = circleGroups[cG]\n                    svg[c] = '<g class=\"'\n                    svg[c+1] = circleGroup[1]\n                    svg[c+2] = '\">'\n                    c=c+3\n                    for l=2, #circleGroup do\n                        local circle = circleGroup[l]\n                        local p = circle[1]\n                        \n                        local wx, wy, wz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                        if wz > 0 then\n                            local radius = circle[2]\n                            local fill = circle[3]\n                            local label = circle[4]\n                            local offX = circle[5]\n                            local offY = circle[6]\n                            local action = circle[7]\n                            svg[c] = '<circle cx=\"'\n                            svg[c+1] = wx\n                            svg[c+2] = '\" cy=\"'\n                            svg[c+3] = wy\n                            svg[c+4] = '\" r=\"'\n                            svg[c+5] = radius\n                            svg[c+6] = '\" fill=\"'\n                            svg[c+7] = fill\n                            svg[c+8] = '\"/>'\n                            c = c+9\n                            if label ~= nil then\n                                svg[c] = '<text x=\"'\n                                svg[c+1] = wx + offX\n                                svg[c+2] = '\" y=\"'\n                                svg[c+3] = wy + offY\n                                svg[c+4] = '\">'\n                                svg[c+5] = label\n                                svg[c+6] = '</text>'\n                                c=c+7\n                            end\n                            if action ~= nil then\n                                c = action(svg, c, object, wx, wy, wz)\n                            end\n                        end\n                    end\n                    svg[c] = '</g>'\n                    c=c+1\n                end\n                for cG = 1, #customGroups do\n                    local customGroup = customGroups[cG]\n                    local multiGroups = customGroup[2]\n                    local singleGroups = customGroup[3]\n                    svg[c] = '<g class=\"'\n                    svg[c+1] = customGroup[1]\n                    svg[c+2] = '\">'\n                    c = c+3\n                    for mGC = 1, #multiGroups do\n                        local multiGroup = multiGroups[mGC]\n                        local pts = multiGroup[1]\n                        local tPoints = {}\n                        local ct = 1\n                        for pC = 1, #pts do\n                            local p = pts[pC]\n                            local tx,ty,tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                            if tz > 0 then\n                                tPoints[ct] = {tx,ty,tz}\n                                ct = ct + 1\n                            end\n                        end\n                        if ct ~= 1 then\n                            local drawFunction = multiGroup[2]\n                            local data = multiGroup[3]\n                            c = drawFunction(svg, c, object, tPoints, data)\n                        end\n                    end\n                    for sGC = 1, #singleGroups do\n                        local singleGroup = singleGroups[sGC]\n                        local p = singleGroup[1]\n                        local tx, ty, tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                        if tz > 0 then\n                            local drawFunction = singleGroup[2]\n                            local data = singleGroup[3]\n                            c = drawFunction(svg,c,object,tx,ty,tz,data)\n                        end\n                    end\n                    svg[c] = '</g>'\n                    c=c+1\n                end\n            end\n            svg[c] = '</g></svg>'\n            c = c+1\n        end\n        return svg, c\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "3"
    },
    {
      "code": "positionTypes = {\n    globalP = \"global\",\n    localP = \"local\"\n}\norientationTypes = {\n    globalO = \"global\",\n    localO = \"local\" \n}\n\nfunction Object(style, position, offset, orientation, positionType, orientationType, transX, transY)\n    local rad = math.rad\n    local print = system.print\n    \n    local position = position\n    local positionOffset = offset\n    local heading = rad(orientation[1])\n    local pitch = rad(orientation[2])\n    local roll = rad(orientation[3])\n    \n    local style = style\n    local polylineGroups = {}\n    local circleGroups = {}\n    local curveGroups = {}\n    local customGroups = {}\n    local subObjects = {}\n    local positionType = positionType\n    local orientationType = orientationType\n    \n    local self = {\n        polylineGroups = polylineGroups, \n        circleGroups = circleGroups, \n        curveGroups = curveGroups, \n        customGroups = customGroups,\n        subObjects = subObjects,\n        positionType = positionType,\n        orientationType = orientationType,\n        orientation = {pitch,heading,roll},\n        style = style,\n        position = position,\n        offset = offset,\n        transX,\n        transY\n    }\n    \n    function self.setPolylines(groupId, style, points, scale)\n        -- Polylines for-loop\n        local group = {style}\n        local scale = scale or 1\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        for i = 2, #points do\n            local line = points[i - 1]\n            local newPoints = {}\n            for k = 1, #line do\n                local point = line[k]\n                newPoints[k] = {(point[1]) / scale + offsetX, (point[2] / scale - offsetY), (point[3] / scale  - offsetZ)}\n            end\n            group[i] = newPoints\n        end\n        self.polylineGroups[groupId] = group\n    end\n    \n    function self.setCircles(groupId, style, scale, offset)\n        local group = {\n            style\n        }\n        local scale = scale or 1\n        local c = 2\n        self.circleGroups[groupId] = group\n        local offset = offset or positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addCircle(position, radius, fill)\n            local self = {}\n            local position = {\n                (position[1] - offsetX) / scale,\n                (position[2] - offsetY) / scale, \n                (position[3] - offsetZ) / scale\n            }\n            function self.setLabel(label, offX, offY)\n                local self = {}\n                local label = label\n                local offX = offX or 0\n                local offY = offY or 0\n                function self.setActionFunction(actionFunction)\n                    local self = {}\n                    function self.build()\n                        group[c] = {position, radius, fill, label, offX, offY, actionFunction}\n                        c = c + 1\n                    end\n                    return self\n                end\n                function self.build()\n                    group[c] = {position, radius, fill, label, offX, offY, nil}\n                    c = c + 1\n                end\n                return self\n            end\n            function self.build()\n                group[c] = {position, radius, fill, nil, nil, nil, nil}\n                c = c + 1\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCurves(group, points)\n    end\n\n    function self.setCustomSVGs(groupId, style, scale)\n        local multiPoint = {}\n        local singlePoint = {}\n        local group = {\n            style,\n            multiPoint,\n            singlePoint\n        }\n        local scale = scale or 1\n        local mC = 1\n        local sC = 1\n        self.customGroups[groupId] = group\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addMultiPointSVG()\n            local points = {}\n            local data = nil\n            local drawFunction = nil\n            local self = {}\n            local pC = 1\n            function self.addPoint(point)\n                local point = point\n                points[pC] = {\n                    (point[1] + offsetX) / scale, \n                    (point[2] - offsetY) / scale, \n                    (point[3] - offsetZ) / scale\n                }\n                pC = pC + 1\n                return self\n            end\n            -- ! This function applies no processing !\n            function self.bulkSetPoints(bulk)\n                points = bulk\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction = draw\n                return self\n            end\n            function self.build()\n                if pC > 0 then\n                    if drawFunction ~= nil then\n                        multiPoint[mC] = {points, drawFunction, data}\n                        mC = mC + 1\n                        return points\n                    else\n                        print(\"WARNING! Malformed multi-point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        function self.addSinglePointSVG()\n            local point = nil\n            local drawFunction = nil\n            local data = nil\n            local self = {}\n            function self.setPosition(position)\n                point = {\n                    (position[1] + offsetX) / scale, \n                    (position[2] - offsetY) / scale, \n                    (position[3] - offsetZ) / scale\n                }\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction = draw\n                return self\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.build()\n                if point ~= nil then\n                    if drawFuction ~= nil then\n                        singlePoint[sC] = {point, drawFunction, data}\n                        sC = sC + 1\n                    else\n                        print(\"WARNING! Malformed single point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed single point build operation, no point specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return self\n    end\n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setPosition(posX, posY, posZ)\n        self.position = {posX, posY, posZ}\n    end\n    \n    function self.setSubObjects()\n        local self = {}\n        local c = 1\n        function self.addSubObject(object)\n            subObjects[c] = object\n            c = c + 1\n            return self\n        end\n        return self\n    end\n    \n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self = {}\n    function self.setStyle(style)\n        local self = {}\n        local style = style\n        function self.setPosition(pos)\n            local self = {}\n            local pos = pos\n            function self.setOffset(offset)\n                local self = {}\n                local offset = offset\n                function self.setOrientation(orientation)\n                    local self = {}\n                    local orientation = orientation\n                    function self.setPositionType(positionType)\n                        local self = {}\n                        local positionType = positionType\n                        function self.setOrientationType(orientationType)\n                            local self = {}\n                            local orientationType = orientationType\n                            local transX = nil\n                            local transY = nil\n                            function self.setTranslation(translateX, translateY)\n                                transX = translateX\n                                transY = translateY\n                                return self\n                            end\n                            function self.build()\n                                return Object(style, pos, offset, orientation, positionType, orientationType, transX, transY)\n                            end\n                            return self\n                        end\n                        return self\n                    end\n                    return self\n                end\n                return self\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "4"
    },
    {
      "code": "local rad = math.rad\ncameraTypes = {\n    fixed = {\n        fLocal = {\n            name = \"fLocal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        },\n        fGlobal = {\n            name = \"fGlobal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        }\n    },\n    player = {\n        jetpack = {\n            name = \"jetpack\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.9}\n        },\n        planet = {\n            name = \"planet\",\n            pitchPos = rad(74.8),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        construct = {\n            name = \"construct\",\n            pitchPos = rad(74.8),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        chair = {\n            firstPerson = {\n                mouseControlled = {\n                    name = \"chairfp_mouse\",\n                    pitchPos = nil,\n                    pitchNeg = nil,\n                    headingPos = nil,\n                    headingNeg = nil,\n                    shift = {-0.1, 0.0, 0.65}\n                },\n                freelook = {\n                    name = \"chairfp_free\",\n                    pitchPos = rad(75),\n                    pitchNeg = rad(-75),\n                    headingPos = rad(95),\n                    headingNeg = rad(-95),\n                    shift = {-0.1, 0.0, 0.65}\n                }\n            },\n            secondPerson = {\n                name = \"chairsp\",\n                pitchPos = 0,\n                pitchNeg = 0,\n                headingPos = 0,\n                headingNeg = 0,\n                shift = {0.0, 0.0, 0.0}\n            },\n            thirdPerson = {\n                name = \"chairtp\",\n                pitchPos = rad(84),\n                pitchNeg = rad(-89),\n                headingPos = nil,\n                headingNeg = nil,\n                shift = {0.0, 0.0, 0.0}\n            }\n        }\n    }\n}\n\nlocal hp = core.getHitPoints()\nlocal coreOffset = 16\nif hp > 10000 then\n    coreOffset = 128\nelseif hp > 1000 then\n    coreOffset = 64\nelseif hp > 150 then\n    coreOffset = 32\nend\n\nlocal function getChairPositions()\n    local elementList = core.getElementIdList()\n    local elementType = core.getElementTypeById\n    local elementPos = core.getElementPositionById\n    local coreOffset = coreOffset\n    local positionList = {}\n    local c = 1\n    for i = 1, #elementList do\n        local element = elementType(elementList[i])\n        if element == \"Gunner Module\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Command Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Wooden Chair\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Hovercraft Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        -- Need to add more seat types here.\n    end\n    return positionList\nend\n\nfunction Camera(camType, position, orientation)\n    local core = core\n    local system = system\n    local unit = unit\n    local planetaryInfluence = unit.getClosestPlanetInfluence\n    \n    local isViewLocked = false\n    \n    local print = system.print\n    local chairs = getChairPositions()\n    local types = cameraTypes\n    local rad = math.rad\n    local abs = math.abs\n    local position = {-position[1], position[2], position[3]}\n    local self = {\n        cType = camType,\n        position = position, \n        orientation = {rad(orientation[1]), rad(orientation[2]), rad(orientation[3])},\n        isViewLocked = isViewLocked,\n        cameraShift\n    }\n    \n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setAlignmentType(alignmentType)\n        self.type = alignmentType\n    end\n    \n    function self.setPosition(pos)\n        self.position = {-pos[1], pos[2], pos[3]}\n    end\n    \n    function self.setViewLock(isViewLocked)\n        self.isViewLocked = isViewLocked\n    end\n    \n    function self.getAlignmentType(ax, ay, az, aw, bodyX, bodyY, bodyZ)\n        local playerType = types.player\n        local alignmentType = playerType.construct\n        if self.cType.name == \"fLocal\" then\n            alignmentType = types.fixed.fLocal\n            return alignmentType\n        elseif self.cType.name == \"fGlobal\" then\n            alignmentType = types.fixed.fGlobal\n            return alignmentType\n        end\n        if ax ~= nil then\n            if ax > 0.001 or ax < -0.001 or ay > 0.001 or ay < -0.001 then\n                alignmentType = playerType.jetpack\n            end\n            if planetaryInfluence() > 0.85 then\n                alignmentType = playerType.planet\n            end\n        \n            local chairs = chairs\n            local bodyX = bodyX\n            local bodyY = bodyY\n            local bodyZ = bodyZ\n            local abs = abs\n            for i = 1, #chairs do\n                local chairPos = chairs[i]\n                local difX = abs(chairPos[1] - bodyX)\n                local difY = abs(chairPos[2] - bodyY)\n                local difZ = abs(chairPos[3] - bodyZ)\n\n                if difX < 0.4 and difY < 0.4 and difZ < 0.4 then\n                    local switch = switched % 3\n                    if switch == 0 then\n                        local fp = playerType.chair.firstPerson\n                        if self.isViewLocked then\n                            alignmentType = fp.mouseControlled\n                        else\n                            alignmentType = fp.freelook\n                        end\n                        return alignmentType\n                    elseif switch == 1 then\n                        alignmentType = playerType.chair.thirdPerson\n                        return alignmentType\n                    elseif switch == 2 then\n                        alignmentType = playerType.chair.secondPerson\n                        return alignmentType\n                    end\n                end\n            end\n        end\n        switched = 0\n        return alignmentType\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "5"
    },
    {
      "code": "function getManager()\n    local self = {}\n    \n    -- Misc function calls\n    local solve = library.systemResolution3\n    local getPWorldPos = system.getPlayerWorldPos\n    local sqrt = math.sqrt\n    local atan = math.atan\n    local asin = math.asin\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    \n    local hp = core.getMaxHitPoints()\n    local cOff = 16\n    if hp > 10000 then\n        cOff = 128\n    elseif hp > 1000 then\n        cOff = 64\n    elseif hp > 150 then\n        cOff = 32\n    end\n\n    function self.getLocalToWorldConverter()\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1, v2, v3, {1,0,0})\n        local v2t = solve(v1, v2, v3, {0,1,0})\n        local v3t = solve(v1, v2, v3, {0,0,1})\n        return function(cref)\n            return solve(v1t, v2t, v3t, cref)\n        end\n    end\n    function self.getWorldToLocalConverter()\n        local vc1 = getCWorldOriR()\n        local vc2 = getCWorldOriF()\n        local vc3 = getCWorldOriU()\n        return function(world)\n            return solve(vc1, vc2, vc3, world)\n        end\n    end\n\n    function self.getTrueWorldPos()\n        local cal = self.getLocalToWorldConverter()\n        local cWorldPos = getCWorldPos()\n        local pos = getElementPositionById(1)\n        local offsetPosition = {pos[1] - cOff, pos[2] - cOff, pos[3] - cOff}\n        local adj = cal(offsetPosition)\n        local adjPos = {cWorldPos[1] - adj[1], cWorldPos[2] - adj[2], cWorldPos[3] - adj[3]}\n        return adjPos\n    end\n\n    function self.getPlayerLocalPos(playerId)\n        local c = self.getWorldToLocalConverter()\n        local cWorldPos = self.getTrueWorldPos()\n        local pWorldPos = getPWorldPos(playerId)\n        local adjPos = c({pWorldPos[1] - cWorldPos[1], pWorldPos[2] - cWorldPos[2], pWorldPos[3] - cWorldPos[3]})\n        adjPos = {-adjPos[1], adjPos[2], adjPos[3]}\n        return adjPos\n    end\n\n    function self.rotationMatrixToQuaternion(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        \n        local t = m11 + m22 + m33\n        if t > 0 then\n            local s = 0.5 / sqrt(t + 1.0)\n            return (m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s\n        elseif m11 > m22 and m11 > m33 then\n            local s = 2.0 * sqrt(1.0 + m11 - m22 - m33)\n            return 0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s\n        elseif m22 > m33 then\n            local s = 2.0 * sqrt(1.0 + m22 - m11 - m33)\n            return (m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s\n        else\n            local s = 2.0 * sqrt(1.0 + m33 - m11 - m22)\n            return (m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s\n        end\n    end\n    \n    function self.rotationMatrixToEuler(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        local y = 0\n        \n        if m13 >= 1 then\n            y = asin(1)\n        elseif m13 <=-1 then\n            y = asin(-1)\n        else\n            y = asin(m13)\n        end\n        if abs(m13) < 0.9999999 then\n            return {atan(-m23,m33), -y, -atan(-m12,m11)}\n        else\n            return {atan(m32, m22), -y, -0}\n        end\n    end\n    \n    function self.inverse(qX, qY, qZ, qW)\n        local mag = qX*qX + qY*qY + qZ*qZ + qW*qW\n        return -qX/mag, -qY/mag, -qZ/mag, qW/mag\n    end\n    \n    function self.multiply(ax, ay, az, aw, bx, by, bz, bw)\n        return ax*bw + aw*bx + ay*bz - az*by, ay*bw + aw*by + az*bx - ax*bz, az*bw + aw*bz + ax*by - ay*bx, aw*bw - ax*bx - ay*by - az*bz\n    end\n    \n    function self.divide(ax, ay, az, aw, bx, by, bz, bw)\n        local cx, cy, cz, cw = self.inverse(bx, by, bz, bw)\n        return self.multiply(ax, ay, az, aw, cx, cy, cz, cw)\n    end\n    \n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "6"
    }
  ],
  "methods": [],
  "events": []
}