{
  "slots": {
    "0": {
      "name": "core",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "1": {
      "name": "databank",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "2": {
      "name": "slot3",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "3": {
      "name": "slot4",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "4": {
      "name": "slot5",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "5": {
      "name": "slot6",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "6": {
      "name": "slot7",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "7": {
      "name": "slot8",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "8": {
      "name": "slot9",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "9": {
      "name": "slot10",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "local sqrt, len, max, print = math.sqrt, string.len, math.max, system.print\n\nlocal freelook = false --export: Enable freelook in first person mode.\nlocal loadWaypoints = true --export: Enable to load waypoints from Archaegeo's HUD's DB.\nlocal displayWarpCells = true --export: To display warp cells or not.\nlocal archHudWaypointSize = 0.01 --export: The size in meters of an ArchHud waypoint\nlocal archHudWPRender = 400 --export: The size in kilometers at which point ArchHud Waypoints do not render.\nlocal maxWaypointSize = 800 --export: The Max Size of a waypoint in pixels.\nlocal minWaypointSize = 15 --export: The min size of a waypoint in pixels.\nlocal infoHighlight = 200 --export: The number of pixels within info is displayed.\nfontsize = 20 --export: font size\ncolorWarp = \"#ADD8E6\" --export: Colour of warpable waypoints\nnonWarp = \"#FFA500\" --export: Colour of non-warpable waypoints\n\nwaypoint = false\nlocal waypointInfo = {\n  {name = \"Madis\", center = {17465536,22665536,-34464}, radius=44300},\n  {name = \"Alioth\", center = {-8,-8,-126303}, radius=126068},\n  {name = \"Thades\", center = {29165536,10865536,65536}, radius=49000},\n  {name = \"Talemai\", center = {-13234464,55765536,465536}, radius=57450},\n  {name = \"Feli\", center = {-43534464,22565536,-48934464}, radius=60000},\n  {name = \"Sicari\", center = {52765536,27165538,52065535}, radius=51100},\n  {name = \"Sinnen\", center = {58665538,29665535,58165535}, radius=54950},\n  {name = \"Teoma\", center = {80865538,54665536,-934463.94}, radius=62000},\n  {name = \"Jago\", center = {-94134462,12765534,-3634464}, radius=61590},\n  {name = \"Lacobus\", center = {98865536,-13534464,-934461.99}, radius=55650},\n  {name = \"Symeon\", center = {14165536,-85634465,-934464.3}, radius=49050},\n  {name = \"Symeon\", center = {14165536,-85634465,-934464.3}, radius=49050},\n  {name = \"ME\", center ={2515342.2058,-99129540.3141,-1117557.9816}, radius=archHudWaypointSize},\n  {name = \"Ion\", center = {2865536.7,-99034464,-934462.02}, radius=44950}\n}\n\nlocal function bTW(bool)\n    if bool then\n        return \"enabled\"\n    else\n        return \"disabled\"\n    end\nend\n\nprint(\"=======================\")\nprint(\"DU AR Waypoint System\")\nprint(\"=======================\")\nprint(\"Concept: Archaegeo\")\nprint(\"Coder  : EasternGamer\")\nprint(\"=======================\")\nprint(\"Settings\")\nprint(\"=======================\")\nprint(\"Freelook        : \" .. bTW(freelook))\nprint(\"Disp. Warp Cells: \" .. bTW(displayWarpCells))\nprint(\"Load saved WP   : \" .. bTW(loadWaypoints))\nprint(\"Font Size       : \" .. fontsize .. \"px\")\nprint(\"Max WP Render   : \" .. archHudWPRender .. \"km\")\nprint(\"Max WP Size     : \" .. maxWaypointSize .. \"px\")\nprint(\"Min WP Size     : \" .. minWaypointSize .. \"px\")\nprint(\"ArchHUD WP Size : \" .. archHudWaypointSize .. \"m\")\nprint(\"Info HL Distance: \" .. infoHighlight .. \"px\")\nprint(\"=======================\")\n\nif loadWaypoints then\n    if databank ~= nil then\n        local getString = databank.getStringValue\n        if getString ~= nil then\n            local dbInfo = json.decode(getString(\"SavedLocations\"))\n            if dbInfo ~= nil then\n                local size = #waypointInfo\n                local dbInfoSize = #dbInfo\n                local c = 0\n                print(\"Found \" .. dbInfoSize .. \" waypoints in databank.\")\n                for i=1, #dbInfo do\n                    local dbEntry = dbInfo[i]\n                    local pos=dbEntry.position\n                    waypointInfo[size+c+1] = {name=dbEntry.name, center={pos.x, pos.y, pos.z}, radius=archHudWaypointSize}\n                    c=c+1\n                end\n                print(\"Loaded \" .. c .. \" waypoints.\")\n            else\n                print('ERROR! No data to read.')\n            end\n        else\n            print('ERROR! Incorrect slot used for databank.')\n        end\n    else\n        print(\"ERROR! No slot connected to databank slot.\")\n    end\nend\n\nlocal position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal orientation = {0,0,0}\nlocal width = system.getScreenWidth() / 2\nlocal height = system.getScreenHeight() / 2\nlocal objectBuilder = ObjectBuilderLinear()\n\nlocal camera = Camera(cameraTypes.player.construct, {0,0,0}, {0,0,0})\n\ncamera.setViewLock(not freelook)\nprojector = Projector(core, camera)\n\nwaypoints = {}\n\nlocal warp = ObjectGroup(\"Warp\")\nlocal notwarp = ObjectGroup(\"NotWarp\")\nprojector.addObjectGroup(warp)\nprojector.addObjectGroup(notwarp)\n\nlocal function drawText(svg, c, x, y, text, opacity)\n    svg[c] = '<text x=\"'\n    svg[c+1] = x\n    svg[c+2] = '\" y=\"'\n    svg[c+3] = y\n    svg[c+4] = '\" fill-opacity=\"'\n    svg[c+5] = opacity\n    svg[c+6] = '\" stroke-opacity=\"'\n    svg[c+7] = opacity\n    svg[c+8] = '\">'\n    svg[c+9] = text\n    svg[c+10] = '</text>'\n    return c+11\nend\nlocal function drawHorizontalLine(svg, c, x, y, length, thickness)\n    svg[c] = '<path fill=\"none\" stroke-width=\"'\n    svg[c+1] = thickness\n    svg[c+2] = '\" d=\"M'\n    svg[c+3] = x\n    svg[c+4] = ' '\n    svg[c+5] = y\n    svg[c+6] = ' h '\n    svg[c+7] = length\n    svg[c+8] = '\"/>'\n    return c+9\nend\nlocal maxD = sqrt(width*width + height*height)\nlocal function drawInfo(svg, c, tx, ty, data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local font = fontsize\n    local name,distance,warpCost,disKM,disM = data.getWaypointInfo()\n    local keyframe = data.keyframe\n\n    if distance > 500 then\n        local id = data.subId\n        local d = notwarp.addObject(waypoints[id][2], id)\n        warp.removeObject(id)\n    else\n        local id = data.subId\n        warp.addObject(waypoints[id][2], id)\n        notwarp.removeObject(id)\n    end\n    c = drawHorizontalLine(svg, c, tx, ty + 3, len(name)*(font*0.7), 2)\n    c = drawText(svg, c, tx, ty, name, 1)\n    \n    if distanceToMouse <= infoHighlight then\n        if keyframe < 6 then\n            data.keyframe = keyframe + 1\n        end\n    else\n        if keyframe ~= 0 then\n            data.keyframe = keyframe - 1\n        end\n    end\n    local opacity = keyframe/6\n    if distanceToMouse < 25 and waypoint then\n        system.setWaypoint('::pos{0,0,' .. data.x ..',' .. data.y .. ',' .. data.z ..'}')\n        waypoint = false\n    end\n    if keyframe > 0 then\n        local disText = ''\n        if disM <=1000 then\n            disText = disM .. ' M'\n        elseif disKM <= 200 then\n            disText = disKM .. ' KM'\n        else\n            disText = distance .. ' SU'\n        end\n        c = drawText(svg, c, tx + 60 - keyframe*10, ty+font+5, disText, opacity)\n        if displayWarpCells then\n            c = drawText(svg, c, tx + 60 - keyframe*10, ty+(font+5)*2, warpCost .. ' Warp Cells', opacity)\n        end\n    end\n    return c\nend\nlocal function draw(svg,c,object,tx,ty,tz,data)\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local r = data.radius\n    local off = (((tz/1000)/200))/100\n    local size = max(projector.getSize(r, tz, 100000000, minWaypointSize) - off, 5)\n    if size >= maxWaypointSize or distanceToMouse > maxD or (r==archHudWaypointSize*1.25 and tz>archHudWPRender*1000) then -- Don't display\n        return c\n    end\n    svg[c] = '<circle cx=\"'\n    svg[c+1] = tx\n    svg[c+2] = '\" cy=\"'\n    svg[c+3] = ty\n    svg[c+4] = '\" r=\"'\n    if r==archHudWaypointSize*1.25 then\n        size = size /2\n        svg[c+5] = size\n        svg[c+6] = '\" fill=\"' .. colorWarp .. '\"/>'\n    else\n        svg[c+5] = size\n        svg[c+6] = '\" fill=\"none\"/>'\n    end\n    c=c+7\n    c=drawInfo(svg, c, tx + size + 5, ty - size + 5, data)\n    return c\nend\n\nfor ii = 1, #waypointInfo do\n    local wDat = waypointInfo[ii]\n    local wCenter = wDat.center\n    local wName = wDat.name\n    local wRadius = wDat.radius\n    local waypoint = objectBuilder\n\t\t\t\t.setStyle(wName)\n\t\t\t\t.setPosition({0,0,0})\n\t\t\t\t.setOffset({0,0,0})\n\t\t\t\t.setOrientation({0,0,0})\n\t\t\t\t.setPositionType(positionTypes.globalP)\n\t\t\t\t.setOrientationType(orientationTypes.globalO)\n\t\t\t\t.build()\n    \n    local subId = warp.addObject(waypoint)\n    local nsubId = notwarp.addObject(waypoint)\n    notwarp.removeObject(nsubId)\n    local waypointObject = Waypoint(wCenter[1],wCenter[2],wCenter[3], wRadius * 1.25, wName, subId)\n    local customSVG = waypoint.setCustomSVGs(1, wName).addSinglePointSVG()\n    waypoints[ii] = {wCenter, waypoint}\n    customSVG.setPosition({wCenter[1], wCenter[2], wCenter[3]})\n    \t    .setData(waypointObject)\n    \t    .setDrawFunction(draw)\n    \t    .build()\nend\n\nunit.setTimer(\"fixed_1\", 1/1000) --The timer to update the camera\nunit.setTimer(\"update\", 1/1000) -- The timer to update the screen\nsystem.showScreen(1)\nunit.hide()",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-1"
      },
      "key": "0"
    },
    {
      "code": "local concat = table.concat\nlocal svg, index = projector.getSVG()\n\nlocal width = system.getScreenWidth()\nlocal height = system.getScreenHeight()\nlocal fontsize = fontsize\nsvg[index] = '<style>svg{ width:'\nsvg[index+1] = width\nsvg[index+2] ='px; height:'\nsvg[index+3] =height\nsvg[index+4] ='px; position:absolute; top:0px; left:0px;}.NotWarp{filter: drop-shadow(0 0 0.5rem '\nsvg[index+5] =nonWarp\nsvg[index+6] ='); stroke: '\nsvg[index+7] =nonWarp\nsvg[index+8] ='; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: '\nsvg[index+9] =fontsize\nsvg[index+10] ='px;}.Warp{filter: drop-shadow(0 0 0.5rem '\nsvg[index+11] =colorWarp\nsvg[index+12] ='); stroke: '\nsvg[index+13] =colorWarp\nsvg[index+14] ='; stroke-width: 3; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: '\nsvg[index+15] =fontsize\nsvg[index+16] ='px;}</style>'\nlocal rendered = concat(svg)\nsystem.setScreen(rendered)\n--slot3.setHTML(rendered)",
      "filter": {
        "args": [
          {
            "value": "update"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "1"
    },
    {
      "code": "projector.updateCamera()",
      "filter": {
        "args": [
          {
            "value": "fixed_1"
          }
        ],
        "signature": "tick(timerId)",
        "slotKey": "-1"
      },
      "key": "2"
    },
    {
      "code": "waypoint = true",
      "filter": {
        "args": [
          {
            "value": "option1"
          }
        ],
        "signature": "actionStart(action)",
        "slotKey": "-2"
      },
      "key": "3"
    },
    {
      "code": "function Projector(core, camera)\n    -- Localize frequently accessed data\n    local utils = require('cpml.utils')\n    local library = library\n    local core = core\n    local unit = unit\n    local system = system\n    local manager = getManager()\n    \n    -- Localize frequently accessed functions\n    --- Library-based function calls\n    local solve = library.systemResolution3\n    \n    --- System-based function calls\n    local getWidth = system.getScreenWidth\n    local getHeight = system.getScreenHeight\n    local getFov = system.getFov\n    local getMouseDeltaX = system.getMouseDeltaX\n    local getMouseDeltaY = system.getMouseDeltaY\n    local getPlayerWorldPos = system.getPlayerWorldPos\n    local print = system.print\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    local getElementRotationById = core.getElementRotationById\n    \n    --- Unit-based function calls\n    local getRelativeOrientation = unit.getMasterPlayerRelativeOrientation\n    \n    --- Camera-based function calls\n    local getAlignmentType = camera.getAlignmentType\n    \n    --- Manager-based function calls\n    ---- Positional Operations\n    local getLocalToWorldConverter = manager.getLocalToWorldConverter\n    local getWorldToLocalConverter = manager.getWorldToLocalConverter\n    local getTrueWorldPos = manager.getTrueWorldPos\n    local getPlayerLocalPos = manager.getPlayerLocalPos\n    ---- Quaternion operations\n    local rotToQuat = manager.rotationMatrixToQuaternion\n    local rotToEuler = manager.rotationMatrixToEuler\n    local inverse = manager.inverse\n    local multiply = manager.multiply\n    local divide = manager.divide\n    \n    -- Localize Math functions\n    local sin, cos, tan = math.sin, math.cos, math.tan\n    local rad, deg, sqrt = math.rad, math.deg, math.sqrt\n    local atan = math.atan\n    local ceil, floor = math.ceil, math.floor\n    local round = utils.round\n\n    -- Projection infomation\n    --- Screen Parameters\n    local width = getWidth()/2\n    local height = getHeight()/2\n\n    --- FOV Paramters\n    \n    --local offset = (width + height) / 5000\n    local offset = 0\n    local hfovRad = rad(getFov() + offset)\n    local tanFov = tan(hfovRad/2)*height/width\n\n    --- Matrix Subprocessing\n    local aspect = width/height\n    local near = width/tanFov\n    local top = near * tanFov\n    local bottom = -top;\n    local left = bottom * aspect\n    local right = top * aspect\n\n    --- Matrix Paramters\n    local x0 = 2 * near / (right - left)\n    local y0 = 2 * near / (top - bottom)\n    \n    -- Player-related values\n    local playerId = unit.getMasterPlayerId()\n    local unitId = unit.getId()\n    \n    -- Camera-Related values\n    local eye = camera.position\n    local cOrientation = camera.orientation\n    local cameraType = camera.cType\n    local alignmentType = nil\n    \n    --- Mouse info\n    local sensitivity = 1 --export: Sensitivtiy\n    local m = sensitivity*(width*2)*0.00104584100642898 + 0.00222458611638299\n\n    local bottomLock = false\n    local topLock = false\n    local rightLock = false\n    local leftLock = false\n\n    local objectGroups = {}\n    \n    local self = {objectGroups = objectGroups}\n\n    function self.getSize(size, zDepth, max, min)\n        local pSize = atan(size, zDepth) * (near / aspect)\n        local max = max or pSize\n        local min = min or pSize\n        if pSize >= max then\n            return max\n        elseif pSize <= min then\n            return min\n        else\n            return pSize\n        end\n    end\n    \n    function self.updateCamera()\n        if cameraType.name ~= \"fGlobal\" and cameraType.name ~= \"fLocal\" then\n            \n            -- Localize variables\n            local atan = atan\n            \n            eye = getPlayerLocalPos(playerId)\n\n            local deltaMouseY = getMouseDeltaY()\n            local deltaMouseX = getMouseDeltaX()\n            local width = width\n            local deltaPitch = atan(-deltaMouseY,width) * m\n            local deltaHeading = atan(deltaMouseX,width) * m\n        \n            local pPitch = cOrientation[1]\n            local pHeading = cOrientation[2]\n            \n            local alignmentType = alignmentType\n            if alignmentType == nil then\n                alignmentType = getAlignmentType()\n            end\n            --print(alignmentType.name)\n            local pitchPos = alignmentType.pitchPos\n            local pitchNeg = alignmentType.pitchNeg\n            local headingPos = alignmentType.headingPos\n            local headingNeg = alignmentType.headingNeg\n            \n            if pitchPos ~= nil then\n                if (bottomLock == false and topLock == false) then  \n                    pPitch = pPitch + deltaPitch\n                    if pPitch <= pitchNeg then\n                        pPitch = pitchNeg\n                        bottomLock = true\n                    end\n                    if pPitch >= pitchPos then\n                        pPitch = pitchPos\n                        topLock = true\n                    end\n                else\n                    if bottomLock == true and deltaMouseY < 0 then\n                        bottomLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                    if topLock == true and deltaMouseY > 0 then\n                        topLock = false\n                        pPitch = pPitch + deltaPitch\n                    end\n                end\n                cOrientation[1] = pPitch\n            else\n                cOrientation[1] = 0\n            end\n            if headingPos ~= nil then\n                if (leftLock == false and rightLock == false) then  \n                    pHeading = pHeading + deltaHeading\n                    if pHeading <= headingNeg then\n                        pHeading = headingNeg\n                        leftLock = true\n                    end\n                    if pHeading >= headingPos then\n                        pHeading = headingPos\n                        rightLock = true\n                    end\n                else\n                    if rightLock == true and deltaMouseX < 0 then\n                        rightLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                    if leftLock == true and deltaMouseX > 0 then\n                        leftLock = false\n                        pHeading = pHeading + deltaHeading\n                    end\n                end\n                cOrientation[2] = pHeading\n            else\n                cOrientation[2] = 0\n            end\n        end\n    end\n\n    function self.addObjectGroup(objectGroup, id)\n        local index = id or #objectGroups + 1\n        objectGroups[index] = objectGroup\n        return index\n    end\n\n    function self.removeObjectGroup(id)\n    \tobjectGroups[id] = {}\n    end\n    \n    function self.getModelMatrices(mObject)\n        \n        local s = sin\n        local c = cos\n        local multi = multiply\n        local inverse = inverse\n        local modelMatrices = {}\n        \n        -- Localize Object values.\n        local obj = mObject\n        local objOriType = obj.orientationType\n        local objOri = obj.orientation\n        local objPosType = obj.positionType\n        local objPos = obj.position\n        local objPosX,objPosY,objPosZ = objPos[1],objPos[2],objPos[3]\n        \n        local cU = getCWorldOriU()\n        local cUX,cUY,cUZ = cU[1],cU[2],cU[3]\n        local cF = getCWorldOriF()\n        local cFX,cFY,cFZ = cF[1],cF[2],cF[3]\n        local cR = getCWorldOriR()\n        local cRX,cRY,cRZ = cR[1],cR[2],cR[3]\n        \n        local sx,sy,sz,sw = rotToQuat({cRX,cRY,cRZ,0,cFX,cFY,cFZ,0,cUX,cUY,cUZ,0,0,0,0,1})\n        \n        local recurse = {}\n        local ct = 2\n        function recurse.subObjectMatrices(lx, ly, lz, lw, sObjX, sObjY, sObjZ, object, posLX, posLY, posLZ)\n            local objPos = object.position\n            local objRot = object.orientation\n            local objRotType = object.orientationType\n            local objX,objY,objZ = objPos[1],objPos[2],objPos[3]\n            \n            local objP,objH,objR = objRot[1] / 2,objRot[2] / 2,objRot[3] / 2\n            local sP,sH,sR = s(objP),s(objR),s(objH)\n            local cP,cH,cR = c(objP),c(objR),c(objH)\n    \n            local wwx = sP*cH*cR - cP*sH*sR\n            local wwy = cP*sH*cR + sP*cH*sR\n            local wwz = cP*cH*sR - sP*sH*cR\n            local www = cP*cH*cR + sP*sH*sR\n            local wx, wy, wz, ww = wwx,wwy,wwz,www\n\n            local lix, liy, liz, liw = inverse(lx, ly, lz, lw)\n            \n            local posTX, posTY, posTZ, posTW = multi(lx, ly, lz, lw, objX, objY, objZ, 0)\n\n            local posIX = -posTX*liw + posTW*lix - posTY*liz - posTZ*liy\n            local posIY = posTY*liw + posTW*liy + posTZ*lix - posTX*liz\n            local posIZ = -posTZ*liw + posTW*liz + posTX*liy + posTY*lix\n\n            if object.positionType == \"local\" then\n                local dotX = cRX*posIX + cFX*posIY + cUX*posIZ\n                local dotY = cRY*posIX + cFY*posIY + cUY*posIZ\n                local dotZ = cRZ*posIX + cFZ*posIY + cUZ*posIZ\n                posIX = dotX\n                posIY = dotY\n                posIZ = dotZ\n            end\n            posIX, posIY, posIZ = posIX + posLX, posIY + posLY, posIZ + posLZ\n            \n            if objRotType == \"local\" then\n                wx, wy, wz, ww = multi(wx, wy, wz, ww, sx, sy, sz, sw)\n            end\n            local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n            local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n            local wzwz,wzww = wz*wz,wz*ww\n            local a1 = 1 - 2*(wywy + wzwz)\n            local b1 = 2*(wxwy - wzww)\n            local c1 = 2*(wxwz + wyww)\n    \n            local d1 = 2*(wxwy + wzww)\n            local e1 = 1 - 2*(wxwx + wzwz)\n            local f1 = 2*(wywz - wxww)\n    \n            local g1 = 2*(wxwz - wyww)\n            local h1 = 2*(wywz + wxww)\n            local i1 = 1 - 2*(wxwx + wywy)\n            \n            modelMatrices[ct] = {\n                object,\n                {\n                    a1, -d1, -g1, posIX,\n                    -b1, e1, h1, -posIY,\n                    -c1, f1, i1, -posIZ,\n                    0, 0, 0, 1\n                }\n\n            }\n            ct=ct+1\n            \n            local subObjects = object.subObjects\n            if #subObjects > 0 then\n                for k = 1, #subObjects do\n                    local subObj = subObjects[k]\n                    if subObj.position~=nil then\n                        recurse.subObjectMatrices(wwx, wwy, wwz, www, objX, objY, objZ, subObj, posIX, posIY, posIZ)\n                    end\n                end\n            end\n        end\n        local pitch,heading,roll = objOri[1] / 2,objOri[2] / 2,objOri[3] / 2\n        \n        --- Quaternion of object rotations\n        local sP,sH,sR = s(pitch),s(roll),s(heading)\n        local cP,cH,cR = c(pitch),c(roll),c(heading)\n    \n        local wwx = (sP*cH*cR - cP*sH*sR)\n        local wwy = (cP*sH*cR + sP*cH*sR)\n        local wwz = (cP*cH*sR - sP*sH*cR)\n        local www = (cP*cH*cR + sP*sH*sR)\n        local wx,wy,wz,ww = wwx,wwy,wwz,www\n        \n        if objOriType == \"local\" then\n            wx,wy,wz,ww = multiply(wx,wy,wz,ww,sx,sy,sz,sw)\n        end\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        if objPosType == \"local\" then\n            local dotX = cRX*objPosX + cFX*objPosY + cUX*objPosZ\n            local dotY = cRY*objPosX + cFY*objPosY + cUY*objPosZ\n            local dotZ = cRZ*objPosX + cFZ*objPosY + cUZ*objPosZ\n            objPosX = dotX\n            objPosY = dotY\n            objPosZ = dotZ\n        else\n            local cWorldPos = getTrueWorldPos()\n            objPosX = objPosX - cWorldPos[1]\n            objPosY = objPosY - cWorldPos[2]\n            objPosZ = objPosZ - cWorldPos[3]\n        end\n        local subObjs = obj.subObjects\n        if #subObjs > 0 then\n            for k = 1, #subObjs do\n                local subObj = subObjs[k]\n                if subObj.position ~= nil then\n                    recurse.subObjectMatrices(wwx,wwy,wwz,www,objPos[1],objPos[2],objPos[3],subObj,objPosX,objPosY,objPosZ)\n                end\n            end\n        end\n        modelMatrices[1] = {obj,{a2, -d2, -g2, objPosX,-b2, e2, h2, -objPosY,-c2, f2, i2, -objPosZ,0, 0, 0, 1}}\n        return modelMatrices\n    end\n\n    function self.getViewMatrix()\n        local multi = multiply\n        local solve = solve\n        \n        local board = getElementRotationById(unitId)\n        local ax,ay,az,aw = board[1],board[2],board[3],board[4]\n        \n        local body = getRelativeOrientation()\n        local bx,by,bz,bw = body[1],body[2],body[3],body[4]\n\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1,v2,v3,{1,0,0})\n        local v2t = solve(v1,v2,v3,{0,1,0})\n        local v3t = solve(v1,v2,v3,{0,0,1})\n        \n        local sx, sy, sz, sw = rotToQuat({v1t[1],v1t[2],v1t[3],0,v2t[1],v2t[2],v2t[3],0,v3t[1],v3t[2],v3t[3],0,0,0,0,1})\n        local lx, ly, lz, lw = rotToQuat({v1[1],v1[2],v1[3],0,v2[1],v2[2],v2[3],0,v3[1],v3[2],v3[3],0,0,0,0,1})\n\n        local eye = eye\n        local eyeX,eyeY,eyeZ = eye[1],eye[2],eye[3]\n        local dotX, dotY, dotZ = eyeX, eyeY, eyeZ\n        local wx, wy, wz, ww = 0,0,0,1\n        local s = sin\n        local c = cos\n        \n        local px, py, pz, pw = multi(ax, ay, az, aw, bx, by, bz, bw)\n        local alignment = getAlignmentType(px, py, pz, pw, eyeX, eyeY, eyeZ)\n        alignmentType = alignment\n        local pix, piy, piz, piw = inverse(px, py, pz, pw)\n        local shift = alignment.shift\n            \n        local eyeTX, eyeTY, eyeTZ, eyeTW = multi(px, py, pz, pw, shift[1], shift[2], shift[3], 0)\n        local eyeIX, eyeIY, eyeIZ, eyeIW = multi(eyeTX, eyeTY, eyeTZ, eyeTW, pix, piy, piz, piw)\n        \n        local alignName = alignment.name\n        local nFG=alignName~=\"fGlobal\"\n        local fG=alignName==\"fGlobal\"\n        local nFL=alignName~=\"fLocal\"\n        local fL=alignName==\"fLocal\"\n        local ori = cOrientation\n        local pitch,roll,heading = ori[1] / 2,0,ori[2] / 2,0\n        if pitch ~= 0 or heading ~= 0 or roll ~= 0 or fG or fL then\n            local sP,sH,sR = s(pitch),s(roll),s(heading)\n            local cP,cH,cR = c(pitch),c(roll),c(heading)\n            \n            local cx = sP*cH*cR - cP*sH*sR\n            local cy = -cP*sH*cR - sP*cH*sR\n            local cz = -cP*cH*sR + sP*sH*cR\n            local cw = cP*cH*cR + sP*sH*sR\n            if nFG and nFL then\n                px,py,pz,pw = multi(px,py,pz,pw,cx,cy,cz,cw)\n\n            elseif alignName == \"fGlobal\" then\n                wx,wy,wz,ww = cx,cy,cz,cw\n            else\n                wx,wy,wz,ww = multi(sx,sy,sz,sw,cx,cy,cz,cw)\n            end\n        end\n        \n        if nFG and nFL then\n            local pxpx,pxpy,pxpz,pxpw = px*px,px*py,px*pz,px*pw\n            local pypy,pypz,pypw = py*py,py*pz,py*pw\n            local pzpz,pzpw = pz*pz,pz*pw\n            \n            local a1 = 1 - 2*(pypy + pzpz)\n            local b1 = 2*(pxpy - pzpw)\n            local c1 = 2*(pxpz + pypw)\n    \n            local d1 = 2*(pxpy + pzpw)\n            local e1 = 1 - 2*(pxpx + pzpz)\n            local f1 = 2*(pypz - pxpw)\n    \n            local g1 = 2*(pxpz - pypw)\n            local h1 = 2*(pypz + pxpw)\n            local i1 = 1 - 2*(pxpx + pypy)\n            eyeX = eyeX - eyeIX\n            eyeY = eyeY + eyeIY\n            eyeZ = eyeZ + eyeIZ\n        \n            dotX = a1*eyeX + -d1*eyeY + -g1*eyeZ\n            dotY = -b1*eyeX + e1*eyeY + h1*eyeZ\n            dotZ = -c1*eyeX + f1*eyeY + i1*eyeZ\n            wx,wy,wz,ww = multi(sx,sy,sz,sw,px,py,pz,pw)\n        end\n        -- Camera rotation determination\n        --- Directly input euler angles in radians\n        \n        local wxwx,wxwy,wxwz,wxww = wx*wx,wx*wy,wx*wz,wx*ww\n        local wywy,wywz,wyww = wy*wy,wy*wz,wy*ww\n        local wzwz,wzww = wz*wz,wz*ww\n        \n        --- Matrix of camera rotations, using quaternions\n        local a2 = 1 - 2*(wywy + wzwz)\n        local b2 = 2*(wxwy - wzww)\n        local c2 = 2*(wxwz + wyww)\n    \n        local d2 = 2*(wxwy + wzww)\n        local e2 = 1 - 2*(wxwx + wzwz)\n        local f2 = 2*(wywz - wxww)\n    \n        local g2 = 2*(wxwz - wyww)\n        local h2 = 2*(wywz + wxww)\n        local i2 = 1 - 2*(wxwx + wywy)\n\n        return {a2, -d2, -g2, dotX,-b2, e2, h2, dotY,-c2, f2, i2, dotZ,0, 0, 0, 1}\n    end\n    \n    function self.getSVG()\n        local svg = {}\n        local c = 1\n        local view = self.getViewMatrix()\n\n        local vx1,vy1,vz1,vw1 = view[1],view[2],view[3],view[4]\n        local vx2,vy2,vz2,vw2 = view[5],view[6],view[7],view[8]\n        local vx3,vy3,vz3,vw3 = view[9],view[10],view[11],view[12]\n        \n        local getSize = self.getSize\n        \n        local function translate(x,y,z,mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n            local x,y,z = x,-y,-z\n            local px = mXX * x + mXY * y + mXZ * z + mXW\n            local py = mYX * x + mYY * y + mYZ * z + mYW\n            local pz = mZX * x + mZY * y + mZZ * z + mZW\n            local pw = -py\n                \n            -- Convert to window coordinates after W-Divide\n            local wx = (px / pw) * width\n            local wy = (pz / pw) * height\n            return wx, wy, pw\n        end\n        local function createCurve(svg,c,mx,my,cx1,cy1,cx2,cy2,ex,ey)\n            svg[c]='M'\n            svg[c+1]=mx\n            svg[c+2]=' '\n            svg[c+3]=my\n            svg[c+4]='C'\n            svg[c+5]=cx1\n            svg[c+6]=' '\n            svg[c+7]=cy1\n            svg[c+8]=','\n            svg[c+9]=cx2\n            svg[c+10]=' '\n            svg[c+11]=cy2\n            svg[c+12]=','\n            svg[c+13]=ex\n            svg[c+14]=' '\n            svg[c+15]=ey\n            return c+16\n        end\n        local function createLabel(svg,c,x,y,text,size,opacity,fill)\n            svg[c] = '<text x=\"'\n            svg[c+1] = x\n            svg[c+2] = '\" y=\"'\n            svg[c+3] = y\n            c=c+4\n            if opacity~=nil then\n                svg[c] = '\" fill-opacity=\"'\n                svg[c+1] = opacity\n                svg[c+2] = '\" stroke-opacity=\"'\n                svg[c+3] = opacity\n                c=c+4\n            end\n            if fill~=nil then\n                svg[c] = '\" fill=\"'\n                svg[c+1]=fill\n                c=c+2\n            end\n            if size~=nil then\n                svg[c] = '\" font-size=\"'\n                svg[c+1]=size\n                c=c+2\n            end\n            \n            svg[c] = '\">'\n            svg[c+1] = text\n            svg[c+2] = '</text>'\n            return c+3\n        end\n        -- Localize projection matrix values\n        local px1 = x0\n        local py2 = 1 --c0\n        local pz3 = y0\n        \n        -- Localize screen info\n        local width = width\n        local height = height\n\n        local objectGroups = objectGroups\n        for i = 1, #objectGroups do\n            local objectGroup = objectGroups[i]\n            if objectGroup.enabled == true then\n            local objGTransX = objectGroup.transX or width\n            local objGTransY = objectGroup.transY or height\n            local objects = objectGroup.objects\n            \n            svg[c] = [[<svg viewBox=\"0 0 ]]\n            svg[c+1] = width*2\n            svg[c+2] = [[ ]]\n            svg[c+3] = height*2\n            svg[c+4] = [[\" class=\"]]\n            svg[c+5] = objectGroup.style\n            svg[c+6] = '\"><g transform=\"translate('\n            svg[c+7] = objGTransX\n            svg[c+8] = ','\n            svg[c+9] = objGTransY\n            svg[c+10] = ')\">'\n            c=c+11\n            for m = 1, #objects do\n                local obj = objects[m]\n                if obj.position ~= nil then\n                local models = self.getModelMatrices(obj)\n                -- Localize model matrix values\n                for k = 1, #models do\n                    local modelObj = models[k]\n                    local object = modelObj[1]\n                    local model = modelObj[2]\n                    \n                    local objStyle = object.style\n                    local objTransX = object.transX or 0\n                    local objTransY = object.transY or 0\n                    \n                    svg[c] = '<g class=\"'\n                    svg[c+1] = objStyle\n                    c=c+2\n                    if objTransX ~= 0 or objTransY ~= 0 then\n                            svg[c] = '\" transform=\"translate('\n                            svg[c+1] = objTransX\n                            svg[c+2] = ','\n                            svg[c+3] = objTransY\n                            svg[c+4] = ')'\n                            c=c+5\n                    end\n                    svg[c] = '\">'\n                    c=c+1\n                    local mx1,my1,mz1,mw1 = model[1],model[2],model[3],model[4]\n                    local mx2,my2,mz2,mw2 = model[5],model[6],model[7],model[8]\n                    local mx3,my3,mz3,mw3 = model[9],model[10],model[11],model[12]\n                \n                    local mXX = px1*(vx1*mx1 + vy1*mx2 + vz1*mx3)\n                    local mXY = px1*(vx1*my1 + vy1*my2 + vz1*my3)\n                    local mXZ = px1*(vx1*mz1 + vy1*mz2 + vz1*mz3)\n                    local mXW = px1*(vw1 + vx1*mw1 + vy1*mw2 + vz1*mw3)\n        \n                    local mYX = (vx2*mx1 + vy2*mx2 + vz2*mx3)\n                    local mYY = (vx2*my1 + vy2*my2 + vz2*my3)\n                    local mYZ = (vx2*mz1 + vy2*mz2 + vz2*mz3)\n                    local mYW = (vw2 + vx2*mw1 + vy2*mw2 + vz2*mw3)\n        \n                    local mZX = pz3*(vx3*mx1 + vy3*mx2 + vz3*mx3)\n                    local mZY = pz3*(vx3*my1 + vy3*my2 + vz3*my3)\n                    local mZZ = pz3*(vx3*mz1 + vy3*mz2 + vz3*mz3)\n                    local mZW = pz3*(vw3 + vx3*mw1 + vy3*mw2 + vz3*mw3)\n                \n                    local polylineGroups = object.polylineGroups\n                    local circleGroups = object.circleGroups\n                    local curvesGroups = object.curveGroups\n                    local customGroups = object.customGroups\n            \n                    -- Polylines for-loop\n                    for d=1,#polylineGroups do\n                        local polylineGroup = polylineGroups[d]\n                        svg[c] = '<path class=\"'\n                        svg[c+1] = polylineGroup[1]\n                        svg[c+2] = '\" d=\"'\n                        c = c+3\n                        for f=2,#polylineGroup do\n                            local line = polylineGroup[f]\n                            svg[c] = 'M '\n                            local lC=0\n                            local sP={}\n                            local eP={}\n                            c=c+1\n                            for h = 1, #line do\n                                local p = line[h]\n                                local wx,wy,ww = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n\n                                -- If PW is negative, it means the point is behind you\n                                if ww > 0 then\n                                    if lC ~= 0 then\n                                        svg[c] = ' L '\n                                        c = c + 1\n                                        eP = {wx, wy}\n                                    else\n                                        sP = {wx, wy}\n                                    end\n                                    svg[c] = wx\n                                    svg[c+1] = ' '\n                                    svg[c+2] = wy\n                                    c=c+3\n                                    lC=lC+1\n                                end\n                            end\n                            if lC < 2 then\n                                if lC == 1 then\n                                    svg[c-4] = ''\n                                    svg[c-3] = ''\n                                    svg[c-2] = ''\n                                    svg[c-1] = ''\n                                    c=c-4\n                                else\n                                    svg[c-1] = ''\n                                    c=c-1\n                                end\n                            else\n                                if eP[1] == sP[1] and eP[2] == sP[2] then\n                                    svg[c-4] = ' Z '\n                                    svg[c-3] = ''\n                                    svg[c-2] = ''\n                                    svg[c-1] = ''\n                                    c=c-3\n                                end\n                            end\n                        end\n                        svg[c] = '\"/>'\n                        c=c+1\n                    end\n                    for cG=1,#circleGroups do\n                        local circleGroup = circleGroups[cG]\n                        svg[c] = '<g class=\"'\n                        svg[c+1] = circleGroup[1]\n                        svg[c+2] = '\">'\n                        c=c+3\n                        for l=2, #circleGroup do\n                            local cir = circleGroup[l]\n                            local p = cir[1]\n                            local wx,wy,wz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                            if wz > 0 then\n                                local radius,fill,label,offX,offY,size,resize,action = cir[2],cir[3],cir[4],cir[5],cir[6],cir[7],cir[8],cir[9]\n                                svg[c] = '<circle cx=\"'\n                                svg[c+1] = wx\n                                svg[c+2] = '\" cy=\"'\n                                svg[c+3] = wy\n                                svg[c+4] = '\" r=\"'\n                                svg[c+5] = radius\n                                svg[c+6] = '\" fill=\"'\n                                svg[c+7] = fill\n                                svg[c+8] = '\"/>'\n                                c = c+9\n                                if label ~= nil then\n                                    svg[c] = '<text x=\"'\n                                    svg[c+1] = wx + offX\n                                    svg[c+2] = '\" y=\"'\n                                    svg[c+3] = wy + offY\n                                    c=c+4\n                                    if size ~= nil then\n                                        if resize==true then\n                                           svg[c]='\" font-size=\"'\n                                           svg[c+1] = getSize(size, wz)\n                                        else\n                                           svg[c]='\" font-size=\"'\n                                           svg[c+1] = size\n                                        end\n                                        c=c+2\n                                    end\n                                    svg[c] = '\">'\n                                    svg[c+1] = label\n                                    svg[c+2] = '</text>'\n                                    c=c+3\n                                end\n                                if action ~= nil then\n                                    c = action(svg, c, object, wx, wy, wz)\n                                end\n                            end\n                        end\n                        svg[c] = '</g>'\n                        c=c+1\n                    end\n                    for cuG=1, #curvesGroups do\n                            local curveG = curvesGroups[cuG]\n                            svg[c] = '<g class=\"'\n                            svg[c+1] = curveG[1]\n                            svg[c+2] = '\">'\n                            c=c+3\n                            local curveG = curvesGroups[cuG]\n                            svg[c] = '<path d=\"'\n                            c=c+1\n                            local curves = curveG[2]\n                            local sLabelDat = {}\n                            local sLDC = 0\n                            for cCt=1, #curves do\n                                local curve = curves[cCt]\n                                if curve[1] == 'circle' then\n                                    local pts = curve[2]\n                                    local labelDat = curve[3]\n                                    local p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12 = pts[1],pts[2],pts[3],pts[4],pts[5],pts[6],pts[7],pts[8],pts[9],pts[10],pts[11],pts[12]\n                                    local m1x,m1y,m1z=translate(p1[1],p1[2],p1[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m2x,m2y,m2z=translate(p2[1],p2[2],p2[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m3x,m3y,m3z=translate(p3[1],p3[2],p3[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m4x,m4y,m4z=translate(p4[1],p4[2],p4[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    if m1z>0 and m2z>0 and m3z>0 and m4z>0 then\n                                            c=createCurve(svg,c,m1x,m1y,m2x,m2y,m3x,m3y,m4x,m4y)\n                                    end\n                                    local m5x,m5y,m5z=translate(p5[1],p5[2],p5[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m6x,m6y,m6z=translate(p6[1],p6[2],p6[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m7x,m7y,m7z=translate(p7[1],p7[2],p7[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    if m4z>0 and m5z>0 and m6z>0 and m7z>0 then\n                                            c=createCurve(svg,c,m4x,m4y,m5x,m5y,m6x,m6y,m7x,m7y)\n                                    end\n                                    local m8x,m8y,m8z=translate(p8[1],p8[2],p8[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m9x,m9y,m9z=translate(p9[1],p9[2],p9[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m10x,m10y,m10z=translate(p10[1],p10[2],p10[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    if m7z>0 and m8z>0 and m9z>0 and m10z>0 then\n                                            c=createCurve(svg,c,m7x,m7y,m8x,m8y,m9x,m9y,m10x,m10y)\n                                    end    \n                                    local m11x,m11y,m11z=translate(p11[1],p11[2],p11[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    local m12x,m12y,m12z=translate(p12[1],p12[2],p12[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                    if m10z>0 and m11z>0 and m12z>0 and m1z>0 then\n                                            c=createCurve(svg,c,m10x,m10y,m11x,m11y,m12x,m12y,m1x,m1y)\n                                    end\n                                    if labelDat[1]~=nil then\n                                            if m1z>0 and m4z>0 and m7z>0 and m10z>0 then\n                                                sLabelDat[sLDC+1]={\n                                                    {m1x,m1y,m1z},\n                                                    {m4x,m4y,m4z},\n                                                    {m7x,m7y,m7z},\n                                                    {m10x,m10y,m10z},\n                                                    labelDat\n                                                }\n                                                sLDC=sLDC+1\n                                            end\n                                    end\n                                else\n                                end\n                            end\n                            svg[c] = '\"/>'\n                            c=c+1\n                            if sLDC > 0 then\n                                for ll=1, sLDC do\n                                        local lInfo = sLabelDat[ll]\n                                        local p1,p2,p3,p4,dat = lInfo[1],lInfo[2],lInfo[3],lInfo[4],lInfo[5]\n                                        local s = dat[3]\n                                        local s1,s2,s3,s4 = s,s,s,s\n                                        local label = dat[1]\n                                        if dat[2] == true then\n                                            s1,s2,s3,s4 = getSize(s1, p1[3], 100, 1), getSize(s2, p2[3], 100, 1), getSize(s3, p3[3], 100, 1), getSize(s4, p4[3], 100, 1)\n                                        end\n                                        c=createLabel(svg,c,p1[1],p1[2],label,s1,nil,'white')\n                                        c=createLabel(svg,c,p2[1],p2[2],label,s2,nil,'white')\n                                        c=createLabel(svg,c,p3[1],p3[2],label,s3,nil,'white')\n                                        c=createLabel(svg,c,p4[1],p4[2],label,s4,nil,'white')\n                                end\n                            end\n                    end\n                    for cG = 1, #customGroups do\n                        local customGroup = customGroups[cG]\n                        local multiGroups = customGroup[2]\n                        local singleGroups = customGroup[3]\n                        svg[c] = '<g class=\"'\n                        svg[c+1] = customGroup[1]\n                        svg[c+2] = '\">'\n                        c = c+3\n                        for mGC = 1, #multiGroups do\n                            local multiGroup = multiGroups[mGC]\n                            local pts = multiGroup[1]\n                            local tPoints = {}\n                            local ct = 1\n                            for pC = 1, #pts do\n                                local p = pts[pC]\n                                local tx,ty,tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                                if tz > 0 then\n                                    tPoints[ct] = {tx,ty,tz}\n                                    ct = ct + 1\n                                end\n                            end\n                            if ct ~= 1 then\n                                local drawFunction = multiGroup[2]\n                                local data = multiGroup[3]\n                                c = drawFunction(svg, c, object, tPoints, data)\n                            end\n                        end\n                        for sGC = 1, #singleGroups do\n                            local singleGroup = singleGroups[sGC]\n                            local p = singleGroup[1]\n                            local tx, ty, tz = translate(p[1],p[2],p[3],mXX,mXY,mXZ,mXW,mYX,mYY,mYZ,mYW,mZX,mZY,mZZ,mZW)\n                            if tz > 0 then\n                                local drawFunction = singleGroup[2]\n                                local data = singleGroup[3]\n                                c = drawFunction(svg,c,object,tx,ty,tz,data)\n                            end\n                        end\n                        svg[c] = '</g>'\n                        c=c+1\n                    end\n                    svg[c] = '</g>'\n                    c=c+1\n                end\n                end\n            end\n            svg[c] = '</g></svg>'\n            c = c+1\n            end\n        end\n        return svg, c\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "4"
    },
    {
      "code": "positionTypes = {\n    globalP = \"global\",\n    localP = \"local\"\n}\norientationTypes = {\n    globalO = \"global\",\n    localO = \"local\" \n}\n\nfunction ObjectGroup(style, objects, transX, transY)\n\n    local objects = objects or {}\n    local self = {style = style, objects = objects, transX = transX, transY = transY, enabled = true}\n    function self.addObject(object, id)\n        local id = id or #objects + 1\n        objects[id] = object\n        return id\n    end\n    function self.removeObject(id)\n        objects[id] = {}\n    end\n    function self.hide()\n        self.enabled = false\n    end\n    function self.show()\n        self.enabled = true\n    end\n    return self\nend\n\nfunction Object(style, position, offset, orientation, positionType, orientationType, transX, transY)\n    local rad = math.rad\n    local print = system.print\n    \n    local position = position\n    local positionOffset = offset\n    local heading = rad(orientation[1])\n    local pitch = rad(orientation[2])\n    local roll = rad(orientation[3])\n    \n    local style = style\n    local polylineGroups = {}\n    local circleGroups = {}\n    local curveGroups = {}\n    local customGroups = {}\n    local subObjects = {}\n    local positionType = positionType\n    local orientationType = orientationType\n    \n    local self = {\n        polylineGroups = polylineGroups, \n        circleGroups = circleGroups, \n        curveGroups = curveGroups, \n        customGroups = customGroups,\n        subObjects = subObjects,\n        positionType = positionType,\n        orientationType = orientationType,\n        orientation = {pitch,heading,roll},\n        style = style,\n        position = position,\n        offset = offset,\n        transX,\n        transY\n    }\n    \n    function self.setPolylines(groupId, style, points, scale)\n        -- Polylines for-loop\n        local group = {style}\n        local scale = scale or 1\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        for i = 2, #points do\n            local line = points[i - 1]\n            local newPoints = {}\n            for k = 1, #line do\n                local point = line[k]\n                newPoints[k] = {(point[1]) / scale + offsetX, (point[2] / scale - offsetY), (point[3] / scale  - offsetZ)}\n            end\n            group[i] = newPoints\n        end\n        self.polylineGroups[groupId] = group\n    end\n    \n    function self.setCircles(groupId, style, scale)\n        local group = {\n            style\n        }\n        local scale = scale or 1\n        local c = 2\n        self.circleGroups[groupId] = group\n        local offset = offset or positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addCircle(position, radius, fill)\n            local self = {}\n            local position = {\n                (position[1] - offsetX) / scale,\n                (position[2] - offsetY) / scale, \n                (position[3] - offsetZ) / scale\n            }\n            local label = nil\n            local offX = nil\n            local offY = nil\n            local size = nil\n            local resize = false\n            local action = nil\n            function self.setLabel(lab, rs, s, ofX, ofY)\n                label = lab\n                offX = ofX or 0\n                offY = ofY or 0\n                size = s or 10\n                resize = rs or false\n                return self\n            end\n            function self.setActionFunction(actionFunction)\n                action = actionFunction\n                return self\n            end\n            function self.build()\n                local circleObj = {position,radius,fill,label,offX,offY,size,resize,actionFunction}\n                group[c] = circleObj\n                c = c + 1\n                return circleObj,c\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCurves(groupId, style, scale)\n        local scale = scale or 1\n        local curves = {}\n        local group = {\n            style,\n            curves\n        }\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        self.curveGroups[groupId] = group\n        local self = {}\n        local c = 1\n        function self.circleBuilder()\n            local self = {}\n            function self.createCircle(center, radius)\n                local k = 0.5522847498\n                local radius = radius / scale\n                local cX,cY,cZ = center[1]/scale+offsetX,center[2]/scale+offsetY, center[3]/scale+offsetZ\n                local cPoints = {\n                    {cX,radius+cY,cZ},\n                    {radius*k+cX,radius+cY,cZ},\n                    {radius+cX,radius*k+cY,cZ},\n                    {radius+cX,cY,cZ},\n                    {radius+cX,-radius*k+cY,cZ},\n                    {radius*k+cX,-radius+cY,cZ},\n                    {cX,-radius+cY,cZ},\n                    {-radius*k+cX,-radius+cY,cZ},\n                    {-radius+cX,-radius*k+cY,cZ},\n                    {-radius+cX,cY,cZ},\n                    {-radius+cX,radius*k+cY,cZ},\n                    {-radius*k+cX,radius+cY,cZ}\n                }\n                local resize = false\n                local size = 10\n                local labelDat = {nil,resize,size}\n                local self = {}\n                \n                function self.setLabel(label, resize, size)\n                    local resize = resize or false\n                    local size = size / 500 or 0.05\n                    labelDat = {label, resize, size}\n                    return self\n                end\n                function self.build()\n                    local persCircleArray = {'circle', cPoints, labelDat}\n                    curves[c]=persCircleArray\n                    c=c+1\n                    return persCircleArray, c\n                end\n                return self\n            end\n            return self\n        end\n        function self.bezierBuilder()\n            local self = {}\n            function self.createCurve(sP)\n            end\n            function self.addControlPoint(cP)\n            end\n            function self.addEndPoint(eP)\n            end\n            return self\n        end\n        return self\n    end\n\n    function self.setCustomSVGs(groupId, style, scale)\n        local multiPoint = {}\n        local singlePoint = {}\n        local group = {\n            style,\n            multiPoint,\n            singlePoint\n        }\n        local scale = scale or 1\n        local mC = 1\n        local sC = 1\n        self.customGroups[groupId] = group\n        local offset = positionOffset\n        local offsetX,offsetY,offsetZ = offset[1],offset[2],offset[3]\n        local self = {}\n        function self.addMultiPointSVG()\n            local points = {}\n            local data = nil\n            local drawFunction = nil\n            local self = {}\n            local pC = 1\n            function self.addPoint(point)\n                local point = point\n                points[pC] = {\n                    (point[1] + offsetX) / scale, \n                    (point[2] - offsetY) / scale, \n                    (point[3] - offsetZ) / scale\n                }\n                pC = pC + 1\n                return self\n            end\n            -- ! This function applies no processing !\n            function self.bulkSetPoints(bulk)\n                points = bulk\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.setDrawFunction(draw)\n                \n                drawFunction = draw\n                return self\n            end\n            function self.build()\n                if pC > 0 then\n                    if drawFunction ~= nil then\n                        multiPoint[mC] = {points, drawFunction, data}\n                        mC = mC + 1\n                        return points\n                    else\n                        print(\"WARNING! Malformed multi-point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        function self.addSinglePointSVG()\n            local point = nil\n            local drawFunction = nil\n            local data = nil\n            local self = {}\n            function self.setPosition(position)\n                point = {\n                    (position[1] + offsetX) / scale, \n                    (position[2] - offsetY) / scale, \n                    (position[3] - offsetZ) / scale\n                }\n                return self\n            end\n            function self.setDrawFunction(draw)\n                drawFunction = draw\n                return self\n            end\n            function self.setData(dat)\n                data = dat\n                return self\n            end\n            function self.build()\n                if point ~= nil then\n                    if drawFunction ~= nil then\n                        singlePoint[sC] = {point, drawFunction, data}\n                        sC = sC + 1\n                    else\n                        print(\"WARNING! Malformed single point build operation, no draw function specified. Ignoring.\")\n                    end\n                else\n                    print(\"WARNING! Malformed single point build operation, no point specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return self\n    end\n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setPosition(posX, posY, posZ)\n        self.position = {posX, posY, posZ}\n    end\n    \n    function self.addSubObject(object, id)\n        local id = id or #self.subObjects+1\n        self.subObjects[id] = object\n        return id\n    end\n    function self.removeSubObject(id)\n        self.subObjects[id] = {}\n    end\n    \n    function self.setSubObjects()\n        local self = {}\n        local c = 1\n        function self.addSubObject(object)\n            subObjects[c] = object\n            c = c + 1\n            return self\n        end\n        return self\n    end\n    \n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self = {}\n    function self.setStyle(style)\n        local self = {}\n        local style = style\n        function self.setPosition(pos)\n            local self = {}\n            local pos = pos\n            function self.setOffset(offset)\n                local self = {}\n                local offset = offset\n                function self.setOrientation(orientation)\n                    local self = {}\n                    local orientation = orientation\n                    function self.setPositionType(positionType)\n                        local self = {}\n                        local positionType = positionType\n                        function self.setOrientationType(orientationType)\n                            local self = {}\n                            local orientationType = orientationType\n                            local transX = nil\n                            local transY = nil\n                            function self.setTranslation(translateX, translateY)\n                                transX = translateX\n                                transY = translateY\n                                return self\n                            end\n                            function self.build()\n                                return Object(style, pos, offset, orientation, positionType, orientationType, transX, transY)\n                            end\n                            return self\n                        end\n                        return self\n                    end\n                    return self\n                end\n                return self\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "5"
    },
    {
      "code": "local rad = math.rad\ncameraTypes = {\n    fixed = {\n        fLocal = {\n            name = \"fLocal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        },\n        fGlobal = {\n            name = \"fGlobal\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.0}\n        }\n    },\n    player = {\n        jetpack = {\n            name = \"jetpack\",\n            pitchPos = nil,\n            pitchNeg = nil,\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.9}\n        },\n        planet = {\n            name = \"planet\",\n            pitchPos = rad(75),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        construct = {\n            name = \"construct\",\n            pitchPos = rad(75),\n            pitchNeg = rad(-75),\n            headingPos = nil,\n            headingNeg = nil,\n            shift = {0.0, 0.0, 0.85}\n        },\n        chair = {\n            firstPerson = {\n                mouseControlled = {\n                    name = \"chairfp_mouse\",\n                    pitchPos = nil,\n                    pitchNeg = nil,\n                    headingPos = nil,\n                    headingNeg = nil,\n                    shift = {-0.1, 0.0, 0.65}\n                },\n                freelook = {\n                    name = \"chairfp_free\",\n                    pitchPos = rad(75),\n                    pitchNeg = rad(-75),\n                    headingPos = rad(95),\n                    headingNeg = rad(-95),\n                    shift = {-0.1, 0.0, 0.65}\n                }\n            },\n            secondPerson = {\n                name = \"chairsp\",\n                pitchPos = 0,\n                pitchNeg = 0,\n                headingPos = 0,\n                headingNeg = 0,\n                shift = {0.0, 0.0, 0.0}\n            },\n            thirdPerson = {\n                name = \"chairtp\",\n                pitchPos = rad(84),\n                pitchNeg = rad(-89),\n                headingPos = nil,\n                headingNeg = nil,\n                shift = {0.0, 0.0, 0.0}\n            }\n        }\n    }\n}\n\nlocal hp = core.getHitPoints()\nlocal coreOffset = 16\nif hp > 10000 then\n    coreOffset = 128\nelseif hp > 1000 then\n    coreOffset = 64\nelseif hp > 150 then\n    coreOffset = 32\nend\n\nlocal function getChairPositions()\n    local elementList = core.getElementIdList()\n    local elementType = core.getElementTypeById\n    local elementPos = core.getElementPositionById\n    local coreOffset = coreOffset\n    local positionList = {}\n    local c = 1\n    for i = 1, #elementList do\n        local element = elementType(elementList[i])\n        if element == \"Gunner Module\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Command Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Wooden Chair\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        if element == \"Hovercraft Seat Controller\" then\n            local elementP = elementPos(elementList[i])\n            positionList[c] = {-(elementP[1] - coreOffset), elementP[2] - coreOffset, elementP[3] - coreOffset}\n            c = c + 1\n        end\n        -- Need to add more seat types here.\n    end\n    return positionList\nend\n\nfunction Camera(camType, position, orientation)\n    local core = core\n    local system = system\n    local unit = unit\n    local planetaryInfluence = unit.getClosestPlanetInfluence\n    \n    local isViewLocked = false\n    \n    local print = system.print\n    local chairs = getChairPositions()\n    local types = cameraTypes\n    local rad = math.rad\n    local abs = math.abs\n    local position = {-position[1], position[2], position[3]}\n    local self = {\n        cType = camType,\n        position = position, \n        orientation = {rad(orientation[1]), rad(orientation[2]), rad(orientation[3])},\n        isViewLocked = isViewLocked,\n        cameraShift\n    }\n    \n    \n    function self.rotateHeading(heading)\n        self.orientation[2] = self.orientation[2] + rad(heading)\n    end\n    \n    function self.rotatePitch(pitch)\n        self.orientation[1] = self.orientation[1] + rad(pitch)\n    end\n    \n    function self.rotateRoll(roll)\n        self.orientation[3] = self.orientation[3] + rad(roll)\n    end\n    \n    function self.setAlignmentType(alignmentType)\n        self.cType = alignmentType\n    end\n    \n    function self.setPosition(pos)\n        self.position = {-pos[1], pos[2], pos[3]}\n    end\n    \n    function self.setViewLock(isViewLocked)\n        self.isViewLocked = isViewLocked\n    end\n    \n    function self.getAlignmentType(ax, ay, az, aw, bodyX, bodyY, bodyZ)\n        local playerType = types.player\n        local alignmentType = playerType.construct\n        if self.cType.name == \"fLocal\" then\n            alignmentType = types.fixed.fLocal\n            return alignmentType\n        elseif self.cType.name == \"fGlobal\" then\n            alignmentType = types.fixed.fGlobal\n            return alignmentType\n        end\n        if ax ~= nil then\n            if ax > 0.001 or ax < -0.001 or ay > 0.001 or ay < -0.001 then\n                alignmentType = playerType.jetpack\n            end\n            if planetaryInfluence() > 0.85 then\n                alignmentType = playerType.planet\n            end\n        \n            local chairs = chairs\n            local bodyX = bodyX\n            local bodyY = bodyY\n            local bodyZ = bodyZ\n            local abs = abs\n            for i = 1, #chairs do\n                local chairPos = chairs[i]\n                local difX = abs(chairPos[1] - bodyX)\n                local difY = abs(chairPos[2] - bodyY)\n                local difZ = abs(chairPos[3] - bodyZ)\n\n                if difX < 0.4 and difY < 0.4 and difZ < 0.4 then\n                    local switch = switched % 3\n                    if switch == 0 then\n                        local fp = playerType.chair.firstPerson\n                        if self.isViewLocked then\n                            alignmentType = fp.mouseControlled\n                        else\n                            alignmentType = fp.freelook\n                        end\n                        return alignmentType\n                    elseif switch == 1 then\n                        alignmentType = playerType.chair.thirdPerson\n                        return alignmentType\n                    elseif switch == 2 then\n                        alignmentType = playerType.chair.secondPerson\n                        return alignmentType\n                    end\n                end\n            end\n        end\n        switched = 0\n        return alignmentType\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "6"
    },
    {
      "code": "function getManager()\n    local self = {}\n    \n    -- Misc function calls\n    local solve = library.systemResolution3\n    local getPWorldPos = system.getPlayerWorldPos\n    local sqrt = math.sqrt\n    local atan = math.atan\n    local asin = math.asin\n    \n    --- Core-based function calls\n    local getCWorldPos = core.getConstructWorldPos\n    local getCWorldOriR = core.getConstructWorldOrientationRight\n    local getCWorldOriF = core.getConstructWorldOrientationForward\n    local getCWorldOriU = core.getConstructWorldOrientationUp\n    local getElementPositionById = core.getElementPositionById\n    \n    local hp = core.getMaxHitPoints()\n    local cOff = 16\n    if hp > 10000 then\n        cOff = 128\n    elseif hp > 1000 then\n        cOff = 64\n    elseif hp > 150 then\n        cOff = 32\n    end\n\n    function self.getLocalToWorldConverter()\n        local v1 = getCWorldOriR()\n        local v2 = getCWorldOriF()\n        local v3 = getCWorldOriU()\n        local v1t = solve(v1, v2, v3, {1,0,0})\n        local v2t = solve(v1, v2, v3, {0,1,0})\n        local v3t = solve(v1, v2, v3, {0,0,1})\n        return function(cref)\n            return solve(v1t, v2t, v3t, cref)\n        end\n    end\n    function self.getWorldToLocalConverter()\n        local vc1 = getCWorldOriR()\n        local vc2 = getCWorldOriF()\n        local vc3 = getCWorldOriU()\n        return function(world)\n            return solve(vc1, vc2, vc3, world)\n        end\n    end\n\n    function self.getTrueWorldPos()\n        local cal = self.getLocalToWorldConverter()\n        local cWorldPos = getCWorldPos()\n        local pos = getElementPositionById(1)\n        local offsetPosition = {pos[1] - cOff, pos[2] - cOff, pos[3] - cOff}\n        local adj = cal(offsetPosition)\n        local adjPos = {cWorldPos[1] - adj[1], cWorldPos[2] - adj[2], cWorldPos[3] - adj[3]}\n        return adjPos\n    end\n\n    function self.getPlayerLocalPos(playerId)\n        local c = self.getWorldToLocalConverter()\n        local cWorldPos = self.getTrueWorldPos()\n        local pWorldPos = getPWorldPos(playerId)\n        local adjPos = c({pWorldPos[1] - cWorldPos[1], pWorldPos[2] - cWorldPos[2], pWorldPos[3] - cWorldPos[3]})\n        adjPos = {-adjPos[1], adjPos[2], adjPos[3]}\n        return adjPos\n    end\n\n    function self.rotationMatrixToQuaternion(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        \n        local t = m11 + m22 + m33\n        if t > 0 then\n            local s = 0.5 / sqrt(t + 1.0)\n            return (m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s\n        elseif m11 > m22 and m11 > m33 then\n            local s = 2.0 * sqrt(1.0 + m11 - m22 - m33)\n            return 0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s\n        elseif m22 > m33 then\n            local s = 2.0 * sqrt(1.0 + m22 - m11 - m33)\n            return (m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s\n        else\n            local s = 2.0 * sqrt(1.0 + m33 - m11 - m22)\n            return (m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s\n        end\n    end\n    \n    function self.rotationMatrixToEuler(rotM)\n        local m11,m21,m31 = rotM[1],rotM[5],rotM[9]\n        local m12,m22,m32 = rotM[2],rotM[6],rotM[10]\n        local m13,m23,m33 = rotM[3],rotM[7],rotM[11]\n        local y = 0\n        \n        if m13 >= 1 then\n            y = asin(1)\n        elseif m13 <=-1 then\n            y = asin(-1)\n        else\n            y = asin(m13)\n        end\n        if abs(m13) < 0.9999999 then\n            return {atan(-m23,m33), -y, -atan(-m12,m11)}\n        else\n            return {atan(m32, m22), -y, -0}\n        end\n    end\n    \n    function self.inverse(qX, qY, qZ, qW)\n        local mag = qX*qX + qY*qY + qZ*qZ + qW*qW\n        return -qX/mag, -qY/mag, -qZ/mag, qW/mag\n    end\n    \n    function self.multiply(ax, ay, az, aw, bx, by, bz, bw)\n        return ax*bw + aw*bx + ay*bz - az*by, ay*bw + aw*by + az*bx - ax*bz, az*bw + aw*bz + ax*by - ay*bx, aw*bw - ax*bx - ay*by - az*bz\n    end\n    \n    function self.divide(ax, ay, az, aw, bx, by, bz, bw)\n        local cx, cy, cz, cw = self.inverse(bx, by, bz, bw)\n        return self.multiply(ax, ay, az, aw, cx, cy, cz, cw)\n    end\n    \n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "7"
    },
    {
      "code": "function Waypoint(x,y,z, radius, name, subId)\n    local sqrt,ceil,floor,max=math.sqrt,math.ceil,math.floor,math.max\n    local function round(value, precision)\n        local value = value/precision\n        local value = value >= 0 and floor(value+0.5) or ceil(value-0.5)\n        return value * precision\n    end\n    \n    local getCWorldPos,getCMass = core.getConstructWorldPos,core.getConstructMass\n    \n    local keyframe = 0\n    local self = {\n        radius = radius,\n        x = x,\n        y = y,\n        z = z,\n        name = name,\n        subId = subId,\n        keyframe = keyframe\n    }\n    \n    function self.getWaypointInfo()\n        local tons = getCMass() / 1000\n        local cPos = getCWorldPos()\n        local px,py,pz = self.x-cPos[1], self.y-cPos[2], self.z-cPos[3]\n        local distance = sqrt(px*px + py*py + pz*pz)\n        local warpCost = max(floor(tons*floor(((distance/1000)/200))*0.00024), 1)\n        local name = self.name\n        \n        return name, round((distance/1000)/200, 0.01), warpCost,round((distance/1000), 0.01),round(distance, 0.01)\n    end\n    return self\nend",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": "-3"
      },
      "key": "8"
    }
  ],
  "methods": [],
  "events": []
}